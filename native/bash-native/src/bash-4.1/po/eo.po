# -*- eval: (po-consider-source-path "../builtins/"); -*-
# Esperanto language file for GNU Bash.
# Copyright (C) 1996 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Sergio Pokrovskij <sergio.pokrovskij@gmail.com>, 1998, 2006, 2009.
#
# Stilaj notoj:
# Angulaj citiloj limigas «plurajn vortojn»,
# 99-66 estas la citiloj de „unuvortaĵo‟
#
# La mesaĝojn pri internaj eraroj (markitaj per XXX) probable malnecesas
# traduki.
#
# Glosaro:
# callback	retrovoko
# to force	... pre superforto
# granted 	jesigita
# here-document	tuj-dokumento	(info "(bash)Redirections")
msgid ""
msgstr ""
"Project-Id-Version: GNU bash 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-12-30 08:25-0500\n"
"PO-Revision-Date: 2009-06-01 00:31+0600\n"
"Last-Translator: Sergio Pokrovskij <sergio.pokrovskij@gmail.com>\n"
"Language-Team: Esperanto <translation-team-eo@lists.sourceforge.net>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:50
msgid "bad array subscript"
msgstr "Misa tabel-indico"

#: arrayfunc.c:313 builtins/declare.def:481
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: Maleblas konverti pozician tabelon en asocitabelon"

#: arrayfunc.c:480
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: Misa asocitabela ŝlosilo"

#: arrayfunc.c:482
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: Valorizato havu nombran indicon"

#: arrayfunc.c:518
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: Valorizante per asocitabelo uzu indicon"

#: bashhist.c:383
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: Ne prosperis krei: %s"

# XXX: internal_error
#: bashline.c:3457
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr "bash_execute_unix_command: Mankas klavartabelo por komando"

#: bashline.c:3543
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: La unua ne-blankspaca signo ne estas „\"‟"

#: bashline.c:3572
#, c-format
msgid "no closing `%c' in %s"
msgstr "Mankas ferma „%c‟ en %s"

#: bashline.c:3606
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: Mankas disiga dupunkto"

#: builtins/alias.def:132
#, fuzzy, c-format
msgid "`%s': invalid alias name"
msgstr "„%s‟: Misa nomo por klavartabelo"

#: builtins/bind.def:120 builtins/bind.def:123
msgid "line editing not enabled"
msgstr "liniredaktado ne estas ebligita"

#: builtins/bind.def:206
#, c-format
msgid "`%s': invalid keymap name"
msgstr "„%s‟: Misa nomo por klavartabelo"

#: builtins/bind.def:245
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: Ne eblas legi: %s"

#: builtins/bind.def:260
#, c-format
msgid "`%s': cannot unbind"
msgstr "%s: Ne eblas malligi"

#: builtins/bind.def:295 builtins/bind.def:325
#, c-format
msgid "`%s': unknown function name"
msgstr "%s: Nekonata funkcinomo"

#: builtins/bind.def:303
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s malhavas klavligon\n"

#: builtins/bind.def:307
#, c-format
msgid "%s can be invoked via "
msgstr "%s vokeblas per "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "iteracinombrilo"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "Sencas nur en iteracio „for‟, „while‟ aŭ „until‟"

#: builtins/caller.def:133
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""
"Liveras la kuntekston de la kuranta procedurvoko.\n"
"\n"
"  Sen ESPR liveras "

#: builtins/caller.def:135
msgid ""
".  With EXPR, returns\n"
"    "
msgstr ""

#: builtins/caller.def:136
msgid ""
"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""

#: builtins/cd.def:215
msgid "HOME not set"
msgstr "HOME malhavas valoron"

#: builtins/cd.def:227
msgid "OLDPWD not set"
msgstr "OLDPWD malhavas valoron"

#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "linio %dª: "

#: builtins/common.c:139 error.c:261
#, c-format
msgid "warning: "
msgstr "Averto: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: Uzmaniero: "

#: builtins/common.c:166 test.c:827
msgid "too many arguments"
msgstr "Tro multe da argumentoj"

#: builtins/common.c:191 shell.c:499 shell.c:782
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: La opcio bezonas argumenton"

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: Necesas nombra argumento"

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: Ne trovita"

#: builtins/common.c:214 shell.c:795
#, c-format
msgid "%s: invalid option"
msgstr "%s: Misa opcio"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: Misa opcinomo"

#: builtins/common.c:228 general.c:231 general.c:236
#, c-format
msgid "`%s': not a valid identifier"
msgstr "„%s‟ ne estas taŭga nomo"

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "Misa okuma nombro"

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "Misa 16uma nombro"

#: builtins/common.c:242 expr.c:1256
msgid "invalid number"
msgstr "Misa nombro"

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: Misa signalindiko"

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "„%s‟: Nek proceznumero, nek taŭga laborindiko"

#: builtins/common.c:264 error.c:454
#, c-format
msgid "%s: readonly variable"
msgstr "%s: Nurlega variablo"

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s estas ekster sia variejo"

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "argumento"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s estas ekster sia variejo"

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: Ne estas tia laboro"

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: Ĉi tiu ŝelo ne disponigas laborregadon"

#: builtins/common.c:292
msgid "no job control"
msgstr "Laborregado ne disponeblas"

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: Limigita"

#: builtins/common.c:304
msgid "restricted"
msgstr "limigita"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "„%s‟ ne estas primitiva komando ŝela"

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "Eraro ĉe skribo: %s"

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "Eraro ĉe agordado de terminalaj atributoj: %s"

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "Eraro ĉe akiro de terminalaj atributoj: %s"

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: Eraro ĉe provo determini la kurantan dosierujon: %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: Ambigua laborindiko"

#: builtins/complete.def:276
#, c-format
msgid "%s: invalid action name"
msgstr "%s: Misa nomo de ago"

#: builtins/complete.def:449 builtins/complete.def:644
#: builtins/complete.def:853
#, c-format
msgid "%s: no completion specification"
msgstr "%s: Kompletigo ne estas specifita"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "Averto: La opcio -F povas funkcii alie ol vi eble supozas"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "Averto: La opcio -C povas funkcii alie ol vi eble supozas"

#: builtins/complete.def:826
msgid "not currently executing completion function"
msgstr "Ni ne estas en plenumado de kompletiga funkcio"

#: builtins/declare.def:122
msgid "can only be used in a function"
msgstr "Uzeblas nur ene de funkcio"

#: builtins/declare.def:360
msgid "cannot use `-f' to make functions"
msgstr "„-f‟ ne estas uzebla por fari funkciojn"

#: builtins/declare.def:372 execute_cmd.c:4937
#, c-format
msgid "%s: readonly function"
msgstr "%s: Nurlega funkcio"

#: builtins/declare.def:468
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "$%s: ĉi tiel ne eblas neniigi variablojn"

#: builtins/declare.def:475
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: Ne eblas konverti asocitabelon en pozician tabelon"

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr "Rultempa ŝargo ne disponeblas"

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "Ne malfermiĝis dinamika biblioteko %s: %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "Mankas %s en la dinamika biblioteko%s: %s"

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: Ne ŝargita dinamike"

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: Ne eblas forigi: %s"

#: builtins/evalfile.c:134 builtins/hash.def:169 execute_cmd.c:4794
#: shell.c:1452
#, c-format
msgid "%s: is a directory"
msgstr "%s estas dosierujo"

#: builtins/evalfile.c:139
#, c-format
msgid "%s: not a regular file"
msgstr "%s: Ne ordinara dosiero"

#: builtins/evalfile.c:147
#, c-format
msgid "%s: file is too large"
msgstr "%s: Tro granda dosiero"

#: builtins/evalfile.c:185 builtins/evalfile.c:203 execute_cmd.c:4864
#: shell.c:1462
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: Neplenumebla duuma dosiero"

#: builtins/exec.def:212
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: Maleblas plenumi: %s"

#: builtins/exit.def:65
#, c-format
msgid "logout\n"
msgstr "adiaŭ\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "La ŝelo ne estas saluta; eliru per «exit»"

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Restas haltigitaj laboroj.\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "Restas rulataj laboroj.\n"

#: builtins/fc.def:262
msgid "no command found"
msgstr "Komando ne trovita"

#: builtins/fc.def:349
msgid "history specification"
msgstr "Historia indiko"

#: builtins/fc.def:370
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: Ne malfermiĝis labordosiero: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr "kuranta"

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "La laboro %d estas lanĉita sen laborregado"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: Misa opcio -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: La opcio bezonas argumenton -- %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr "Nomkonservado (haketado, «hashing») estas malŝaltita"

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: Hakettabelo estas malplena\n"

#: builtins/hash.def:244
#, c-format
msgid "hits\tcommand\n"
msgstr "Trafoj\tKomando\n"

# ZZZ: aĉaj citiloj (fermita en la programo)
#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Ŝelaj komandoj kongruaj kun la ŝlosilvorto '"
msgstr[1] "Ŝelaj komandoj kongruaj kun la ŝlosilvortoj '"

#: builtins/help.def:168
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"Helpaĵo pri „%s‟ malestas.\n"
"Provu «help help» aŭ «man -k %s» aŭ «info %s»."

#: builtins/help.def:185
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: Fiaskis malfermo de %s"

#: builtins/help.def:337
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Jenaj komandoj estas enkonstruitaj.  Tajpu „help‟ por eligi la liston.\n"
"Tajpu «help NOMO» por informoj pri la funkcio NOMO.\n"
"Uzu «info bash» por la ĝenerala informo pri la ŝelo.\n"
"Uzu «man -k» aŭ «info» por informo pri komandoj ĉi tie ne listigitaj.\n"
"\n"
"Steleto (*) tuj post nomo indikas, ke la komando estas malebligita.\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr "Ne pli ol unu el -anrw estas uzebla"

#: builtins/history.def:186
msgid "history position"
msgstr "pozicio en la historio"

#: builtins/history.def:365
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: Historia malvolvo fiaskis"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: inlib fiaskis"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "La uzo de „-x‟ malebligas aliajn opciojn"

#: builtins/kill.def:200
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: Argumento estu proceznumero aŭ laborindiko"

#: builtins/kill.def:263
msgid "Unknown error"
msgstr "Nekonata eraro"

#: builtins/let.def:95 builtins/let.def:120 expr.c:501 expr.c:516
msgid "expression expected"
msgstr "Mankas esprimo"

#: builtins/mapfile.def:165
#, fuzzy, c-format
msgid "%s: not an indexed array"
msgstr "%s: Ne tabela variablo"

#: builtins/mapfile.def:249 builtins/read.def:279
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: Misa indiko de dosiernumero"

#: builtins/mapfile.def:257 builtins/read.def:286
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: Misa dosiernumero: %s"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: Misa lininombro"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: Misa tabelbazo"

# Supozeble callback => retrovoko ??
#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: Misa kvanto ĉe retrovoko"

#: builtins/mapfile.def:326
msgid "empty array variable name"
msgstr "Mankas nomo de tabelvariablo"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "necesas subteno de tabelvariabloj"

#: builtins/printf.def:374
#, c-format
msgid "`%s': missing format character"
msgstr "„%s‟: Mankas formata signo"

#: builtins/printf.def:551
#, c-format
msgid "`%c': invalid format character"
msgstr "„%c‟: Misa signo formata"

#: builtins/printf.def:578
#, c-format
msgid "warning: %s: %s"
msgstr "Averto: %s: %s"

#: builtins/printf.def:757
msgid "missing hex digit for \\x"
msgstr "Mankas 16uma cifero por \\x"

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "Ne estas alia dosierujo"

#: builtins/pushd.def:462
msgid "<no current directory>"
msgstr "<mankas kuranta dosierujo>"

#: builtins/pushd.def:506
msgid "directory stack empty"
msgstr "Dosierujstako malplenas"

#: builtins/pushd.def:508
msgid "directory stack index"
msgstr "indico de dosierujstako"

# dirs [-clpv] [+N] [-N]
#: builtins/pushd.def:683
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Listigu la kurantan dosierujstakon. La dosierujoj trafas en\n"
"    la stakon per la komando „pushd‟ kaj estas forigeblaj per la\n"
"    komando „popd‟.\n"
"\n"
"    Opcioj:\n"
"    -c\tforviŝu la dosierujstakon (forigu ĉiujn erojn)\n"
"    -l\tne uzu tildon en la dosierujnomoj bazitaj relative\n"
"      \tal via hejma dosierujo\n"
"    -p\teligu dosierujstakon lokante po unu eron sur linio\n"
"    -v\teligu dosierujstakon lokante po unu eron sur linio,\n"
"\tprefiksante la dosierujnomon per ĝia numero en la stako\n"
"\n"
"    Argumentoj:\n"
"    +N\teligu la Nan eron nombrante de maldekstre en la listo eligebla\n"
"\tper „dirs‟ sen opcioj, numerante ekde 0.\n"
"\n"
"    -N\teligu la Nan eron nombrante de dekstre en la listo eligebla\n"
"\tper „dirs‟ sen opcioj, numerante ekde 0."

# pushd [dir | +N | -N] [-n]
#: builtins/pushd.def:705
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Surstakigu dosierujon sur la stakon da dosierujoj, aŭ cikle ŝovu\n"
"    la stakon tiel, ke la nova stakpinto iĝu la kuranta dosierujo.\n"
"    Senargumente, permutu la du plej suprajn dosierujojn de la stako.\n"
"\n"
"    Opcioj:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon surstakigante dosierujon sur\n"
"    \tla stakon; do, nur la stakon ŝanĝu.\n"
"\n"
"    +N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tmaldekstre en la listo eligebla per „dirs‟, numerante de 0)\n"
"        iĝu la pinta.\n"
"\n"
"    -N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tdekstre en la listo eligebla per „dirs‟, numerante de 0) iĝu\n"
"        la pinta.\n"
"\n"
"    dir\tsurstakigu la dosierujon dir kaj faru ĝin la nova kuranta\n"
"    \tdosierujo labora.\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟."

# popd [+N | -N] [-n]
#: builtins/pushd.def:730
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Elstakigu erojn el la stako de dosierujoj.  Senargumente, forigu la\n"
"    pintan dosierujon kaj iru (cd) en la novan pintan dosierujon.\n"
"\n"
"\n"
"    Opcioj:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon demetante dosierujon el la\n"
"\tstako; do, nur la stakon ŝanĝu.\n"
"\n"
"    Argumentoj:\n"
"    +N\tforigu la Nan eron de maldekstre de la listo eligebla per\n"
"\t„dirs‟, numerante ekde 0.  Ekz-e: «popd +0» forigas la plej\n"
"\tmaldekstran dosierujon; «popd +1», ĝian najbaron.\n"
"\n"
"    -N\tforigu la Nan eron de dekstre de la listo eligebla per „dirs‟,\n"
"\tnumerante ekde 0.  Ekz-e: «popd -0» forigas la lastan\n"
"\tdosierujon; «popd -1», la antaŭlastan.\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟."

#: builtins/read.def:252
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: Misa indiko de atendotempo"

#: builtins/read.def:588
#, c-format
msgid "read error: %d: %s"
msgstr "Lega (read) eraro: %d: %s"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr ""
"„return‟ sencas nur en funkcio aŭ punkte vokita („.‟, „source‟) skripto"

#: builtins/set.def:768
msgid "cannot simultaneously unset a function and a variable"
msgstr "Ne eblas samtempe malaktivigi funkcion kaj variablon"

#: builtins/set.def:805
#, c-format
msgid "%s: cannot unset"
msgstr "%s: Malaktivigo fiaskis"

#: builtins/set.def:812
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: Malaktivigo fiaskis: nurlega %s"

#: builtins/set.def:823
#, c-format
msgid "%s: not an array variable"
msgstr "%s: Ne tabela variablo"

#: builtins/setattr.def:186
#, c-format
msgid "%s: not a function"
msgstr "%s: Ne funkcio"

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr "Nombrilo de „shift‟"

#: builtins/shopt.def:260
msgid "cannot set and unset shell options simultaneously"
msgstr "Maleblas samtempe ŝalti kaj malŝalti ŝelan opcion"

#: builtins/shopt.def:325
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: Misa nomo de ŝela opcio"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "Necesas dosiernoma argumento"

#: builtins/source.def:153
#, c-format
msgid "%s: file not found"
msgstr "%s: Dosiero ne trovita"

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr "Ne eblas halteti"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "Ne eblas haltetigi salutan ŝelon"

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "„%s‟ alinomas jenon: «%s»\n"

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr "„%s‟ estas ŝlosilvorto de la ŝelo\n"

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s estas funkcio\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr "„%s‟ estas primitiva komando de la ŝelo\n"

#: builtins/type.def:317 builtins/type.def:391
#, c-format
msgid "%s is %s\n"
msgstr "„%s‟ estas „%s‟\n"

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "„%s‟ estas metita en hakettabelon (%s)\n"

#: builtins/ulimit.def:372
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: Maltaŭga argumento por limo"

#: builtins/ulimit.def:398
#, c-format
msgid "`%c': bad command"
msgstr "„%c‟: Misa komando"

#: builtins/ulimit.def:427
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: Fiaskis provo legi limon: %s"

#: builtins/ulimit.def:453
msgid "limit"
msgstr "limo"

#: builtins/ulimit.def:465 builtins/ulimit.def:765
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: Malprosperis ŝanĝi limon: %s"

#: builtins/umask.def:118
msgid "octal number"
msgstr "Okuma nombro"

# Misa modifilo: «umask Z-w» aŭ «umask aZw»
#: builtins/umask.def:231
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "„%c‟: Maltaŭga simbolo por atingorajta modifilo"

# Misa kategorio: ne [rw] ktp
#: builtins/umask.def:286
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "„%c‟: La signo ne estas simbolo de atingorajta kategorio"

#: error.c:90 error.c:321 error.c:323 error.c:325
msgid " line "
msgstr " linio "

#: error.c:165
#, c-format
msgid "last command: %s\n"
msgstr "La ĵusa komando: %s\n"

#: error.c:173
#, c-format
msgid "Aborting..."
msgstr "Ĉesigado ..."

#: error.c:406
msgid "unknown command error"
msgstr "Nekonata komand-eraro"

#: error.c:407
msgid "bad command type"
msgstr "Misa komandotipo"

#: error.c:408
msgid "bad connector"
msgstr "Misa stir-operacio"

#: error.c:409
msgid "bad jump"
msgstr "Misa salto"

#: error.c:447
#, c-format
msgid "%s: unbound variable"
msgstr "%s: Neligita variablo"

#: eval.c:181
#, c-format
msgid "timed out waiting for input: auto-logout\n"
msgstr "Tro longe sen enigo: Aŭtomata seancofino\n"

# XXX: internal error:
#: execute_cmd.c:497
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "Fiaskis provo nomumi la disponaĵon «/dev/null» ĉefenigujo: %s"

# XXX: internal error:
#: execute_cmd.c:1162
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: „%c‟: Misa formatsigno"

#: execute_cmd.c:2075
msgid "pipe error"
msgstr "Eraro en dukto"

#: execute_cmd.c:4481
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: Malpermesitas uzi „/‟ en komandonomoj"

#: execute_cmd.c:4572
#, c-format
msgid "%s: command not found"
msgstr "%s: Komando ne trovita"

#: execute_cmd.c:4827
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: Misa interpretilo"

#: execute_cmd.c:4976
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "Ne eblas kunnomumi al dosiernumero %d la dosiernumeron %d"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "Tro profunda rekursio en esprimo"

#: expr.c:265
msgid "recursion stack underflow"
msgstr "Rekursistako elĉerpita"

#: expr.c:379
msgid "syntax error in expression"
msgstr "Sintaksa eraro en esprimo"

#: expr.c:419
msgid "attempted assignment to non-variable"
msgstr "Provo valorizi ne-variablon"

#: expr.c:440 expr.c:445 expr.c:756
msgid "division by 0"
msgstr "Divido per 0"

#: expr.c:471
msgid "bug: bad expassign token"
msgstr "CIMO: Misa operacisigno en kombinita valorizsimbolo"

#: expr.c:513
msgid "`:' expected for conditional expression"
msgstr "„:‟ mankas kondiĉa esprimo"

#: expr.c:781
msgid "exponent less than 0"
msgstr "Negativa eksponento"

#: expr.c:826
msgid "identifier expected after pre-increment or pre-decrement"
msgstr "Post antaŭkremento aperu nomo de variablo"

#: expr.c:854
msgid "missing `)'"
msgstr "Mankas „)‟"

#: expr.c:897 expr.c:1176
msgid "syntax error: operand expected"
msgstr "Sintaksa eraro: Mankas operando"

#: expr.c:1178
msgid "syntax error: invalid arithmetic operator"
msgstr "Sintaksa eraro: Misa operacisimbolo aritmetika"

#: expr.c:1202
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (misa simbolo estas „%s‟)"

#: expr.c:1260
msgid "invalid arithmetic base"
msgstr "Maltaŭga bazo nombrosistema"

#: expr.c:1280
msgid "value too great for base"
msgstr "Tro granda valoro por bazo de nombrosistemo"

#: expr.c:1329
#, c-format
msgid "%s: expression error\n"
msgstr "%s: Misa esprimo\n"

#: general.c:61
msgid "getcwd: cannot access parent directories"
msgstr "getwd: Ne eblas atingi patrajn dosierujojn"

#: input.c:94 subst.c:4857
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "Ne eblas reŝalti senprokrastan reĝimon por dosiernumero %d"

#: input.c:258
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr "Maleblas disponigi novan dosiernumeron por Baŝa enigo el n-ro %d"

#: input.c:266
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr "save_bash_input: La nova dosiernumero (fd %d) jam havas bufron"

# ZZZ: sys_error (_("start_pipeline: pgrp pipe"));
#: jobs.c:466
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: procezgrupo dukto"

#: jobs.c:887
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "Forke farita proceznumero %d aperas en rulata laboro %d"

#: jobs.c:1005
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "Haltigita laboro %d kun procezgrupo %ld estas forigata"

# ifdef DEBUG ... internal_warning():
#: jobs.c:1110
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr "add_process: process %5ld (%s) in the_pipeline"

# ifdef DEBUG ... internal_warning():
#: jobs.c:1113
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) marked as still alive"

#: jobs.c:1401
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: Ne estas tia proceznumero (%ld)!"

#: jobs.c:1416
#, c-format
msgid "Signal %d"
msgstr "Signalo %d"

#: jobs.c:1430 jobs.c:1455
msgid "Done"
msgstr "Farite"

#: jobs.c:1435 siglist.c:123
msgid "Stopped"
msgstr "Haltigita"

#: jobs.c:1439
#, c-format
msgid "Stopped(%s)"
msgstr "Haltigita(%s)"

#: jobs.c:1443
msgid "Running"
msgstr "Rulata"

#: jobs.c:1457
#, c-format
msgid "Done(%d)"
msgstr "Farite(%d)"

#: jobs.c:1459
#, c-format
msgid "Exit %d"
msgstr "Eliro %d"

#: jobs.c:1462
msgid "Unknown status"
msgstr "Nekonata stato"

#: jobs.c:1549
#, c-format
msgid "(core dumped) "
msgstr "(nekropsio elŝutita)"

#: jobs.c:1568
#, c-format
msgid "  (wd: %s)"
msgstr "  (labordosierujo: %s)"

#: jobs.c:1776
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "provo atribui (setpgid) procezgrupon %2$ld de la procezido %1$ld"

#: jobs.c:2104 nojobs.c:585
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: La procezo %ld ne estas ido de ĉi tiu ŝelo"

#: jobs.c:2331
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: Malestas informoj pri procezo %ld"

#: jobs.c:2607
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: La laboro %d estas haltigita"

#: jobs.c:2829
#, c-format
msgid "%s: job has terminated"
msgstr "%s: La laboro finiĝis"

#: jobs.c:2838
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: La laboro %d jam estas fona"

#: jobs.c:3059
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

#: jobs.c:3508
#, c-format
msgid "%s: line %d: "
msgstr "%s: linio %dª: "

#: jobs.c:3522 nojobs.c:814
#, c-format
msgid " (core dumped)"
msgstr "(nekropsio elŝutita)"

#: jobs.c:3534 jobs.c:3547
#, c-format
msgid "(wd now: %s)\n"
msgstr "(nun labordosierujo estas: %s)\n"

#: jobs.c:3579
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_job_control: getpgrp fiaskis"

#: jobs.c:3639
msgid "initialize_job_control: line discipline"
msgstr "initialize_job_control: liniaranĝo"

#: jobs.c:3649
msgid "initialize_job_control: setpgid"
msgstr "initialize_job_control: setpgid()"

#: jobs.c:3677
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "ne prosperis atribui grupon (%d) de terminala procezo"

#: jobs.c:3682
msgid "no job control in this shell"
msgstr "Ĉi tiu ŝelo ne disponigas laborregadon"

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: Malveras la aserto: %s\n"

# XXX: debug?
#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: aserto sufokita\r\n"

# XXX: internal error
#: lib/malloc/malloc.c:313
msgid "unknown"
msgstr "nekonata"

# XXX: debug?
#: lib/malloc/malloc.c:797
msgid "malloc: block on free list clobbered"
msgstr "malloc: Skribdifektita bloko en malokupa listo (free list)"

# XXX: debug?
#: lib/malloc/malloc.c:874
msgid "free: called with already freed block argument"
msgstr "free: La argumento montras blokon jam malokupitan"

# XXX: debug?
#: lib/malloc/malloc.c:877
msgid "free: called with unallocated block argument"
msgstr "free: La argumento ne montras generitan memoron"

# XXX: debug?
#: lib/malloc/malloc.c:896
msgid "free: underflow detected; mh_nbytes out of range"
msgstr "free: Okazis maltroo; mh_nbytes estas ekster sia variejo"

# XXX: debug?
#: lib/malloc/malloc.c:902
msgid "free: start and end chunk sizes differ"
msgstr "free: La ĉapa kaj vosta longoj de memorpeco ne estas egalaj"

# XXX: debug?
#: lib/malloc/malloc.c:1001
msgid "realloc: called with unallocated block argument"
msgstr "realloc: La argumento ne montras generitan memoron"

# XXX: debug?
#: lib/malloc/malloc.c:1016
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr "realloc: Okazis maltroo; mh_nbytes estas ekster sia variejo"

# XXX: debug?
#: lib/malloc/malloc.c:1022
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: La ĉapa kaj vosta longoj de memorpeco ne estas egalaj"

# XXX: debug?
#: lib/malloc/table.c:177
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: „alloc‟-tabelo elĉerpiĝis je FIND_ALLOC?\n"

# XXX: debug?
#: lib/malloc/table.c:184
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: %p jam en la tabelo kvazaŭ kreita (?)\n"

# XXX: debug?
#: lib/malloc/table.c:220
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: %p jam en la tabelo kvazaŭ malokupita (?)\n"

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr "Misa bazo nombrosistema"

# XXX: internal error
#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: Nekonata retnodo"

#  XXX: internal error
#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: Misa servo-indiko"

# XXX: internal error
#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: Misa retvojo-indiko"

# XXX: internal error
#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "Reta funkciado ne disponeblas"

#: locale.c:192
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr ""

#: locale.c:194
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr ""

# XXX: fatal_error
#: locale.c:247
#, fuzzy, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "xrealloc: %s:%d: ne eblas reokupi %lu bajtojn"

# XXX: fatal_error
#: locale.c:249
#, fuzzy, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "xrealloc: %s:%d: ne eblas reokupi %lu bajtojn"

#: mailcheck.c:433
msgid "You have mail in $_"
msgstr "Vi havas poŝton en $_"

#: mailcheck.c:458
msgid "You have new mail in $_"
msgstr "Nova poŝto en $_"

#: mailcheck.c:474
#, c-format
msgid "The mail in %s has been read\n"
msgstr "La poŝto en %s estas jam legita\n"

#: make_cmd.c:323
msgid "syntax error: arithmetic expression required"
msgstr "Sintaksa eraro: Necesas aritmetika esprimo"

#: make_cmd.c:325
msgid "syntax error: `;' unexpected"
msgstr "Sintaksa eraro: Neatendita „;‟"

#: make_cmd.c:326
#, c-format
msgid "syntax error: `((%s))'"
msgstr "Sintaksa eraro: „((%s))‟"

#: make_cmd.c:575
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: Misa ordontipo %d"

# internal_warning():
#: make_cmd.c:659
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr "Tuj-dokumenton de linio %d limigas dosierfino (mankas „%s‟)"

# XXX: programming_error
#: make_cmd.c:756
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr "make_redirection: Alidirektada komando „%d‟ ekster sia variejo"

#: parse.y:3133 parse.y:3369
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "Neatendita dosierfino dum serĉo de responda „%c‟"

#: parse.y:3951
msgid "unexpected EOF while looking for `]]'"
msgstr "Neatendita dosierfino dum serĉo de „]]‟"

#: parse.y:3956
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "Sintaksa eraro en kondiĉa esprimo: Neatendita simbolo „%s‟"

#: parse.y:3960
msgid "syntax error in conditional expression"
msgstr "Sintaksa eraro en kondiĉa esprimo"

#: parse.y:4038
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "Nekonvena simbolo „%s‟ anstataŭ „)‟"

#: parse.y:4042
msgid "expected `)'"
msgstr "Mankas „)‟"

#: parse.y:4070
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "La argumento „%s‟ ne konvenas por unuloka kondiĉa operacisimbolo"

#: parse.y:4074
msgid "unexpected argument to conditional unary operator"
msgstr "Maltaŭga argumento por unuloka kondiĉa operacisimbolo"

#: parse.y:4120
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "Misa simbolo „%s‟ anstataŭ duloka kondiĉa operacisigno"

#: parse.y:4124
msgid "conditional binary operator expected"
msgstr "ĉi tie devas esti duloka kondiĉa operacisigno"

#: parse.y:4146
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "La argumento „%s‟ ne konvenas por duloka kondiĉa operacisimbolo"

#: parse.y:4150
msgid "unexpected argument to conditional binary operator"
msgstr "<maltaŭga argumento por duloka kondiĉa operacisimbolo"

#: parse.y:4161
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "Misa simbolo „%c‟ en kondiĉa komando"

#: parse.y:4164
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "Misa simbolo „%s‟ en kondiĉa komando"

#: parse.y:4168
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "Misa simbolo „%d‟ en kondiĉa komando"

#: parse.y:5459
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "Sintaksa eraro apud neatendita simbolo „%s‟"

#: parse.y:5477
#, c-format
msgid "syntax error near `%s'"
msgstr "Sintaksa eraro apud „%s‟"

#: parse.y:5487
msgid "syntax error: unexpected end of file"
msgstr "Sintaksa eraro: Neatendita dosierfino"

#: parse.y:5487
msgid "syntax error"
msgstr "Sintaksa eraro"

#: parse.y:5549
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Uzu «%s» por eliri el la ŝelo.\n"

#: parse.y:5711
msgid "unexpected EOF while looking for matching `)'"
msgstr "Neatendita dosierfino dum serĉo de responda „)‟"

# XXX: internal_error
#: pcomplete.c:1030
#, c-format
msgid "completion: function `%s' not found"
msgstr "Kompletigo: Funkcio „%s‟ ne trovita"

# XXX: programming_error
#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: NULL COMPSPEC"

#: print_cmd.c:290
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: Misa stir-operacio „%d‟"

#: print_cmd.c:363
#, fuzzy, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "%d: Misa dosiernumero: %s"

#: print_cmd.c:368
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.c:372
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

# XXX: programming_error
#: print_cmd.c:1461
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: „%c‟: Misa formatsigno"

#: redir.c:110
msgid "file descriptor out of range"
msgstr "Ekstervarieja dosiernomo"

# XXX: internal_error
#: redir.c:166
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: Ambigua alidirektado"

# XXX: internal_error
#: redir.c:170
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: Maleblas surskribi ekzistantan dosieron"

# XXX: internal_error
#: redir.c:175
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: Limigita ŝelo: malpermesitas alidirekti eligon"

# XXX: internal_error
#: redir.c:180
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "Malprosperis krei labordosieron por tuj-dokumento: %s"

#: redir.c:184
#, fuzzy, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: Maleblas valorizi tabelanon per listo"

# XXX: internal_warning
#: redir.c:544
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "«/dev/(tcp|udp)/host/port» ne disponeblas ekster retumado"

#: redir.c:1101
msgid "redirection error: cannot duplicate fd"
msgstr "Alidirektada eraro: Fiaskis kunnomumo al dosiernumero"

#: shell.c:332
msgid "could not find /tmp, please create!"
msgstr "Mankas «/tmp», bv krei ĝin!"

#: shell.c:336
msgid "/tmp must be a valid directory name"
msgstr "«/tmp» devas esti valida dosierujo"

#: shell.c:884
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: Misa opcio"

#: shell.c:1651
msgid "I have no name!"
msgstr "Mi ne havas nomon!"

#: shell.c:1793
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNUa «bash», versio %s-(%s)\n"

#: shell.c:1794
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Uzo:\t%s [GNUa opcio longforma] [opcio] ...\n"
"\t%s [GNUa opcio longforma] [opcio] SKRIPTODOSIERO ...\n"

#: shell.c:1796
msgid "GNU long options:\n"
msgstr "GNUaj opcioj longformaj:\n"

#: shell.c:1800
msgid "Shell options:\n"
msgstr "Ŝelaj opcioj:\n"

#: shell.c:1801
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD aŭ -c komando aŭ -O shopt_opcio\t\t(nur voko)\n"

#: shell.c:1816
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s aŭ -o opcio\n"

# bash --help
#: shell.c:1822
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr "Por pluaj informoj pri la opcioj tajpu: «%s -c \"help set\"»\n"

#: shell.c:1823
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr "Por scii pli pri la primitivaj ŝelkomandoj tajpu: „%s -c help‟\n"

#: shell.c:1824
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Por raporti pri eraroj uzu la komandon „bashbug‟\n"

# XXX: internal_error
#: sig.c:626
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: Misa operacio"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Ŝtopsignalo"

# Hangup detected on controlling terminal or death of controlling
# process
#: siglist.c:51
msgid "Hangup"
msgstr "Malkonekto"

# Interrupt from keyboard
#: siglist.c:55
msgid "Interrupt"
msgstr "Interrompo"

# Quit from keyboard
#: siglist.c:59
msgid "Quit"
msgstr "Klavara eliro"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Miskomando"

# SIGTRAP        5        Core    Trace/breakpoint trap
#: siglist.c:67
msgid "BPT trace/trap"
msgstr "Spurada kontrolpunkto"

# Abort signal from abort(3)
#: siglist.c:75
msgid "ABORT instruction"
msgstr "Komando ABORT"

# SIGEMT is not specified in POSIX 1003.1-2001, but  neverthless  appears
# on  most  other Unices, where its default action is typically to termi-
# nate the process with a core dump.
#: siglist.c:79
msgid "EMT instruction"
msgstr "EMT-komando"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Glitpunkta escepto"

# SIGKILL       9       Term    Kill signal
# Nek kaptebla nek ignorebla (malkiel ABORT)
#: siglist.c:87
msgid "Killed"
msgstr "Murdu"

#: siglist.c:91
msgid "Bus error"
msgstr "Bus-eraro"

# SIGSEGV      11       Core    Invalid memory reference
#: siglist.c:95
msgid "Segmentation fault"
msgstr "Adreseraro"

# SIGSYS      12,-,12     Core    Bad argument to routine (SVID)
#: siglist.c:99
msgid "Bad system call"
msgstr "Misa sistemvoko"

# SIGPIPE      13       Term    Broken pipe: write to pipe with no readers
#: siglist.c:103
msgid "Broken pipe"
msgstr "Rompita dukto"

# SIGALRM      14       Term    Timer signal from alarm(2)
#: siglist.c:107
msgid "Alarm clock"
msgstr "Vekhorloĝo"

# SIGTERM     15       Term    Termination signal
#: siglist.c:111
msgid "Terminated"
msgstr "Finiĝu"

# SIGURG      16,23,21    Ign     Urgent condition on socket (4.2 BSD)
#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Urĝa stato eneliga"

# SIGSTOP   17,19,23    Stop    Stop process
# Nek kaptebla nek ignorebla (samkiel SIGKILL)
# Haltu (poste eblos plu iri, vd SIGCONT)
#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Haltu (signalo)"

# SIGCONT   19,18,25            Continue if stopped
#: siglist.c:127
msgid "Continue"
msgstr "Pluen"

# SIGCHLD   20,17,18    Ign     Child stopped or terminated
#: siglist.c:135
msgid "Child death or stop"
msgstr "Procezido mortis aŭ haltis"

# SIGTTIN   21,21,26    Stop    tty input for background process
#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Haltu (pro terminalenigo)"

# SIGTTOU   22,22,27    Stop    tty output for background process
#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Haltu (pro terminaleligo)"

# SIGIO       23,29,22    Term    I/O now possible (4.2 BSD)
#: siglist.c:147
msgid "I/O ready"
msgstr "Eneligo pretas"

# SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2 BSD)
#: siglist.c:151
msgid "CPU limit"
msgstr "Ĉefprocesora tempolimo"

# SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2 BSD)
#: siglist.c:155
msgid "File limit"
msgstr "Dosiera longolimo"

# SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2 BSD)
#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Vekilo (virtuala)"

# SIGPROF     27,27,29    Term    Profiling timer expired
#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Vekilo (profilada)"

# SIGWINCH    28,28,20    Ign     Window resize signal (4.3 BSD, Sun)
#: siglist.c:167
msgid "Window changed"
msgstr "Fenestro ŝanĝiĝis"

# SIGLOST      -,-,-      Term    File lock lost
#: siglist.c:171
msgid "Record lock"
msgstr "Dosierŝloso"

# SIGUSR1   30,10,16    Term    User-defined signal 1
#: siglist.c:175
msgid "User signal 1"
msgstr "Uzulsignalo 1ª"

#: siglist.c:179
msgid "User signal 2"
msgstr "Uzulsignalo 2ª"

# Harbor File Transfer:
#: siglist.c:183
msgid "HFT input data pending"
msgstr "Pendas HFT-enigo"

# SIGPWR      29,30,19    Term    Power failure (System V)
#: siglist.c:187
msgid "power failure imminent"
msgstr "Energiprovizo paneontas"

# SIGDANGER
#: siglist.c:191
msgid "system crash imminent"
msgstr "La sistemo estas kraŝonta"

# SIGMIGRATE:
#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "La procezo iru al alia ĉefprocesoro"

# SIGPRE
#: siglist.c:199
msgid "programming error"
msgstr "Programeraro"

# SIGGRANT (monopola??)
#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "HFT-monitorreĝimo jesigita"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "HFT-monitorreĝimo forprenita"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "HFT-sonsekvenco finiĝis"

# SIGINFO      29,-,-             A synonym for SIGPWR
#: siglist.c:215
msgid "Information request"
msgstr "Informmendo"

#: siglist.c:223
msgid "Unknown Signal #"
msgstr "Nekonata signalnumero"

#: siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Nekonata signalo n-ro %d"

#: subst.c:1333 subst.c:1454
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "Misa anstataŭigo: Mankas ferma „%s‟ en %s"

#: subst.c:2735
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: Maleblas valorizi tabelanon per listo"

#: subst.c:4754 subst.c:4770
msgid "cannot make pipe for process substitution"
msgstr "Ne prosperis fari dukton por proceza anstataŭigo"

#: subst.c:4802
msgid "cannot make child for process substitution"
msgstr "Ne prosperis krei idon por proceza anstataŭigo"

#: subst.c:4847
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "Ne prosperis malfermi nomitan dukton %s porlegan"

#: subst.c:4849
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "Ne prosperis malfermi nomitan dukton %s por skribado"

#: subst.c:4867
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "Ne prosperis kunnomumi nomhavan dukton %s kiel dosiernumeron %d"

#: subst.c:5063
msgid "cannot make pipe for command substitution"
msgstr "Ne prosperis fari dukton por komanda anstataŭigo"

#: subst.c:5097
msgid "cannot make child for command substitution"
msgstr "Ne prosperis krei procezidon por komanda anstataŭigo"

#: subst.c:5114
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: Ne prosperis kunnomumi la dosiernumeron 1 al dukto"

#: subst.c:5617
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: Parametro estas NUL aŭ malaktiva"

#: subst.c:5907
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: subĉeno-esprimo < 0"

#: subst.c:6965
#, c-format
msgid "%s: bad substitution"
msgstr "%s: Misa anstataŭigo"

#: subst.c:7045
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: ĉi tiel ne valorizebla"

#: subst.c:7374
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""

#: subst.c:7839
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "Misa anstataŭigo: Mankas ferma „`‟ en %s"

#: subst.c:8720
#, c-format
msgid "no match: %s"
msgstr "Nenio kongrua: %s"

#: test.c:146
msgid "argument expected"
msgstr "Mankas argumento"

#: test.c:155
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: Mankas entjera esprimo"

#: test.c:263
msgid "`)' expected"
msgstr "Mankas „)‟"

#: test.c:265
#, c-format
msgid "`)' expected, found %s"
msgstr "Anstataŭ „)‟ troviĝas %s"

#: test.c:280 test.c:693 test.c:696
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: Tie devas esti unuloka operacisigno"

#: test.c:449 test.c:736
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: Tie devas esti duloka operacisigno"

#: test.c:811
msgid "missing `]'"
msgstr "Mankas „]‟"

#: trap.c:203
msgid "invalid signal number"
msgstr "Misa signalnumero"

# XXX: internal_warning
#: trap.c:327
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: Misa valoro en trap_list[%d]: %p"

# XXX: internal_warning
#: trap.c:331
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr "run_pending_traps: Signaltraktilo SIG_DFL resendas %d (%s) al mi mem"

#: trap.c:380
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: Misa signalnumero %d"

#: variables.c:363
#, c-format
msgid "error importing function definition for `%s'"
msgstr "Eraro ĉe importo de funkcidifino por „%s‟"

# XXX: internal_warning
#: variables.c:748
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "%d estas tro granda ŝelnivelo; mallevita ĝis 1"

# XXX: internal_error
#: variables.c:1915
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: Malestas funkcia kunteksto en ĉi-regiono"

# XXX: internal_error
#: variables.c:3159
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: Malestas funkcia kunteksto en ĉi-regiono"

#: variables.c:3376
#, fuzzy, c-format
msgid "%s has null exportstr"
msgstr "%s: Parametro estas NUL aŭ malaktiva"

# XXX: internal_error
#: variables.c:3381 variables.c:3390
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "Misa signo %d en eksporta signoĉeno por „%s‟"

# XXX: internal_error
#: variables.c:3396
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "Mankas „=‟ en eksporta signoĉeno por „%s‟"

# XXX: internal_error
#: variables.c:3835
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: La kapo de „shell_variables‟ ne estas funkcia kunteksto"

# XXX: internal_error
#: variables.c:3848
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: Mankas kunteksto de „global_variables‟"

# XXX: internal_error
#: variables.c:3922
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr "pop_scope: La kapo de „shell_variables‟ ne estas provizora regiono"

#: variables.c:4678
#, fuzzy, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: Fiaskis malfermo de %s"

#: variables.c:4683
#, fuzzy, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%d: Misa dosiernumero: %s"

#: version.c:46
msgid "Copyright (C) 2009 Free Software Foundation, Inc."
msgstr "Copyright (C) 2009 ĉe «Free Software Foundation, Inc.»"

#: version.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"La permesilo estas GPLv3+; t.e. GNU GPL, versio 3ª aŭ pli nova.\n"
"La tekston vd ĉe <http://gnu.org/licenses/gpl.html>\n"

#: version.c:86 version2.c:83
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNUa «bash», versio %s (%s)\n"

#: version.c:91 version2.c:88
#, c-format
msgid "This is free software; you are free to change and redistribute it.\n"
msgstr ""
"Ĉi tiu programo estas libera; vi rajtas libere ĝin ŝanĝi kaj pludoni.\n"

#: version.c:92 version2.c:89
#, c-format
msgid "There is NO WARRANTY, to the extent permitted by law.\n"
msgstr ""
"NENIA GARANTIO estas donita, tiom kiom tion permesas la koncerna leĝo.\n"

#: version2.c:86
#, fuzzy, c-format
msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
msgstr "Copyright (C) 2009 ĉe «Free Software Foundation, Inc.»"

#: version2.c:87
#, fuzzy, c-format
msgid ""
"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"La permesilo estas GPLv3+; t.e. GNU GPL, versio 3ª aŭ pli nova.\n"
"La tekston vd ĉe <http://gnu.org/licenses/gpl.html>\n"

#: xmalloc.c:91
#, fuzzy, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc(): Ne povas okupi %lu bajtojn (%lu bajtoj disponigitaj)"

#: xmalloc.c:93
#, fuzzy, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "xmalloc: Ne prosperis okupi %lu bajtojn"

# XXX: fatal_error
#: xmalloc.c:163
#, fuzzy, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: %s:%d: ne eblas okupi %lu bajtojn (%lu bajtoj disponigitaj)"

# XXX: fatal_error
#: xmalloc.c:165
#, fuzzy, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: %s:%d: ne eblas okupi %lu bajtojn"

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [NOMO[=VALORO] ... ]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] NOMO [NOMO ...]"

#: builtins.c:51
msgid ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m KLAVARTABELO] [-f DOSIERNOMO] [-q NOMO]\n"
"          [-u NOMO] [-r KLAVAĴO] [-x KLAVAĴO:ŜELKOMANDO]\n"
"          [KLAVAĴO:READLINE-FUNKCIO AŬ READLINE-KOMANDO] "

#: builtins.c:54
msgid "break [n]"
msgstr "break [N]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [N]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [ŜELAĴO [ARG ...]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [ESPRIMO]"

#: builtins.c:64
msgid "cd [-L|-P] [dir]"
msgstr "cd [-L|-P] [DOSIERUJO]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "true"

#: builtins.c:72
msgid "false"
msgstr "false"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] KOMANDO [ARG ...]"

#: builtins.c:76
msgid "declare [-aAfFilrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFilrtux] [-p] [NOMO[=VALORO] ...]"

#: builtins.c:78
msgid "typeset [-aAfFilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFilrtux] [-p] NOMO[=VALORO] ..."

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [OPCIO] NOMO[=VALORO] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [ARG ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [ARG ...]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f DOSIERNOMO] [NOMO ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [ARG ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts OPCIĈENO NOMO [ARG]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a NOMO] [KOMANDO [ARGUMENTOJ ...]] [ALIDIREKTADO ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [N]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [N]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr ""
"fc [-e REDAKTILO] [-lnr] [UNUA] [LASTA] aŭ\n"
"fc -s [ŜABLONO=ANST] [KOMANDO]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [LABORINDIKO]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [LABORINDIKO]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p VOJNOMO] [-dt] [NOMO ...]"

#: builtins.c:117
#, fuzzy
msgid "help [-dms] [pattern ...]"
msgstr "help [-ds] [ŜABLONO ...]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d DEŜOVO] [n] aŭ\n"
"history -awr [DOSIERNOMO] aŭ\n"
"history -ps ARG [ARG...]"

#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr ""
"jobs [-lnprs] [LABORINDIKO ...] aŭ\n"
"jobs -x KOMANDO [ARGS]"

#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [LABORINDIKO ...]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s SIGSNOM | -n SIGNUM | -SIGNOM] [PN | LABORINDIKO] ... aŭ\n"
"kill -l [SIGNOM]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let ARG [ARG ...]"

#: builtins.c:136
#, fuzzy
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a TABELO] [-d DISIG] [-i TEKSTO] [-n NSIGN] [-p INVIT] [-t "
"TLIM] [-u DN] [NOMO ...]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [N]"

#: builtins.c:140
msgid "set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o OPCINOMO] [ARG ...]"

#: builtins.c:142
msgid "unset [-f] [-v] [name ...]"
msgstr "unset [-f] [-v] [NOMO ...]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [NOMO[=VALORO] ...]  aŭ  export -p"

#: builtins.c:146
msgid "readonly [-af] [name[=value] ...] or readonly -p"
msgstr "readonly [-aAf] [NOMO[=VALORO] ...]  aŭ  readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [N]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source DOSIERNOMO [ARGUMENTOJ]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". DOSIERNOMO [ARGUMENTOJ]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [ESPRIMO]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ ARG... ]"

#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[ARG] SIGNALINDIKO ...]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] NOMO [NOMO ...]"

#: builtins.c:169
msgid "ulimit [-SHacdefilmnpqrstuvx] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [LIMO]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [REĜIMO]"

#: builtins.c:175
msgid "wait [id]"
msgstr "wait [IND]"

#: builtins.c:179
msgid "wait [pid]"
msgstr "wait [PN]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOMO [in VORTOJ ... ] ; do KOMANDOJ; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( ESPR1; ESPR2; ESPR3 )); do KOMANDOJ; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NONO [in VORTOJ ... ;] do KOMANDOJ; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr "time [-p] DUKTO"

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case VORTO in [ŜABLONO [| ŜABLONO]...) KOMANDOJ ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if KOMANDOJ; then KOMANDOJ; [ elif KOMANDOJ; then KOMANDOJ; ]... [ else "
"KOMANDOJ; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while KOMANDOJ; do KOMANDOJ; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until KOMANDOJ; do KOMANDOJ; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOMO] KOMANDO [ALIDIREKTADOJ]"

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function NOMO { KOMANDOJ ; }  aŭ  NOMO () { KOMANDOJ ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ KOMANDOJ ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "LABORINDIKO [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( ESPRIMO ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ ESPRIMO ]]"

# Ĉu "variables" estas serĉa ŝlosilo ?
# T.e. "help var" aŭ "help variabl", sed ne "nelp variabloj"?
#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "var - Nomoj kaj signifo de kelkaj ŝelvariabloj"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | DOSIERUJO]"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [OPCINOMO ...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v VAR] FORMATO [ARGUMENTOJ]"

#: builtins.c:229
#, fuzzy
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-"
"W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-o OPCIO] [-A AGO] [-G GLOBŜAB] [-W "
"VORTLISTO]  [-F FUNKCIO] [-C KOMANDO] [-X FILTROŜAB] [-P PREFIKSO] [-S "
"SUFFIKSO] [NOMO ...]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o OPCIO]  [-A AGO] [-G GLOBŜAB] [-W vORTLISTO]  [-"
"F FUNKCIO] [-C KOMANDO] [-X FILTROŜAB] [-P PREFIKSO] [-S SUFFIKSO] [VORTO]"

#: builtins.c:237
#, fuzzy
msgid "compopt [-o|+o option] [-DE] [name ...]"
msgstr "compopt [-o|+o OPCIO] [NOMO ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n NOMBRILO] [-O ORIGINO] [-s NOMBRILO] [-t] [-u DN] [-C RETROVOKO] "
"[-c KVANTO] [TABELO]"

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"readarray [-n NOMBRILO] [-O ORIGINO] [-s NOMBRILO] [-t] [-u DN] [-C "
"RETROVOKO] [-c KVANTO] [TABELO]"

#  alias:
#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Difinu aŭ listigu alinomojn.\n"
"\n"
"    Sen argumento aŭ kun la opcio  -p  „alias‟ eligas en la ĉefeligujon\n"
"    la liston da alinomoj en la reuzebla formo «alias NOMO=VALORO».\n"
"\n"
"    Alie, ĉiu NOMO iĝas difinita kiel alinomo por indikita VALORO.\n"
"    Vosta spaceto en la VALORO kaŭzas teston, ĉu la sekva vorto estas\n"
"    alinome anstataŭigenda ĉe la komputo de la alinomo.\n"
"\n"
"    Opcioj:\n"
"    -p\tEligu ĉiujn difinitajn alinomojn en reuzebla formo.\n"
"\n"
"    Elirstato:\n"
"    La komando „alias‟ liveras „true‟ krom se aperas NOMO ne difinita\n"
"    alinome."

# unalias [-a] name [name ...]
#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Forigu la nomojn name ... el la listo de difinitaj alinomoj.\n"
"\n"
"    Opcioj:\n"
"    -a\tSe enestas la opcio „-a‟, ĉiujn alinomojn forigu.\n"
"\n"
"    Liveru sukceson krom se name ne estas difinita alinome."

# bind [-lpvsPVS] [-m KLAVARTABELO] [-f DOSIERNOMO] [-q NOMO] [-u NOMO]
#      [-r KLAVAĴO] [-x KLAVAĴO:ŜELKOMANDO]
#      [KLAVAĴO:READLINE-FUNKCIO AŬ READLINE-KOMANDO]
#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Difinu klavligojn kaj variablojn.\n"
"\n"
"    Ligu klavosekvencon al linilega funkcio, aŭ al makroo, aŭ valorizu\n"
"    linilegan variablon.  La sintakso de ne-opcia argumento estas tiu\n"
"    de «~/.inputrc», tamen la ligon oni esprimu unuargumente; ekz-e:\n"
"    bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"\n"
"    Opcioj:\n"
"    -m KLAVARTABELO   Uzu KLAVARTABELOn dum la daŭro de ĉi tiu komando.\n"
"                      La eblaj nomoj de klavartabelo estas: „emacs‟,\n"
"                      „emacs-standard‟, „emacs-meta‟, „emacs-ctlx‟,\n"
"                      „vi‟, „vi-move‟, „vi-command‟ kaj „vi-insert‟.\n"
"    -l                Listigu funkcinomojn.\n"
"    -P                Listigu funkcinomojn kaj klavligojn.\n"
"    -p                Listigu funkcinomojn kaj klavligojn en formo\n"
"                      reuzebla por enigo.\n"
"    -S                Listigu makroajn klavsekvencojn kaj ilian valoron.\n"
"    -s                Listigu makroajn klavsekvencojn kaj ilian valoron\n"
"                      en formo reuzebla por enigo.\n"
"    -V                Listigu variablonomojn kaj ilian valoron.\n"
"    -v                Listigu variablonomojn kaj ilian valoron en formo\n"
"                      reuzebla por enigo.\n"
"    -q FUNKCINOMO     Demando pri la klavoj ligitaj al la FUNKCINOMO.\n"
"    -u FUNKCINOMO     Malligu ĉiujn klavligojn disde la FUNKCINOMO.\n"
"    -r KLAVAĴO        Forigu la ligon de la klavsekvenco KLAVAĴO\n"
"    -f DOSIERNOMO     Legu klavligojn el DOSIERNOMO\n"
"    -x KLAVAĴO:ŜELKOMANDO  La ŜELKOMANDO plenumiĝu ĉe enigo de KLAVAĴO.\n"
"\n"
"    Elirstato:\n"
"    0, krom se nekonata opcio estas donita aŭ eraro okazis."

# exit:
#: builtins.c:326
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Finu iteracion FOR, WHILE aŭ UNTIL\n"
"\n"
"    Eliru ekster iteracion FOR, WHILE aŭ UNTIL. Se N estas donita,\n"
"    iru N iteraciajn nivelojn eksteren.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke N estas pli granda ol aŭ egala al 1."

# continue:
#: builtins.c:338
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Daŭrigu iteraciadon de ordono FOR, WHILE aŭ UNTIL\n"
"\n"
"    Pasu al la sekva iteraciero de  FOR, WHILE aŭ UNTIL.\n"
"    Se N estas donita, eliru ĝis la nivelon de la Nª inganta\n"
"    iteraciordono.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke N estas pli granda ol aŭ egala al 1."

# builtin [shell-builtin [arg ...]]
# builtin [ŜELAĴO [ARG ...]]
#: builtins.c:350
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"Rulu primitivan ŝelkomandon\n"
"\n"
"    Plenumu primitivan ŝelkomandon ŜELAĴO kun la argumentoj ARG sen la\n"
"    normala komadoserĉo.  Tio utilas se oni volas uzi la nomon de\n"
"    ŝelaĵo por nomi funkcion, sed bezonas la koncernan primitivon en\n"
"    la funkcio mem.\n"
"\n"
"    Elirstato:\n"
"    Tiu de de ŜELAĴO; aŭ malsukceso, se ŜELAĴO ne estas primitiva\n"
"    ŝelkomando."

# caller [expr] =>
# caller [ESPRIMO]
#: builtins.c:365
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Liveru la kuntekston de la kuranta procedurvoko\n"
"\n"
"    Se ESPRIMO malestas, liveru «$line $filename».  Se ESPRIMO\n"
"    ĉeestas, liveru «$line $subroutine $filename»; ĉi tiu krominformo\n"
"    uzeblas por vidigi la vok-stakon.\n"
"\n"
"    La valoro de ESPRIMO indikas, kiom da vokkadroj retroiri disde la\n"
"    kuranta; la pinta kadro havas la numeron 0.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, kondiĉe ke la ŝelo plenumas ŝelfunkcion kaj la ESPRIMO\n"
"    estas valida."

# cd:
#: builtins.c:383
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed; non-zero otherwise."
msgstr ""
"Ŝanĝu la kurantan laboran dosierujon de la ŝelo.\n"
"\n"
"    La kuranta dosierujo iĝu dir aŭ, se dir malestas, la valoro\n"
"    de la variablo $HOME.\n"
"\n"
"    La variablo $CDPATH difinas la serĉvojon por la dosierujo\n"
"    entenanta dir-on.  En $CDPATH, dupunkto  „:‟ apartigas alternativajn\n"
"    dosierujojn, vakua dosiernomo egalas la kurantan (t.e. „.‟).  Se dir\n"
"    komenciĝas per „/‟, la variablo $CDPATH ne estas uzata.\n"
"\n"
"    Se la dosierujo ne troviĝas, kaj la ŝela opcio „cdable_vars‟ estas\n"
"    ŝaltita, la vorto estas interpretata kiel variablo.  Se la\n"
"    variablo havas valoron, plenumiĝas „cd‟ al tiu valoro.\n"
"\n"
"    Opcioj:\n"
"    -L\tsekvu simbolajn ligilojn.\n"
"    -P\tuzu la fizikan strukturon de dosierujoj sen iri laŭ\n"
"\tsimbolaj ligiloj\n"
"\n"
"    Defaŭlte la simbolaj ligiloj estas sekvataj, kvazaŭ „-L‟ ĉeestus.\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, se la dosierujŝanĝo sukcesis; nenulo aliokaze."

# pwd [-LP]
#: builtins.c:411
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Eligu la nomon de kuranta labora dosierujo\n"
"\n"
"    Opcioj:\n"
"    -L  eligu la valoron de $PWD, se ĝi indikas la kurantan laboran\n"
"        dosierujon\n"
"    -P  eligu la nomon de la fizika dosierujo, sen eventualaj simbolaj\n"
"        ligiloj\n"
"\n"
"    Defaŭlte „pwd‟ kondutas tiel, kiel kun la opcio „-L‟.\n"
"\n"
"    Elirstato:\n"
"    0, krom se aperas misa opcio aŭ la kuranta dosierujo estas\n"
"    nelegebla."

#: builtins.c:428
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Malplena ordono\n"
"\n"
"    Senefika: La komando nenion faras.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# true
#: builtins.c:439
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Liveru sukcesan rezulton\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# false:
#: builtins.c:448
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Liveru fiaskon.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam malsukcesa."

# command [-pVv] command [arg ...]
# command [-pVv] KOMANDO [ARG ...]
#: builtins.c:457
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Plenumu simplan komandon aŭ vidigu informojn pri komandoj\n"
"\n"
"    Plenumu KOMANDOn kun ARGoj sen atenti eventualajn ŝelfunkciojn\n"
"    samnomajn; aŭ vidigu informojn pri indikitaj KOMANDOj.  Uzeblas\n"
"    por voki komandojn de disko malgraŭ la ekzisto de samnomaj\n"
"    funkcioj.\n"
"\n"
"    Opcioj:\n"
"    -p  Uzu la defaŭltan valoron de la de la variablo $PATH (tio\n"
"\tebligas trovi ĉiujn normajn utilaĵojn)\n"
"    -v\tEligu komandopriskribon laŭ la maniero de la primitivaĵo „type‟\n"
"    -V\tEligu pli detalan priskribon de KOMANDO\n"
"\n"
"    Elirstato:\n"
"    Tiu de KOMANDO; aŭ malsukceso, se KOMANDO ne troveblas."

# declare [-afFirtx] [-p] [name[=value] ...]
# declare [-aAfFilrtux] [-p] [NOMO[=VALORO] ...]
#: builtins.c:476
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Difinu valorojn aŭ atributojn de variabloj\n"
"\n"
"    Deklaru variablojn aŭ valorizu ilin per atributoj.\tSe NOMOj\n"
"    mankas, anstataŭe eligu la valoron de ĉiuj variabloj.\n"
"\n"
"    Opcioj:\n"
"    -f\tla ago aŭ eligo koncernu nur la funkciajn NOMOjn kaj difinojn\n"
"    -F\teligu nur funkcinomojn (ĉe erarserĉo, ankaŭ lininumeron kaj\n"
"\tfontodosieran nomon) sen difinoj\n"
"    -p\teligu la atributojn kaj la valorojn de ĉiu NOMO\n"
"\n"
"    Opcioj atributdonaj:\n"
"    -a\tfaru la NOMOjn poziciaj tabeloj (se realigite)\n"
"    -A\tfaru la NOMOjn asocitabeloj (se realigite)\n"
"    -i\thavigu al la variabloj NOMOj la atributon „integer‟ (entjera)\n"
"    -l\tminuskligu la NOMOjn ĉe valorizo\n"
"    -r\tfaru la variablojn NOMOj nurlegaj\n"
"    -t\thavigu al la NOMOj la atributon „trace‟ (spurata)\n"
"    -u\tmajuskligu la NOMOjn ĉe valorizo\n"
"    -x\teksportu la variablojn NOMOj\n"
"\n"
"    La uzo de „+‟ anstataŭ „-‟ malŝaltas la koncernan attributon.\n"
"    Uzite en funkcio, „declare‟ faras la NOMOjn lokaj, samkiel la\n"
"    komando „local‟.\n"
"\n"
"    Ĉe valorizo de variablo havanta atributon „integer‟ (entjera)\n"
"    okazas aritmetika komputado (vd „let‟).\n"
"\n"
"    Eliistato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro."

# typeset [-aAfFilrtux] [-p] name[=value] ...
#: builtins.c:512
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"Difinu atributojn kaj valorojn de variabloj\n"
"\n"
"   Arkaika. Vd «help declare»."

# local [option] name[=value] ...
# local [OPCIO] NOMO[=VALORO] ...
#: builtins.c:520
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, an error occurs,\n"
"    or the shell is not executing a function."
msgstr ""
"Difinu lokajn variablojn\n"
"\n"
"    Kreu lokan variablon NOMO kaj ĝin valorizu per VALORO.  OPCIO\n"
"    povas esti ajna el la opcioj de „declare‟.\n"
"\n"
"    Lokaj variabloj uzeblas nur ene de funkcio; ili estas videblaj nur\n"
"    en la funkcio kie ili estas difinitaj kaj en ĝiaj idoj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio, okazas eraro, aŭ la ŝelo ne\n"
"    estas plenumanta funkcion."

# echo:
#: builtins.c:537
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Eligu la argumentojn en la ĉefeligujon\n"
"\n"
"    Eligu la ARGojn en la ĉefeligujon, postmetu linirompon.\n"
"\n"
"    Opcioj:\n"
"    -n\tne aldonu la finan linirompon\n"
"    -e\taktivigu interpretadon de la ĉi-subaj deklivaĵoj\n"
"    -E\tmalaktivigu interpretadon de la ĉi-subaj deklivaĵoj\n"
"\n"
"    „echo‟ povas interpreti la sekvajn literojn prefiksitajn per\n"
"    deklivo (per la signo „\\‟):\n"
"\t\\a\tpepo (sonsignalo)\n"
"\t\\b\tretropaŝo\n"
"\t\\c\tĉesigu pluan eligon\n"
"\t\\e\teskapsigno\n"
"\t\\f\tpaĝ-avanco\n"
"\t\\n\tlinifino\n"
"\t\\r\tĉaretreveno\n"
"\t\\t\thorizontala tabo\n"
"\t\\v\tvertikala tabo\n"
"\t\\\\\tdeklivo „\\‟\n"
"\t\\0CCC\tla signo kies Askia kodono estas CCC (okume).  CCC\n"
"\t\tpovas enteni 0, 1, 2 aŭ 3 okumajn ciferojn\n"
"\t\\0xHH\tla signo kies 8-bita kodono estas HH (16-ume).  HH\n"
"\t\tpovas enteni unu aŭ du 16-umajn ciferojn\n"
"\n"
"    Elirstato:\n"
"    Sukcesa, krom se okazas elig-eraro."

# echo [-n] [ARG ...]
#: builtins.c:571
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Skribu argumentojn en la ĉefeligujon\n"
"\n"
"    Eligu la ARGojn en la ĉefeligujon, aldonu linifinilon.\n"
"\n"
"    Opcio:\n"
"    -n  Ne aldonu postan linifinilon\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se okazas skriberaro."

# enable [-a] [-dnps] [-f filename] [name ...]
# enable [-a] [-dnps] [-f DOSIERNOMO] [NOMO ...]
#: builtins.c:586
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Aktivigu aŭ malaktivigu primitivajn komandojn\n"
"\n"
"    Aktivigu aŭ malaktivigu primitivajn ŝelkomandojn.  Tio ebligas\n"
"    uzi eksteran komandon, samnoman kun primitivaĵo, sen indiki\n"
"    ĝian plenan vojon.\n"
"\n"
"    Opcioj:\n"
"    -a\tListigu la primitivaĵojn indikante, ĉu ili estas aktivaj\n"
"    -n  Malaktivigu la NOMOjn, aŭ listigu la malaktivajn primitivaĵojn\n"
"    -p\tListigu primitivaĵojn en formo taŭga por reuzo\n"
"    -s  Eligu nur la «specialajn» ŝelfunkciojn de Posix\n"
"\n"
"    Opcioj regantaj dinamikan ŝargadon:\n"
"    -f\tŜargu primitivaĵon NOMO el la dinamika biblioteko DOSIERNOMO\n"
"    -d  Forigu ŝelkomandon dinamike ŝargitan per  -f\n"
"\n"
"    Senopcie: Aktivigu ĉiujn NOMOjn\n"
"\n"
"    Ekz-e por uzi la „test‟on troveblan en  $PATH  anstataŭ la\n"
"    samnoman primitivan ŝelkomandon, diru: «enable -n test».\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se NOMO ne estas primitiva ŝelkomando aŭ okazis\n"
"    eraro."

# eval [ARG ...]
#: builtins.c:614
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Plenumu argumentojn kiel ŝelkomandon\n"
"\n"
"    Kunmetu la ARGojn en unu ĉenon, uzu la rezulton kiel enigaĵon por\n"
"    la ŝelo kaj plenumu la legita(j)n komando(j)n.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komandoĉeno; sukceso, se la komando estas vakua."

# getopts optstring name [arg] =>
# getopts OPCIĈENO NOMO [ARG]
#: builtins.c:626
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Analizu opciajn argumentojn\n"
"\n"
"    La funkcion „getopts‟ uzas ŝelproceduroj por analizi opciformajn\n"
"    numerparametrojn.\n"
"\n"
"    La argumento OPCIĈENO entenas la rekonendajn opciliterojn; se\n"
"    literon sekvas dupunkto, la opcio postulas argumenton, disde ĝi\n"
"    apartigendan per blanka spaco.\n"
"\n"
"    Ĉe ĉiu voko „getopts‟ liveros la vican opcion en la ŝelvariablon\n"
"    $NOMO (estigante la variablon se ĝi ne ekzistas); kaj la indicon\n"
"    de la sekve traktota argumento en la ŝelvariablon OPTIND.  OPTIND\n"
"    ricevas la komencan valoron  1  ĉe ĉiu voko de la ŝelo aŭ ŝela\n"
"    skripto.  Kiam opcio bezonas argumenton, „getopts‟ liveras tiun\n"
"    argumenton en la ŝelvariablon  OPTARG.\n"
"\n"
"    La funkcio „getopts‟ raportas pri eraroj dumaniere. Se la unua\n"
"    signo de OPCIĈENO estas dupunkto,  „getopts‟  prisilentas\n"
"    erarojn.  En tiu reĝimo, nenia erarmesaĝo estas eligata.\n"
"    Renkontinte misan opcion, „getopts‟ metas la trovitan opciliteron\n"
"    en  OPTARG.  Se mankas bezonata argumento, la ŝelvariablo  NOMO\n"
"    ricevas la valoron  ':', kaj la variablo OPTARG,  la trovitan\n"
"    opcion.  Se „getopts‟ ne estas en silenta reĝimo kaj trovas\n"
"    misan opcion, tiam NOMO ricevas la valoron '?' kaj  OPTARG\n"
"    senvaloriĝas.  Se mankas bezonata opcio, NOMO ricevas la\n"
"    valoron '?', OPTARG senvaloriĝas kaj erarmesaĝo estas eligata.\n"
"\n"
"    Se la ŝelvariablo  OPTERR  havas la valoron  0,  „getopts‟\n"
"    malaktivigas la eligon de erarmesaĝoj, eĉ se la unua signo de\n"
"    OPCIĈENO ne estas dupunkto.  La apriora valoro de OPTERR estas 1.\n"
"\n"
"    Normale „getopts‟ analizas la numerparametrojn  ($0 - $9), sed se\n"
"    estas pli da argumentoj, „getopts‟ anstataŭe analizas ilin.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se opcio estas trovita; malsukceso, se renkontiĝis\n"
"    la fino de la opcioj aŭ okazis eraro."

# exec [-cl] [-a name] [command [arguments ...]] [redirection ...]
# exec [-cl] [-a NOMO] [KOMANDO [ARGUMENTOJ ...]] [ALIDIREKTADO ...]
#: builtins.c:668
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Anstataŭigu la ŝelon je la donita komando\n"
"\n"
"    Plenumu la KOMANDOn, anstataŭigante la ŝelon je la donita\n"
"    programo.  La ARGUMENTOj servas kiel argumentoj por KOMANDO.\n"
"    Se KOMANDO ne estas indikita, la alidirektadoj okazu en \n"
"    la kuranta ŝelo.\n"
"\n"
"    Opcioj:\n"
"    -a NOMO  Pasigu NOMOn al KOMANDO kiel la argumenton  argv[0]\n"
"    -c\tLa plenumo de KOMANDO okazu en vakua medio\n"
"    -l\tMetu minuson en la nulan argumenton pasigatan al KOMANDO\n"
"\n"
"    Se la komandon ne eblas plenumi kaj la ŝelo ne estas dialoga, tiam\n"
"    la ŝelo finiĝas, krom se la opcio „execfail‟ estas aktiva.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se KOMANDO ne estas trovita aŭ okazis eraro pri\n"
"    alirektado."

# exit [n]
#: builtins.c:689
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Forlasu la ŝelon\n"
"\n"
"    Forlasu la ŝelon kun elirstato N.  Se  N  mankas, la elirstato\n"
"    estas tiu de la plej ĵuse plenumita komando."

# logout [N]
#: builtins.c:698
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Adiaŭ, saluta ŝelo!\n"
"\n"
"    Eliru el saluta ŝelo kun la elirstato  N.  Liveru malsukceson, se\n"
"    plenumate ne en saluta ŝelo."

# ZZZ: fc [-e ename] [-nlr] [first] [last] or
#      fc -s [pat=rep] [command] =>
# fc [-e REDAKTILO] [-lnr] [UNUA] [LASTA] aŭ
# fc -s [ŜABLONO=ANST] [KOMANDO]
#: builtins.c:708
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Eligu aŭ plenumu komandojn el la historilisto\n"
"\n"
"    „fc‟ servas por listigi aŭ redakti kaj replenumi komandojn el la\n"
"    historilisto.  UNUA  kaj  LASTA  povas esti numeroj, indikantaj\n"
"    intervalon da numeroj; aŭ, se  UNUA  estas signoĉeno, ĝi indikas\n"
"    la plej ĵusan komandon komenciĝantan per tiu signoĉeno.\n"
"\n"
"    Opcioj:\n"
"    -e REDAKTILO\tla uzota redaktilo.  Defaŭlte FCEDIT, poste\n"
"\tEDITOR, poste „vi‟\n"
"    -l\tnur eligu la liniojn sen redakti ilin\n"
"    -n\teligu sennumere (nur la liniojn)\n"
"    -r\tinversigu la ordon de la linioj (komencu per la plej ĵusaj).\n"
"\n"
"    «fc -s [ŜABLONO=ANST ...] [KOMANDO]» plenumas la KOMANDOn en kiu\n"
"    ĉiu apero de ŜABLONO estas la anstataŭigita je ANST.\n"
"\n"
"    Oportuna alinomo por tio estas «alias r='fc -s'», tiel ke ekz-e per\n"
"    «r cc» oni rulos la plej ĵusan komandon komenciĝantan per «cc», kaj\n"
"    per «r» replenumigas la ĵusan komandon.\n"
"\n"
"    Elisrstato:\n"
"    Sukceso, aŭ la elirstato de la plenumita KOMANDO; nenulo, se okazis\n"
"    eraro."

# fg [job_spec] => fg [LABORINDIKO]
#: builtins.c:738
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Movu laboron en la dialogon\n"
"\n"
"    Faru la laboron  LABORINDIKO  dialoga kaj la kuranta.  Se\n"
"    LABORINDIKO malestas, apliku la ŝelan koncepton pri la kuranta\n"
"    laboro.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la dialogigita komando; aŭ malsukceso, se okazis eraro."

# bg [job_spec] => bg [LABORINDIKO]
#: builtins.c:753
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Forŝovu laboron fonen\n"
"\n"
"    Forŝovu la laboron  LABORINDIKO  en la fonon, faru ĝin kvazaŭ\n"
"    lanĉita kun „&‟.  Se nenia laboro estas indikita, apliku la\n"
"    ŝelan koncepton pri la kuranta laboro.\n"
"\n"
"    Elirstato:\\n\"\n"
"    Sukceso, kondiĉe ke laborregadon estas ŝaltita kaj ne okazis\n"
"    eraro."

# hash [-lr] [-p VOJNOMO] [-dt] [NOMO ...]
#: builtins.c:767
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME is the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Registru aŭ vidigu vojnomojn de programoj\n"
"\n"
"    Por ĉiu komando NOMO, trovu kaj registru en hakettabelo la\n"
"    kompletan vojon al ties programo.  Se nenia argumento estas\n"
"    donita, eligu la informojn pri la memorataj komandoj.\n"
"\n"
"    Opcioj:\n"
"    -d  Forgesu la registritajn vojojn por ĉiu NOMO\n"
"    -l  Eligu en formo reuzeblan por enigo\n"
"    -p VOJNOMO\tuzu VOJNOMOn kiel kompletan vojon por la NOMO\n"
"    -r  Forgesu ĉiujn registritajn vojojn\n"
"    -t  Eligu la registritajn vojojn por ĉiu NOMO, mentante la NOMOn\n"
"        titole antaŭ ĝia vojo se estas pluraj NOMOj\n"
"\n"
"    Argumentoj:\n"
"    NOMO  Ĉiu NOMO estas serĉota en $PATH kaj registrota en la\n"
"\thakettabelo de registritaj komandoj\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas netrovebla NOMO aŭ misa opcio."

# help [-ds] [pattern ...]
# help [-ds] [ŜABLONO ...]
#: builtins.c:792
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Vidigu informon pri prmitivaj komandoj\n"
"\n"
"    Eligu mallongan resummon pri la primitivaj komandoj.  Se ĉeestas\n"
"    ŜABLONO, eligu detalan helpon pri ĉiuj komandoj kongruaj kun la\n"
"    ŝablono; alie eligu nur liston da temoj.\n"
"\n"
"    Opcioj:\n"
"    -d\tEligu mallongajn priskribojn de ĉiuj temoj\n"
"    -m\tVidigu uzmanieron en la „manpaĝa‟ stilo (kiel la komando „man‟)\n"
"    -s\tEligu nur mallongan resumon pri ĉiu trovita kongruaĵo\n"
"\n"
"    Argumentoj:\n"
"    ŜABLONO  Komenca signoĉeno de temtitolo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se mankas kongruaĵoj por ŜABLONO, aŭ aperis\n"
"    misa opcio."

# ZZZ history [-c] [-d offset] [n] or
#     history -awr [filename] or
#     history -ps arg [arg...] =>
# history [-c] [-d DEŜOVO] [n] aŭ
# history -awr [DOSIERNOMO] aŭ
# history -ps ARG [ARG...]
#: builtins.c:816
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Eligu aŭ redaktu la historiliston\n"
"\n"
"    Eligu la liston de enigitaj komandoj kun lininumeroj. La ŝanĝitajn\n"
"    liniojn marku per  „*‟.  Kun argumento  n,  eligu nur la ĵusajn\n"
"    n  liniojn.\n"
"\n"
"    Opcioj:\n"
"    -c\tforviŝu la tutan historion (forigu ĉiujn eroj el la listo)\n"
"    -d  forviŝu la linion kies numero estas  DEŜOVO\n"
"\n"
"    -a\taldonu la historiliniojn de la kuranta seanco al la\n"
"        historidosiero\n"
"    -n\tlegu ĉiujn ankoraŭ ne legitajn liniojn el la historidosiero\n"
"        kaj aldonu ilin en la historiliston\n"
"    -r  legu la dosieron kaj aldonu ĝian enhavon al la kuranta\n"
"        historilisto\n"
"    -w  konservu la kurantan historion en la historidosiero\n"
"\n"
"    -p  plenumu historian anstataŭigon por ĉiu el la argumentoj ARG\n"
"        kaj eligu la rezulton sen konservi ion en la historilisto\n"
"\n"
"    -s  enŝovu la neopciajn argumentojn  ARG  en la historiliston\n"
"        kiel unu apartan linion\n"
"\n"
"    Se ĉeestas  DOSIERNOMO,  uzu ĝin kiel nomon de historidosiero;\n"
"    alie, se la variablo $HISTFILE havas valoron, uzu ĉi tiun;\n"
"    alie uzu «~/.bash_history».\n"
"\n"
"    Se la variablo $HISTTIMEFORMAT havas valoron kaj se ĉi tiu ne\n"
"    estas null, tiam ĝi servu kiel formata ĉeno en  strftime(3)  por\n"
"    tempostampi ĉiun linion en eligaĵoj de historio.  Aliokaze nenia\n"
"    tempostampo estu eligata.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se renkontiĝas mis opcio aŭ okazis eraro."

# ZZZ jobs [-lnprs] [jobspec ...] or
#     jobs -x command [args] =>
# jobs [-lnprs] [LABORINDIKO ...] aŭ
# jobs -x KOMANDO [ARGS]
#: builtins.c:852
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlist only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Montru la staton de laboroj\n"
"\n"
"    Eligu liston da aktivaj laboroj.  Se  LABORINDIKO  estas donita,\n"
"    nur pri tiu laboro informu.  Senopcie, montru la staton de ĉiuj\n"
"    aktivaj laboroj.\n"
"\n"
"    Opcioj:\n"
"    -l  eligu, krom la normalajn informojn, ankaŭ la proceznumerojn\n"
"    -n  listigu nur la procezojn kies stato ŝanĝiĝis post la lasta\n"
"        informmendo\n"
"    -p  eligu nur la proceznumerojn\n"
"    -r  informu nur pri la laboroj aktivaj (rulataj)\n"
"    -s  informu nur pri la laboroj haltigitaj\n"
"\n"
"    La opcio -x lanĉas la  KOMANDOn,  antaŭe ŝanĝinte ĉiujn\n"
"    laborindikojn aperantajn en la argumentoj  ARGS  je la\n"
"    proceznumero de la ĉefprocezo de la grupo.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ okazis eraro.\n"
"    Ĉe „-x‟, la elirstato de la KOMANDO."

# disown [-h] [-ar] [jobspec ...]
#: builtins.c:879
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Forigu laborojn el la kuranta ŝelo\n"
"\n"
"    Forigu ĉiun laboron indikitan per argumento  LABORINDIKO  el\n"
"    la tabelo de aktivaj laboroj.  Se nenia laboro estas indikita,\n"
"    apliku la ŝelan koncepton pri la kuranta laboro.\n"
"\n"
"    Opcioj:\n"
"    -a  forigu ĉiujn laborojn el la labortabelo\n"
"    -h  anstataŭ forigi laboron el la tabelo, marku ĝin tiel, ke la\n"
"        signalo SIGHUP ne estu plusendita al la laboro(j) kiam tian\n"
"        signalon ricevas la ŝelo\n"
"    -r  forigu nur rulatajn laborojn\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ LABORINDIKO."

# ZZZ: kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or
#      kill -l [sigspec] =>
# kill [-s SIGSNOM | -n SIGNUM | -SIGNOM] PN | LABORINDIKO ... aŭ
# kill -l [SIGNOM]
#: builtins.c:898
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Sendu signalon al laboro\n"
"\n"
"    Sendu al la procezoj, indikitaj per sia proceznumero  PN  (aŭ\n"
"    per la LABORINDIKO) la signalon  SIGNOM  aŭ  SIGNUM.  Se nek\n"
"    SIGNUM  nek  SIGNOM  enestas, sendu SIGTERM.\n"
"\n"
"    Opcioj:\n"
"    -s\tSIGNOM estas nomo de signalo\n"
"    -n\tSIGNUM estas numero de signalo\n"
"    -l  listigu signalnomojn; la eventuale sekvantaj entjeraj\n"
"        argumentoj estas signalnumeroj, ĉeeste de kiuj nur la al\n"
"        ili respondaj signalnomoj estu eligataj.\n"
"\n"
"    „kill‟ estas primitiva ŝelkomando pro du kaŭzoj:\n"
"    unue, ĝi ebligas uzi laborindikojn anstataŭ proceznumerojn;\n"
"    kaj due, se la maksimuma nombro de kreeblaj procezoj estas\n"
"    atingita, ne necesas lanĉi kroman procezon por ĉesigi iun alian.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se enestas misa opcio aŭ okazis eraro."

# let arg [arg ...]
#: builtins.c:921
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."
msgstr ""
"Komputu aritmetikan esprimon\n"
"\n"
"    Ĉiu  arg  estas komputenda aritmetika esprimo. La komputado uzas\n"
"    fikslongajn entjerojn sen kontrolo pri trooj; tamen divido per  0\n"
"    estas kaptata kaj raportata kiel eraro.  En la sekvanta listo\n"
"    da operacioj la samprioritataj operacisimboloj aperas kune.\n"
"    La grupoj estas aranĝitaj laŭ malkresko de ligforto.\n"
"\n"
"\tnomo++, nomo--\tpostkrementoj de variablo\n"
"\t++nomo, --nomo\tantaŭkrementoj de variablo\n"
"\t-, +\t\tunulokaj minus, plus\n"
"\t!, ~\t\tlogika kaj laŭbita negoj\n"
"        **              potencigo\n"
"\t*, /, %\t\tmultipliko, divido, resto\n"
"\t+, -\t\tadicio, subtraho\n"
"\t<<, >>\t\tlaŭbitaj ŝovoj maldekstren kaj dekstren\n"
"\t<=, >=, <, >\tkomparaj operacioj\n"
"\t==, !=\t\tegalo, neegalo\n"
"\t&\t\tlaŭbita KAJ\n"
"\t^\t\tlaŭbita DISAŬ\n"
"\t|\t\tlaŭbita AŬ\n"
"\t&&\t\tlogika KAJ\n"
"\t||\t\tlogika AŬ\n"
"\tesprimo ? esprimo : esprimo\n"
"\t\t\tkondiĉa esprimo\n"
"\t=, *=, /=, %=,\n"
"\t+=, -=, <<=, >>=,\n"
"\t&=, ^=, |=\tvalorizoj\n"
"\n"
"    Ŝelvariabloj uzeblas kiel operandoj.  En esprimo la nomon de\n"
"    variablo anstataŭas ĝia valoro (altipigita al fikslonga entjero).\n"
"    Por tia uzo en esprimo variablo ne bezonas havi ŝaltita sian\n"
"    atributon „integer‟ (entjera).\n"
"\n"
"    La operacioj plenumiĝas laŭ la ligforto de siaj operacisignoj.  La\n"
"    enkrampigitaj subesprimoj plenumiĝas unue, kaj tio ebligas\n"
"    ĉirkaŭiri la supre priskribitajn regulojn pri la ligfortoj.\n"
"\n"
"    Elirstato:\n"
"    Se la komputo de la lasta  arg  donas  0,  la komando „let‟\n"
"    liveras  1;  alie ĝi liveras  0."

# read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt]
#      [-t timeout] [-u fd] [name ...]
# read [-ers] [-a TABELO] [-d DISIG] [-i TEKSTO] [-n NSIGN] [-p INVIT]
#      [-t TLIM] [-u DN] [NOMO ...]
#: builtins.c:966
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than NCHARS\n"
"    \t\tcharacters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any delimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read withint TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns success only\n"
"    \t\tif input is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Legu linion el la ĉefenigujo kaj disigu ĝin en kampojn\n"
"\n"
"    Legu unu linion el la ĉefenigujo, aŭ el la dosiero indikita\n"
"    per dosiernumero DN, se la opcio -u estas donita.  La linion\n"
"    disigu en kampojn, kiel ĉe vortodisigo, kaj la unuan vorton ricevu\n"
"    la unua argumento NOMO; la duan, la dua NOMO ktp; la lasta NOMO\n"
"    ricevu ĉiujn restantajn vortojn.  Nur la signoj troveblaj en la\n"
"    variablo $IFS rolas kiel vortodisigiloj.\n"
"\n"
"    Se nenia NOMO estas donita, konservu la legitan linion en la\n"
"    variablo REPLY.\n"
"\n"
"    Opcioj:\n"
"    -a TABELO\tla legatajn vortojn konservu en la sinsekvaj anoj de\n"
"\t\tTABELO, komencante ekde la indico 0\n"
"    -d DISIG\tlegu ĝis la unua signo de la disigilo DISIG (anstataŭ\n"
"\t\tlegi ĝis linifino)\n"
"    -e\t\tuzu Readline por akiri la linion en dialoga ŝelo\n"
"    -i TEKSTO\tuzu TEKSTOn kiel komencan tekston por Readline\n"
"    -n NSIGN\tĉesu leginte NSIGN da signoj (anstataŭ legi ĝis\n"
"\t\tlinifino)\n"
"    -p INVIT\teligu de la invitĉenon\tINVIT  sen liniavanco antaŭ la\n"
"\t\tatendata enigo\n"
"    -r\t\tla deklivo „\\‟ estu ordinara signo (ne eskapsigno)\n"
"    -s\t\tsilentigu la eĥon de la terminala enigo\n"
"    -t TLIM\tla komando  read  ĉesiĝu kun fiaska elirstato se\n"
"\t\tkompleta linio da enigaĵo ne estas ricevita dum\t TLIM\n"
"\t\tda sekundoj.  Se la variablo  TMOUT  havas valoron, ĉi\n"
"\t\ttiu estas uzata kiel defaŭlta atendolimo.  TLIM povas\n"
"\t\testi frakcio.  Se TLIM estas 0,\t read  sukcesas nur se\n"
"\t\tla engaĵo pretas ĉe la indikita dosiernumero.  La\n"
"\t\telirstato estas pli granda ol 128 se la atendotempo\n"
"\t\testas atingita\n"
"    -u DN\tlegu per la dosiernunero DN anstataŭ el la ĉefenigujo\n"
"\n"
"    Elirstato:\n"
"    Ĝi estas 0, krom se renkontiĝas dosierfino, aŭ atendolimo estas\n"
"    atingita, aŭ -u indikas nevalidan dosiernumeron."

# return [n]
# return [N]
#: builtins.c:1009
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Revenu el ŝelfunkcio\n"
"\n"
"    Igas la funkcion aŭ punkte vokitan („.‟, „source‟) skripton finiĝi\n"
"    kaj liveri la donitan valoron  N  kiel elirstaton.  Se  N  mankas,\n"
"    la elirstato estas tiu de la ĵusa komando.\n"
"\n"
"    Elirstato:\n"
"    N, aŭ malsukceso se la ŝelo ne plenumas ŝelfunkcion aŭ skripton."

# set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]
# set [--abefhkmnptuvxBCHP] [-o OPCINOMO] [ARG ...]
#: builtins.c:1022
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not follow symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Donu aŭ forprenu valorojn de ŝelvariabloj kaj numerparametroj.\n"
"\n"
"    Ŝanĝu la valoron de ŝelatributoj kaj numerparametroj, aŭ vidigu la\n"
"    nomojn kaj valorojn de ŝelvariabloj.\n"
"\n"
"    Opcioj:\n"
"    -a\tMarku eksportendaj la variablojn ŝanĝitajn aŭ kreitajn\n"
"    -b\tTuj sciigu pri finiĝo de fonaj laboroj\n"
"    -e\tEliru tuj se ajna komando finiĝis kun elirstato alia ol 0\n"
"    -f\tMalŝaltu generadon de dosiernomoj (globbing)\n"
"    -h\tRegistru en hakettabelo la situon de komandoj serĉataj\n"
"    -k\tĈiujn valorizojn en ajna parto de komandolinio rigardu\n"
"\tkiel valorizojn de ŝelvariabloj por la labormedio de la\n"
"\tkomando, ne nur la valorizojn antaŭ la komandonomo\n"
"    -m\tAktivigu la laborregadon\n"
"    -n\tLegu la komandojn sen plenumi ilin\n"
"    -o OPCINOMO\n"
"\tAktivigu la variablon respondan al la OPCIONOMO:\n"
"\t    allexport\tsamkiel -a\n"
"\t    braceexpand\tsamkiel -B\n"
"\t    emacs\tuzu emakseskan interfacon por liniredaktado\n"
"\t    errexit\tsamkiel -e\n"
"\t    errtrace\tsamkiel -E\n"
"\t    functrace\tsamkiel -T\n"
"\t    hashall\tsamkiel -h\n"
"\t    histexpand\tsamkiel -H\n"
"\t    history\tebligu komandohistorion\n"
"\t    ignoreeof\tla ŝelo ne finiĝu leginte dosierfinilon\n"
"\t    interactive-comments\n"
"\t\t\ttoleru komentojn en dialogaj komandoj\n"
"\t    keyword\tsamkiel -k\n"
"\t    monitor\tsamkiel -m\n"
"\t    noclobber\tsamkiel -C\n"
"\t    noexec\tsamkiel -n\n"
"\t    noglob\tsamkiel -f\n"
"\t    notify\tsamkiel -b\n"
"\t    nounset\tsamkiel -u\n"
"\t    onecmd\tsamkiel -t\n"
"\t    physical\tsamkiel -P\n"
"\t    pipefail\tla elirstato de dukto estu la elirstato\n"
"\t\t\tde la lasta komando finiĝinta nenule, aŭ\n"
"\t\t\t0, se neniu komando alie finiĝis\n"
"\t    posix\tŝanĝu la konduton de Baŝo ĉie kie ĝia defaŭlta\n"
"\t\t\tfunkciado devias disde Pozikso, tiel ke ĝi\n"
"\t\t\tkonformu al tiu normo\n"
"\t    privileged\tsamkiel -p\n"
"\t    verbose\tsamkiel -v\n"
"\t    vi\t\tuzu vi-eskan interfacon por liniredaktado\n"
"\t    xtrace\tsamkiel -x\n"
"    -p\tPrivilegia reĝimo, aktiviĝas meme kiam la reala kaj efektiva\n"
"\tidentoj de la uzanto malkongruas.  La dosiero $ENV ne estas\n"
"\ttraktata, nek la ŝelfunkcioj, importataj el la medio.\n"
"\tMalaktivigo de tiu opcio ŝanĝas la efektivajn uid kaj gid\n"
"\tlaŭ la realaj uid kaj gid\n"
"    -t\tFinu la ŝelon leginte kaj plenuminte unu komandon\n"
"    -u\tProvo anstataŭigi senvaloran variablon estu eraro\n"
"    -v\tEligu la komandoliniojn legatajn\n"
"    -x\tEligu la plenumotajn komandojn kaj iliajn argumentojn\n"
"    -B\tLa ŝelo faru vinkulmalvolvon\n"
"    -C\tSe aktiva, malebligu skribdifekti ekzistantajn ordinarajn\n"
"\tdosierojn per alidirektado de la eligo\n"
"    -E\tSe aktiva, la ERR-kaptilon (ERR trap) heredas la ŝelaj\n"
"\tfunkcioj\n"
"    -H\tEbligu atingi la historion !-stile. Defaŭlte la opcio estas\n"
"\taktiva en la dialogaj ŝeloj.\n"
"    -P\tNe sekvu simbolajn ligilojn plenumante komandojn ŝanĝantajn\n"
"\tla kurantan dosierujon („cd‟ ktp)\n"
"    -T\tSe aktiva, la DEBUG-kaptilon (DEBUG trap) heredas la ŝelaj\n"
"\tfunkcioj\n"
"    -\tLa restantajn argumentojn uzu por valorizi la\n"
"        numerparametrojn.  La opcioj -x kaj -v malaktiviĝas.\n"
"\n"
"    Uzante la signon + anstataŭ - vi povas malŝalti la opcion. La\n"
"    opciojn ankaŭ eblas uzi ĉe la voko de la ŝelo. La kuranta aro da\n"
"    aktivaj opcioj troveblas en $-.  La restantaj  n  argumentoj  ARG\n"
"    iĝas valoroj de la numervariabloj $1, $2 ... $n (en tiu ordo).\n"
"    Senargumente, eligu ĉiujn ŝelvariablojn.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se renkontiĝas misa opcio."

# unset [-f] [-v] [name ...]
# unset [-f] [-v] [NOMO ...]
#: builtins.c:1104
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Forigu valorojn kaj atributojn de ŝelaj funkcioj kaj variabloj\n"
"\n"
"    Por ĉiu NOMO, forigu la respondan variablon aŭ funkcion.\n"
"\n"
"    Opcioj:\n"
"    -f\ttraktu ĉiun NOMOn kiel funkcion\n"
"    -v  traktu ĉiun NOMOn kiel variablon\n"
"\n"
"    Se neniu el la du opcioj estas indikita, „unset‟ unue provos\n"
"    forigi variablon, kaj se tia ne troviĝos, funkcion.\n"
"\n"
"    Iujn variablojn ne eblas forigi.  Vd ankaŭ la helpon pri\n"
"    „readonly‟.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperis misa opcio aŭ NOMO estas nurlega."

# export [-fn] [name[=value] ...] or export -p
# export [-fn] [NOMO[=VALORO] ...]  aŭ  export -p
#: builtins.c:1124
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marku ŝelvariablojn kiel eksportajn\n"
"\n"
"    Marku la NOMOjn por aŭtomata eksporto en la medion de la\n"
"    plenumotaj komandoj.  Se ĉeestas VALORO, uzu ĝin por valorizi\n"
"    NOMOn antaŭ ol eksporti.\n"
"\n"
"    Opcioj:\n"
"    -f\ttemas pri ŝelfunkcioj\n"
"    -n\tforviŝu la eksportomarkon de la NOMOj\n"
"    -p\teligu la liston de ĉiuj eksportaj variabloj kaj funkcioj\n"
"\n"
"    La opcio „--‟ ĉesigas pluan opcitraktadon.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperis nevalida NOMO aŭ misa opcio."

# readonly [-af] [name[=value] ...] or readonly -p
# readonly [-aAf] [NOMO[=VALORO] ...]  aŭ  readonly -p
#: builtins.c:1143
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Faru ŝelvariablojn neŝanĝeblaj\n"
"\n"
"    La donitaj NOMOj  iĝas nurlegaj kaj la valorojn de tiuj nomoj\n"
"    ne povas ŝanĝi posta valorizo.  Se ĉeestas VALORO, uzu ĝin por\n"
"    valorizi la NOMOn antaŭ ol fari ĝin nurlega.\n"
"\n"
"    Opcioj:\n"
"    -a\ttemas pri pozicitabela signifo de plursignifa NOMO\n"
"    -A\ttemas pri asocitabela signifo de plursignifa NOMO\n"
"    -f\ttemas pri ŝelfunkcia signifo de plursignifa NOMO\n"
"    -p\teligu ĉiujn nurlegajn variablojn kaj funkciojn\n"
"\n"
"    La opcio „--‟ ĉesigas pluan opcitraktadon.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas nevalida nomo aŭ misa opcio."

# shift [n]
#: builtins.c:1164
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Ŝovu numerparametrojn\n"
"\n"
"    La numerparametrojn  $N+1, $N+2 ...  renumeru al  $1, $2 ...\n"
"    Se  N  ne estas indikita, uzu  1  anstataŭe."

# source filename [arguments]
# source DOSIERNOMO [ARGUMENTOJ]
#: builtins.c:1176 builtins.c:1191
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Plenumu komandojn el dosiero en la kuranta ŝelo\n"
"\n"
"    Legu kaj plenumu la komandojn el DOSIERNOMO en la kuranta ŝelo.\n"
"    Uzu la vojojn el la variablo  $PATH  por trovi la dosierujon de\n"
"    DOSIERNOMO.  La eventualaj ARGUMENTOJ iĝas la numerparametroj por\n"
"    plenumo de DOSIERNOMO.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita en DOSIERNOMO; malsukceso, se\n"
"    DOSIERNOMO ne legeblas."

# suspend [-f]
#: builtins.c:1207
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Haltetigu la plenumon de la ŝelo\n"
"\n"
"    Haltetigu la plenumon de la ŝelo ĝis ĝi ricevos la signalon SIGCONT.\n"
"    Krom se per superforto, salutan ŝelon ne eblas haltetigi.\n"
"\n"
"    Opcio:\n"
"    -f\tSuperforte haltetu, eĉ se la ŝelo estas saluta ŝelo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se laborregado estas malŝaltita aŭ okazis eraro."

# test [expr]
# test [ESPRIMO]
#: builtins.c:1223
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Komputu kondiĉan esprimon\n"
"\n"
"    Liveru elirstaton 0 (vera) aŭ 1 (malvera) laŭ la rezulto de\n"
"    komputado de la ESPRIMO.  La esprimoj povas esti unulokaj aŭ\n"
"    dulokaj.  La unulokaj plejparte servas por determini la \n"
"    statuson de dosiero.  Krome, estas operacioj super ĉenoj kaj la\n"
"    nombrokomparaj operacioj.\n"
"\n"
"    Operacioj super dosieroj:\n"
"\n"
"\t-a DOSIERO\tVera se DOSIERO ekzistas\n"
"\t-b DOSIERO\tVera se DOSIERO estas por bloka eneligo\n"
"\t-c DOSIERO\tVera se DOSIERO estas por bajta eneligo\n"
"\t-d DOSIERO\tVera se DOSIERO estas dosierujo\n"
"\t-e DOSIERO\tVera se DOSIERO ekzistas\n"
"\t-f DOSIERO\tVera se DOSIERO ekzistas kaj estas ordinara\n"
"\t-g DOSIERO\tVera se DOSIERO havas set-group-id = 1\n"
"\t-h DOSIERO\tVera se DOSIERO estas simbola ligilo\n"
"\t-L DOSIERO\tVera se DOSIERO estas simbola ligilo\n"
"\t-k DOSIERO\tVera se la DOSIERO havas sticky = 1\n"
"\t-p DOSIERO\tVera se DOSIERO estas nomhava dukto\n"
"\t-r DOSIERO\tVera se vi rajtas legi DOSIEROn\n"
"\t-s DOSIERO\tVera se DOSIERO ekzistas kaj longas pli ol 0\n"
"\t-S DOSIERO\tVera se DOSIERO estas kontaktingo („socket‟)\n"
"\t-t DNUMERO\tVera se la dosiero DNUMERO estas terminala\n"
"\t-u DOSIERO\tVera se DOSIERO havas set-user-id = 1\n"
"\t-w DOSIERO\tVera se vi rajtas skribi en DOSIEROn\n"
"\t-x DOSIERO\tVera se vi rajtas lanĉi DOSIEROn\n"
"\t-O DOSIERO\tVera se DOSIERO estas via dosiero\n"
"\t-G DOSIERO\tVera se DOSIERO apartenas al via grupo\n"
"\t-N DOSIERO\tVera se DOSIERO ŝanĝiĝis post la lasta lego\n"
"\n"
"\tD_RO1 -nt D_RO2\tVera se la dosiero D_RO1 estas pli freŝa\n"
"\t\t\t(laŭ la ŝanĝodato) ol la dosiero D_RO2\n"
"\tD_RO1 -ot D_RO2\tVera se D_RO1 estas malpli freŝas ol D_RO2\n"
"\tD_RO1 -ef D_RO2\tVera se D_RO1 estas rekta ligilo al D_RO2\n"
"\n"
"    Operacioj super ĉenoj:\n"
"\n"
"\t-z ĈENO\t\tVera se ĈENO estas vakua\n"
"\t-n ĈENO\t\tVera se ĈENO ne estas vakua\n"
"\tĈENO\t\tVera se ĈENO ne estas vakua\n"
"\tĈENO1 = ĈENO2\tVera se la ĉenoj estas egalaj\n"
"\tĈENO1 != ĈENO2\tVera se la ĉenoj ne estas egalaj\n"
"\tĈENO1 < ĈENO2\tVera se ĈENO1 leksikografie antaŭas la\n"
"\t\t\tĉenon ĈENO2\n"
"\tĈENO1 > ĈENO2\tVera se ĈENO1 leksikografie sekvas la\n"
"\t\t\tĉenon ĈENO2\n"
"\n"
"    Diversaj operacioj:\n"
"\n"
"        -o OPCIO        Vera se la ŝelopcio OPCIO estas ŝaltita\n"
"\t! ESPR\t\tVera se la esprimo ESPR estas falsa\n"
"\tESPR1 -a ESPR2\tVera se ambaŭ esprimoj estas veraj\n"
"\tESPR1 -o ESPR2\tVera se ajna el la esprimoj estas vera\n"
"\n"
"\targ1 KP arg2\tAritmetikaj komparoj.  KP estas iu el la\n"
"\t\t\trilatoj -eq, -ne, -lt, -le, -gt, -ge\n"
"\n"
"    La aritmetikaj komparoj liveras veron se arg1 estas respektive\n"
"    egala, neegala, malplia ol, malplia aŭ egala al, plia ol,\n"
"    plia aŭ egala al arg2.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se la rezulto de la komputo de ESPRIMO estas vero;\n"
"    malsukceso, se la rezulto estas malvero aŭ renkontiĝas misa\n"
"    argumento."

# [ arg... ]
#: builtins.c:1299
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Ĉi tiu estas sinonimo de la primitivo „test‟; tamen la lasta\n"
"    argumento devas esti „]‟ fermanta la esprimon komencitan per „[‟."

#: builtins.c:1308
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Vidigu proceztempojn\n"
"\n"
"    Eligu la tempojn akumulitajn de la uzanto kaj de la kerno\n"
"    por la ŝelo kaj ĝiaj procezidoj.\n"
"\n"
"    Elirstato:\n"
"    Ĉiam sukcesa."

# trap [-lp] [[arg] signal_spec ...]
# trap [-lp] [[ARG] SIGNALINDIKO ...]
#: builtins.c:1320
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Kaptu signalojn kaj aliajn eventojn\n"
"\n"
"    Difinu kaj aktivigu traktilojn plenumotajn kiam ŝelo ricevos\n"
"    signalojn aŭ ĉe aliaj kondiĉoj.\n"
"\n"
"    La komando ARG estas legota kaj plenumota kiam la ŝelo ricevos\n"
"    signalon el SIGNALINDIKO.  Se ARG malestas (kaj SIGNALINDIKO\n"
"    konsistas el unu sola signalo) aŭ estas „-‟, ĉiuj indikitaj\n"
"    signaloj rericevas sian komencan valoron.  Se ARG estas vakua\n"
"    ĉeno, la ŝelo mem kaj komandoj el ĝi vokitaj malatentos ĉiujn\n"
"    signalojn de SIGNALINDIKO.\n"
"\n"
"    Se inter la signaloj SIGNALINDIKO estas „EXIT‟ (aŭ 0), tiam ARG de\n"
"    la komando plenumiĝos ĉe la eliro el la ŝelo. Se en SIGNALINDIKO\n"
"    estas „DEBUG‟, ARG plenumiĝos post ĉiu komando.\n"
"\n"
"    Senargumente trap listigas komandojn plenumotajn laŭ ĉiu signalo.\n"
"\n"
"    Opcioj:\n"
"    -l\tlistigu la signalnomojn kun la numeroj\n"
"    -p  vidigu la trap-komandojn por trakti ĉiun SIGNALINDIKOn\n"
"\n"
"    Ĉiu SIGNALINDIKO estas aŭ signalnomo el <signal.h>, aŭ\n"
"    signalnumero.  La signalnomoj estas usklecoblindaj, kaj la\n"
"    prefikso „SIG‟ estas ellasebla.  Signalon S oni povas sendi al la\n"
"    ŝelo per la komando «kill -S $$».\n"
"\n"
"    Elirstato:\n"
"    Sukceso, kondiĉe ke SIGNALINDIKOj kaj la opcioj estas taŭgaj."

# type [-afptP] name [name ...]
# type [-afptP] NOMO [NOMO ...]
#: builtins.c:1352
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Vidigu informon pri tipo de komando\n"
"\n"
"    Por ĉiu NOMO, montru kion ĝi signifus en la pozicio de\n"
"    komadonomo.\n"
"\n"
"    Opcioj:\n"
"    -a\tlistigu ĉiujn lokojn entenantajn plenumeblan dosieron\n"
"        kun koncerna NOMO;  la listo inkludas alinomojn kaj\n"
"        funkciojn, se kaj nur se malestas la opcio  „-p‟\n"
"    -f  ekskludas el la serĉo la ŝelfunkciojn\n"
"    -P\tapliku vojserĉon laŭ PATH por ĉiu NOMO, eĉ se ekzistas tianoma\n"
"        funkcio, primitiva komando aŭ alinomo, kaj liveru la nomon de\n"
"        tiel plenumebla diskdosiero\n"
"    -p\teligu la nomon de dosiero kiu iĝus plenumata;\n"
"        aŭ nenion, se «type -t name» ne eligus „file‟\n"
"    -t\teligu unu vorton, iun el la sekvaj:\n"
"        „alias‟, „keyword‟, „function‟, „builtin‟, „file‟ aŭ „‟ --\n"
"        se NOMO  estas, respektive, alinomo, ŝela ŝlosilvorto,\n"
"        ŝelfunkcio, ŝela primitivo, dosiero aŭ nenio konata\n"
"\n"
"    Argumentoj:\n"
"    NOMO  Esplorenda komandonomo\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se ĉiujn NOMOjn prosperis trovi; malsukceso, se estis\n"
"    netrovitaj."

# ulimit [-SHacdefilmnpqrstuvx] [limit]
# ulimit [-SHacdefilmnpqrstuvx] [LIMO]
#: builtins.c:1383
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Ŝanĝu risurcolimaĵojn de la ŝelo\n"
"\n"
"    La komando „ulimit‟ ebligas mastrumi la risurcojn disponeblajn al\n"
"    la procezoj lanĉataj el la ŝelo (se la operaciumo ebligas tian\n"
"    mastrumadon).\n"
"\n"
"    Opcioj:\n"
"    -S\tŝanĝebla („soft‟) limo\n"
"    -H\tfirma („hard‟) limo\n"
"    -a\teligu ĉiujn kurantajn risurcolimaĵojn\n"
"    -c\tmaksimuma longo de nekropsia dosiero („core‟)\n"
"    -d\tmaksimuma longo de datumsegmento de procezo\n"
"    -e\tmaksimuma viciga prioritato („nice‟)\n"
"    -f\tmaksimuma longo de dosieroj skribataj de la ŝelo kaj ĝiaj idoj\n"
"    -l\tmaksimuma longo de ŝlosebla procezmemoro (mlock)\n"
"    -m\tmaksimuma longo de rezida procezmemoro\n"
"    -n\tmaksimuma nombro de malfermitaj dosiernumeroj\n"
"    -p\tlongo de dukta bufro (pipe)\n"
"    -q\tmaksimuma nombro da bajtoj en atendovicoj de Poziksaj mesaĝoj\n"
"    -r\tmaksimuma prioritato realtempa\n"
"    -s\tmaksimuma longo de stako\n"
"    -t\tmaksimuma tempo ĉefprocesora (en sekundoj)\n"
"    -u\tmaksimuma nombro de procezoj de la uzanto\n"
"    -v\tlongo de la virtuala memoro\n"
"    -x\tmaksimuma nombro de dosierŝlosoj\n"
"\n"
"    Se LIMO estas indikita, ĝia valoro limigas la koncernan risurcon;\n"
"    la specialaj vortoj por LIMO: „soft‟, „hard‟, „unlimited‟\n"
"    signifas, respektive: «la kuranta ŝanĝebla limo», «la kuranta\n"
"    firma limo», «sen limo».  Alie estas eligata la kuranta valoro de\n"
"    la koncerna risurco.  Manko de opcioj implicas -f.\n"
"\n"
"    La valoroj estas en obloj de 1024 bajtoj, krom por la opcio -t,\n"
"    kiu estas en sekundoj; por -p, kiu estas en obloj de 512 bajtoj;\n"
"    kaj por -u, kiu estas sendimensia nombro de procezoj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, kondiĉe ke la opcioj estas taŭgaj kaj ne okazis eraro."

# umask [-p] [-S] [mode]
# umask [-p] [-S] [REĜIMO]
#: builtins.c:1428
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Vidigu aŭ agordu dosierreĝiman maskon\n"
"\n"
"    La dosierkrea masko de la uzanto havu la valoron de la argumento\n"
"    REĜIMO.  Se REĜIMO mankas, eligu la kurantan valoron de la masko.\n"
"\n"
"    Se la argumento REĜIMO komenciĝas per cifero, ĝi estas\n"
"    interpretata kiel okuma nombro; alie, kiel simbola signoĉeno\n"
"    laŭ chmod(1).\n"
"\n"
"    Opcioj:\n"
"    -p\tse REĜIMO malestas, la eligaĵo havu formon taŭgan por enigo\n"
"    -S\tla eligo estu simbola; alie ĝi estas okuma nombro\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se REĜIMO estas nevalida aŭ aperas misa opcio."

# wait [id]
# wait [IND]
#: builtins.c:1448
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for the process identified by ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in the job's pipeline.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Atendu ke laboro finiĝu, kaj liveru elirstaton\n"
"\n"
"    Atendu finiĝon de la procezo indikita per IND (kiu povas esti\n"
"    proceznumero aŭ laborindiko) kaj liveru ĝian elirstaton.  Se IND\n"
"    malestas, atendu ĉiujn aktivajn procezidojn, kaj liveru la \n"
"    elirstaton 0.  Se IND estas laborindiko, atendu ĉiujn procezojn en\n"
"    la dukto de la laboro.\n"
"\n"
"    Elirstato:\n"
"    Tiu de IND; malsukceso, se IND estas nevalida aŭ se renkontiĝas\n"
"    nevalida opcio.<"

# wait [pid]
# wait [PN]
#: builtins.c:1466
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for the specified process and reports its termination status.  If\n"
"    PID is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Atendu ke procezo finiĝu, kaj liveru elirstaton\n"
"\n"
"    Atendu finiĝon de la indikita procezo kaj liveru ĝian elirstaton.\n"
"    Se PN malestas, atendu ĉiujn aktivajn procezidojn, kaj liveru la\n"
"    elirstaton 0.  PN  devas esti proceznumero.\n"
"\n"
"    Elirstato:\n"
"    Tiu de PN; malsukceso, se PN estas nevalida aŭ se renkontiĝas\n"
"    nevalida opcio."

# for NAME [in WORDS ... ] ; do COMMANDS; done
# for NOMO [in VORTOJ ... ] ; do KOMANDOJ; done
#: builtins.c:1481
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn por ĉiu ero de listo\n"
"\n"
"    La iteracio „for‟ plenumas la KOMANDOJn por ĉiu ero de sia listo.\n"
"    Se la parto «in VORTOJ ...;» malestas, «in \"$@\"» estas uzata\n"
"    anstataŭe.  Por ĉiu el la VORTOJ, la NOMO estas valorizata per tiu\n"
"    ero kaj la KOMANDOJ estas plenumataj.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# for (( exp1; exp2; exp3 )); do COMMANDS; done
# for (( ESPR1; ESPR2; ESPR3 )); do KOMANDOJ; done
#: builtins.c:1495
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmetika iteracio\n"
"\n"
"    Ekvivalentas al\n"
"\t(( ESPR1 ))\n"
"\twhile (( ESPR2 )); do\n"
"\t   KOMANDOJ\n"
"\t   (( ESPR3 ))\n"
"\tdone\n"
"    kie ESPR1, ESPR2 kaj ESPR3 estas aritmetikaj esprimoj.  Se iu el\n"
"    ili malestas, 1 estas uzata anstataŭe.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# select NAME [in WORDS ... ;] do COMMANDS; done
# select NONO [in VORTOJ ... ;] do KOMANDOJ; done
#: builtins.c:1513
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Elektu vortojn el listo kaj plenumu komandojn\n"
"\n"
"    Malvolvu VORTOJn, generante liston da vortoj.  Tiujn vortojn eligu\n"
"    en la ĉeferarujon, ĉiu antaŭate de sia numero.  Se „in VORTOJ‟\n"
"    malestas, prenu anstataŭe la enhavon de \"$@\".  Poste eligu la\n"
"    inviton laŭ la variablo PS3 kaj legu linion el la ĉefenigujo.  Se\n"
"    la linio konsistas el numero responda al iu el la vortoj eligitaj,\n"
"    la NOMO ricevu ĝin kiel sian valoron.  Se la linio entenas nenion,\n"
"    ripetu VORTOJn kaj la inviton.  Ĉe la dosierfino la komando\n"
"    finiĝas.  Ajna alia enigaĵo vakuigas la variablon NOMO.  La legita\n"
"    linio konserviĝas en la variablo REPLY.  Plenumu la KOMANDOJn post\n"
"    ĉiu elekto, ĝis renkontiĝos komando de eliro (break).\n"
"\n"
"    Elirstato:\n"
"    Tiu de la laste plenumita komando."

# time [-p] PIPELINE
# time [-p] DUKTO
#: builtins.c:1534
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Raportu tempon konsumitan de dukto\n"
"\n"
"    Plenumu la DUKTOn kaj poste eligu tabelon el la reala tempo,\n"
"    la ĉefprocesora tempo de la uzanto, kaj la ĉefprocesora tempo\n"
"    sistema, konsumitaj por plenumi la DUKTOn, kiam ĝi finĝos.\n"
"\n"
"    Opcio:\n"
"    -p\tprezentu la tempojn laŭ la portebla Poziksa formo\n"
"\n"
"    La variablo TIMEFORMAT difinas la formon de la eligaĵo.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la DUKTO."

# case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac
# case VORTO in [ŜABLONO [| ŜABLONO]...) KOMANDOJ ;;]... esac
#: builtins.c:1551
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn laŭ ŝablonkongruo \n"
"\n"
"    Plenumu KOMANDOJn kondiĉe ke VORTO kongruas kun ŜABLONO.\n"
"    La streko „|‟ servas por disigi ŝablonojn (se pluraj).\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]...
# [ else COMMANDS; ] fi
# if KOMANDOJ; then KOMANDOJ;[ elif KOMANDOJ; then KOMANDOJ; ]...
# [ else KOMANDOJ; ] fi
#: builtins.c:1563
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumu komandojn depende je kondiĉo\n"
"\n"
"    Plenumu la komandojn el «if KOMANDOJ». Se la elirstato estas 0,\n"
"    tiam plenumu la komandojn el «then KOMANDOJ». Alie, laŭvice,\n"
"    plenumu la komandoj el «elif KOMANDOJ», kaj se la elirstato\n"
"    estas 0, plenumu la komandojn de ties «then KOMANDOJ», post kio\n"
"    la komando „if‟ finiĝas.  Alie plenumu la komandojn el\n"
"    «else KOMANDOJ» (se tiaj enestas).  La elirstato estas tiu de la\n"
"    lasta komando plenumita, aŭ 0 se neniu el la kondiĉoj estis vera."

# while COMMANDS; do COMMANDS; done
# while KOMANDOJ; do KOMANDOJ; done
#: builtins.c:1580
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumadu komandojn dum testo sukcesas\n"
"\n"
"    Ripete malvolvu kaj plenumu la KOMANDOJn dum la lasta el la\n"
"    KOMANDOJ de la „while‟-parto liveras elirstaton 0.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita. "

# until COMMANDS; do COMMANDS; done
# until KOMANDOJ; do KOMANDOJ; done
#: builtins.c:1592
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Plenumadu komandojn ĝis kiam testo sukcesos\n"
"\n"
"    Ripete malvolvu kaj plenumu la komandojn dum la lasta el la\n"
"    KOMANDOJ de la „until‟-parto liveras elirstaton alian ol 0.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# coproc [NAME] command [redirections]
# coproc [NOMO] KOMANDO [ALIDIREKTADOJ]
#: builtins.c:1604
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""
"Kreu kunprocezon nomotan NOMO\n"
"\n"
"    Plenumu KOMANDOn nesinkrone, konektinte per dukto ĝiajn ĉefelgujon\n"
"    kaj ĉefengujon al la dosiernumeroj listigitaj en la tabelo NOMO de\n"
"    la kuranta ŝelo ĉe la indicoj 0 kaj 1.  La defaŭlta NOMO estas\n"
"    „COPROC‟.\n"
"\n"
"    Elirstato:\n"
"    Tiu de KOMANDO."

# function name { COMMANDS ; } or name () { COMMANDS ; }
# function NOMO { KOMANDOJ ; }  aŭ  NOMO () { KOMANDOJ ; }
#: builtins.c:1618
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Difinu ŝelfunkcion\n"
"\n"
"    Kreu ŝelfunkcion kun NOMO.  Vokite kiel simpla komando,  NOMO\n"
"    plenumas la KOMANDOJn en la medio de la vokanta ŝelo.  Ĉe voko de\n"
"    NOMO la komandoliniajn argumentojn la funkcio ricevas en  $0...$n,\n"
"    kaj la funkcinomo registriĝas en  $FUNCNAME.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se NOMO estas nurlega."

# grouping_braces: { COMMANDS ; }
# { KOMANDOJ ; }
#: builtins.c:1632
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Arigu komandojn en komandan unuon\n"
"\n"
"    Plenumu la komandojn grupe.  Tiel eblas apliki alidirektadon al\n"
"    tuta grupo da komandoj.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la komando laste plenumita."

# job_spec [&]
# LABORINDIKO [&]
#: builtins.c:1644
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reaktivigu laboron en la fono\n"
"\n"
"    Samkiel la argumento LABORINDIKO en komando „fg‟.  Reaktivigu\n"
"    haltigitan aŭ fonan laboron.  LABORINDIKO povas esti labornomo aŭ\n"
"    labornumero.  Postmetita „&‟ sendas la laboron en la fonon,\n"
"    samkiel se la komando „bg‟ estus aplikita al LABORINDIKO.\n"
"\n"
"    Elirstato:\n"
"    Tiu de la reakivigita laboro."

# (( expression ))
# (( ESPRIMO ))
#: builtins.c:1659
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Komputu aritmetikan esprimon\n"
"\n"
"    La esprimo EXPRESSION komputiĝas laŭ la aritmetikaj reguloj.\n"
"    Ekvivalentas al «let EXPRESSION».\n"
"\n"
"    Elirstato:\n"
"    1, se la rezulto de la ESPRIMO estas 0; 0 aliokaze."

# [[ expression ]]
# [[ ESPRIMO ]]
#: builtins.c:1671
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Plenumu kondiĉkomandon\n"
"\n"
"    Liveras elirstaton 0 aŭ 1 laŭ la rezulto de komputado de kondiĉa\n"
"    ESPRIMO.  Esprimoj konsistas el bazaj esprimoj, kiajn uzas la\n"
"    primitivaĵo „test‟, kaj komponiĝas per sekvaj operacioj:\n"
"\n"
"      ( ESPRIMO )   Liveras la valoron de ESPRIMO\n"
"      ! ESPRIMO\t    Vera, se ESPRIMO estas malvera; alie malvera\n"
"      ESP1 && ESP2  Vera, se veras ambaŭ ESP1 kaj ESP2; alie malvera\n"
"      ESP1 || ESP2  Vera, se veras ajna el ESP1 kaj ESP2; alie malvera\n"
"\n"
"    En la operacioj „==‟ kaj „!=‟ la signoĉeno dekstre de la operacisigno\n"
"    rolas kiel ŝablono, kongrueco al kiu estas testata.  Ĉe la\n"
"    operacio „=~‟ la ĉeno en la dekstra parto rolas kiel regulesprimo\n"
"    por kongruectestado.\n"
"\n"
"    En la operacioj && kaj || la duaj subesprimoj ESP2 ne estas\n"
"    komputataj se ESP1 jam sufiĉas por determini la rezulton.\n"
"\n"
"    Elirstato:\n"
"    0 aŭ 1, laŭ la valoro de ESPRIMO."

# help var
# variables - Names and meanings of some shell variables
#: builtins.c:1697
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nomoj kaj uzoj de komunaj ŝelvariabloj\n"
"\n"
"    BASH_VERSION Informo pri la versio de ĉi tiu Baŝo\n"
"    CDPATH\tListo da dosierujoj (disigitaj per dupunkto) en\n"
"\t\tkiuj argumenta dosierujo de „cd‟ estu serĉata\n"
"    GLOBIGNORE\tListo da ŝablonoj (disigitaj per dupunkto) difinanta\n"
"\t\tdosiernomojn ignorendajn ĉe malvolvo de dosierindikoj\n"
"    HISTFILE\tNomo de la dosiero por via komandohistorio\n"
"    HISTFILESIZE  Maksimuma nombro de linioj konserveblaj en HISTFILE\n"
"    HISTSIZE\tMaksimuma nombro de linioj el komandohistorio\n"
"\t\tatingeblaj el plenumata ŝelo\n"
"    HOME\tPlena dosierindiko pri via hejma dosierujo\n"
"    HOSTNAME\tNomo de la rulanta komputilo\n"
"    HOSTTYPE\tTipo de la ĉefprocesoro rulanta ĉi tiun Baŝon\n"
"    IGNOREEOF\tDeterminas la konduton de la ŝelo kiam ĝi ricevas\n"
"\t\tdosierfinilon (^D, \\004) kiel nuran enigaĵon.  Se ĝi\n"
"\t\tekzistas kaj havas nombran valoron, tiam ĉi tiu\n"
"                indikas, kiom da sinsekvaj dosierfinilojn toleri\n"
"\t\tantaŭ ol la ŝelo finiĝu (defaŭlte, 10).  Sen tia\n"
"\t\tvaloro,  ^D  signifas finon de enigo\n"
"    MACHTYPE\tSignoĉeno priskribanta la komputsistemon rulantan\n"
"\t\tĉi tiun Baŝon\n"
"    MAILCHECK\tKiom ofte (post kiom da sekundoj) Baŝo kontrolu\n"
"\t\tricevon de nova retpoŝta mesaĝo\n"
"    MAILPATH\tListo da dosiernomoj (disigitaj per dupunkto) kiujn\n"
"\t\tBaŝo testu pri nova retpoŝtaĵo\n"
"    OSTYPE\tVersio de Unikso sur kiu ĉi tiu Baŝo ruliĝas\n"
"    PATH\tListo da dosierujoj (disigitaj per dupunkto) kie serĉi\n"
"\t\tkomandojn\n"
"    PROMPT_COMMAND  Komando plenumenda antaŭ ĉiu unuaranga invito\n"
"    PS1\t\tSignoĉeno de la unuaranga invito\n"
"    PS2\t\tSignoĉeno de la duaranga invito\n"
"    PWD\t\tPlena dosierindiko de la kuranta dosierujo\n"
"    SHELLOPTS\tListo da aktivaj ŝelaj opcioj (disigitaj per dupunktoj)\n"
"    TERM\tTipo de la uzata terminalo\n"
"    TIMEFORMAT\tFormato por eligi tempostatistikon per la komando „time‟\n"
"    auto_resume\tSe ne vakua, indikas ke komandan vorton sole aperanta\n"
"\t\ten linio la ŝelo unue serĉu en la listo de haltetintaj\n"
"\t\tlaboroj. Se trovita tie, la laboro iĝu dialoga.\n"
"\t\tLa valoro „exact‟ postulas ekzaktan kongruon de la\n"
"\t\tkomanda vorto kun la komando el la laborlisto. La valoro\n"
"\t\t„substring‟ indikas ke la komanda vorto kongruu kun\n"
"\t\tsubĉeno de la laboro. Ĉia alia valoro indikas ke la\n"
"\t\tkomando estu komenca parto de la labornomo\n"
"    histchars\tSignoj regantaj reuzon de komandohistorio kaj rapidan\n"
"\t\tanstataŭigon. Unue estas la reuziga signo, kutime „!‟.\n"
"\t\tDue estas la signo de „rapida anstataŭigo‟, kutime „^‟.\n"
"\t\tTrie estas la signo de „historia komentilo‟,\n"
"\t\tkutime „#‟\n"
"    HISTIGNORE\tListo da ŝablonoj (disigitaj per dupunkto) difinanta\n"
"\t\tkiujn komandojn konservi en la historilisto\n"

# pushd [-n] [+N | -N | dir]
# pushd [-n] [+N | -N | DOSIERUJO]
#: builtins.c:1754
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Surstakigu dosierujojn\n"
"\n"
"    Surstakigu dosierujon sur la stakon da dosierujoj, aŭ cikle ŝovu\n"
"    la stakon tiel, ke la nova stakpinto estu la kuranta dosierujo.\n"
"    Senargumente, permutu la du plej suprajn dosierujojn de la stako.\n"
"\n"
"    Opcio:\n"
"    -n\tNe ŝanĝu la kurantan dosierujon (ne plenumu cd) surstakigante\n"
"        dosierujon sur la stakon; do, nur la stakon ŝanĝu\n"
"\n"
"    Argumentoj:\n"
"    +N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tmaldekstre en la listo eligebla per „dirs‟, numerante de 0)\n"
"        iĝu la pinta\n"
"\n"
"    -N\tCikle ŝovu la stakon tiel ke la Nª dosierujo (nombrante de\n"
"    \tdekstre en la listo eligebla per „dirs‟, numerante de 0) iĝu\n"
"        la pinta\n"
"\n"
"    DOSIERUJO\n"
"\tsurstakigu la DOSIERUJOn kaj faru ĝin la nova kuranta\n"
"    \tdosierujo labora\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa argumento aŭ se cd malsukcesas."

# popd [-n] [+N | -N]
#: builtins.c:1788
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Elstakigu dosierujojn\n"
"\n"
"    Elstakigu erojn el la stako da dosierujoj.  Senargumente, forigu\n"
"    la pintan dosierujon kaj iru (cd) en la novan pintan dosierujon.\n"
"\n"
"    Opcio:\n"
"    -n\tNe ŝanĝu (cd) la kurantan dosierujon demetante dosierujon el\n"
"        la stako; do, nur la stakon ŝanĝu\n"
"\n"
"    Argumentoj:\n"
"    +N\tForigu la N-an eron de maldekstre de la listo eligebla per\n"
"\t„dirs‟, numerante ekde 0.  Ekz-e: «popd +0» forigas la plej\n"
"\tmaldekstran dosierujon; «popd +1», ĝian najbaron\n"
"\n"
"    -N\tForigu la N-an eron de dekstre de la listo eligebla per\n"
"        „dirs‟, numerante ekde 0.  Ekz-e: «popd -0» forigas la lastan\n"
"\tdosierujon; «popd -1», la antaŭlastan\n"
"\n"
"    Vi povas vidigi la stakon da dosierujoj per la komando „dirs‟.\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa argumento aŭ se cd malsukcesas."

# dirs [-clpv] [+N] [-N]
#: builtins.c:1818
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Listigu dosierujstakon\n"
"\n"
"    Listigu la kurantan dosierujstakon. La dosierujoj trafas en la\n"
"    stakon per la komando „pushd‟ kaj estas forigeblaj per la komando\n"
"    „popd‟.\n"
"\n"
"    Opcioj:\n"
"    -c  viŝu la dosierujstakon forigante el ĝi ĉiujn erojn\n"
"    -l  ne uzu mallongan formon de dosierujnomoj relative al via hejma\n"
"        dosierujo\n"
"    -p  listigu dosierujstakon lokante po unu eron sur linio\n"
"    -v  listigu po unu eron de la dosierujstako en linio, metante\n"
"        antaŭ la dosierujnomo ĝian numeron en la stako \n"
"\n"
"    Argumentoj:\n"
"    +N\teligu la N-an eron (numerante de maldekstre kaj ekde 0) de la\n"
"        listo eligebla per senopcia „dirs‟\n"
"\n"
"    -N\teligu la N-an eron (numerante de dekstre kaj ekde 0) en la\n"
"        listo eligebla per senopcia „dirs‟\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro."

# shopt [-pqsu] [-o] [optname ...]
# shopt [-pqsu] [-o] [OPCINOMO ...]
#: builtins.c:1847
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Ŝaltu kaj malŝaltu ŝelajn opciojn\n"
"\n"
"    Ŝanĝu la staton de ĉiu el la OPCINOMOj.  Sen opciaj argumentoj,\n"
"    listigu ĉiujn ŝelajn opciojn, indikante pri ĉiu el ili, ĉu ĝi\n"
"    estas ŝaltita.\n"
"\n"
"    Opcioj:\n"
"    -o  limigu OPCINOMOJn je tiuj difinitaj por uzo per «set -o»\n"
"    -p  eligu ĉiun ŝelan opcion indikante ĉu ĝi estas ŝaltita\n"
"    -q  silentigu eligon\n"
"    -s  ŝaltu (aktivigu) ĉiun el la OPCINOMOj\n"
"    -u  malŝaltu (malaktivigu) ĉiun el la OPCINOMOj\n"
"\n"
"    Elirstato:\n"
"    Sukceso, se OPCINOMO estas ŝaltita; malsukceso, se aperas misa\n"
"    opcio, aŭ se OPCINOMO estas malŝaltita.\n"
"    "

# printf [-v var] format [arguments]
# printf [-v VAR] FORMATO [ARGUMENTOJ]
#: builtins.c:1868
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf"
"(1)\n"
"    and printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Aranĝu kaj eligu argumentojn argumentojn laŭ formato\n"
"\n"
"    Opcio:\n"
"    -v VAR  eligu en ŝelvariablon VAR anstataŭ en la ĉefeligujon\n"
"\n"
"    FORMATO estas signoĉeno entenanta 3 tipojn da objektoj:\n"
"    ordinaraj signoj, simple kopiataj en la ĉefeligujon;\n"
"    eskapsekvencoj por signo, konvertataj kaj kopiataj en la ĉefeligujon; \n"
"    kaj formataj specifoj, ĉiu el kiuj kaŭzas eligon de vica argumento.\n"
"\n"
"    Aldone al la normaj specifiloj laŭ „printf(1)‟ kaj „printf(3)‟,\n"
"    „%b‟ igas malvolvi deklivajn (\\) eskapsekvencojn en sia argumento, kaj\n"
"    „%q‟ ordonas ke la argumento eliĝu en formo taŭga por ŝela re-enigo.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro pri skribo aŭ\n"
"    valorizo."

# complete [-abcdefgjksuv] [-pr] [-o OPCIO] [-A AGO] [-G GLOBŜAB]
# 	 [-W VORTLISTO]  [-F FUNKCIO] [-C KOMANDO] [-X FILTROŜAB]
#          [-P PREFIKSO] [-S SUFFIKSO] [NOMO ...]
#: builtins.c:1895
#, fuzzy
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \tcompletion attempted on a blank line\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.  The -D option takes\n"
"    precedence over -E.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Difinu, kiel Readline kompletigu argumentojn\n"
"\n"
"    Por ĉiu NOMO difinu, kiel la argumentoj estu kompletigotaj.  Se\n"
"    nenia opcio estas donita, eligu la aktualajn \n"
"    kompletigoregulojn en formo reuzebla por enigo en la ŝelon.\n"
"\n"
"    Opcioj:\n"
"    -p\tkompletigoregulojn en formo reuzebla por enigo en la ŝelon\n"
"    -r\tforigu la kompletigoregulon por ĉiu NOMO, aŭ, se nenia NOMO\n"
"\testas donita, ĉiujn kompletigoregulojn\n"
"\n"
"    Ĉe provo kompletigi la agoj aplikiĝas laŭ la ordo de majusklaj\n"
"    opcioj en la ĉi-supre listo.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se misa opcio estas donita, aŭ eraro okazis."

# compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat]
# 	[-W wordlist] [-P prefix] [-S suffix] [-X filterpat]
# 	[-F function] [-C command] [word]
# compgen [-abcdefgjksuv] [-o OPCIO]  [-A AGO] [-G GLOBŜAB]
# 	[-W vORTLISTO]  [-F FUNKCIO] [-C KOMANDO] [-X FILTROŜAB]
# 	[-P PREFIKSO] [-S SUFFIKSO] [VORTO]
#: builtins.c:1923
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Montru la eblajn kompletigojn depende je la opcioj\n"
"\n"
"    Destinita por uzo en ŝelfunkcio generanta eblajn kompletigojn.  Se\n"
"    la eventuala argumento VORTO estas donita, generu ĝiajn kongruaĵojn.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ okazas eraro."

# compopt [-o|+o option] [name ...]
# compopt [-o|+o OPCIO] [NOMO ...]
#: builtins.c:1938
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently begin executed.  If no OPTIONs are givenm, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Ŝanĝu aŭ vidigu opciojn pri kompletigo\n"
"\n"
"    Ŝanĝu la kompletigajn opciojn por ĉiu NOMO, aŭ - se nenia NOMO\n"
"    estas indikita - la nune plenumatan kompletigon.  Se nenia OPCIO\n"
"    estas donita, eligu la kompletigajn opciojn por ĉiu NOMO aŭ la\n"
"    kurantan kompletigan regularon.\n"
"\n"
"    Opcioj:\n"
"    -o OPCIO  Ŝaltu kompletigan OPCIOn por ĉiu NOMO\n"
"\n"
"    Uzante «+o» anstataŭ «-o» oni povas malŝalti la indikitan OPCIOn.\n"
"\n"
"    Argumentoj:\n"
"    Ĉiu NOMO indikas komandon, por kiu kompletiga regulo devas esti\n"
"    jam difinita per la primitivaĵo „complete‟.  Se nenia NOMO estas\n"
"    donita, tiam la komandon compopt devas voki funkcio generanta, kaj\n"
"    ĝuste la opcioj por ĉi tiu nune plenumata generilo de kompletigoj\n"
"    estu ŝanĝitaj.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio, aŭ por NOMO mankas difino de\n"
"    kompletiga regulo."

# mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback]
# 	[-c quantum] [array]
# mapfile [-n NOMBRILO] [-O ORIGINO] [-s NOMBRILO] [-t] [-u DN] [-C RETROVOKO]
# 	[-c KVANTO] [TABELO] 
#: builtins.c:1968
#, fuzzy
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned as an additional argument.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Legu liniojn el la ĉefenigujo en tabelvariablon\n"
"\n"
"    Legu liniojn el la ĉefenigujo en la variablon TABELO, aŭ el la\n"
"    dosiernumero DN, se ĉeestas la opcio „-u‟.  La defaŭlta tabelo\n"
"    estas la variablo MAPFILE.\n"
"\n"
"    Opcioj:\n"
"    -n NOMBRILO Kopiu maksimume NOMBRILOn da linioj.  Se NOMBRILO\n"
"                estas 0, kopiu ĉiujn liniojn\n"
"    -O ORIGINO  Komencu valorizi la TABELOn ekde la indekso ORIGINO.\n"
"                La defaŭlta origino estas 0.\n"
"    -s NOMBRILO Ignoru NOMBRILOn da unuaj linioj\n"
"    -t          Forigu la vostan linifinilon el ĉiu legita linio\n"
"    -u DN       Legu per la dosiernunero DN anstataŭ el la ĉefenigujo\n"
"    -C RETROVOKO  Plenumu RETROVOKOn post ĉiu KVANTO da legitaj linioj\n"
"    -c KVANTO\tPo kiom da linioj legi inter sinsekvaj RETROVOKOj\n"
"\n"
"    Argumento:\n"
"    TABELO\tNomo de tabelvariablo uzota por la legotaj datumoj\n"
"\n"
"    Se „-C‟ aperas sen „-c‟, la defaŭlta kvanto estas 5000.  Ĉe\n"
"    komputo de RETROVOKO ĉi tiu ricevas la indicon de la sekva\n"
"    elemento de la tabelo kiel kroman argumenton.\n"
"\n"
"    Se mankas malimplica ORIGINO, mapfile viŝos la TABELOn antaŭ\n"
"    valorizi ĝin.\n"
"\n"
"    Elirstato:\n"
"    Sukceso, krom se aperas misa opcio aŭ TABELO estas nurlega."

# readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback]
# 	  [-c quantum] [array]
#: builtins.c:2001
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Legu liniojn el la ĉefenigujo en tabelvariablon\n"
"\n"
"    Sinonimo de „mapfile‟."

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc(): Ne povas reokupi %lu bajtojn (%lu bajtoj disponigitaj)."

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc: Ne eblas reokupi %lu bajtojn."

# XXX: fatal_error
#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "xrealloc: %s:%d: ne eblas reokupi %lu bajtojn (%lu bajtoj disponigitaj)"
