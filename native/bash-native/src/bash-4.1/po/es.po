# Mensajes en español para GNU bash-4.0.
# Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
# This file is distributed under the same license as the bash package.
# Cristian Othón Martínez Vera <cfuga@itam.mx>, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU bash 4.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2009-12-30 08:25-0500\n"
"PO-Revision-Date: 2009-03-19 19:34-0600\n"
"Last-Translator: Cristian Othón Martínez Vera <cfuga@itam.mx>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=ISO-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: arrayfunc.c:50
msgid "bad array subscript"
msgstr "subíndice de matriz incorrecto"

#: arrayfunc.c:313 builtins/declare.def:481
#, c-format
msgid "%s: cannot convert indexed to associative array"
msgstr "%s: no se puede convertir la matriz de indizada a asociativa"

#: arrayfunc.c:480
#, c-format
msgid "%s: invalid associative array key"
msgstr "%s: índice de matriz asociativa inválido"

#: arrayfunc.c:482
#, c-format
msgid "%s: cannot assign to non-numeric index"
msgstr "%s: no se puede asignar a un índice que no es numérico"

#: arrayfunc.c:518
#, c-format
msgid "%s: %s: must use subscript when assigning associative array"
msgstr "%s: %s: se debe usar un subíndice al asignar a una matriz asociativa"

#: bashhist.c:383
#, c-format
msgid "%s: cannot create: %s"
msgstr "%s: no se puede crear: %s"

#: bashline.c:3457
msgid "bash_execute_unix_command: cannot find keymap for command"
msgstr ""
"bash_execute_unix_command: no se puede encontrar la combinación de teclas "
"para la orden"

#: bashline.c:3543
#, c-format
msgid "%s: first non-whitespace character is not `\"'"
msgstr "%s: el primer carácter que no es espacio en blanco no es `\"'"

#: bashline.c:3572
#, c-format
msgid "no closing `%c' in %s"
msgstr "no hay un `%c' que cierre en %s"

#: bashline.c:3606
#, c-format
msgid "%s: missing colon separator"
msgstr "%s: falta un `:' separador"

#: builtins/alias.def:132
#, fuzzy, c-format
msgid "`%s': invalid alias name"
msgstr "`%s': nombre de combinación de teclas inválido"

#: builtins/bind.def:120 builtins/bind.def:123
msgid "line editing not enabled"
msgstr "no se activó la edición de línea"

#: builtins/bind.def:206
#, c-format
msgid "`%s': invalid keymap name"
msgstr "`%s': nombre de combinación de teclas inválido"

#: builtins/bind.def:245
#, c-format
msgid "%s: cannot read: %s"
msgstr "%s: no se puede leer: %s"

#: builtins/bind.def:260
#, c-format
msgid "`%s': cannot unbind"
msgstr "%s: no se puede borrar la asignación"

#: builtins/bind.def:295 builtins/bind.def:325
#, c-format
msgid "`%s': unknown function name"
msgstr "`%s': nombre de función desconocido"

#: builtins/bind.def:303
#, c-format
msgid "%s is not bound to any keys.\n"
msgstr "%s no está asignado a ninguna tecla.\n"

#: builtins/bind.def:307
#, c-format
msgid "%s can be invoked via "
msgstr "%s se puede invocar a través de "

#: builtins/break.def:77 builtins/break.def:117
msgid "loop count"
msgstr "cuenta de ciclo"

#: builtins/break.def:137
msgid "only meaningful in a `for', `while', or `until' loop"
msgstr "sólo tiene significado en un ciclo `for', `while' o `until'"

#: builtins/caller.def:133
msgid ""
"Returns the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns "
msgstr ""
"Devuelve el contexto de la llamada a subrutina actual.\n"
"    \n"
"    Sin EXPR, devuelve "

#: builtins/caller.def:135
msgid ""
".  With EXPR, returns\n"
"    "
msgstr ""

#: builtins/caller.def:136
msgid ""
"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0."
msgstr ""

#: builtins/cd.def:215
msgid "HOME not set"
msgstr "HOME no está definido"

#: builtins/cd.def:227
msgid "OLDPWD not set"
msgstr "OLDPWD no está definido"

#: builtins/common.c:101
#, c-format
msgid "line %d: "
msgstr "línea %d: "

#: builtins/common.c:139 error.c:261
#, c-format
msgid "warning: "
msgstr "aviso: "

#: builtins/common.c:153
#, c-format
msgid "%s: usage: "
msgstr "%s: uso: "

#: builtins/common.c:166 test.c:827
msgid "too many arguments"
msgstr "demasiados argumentos"

#: builtins/common.c:191 shell.c:499 shell.c:782
#, c-format
msgid "%s: option requires an argument"
msgstr "%s: la opción requiere un argumento"

#: builtins/common.c:198
#, c-format
msgid "%s: numeric argument required"
msgstr "%s: se requiere un argumento numérico"

#: builtins/common.c:205
#, c-format
msgid "%s: not found"
msgstr "%s: no se encontró"

#: builtins/common.c:214 shell.c:795
#, c-format
msgid "%s: invalid option"
msgstr "%s: opción inválida"

#: builtins/common.c:221
#, c-format
msgid "%s: invalid option name"
msgstr "%s: nombre de opción inválido"

#: builtins/common.c:228 general.c:231 general.c:236
#, c-format
msgid "`%s': not a valid identifier"
msgstr "`%s': no es un identificador válido"

#: builtins/common.c:238
msgid "invalid octal number"
msgstr "número octal inválido"

#: builtins/common.c:240
msgid "invalid hex number"
msgstr "número hexadecimal inválido"

#: builtins/common.c:242 expr.c:1256
msgid "invalid number"
msgstr "número inválido"

#: builtins/common.c:250
#, c-format
msgid "%s: invalid signal specification"
msgstr "%s: especificación de señal inválida"

#: builtins/common.c:257
#, c-format
msgid "`%s': not a pid or valid job spec"
msgstr "`%s': no es un pid o una especificación válida de trabajo"

#: builtins/common.c:264 error.c:454
#, c-format
msgid "%s: readonly variable"
msgstr "%s: variable de sólo lectura"

#: builtins/common.c:272
#, c-format
msgid "%s: %s out of range"
msgstr "%s: %s fuera de rango"

#: builtins/common.c:272 builtins/common.c:274
msgid "argument"
msgstr "argumento"

#: builtins/common.c:274
#, c-format
msgid "%s out of range"
msgstr "%s fuera de rango"

#: builtins/common.c:282
#, c-format
msgid "%s: no such job"
msgstr "%s: no existe ese trabajo"

#: builtins/common.c:290
#, c-format
msgid "%s: no job control"
msgstr "%s: no hay control de trabajos"

#: builtins/common.c:292
msgid "no job control"
msgstr "no hay control de trabajos"

#: builtins/common.c:302
#, c-format
msgid "%s: restricted"
msgstr "%s: restringido"

#: builtins/common.c:304
msgid "restricted"
msgstr "restringido"

#: builtins/common.c:312
#, c-format
msgid "%s: not a shell builtin"
msgstr "%s: no es una orden interna del shell"

#: builtins/common.c:321
#, c-format
msgid "write error: %s"
msgstr "error de escritura: %s"

#: builtins/common.c:329
#, c-format
msgid "error setting terminal attributes: %s"
msgstr "error al establecer los atributos de la terminal: %s"

#: builtins/common.c:331
#, c-format
msgid "error getting terminal attributes: %s"
msgstr "error al obtener los atributos de la terminal: %s"

#: builtins/common.c:563
#, c-format
msgid "%s: error retrieving current directory: %s: %s\n"
msgstr "%s: error al obtener el directorio actual: %s: %s\n"

#: builtins/common.c:629 builtins/common.c:631
#, c-format
msgid "%s: ambiguous job spec"
msgstr "%s: especificación de trabajo ambigua"

#: builtins/complete.def:276
#, c-format
msgid "%s: invalid action name"
msgstr "%s: nombre de acción inválido"

#: builtins/complete.def:449 builtins/complete.def:644
#: builtins/complete.def:853
#, c-format
msgid "%s: no completion specification"
msgstr "%s: no hay completado de especificación"

#: builtins/complete.def:696
msgid "warning: -F option may not work as you expect"
msgstr "aviso: es posible que la opción -F no funcione como se espera"

#: builtins/complete.def:698
msgid "warning: -C option may not work as you expect"
msgstr "aviso: es posible que la opción -C no funcione como se espera"

#: builtins/complete.def:826
msgid "not currently executing completion function"
msgstr "no se está ejecutando la función de completado"

# sólo se puede usar. sv
# De acuerdo. cfuga
#: builtins/declare.def:122
msgid "can only be used in a function"
msgstr "sólo se puede usar dentro de una función"

#: builtins/declare.def:360
msgid "cannot use `-f' to make functions"
msgstr "no se puede usar `-f' para hacer funciones"

#: builtins/declare.def:372 execute_cmd.c:4937
#, c-format
msgid "%s: readonly function"
msgstr "%s: función de sólo lectura"

#: builtins/declare.def:468
#, c-format
msgid "%s: cannot destroy array variables in this way"
msgstr "%s: no se pueden destruir variables de matriz de esta forma"

#: builtins/declare.def:475
#, c-format
msgid "%s: cannot convert associative to indexed array"
msgstr "%s: no se puede convertir una matriz asociativa a indizada"

#: builtins/enable.def:137 builtins/enable.def:145
msgid "dynamic loading not available"
msgstr "la carga dinámica no está disponible"

#: builtins/enable.def:312
#, c-format
msgid "cannot open shared object %s: %s"
msgstr "no se puede abrir el objeto compartido %s: %s"

#: builtins/enable.def:335
#, c-format
msgid "cannot find %s in shared object %s: %s"
msgstr "no se puede encontrar %s en el objeto compartido %s: %s"

#: builtins/enable.def:459
#, c-format
msgid "%s: not dynamically loaded"
msgstr "%s: no se cargó dinámicamente"

#: builtins/enable.def:474
#, c-format
msgid "%s: cannot delete: %s"
msgstr "%s: no se puede borrar: %s"

#: builtins/evalfile.c:134 builtins/hash.def:169 execute_cmd.c:4794
#: shell.c:1452
#, c-format
msgid "%s: is a directory"
msgstr "%s: es un directorio"

#: builtins/evalfile.c:139
#, c-format
msgid "%s: not a regular file"
msgstr "%s: no es un fichero regular"

#: builtins/evalfile.c:147
#, c-format
msgid "%s: file is too large"
msgstr "%s: el fichero es demasiado grande"

# file=fichero. archive=archivo. Si no, es imposible traducir tar. sv
# De acuerdo. Corregido en todo el fichero. cfuga
#: builtins/evalfile.c:185 builtins/evalfile.c:203 execute_cmd.c:4864
#: shell.c:1462
#, c-format
msgid "%s: cannot execute binary file"
msgstr "%s: no se puede ejecutar el fichero binario"

#: builtins/exec.def:212
#, c-format
msgid "%s: cannot execute: %s"
msgstr "%s: no se puede ejecutar: %s"

#: builtins/exit.def:65
#, c-format
msgid "logout\n"
msgstr "logout\n"

#: builtins/exit.def:88
msgid "not login shell: use `exit'"
msgstr "no es un shell de entrada: use `exit'"

#: builtins/exit.def:120
#, c-format
msgid "There are stopped jobs.\n"
msgstr "Hay trabajos detenidos.\n"

#: builtins/exit.def:122
#, c-format
msgid "There are running jobs.\n"
msgstr "Hay trabajos en ejecución.\n"

#: builtins/fc.def:262
msgid "no command found"
msgstr "no se encontró la orden"

#: builtins/fc.def:349
msgid "history specification"
msgstr "especificación de historia"

#: builtins/fc.def:370
#, c-format
msgid "%s: cannot open temp file: %s"
msgstr "%s: no se puede abrir el fichero temporal: %s"

#: builtins/fg_bg.def:149 builtins/jobs.def:282
msgid "current"
msgstr "actual"

#: builtins/fg_bg.def:158
#, c-format
msgid "job %d started without job control"
msgstr "el trabajo %d inició sin control de trabajo"

#: builtins/getopt.c:110
#, c-format
msgid "%s: illegal option -- %c\n"
msgstr "%s: opción ilegal -- %c\n"

#: builtins/getopt.c:111
#, c-format
msgid "%s: option requires an argument -- %c\n"
msgstr "%s: la opción requiere un argumento -- %c\n"

#: builtins/hash.def:92
msgid "hashing disabled"
msgstr "asociación desactivada"

#: builtins/hash.def:138
#, c-format
msgid "%s: hash table empty\n"
msgstr "%s: tabla de asociación vacía\n"

#: builtins/hash.def:244
#, c-format
msgid "hits\tcommand\n"
msgstr "coinc\torden\n"

#: builtins/help.def:130
#, c-format
msgid "Shell commands matching keyword `"
msgid_plural "Shell commands matching keywords `"
msgstr[0] "Orden del shell que coinciden con la palabra `"
msgstr[1] "Órdenes del shell que coinciden con la palabra `"

#: builtins/help.def:168
#, c-format
msgid ""
"no help topics match `%s'.  Try `help help' or `man -k %s' or `info %s'."
msgstr ""
"no hay temas de ayuda que coincidan con `%s'.  Pruebe `help help' o `man -k %"
"s' o `info %s'."

#: builtins/help.def:185
#, c-format
msgid "%s: cannot open: %s"
msgstr "%s: no se puede abrir: %s"

#: builtins/help.def:337
#, c-format
msgid ""
"These shell commands are defined internally.  Type `help' to see this list.\n"
"Type `help name' to find out more about the function `name'.\n"
"Use `info bash' to find out more about the shell in general.\n"
"Use `man -k' or `info' to find out more about commands not in this list.\n"
"\n"
"A star (*) next to a name means that the command is disabled.\n"
"\n"
msgstr ""
"Estas órdenes del shell están definidas internamente.  Teclee `help' para\n"
"ver esta lista.\n"
"Teclee `help nombre' para saber más sobre la función `nombre'.\n"
"Use `info bash' para saber más sobre el shell en general.\n"
"Use `man -k' o `info' para saber más sobre las órdenes que no están en\n"
"esta lista.\n"
"\n"
"Un asterisco (*) junto a un nombre significa que el comando está "
"desactivado.\n"
"\n"

#: builtins/history.def:154
msgid "cannot use more than one of -anrw"
msgstr "no se puede usar más de uno de -anrw"

#: builtins/history.def:186
msgid "history position"
msgstr "posición en la historia"

#: builtins/history.def:365
#, c-format
msgid "%s: history expansion failed"
msgstr "%s: falló la expansión de la historia"

#: builtins/inlib.def:71
#, c-format
msgid "%s: inlib failed"
msgstr "%s: falló inlib"

#: builtins/jobs.def:109
msgid "no other options allowed with `-x'"
msgstr "no se permiten otras opciones con `-x'"

#: builtins/kill.def:200
#, c-format
msgid "%s: arguments must be process or job IDs"
msgstr "%s: los argumentos deben ser procesos o IDs de trabajos"

#: builtins/kill.def:263
msgid "Unknown error"
msgstr "Error desconocido"

#: builtins/let.def:95 builtins/let.def:120 expr.c:501 expr.c:516
msgid "expression expected"
msgstr "se esperaba una expresión"

#: builtins/mapfile.def:165
#, fuzzy, c-format
msgid "%s: not an indexed array"
msgstr "%s: no es una variable de matriz"

#: builtins/mapfile.def:249 builtins/read.def:279
#, c-format
msgid "%s: invalid file descriptor specification"
msgstr "%s: especificación de descriptor de fichero inválida"

#: builtins/mapfile.def:257 builtins/read.def:286
#, c-format
msgid "%d: invalid file descriptor: %s"
msgstr "%d: descriptor de fichero inválido: %s"

#: builtins/mapfile.def:266 builtins/mapfile.def:304
#, c-format
msgid "%s: invalid line count"
msgstr "%s: cuenta de líneas inválida"

#: builtins/mapfile.def:277
#, c-format
msgid "%s: invalid array origin"
msgstr "%s: origen de matriz inválido"

#: builtins/mapfile.def:294
#, c-format
msgid "%s: invalid callback quantum"
msgstr "%s: quantum de llamada inválido"

#: builtins/mapfile.def:326
msgid "empty array variable name"
msgstr "nombre de variable de matriz vacío"

#: builtins/mapfile.def:347
msgid "array variable support required"
msgstr "se requiere el soporte de variable de matriz"

#: builtins/printf.def:374
#, c-format
msgid "`%s': missing format character"
msgstr "`%s': falta el carácter de formato"

#: builtins/printf.def:551
#, c-format
msgid "`%c': invalid format character"
msgstr "`%c': carácter de formato inválido"

#: builtins/printf.def:578
#, c-format
msgid "warning: %s: %s"
msgstr "aviso: %s: %s"

#: builtins/printf.def:757
msgid "missing hex digit for \\x"
msgstr "falta el dígito hexadecimal para \\x"

#: builtins/pushd.def:195
msgid "no other directory"
msgstr "no hay otro directorio"

#: builtins/pushd.def:462
msgid "<no current directory>"
msgstr "<no hay directorio actual>"

#: builtins/pushd.def:506
msgid "directory stack empty"
msgstr "la pila de directorios está vacía"

#: builtins/pushd.def:508
msgid "directory stack index"
msgstr "índice de la pila de directorios"

#: builtins/pushd.def:683
msgid ""
"Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"\tdirs when invoked without options, starting with zero."
msgstr ""
"Muestra la lista de directorios actualmente grabados.  Los directorios\n"
"    se guardan en la lista con la orden `pushd'; pueden ir saliendo de\n"
"    la lista con la orden `popd'.\n"
"    \n"
"    Opciones:\n"
"      -c\tlimpia la pila de directorios, eliminando todos los elementos\n"
"      -l\tno muestra las versiones con prefijo de tilde de los directorios\n"
"    \trelativos a su directorio inicial\n"
"      -p\tmuestra la pila de directorios con una entrada por línea\n"
"      -v\tmuestra la pila de directorios con una entrada por línea con\n"
"    \tsu posición en la pila como prefijo\n"
"    \n"
"    Argumentos:\n"
"      +N\tMuestra la N-ésima entrada contando desde la izquierda de\n"
"    \tla lista mostrada por dirs cuando se llama sin opciones,\n"
"    \tempezando desde cero.\n"
"    \n"
"      -N\tMuestra la N-ésima entrada contando desde la derecha de\n"
"\tla lista mostrada por dirs cuando se llama sin opciones,\n"
"\tempezando desde cero."

#: builtins/pushd.def:705
msgid ""
"Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Agrega un directorio al tope de la pila de directorios, o rota\n"
"    la pila, haciendo que el nuevo tope de la pila sea el\n"
"    directorio de trabajo actual.  Sin argumentos, intercambia\n"
"    los dos directorios del tope.\n"
"    \n"
"    Argumentos:\n"
"    +N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tde la izquierda de la lista mostrada por `dirs',\n"
"    \tcomenzando desde cero) esté en el tope.\n"
"    -N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tde la derecha de la lista mostrada por `dirs',\n"
"    \tcomenzando desde cero) esté en el tope.\n"
"    \n"
"     dir\tagrega DIR a la pila de directorios en el tope,\n"
"    \thaciéndolo el nuevo directorio de trabajo actual.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios."

#: builtins/pushd.def:730
msgid ""
"Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack."
msgstr ""
"Borra entradas de la pila de directorios.  Sin argumentos, borra\n"
"    directorio del tope de la pila, y cambia al nuevo directorio tope.\n"
"    \n"
"    Opciones:\n"
"      -n\tsuprime el cambio normal de directorio cuando se borran\n"
"    \tdirectorios de la pila, así sólo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"      +N\tBorra la N-ésima entrada contando de la izquierda de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero.\n"
"    \tPor ejemplo: `popd +0' borra el primer directorio, `popd +1'\n"
"    \tel segundo.\n"
"    \n"
"      -N\tBorra la N-ésima entrada contando de la derecha de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero.\n"
"    \tPor ejemplo: `popd -0' borra el último directorio, `popd -1'\n"
"    \tel penúltimo.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios."

#: builtins/read.def:252
#, c-format
msgid "%s: invalid timeout specification"
msgstr "%s: especificación de tiempo de expiración inválida"

#: builtins/read.def:588
#, c-format
msgid "read error: %d: %s"
msgstr "error de lectura: %d: %s"

#: builtins/return.def:73
msgid "can only `return' from a function or sourced script"
msgstr ""
"sólo se puede usar `return' en una función o un guión leído con `source'"

#: builtins/set.def:768
msgid "cannot simultaneously unset a function and a variable"
msgstr "no se puede borrar al mismo tiempo una función y una variable"

#: builtins/set.def:805
#, c-format
msgid "%s: cannot unset"
msgstr "%s: no se puede borrar"

#: builtins/set.def:812
#, c-format
msgid "%s: cannot unset: readonly %s"
msgstr "%s: no se puede borrar: %s es de solo lectura"

#: builtins/set.def:823
#, c-format
msgid "%s: not an array variable"
msgstr "%s: no es una variable de matriz"

#: builtins/setattr.def:186
#, c-format
msgid "%s: not a function"
msgstr "%s: no es una función"

#: builtins/shift.def:71 builtins/shift.def:77
msgid "shift count"
msgstr "cuenta de shift"

#: builtins/shopt.def:260
msgid "cannot set and unset shell options simultaneously"
msgstr "no se pueden activar y desactivar opciones del shell simultáneamente"

#: builtins/shopt.def:325
#, c-format
msgid "%s: invalid shell option name"
msgstr "%s: nombre de opción del shell inválido"

#: builtins/source.def:128
msgid "filename argument required"
msgstr "se requiere un argumento de nombre de fichero"

#: builtins/source.def:153
#, c-format
msgid "%s: file not found"
msgstr "%s: no se encontró el fichero"

#: builtins/suspend.def:101
msgid "cannot suspend"
msgstr "no se puede suspender"

#: builtins/suspend.def:111
msgid "cannot suspend a login shell"
msgstr "no se puede suspender un shell de entrada"

#: builtins/type.def:234
#, c-format
msgid "%s is aliased to `%s'\n"
msgstr "%s es un alias de `%s'\n"

#: builtins/type.def:255
#, c-format
msgid "%s is a shell keyword\n"
msgstr "%s es una palabra clave del shell\n"

#: builtins/type.def:274
#, c-format
msgid "%s is a function\n"
msgstr "%s: es una función\n"

#: builtins/type.def:296
#, c-format
msgid "%s is a shell builtin\n"
msgstr "%s es una orden interna del shell\n"

#: builtins/type.def:317 builtins/type.def:391
#, c-format
msgid "%s is %s\n"
msgstr "%s is %s\n"

#: builtins/type.def:337
#, c-format
msgid "%s is hashed (%s)\n"
msgstr "%s está asociado (%s)\n"

#: builtins/ulimit.def:372
#, c-format
msgid "%s: invalid limit argument"
msgstr "%s: límite de argumento inválido"

#: builtins/ulimit.def:398
#, c-format
msgid "`%c': bad command"
msgstr "`%c': orden errónea"

#: builtins/ulimit.def:427
#, c-format
msgid "%s: cannot get limit: %s"
msgstr "%s: no se puede obtener el límite: %s"

#: builtins/ulimit.def:453
msgid "limit"
msgstr "límite"

#: builtins/ulimit.def:465 builtins/ulimit.def:765
#, c-format
msgid "%s: cannot modify limit: %s"
msgstr "%s: no se puede modificar el límite: %s"

#: builtins/umask.def:118
msgid "octal number"
msgstr "número octal"

#: builtins/umask.def:231
#, c-format
msgid "`%c': invalid symbolic mode operator"
msgstr "`%c': operador de modo simbólico inválido"

#: builtins/umask.def:286
#, c-format
msgid "`%c': invalid symbolic mode character"
msgstr "`%c': carácter de modo simbólico inválido"

#: error.c:90 error.c:321 error.c:323 error.c:325
msgid " line "
msgstr " línea "

#: error.c:165
#, c-format
msgid "last command: %s\n"
msgstr "última orden: %s\n"

#: error.c:173
#, c-format
msgid "Aborting..."
msgstr "Abortando..."

#: error.c:406
msgid "unknown command error"
msgstr "error de orden desconocido"

#: error.c:407
msgid "bad command type"
msgstr "tipo de orden erróneo"

#: error.c:408
msgid "bad connector"
msgstr "conector erróneo"

#: error.c:409
msgid "bad jump"
msgstr "salto erróneo"

#: error.c:447
#, c-format
msgid "%s: unbound variable"
msgstr "%s: variable sin asignar"

#: eval.c:181
#, c-format
msgid "timed out waiting for input: auto-logout\n"
msgstr "ha expirado mientras esperaba alguna entrada: auto-logout\n"

#: execute_cmd.c:497
#, c-format
msgid "cannot redirect standard input from /dev/null: %s"
msgstr "no se puede redirigir la salida estándar desde /dev/null: %s"

#: execute_cmd.c:1162
#, c-format
msgid "TIMEFORMAT: `%c': invalid format character"
msgstr "TIMEFORMAT: `%c': carácter de formato inválido"

#: execute_cmd.c:2075
msgid "pipe error"
msgstr "error de tubería"

#: execute_cmd.c:4481
#, c-format
msgid "%s: restricted: cannot specify `/' in command names"
msgstr "%s: restringido: no se puede especificar `/' en nombres de órdenes"

#: execute_cmd.c:4572
#, c-format
msgid "%s: command not found"
msgstr "%s: no se encontró la orden"

#: execute_cmd.c:4827
#, c-format
msgid "%s: %s: bad interpreter"
msgstr "%s: %s: intérprete erróneo"

#: execute_cmd.c:4976
#, c-format
msgid "cannot duplicate fd %d to fd %d"
msgstr "no se puede duplicar el df %d al df %d"

#: expr.c:241
msgid "expression recursion level exceeded"
msgstr "se ha excedido el nivel de recursión de la expresión"

#: expr.c:265
msgid "recursion stack underflow"
msgstr "desbordamiento de la base de la pila de recursión"

#: expr.c:379
msgid "syntax error in expression"
msgstr "error sintáctico en la expresión"

#: expr.c:419
msgid "attempted assignment to non-variable"
msgstr "se intentó asignar a algo que no es una variable"

#: expr.c:440 expr.c:445 expr.c:756
msgid "division by 0"
msgstr "división por 0"

# token en bison fue traducido como terminal. ¿Lo traducimos igual aquí
# o lo dejamos como 'unidad' o 'elemento'? cfuga
#: expr.c:471
msgid "bug: bad expassign token"
msgstr "bicho: elemento de asignación de expresión erróneo"

#: expr.c:513
msgid "`:' expected for conditional expression"
msgstr "se esperaba `:' para la expresión condicional"

#: expr.c:781
msgid "exponent less than 0"
msgstr "exponente menor que 0"

#: expr.c:826
msgid "identifier expected after pre-increment or pre-decrement"
msgstr ""
"se esperaba un identificador después del pre-incremento o pre-decremento"

# falta , singular em+
# mmmh, puede faltar más de un paréntesis cfuga
# tiene razón Enrique, es singular. cfuga
#: expr.c:854
msgid "missing `)'"
msgstr "falta un `)'"

#: expr.c:897 expr.c:1176
msgid "syntax error: operand expected"
msgstr "error sintáctico: se esperaba un operando"

#: expr.c:1178
msgid "syntax error: invalid arithmetic operator"
msgstr "error sintáctico: operador aritmético inválido"

#: expr.c:1202
#, c-format
msgid "%s%s%s: %s (error token is \"%s\")"
msgstr "%s%s%s: %s (el elemento de error es \"%s\")"

#: expr.c:1260
msgid "invalid arithmetic base"
msgstr "base aritmética inválida"

#: expr.c:1280
msgid "value too great for base"
msgstr "valor demasiado grande para la base"

#: expr.c:1329
#, c-format
msgid "%s: expression error\n"
msgstr "%s: error de expresión\n"

#: general.c:61
msgid "getcwd: cannot access parent directories"
msgstr "getcwd: no se puede acceder a los directorios padre"

#: input.c:94 subst.c:4857
#, c-format
msgid "cannot reset nodelay mode for fd %d"
msgstr "no se puede reestablecer el modo nodelay para el df %d"

#: input.c:258
#, c-format
msgid "cannot allocate new file descriptor for bash input from fd %d"
msgstr ""
"no se puede asignar un nuevo descriptor de fichero para la entrada de bash "
"desde el df %d"

# buffer: espacio intermedio , alojamiento intermedio ( me gusta menos )
# em+
# almacenamiento intermedio. cfuga
#: input.c:266
#, c-format
msgid "save_bash_input: buffer already exists for new fd %d"
msgstr ""
"save_bash_input: el almacenamiento intermedio ya existe para el nuevo df %d"

#: jobs.c:466
msgid "start_pipeline: pgrp pipe"
msgstr "start_pipeline: tubería de pgrp"

#: jobs.c:887
#, c-format
msgid "forked pid %d appears in running job %d"
msgstr "el pid `forked' %d aparece en el trabajo en ejecución %d"

#: jobs.c:1005
#, c-format
msgid "deleting stopped job %d with process group %ld"
msgstr "borrando el trabajo detenido %d con grupo de proceso %ld"

#: jobs.c:1110
#, c-format
msgid "add_process: process %5ld (%s) in the_pipeline"
msgstr "add_process: el proceso %5ld (%s) en the_pipeline"

#: jobs.c:1113
#, c-format
msgid "add_process: pid %5ld (%s) marked as still alive"
msgstr "add_process: pid %5ld (%s) se marca como vivo aún"

# Cambiaría 'hay' por 'existe' em+
#: jobs.c:1401
#, c-format
msgid "describe_pid: %ld: no such pid"
msgstr "describe_pid: %ld: no existe tal pid"

#: jobs.c:1416
#, c-format
msgid "Signal %d"
msgstr "Señal %d"

#: jobs.c:1430 jobs.c:1455
msgid "Done"
msgstr "Hecho"

#: jobs.c:1435 siglist.c:123
msgid "Stopped"
msgstr "Detenido"

#: jobs.c:1439
#, c-format
msgid "Stopped(%s)"
msgstr "Detenido(%s)"

#: jobs.c:1443
msgid "Running"
msgstr "Ejecutando"

#: jobs.c:1457
#, c-format
msgid "Done(%d)"
msgstr "Hecho(%d)"

#: jobs.c:1459
#, c-format
msgid "Exit %d"
msgstr "Salida %d"

#: jobs.c:1462
msgid "Unknown status"
msgstr "Estado desconocido"

#: jobs.c:1549
#, c-format
msgid "(core dumped) "
msgstr "(`core' generado) "

#: jobs.c:1568
#, c-format
msgid "  (wd: %s)"
msgstr "  (dir ahora: %s)"

#: jobs.c:1776
#, c-format
msgid "child setpgid (%ld to %ld)"
msgstr "setpgid hijo (%ld a %ld)"

#: jobs.c:2104 nojobs.c:585
#, c-format
msgid "wait: pid %ld is not a child of this shell"
msgstr "wait: pid %ld no es un proceso hijo de este shell"

#: jobs.c:2331
#, c-format
msgid "wait_for: No record of process %ld"
msgstr "wait_for: No hay un registro del proceso %ld"

#: jobs.c:2607
#, c-format
msgid "wait_for_job: job %d is stopped"
msgstr "wait_for_job: el trabajo %d está detenido"

#: jobs.c:2829
#, c-format
msgid "%s: job has terminated"
msgstr "%s: el trabajo ha terminado"

#: jobs.c:2838
#, c-format
msgid "%s: job %d already in background"
msgstr "%s: el trabajo %d ya está en segundo plano"

#: jobs.c:3059
msgid "waitchld: turning on WNOHANG to avoid indefinite block"
msgstr ""

#: jobs.c:3508
#, c-format
msgid "%s: line %d: "
msgstr "%s: línea %d: "

#: jobs.c:3522 nojobs.c:814
#, c-format
msgid " (core dumped)"
msgstr " (`core' generado)"

#: jobs.c:3534 jobs.c:3547
#, c-format
msgid "(wd now: %s)\n"
msgstr "(dir ahora: %s)\n"

#: jobs.c:3579
msgid "initialize_job_control: getpgrp failed"
msgstr "initialize_jobs_control: falló getpgrp"

#: jobs.c:3639
msgid "initialize_job_control: line discipline"
msgstr "initialize_jobs_control: disciplina de línea"

#: jobs.c:3649
msgid "initialize_job_control: setpgid"
msgstr "initialize_jobs_control: setpgid"

#: jobs.c:3677
#, c-format
msgid "cannot set terminal process group (%d)"
msgstr "no se puede establecer el grupo de proceso de terminal (%d)"

#: jobs.c:3682
msgid "no job control in this shell"
msgstr "no hay control de trabajos en este shell"

#: lib/malloc/malloc.c:296
#, c-format
msgid "malloc: failed assertion: %s\n"
msgstr "malloc: falló la aserción: %s\n"

#: lib/malloc/malloc.c:312
#, c-format
msgid ""
"\r\n"
"malloc: %s:%d: assertion botched\r\n"
msgstr ""
"\r\n"
"malloc: %s:%d: aserción arruinada\r\n"

#: lib/malloc/malloc.c:313
msgid "unknown"
msgstr "desconocido"

#: lib/malloc/malloc.c:797
msgid "malloc: block on free list clobbered"
msgstr "malloc: bloque en la lista libre sobreescrito"

#: lib/malloc/malloc.c:874
msgid "free: called with already freed block argument"
msgstr "free: se llamó con un argumento de bloque previamente liberado"

#: lib/malloc/malloc.c:877
msgid "free: called with unallocated block argument"
msgstr "free: se llamó con un argumento de bloque sin asignar"

#: lib/malloc/malloc.c:896
msgid "free: underflow detected; mh_nbytes out of range"
msgstr ""
"free: se detectó un desbordamiento por debajo; mh_nbytes fuera de rango"

#: lib/malloc/malloc.c:902
msgid "free: start and end chunk sizes differ"
msgstr "free: los tamaños de los pedazos de inicio y fin son diferentes"

#: lib/malloc/malloc.c:1001
msgid "realloc: called with unallocated block argument"
msgstr "realloc: se llamó con un argumento de bloque sin asignar"

#: lib/malloc/malloc.c:1016
msgid "realloc: underflow detected; mh_nbytes out of range"
msgstr ""
"realloc: se detectó un desbordamiento por debajo; mh_nbytes fuera de rango"

#: lib/malloc/malloc.c:1022
msgid "realloc: start and end chunk sizes differ"
msgstr "realloc: los tamaños de los pedazos de inicio y fin son diferentes"

#: lib/malloc/table.c:177
#, c-format
msgid "register_alloc: alloc table is full with FIND_ALLOC?\n"
msgstr "register_alloc: ¿la tabla alloc está llena con FIND_ALLOC?\n"

#: lib/malloc/table.c:184
#, c-format
msgid "register_alloc: %p already in table as allocated?\n"
msgstr "register_alloc: ¿%p ya está en la tabla como asignado?\n"

#: lib/malloc/table.c:220
#, c-format
msgid "register_free: %p already in table as free?\n"
msgstr "register_free: ¿%p ya está en la tabla como libre?\n"

#: lib/sh/fmtulong.c:101
msgid "invalid base"
msgstr "base inválida"

#: lib/sh/netopen.c:168
#, c-format
msgid "%s: host unknown"
msgstr "%s: anfitrión desconocido"

#: lib/sh/netopen.c:175
#, c-format
msgid "%s: invalid service"
msgstr "%s: servicio inválido"

#: lib/sh/netopen.c:306
#, c-format
msgid "%s: bad network path specification"
msgstr "%s: especificación de ruta de red errónea"

#: lib/sh/netopen.c:346
msgid "network operations not supported"
msgstr "no hay soporte para operaciones de red"

#: locale.c:192
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s)"
msgstr ""

#: locale.c:194
#, c-format
msgid "setlocale: LC_ALL: cannot change locale (%s): %s"
msgstr ""

#: locale.c:247
#, fuzzy, c-format
msgid "setlocale: %s: cannot change locale (%s)"
msgstr "xrealloc: %s:%d: no se pueden reasignar %lu bytes"

#: locale.c:249
#, fuzzy, c-format
msgid "setlocale: %s: cannot change locale (%s): %s"
msgstr "xrealloc: %s:%d: no se pueden reasignar %lu bytes"

#: mailcheck.c:433
msgid "You have mail in $_"
msgstr "Tiene correo en $_"

#: mailcheck.c:458
msgid "You have new mail in $_"
msgstr "Tiene correo nuevo en $_"

#: mailcheck.c:474
#, c-format
msgid "The mail in %s has been read\n"
msgstr "El correo en %s fue leído\n"

#: make_cmd.c:323
msgid "syntax error: arithmetic expression required"
msgstr "error sintáctico: se requiere una expresión aritmética"

#: make_cmd.c:325
msgid "syntax error: `;' unexpected"
msgstr "error sintáctico: `;' inesperado"

#: make_cmd.c:326
#, c-format
msgid "syntax error: `((%s))'"
msgstr "error sintáctico: `((%s))'"

#: make_cmd.c:575
#, c-format
msgid "make_here_document: bad instruction type %d"
msgstr "make_here_document: tipo de instrucción %d erróneo"

#: make_cmd.c:659
#, c-format
msgid "here-document at line %d delimited by end-of-file (wanted `%s')"
msgstr ""
"el documento-aquí en la línea %d está delimitado por fin-de-fichero (se "
"esperaba `%s')"

#: make_cmd.c:756
#, c-format
msgid "make_redirection: redirection instruction `%d' out of range"
msgstr ""
"make_redirection: la instrucción de redirección `%d' está fuera de rango"

#: parse.y:3133 parse.y:3369
#, c-format
msgid "unexpected EOF while looking for matching `%c'"
msgstr "EOF inesperado mientras se buscaba un `%c' coincidente"

#: parse.y:3951
msgid "unexpected EOF while looking for `]]'"
msgstr "EOF inesperado mientras se buscaba `]]'"

#: parse.y:3956
#, c-format
msgid "syntax error in conditional expression: unexpected token `%s'"
msgstr "error sintáctico en la expresión condicional: elemento inesperado `%s'"

#: parse.y:3960
msgid "syntax error in conditional expression"
msgstr "error sintáctico en la expresión condicional"

#: parse.y:4038
#, c-format
msgid "unexpected token `%s', expected `)'"
msgstr "elemento inesperado `%s', se esperaba `)'"

#: parse.y:4042
msgid "expected `)'"
msgstr "se esperaba `)'"

#: parse.y:4070
#, c-format
msgid "unexpected argument `%s' to conditional unary operator"
msgstr "argumento inesperado `%s' para el operador unario condicional"

#: parse.y:4074
msgid "unexpected argument to conditional unary operator"
msgstr "argumento inesperado para el operador unario condicional"

#: parse.y:4120
#, c-format
msgid "unexpected token `%s', conditional binary operator expected"
msgstr "elemento inesperado `%s', se esperaba un operador binario condicional"

#: parse.y:4124
msgid "conditional binary operator expected"
msgstr "se esperaba un operador binario condicional"

#: parse.y:4146
#, c-format
msgid "unexpected argument `%s' to conditional binary operator"
msgstr "argumento inesperado `%s' para el operador binario condicional"

#: parse.y:4150
msgid "unexpected argument to conditional binary operator"
msgstr "argumento inesperado para el operador binario condicional"

#: parse.y:4161
#, c-format
msgid "unexpected token `%c' in conditional command"
msgstr "elemento inesperado `%c' en la orden condicional"

#: parse.y:4164
#, c-format
msgid "unexpected token `%s' in conditional command"
msgstr "elemento inesperado `%s' en la orden condicional"

#: parse.y:4168
#, c-format
msgid "unexpected token %d in conditional command"
msgstr "elemento inesperado %d en la orden condicional"

# Token: elemento ?
# error sintáctico, no se esperaba el símbolo `%c' em+
# No puedo tomar tal cual la corrección. El error puede no ser
# provocado por el símbolo. Simplemente estar cerca del mismo. cfuga
# Por consistencia con el siguiente, yo borraría la coma. sv
# Cierto. Coma borrada. cfuga
#: parse.y:5459
#, c-format
msgid "syntax error near unexpected token `%s'"
msgstr "error sintáctico cerca del elemento inesperado `%s'"

#: parse.y:5477
#, c-format
msgid "syntax error near `%s'"
msgstr "error sintáctico cerca de `%s'"

# Propongo cambio de orden:
# no se esperaba el final de la línea em+
# Ojo, que end of file es fin de fichero, no de línea. sv
# Se hicieron ambos cambios. cfuga
#: parse.y:5487
msgid "syntax error: unexpected end of file"
msgstr "error sintáctico: no se esperaba el final del fichero"

#: parse.y:5487
msgid "syntax error"
msgstr "error sintáctico"

#: parse.y:5549
#, c-format
msgid "Use \"%s\" to leave the shell.\n"
msgstr "Use \"%s\" para dejar el shell.\n"

#: parse.y:5711
msgid "unexpected EOF while looking for matching `)'"
msgstr "EOF inesperado mientras se buscaba un `)' coincidente"

#: pcomplete.c:1030
#, c-format
msgid "completion: function `%s' not found"
msgstr "completion: no se encuentra la función `%s'"

#: pcomplib.c:179
#, c-format
msgid "progcomp_insert: %s: NULL COMPSPEC"
msgstr "progcomp_insert: %s: COMPSPEC nulo"

#: print_cmd.c:290
#, c-format
msgid "print_command: bad connector `%d'"
msgstr "print_command: conector erróneo `%d'"

#: print_cmd.c:363
#, fuzzy, c-format
msgid "xtrace_set: %d: invalid file descriptor"
msgstr "%d: descriptor de fichero inválido: %s"

#: print_cmd.c:368
msgid "xtrace_set: NULL file pointer"
msgstr ""

#: print_cmd.c:372
#, c-format
msgid "xtrace fd (%d) != fileno xtrace fp (%d)"
msgstr ""

#: print_cmd.c:1461
#, c-format
msgid "cprintf: `%c': invalid format character"
msgstr "cprintf: `%c': carácter de formato inválido"

#: redir.c:110
msgid "file descriptor out of range"
msgstr "descriptor de fichero fuera de rango"

#: redir.c:166
#, c-format
msgid "%s: ambiguous redirect"
msgstr "%s: redireccionamiento ambiguo"

#: redir.c:170
#, c-format
msgid "%s: cannot overwrite existing file"
msgstr "%s: no se puede sobreescribir un fichero existente"

#: redir.c:175
#, c-format
msgid "%s: restricted: cannot redirect output"
msgstr "%s: restringido: no se puede redirigir la salida"

#: redir.c:180
#, c-format
msgid "cannot create temp file for here-document: %s"
msgstr "no se puede crear un fichero temporal para el documento-aquí: %s"

#: redir.c:184
#, fuzzy, c-format
msgid "%s: cannot assign fd to variable"
msgstr "%s: no se puede asignar una lista a un miembro de la matriz"

#: redir.c:544
msgid "/dev/(tcp|udp)/host/port not supported without networking"
msgstr "no se admite /dev/(tcp|udp)/anfitrion/puerto sin red"

#: redir.c:1101
msgid "redirection error: cannot duplicate fd"
msgstr "error de redirección: no se puede duplicar el df"

#: shell.c:332
msgid "could not find /tmp, please create!"
msgstr "¡no se puede encontrar /tmp, crear por favor!"

#: shell.c:336
msgid "/tmp must be a valid directory name"
msgstr "/tmp debe ser un nombre de directorio válido"

#: shell.c:884
#, c-format
msgid "%c%c: invalid option"
msgstr "%c%c: opción inválida"

# Yo pondría "no tengo ningún nombre". sv
# Revisé el código fuente de bash. Es un mensaje de error cuando no se
# encuentra el nombre del usuario que ejecuta el shell. cfuga
#: shell.c:1651
msgid "I have no name!"
msgstr "¡No tengo nombre de usuario!"

#: shell.c:1793
#, c-format
msgid "GNU bash, version %s-(%s)\n"
msgstr "GNU bash, versión %s-(%s)\n"

# En la lista spanglish se discutió mucho sobre script,
# no sé en que quedó, ni puedo decirte ahora cómo lo hemos
# traducido en otras ocasiones. Sehll script lo henmos traducido
# como guión del shell , eso es seguro ... así que puede estar
# bien así , ya lo verán otros em+
#: shell.c:1794
#, c-format
msgid ""
"Usage:\t%s [GNU long option] [option] ...\n"
"\t%s [GNU long option] [option] script-file ...\n"
msgstr ""
"Modo de empleo:\t%s [opción GNU larga] [opción] ...\n"
"\t%s [opción GNU larga] [opción] guión-del-shell\n"

#: shell.c:1796
msgid "GNU long options:\n"
msgstr "Opciones GNU largas:\n"

#: shell.c:1800
msgid "Shell options:\n"
msgstr "Opciones del shell:\n"

#: shell.c:1801
msgid "\t-irsD or -c command or -O shopt_option\t\t(invocation only)\n"
msgstr "\t-irsD o -c orden o -O opcion_shopt\t\t(sólo invocación)\n"

#: shell.c:1816
#, c-format
msgid "\t-%s or -o option\n"
msgstr "\t-%s o -o opción\n"

#: shell.c:1822
#, c-format
msgid "Type `%s -c \"help set\"' for more information about shell options.\n"
msgstr ""
"Teclee `%s -c \"help set\"' para más información sobre las opciones del "
"shell.\n"

#: shell.c:1823
#, c-format
msgid "Type `%s -c help' for more information about shell builtin commands.\n"
msgstr ""
"Teclee `%s -c help' para más información sobre las órdenes internas del "
"shell.\n"

#: shell.c:1824
#, c-format
msgid "Use the `bashbug' command to report bugs.\n"
msgstr "Use la orden `bashbug' para reportar bichos.\n"

#: sig.c:626
#, c-format
msgid "sigprocmask: %d: invalid operation"
msgstr "sigprocmask: %d: operación inválida"

#: siglist.c:48
msgid "Bogus signal"
msgstr "Señal ambigua"

#: siglist.c:51
msgid "Hangup"
msgstr "Colgar"

#: siglist.c:55
msgid "Interrupt"
msgstr "Interrumpir"

#: siglist.c:59
msgid "Quit"
msgstr "Salir"

#: siglist.c:63
msgid "Illegal instruction"
msgstr "Instrucción ilegal"

#: siglist.c:67
msgid "BPT trace/trap"
msgstr "BPT rastreo/captura"

#: siglist.c:75
msgid "ABORT instruction"
msgstr "instrucción ABORT"

#: siglist.c:79
msgid "EMT instruction"
msgstr "instrucción EMT"

#: siglist.c:83
msgid "Floating point exception"
msgstr "Excepción de coma flotante"

#: siglist.c:87
msgid "Killed"
msgstr "Matado"

#: siglist.c:91
msgid "Bus error"
msgstr "Error en el bus"

#: siglist.c:95
msgid "Segmentation fault"
msgstr "Violación de segmento"

# llamada del sistema em+
# Es una llamada a una función del sistema em+
# De acuerdo, pero lo que está mal es la forma de invocar la
# llamada a la función del sistema, no la llamada en sí cfuga
#: siglist.c:99
msgid "Bad system call"
msgstr "Llamada al sistema errónea"

# (pipe) no, por favor. Esto ya está traducido en libc, así que a estas
# alturas, la gente ya debería saber qué es eso de la tubería. sv
# De acuerdo. cfuga
#: siglist.c:103
msgid "Broken pipe"
msgstr "Tubería rota"

#: siglist.c:107
msgid "Alarm clock"
msgstr "Temporizador"

#: siglist.c:111
msgid "Terminated"
msgstr "Terminado"

#: siglist.c:115
msgid "Urgent IO condition"
msgstr "Condición de E/S urgente"

#: siglist.c:119
msgid "Stopped (signal)"
msgstr "Detenido (señal)"

#: siglist.c:127
msgid "Continue"
msgstr "Continúa"

#: siglist.c:135
msgid "Child death or stop"
msgstr "El proceso hijo ha muerto o está parado"

#: siglist.c:139
msgid "Stopped (tty input)"
msgstr "Detenido (entrada por terminal)"

#: siglist.c:143
msgid "Stopped (tty output)"
msgstr "Detenido (salida por terminal)"

#: siglist.c:147
msgid "I/O ready"
msgstr "E/S listas"

#: siglist.c:151
msgid "CPU limit"
msgstr "Límite de CPU"

#: siglist.c:155
msgid "File limit"
msgstr "Límite de ficheros"

#: siglist.c:159
msgid "Alarm (virtual)"
msgstr "Alarma (virtual)"

#: siglist.c:163
msgid "Alarm (profile)"
msgstr "Alarma (entorno)"

#: siglist.c:167
msgid "Window changed"
msgstr "Ventana cambiada"

#: siglist.c:171
msgid "Record lock"
msgstr "Bloqueo de grabación"

#: siglist.c:175
msgid "User signal 1"
msgstr "Señal de usuario 1"

#: siglist.c:179
msgid "User signal 2"
msgstr "Señal de usuario 2"

#: siglist.c:183
msgid "HFT input data pending"
msgstr "entrada de datos HFT pendiente"

# falla: fallo em+
# Suscribo lo anterior. falla suena muy raro.
# Yo lo pondría además al revés: fallo de energía inminente. sv
# Me gusta como lo sugieres. Cambio hecho. cfuga
#: siglist.c:187
msgid "power failure imminent"
msgstr "fallo de energía inminente"

#: siglist.c:191
msgid "system crash imminent"
msgstr "caída del sistema inminente"

#: siglist.c:195
msgid "migrate process to another CPU"
msgstr "migrando el proceso a otra CPU"

#: siglist.c:199
msgid "programming error"
msgstr "error de programación"

#: siglist.c:203
msgid "HFT monitor mode granted"
msgstr "el modo monitor HFT ha sido concedido"

#: siglist.c:207
msgid "HFT monitor mode retracted"
msgstr "el modo monitor HTF ha sido retirado"

#: siglist.c:211
msgid "HFT sound sequence has completed"
msgstr "la secuencia de sonido HFT ha sido completado"

#: siglist.c:215
msgid "Information request"
msgstr "Solicitud de información"

#: siglist.c:223
msgid "Unknown Signal #"
msgstr "Señal Desconocida #"

#: siglist.c:225
#, c-format
msgid "Unknown Signal #%d"
msgstr "Señal Desconocida #%d"

#: subst.c:1333 subst.c:1454
#, c-format
msgid "bad substitution: no closing `%s' in %s"
msgstr "sustitución errónea: no hay un `%s' que cierre en %s"

#: subst.c:2735
#, c-format
msgid "%s: cannot assign list to array member"
msgstr "%s: no se puede asignar una lista a un miembro de la matriz"

#: subst.c:4754 subst.c:4770
msgid "cannot make pipe for process substitution"
msgstr "no se puede crear la tubería para la sustitución del proceso"

#: subst.c:4802
msgid "cannot make child for process substitution"
msgstr "no se puede crear un proceso hijo para la sustitución del proceso"

#: subst.c:4847
#, c-format
msgid "cannot open named pipe %s for reading"
msgstr "no se puede abrir la tubería llamada %s para lectura"

#: subst.c:4849
#, c-format
msgid "cannot open named pipe %s for writing"
msgstr "no se puede abrir la tubería llamada %s para escritura"

#: subst.c:4867
#, c-format
msgid "cannot duplicate named pipe %s as fd %d"
msgstr "no se puede duplicar la tubería llamada %s como df %d"

#: subst.c:5063
msgid "cannot make pipe for command substitution"
msgstr "no se pueden crear la tubería para la sustitución de la orden"

#: subst.c:5097
msgid "cannot make child for command substitution"
msgstr "no se puede crear un proceso hijo para la sustitución de la orden"

#: subst.c:5114
msgid "command_substitute: cannot duplicate pipe as fd 1"
msgstr "command_substitute: no se puede duplicar la tubería como df 1"

#: subst.c:5617
#, c-format
msgid "%s: parameter null or not set"
msgstr "%s: parámetro nulo o no establecido"

#: subst.c:5907
#, c-format
msgid "%s: substring expression < 0"
msgstr "%s: expresión de subcadena < 0"

#: subst.c:6965
#, c-format
msgid "%s: bad substitution"
msgstr "%s: sustitución errónea"

#: subst.c:7045
#, c-format
msgid "$%s: cannot assign in this way"
msgstr "$%s: no se puede asignar de esta forma"

#: subst.c:7374
msgid ""
"future versions of the shell will force evaluation as an arithmetic "
"substitution"
msgstr ""

#: subst.c:7839
#, c-format
msgid "bad substitution: no closing \"`\" in %s"
msgstr "sustitución errónea: no hay una \"`\" que cierre en %s"

#: subst.c:8720
#, c-format
msgid "no match: %s"
msgstr "no hay coincidencia: %s"

#: test.c:146
msgid "argument expected"
msgstr "se esperaba un argumento"

#: test.c:155
#, c-format
msgid "%s: integer expression expected"
msgstr "%s: se esperaba una expresión entera"

#: test.c:263
msgid "`)' expected"
msgstr "se esperaba `)'"

#: test.c:265
#, c-format
msgid "`)' expected, found %s"
msgstr "se esperaba `)', se encontró %s"

#: test.c:280 test.c:693 test.c:696
#, c-format
msgid "%s: unary operator expected"
msgstr "%s: se esperaba un operador unario"

#: test.c:449 test.c:736
#, c-format
msgid "%s: binary operator expected"
msgstr "%s: se esperaba un operador binario"

# Singular em+
# Puede faltar más de un ] cfuga
# Cierto, pero al menos uno seguro que falta.
# Yo creo que no hace falta el (n). sv
# Abreviando "falta [al menos] un `]'" saldría: "falta un `]'".
# ¿No es mejor "falta algún `]'"? cfuga
# Tiene razón Enrique: singular. cfuga
#: test.c:811
msgid "missing `]'"
msgstr "falta un `]'"

#: trap.c:203
msgid "invalid signal number"
msgstr "número de señal inválido"

#: trap.c:327
#, c-format
msgid "run_pending_traps: bad value in trap_list[%d]: %p"
msgstr "run_pending_traps: valor erróneo en trap_list[%d]: %p"

#: trap.c:331
#, c-format
msgid ""
"run_pending_traps: signal handler is SIG_DFL, resending %d (%s) to myself"
msgstr ""
"run_pending_traps: el manejador de señal es SIG_DFL, reenviando %d (%s) a mí "
"mismo"

#: trap.c:380
#, c-format
msgid "trap_handler: bad signal %d"
msgstr "trap_handler: señal errónea %d"

#: variables.c:363
#, c-format
msgid "error importing function definition for `%s'"
msgstr "error al importar la definición de la función para `%s'"

#: variables.c:748
#, c-format
msgid "shell level (%d) too high, resetting to 1"
msgstr "el nivel de shell (%d) es demasiado alto, se reestablece a 1"

#: variables.c:1915
msgid "make_local_variable: no function context at current scope"
msgstr "make_local_variable: no hay contexto de función en el ámbito actual"

#: variables.c:3159
msgid "all_local_variables: no function context at current scope"
msgstr "all_local_variables: no hay contexto de función en el ámbito actual"

#: variables.c:3376
#, fuzzy, c-format
msgid "%s has null exportstr"
msgstr "%s: parámetro nulo o no establecido"

#: variables.c:3381 variables.c:3390
#, c-format
msgid "invalid character %d in exportstr for %s"
msgstr "carácter inválido %d en exportstr para %s"

#: variables.c:3396
#, c-format
msgid "no `=' in exportstr for %s"
msgstr "no hay `=' en exportstr para %s"

#: variables.c:3835
msgid "pop_var_context: head of shell_variables not a function context"
msgstr ""
"pop_var_context: la cabeza de shell_variables no es un contexto de función"

#: variables.c:3848
msgid "pop_var_context: no global_variables context"
msgstr "pop_var_context: no es un contexto global_variables"

#: variables.c:3922
msgid "pop_scope: head of shell_variables not a temporary environment scope"
msgstr ""
"pop_scope: la cabeza de shell_variables no es un ámbito de ambiente temporal"

#: variables.c:4678
#, fuzzy, c-format
msgid "%s: %s: cannot open as FILE"
msgstr "%s: no se puede abrir: %s"

#: variables.c:4683
#, fuzzy, c-format
msgid "%s: %s: invalid value for trace file descriptor"
msgstr "%d: descriptor de fichero inválido: %s"

#: version.c:46
msgid "Copyright (C) 2009 Free Software Foundation, Inc."
msgstr "Copyright (C) 2009 Free Software Foundation, Inc."

#: version.c:47
msgid ""
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Licencia GPLv3+: GPL de GNU versión 3 o posterior <http://gnu.org/licenses/"
"gpl.html>\n"

#: version.c:86 version2.c:83
#, c-format
msgid "GNU bash, version %s (%s)\n"
msgstr "GNU bash, versión %s (%s)\n"

#: version.c:91 version2.c:88
#, c-format
msgid "This is free software; you are free to change and redistribute it.\n"
msgstr ""
"Esto es software libre; usted es libre de cambiarlo y redistribuirlo.\n"

#: version.c:92 version2.c:89
#, c-format
msgid "There is NO WARRANTY, to the extent permitted by law.\n"
msgstr "NO hay GARANTÍA, a la extensión permitida por la ley.\n"

#: version2.c:86
#, fuzzy, c-format
msgid "Copyright (C) 2009 Free Software Foundation, Inc.\n"
msgstr "Copyright (C) 2009 Free Software Foundation, Inc."

#: version2.c:87
#, fuzzy, c-format
msgid ""
"License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl."
"html>\n"
msgstr ""
"Licencia GPLv3+: GPL de GNU versión 3 o posterior <http://gnu.org/licenses/"
"gpl.html>\n"

#: xmalloc.c:91
#, fuzzy, c-format
msgid "%s: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: no se pueden asignar %lu bytes (%lu bytes asignados)"

#: xmalloc.c:93
#, fuzzy, c-format
msgid "%s: cannot allocate %lu bytes"
msgstr "xmalloc: no se pueden asignar %lu bytes"

#: xmalloc.c:163
#, fuzzy, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes (%lu bytes allocated)"
msgstr "xmalloc: %s:%d: no se pueden asignar %lu bytes (%lu bytes asignados)"

#: xmalloc.c:165
#, fuzzy, c-format
msgid "%s: %s:%d: cannot allocate %lu bytes"
msgstr "xmalloc: %s:%d: no se pueden asignar %lu bytes"

#: builtins.c:43
msgid "alias [-p] [name[=value] ... ]"
msgstr "alias [-p] [nombre[=valor] ... ]"

#: builtins.c:47
msgid "unalias [-a] name [name ...]"
msgstr "unalias [-a] nombre [nombre ...]"

#: builtins.c:51
msgid ""
"bind [-lpvsPVS] [-m keymap] [-f filename] [-q name] [-u name] [-r keyseq] [-"
"x keyseq:shell-command] [keyseq:readline-function or readline-command]"
msgstr ""
"bind [-lpvsPVS] [-m comb_teclas] [-f fichero] [-q nombre] [-u nombre] [-r "
"secteclas] [-x secteclas:orden-shell] [secteclas:función-readline u orden-"
"readline]"

#: builtins.c:54
msgid "break [n]"
msgstr "break [n]"

#: builtins.c:56
msgid "continue [n]"
msgstr "continue [n]"

#: builtins.c:58
msgid "builtin [shell-builtin [arg ...]]"
msgstr "builtin [orden-interna-shell [arg ...]]"

#: builtins.c:61
msgid "caller [expr]"
msgstr "caller [expresión]"

#: builtins.c:64
msgid "cd [-L|-P] [dir]"
msgstr "cd [-L|-P] [directorio]"

#: builtins.c:66
msgid "pwd [-LP]"
msgstr "pwd [-LP]"

#: builtins.c:68
msgid ":"
msgstr ":"

#: builtins.c:70
msgid "true"
msgstr "true"

#: builtins.c:72
msgid "false"
msgstr "false"

#: builtins.c:74
msgid "command [-pVv] command [arg ...]"
msgstr "command [-pVv] orden [arg ...]"

#: builtins.c:76
msgid "declare [-aAfFilrtux] [-p] [name[=value] ...]"
msgstr "declare [-aAfFilrtux] [-p] nombre[=valor] ..."

#: builtins.c:78
msgid "typeset [-aAfFilrtux] [-p] name[=value] ..."
msgstr "typeset [-aAfFilrtux] [-p] nombre[=valor] ..."

#: builtins.c:80
msgid "local [option] name[=value] ..."
msgstr "local [opción] nombre[=valor] ..."

#: builtins.c:83
msgid "echo [-neE] [arg ...]"
msgstr "echo [-neE] [arg ...]"

#: builtins.c:87
msgid "echo [-n] [arg ...]"
msgstr "echo [-n] [arg ...]"

#: builtins.c:90
msgid "enable [-a] [-dnps] [-f filename] [name ...]"
msgstr "enable [-a] [-dnps] [-f fichero] [nombre ...]"

#: builtins.c:92
msgid "eval [arg ...]"
msgstr "eval [arg ...]"

#: builtins.c:94
msgid "getopts optstring name [arg]"
msgstr "getopts cadena_opciones nombre [arg]"

#: builtins.c:96
msgid "exec [-cl] [-a name] [command [arguments ...]] [redirection ...]"
msgstr "exec [-cl] [-a nombre] [orden [argumentos ...]] [redirección ...]"

#: builtins.c:98
msgid "exit [n]"
msgstr "exit [n]"

#: builtins.c:100
msgid "logout [n]"
msgstr "logout [n]"

#: builtins.c:103
msgid "fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]"
msgstr "fc [-e nombre_e] [-lnr] [primero] [último] ó fc -s [pat=rep] [orden]"

#: builtins.c:107
msgid "fg [job_spec]"
msgstr "fg [id_trabajo]"

#: builtins.c:111
msgid "bg [job_spec ...]"
msgstr "bg [id_trabajo ...]"

#: builtins.c:114
msgid "hash [-lr] [-p pathname] [-dt] [name ...]"
msgstr "hash [-lr] [-p ruta] [-dt] [nombre ...]"

#: builtins.c:117
#, fuzzy
msgid "help [-dms] [pattern ...]"
msgstr "help [-ds] [patrón ...]"

#: builtins.c:121
msgid ""
"history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg "
"[arg...]"
msgstr ""
"history [-c] [-d despl] [n] ó history -anrw [fichero] ó history -ps arg "
"[arg...]"

# jobspec no es sólo el pid del proceso, puede ser tambien
# el nombre de la orden que se creo con el proceso em+
# por eso es idtrabajo, no pidtrabajo. De cualquier forma, no me agrada
# mucho. ¿Sugerencias? cfuga
#: builtins.c:125
msgid "jobs [-lnprs] [jobspec ...] or jobs -x command [args]"
msgstr "jobs [-lnprs] [idtrabajo ...] ó jobs -x orden [args]"

# lo mismo em+
#: builtins.c:129
msgid "disown [-h] [-ar] [jobspec ...]"
msgstr "disown [-h] [-ar] [idtrabajo ...]"

#: builtins.c:132
msgid ""
"kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l "
"[sigspec]"
msgstr ""
"kill [-s id_señal | -n num_señal | -id_señal] pid | idtrabajo ... ó kill -l "
"[id_señal]"

#: builtins.c:134
msgid "let arg [arg ...]"
msgstr "let arg [arg ...]"

#: builtins.c:136
#, fuzzy
msgid ""
"read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p "
"prompt] [-t timeout] [-u fd] [name ...]"
msgstr ""
"read [-ers] [-a matriz] [-d delim] [-i texto] [-n ncars] [-p prompt] [-t "
"tiempo] [-u df] [nombre ...]"

#: builtins.c:138
msgid "return [n]"
msgstr "return [n]"

#: builtins.c:140
msgid "set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]"
msgstr "set [--abefhkmnptuvxBCHP] [-o nombre-opción] [arg ...]"

#: builtins.c:142
msgid "unset [-f] [-v] [name ...]"
msgstr "unset [-f] [-v] [nombre ...]"

#: builtins.c:144
msgid "export [-fn] [name[=value] ...] or export -p"
msgstr "export [-fn] [nombre[=valor] ...] ó export -p"

#: builtins.c:146
msgid "readonly [-af] [name[=value] ...] or readonly -p"
msgstr "readonly [-af] [nombre[=valor] ...] ó readonly -p"

#: builtins.c:148
msgid "shift [n]"
msgstr "shift [n]"

#: builtins.c:150
msgid "source filename [arguments]"
msgstr "source fichero [argumentos]"

#: builtins.c:152
msgid ". filename [arguments]"
msgstr ". fichero [argumentos]"

#: builtins.c:155
msgid "suspend [-f]"
msgstr "suspend [-f]"

#: builtins.c:158
msgid "test [expr]"
msgstr "test [expresión]"

#: builtins.c:160
msgid "[ arg... ]"
msgstr "[ arg... ]"

# Esto podría ser "veces". Mirar el contexto. sv
# No es veces. times es una orden interna del shell. cfuga
#: builtins.c:162
msgid "times"
msgstr "times"

#: builtins.c:164
msgid "trap [-lp] [[arg] signal_spec ...]"
msgstr "trap [-lp] [[arg] id_señal ...]"

#: builtins.c:166
msgid "type [-afptP] name [name ...]"
msgstr "type [-afptP] nombre [nombre ...]"

#: builtins.c:169
msgid "ulimit [-SHacdefilmnpqrstuvx] [limit]"
msgstr "ulimit [-SHacdefilmnpqrstuvx] [límite]"

#: builtins.c:172
msgid "umask [-p] [-S] [mode]"
msgstr "umask [-p] [-S] [modo]"

#: builtins.c:175
msgid "wait [id]"
msgstr "wait [id]"

#: builtins.c:179
msgid "wait [pid]"
msgstr "wait [pid]"

#: builtins.c:182
msgid "for NAME [in WORDS ... ] ; do COMMANDS; done"
msgstr "for NOMBRE [in PALABRAS ... ] ; do ÓRDENES; done"

#: builtins.c:184
msgid "for (( exp1; exp2; exp3 )); do COMMANDS; done"
msgstr "for (( exp1; exp2; exp3 )); do ÓRDENES; done"

#: builtins.c:186
msgid "select NAME [in WORDS ... ;] do COMMANDS; done"
msgstr "select NOMBRE [in PALABRAS ... ;] do ÓRDENES; done"

#: builtins.c:188
msgid "time [-p] pipeline"
msgstr "time [-p] tubería"

#: builtins.c:190
msgid "case WORD in [PATTERN [| PATTERN]...) COMMANDS ;;]... esac"
msgstr "case PALABRA in [PATRÓN [| PATRÓN]...) ÓRDENES ;;]... esac"

#: builtins.c:192
msgid ""
"if COMMANDS; then COMMANDS; [ elif COMMANDS; then COMMANDS; ]... [ else "
"COMMANDS; ] fi"
msgstr ""
"if ÓRDENES; then ÓRDENES; [ elif ÓRDENES; then ÓRDENES; ]...[ else "
"ÓRDENES; ] fi"

#: builtins.c:194
msgid "while COMMANDS; do COMMANDS; done"
msgstr "while ÓRDENES; do ÓRDENES; done"

#: builtins.c:196
msgid "until COMMANDS; do COMMANDS; done"
msgstr "until ÓRDENES; do ÓRDENES; done"

#: builtins.c:198
msgid "coproc [NAME] command [redirections]"
msgstr "coproc [NOMBRE] orden [redirecciones]"

#: builtins.c:200
msgid "function name { COMMANDS ; } or name () { COMMANDS ; }"
msgstr "function nombre { ÓRDENES ; } ó nombre () { ÓRDENES ; }"

#: builtins.c:202
msgid "{ COMMANDS ; }"
msgstr "{ ÓRDENES ; }"

#: builtins.c:204
msgid "job_spec [&]"
msgstr "id_trabajo [&]"

#: builtins.c:206
msgid "(( expression ))"
msgstr "(( expresión ))"

#: builtins.c:208
msgid "[[ expression ]]"
msgstr "[[ expresión ]]"

#: builtins.c:210
msgid "variables - Names and meanings of some shell variables"
msgstr "variables - Nombres y significados de algunas variables de shell"

#: builtins.c:213
msgid "pushd [-n] [+N | -N | dir]"
msgstr "pushd [-n] [+N | -N | dir"

#: builtins.c:217
msgid "popd [-n] [+N | -N]"
msgstr "popd [-n] [+N | -N]"

#: builtins.c:221
msgid "dirs [-clpv] [+N] [-N]"
msgstr "dirs [-clpv] [+N] [-N]"

#: builtins.c:224
msgid "shopt [-pqsu] [-o] [optname ...]"
msgstr "shopt [-pqsu] [-o] [nombre_opción...]"

#: builtins.c:226
msgid "printf [-v var] format [arguments]"
msgstr "printf [-v var] formato [argumentos]"

#: builtins.c:229
#, fuzzy
msgid ""
"complete [-abcdefgjksuv] [-pr] [-DE] [-o option] [-A action] [-G globpat] [-"
"W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S "
"suffix] [name ...]"
msgstr ""
"complete [-abcdefgjksuv] [-pr] [-o opción] [-A acción] [-G patglob] [-W "
"listapalabras] [-F función] [-C orden] [-X patfiltro] [-P prefijo] [-S "
"sufijo] [nombre ...]"

#: builtins.c:233
msgid ""
"compgen [-abcdefgjksuv] [-o option]  [-A action] [-G globpat] [-W wordlist]  "
"[-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]"
msgstr ""
"compgen [-abcdefgjksuv] [-o opción]  [-A acción] [-G patglob] [-W "
"listapalabras] [-F función] [-C orden] [-X patfiltro] [-P prefijo] [-S "
"sufijo] [palabra]"

#: builtins.c:237
#, fuzzy
msgid "compopt [-o|+o option] [-DE] [name ...]"
msgstr "compopt [-o|+o opción] [nombre ...]"

#: builtins.c:240
msgid ""
"mapfile [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"mapfile [-n cuenta] [-O origen] [-s cuenta] [-t] [-u df] [-C llamada] [-c "
"quantum] [matriz]"

#: builtins.c:242
msgid ""
"readarray [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c "
"quantum] [array]"
msgstr ""
"readarray [-n cuenta] [-O origen] [-s cuenta] [-t] [-u df] [-C llamada] [-c "
"quantum] [matriz]"

# Más en español sería: se define un alias por cada NOMBRE cuyo VALOR se da. sv
# Lo mismo de antes: el alias es expandido -> el alias se expande. sv
# no alias -> ningún alias. sv
# De acuerdo. cfuga
#: builtins.c:254
msgid ""
"Define or display aliases.\n"
"    \n"
"    Without arguments, `alias' prints the list of aliases in the reusable\n"
"    form `alias NAME=VALUE' on standard output.\n"
"    \n"
"    Otherwise, an alias is defined for each NAME whose VALUE is given.\n"
"    A trailing space in VALUE causes the next word to be checked for\n"
"    alias substitution when the alias is expanded.\n"
"    \n"
"    Options:\n"
"      -p\tPrint all defined aliases in a reusable format\n"
"    \n"
"    Exit Status:\n"
"    alias returns true unless a NAME is supplied for which no alias has "
"been\n"
"    defined."
msgstr ""
"Define o muestra aliases.\n"
"    \n"
"    `alias' sin argumentos muestra la lista de aliases en la forma\n"
"    reutilizable `alias NOMBRE=VALOR' en la salida estándar.\n"
"    \n"
"    De otra manera, se define un alias por cada NOMBRE cuyo VALOR se\n"
"    proporcione.  Un espacio final en VALOR causa que se revise\n"
"    la siguiente palabra para sustitución de alias cuando se expande\n"
"    el alias.\n"
"    \n"
"    Opciones:\n"
"      -p\tMuestra todos los aliases definidos en un formato reusable\n"
"    \n"
"    Estado de salida:\n"
"    alias devuelve verdadero a menos que se de un NOMBRE para el cual\n"
"    no se haya definido ningún alias."

#: builtins.c:276
msgid ""
"Remove each NAME from the list of defined aliases.\n"
"    \n"
"    Options:\n"
"      -a\tremove all alias definitions.\n"
"    \n"
"    Return success unless a NAME is not an existing alias."
msgstr ""
"Borra cada NOMBRE de la lista de alias definidos.\n"
"    \n"
"    Opciones:\n"
"      -a\telimina todas las definiciones de alias.\n"
"    Devuelve verdadero a menos que un NOMBRE no sea un alias existente."

# lee 'la'... em+
# Corregido. Además, es plural: lee las asignaciones... cfuga
#: builtins.c:289
msgid ""
"Set Readline key bindings and variables.\n"
"    \n"
"    Bind a key sequence to a Readline function or a macro, or set a\n"
"    Readline variable.  The non-option argument syntax is equivalent to\n"
"    that found in ~/.inputrc, but must be passed as a single argument:\n"
"    e.g., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Options:\n"
"      -m  keymap         Use KEYMAP as the keymap for the duration of this\n"
"                         command.  Acceptable keymap names are emacs,\n"
"                         emacs-standard, emacs-meta, emacs-ctlx, vi, vi-"
"move,\n"
"                         vi-command, and vi-insert.\n"
"      -l                 List names of functions.\n"
"      -P                 List function names and bindings.\n"
"      -p                 List functions and bindings in a form that can be\n"
"                         reused as input.\n"
"      -S                 List key sequences that invoke macros and their "
"values\n"
"      -s                 List key sequences that invoke macros and their "
"values\n"
"                         in a form that can be reused as input.\n"
"      -V                 List variable names and values\n"
"      -v                 List variable names and values in a form that can\n"
"                         be reused as input.\n"
"      -q  function-name  Query about which keys invoke the named function.\n"
"      -u  function-name  Unbind all keys which are bound to the named "
"function.\n"
"      -r  keyseq         Remove the binding for KEYSEQ.\n"
"      -f  filename       Read key bindings from FILENAME.\n"
"      -x  keyseq:shell-command\tCause SHELL-COMMAND to be executed when\n"
"    \t\t\t\tKEYSEQ is entered.\n"
"    \n"
"    Exit Status:\n"
"    bind returns 0 unless an unrecognized option is given or an error occurs."
msgstr ""
"Establece secuencias de teclas Readline y variables.\n"
"\n"
"    Asigna una secuencia de teclas a una función Readline o a una macro, o\n"
"    establece una variable Readline.  La sintaxis de los argumentos que\n"
"    no son opciones es equivalente a la que se encuentra en ~/.inputrc,\n"
"    pero se debe pasar como un solo argumento:\n"
"    p.e., bind '\"\\C-x\\C-r\": re-read-init-file'.\n"
"    \n"
"    Opciones:\n"
"    \n"
"      -m  comb_teclas    Usa COMB_TECLAS como la combinación de teclas por "
"la\n"
"                         duración de esta orden.  Los nombres de "
"combinaciones\n"
"                         de teclas aceptables son emacs, emacs-standard,\n"
"                         emacs-meta, emacs-ctlx, vi, vi-move, vi-command y\n"
"                         vi-insert.\n"
"      -l                 Enlista los nombres de las funciones.\n"
"      -P                 Enlista los nombres de las funciones y "
"asignaciones.\n"
"      -p                 Enlista las funciones y asignaciones en una forma "
"que\n"
"                         se puede reusar como entrada.\n"
"      -S                 Enlista las secuencias de teclas que invocan "
"macros\n"
"                         y sus valores.\n"
"      -s                 Enlista las secuencias de teclas que invocan "
"macros\n"
"                         y sus valores en una forma que se pueden reusar "
"como\n"
"                         entrada.\n"
"      -V                 Enlista los nombres de variables y valores.\n"
"      -v                 Enlista los nombres de variables y valores en una\n"
"                         forma que se pueden reusar como entrada.\n"
"      -q nombre-funcion  Pregunta qué teclas invocan la función nombrada.\n"
"      -u nombre-función  Borra todas las teclas que están ligadas a\n"
"                         la función nombrada.\n"
"      -r secteclas       Borra la asignación para la SECTECLAS.\n"
"      -f fichero         Lee las asignaciones de teclas del FICHERO.\n"
"      -x secteclas:orden-shell\tCausa que se ejecute la ORDEN-SHELL cuando\n"
"    \t\t\t\tse introduce la SECTECLAS.\n"
"    \n"
"    Estado de salida:\n"
"    bind devuelve 0 a menos que se presente una opción desconocida o suceda\n"
"    un error."

#: builtins.c:326
msgid ""
"Exit for, while, or until loops.\n"
"    \n"
"    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing\n"
"    loops.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Termina ciclos for, while o until.\n"
"    \n"
"    Termina un ciclo FOR, WHILE o UNTIL.  Si se especifica N, termina\n"
"    N ciclos anidados.\n"
"    \n"
"    Estado de salida:\n"
"    El estado de salida es 0 a menos que N no sea mayor o igual a 1."

#: builtins.c:338
msgid ""
"Resume for, while, or until loops.\n"
"    \n"
"    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.\n"
"    If N is specified, resumes the Nth enclosing loop.\n"
"    \n"
"    Exit Status:\n"
"    The exit status is 0 unless N is not greater than or equal to 1."
msgstr ""
"Continúa iteraciones for, while o until\n"
"    \n"
"    Continúa la siguiente iteración del ciclo FOR, WHILE o UNTIL\n"
"    circundante.  Si se especifica N, retoma en el N-ésimo ciclo "
"circundante.\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de salida es 0 a menos que N no sea mayor o igual a 1."

#: builtins.c:350
msgid ""
"Execute shell builtins.\n"
"    \n"
"    Execute SHELL-BUILTIN with arguments ARGs without performing command\n"
"    lookup.  This is useful when you wish to reimplement a shell builtin\n"
"    as a shell function, but need to execute the builtin within the "
"function.\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is\n"
"    not a shell builtin.."
msgstr ""
"Ejecuta órdenes internas del shell\n"
"    \n"
"    Ejecuta la ORDEN-INTERNA-SHELL con los argumentos ARGs sin realizar\n"
"    la búsqueda interna de órdenes.  Esto es útil cuando desea "
"reimplementar\n"
"    una orden interna del shell como una función de shell, pero necesita\n"
"    ejecutar la orden interna dentro de la función.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la ORDEN-INTERNA-SHELL, o falso si la\n"
"    ORDEN-INTERNA-SHELL no es una orden interna de shell."

#: builtins.c:365
msgid ""
"Return the context of the current subroutine call.\n"
"    \n"
"    Without EXPR, returns \"$line $filename\".  With EXPR, returns\n"
"    \"$line $subroutine $filename\"; this extra information can be used to\n"
"    provide a stack trace.\n"
"    \n"
"    The value of EXPR indicates how many call frames to go back before the\n"
"    current one; the top frame is frame 0.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless the shell is not executing a shell function or EXPR\n"
"    is invalid."
msgstr ""
"Devuelve el contexto de la llamada a subrutina actual.\n"
"    \n"
"    Sin EXPR, devuelve \"$linea $nombrefichero\".  Con EXPR, devuelve\n"
"    \"$linea $subrutina $nombrefichero\"; esta información adicional\n"
"    se puede usar para proveer un volcado de pila.\n"
"    \n"
"    El valor de EXPR indica cuántos marcos de llamada se debe retroceder\n"
"    antes del actual; el marco inicial es el marco 0.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 a menos que el shell no esté ejecutando una función de shell\n"
"    o EXPR sea inválida."

# Slash lo venimos traduciendo por barra inclinada , y backslash
# por barra invertida em++
# Corregido en toda la traducción. cfuga
#: builtins.c:383
msgid ""
"Change the shell working directory.\n"
"    \n"
"    Change the current directory to DIR.  The default DIR is the value of "
"the\n"
"    HOME shell variable.\n"
"    \n"
"    The variable CDPATH defines the search path for the directory "
"containing\n"
"    DIR.  Alternative directory names in CDPATH are separated by a colon "
"(:).\n"
"    A null directory name is the same as the current directory.  If DIR "
"begins\n"
"    with a slash (/), then CDPATH is not used.\n"
"    \n"
"    If the directory is not found, and the shell option `cdable_vars' is "
"set,\n"
"    the word is assumed to be  a variable name.  If that variable has a "
"value,\n"
"    its value is used for DIR.\n"
"    \n"
"    Options:\n"
"        -L\tforce symbolic links to be followed\n"
"        -P\tuse the physical directory structure without following symbolic\n"
"    \tlinks\n"
"    \n"
"    The default is to follow symbolic links, as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 if the directory is changed; non-zero otherwise."
msgstr ""
"Cambia el directorio de trabajo del shell.\n"
"    \n"
"    Cambia el directorio actual a DIR.  DIR por defecto es el valor de la\n"
"    variable de shell HOME.\n"
"    La variable CDPATH define la ruta de búsqueda por el directorio que\n"
"    contiene DIR.  Los nombres alternativos de directorio en CDPATH se\n"
"    separan con dos puntos (:).  Un nombre de directorio nulo es igual que\n"
"    el directorio actual  Si DIR comienza con una barra inclinada (/),\n"
"    entonces no se usa CDPATH.\n"
"    Si no se encuentra el directorio, y la opción del shell `cdable_vars'\n"
"    está activa, entonces se trata la palabra como un nombre de variable.\n"
"    Si esa variable tiene un valor, se utiliza su valor como DIR.\n"
"    \n"
"    Opciones:\n"
"        -L\tfuerza a seguir los enlaces simbólicos\n"
"        -P\tusar la estructura física de directorios sin seguir los enlaces\n"
"    \tsimbólicos\n"
"    \n"
"    La acción por defecto es seguir los enlaces simbólicos, como si se\n"
"    especificara `-L'.\n"
"    \n"
"    Estado de salida:\n"
"    Devuelve 0 si se cambia el directorio; de otra forma es diferente a cero."

#: builtins.c:411
msgid ""
"Print the name of the current working directory.\n"
"    \n"
"    Options:\n"
"      -L\tprint the value of $PWD if it names the current working\n"
"    \tdirectory\n"
"      -P\tprint the physical directory, without any symbolic links\n"
"    \n"
"    By default, `pwd' behaves as if `-L' were specified.\n"
"    \n"
"    Exit Status:\n"
"    Returns 0 unless an invalid option is given or the current directory\n"
"    cannot be read."
msgstr ""
"Muestra el nombre del directorio de trabajo actual.\n"
"    \n"
"    Opciones:\n"
"      -L\tmuestra el valor de $PWD si nombra al directorio de\n"
"    \ttrabajo actual\n"
"      -P\tmuestra el directorio físico, sin enlaces simbólicos\n"
"    \n"
"    Por defecto, `pwd' se comporta como si se especificara `-L'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 0 a menos que se de una opción inválida o no se pueda leer\n"
"    el directorio actual."

#: builtins.c:428
msgid ""
"Null command.\n"
"    \n"
"    No effect; the command does nothing.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Orden nula.\n"
"    \n"
"    Sin efecto; la orden no hace nada.\n"
"    \n"
"    Estado de Salida:\n"
"    Siempre con éxito."

#: builtins.c:439
msgid ""
"Return a successful result.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Devuelve un resultado con éxito.\n"
"    \n"
"    Estado de salida:\n"
"    Siempre con éxito."

#: builtins.c:448
msgid ""
"Return an unsuccessful result.\n"
"    \n"
"    Exit Status:\n"
"    Always fails."
msgstr ""
"Devuelve un resultado sin éxito.\n"
"    \n"
"    Estado de salida:\n"
"    Siempre falla."

#: builtins.c:457
msgid ""
"Execute a simple command or display information about commands.\n"
"    \n"
"    Runs COMMAND with ARGS suppressing  shell function lookup, or display\n"
"    information about the specified COMMANDs.  Can be used to invoke "
"commands\n"
"    on disk when a function with the same name exists.\n"
"    \n"
"    Options:\n"
"      -p\tuse a default value for PATH that is guaranteed to find all of\n"
"    \tthe standard utilities\n"
"      -v\tprint a description of COMMAND similar to the `type' builtin\n"
"      -V\tprint a more verbose description of each COMMAND\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of COMMAND, or failure if COMMAND is not found."
msgstr ""
"Ejecuta una orden simple o muestra información sobre órdenes.\n"
"    \n"
"    Ejecuta la ORDEN con ARGumentos, suprimiendo la búsqueda de funciones\n"
"    de shell, o muestra información sobre las ÓRDENes especificadas. Se "
"puede\n"
"    usar para invocar órdenes en disco cuando existe una función con el "
"mismo\n"
"    nombre.\n"
"    \n"
"    Opciones:\n"
"      -p\tusa un valor por defecto para PATH para garantizar que\n"
"    \tencuentre todas las utilidades estándar\n"
"      -v\tmuestra una descripción de la ORDEN similar a la orden\n"
"    \tinterna `type'\n"
"      -V\tmuestra una descripción más detallada de cada ORDEN\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la ORDEN, o falla si no se encuentra\n"
"    la ORDEN."

#: builtins.c:476
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Declare variables and give them attributes.  If no NAMEs are given,\n"
"    display the attributes and values of all variables.\n"
"    \n"
"    Options:\n"
"      -f\trestrict action or display to function names and definitions\n"
"      -F\trestrict display to function names only (plus line number and\n"
"    \tsource file when debugging)\n"
"      -p\tdisplay the attributes and value of each NAME\n"
"    \n"
"    Options which set attributes:\n"
"      -a\tto make NAMEs indexed arrays (if supported)\n"
"      -A\tto make NAMEs associative arrays (if supported)\n"
"      -i\tto make NAMEs have the `integer' attribute\n"
"      -l\tto convert NAMEs to lower case on assignment\n"
"      -r\tto make NAMEs readonly\n"
"      -t\tto make NAMEs have the `trace' attribute\n"
"      -u\tto convert NAMEs to upper case on assignment\n"
"      -x\tto make NAMEs export\n"
"    \n"
"    Using `+' instead of `-' turns off the given attribute.\n"
"    \n"
"    Variables with the integer attribute have arithmetic evaluation (see\n"
"    the `let' command) performed when the variable is assigned a value.\n"
"    \n"
"    When used in a function, `declare' makes NAMEs local, as with the "
"`local'\n"
"    command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Establece valores de variable y atributos.\n"
"    \n"
"    Declara variables y les da atributos.  Si no se da ningún NOMBRE,\n"
"    muestra los atributos y valores de todas las variables.\n"
"    \n"
"    Opciones:\n"
"      -f\trestringe la acción o muestra a nombres y definiciones\n"
"    \tde funciones\n"
"      -F\trestringe la muestra a nombres de funciones (con número de\n"
"    \tlínea y fichero fuente al depurar)\n"
"      -p\tmuestra los atributos y valor de cada NOMBRE\n"
"    \n"
"    Opciones que establecen atributos:\n"
"      -a\testablece NOMBREs como matrices indizadas (si se admiten)\n"
"      -A\testablece NOMBREs como matrices asociativas (si se admiten)\n"
"      -i\testablece NOMBREs con el atributo `integer'\n"
"      -l\tconvierte NOMBREs a minúsculas en la asignación\n"
"      -r\testablece NOMBREs como de sólo lectura\n"
"      -t\testablece NOMBREs con el atributo `trace'\n"
"      -u\tconvierte NOMBREs a mayúsculas en la asignación\n"
"      -x\testablece NOMBREs para exportar\n"
"    \n"
"    Si usa `+' en lugar de `-' desactiva el atributo dado.\n"
"    \n"
"    Las variables con el atributo integer realizan evaluación aritmética\n"
"    (vea la orden `let') cuando se asigna un valor a la variable.\n"
"    \n"
"    Cuando se usa en una función, `declare' hace locales a los NOMBREs,\n"
"    como sucede con la orden `local'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se de una opción inválida o\n"
"    suceda un error."

#: builtins.c:512
msgid ""
"Set variable values and attributes.\n"
"    \n"
"    Obsolete.  See `help declare'."
msgstr ""
"Establece valores de variables y atributos.\n"
"    \n"
"    Obsoleto.  Consulte `help declare'."

#: builtins.c:520
msgid ""
"Define local variables.\n"
"    \n"
"    Create a local variable called NAME, and give it VALUE.  OPTION can\n"
"    be any option accepted by `declare'.\n"
"    \n"
"    Local variables can only be used within a function; they are visible\n"
"    only to the function where they are defined and its children.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied, an error occurs,\n"
"    or the shell is not executing a function."
msgstr ""
"Define variables locales.\n"
"    \n"
"    Crea una variable local llamada NOMBRE, y le da un VALOR.  OPCIÓN puede\n"
"    ser cualquier opción aceptada por `declare'.\n"
"    \n"
"    Las variables locales sólo se pueden usar en una función; son visibles\n"
"    sólo en la función donde se definen y sus hijos.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se de una opción inválida, suceda\n"
"    un error, o el shell no esté ejecutando una función."

#: builtins.c:537
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"      -e\tenable interpretation of the following backslash escapes\n"
"      -E\texplicitly suppress interpretation of backslash escapes\n"
"    \n"
"    `echo' interprets the following backslash-escaped characters:\n"
"      \\a\talert (bell)\n"
"      \\b\tbackspace\n"
"      \\c\tsuppress further output\n"
"      \\e\tescape character\n"
"      \\f\tform feed\n"
"      \\n\tnew line\n"
"      \\r\tcarriage return\n"
"      \\t\thorizontal tab\n"
"      \\v\tvertical tab\n"
"      \\\\\tbackslash\n"
"      \\0nnn\tthe character whose ASCII code is NNN (octal).  NNN can be\n"
"    \t0 to 3 octal digits\n"
"      \\xHH\tthe eight-bit character whose value is HH (hexadecimal).  HH\n"
"    \tcan be one or two hex digits\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escribe argumentos en la salida estándar.\n"
"    \n"
"    Muestra los ARGumentos en la salida estándar seguidos por un carácter\n"
"    de fin de línea.\n"
"    Opciones:\n"
"      -n\tno agrega un carácter de fin de línea\n"
"      -e\tactiva la interpretación de caracteres de escape de\n"
"    \tde barra invertida\n"
"      -E\tdesactiva explícitamente la interpretación de caracteres de\n"
"    \tde escape de barra invertida\n"
"    \n"
"    `echo' interpreta los siguientes caracteres de escape de barra "
"invertida:\n"
"     \\a\talerta (timbre)\n"
"     \\b\tespacio hacia atrás\n"
"     \\c\tsuprime toda salida a continuación\n"
"     \\E\tcarácter de escape\n"
"     \\f\talimentación de papel\n"
"     \\n\tlínea nueva\n"
"     \\r\tretorno de carro\n"
"     \\t\ttabulador horizontal\n"
"     \\v\ttabulador vertical\n"
"     \\\\\tbarra invertida\n"
"     \\0nnn\tel carácter cuyo código ASCII es NNN (octal).  NNN puede ser\n"
"    \tde 0 a 3 dígitos octales\n"
"     \\xHH\tel carácter de ocho bits cuyo valor es HH (hexadecimal).  HH\n"
"    \tpuede ser de uno o dos dígitos hexadecimales\n"
"    \n"
"    Estado de salida:\n"
"    Devuelve con éxito a menos que suceda un error de escritura."

#: builtins.c:571
msgid ""
"Write arguments to the standard output.\n"
"    \n"
"    Display the ARGs on the standard output followed by a newline.\n"
"    \n"
"    Options:\n"
"      -n\tdo not append a newline\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a write error occurs."
msgstr ""
"Escribe argumentos en la salida estándar.\n"
"    \n"
"    Muestra los ARGumentos en la salida estándar seguidos por un carácter\n"
"    de fin de línea.\n"
"    Opciones:\n"
"      -n\tno agrega un carácter de fin de línea\n"
"    \n"
"    Estado de salida:\n"
"    Devuelve con éxito a menos que suceda un error de escritura."

#: builtins.c:586
msgid ""
"Enable and disable shell builtins.\n"
"    \n"
"    Enables and disables builtin shell commands.  Disabling allows you to\n"
"    execute a disk command which has the same name as a shell builtin\n"
"    without using a full pathname.\n"
"    \n"
"    Options:\n"
"      -a\tprint a list of builtins showing whether or not each is enabled\n"
"      -n\tdisable each NAME or display a list of disabled builtins\n"
"      -p\tprint the list of builtins in a reusable format\n"
"      -s\tprint only the names of Posix `special' builtins\n"
"    \n"
"    Options controlling dynamic loading:\n"
"      -f\tLoad builtin NAME from shared object FILENAME\n"
"      -d\tRemove a builtin loaded with -f\n"
"    \n"
"    Without options, each NAME is enabled.\n"
"    \n"
"    To use the `test' found in $PATH instead of the shell builtin\n"
"    version, type `enable -n test'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not a shell builtin or an error occurs."
msgstr ""
"Activa y desactiva las órdenes internas del shell.\n"
"    \n"
"    Activa y desactiva las órdenes internas del shell.  El desactivar le\n"
"    permite ejecutar una orden del disco que tenga el mismo nombre que\n"
"    la orden interna del shell, sin usar el nombre de ruta completo.\n"
"    \n"
"    Opciones:\n"
"      -a\tmuestra la lista de órdenes internas indicando si están activas o "
"no\n"
"      -n\tdesactiva cada NOMBRE o muestra la lista de órdenes internas\n"
"    \tdesactivadas\n"
"      -p\tmuestra la lista de órdenes internas en una forma reusable\n"
"      -s\tmuestra sólo los nombres de las órdenes internas `especiales' "
"Posix\n"
"    \n"
"    Opciones que controlan la carga dinámica:\n"
"      -f\tcarga la orden interna NOMBRE del objeto compartido FICHERO\n"
"      -d\tborra una orden interna cargada con -f\n"
"    \n"
"    Sin opciones, se activa cada NOMBRE.\n"
"    \n"
"    Para usar `test' que se encuentra en $PATH en lugar de la orden interna\n"
"    del shell, ejecute `enable -n test'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que NOMBRE no sea una orden interna del "
"shell\n"
"    o suceda un error."

#: builtins.c:614
msgid ""
"Execute arguments as a shell command.\n"
"    \n"
"    Combine ARGs into a single string, use the result as input to the "
"shell,\n"
"    and execute the resulting commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns exit status of command or success if command is null."
msgstr ""
"Ejecuta argumentos como una orden de shell.\n"
"    \n"
"    Combina los ARGumentos en una sola cadena, usa el resultado como "
"entrada\n"
"    para el shell, y ejecuta las órdenes resultantes.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la orden o éxito si la orden es nula."

# "a ser reconocidas" no está en español.
# Yo pondría "las letras de opción que se reconocen". sv
# en una de dos formas -> en una de las dos formas siguientes em+
# dar argumentos -> especificar em+
# De acuerdo. cfuga
#: builtins.c:626
msgid ""
"Parse option arguments.\n"
"    \n"
"    Getopts is used by shell procedures to parse positional parameters\n"
"    as options.\n"
"    \n"
"    OPTSTRING contains the option letters to be recognized; if a letter\n"
"    is followed by a colon, the option is expected to have an argument,\n"
"    which should be separated from it by white space.\n"
"    \n"
"    Each time it is invoked, getopts will place the next option in the\n"
"    shell variable $name, initializing name if it does not exist, and\n"
"    the index of the next argument to be processed into the shell\n"
"    variable OPTIND.  OPTIND is initialized to 1 each time the shell or\n"
"    a shell script is invoked.  When an option requires an argument,\n"
"    getopts places that argument into the shell variable OPTARG.\n"
"    \n"
"    getopts reports errors in one of two ways.  If the first character\n"
"    of OPTSTRING is a colon, getopts uses silent error reporting.  In\n"
"    this mode, no error messages are printed.  If an invalid option is\n"
"    seen, getopts places the option character found into OPTARG.  If a\n"
"    required argument is not found, getopts places a ':' into NAME and\n"
"    sets OPTARG to the option character found.  If getopts is not in\n"
"    silent mode, and an invalid option is seen, getopts places '?' into\n"
"    NAME and unsets OPTARG.  If a required argument is not found, a '?'\n"
"    is placed in NAME, OPTARG is unset, and a diagnostic message is\n"
"    printed.\n"
"    \n"
"    If the shell variable OPTERR has the value 0, getopts disables the\n"
"    printing of error messages, even if the first character of\n"
"    OPTSTRING is not a colon.  OPTERR has the value 1 by default.\n"
"    \n"
"    Getopts normally parses the positional parameters ($0 - $9), but if\n"
"    more arguments are given, they are parsed instead.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if an option is found; fails if the end of options is\n"
"    encountered or an error occurs."
msgstr ""
"Decodifica argumentos de opción.\n"
"\n"
"    Getopts se usa en procedimientos del shell para decodificar parámetros\n"
"    posicionales como opciones.\n"
"    \n"
"    CADENA_OPCIONES contiene las letras de opción para reconocer; si\n"
"    una letra es seguida por dos puntos, se espera que la opción tenga\n"
"    un argumento, del cual se debe separar con espacios en blanco.\n"
"    \n"
"    Cada vez que se invoca, getopts colocará la siguiente opción en la\n"
"    variable de shell $nombre, inicializando nombre si no existe, y el\n"
"    índice del siguiente argumento a ser procesado en la variable de\n"
"    shell OPTIND.  OPTIND se inicializa a 1 cada vez que se invoca el\n"
"    shell, o un guión de shell.  Cuando una opción requiere un argumento,\n"
"    getopts coloca ese argumento en la variable de shell OPTARG.\n"
"    \n"
"    getopts reporta errores en una de las dos formas siguientes.  Si\n"
"    el primer carácter de OPTSTRING es dos puntos, getopts usa el\n"
"    aviso de errores silencioso.  En este modo, no se muestran\n"
"    mensajes de error.  Si se encuentra una opción inválida, getopts\n"
"    coloca el carácter de opción encontrado en OPTARG.  Si no se\n"
"    encuentra el argumento necesario, getopts coloca ':' en NOMBRE y\n"
"    define OPTARG con el carácter de opción encontrado.  Si getopts no\n"
"    está en modo silencioso, y se encuentra una opción inválida, getopts\n"
"    coloca '?' en NOMBRE y borra OPTARG.  Si no se encuentra un argumento\n"
"    necesario, se coloca '?' en NOMBRE, se borra OPTARG, y se muestra\n"
"    un mensaje de diagnóstico.\n"
"    \n"
"    Si la variable de shell OPTERR tiene el valor 0, getopts desactiva\n"
"    la notificación de mensajes de error, aún si el primer carácter de\n"
"    OPTSTRING no es ':'.  OPTERR tiene el valor 1 por defecto.\n"
"    \n"
"    Getopts normalmente compara los parámetros de posición ($0 - $9),\n"
"    pero si se especifican más argumentos, éstos se comparan en lugar\n"
"    de los primeros.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito si se encuentra una opción; falla si se encuentra\n"
"    el final de las opciones o sucede un error."

#: builtins.c:668
msgid ""
"Replace the shell with the given command.\n"
"    \n"
"    Execute COMMAND, replacing this shell with the specified program.\n"
"    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not "
"specified,\n"
"    any redirections take effect in the current shell.\n"
"    \n"
"    Options:\n"
"      -a name\tpass NAME as the zeroth argument to COMMAND\n"
"      -c\t\texecute COMMAND with an empty environment\n"
"      -l\t\tplace a dash in the zeroth argument to COMMAND\n"
"    \n"
"    If the command cannot be executed, a non-interactive shell exits, "
"unless\n"
"    the shell option `execfail' is set.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless COMMAND is not found or a redirection error "
"occurs."
msgstr ""
"Reemplaza el shell con la orden dada.\n"
"    \n"
"    Ejecuta la ORDEN, reemplazando este shell con el programa especificado.\n"
"    Los ARGUMENTOS se vuelven los argumentos de la ORDEN.  Si no se\n"
"    especifica la ORDEN, cualquir redirección toma efecto en el shell "
"actual.\n"
"    \n"
"    Opciones:\n"
"      -a nombre\tpasa el NOMBRE como el argumento cero de la ORDEN\n"
"      -c\t\tejecuta la ORDEN en un ambiente vacío\n"
"      -l\t\tcoloca un guión en el argumento cero de la ORDEN\n"
"    \n"
"    Si la orden no se puede ejecutar, termina un shell no interactivo,\n"
"    a menos que la opción de shell `execfail' esté activa.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve éxito a menos que no se encuentre la ORDEN o que suceda un\n"
"    error de redirección."

#: builtins.c:689
msgid ""
"Exit the shell.\n"
"    \n"
"    Exits the shell with a status of N.  If N is omitted, the exit status\n"
"    is that of the last command executed."
msgstr ""
"Termina el shell.\n"
"    \n"
"    Termina el shell con un estado de N.  Si se omite N, el estado de "
"salida\n"
"    es el mismo de la última orden ejecutada."

#: builtins.c:698
msgid ""
"Exit a login shell.\n"
"    \n"
"    Exits a login shell with exit status N.  Returns an error if not "
"executed\n"
"    in a login shell."
msgstr ""
"Termina un shell de entrada.\n"
"    \n"
"    Termina un shell de entrada con un estado de salida de N. Devuelve un\n"
"    error si no se ejecuta en un shell de entrada."

#: builtins.c:708
msgid ""
"Display or execute commands from the history list.\n"
"    \n"
"    fc is used to list or edit and re-execute commands from the history "
"list.\n"
"    FIRST and LAST can be numbers specifying the range, or FIRST can be a\n"
"    string, which means the most recent command beginning with that\n"
"    string.\n"
"    \n"
"    Options:\n"
"      -e ENAME\tselect which editor to use.  Default is FCEDIT, then "
"EDITOR,\n"
"    \t\tthen vi\n"
"      -l \tlist lines instead of editing\n"
"      -n\tomit line numbers when listing\n"
"      -r\treverse the order of the lines (newest listed first)\n"
"    \n"
"    With the `fc -s [pat=rep ...] [command]' format, COMMAND is\n"
"    re-executed after the substitution OLD=NEW is performed.\n"
"    \n"
"    A useful alias to use with this is r='fc -s', so that typing `r cc'\n"
"    runs the last command beginning with `cc' and typing `r' re-executes\n"
"    the last command.\n"
"    \n"
"    Exit Status:\n"
"    Returns success or status of executed command; non-zero if an error "
"occurs."
msgstr ""
"Muestra o ejecuta órdenes de la lista de historia.\n"
"    \n"
"    fc se usa para listar o editar y reejecutar órdenes de la lista de\n"
"    historia.  PRIMERO y ÚLTIMO pueden ser números que especifican el "
"rango,\n"
"    o PRIMERO puede ser una cadena, que significa la orden más reciente que\n"
"    comience con esa cadena.\n"
"    \n"
"       -e NOMBRE_E selecciona el editor a usar.  Por defecto es FCEDIT,\n"
"    \t\tdespués EDITOR, después vi\n"
"       -l lista líneas en lugar de editar\n"
"       -n omite los números de línea al listar\n"
"       -r inverte el orden de las líneas (muestra primero las más "
"recientes)\n"
"    \n"
"    Con el formato `fc -s [pat=rep ...] [orden]', la ORDEN se\n"
"    ejecuta de nuevo después de realizar la sustitución ANT=NUEVO.\n"
"    \n"
"    Un alias útil para usar con esto es r='fc -s', así que al teclear\n"
"    `r cc' ejecuta la última orden que comience con `cc' y al teclear\n"
"    `r' re-ejecuta la última orden.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito o el estado de la orden ejecutada; si sucede un "
"error\n"
"    es diferente de cero."

#: builtins.c:738
msgid ""
"Move job to the foreground.\n"
"    \n"
"    Place the job identified by JOB_SPEC in the foreground, making it the\n"
"    current job.  If JOB_SPEC is not present, the shell's notion of the\n"
"    current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Status of command placed in foreground, or failure if an error occurs."
msgstr ""
"Mueve el trabajo al primer plano.\n"
"    \n"
"    Ubica al trabajo identificado con IDTRABAJO en el primer plano, y\n"
"    lo hace el trabajo actual.  Si IDTRABAJO no está presente, se usa\n"
"    la noción del shell del trabajo actual.\n"
"    \n"
"    Estado de Salida:\n"
"    El estado del comando ubicado en primer plano, o falla si sucede un "
"error."

#: builtins.c:753
msgid ""
"Move jobs to the background.\n"
"    \n"
"    Place the jobs identified by each JOB_SPEC in the background, as if "
"they\n"
"    had been started with `&'.  If JOB_SPEC is not present, the shell's "
"notion\n"
"    of the current job is used.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Mueve trabajos al segundo plano.\n"
"    \n"
"    Coloca los trabajos identificados por cada IDTRABAJO en segundo plano,\n"
"    como si se hubieran iniciado con `&'.  Si IDTRABAJO no está presente,\n"
"    se usa la noción del shell del trabajo actual.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve éxito a menos que el control de trabajos no esté activado o\n"
"    suceda un error."

#: builtins.c:767
msgid ""
"Remember or display program locations.\n"
"    \n"
"    Determine and remember the full pathname of each command NAME.  If\n"
"    no arguments are given, information about remembered commands is "
"displayed.\n"
"    \n"
"    Options:\n"
"      -d\t\tforget the remembered location of each NAME\n"
"      -l\t\tdisplay in a format that may be reused as input\n"
"      -p pathname\tuse PATHNAME is the full pathname of NAME\n"
"      -r\t\tforget all remembered locations\n"
"      -t\t\tprint the remembered location of each NAME, preceding\n"
"    \t\teach location with the corresponding NAME if multiple\n"
"    \t\tNAMEs are given\n"
"    Arguments:\n"
"      NAME\t\tEach NAME is searched for in $PATH and added to the list\n"
"    \t\tof remembered commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is not found or an invalid option is given."
msgstr ""
"Almacena o muestra la ubicación de los programas.\n"
"    \n"
"    Determina y almacena la ruta completa de cada órden NOMBRE. Si\n"
"    no se proporcionan argumentos, se muestra la información de las\n"
"    órdenes almacenadas.\n"
"    \n"
"    Opciones:\n"
"      -d\t\tolvida la ubicación almacenada de cada NOMBRE\n"
"      -l\t\tmuestra en un formato que se puede reusar como entrada\n"
"      -p ruta\tusa RUTA como la ruta completa de NOMBRE\n"
"      -r\t\tolvida todas las ubicaciones almacenadas\n"
"      -t\t\tmuestra la ubicación almacenada de cada NOMBRE,\n"
"    \t\tcada ubicación con el NOMBRE correspondiente\n"
"    \t\tse dan varios NOMBREs\n"
"    Argumentos:\n"
"      NOMBRE\t\tCada NOMBRE se busca en $PATH y se agrega a la lista\n"
"    \t\tde órdenes almacenadas.\n"
"    \n"
"    Estado de Salida\n"
"    Devuelve con éxito a menos que no se encuentre NOMBRE o se proporcione\n"
"    una opción inválida."

#: builtins.c:792
msgid ""
"Display information about builtin commands.\n"
"    \n"
"    Displays brief summaries of builtin commands.  If PATTERN is\n"
"    specified, gives detailed help on all commands matching PATTERN,\n"
"    otherwise the list of help topics is printed.\n"
"    \n"
"    Options:\n"
"      -d\toutput short description for each topic\n"
"      -m\tdisplay usage in pseudo-manpage format\n"
"      -s\toutput only a short usage synopsis for each topic matching\n"
"    \tPATTERN\n"
"    \n"
"    Arguments:\n"
"      PATTERN\tPattern specifiying a help topic\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless PATTERN is not found or an invalid option is "
"given."
msgstr ""
"Muestra información sobre órdenes internas.\n"
"    \n"
"    Muestra un resumen breve de las órdenes internas.  Si se especifica\n"
"    un PATRÓN, da ayuda detallada sobre todas las órdenes que\n"
"    coincidan con el PATRÓN, de otra forma se muestra la lista de\n"
"    tópicos de ayuda.\n"
"    \n"
"    Opciones:\n"
"      -d\tmuestra una descripción corta para cada tópico\n"
"      -m\tmuestra el uso en un formato similar a página man\n"
"      -s\tmuestra sólo una sinopsis breve de uso para cada tópico que\n"
"    \tcoincida con el PATRÓN\n"
"    \n"
"    Argumentos:\n"
"      PATRÓN\tPatrón que especifica un tópico de ayuda\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que no se encuentre PATRÓN o se proporcione\n"
"    una opción inválida."

#: builtins.c:816
msgid ""
"Display or manipulate the history list.\n"
"    \n"
"    Display the history list with line numbers, prefixing each modified\n"
"    entry with a `*'.  An argument of N lists only the last N entries.\n"
"    \n"
"    Options:\n"
"      -c\tclear the history list by deleting all of the entries\n"
"      -d offset\tdelete the history entry at offset OFFSET.\n"
"    \n"
"      -a\tappend history lines from this session to the history file\n"
"      -n\tread all history lines not already read from the history file\n"
"      -r\tread the history file and append the contents to the history\n"
"    \tlist\n"
"      -w\twrite the current history to the history file\n"
"    \tand append them to the history list\n"
"    \n"
"      -p\tperform history expansion on each ARG and display the result\n"
"    \twithout storing it in the history list\n"
"      -s\tappend the ARGs to the history list as a single entry\n"
"    \n"
"    If FILENAME is given, it is used as the history file.  Otherwise,\n"
"    if $HISTFILE has a value, that is used, else ~/.bash_history.\n"
"    \n"
"    If the $HISTTIMEFORMAT variable is set and not null, its value is used\n"
"    as a format string for strftime(3) to print the time stamp associated\n"
"    with each displayed history entry.  No time stamps are printed "
"otherwise.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Muestra o manipula la lista de la historia.    \n"
"    Muestra la lista de la historia con números de línea, mostrando\n"
"    cada línea modificada con un `*' como prefijo.  El argumento N\n"
"    muestra solamente las últimas N entradas.\n"
"    \n"
"    Opciones:\n"
"      -c\tborra la lista de historia eliminando todas las entradas\n"
"      -d despl\tborra la entrada de la histora en la posición DESPL\n"
"    \n"
"      -a\tagrega las líneas de histora de esta sesión al fichero de "
"historia\n"
"      -n\tlee todas las líneas de historia que no se han leído del fichero\n"
"    \tde historia\n"
"      -r\tlee el fichero de historia y agrega el contenido al fichero\n"
"    \tde historia\n"
"      -w\tescribe la historia actual en el fichero de historia\n"
"    \n"
"      -p\thace expansión de historia en cada ARGumento y muestra el\n"
"    \tresultado, sin guardarlo en la lista de historia\n"
"      -s\tagrega los ARGumentos a la lista de historia como\n"
"    \tuna sola entrada\n"
"    Si se proporciona FICHERO, entonces se usa como el fichero de\n"
"    historia. Si no, si $HISTFILE tien un valor, éste se usa, en otro caso\n"
"    ~/.bash_history.\n"
"    \n"
"    Si la variable $HISTTIMEFORMAT está definida y no es nula, se usa su\n"
"    valor como una cadena de formato strftime(3) para mostrar la marca de\n"
"    tiempo asociada con cada entrada de historia mostrada.  No se muestra\n"
"    ninguna marca de tiempo de otra forma."

#: builtins.c:852
msgid ""
"Display status of jobs.\n"
"    \n"
"    Lists the active jobs.  JOBSPEC restricts output to that job.\n"
"    Without options, the status of all active jobs is displayed.\n"
"    \n"
"    Options:\n"
"      -l\tlists process IDs in addition to the normal information\n"
"      -n\tlist only processes that have changed status since the last\n"
"    \tnotification\n"
"      -p\tlists process IDs only\n"
"      -r\trestrict output to running jobs\n"
"      -s\trestrict output to stopped jobs\n"
"    \n"
"    If -x is supplied, COMMAND is run after all job specifications that\n"
"    appear in ARGS have been replaced with the process ID of that job's\n"
"    process group leader.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs.\n"
"    If -x is used, returns the exit status of COMMAND."
msgstr ""
"Muestra el estado de los trabajos.\n"
"    \n"
"    Muestra los trabajos activos.  IDTRABAJO restringe la salida a\n"
"    ese trabajo.  Sin opciones, se muestra el estado de todos los trabajos\n"
"    activos.\n"
"    \n"
"    Opciones:\n"
"      -l\tmuestra los id's de los procesos, además de\n"
"    \tla información normal\n"
"      -n\tsolo muestra los procesos que han cambia de estado desde\n"
"    \tla última notificación\n"
"      -p\tsolo muestra los id's de los procesos      -r\trestringe la salida "
"a los trabajos en ejecución\n"
"      -s\trestringe la salida a los trabajos detenidos\n"
"    \n"
"    Si se especifica -x, la ORDEN se ejecuta después de que todas las\n"
"    especificaciones de trabajo que aparecen en ARGS se han reemplazado\n"
"    con el ID de proceso del líder del grupo de procesos de dicho trabajo.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se de una opción inválida o suceda un\n"
"    error.  Si se usa -x, devuelve el estado de salida de la ORDEN."

#: builtins.c:879
msgid ""
"Remove jobs from current shell.\n"
"    \n"
"    Removes each JOBSPEC argument from the table of active jobs.  Without\n"
"    any JOBSPECs, the shell uses its notion of the current job.\n"
"    \n"
"    Options:\n"
"      -a\tremove all jobs if JOBSPEC is not supplied\n"
"      -h\tmark each JOBSPEC so that SIGHUP is not sent to the job if the\n"
"    \tshell receives a SIGHUP\n"
"      -r\tremove only running jobs\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option or JOBSPEC is given."
msgstr ""
"Borra trabajos del shell actual.\n"
"    \n"
"    Borra cada argumento IDTRABAJO de la tabla de trabajos activos. Sin\n"
"    algún IDTRABAJO, el shell utiliza su noción del trabajo actual.\n"
"    \n"
"    Opciones:\n"
"      -a\tborra todos los trabajos si no se proporciona IDTRABAJO\n"
"      -h\tmarca cada IDTRABAJO para no se envíe SIGHUP al trabajo si\n"
"    \tel shell recibe un SIGHUP\n"
"      -r\tborra solo los trabajos en ejecución\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcionen una opción o un\n"
"    IDTRABAJO inválidos."

#: builtins.c:898
msgid ""
"Send a signal to a job.\n"
"    \n"
"    Send the processes identified by PID or JOBSPEC the signal named by\n"
"    SIGSPEC or SIGNUM.  If neither SIGSPEC nor SIGNUM is present, then\n"
"    SIGTERM is assumed.\n"
"    \n"
"    Options:\n"
"      -s sig\tSIG is a signal name\n"
"      -n sig\tSIG is a signal number\n"
"      -l\tlist the signal names; if arguments follow `-l' they are\n"
"    \tassumed to be signal numbers for which names should be listed\n"
"    \n"
"    Kill is a shell builtin for two reasons: it allows job IDs to be used\n"
"    instead of process IDs, and allows processes to be killed if the limit\n"
"    on processes that you can create is reached.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or an error occurs."
msgstr ""
"Envía una señal a un trabajo.\n"
"    \n"
"    Envía a los procesos nombrados por PID (o IDTRABAJO) la señal ID_SEÑAL\n"
"    o NUM_SEÑAL. Si no están presentes ni ID_SEÑAL o NUM_SEÑAL, se asume\n"
"    SIGTERM.\n"
"    \n"
"    Opciones:\n"
"      -s sig\tSIG es un nombre de señal\n"
"      -n sig\tSIG es un número de señal\n"
"      -l\tenlista los nombres de señales; si hay argumentos a continuación\n"
"    \tde `-l', se asume que son números de señal para las cuales se debe\n"
"    mostrar el nombre.\n"
"    \n"
"    Kill es una orden interna del shell por dos razones: permite que se\n"
"    puedan usar IDs de trabajo en lugar de IDs de proceso, y permite matar\n"
"    procesos si ha alcanzado el límite de procesos que puede crear.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se de una opción inválida o suceda un "
"error."

# "a ser evaluada" no está en español. sv
# Cierto. ¿Así está mejor? cfuga
# overflow -> desbordamiento o sobrepasamiento. nunca lo he visto
# traducido como sobreflujo. sv
# Corregido. cfuga
# No sé si existe precedencia en español, pero me suena fatal.
# Yo pondría simplemente "prioridad". sv
# Creo que si existe, pero tu sugerencia es mejor. cfuga
#: builtins.c:921
msgid ""
"Evaluate arithmetic expressions.\n"
"    \n"
"    Evaluate each ARG as an arithmetic expression.  Evaluation is done in\n"
"    fixed-width integers with no check for overflow, though division by 0\n"
"    is trapped and flagged as an error.  The following list of operators is\n"
"    grouped into levels of equal-precedence operators.  The levels are "
"listed\n"
"    in order of decreasing precedence.\n"
"    \n"
"    \tid++, id--\tvariable post-increment, post-decrement\n"
"    \t++id, --id\tvariable pre-increment, pre-decrement\n"
"    \t-, +\t\tunary minus, plus\n"
"    \t!, ~\t\tlogical and bitwise negation\n"
"    \t**\t\texponentiation\n"
"    \t*, /, %\t\tmultiplication, division, remainder\n"
"    \t+, -\t\taddition, subtraction\n"
"    \t<<, >>\t\tleft and right bitwise shifts\n"
"    \t<=, >=, <, >\tcomparison\n"
"    \t==, !=\t\tequality, inequality\n"
"    \t&\t\tbitwise AND\n"
"    \t^\t\tbitwise XOR\n"
"    \t|\t\tbitwise OR\n"
"    \t&&\t\tlogical AND\n"
"    \t||\t\tlogical OR\n"
"    \texpr ? expr : expr\n"
"    \t\t\tconditional operator\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tassignment\n"
"    \n"
"    Shell variables are allowed as operands.  The name of the variable\n"
"    is replaced by its value (coerced to a fixed-width integer) within\n"
"    an expression.  The variable need not have its integer attribute\n"
"    turned on to be used in an expression.\n"
"    \n"
"    Operators are evaluated in order of precedence.  Sub-expressions in\n"
"    parentheses are evaluated first and may override the precedence\n"
"    rules above.\n"
"    \n"
"    Exit Status:\n"
"    If the last ARG evaluates to 0, let returns 1; let returns 0 otherwise.."
msgstr ""
"Evalúa expresiones aritméticas.\n"
"    \n"
"    Evalúa cada ARG como una expresión aritmética.  La evaluación se hace\n"
"    con enteros de longitud fija, sin revisar desbordamientos, aunque la\n"
"    la división por 0 se captura y se marca como un error.  La siguiente\n"
"    lista de operadores está agrupada en niveles de operadores de la misma\n"
"    prioridad.  Se muestran los niveles en orden de prioridad decreciente.\n"
"    \n"
"    \tid++, id--\tpost-incremento, post-decremento de variable\n"
"    \t++id, --id\tpre-incremento, pre-decremento de variable\n"
"    \t-, +\t\tmenos, más unario\n"
"    \t!, ~\t\tnegación lógica y basada en bits\n"
"    \t**\t\texponenciación\n"
"    \t*, /, %\t\tmultiplicación, división, residuo\n"
"    \t+, -\t\tadición, sustracción\n"
"    \t<<, >>\t\tdesplazamientos de bits izquierdo y derecho\n"
"    \t<=, >=, <, >\tcomparación\n"
"    \t==, !=\t\tequivalencia, inequivalencia\n"
"    \t&\t\tAND de bits\n"
"    \t^\t\tXOR de bits\n"
"    \t|\t\tOR de bits\n"
"    \t&&\t\tAND lógico\n"
"    \t||\t\tOR lógico\n"
"    \texpr ? expr : expr\n"
"    \t\t\toperador condicional\n"
"    \t=, *=, /=, %=,\n"
"    \t+=, -=, <<=, >>=,\n"
"    \t&=, ^=, |=\tasignación\n"
"    \n"
"    Se permiten las variables de shell como operandos.  Se reemplaza\n"
"    el nombre de la variable por su valor (coercionado a un entero\n"
"    de longitud fija) dentro de una expresión.  La variable no\n"
"    necesita tener activado su atributo integer para ser usada en\n"
"    una expresión.\n"
"    \n"
"    Los operadores se evalúan en orden de prioridad.  Primero se\n"
"    evalúan las sub-expresiones en paréntesis y pueden sobrepasar\n"
"    las reglas de prioridad anteriores.\n"
"    \n"
"    Estado de salida:\n"
"    Si el último ARGumento se evalúa como 0, let devuelve 1; de otra\n"
"    forma, let devuelve 0."

#: builtins.c:966
#, fuzzy
msgid ""
"Read a line from the standard input and split it into fields.\n"
"    \n"
"    Reads a single line from the standard input, or from file descriptor FD\n"
"    if the -u option is supplied.  The line is split into fields as with "
"word\n"
"    splitting, and the first word is assigned to the first NAME, the second\n"
"    word to the second NAME, and so on, with any leftover words assigned to\n"
"    the last NAME.  Only the characters found in $IFS are recognized as "
"word\n"
"    delimiters.\n"
"    \n"
"    If no NAMEs are supplied, the line read is stored in the REPLY "
"variable.\n"
"    \n"
"    Options:\n"
"      -a array\tassign the words read to sequential indices of the array\n"
"    \t\tvariable ARRAY, starting at zero\n"
"      -d delim\tcontinue until the first character of DELIM is read, rather\n"
"    \t\tthan newline\n"
"      -e\t\tuse Readline to obtain the line in an interactive shell\n"
"      -i text\tUse TEXT as the initial text for Readline\n"
"      -n nchars\treturn after reading NCHARS characters rather than waiting\n"
"    \t\tfor a newline, but honor a delimiter if fewer than NCHARS\n"
"    \t\tcharacters are read before the delimiter\n"
"      -N nchars\treturn only after reading exactly NCHARS characters, "
"unless\n"
"    \t\tEOF is encountered or read times out, ignoring any delimiter\n"
"      -p prompt\toutput the string PROMPT without a trailing newline before\n"
"    \t\tattempting to read\n"
"      -r\t\tdo not allow backslashes to escape any characters\n"
"      -s\t\tdo not echo input coming from a terminal\n"
"      -t timeout\ttime out and return failure if a complete line of input "
"is\n"
"    \t\tnot read withint TIMEOUT seconds.  The value of the TMOUT\n"
"    \t\tvariable is the default timeout.  TIMEOUT may be a\n"
"    \t\tfractional number.  If TIMEOUT is 0, read returns success only\n"
"    \t\tif input is available on the specified file descriptor.  The\n"
"    \t\texit status is greater than 128 if the timeout is exceeded\n"
"      -u fd\t\tread from file descriptor FD instead of the standard input\n"
"    \n"
"    Exit Status:\n"
"    The return code is zero, unless end-of-file is encountered, read times "
"out,\n"
"    or an invalid file descriptor is supplied as the argument to -u."
msgstr ""
"Lee una línea de la salida estándar y la divide en campos.\n"
"    \n"
"    Lee una sola línea de la entrada estándar, o del descriptor de\n"
"    fichero FD si se proporciona la opción -u.  La línea se divide en "
"campos\n"
"    con separación de palabras, y la primera palabra se asigna al primer\n"
"    NOMBRE, la segunda palabra al segundo NOMBRE, y así sucesivamente, con\n"
"    las palabras restantes asignadas al último NOMBRE.  Sólo los caracteres\n"
"    que se encuentran en $IFS se reconocen como delimitadores de palabras.\n"
"    \n"
"    Si no se proporciona ningún NOMBRE, la línea leída se guarda en la\n"
"    variable REPLY.\n"
"    \n"
"    Opciones:\n"
"      -a matriz\tasigna las palabras leídas a índices secuenciales de\n"
"    \tla variable de matriz MATRIZ, empezando en cero\n"
"      -d delim\tcontinúa hasta que se lea el primer carácter de DELIM,\n"
"    \t\ten lugar de línea nueva\n"
"      -e\t\tusa Readline para obtener la línea en un shell interactivo\n"
"      -i texto\tUsa el TEXTO como el texto inicial para Readline\n"
"      -n ncars\tregresa después de leer NCARS caracteres en lugar de\n"
"    \t\tesperar una línea nueva\n"
"      -p prompt\tmuestra la cadena PROMPT sin un caractér de línea nueva\n"
"    \t\tal final antes de intentar leer\n"
"      -r\t\tno permite que las barras invertidas escapen caracteres\n"
"      -s\t\tno muestra la salida que proviene de una terminal\n"
"      -t tiempo\texpira y devuelve fallo si no se lee una línea completa\n"
"    \t\tde entrada en TIEMPO segundos.  El valor de la variable TMOUT\n"
"    \t\tes el tiempo de expiración por defecto.  TIEMPO puede ser un\n"
"    \t\tnúmero fraccionario.  Si TIEMPO es 0, read devuelve con éxito\n"
"    \t\tsólo si hay entrada disponible en el descriptor de fichero\n"
"    \t\tespecificado.  El estado de salida es mayor que 128 si se excede\n"
"    \t\tel tiempo de expiración.\n"
"      -u df\t\tlee del descriptor de fichero DF en lugar de la entrada\n"
"    \t\testándar    \n"
"    Estado de Salida:\n"
"    El código de devolución es cero, a menos que se encuentre un final de\n"
"    línea, el tiempo de read expire, o se proporcione un descriptor de\n"
"    fichero inválido como el argumento de -u."

#: builtins.c:1009
msgid ""
"Return from a shell function.\n"
"    \n"
"    Causes a function or sourced script to exit with the return value\n"
"    specified by N.  If N is omitted, the return status is that of the\n"
"    last command executed within the function or script.\n"
"    \n"
"    Exit Status:\n"
"    Returns N, or failure if the shell is not executing a function or script."
msgstr ""
"Devuelve de una función de shell.\n"
"    \n"
"    Causa que una función o un guión leído termine con el valor de "
"devolución\n"
"    especificado por N.  Si se omite N, el estado de devolución es el de\n"
"    la última orden ejecutada dentro de la función o guión.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve N, o falla si el shell no está ejecutando una función o un "
"guión."

#: builtins.c:1022
msgid ""
"Set or unset values of shell options and positional parameters.\n"
"    \n"
"    Change the value of shell attributes and positional parameters, or\n"
"    display the names and values of shell variables.\n"
"    \n"
"    Options:\n"
"      -a  Mark variables which are modified or created for export.\n"
"      -b  Notify of job termination immediately.\n"
"      -e  Exit immediately if a command exits with a non-zero status.\n"
"      -f  Disable file name generation (globbing).\n"
"      -h  Remember the location of commands as they are looked up.\n"
"      -k  All assignment arguments are placed in the environment for a\n"
"          command, not just those that precede the command name.\n"
"      -m  Job control is enabled.\n"
"      -n  Read commands but do not execute them.\n"
"      -o option-name\n"
"          Set the variable corresponding to option-name:\n"
"              allexport    same as -a\n"
"              braceexpand  same as -B\n"
"              emacs        use an emacs-style line editing interface\n"
"              errexit      same as -e\n"
"              errtrace     same as -E\n"
"              functrace    same as -T\n"
"              hashall      same as -h\n"
"              histexpand   same as -H\n"
"              history      enable command history\n"
"              ignoreeof    the shell will not exit upon reading EOF\n"
"              interactive-comments\n"
"                           allow comments to appear in interactive commands\n"
"              keyword      same as -k\n"
"              monitor      same as -m\n"
"              noclobber    same as -C\n"
"              noexec       same as -n\n"
"              noglob       same as -f\n"
"              nolog        currently accepted but ignored\n"
"              notify       same as -b\n"
"              nounset      same as -u\n"
"              onecmd       same as -t\n"
"              physical     same as -P\n"
"              pipefail     the return value of a pipeline is the status of\n"
"                           the last command to exit with a non-zero status,\n"
"                           or zero if no command exited with a non-zero "
"status\n"
"              posix        change the behavior of bash where the default\n"
"                           operation differs from the Posix standard to\n"
"                           match the standard\n"
"              privileged   same as -p\n"
"              verbose      same as -v\n"
"              vi           use a vi-style line editing interface\n"
"              xtrace       same as -x\n"
"      -p  Turned on whenever the real and effective user ids do not match.\n"
"          Disables processing of the $ENV file and importing of shell\n"
"          functions.  Turning this option off causes the effective uid and\n"
"          gid to be set to the real uid and gid.\n"
"      -t  Exit after reading and executing one command.\n"
"      -u  Treat unset variables as an error when substituting.\n"
"      -v  Print shell input lines as they are read.\n"
"      -x  Print commands and their arguments as they are executed.\n"
"      -B  the shell will perform brace expansion\n"
"      -C  If set, disallow existing regular files to be overwritten\n"
"          by redirection of output.\n"
"      -E  If set, the ERR trap is inherited by shell functions.\n"
"      -H  Enable ! style history substitution.  This flag is on\n"
"          by default when the shell is interactive.\n"
"      -P  If set, do not follow symbolic links when executing commands\n"
"          such as cd which change the current directory.\n"
"      -T  If set, the DEBUG trap is inherited by shell functions.\n"
"      -   Assign any remaining arguments to the positional parameters.\n"
"          The -x and -v options are turned off.\n"
"    \n"
"    Using + rather than - causes these flags to be turned off.  The\n"
"    flags can also be used upon invocation of the shell.  The current\n"
"    set of flags may be found in $-.  The remaining n ARGs are positional\n"
"    parameters and are assigned, in order, to $1, $2, .. $n.  If no\n"
"    ARGs are given, all shell variables are printed.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given."
msgstr ""
"Establece o borra los valores de las opciones de shell y los parámetros\n"
"posicionales.\n"
"    \n"
"    Opciones:\n"
"      -a  Marca las variables que se modifican o crean para exportación.\n"
"      -b  Notifica el término de trabajos inmediatamente.\n"
"      -e  Termina inmediatamente si una orden termina con un estado\n"
"          diferente a cero.\n"
"      -f  Desactiva la generación de nombres de ficheros (englobamiento).\n"
"      -h  Recuerda la ubicación de las órdenes como se localizaron.\n"
"      -k  Todos los argumentos de asignación se colocan en el ambiente para "
"una\n"
"          orden, no solo aquellos que preceden al nombre de la orden.\n"
"      -m  Activa el control de trabajos.\n"
"      -n  Lee órdenes pero no las ejecuta.\n"
"      -o nombre-opcion\n"
"          Establece la variable correspondiente a nombre-opcion:\n"
"              allexport    igual que -a\n"
"              braceexpand  igual que -B\n"
"              emacs        usa una interfaz de edición de línea estilo "
"emacs\n"
"              errexit      igual que -e\n"
"              errtrace     igual que -E\n"
"              functrace    igual que -T\n"
"              hashall      igual que -h\n"
"              histexpand   igual que -H\n"
"              history      activa la historia de órdenes\n"
"              ignoreeof    el shell no terminará después de leer EOF\n"
"              interactive-comments\n"
"                           permite que haya comentarios en órdenes "
"interactivas\n"
"              keyword      igual que -k\n"
"              monitor      igual que -m\n"
"              noclobber    igual que -C\n"
"              noexec       igual que -n\n"
"              noglob       igual que -f\n"
"              nolog        actualmente se acepta pero se descarta\n"
"              notify       igual que -b\n"
"              nounset      igual que -u\n"
"              onecmd       igual que -t\n"
"              physical     igual que -P\n"
"              pipefail     el valor de devolución de una tubería es el "
"estado\n"
"                           del último comando en salir con un estado "
"diferente\n"
"                           de cero, o cero si ninguna orden termina con un\n"
"                           estado diferente de cero\n"
"              posix        cambia el comportamiento de bash donde la "
"operación\n"
"                           por defecto difiere del estándar Posix para que\n"
"                           coincida con el estándar\n"
"              privileged   igual que -p\n"
"              verbose      igual que -v\n"
"              vi           usa una interfaz de edición de línea estilo vi\n"
"              xtrace       igual que -x\n"
"      -p  Activo cuando los ids real y efectivo del usuario no coinciden.\n"
"          Desactiva el procesamiento del fichero $ENV y la importación de\n"
"          funciones de shell.  Si se desactiva esta opción causa que el uid "
"y\n"
"          el gid efectivos sean iguales al uid y el gid real.\n"
"      -t  Termina después de leer y ejecutar una orden.\n"
"      -u  Trata las variables sin definir como un error se sustituyen.\n"
"      -v  Muestra las líneas de entrada del shell mientras se leen.\n"
"      -x  Muestra las órdenes y sus argumentos mientras se ejecutan.\n"
"      -B  el shell realizará expansión de llaves.\n"
"      -C  Si se activa, no permite que los ficheros regulares existentes\n"
"          se sobreescriban por redirección de la salida.\n"
"      -E  Si se activa, las funciones del shell heredan la trampa ERR.\n"
"      -H  Activa el estilo de sustitución de historia ! . Esta opción está\n"
"          activa por defecto cuando el shell es interactivo.\n"
"      -P  Si se activa, no sigue enlaces simbólicos cuando se ejecutan "
"órdenes\n"
"          como cd, que cambian el directorio actual.\n"
"      -T  Si se activa, las funciones del shell heredan la trampa DEBUG.\n"
"      -   Asigna cualquier argumento restante a los parámetros "
"posicionales.\n"
"          Las opciones -x y -v se desactivan.\n"
"    \n"
"    Si se usa + en lugar de - causa que estas opciones se desactiven. Las\n"
"    opciones también se pueden usar en la invocación del shell.  El "
"conjunto\n"
"    actual de opciones se puede encontrar en $-.  Los n ARGs restantes son\n"
"    parámetros posicionales que se asignan, en orden, a $1, $2, .. $n.  Si "
"no\n"
"    se proporciona ningún ARG, se muestran todas las variables del shell.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida."

#: builtins.c:1104
msgid ""
"Unset values and attributes of shell variables and functions.\n"
"    \n"
"    For each NAME, remove the corresponding variable or function.\n"
"    \n"
"    Options:\n"
"      -f\ttreat each NAME as a shell function\n"
"      -v\ttreat each NAME as a shell variable\n"
"    \n"
"    Without options, unset first tries to unset a variable, and if that "
"fails,\n"
"    tries to unset a function.\n"
"    \n"
"    Some variables cannot be unset; also see `readonly'.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a NAME is read-only."
msgstr ""
"Desactiva valores y atributos de las variables y funciones del shell.\n"
"    \n"
"    Por cada NOMBRE, borra la función o variable correspondiente.\n"
"    \n"
"    Opciones:\n"
"      -f\ttrata cada NOMBRE como una función de shell\n"
"      -v\ttrata cada NOMBRE como una variable de shell\n"
"    \n"
"    Sin opciones, unset primero trata de borrar una variable, y si falla,\n"
"    trata de borrar una función.\n"
"    \n"
"    Algunas variables no se pueden borrar; también consulte `readonly'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    un NOMBRE sea de sólo lectura."

#: builtins.c:1124
msgid ""
"Set export attribute for shell variables.\n"
"    \n"
"    Marks each NAME for automatic export to the environment of subsequently\n"
"    executed commands.  If VALUE is supplied, assign VALUE before "
"exporting.\n"
"    \n"
"    Options:\n"
"      -f\trefer to shell functions\n"
"      -n\tremove the export property from each NAME\n"
"      -p\tdisplay a list of all exported variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Establece el atributo de exportación para las variables de shell.\n"
"    \n"
"    Marca cada NOMBRE para exportación automática al ambiente para las "
"órdenes\n"
"    ejecutadas subsecuentemente.  Si se proporciona un VALOR, se asigna el\n"
"    VALOR antes de exportar.\n"
"    \n"
"    Opciones:\n"
"      -f\tse refiere a funciones de shell\n"
"      -n\tborra la propiedad de exportación para cada NOMBRE\n"
"      -p\tmuestra una lista de todas las variables y funciones exportadas\n"
"    \n"
"    El argumento `--' desactiva el procesamiento posterior de opciones.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o que\n"
"    NOMBRE sea inválido."

#: builtins.c:1143
msgid ""
"Mark shell variables as unchangeable.\n"
"    \n"
"    Mark each NAME as read-only; the values of these NAMEs may not be\n"
"    changed by subsequent assignment.  If VALUE is supplied, assign VALUE\n"
"    before marking as read-only.\n"
"    \n"
"    Options:\n"
"      -a\trefer to indexed array variables\n"
"      -A\trefer to associative array variables\n"
"      -f\trefer to shell functions\n"
"      -p\tdisplay a list of all readonly variables and functions\n"
"    \n"
"    An argument of `--' disables further option processing.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or NAME is invalid."
msgstr ""
"Marca las variables de shell para evitar su modificación.\n"
"    \n"
"    Marca cada NOMBRE como de sólo lectura; los valores de esos NOMBREs\n"
"    no se pueden modificar por asignaciones subsecuentes.  Si se "
"proporciona\n"
"    un VALOR, se asigna el VALOR antes de marcar como de sólo lectura.\n"
"    \n"
"    Opciones:\n"
"      -a\tse refiere a variables de matriz indizada\n"
"      -A\tse refiere a variables de matriz asociativa\n"
"      -f\tse refiere a funciones de shell\n"
"      -p\tmuestra una lista de todas las variables y funciones de sólo "
"lectura\n"
"    \n"
"    El argumento `--' desactiva el procesamiento posterior de opciones.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    el NOMBRE sea inválido."

#: builtins.c:1164
msgid ""
"Shift positional parameters.\n"
"    \n"
"    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is\n"
"    not given, it is assumed to be 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless N is negative or greater than $#."
msgstr ""
"Desplaza los parámetros posicionales.\n"
"    \n"
"    Renombra los parámetros posicionales $N+1,$N+2 ... a $1,$2 ... Si no\n"
"    se proporciona N, se asume que es 1.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que N sea negativo o mayor que $#."

#: builtins.c:1176 builtins.c:1191
msgid ""
"Execute commands from a file in the current shell.\n"
"    \n"
"    Read and execute commands from FILENAME in the current shell.  The\n"
"    entries in $PATH are used to find the directory containing FILENAME.\n"
"    If any ARGUMENTS are supplied, they become the positional parameters\n"
"    when FILENAME is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed in FILENAME; fails if\n"
"    FILENAME cannot be read."
msgstr ""
"Ejecuta órdenes de un fichero en el shell actual.\n"
"    \n"
"    Lee y ejecuta órdenes del FICHERO en el shell actual.  Se utilizan las\n"
"    entradas en $PATH para encontrar el directorio que contiene el FICHERO.\n"
"    Si se proporciona ARGUMENTOS, se convierten en los parámetros "
"posicionales\n"
"    cuando se ejecuta el FICHERO.\n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada del FICHERO; falla si\n"
"    no se puede leer el FICHERO."

#: builtins.c:1207
msgid ""
"Suspend shell execution.\n"
"    \n"
"    Suspend the execution of this shell until it receives a SIGCONT signal.\n"
"    Unless forced, login shells cannot be suspended.\n"
"    \n"
"    Options:\n"
"      -f\tforce the suspend, even if the shell is a login shell\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless job control is not enabled or an error occurs."
msgstr ""
"Suspende la ejecución del shell.\n"
"    \n"
"    Suspende la ejecución de este shell hasta que recibe una señal SIGCONT.\n"
"    Los shells de entrada no se pueden suspender, a menos que sean "
"forzados.\n"
"    \n"
"    Opciones:\n"
"      -f\tfuerza la suspensión, aún si el shell es un shell de entrada\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que no esté activo el control de trabajos o\n"
"    suceda un error."

#: builtins.c:1223
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    Exits with a status of 0 (true) or 1 (false) depending on\n"
"    the evaluation of EXPR.  Expressions may be unary or binary.  Unary\n"
"    expressions are often used to examine the status of a file.  There\n"
"    are string operators as well, and numeric comparison operators.\n"
"    \n"
"    File operators:\n"
"    \n"
"      -a FILE        True if file exists.\n"
"      -b FILE        True if file is block special.\n"
"      -c FILE        True if file is character special.\n"
"      -d FILE        True if file is a directory.\n"
"      -e FILE        True if file exists.\n"
"      -f FILE        True if file exists and is a regular file.\n"
"      -g FILE        True if file is set-group-id.\n"
"      -h FILE        True if file is a symbolic link.\n"
"      -L FILE        True if file is a symbolic link.\n"
"      -k FILE        True if file has its `sticky' bit set.\n"
"      -p FILE        True if file is a named pipe.\n"
"      -r FILE        True if file is readable by you.\n"
"      -s FILE        True if file exists and is not empty.\n"
"      -S FILE        True if file is a socket.\n"
"      -t FD          True if FD is opened on a terminal.\n"
"      -u FILE        True if the file is set-user-id.\n"
"      -w FILE        True if the file is writable by you.\n"
"      -x FILE        True if the file is executable by you.\n"
"      -O FILE        True if the file is effectively owned by you.\n"
"      -G FILE        True if the file is effectively owned by your group.\n"
"      -N FILE        True if the file has been modified since it was last "
"read.\n"
"    \n"
"      FILE1 -nt FILE2  True if file1 is newer than file2 (according to\n"
"                       modification date).\n"
"    \n"
"      FILE1 -ot FILE2  True if file1 is older than file2.\n"
"    \n"
"      FILE1 -ef FILE2  True if file1 is a hard link to file2.\n"
"    \n"
"    String operators:\n"
"    \n"
"      -z STRING      True if string is empty.\n"
"    \n"
"      -n STRING\n"
"         STRING      True if string is not empty.\n"
"    \n"
"      STRING1 = STRING2\n"
"                     True if the strings are equal.\n"
"      STRING1 != STRING2\n"
"                     True if the strings are not equal.\n"
"      STRING1 < STRING2\n"
"                     True if STRING1 sorts before STRING2 "
"lexicographically.\n"
"      STRING1 > STRING2\n"
"                     True if STRING1 sorts after STRING2 lexicographically.\n"
"    \n"
"    Other operators:\n"
"    \n"
"      -o OPTION      True if the shell option OPTION is enabled.\n"
"      ! EXPR         True if expr is false.\n"
"      EXPR1 -a EXPR2 True if both expr1 AND expr2 are true.\n"
"      EXPR1 -o EXPR2 True if either expr1 OR expr2 is true.\n"
"    \n"
"      arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,\n"
"                     -lt, -le, -gt, or -ge.\n"
"    \n"
"    Arithmetic binary operators return true if ARG1 is equal, not-equal,\n"
"    less-than, less-than-or-equal, greater-than, or greater-than-or-equal\n"
"    than ARG2.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if EXPR evaluates to true; fails if EXPR evaluates to\n"
"    false or an invalid argument is given."
msgstr ""
"Evalúa expresiones condicionales.\n"
"    \n"
"    Termina con un estado de 0 (verdadero) o 1 (falso) dependiendo de\n"
"    la evaluación de EXPR.  Las expresiones pueden ser unarias o binarias.\n"
"    Las expresiones unarias se usan generalmente para examinar el estado\n"
"    de un fichero.  Hay también operadores de cadenas, y operadores de\n"
"    comparación numérica.\n"
"    \n"
"    Operadores de fichero:\n"
"    \n"
"      -a FICHERO     Verdadero si el fichero existe.\n"
"      -b FICHERO     Verdadero si el fichero es especial de bloques.\n"
"      -c FICHERO     Verdadero si el fichero es especial de caracteres.\n"
"      -d FICHERO     Verdadero si el fichero es un directorio.\n"
"      -e FICHERO     Verdadero si el fichero existe.\n"
"      -f FICHERO     Verdadero si el fichero existe y es un fichero "
"regular.\n"
"      -g FICHERO     Verdadero si el fichero tiene activado el set-group-"
"id.\n"
"      -h FICHERO     Verdadero si el fichero es un enlace simbólico.\n"
"      -L FICHERO     Verdadero si el fichero es un enlace simbólico.\n"
"      -k FICHERO     Verdadero si el fichero tiene el bit `sticky' "
"activado.\n"
"      -p FICHERO     Verdadero si el fichero es una tubería nombrada.\n"
"      -r FICHERO     Verdadero si el fichero es legible para usted.\n"
"      -s FICHERO     Verdadero si el fichero existe y no está vacío.\n"
"      -S FICHERO     Verdadero si el fichero es un `socket'.\n"
"      -t DF          Verdadero si el DF está abierto en una terminal.\n"
"      -u FICHERO     Verdadero si el fichero tiene activado el set-user-id.\n"
"      -w FICHERO     Verdadero si usted puede escribir en el fichero.\n"
"      -x FICHERO     Verdadero si usted puede ejecutar el fichero.\n"
"      -O FICHERO     Verdadero si usted efectivamente posee el fichero.\n"
"      -G FICHERO     Verdadero si su grupo efectivamente posee el fichero.\n"
"      -N FICHERO     Verdadero si el fichero se modificó desde la última "
"lectura.\n"
"    \n"
"      FICH1 -nt FICH2  Verdadero si fich1 es más reciente que fich2\n"
"                       (de acuerdo a la fecha de modificación).\n"
"    \n"
"      FICH1 -ot FICH2  Verdadero si fich1 es más antiguo que fich2.\n"
"    \n"
"      FICH1 -ef FICH2  Verdadero si fich1 es un enlace duro a fich2.\n"
"    \n"
"    Operadores de cadenas:\n"
"    \n"
"      -z CADENA      Verdadero si la cadena está vacía.\n"
"    \n"
"      -n CADENA\n"
"         CADENA      Verdadero si la cadena no está vacía.\n"
"    \n"
"      CADENA1 = CADENA2\n"
"                     Verdadero si las cadenas son iguales.\n"
"      CADENA1 != CADENA2\n"
"                     Verdadero si las cadenas no son iguales.\n"
"      CADENA1 < CADENA2\n"
"                     Verdadero si STRING1 se ordena antes que STRING2\n"
"                     lexicográficamente.\n"
"      CADENA1 > CADENA2\n"
"                     Verdadero si STRING1 se ordena después que STRING2\n"
"                     lexicográficamente.\n"
"    \n"
"    Otros operadores:\n"
"    \n"
"      -o OPCIÓN      Verdadero si la opción del shell OPCIÓN está activada.\n"
"      ! EXPR         Verdadero si expr es falso.\n"
"      EXPR1 -a EXPR2 Verdadero si expr1 Y expr2 are son verdaderas.\n"
"      EXPR1 -o EXPR2 Verdadero si cualquiera de expr1 O expr2 es verdadera.\n"
"    \n"
"      arg1 OP arg2   Pruebas aritméticas.  OP es uno de -eq, -ne,\n"
"                       -lt, -le, -gt, or -ge.\n"
"    \n"
"    Los operadores binarios aritméticos devuelven verdadero si ARG1 es\n"
"    igual, no igual, menor, menor o igual, mayor, mayor o igual que ARG2.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito si EXPR evalúa a verdadero; falla si EXPR evalúa a\n"
"    falso o se proporciona un argumento inválido."

#: builtins.c:1299
msgid ""
"Evaluate conditional expression.\n"
"    \n"
"    This is a synonym for the \"test\" builtin, but the last argument must\n"
"    be a literal `]', to match the opening `['."
msgstr ""
"Evalúa una expresión condicional.\n"
"    \n"
"    Este es un sinónimo para la orden interna \"test\", pero el último\n"
"    argumento debe ser un `]' literal, que coincida con el `[' inicial."

#: builtins.c:1308
msgid ""
"Display process times.\n"
"    \n"
"    Prints the accumulated user and system times for the shell and all of "
"its\n"
"    child processes.\n"
"    \n"
"    Exit Status:\n"
"    Always succeeds."
msgstr ""
"Muestra los tiempos de proceso.\n"
"    \n"
"    Muestra los tiempos de usuario y sistema acumulados por el shell y "
"todos\n"
"    sus procesos hijos.\n"
"    \n"
"    Estado de salida:\n"
"    Siempre con éxito."

#: builtins.c:1320
msgid ""
"Trap signals and other events.\n"
"    \n"
"    Defines and activates handlers to be run when the shell receives "
"signals\n"
"    or other conditions.\n"
"    \n"
"    ARG is a command to be read and executed when the shell receives the\n"
"    signal(s) SIGNAL_SPEC.  If ARG is absent (and a single SIGNAL_SPEC\n"
"    is supplied) or `-', each specified signal is reset to its original\n"
"    value.  If ARG is the null string each SIGNAL_SPEC is ignored by the\n"
"    shell and by the commands it invokes.\n"
"    \n"
"    If a SIGNAL_SPEC is EXIT (0) ARG is executed on exit from the shell.  "
"If\n"
"    a SIGNAL_SPEC is DEBUG, ARG is executed before every simple command.\n"
"    \n"
"    If no arguments are supplied, trap prints the list of commands "
"associated\n"
"    with each signal.\n"
"    \n"
"    Options:\n"
"      -l\tprint a list of signal names and their corresponding numbers\n"
"      -p\tdisplay the trap commands associated with each SIGNAL_SPEC\n"
"    \n"
"    Each SIGNAL_SPEC is either a signal name in <signal.h> or a signal "
"number.\n"
"    Signal names are case insensitive and the SIG prefix is optional.  A\n"
"    signal may be sent to the shell with \"kill -signal $$\".\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless a SIGSPEC is invalid or an invalid option is "
"given."
msgstr ""
"Atrapa señales y otros eventos.\n"
"    \n"
"    Define y activa manejadores a ejecutar cuando el shell recibe señales\n"
"    u otras condiciones.\n"
"    \n"
"    ARG es una orden para leer y ejecutar cuando el shell recibe la(s)\n"
"    señal(es) ID_SEÑAL.  Si ARG no está presente (y sólo se proporciona\n"
"    una sola ID_SEÑAL) o se proporciona `-', cada señal especificada se\n"
"    reestablece a su valor original.  Si ARG es la cadena nula, el shell\n"
"    y las órdenes que invoque ignoran cada ID_SEÑAL.\n"
"    \n"
"    Si una ID_SEÑAL es EXIT (0) se ejecuta la orden ARG al salir del\n"
"    shell.  Si una ID_SEÑAL es DEBUG, se ejecuta ARG después de cada\n"
"    orden simple.\n"
"    \n"
"    Si no se proporcionan argumentos, trap muestra la lista de órdenes\n"
"    asociadas con cada señal.\n"
"    \n"
"    Opciones:\n"
"      -l\tmuestra una lista de nombres de señal con su número "
"correspondiente\n"
"      -p\tmuestra las órdenes trap asociadas con cada ID_SEÑAL\n"
"    \n"
"    Cada ID_SEÑAL es un nombre de señal en <signal.h> o un número de señal.\n"
"    Los nombres de señal no son sensibles a mayúsculas y minúsculas y el\n"
"    prefijo SIG es opcional.  Se puede enviar una señal al shell con\n"
"    \"kill -signal $$\".    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que una ID_SEÑAL sea inválida o se "
"proporcione\n"
"    una opción inválida."

#  No he visto que este fichero incluya la posibilidad de traducir las
#  palabras que muestra `type -t'. Por esta razón, se dejan en inglés. cfuga
#: builtins.c:1352
msgid ""
"Display information about command type.\n"
"    \n"
"    For each NAME, indicate how it would be interpreted if used as a\n"
"    command name.\n"
"    \n"
"    Options:\n"
"      -a\tdisplay all locations containing an executable named NAME;\n"
"    \tincludes aliases, builtins, and functions, if and only if\n"
"    \tthe `-p' option is not also used\n"
"      -f\tsuppress shell function lookup\n"
"      -P\tforce a PATH search for each NAME, even if it is an alias,\n"
"    \tbuiltin, or function, and returns the name of the disk file\n"
"    \tthat would be executed\n"
"      -p\treturns either the name of the disk file that would be executed,\n"
"    \tor nothing if `type -t NAME' would not return `file'.\n"
"      -t\toutput a single word which is one of `alias', `keyword',\n"
"    \t`function', `builtin', `file' or `', if NAME is an alias, shell\n"
"    \treserved word, shell function, shell builtin, disk file, or not\n"
"    \tfound, respectively\n"
"    \n"
"    Arguments:\n"
"      NAME\tCommand name to be interpreted.\n"
"    \n"
"    Exit Status:\n"
"    Returns success if all of the NAMEs are found; fails if any are not "
"found."
msgstr ""
"Muestra información sobre el tipo de orden.\n"
"    \n"
"    Por cada NOMBRE, indica cómo se interpretaría si se usa como un nombre\n"
"    de orden.\n"
"    \n"
"    Opciones:\n"
"      -a\tmuestra todas las ubicaciones que contienen un ejecutable llamado\n"
"    \tNOMBRE; incluye aliases, órdenes internas, y funciones, solo y solo "
"si\n"
"    \tno se usó también la opción `-p'\n"
"      -f\tsuprime la búsqueda de funciones de shell\n"
"      -P\tfuerza una búsqueda en PATH por cada nombre, aún si hay un alias,\n"
"    \torden interna, o función, y devuelve el nombre del fichero en el "
"disco\n"
"    \tque se ejecutaría\n"
"      -p\tdevuelve ya sea el nombre del fichero en disco que se ejecutaría,\n"
"    \to nada si `type -t NOMBRE' no devuelve `fichero'.\n"
"      -t\tmuestra una sola palabra, que es una de `alias', `keyword',\n"
"    \t`function', `builtin', `file' o `', si el NOMBRE es un alias,\n"
"    \tpalabra reservada del shell, función del shell, orden interna del\n"
"    \tshell, fichero de disco, o no se encuentra, respectivamente.\n"
"    \n"
"    Argumentos:\n"
"      NOMBRE\tNombre de orden a interpretar.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito si se encuentran todos los NOMBREs; falla si no se\n"
"    encuentra alguno."

#: builtins.c:1383
msgid ""
"Modify shell resource limits.\n"
"    \n"
"    Provides control over the resources available to the shell and "
"processes\n"
"    it creates, on systems that allow such control.\n"
"    \n"
"    Options:\n"
"      -S\tuse the `soft' resource limit\n"
"      -H\tuse the `hard' resource limit\n"
"      -a\tall current limits are reported\n"
"      -b\tthe socket buffer size\n"
"      -c\tthe maximum size of core files created\n"
"      -d\tthe maximum size of a process's data segment\n"
"      -e\tthe maximum scheduling priority (`nice')\n"
"      -f\tthe maximum size of files written by the shell and its children\n"
"      -i\tthe maximum number of pending signals\n"
"      -l\tthe maximum size a process may lock into memory\n"
"      -m\tthe maximum resident set size\n"
"      -n\tthe maximum number of open file descriptors\n"
"      -p\tthe pipe buffer size\n"
"      -q\tthe maximum number of bytes in POSIX message queues\n"
"      -r\tthe maximum real-time scheduling priority\n"
"      -s\tthe maximum stack size\n"
"      -t\tthe maximum amount of cpu time in seconds\n"
"      -u\tthe maximum number of user processes\n"
"      -v\tthe size of virtual memory\n"
"      -x\tthe maximum number of file locks\n"
"    \n"
"    If LIMIT is given, it is the new value of the specified resource; the\n"
"    special LIMIT values `soft', `hard', and `unlimited' stand for the\n"
"    current soft limit, the current hard limit, and no limit, respectively.\n"
"    Otherwise, the current value of the specified resource is printed.  If\n"
"    no option is given, then -f is assumed.\n"
"    \n"
"    Values are in 1024-byte increments, except for -t, which is in seconds,\n"
"    -p, which is in increments of 512 bytes, and -u, which is an unscaled\n"
"    number of processes.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Modifica los límites de recursos del shell.\n"
"    \n"
"    Provee control sobre los recursos disponibles para el shell y los\n"
"    procesos que crea, en sistemas que permiten tal control.\n"
"    \n"
"    Opciones:\n"
"    \n"
"      -S\tusa el límite de recurso `soft'\n"
"      -H\tusa el límite de recurso `hard'\n"
"      -a\tmuestra todos los límites actuales\n"
"      -b\tel tamaño del almacenamiento intermedio del `socket'\n"
"      -c\tel tamaño máximo de los ficheros `core' creados\n"
"      -d\tel tamaño máximo del segmento de datos de un proceso\n"
"      -e\tla prioridad máxima de calendarización (`nice')\n"
"      -f\tel tamaño máximo de los ficheros escritos por el shell y sus "
"hijos\n"
"      -i\tel número máximo de señales pendientes\n"
"      -l\tel tamaño máximo que un proceso puede bloquear en memoria\n"
"      -m\tel tamaño máximo para las variables residentes\n"
"      -n\tel número máximo de descriptores de fichero abiertos\n"
"      -p\tel tamaño del almacenamiento intermedio para tuberías\n"
"      -q\tel tamaño máximo de bytes en las colas de mensajes POSIX\n"
"      -r\tla prioridad máxima de calendarización en tiempo real\n"
"      -s\tel tamaño máximo de pila\n"
"      -t\tla cantidad máxima de tiempo de cpu en segundos\n"
"      -u\tel número máximo de procesos de usuario\n"
"      -v\tel tamaño de la memoria virtual\n"
"      -x\tel número máximo de bloqueos de ficheros\n"
"    \n"
"    Si se establece LÍMITE, éste es el nuevo valor del recurso "
"especificado;\n"
"    los valores especiales de LÍMITE `soft', `hard' y `unlimited'\n"
"    corresponden al límite suave actual, el límite duro actual, y\n"
"    sin límite, respectivamente.  De otra forma, se muestra el valor actual\n"
"    de los recursos especificados.  Si no se proporciona una opción, se\n"
"    asume -f.\n"
"    \n"
"    Los valores son en incrementos de 1024 bytes, excepto para -t, el cual\n"
"    es en segundos, -p, el cual es en incrementos de 512 bytes, y -u, el\n"
"    cual es un número de procesos sin escala.\n"
"    \n"
"    Estado de salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o "
"suceda\n"
"    un error."

#: builtins.c:1428
msgid ""
"Display or set file mode mask.\n"
"    \n"
"    Sets the user file-creation mask to MODE.  If MODE is omitted, prints\n"
"    the current value of the mask.\n"
"    \n"
"    If MODE begins with a digit, it is interpreted as an octal number;\n"
"    otherwise it is a symbolic mode string like that accepted by chmod(1).\n"
"    \n"
"    Options:\n"
"      -p\tif MODE is omitted, output in a form that may be reused as input\n"
"      -S\tmakes the output symbolic; otherwise an octal number is output\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless MODE is invalid or an invalid option is given."
msgstr ""
"Muestra o establece la máscara de modo de ficheros.\n"
"    \n"
"    Establece la máscara de creación de ficheros del usuario a MODO. Si se\n"
"    omite el MODO, muestra el valor actual de la máscara.\n"
"    \n"
"    Si el MODO empieza con un dígito, se interpreta como un número octal;\n"
"    de otra forma es una cadena de modo simbólico como la que acepta chmod "
"(1).\n"
"    \n"
"    Opciones:\n"
"      -p\tsi se omite el MODO, muestra en una forma reusable como entrada\n"
"      -S\tsalida simbólica; de otra forma muestra el modo como número octal\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que el MODO sea inválido o se proporcione\n"
"    una opción inválida."

#: builtins.c:1448
msgid ""
"Wait for job completion and return exit status.\n"
"    \n"
"    Waits for the process identified by ID, which may be a process ID or a\n"
"    job specification, and reports its termination status.  If ID is not\n"
"    given, waits for all currently active child processes, and the return\n"
"    status is zero.  If ID is a a job specification, waits for all "
"processes\n"
"    in the job's pipeline.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Espera la terminación del trabajo y devuelve el estado de salida.\n"
"    \n"
"    Espera al proceso identificado por ID, el cual puede ser un ID de\n"
"    proceso o una especificación de trabajo, y reporta su estado de salida.\n"
"    Si no se proporciona un ID, espera a todos los procesos hijo activos,\n"
"    y el estado de devolución es cero.  Si ID es una especificación de\n"
"    trabajo, espera a todos los procesos en la cola de trabajos.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de ID; falla si ID es inválido o se proporciona una\n"
"    opción inválida."

#: builtins.c:1466
msgid ""
"Wait for process completion and return exit status.\n"
"    \n"
"    Waits for the specified process and reports its termination status.  If\n"
"    PID is not given, all currently active child processes are waited for,\n"
"    and the return code is zero.  PID must be a process ID.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of ID; fails if ID is invalid or an invalid option "
"is\n"
"    given."
msgstr ""
"Espera la terminación del trabajo y devuelve el estado de salida.\n"
"    \n"
"    Espera al proceso especificado y reporta su estado de salida.  Si\n"
"    no se proporciona un PID, espera a todos los procesos hijo activos,\n"
"    y el código de devolución es cero.  PID debe ser un ID de proceso.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de ID; falla si ID es inválido o se proporciona una\n"
"    opción inválida."

#: builtins.c:1481
msgid ""
"Execute commands for each member in a list.\n"
"    \n"
"    The `for' loop executes a sequence of commands for each member in a\n"
"    list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is\n"
"    assumed.  For each element in WORDS, NAME is set to that element, and\n"
"    the COMMANDS are executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes por cada miembro en una lista.\n"
"    \n"
"    El ciclo `for' ejecuta una secuencia de órdenes para cada miembro en\n"
"    una lista de elementos.  Si `in PALABRAS ...;' no está presente,\n"
"    entonces se asume `in \"$@\"'.  Para cada elemento en PALABRAS,\n"
"    se define NOMBRE como ese elemento, y se ejecutan las ÓRDENES.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1495
msgid ""
"Arithmetic for loop.\n"
"    \n"
"    Equivalent to\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tCOMMANDS\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, and EXP3 are arithmetic expressions.  If any expression is\n"
"    omitted, it behaves as if it evaluates to 1.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Aritmética para un ciclo.\n"
"    \n"
"    Equivalente a\n"
"    \t(( EXP1 ))\n"
"    \twhile (( EXP2 )); do\n"
"    \t\tÓRDENES\n"
"    \t\t(( EXP3 ))\n"
"    \tdone\n"
"    EXP1, EXP2, y EXP3 son expresiones aritméticas.  Si se omite\n"
"    cualquier expresión, se comporta como si se evaluara a 1.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1513
msgid ""
"Select words from a list and execute commands.\n"
"    \n"
"    The WORDS are expanded, generating a list of words.  The\n"
"    set of expanded words is printed on the standard error, each\n"
"    preceded by a number.  If `in WORDS' is not present, `in \"$@\"'\n"
"    is assumed.  The PS3 prompt is then displayed and a line read\n"
"    from the standard input.  If the line consists of the number\n"
"    corresponding to one of the displayed words, then NAME is set\n"
"    to that word.  If the line is empty, WORDS and the prompt are\n"
"    redisplayed.  If EOF is read, the command completes.  Any other\n"
"    value read causes NAME to be set to null.  The line read is saved\n"
"    in the variable REPLY.  COMMANDS are executed after each selection\n"
"    until a break command is executed.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Selecciona palabras de una lista y ejecuta órdenes.\n"
"    \n"
"    Se expanden las PALABRAS, generando una lista de palabras.  El\n"
"    conjunto de palabras expandidas se muestra en la salida de error\n"
"    estándar, cada una precedida por un número.  Si `in PALABRAS' no\n"
"    está presente, se asume `in \"$@\"'.  Entonces se muestra el\n"
"    prompt PS3 y se lee una línea de la entrada estándar.  Si la\n"
"    línea consiste en el número correspondiente a una de las palabras\n"
"    mostradas, entonces se define NOMBRE como esa palabra.  Si la\n"
"    línea está vacía, PALABRAS y el prompt se muestran de nuevo.  Si\n"
"    se lee EOF, se completa la orden.  Cualquier otro valor leído\n"
"    causa que NOMBRE se defina como nulo.  La línea leída se guarda\n"
"    en la variable REPLY.  Se ejecutan las ÓRDENES después de cada\n"
"    selección hasta que se ejecuta una orden break.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1534
msgid ""
"Report time consumed by pipeline's execution.\n"
"    \n"
"    Execute PIPELINE and print a summary of the real time, user CPU time,\n"
"    and system CPU time spent executing PIPELINE when it terminates.\n"
"    \n"
"    Options:\n"
"      -p\tprint the timing summary in the portable Posix format\n"
"    \n"
"    The value of the TIMEFORMAT variable is used as the output format.\n"
"    \n"
"    Exit Status:\n"
"    The return status is the return status of PIPELINE."
msgstr ""
"Reporta el tiempo consumido por la ejecución de la tubería.\n"
"    \n"
"    Ejecuta la TUBERÍA y muestra un resumen del tiempo real, el tiempo de\n"
"    CPU del usuario, y el tiempo de CPU del sistema utilizado por\n"
"    la ejecución de la TUBERÍA cuando termina.\n"
"    \n"
"    Opciones:\n"
"      -p\tmuestra el resumen de tiempos en el formato Posix transportable\n"
"    \n"
"    Estado de Salida:\n"
"    El estado de devolución es el estado de devolución de la TUBERÍA."

#: builtins.c:1551
msgid ""
"Execute commands based on pattern matching.\n"
"    \n"
"    Selectively execute COMMANDS based upon WORD matching PATTERN.  The\n"
"    `|' is used to separate multiple patterns.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes en base a la coincidencia de patrones.\n"
"    \n"
"    Ejecuta ÓRDENES selectivamente basado en coincidencias de la PALABRA\n"
"    con el PATRÓN. Se utiliza `|' para separar patrones múltiples.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1563
msgid ""
"Execute commands based on conditional.\n"
"    \n"
"    The `if COMMANDS' list is executed.  If its exit status is zero, then "
"the\n"
"    `then COMMANDS' list is executed.  Otherwise, each `elif COMMANDS' list "
"is\n"
"    executed in turn, and if its exit status is zero, the corresponding\n"
"    `then COMMANDS' list is executed and the if command completes.  "
"Otherwise,\n"
"    the `else COMMANDS' list is executed, if present.  The exit status of "
"the\n"
"    entire construct is the exit status of the last command executed, or "
"zero\n"
"    if no condition tested true.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta comandos en base a condicionales.\n"
"    \n"
"    Se ejecuta la lista `if ÓRDENES'.  Si su estado de salida es cero,\n"
"    entonces se ejecuta la lista `then ÓRDENES`.  De otra forma, cada lista\n"
"    `elif ÓRDENES' se ejecuta en su lugar, y si su estado de salida es "
"cero,\n"
"    se ejecuta la lista `then ÓRDENES' correspondiente y se completa la\n"
"    orden if.  De otra forma, se ejecuta la lista `else ÓRDENES', si está\n"
"    presente.  El estado de salida de toda la construcción es el estado de\n"
"    salida de la última orden ejecutada, o cero si ninguna condición "
"resultó\n"
"    verdadera.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1580
msgid ""
"Execute commands as long as a test succeeds.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `while' COMMANDS has an exit status of zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes mientras una prueba tenga éxito.\n"
"    \n"
"    Expande y ejecuta ÓRDENES mientras la orden final en las ÓRDENES\n"
"    `while' tenga un estado de salida de cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1592
msgid ""
"Execute commands as long as a test does not succeed.\n"
"    \n"
"    Expand and execute COMMANDS as long as the final command in the\n"
"    `until' COMMANDS has an exit status which is not zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Ejecuta órdenes mientras una prueba no tenga éxito.\n"
"    \n"
"    Expande y ejecuta ÓRDENES mientras la orden final en las ÓRDENES\n"
"    `until' tengan un estado de salida que no sea cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1604
msgid ""
"Create a coprocess named NAME.\n"
"    \n"
"    Execute COMMAND asynchronously, with the standard output and standard\n"
"    input of the command connected via a pipe to file descriptors assigned\n"
"    to indices 0 and 1 of an array variable NAME in the executing shell.\n"
"    The default NAME is \"COPROC\".\n"
"    \n"
"    Exit Status:\n"
"    Returns the exit status of COMMAND."
msgstr ""
"Crea un coproceso llamado NOMBRE.\n"
"    \n"
"    Ejecuta la ORDEN asíncronamente, con la salida estándar y la entrada\n"
"    estándar de la orden contectada a través de una tubería a los "
"descriptores\n"
"    de fichero asignados a los índices 0 y 1 de una variable de matriz "
"NOMBRE\n"
"    en el shell en ejecución.  El nombre por defecto es \"COPROC\".\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de salida de la ORDEN."

#: builtins.c:1618
msgid ""
"Define shell function.\n"
"    \n"
"    Create a shell function named NAME.  When invoked as a simple command,\n"
"    NAME runs COMMANDs in the calling shell's context.  When NAME is "
"invoked,\n"
"    the arguments are passed to the function as $1...$n, and the function's\n"
"    name is in $FUNCNAME.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless NAME is readonly."
msgstr ""
"Define una función de shell.\n"
"    \n"
"    Crea una función de shell llamada NOMBRE.  Cuando se invoca como una\n"
"    orden simple, NOMBRE ejecuta ÓRDENES en el contexto del shell que lo\n"
"    llamó.  Cuando se invoca NOMBRE, los argumentos se pasan a la función\n"
"    como $1...$n, y el nombre de la función está en $FUNCNAME.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que NOMBRE sea de sólo lectura"

#: builtins.c:1632
msgid ""
"Group commands as a unit.\n"
"    \n"
"    Run a set of commands in a group.  This is one way to redirect an\n"
"    entire set of commands.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the last command executed."
msgstr ""
"Agrupa órdenes como una unidad.\n"
"    \n"
"    Ejecuta un conjunto de órdenes en un grupo.  Esta es una forma de\n"
"    redirigir un conjunto completo de órdenes.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado de la última orden ejecutada."

#: builtins.c:1644
msgid ""
"Resume job in foreground.\n"
"    \n"
"    Equivalent to the JOB_SPEC argument to the `fg' command.  Resume a\n"
"    stopped or background job.  JOB_SPEC can specify either a job name\n"
"    or a job number.  Following JOB_SPEC with a `&' places the job in\n"
"    the background, as if the job specification had been supplied as an\n"
"    argument to `bg'.\n"
"    \n"
"    Exit Status:\n"
"    Returns the status of the resumed job."
msgstr ""
"Reinicia el trabajo en primer plano.\n"
"    \n"
"    Equivalente al argumento IDTRABAJO de la orden `fg'.  Reinicia un\n"
"    trabajo detenido o en segundo plano.  IDTRABAJO puede especificar\n"
"    un nombre de trabajo o un número de trabajo.  Un `&' a continuación\n"
"    de IDTRABAJO coloca al trabajo en segundo plano, como si la\n"
"    especificación del trabajo se hubiera proporcionado como\n"
"    un argumento de `bg'.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve el estado del trabajo reiniciado."

#: builtins.c:1659
msgid ""
"Evaluate arithmetic expression.\n"
"    \n"
"    The EXPRESSION is evaluated according to the rules for arithmetic\n"
"    evaluation.  Equivalent to \"let EXPRESSION\".\n"
"    \n"
"    Exit Status:\n"
"    Returns 1 if EXPRESSION evaluates to 0; returns 0 otherwise."
msgstr ""
"Evalúa una expresión aritmética.\n"
"    \n"
"    Se evalua la EXPRESIÓN de acuerdo a las reglas de evaluación\n"
"    aritmética.  Equivalente a \"let EXPRESIÓN\".\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve 1 si la EXPRESIÓN evalúa a 0; devuelve 0 de otra manera."

#: builtins.c:1671
msgid ""
"Execute conditional command.\n"
"    \n"
"    Returns a status of 0 or 1 depending on the evaluation of the "
"conditional\n"
"    expression EXPRESSION.  Expressions are composed of the same primaries "
"used\n"
"    by the `test' builtin, and may be combined using the following "
"operators:\n"
"    \n"
"      ( EXPRESSION )\tReturns the value of EXPRESSION\n"
"      ! EXPRESSION\t\tTrue if EXPRESSION is false; else false\n"
"      EXPR1 && EXPR2\tTrue if both EXPR1 and EXPR2 are true; else false\n"
"      EXPR1 || EXPR2\tTrue if either EXPR1 or EXPR2 is true; else false\n"
"    \n"
"    When the `==' and `!=' operators are used, the string to the right of\n"
"    the operator is used as a pattern and pattern matching is performed.\n"
"    When the `=~' operator is used, the string to the right of the operator\n"
"    is matched as a regular expression.\n"
"    \n"
"    The && and || operators do not evaluate EXPR2 if EXPR1 is sufficient to\n"
"    determine the expression's value.\n"
"    \n"
"    Exit Status:\n"
"    0 or 1 depending on value of EXPRESSION."
msgstr ""
"Ejecuta una orden condicional.\n"
"    \n"
"    Devuelve un estado de 0 ó 1 dependiendo de la evaluación de la "
"expresión\n"
"    condicional EXPRESIÓN.  Las expresiones se componen de los mismos\n"
"    elementos primarios usados por la orden interna `test', y se pueden\n"
"    combinar usando los siguientes operadores:\n"
"    \n"
"      ( EXPRESIÓN )\tDevuelve el valor de la EXPRESIÓN\n"
"      ! EXPRESIÓN\tVerdadero si la EXPRESIÓN es falsa; de otra forma es "
"falso\n"
"      EXPR1 && EXPR2\tVerdadero si EXPR1 y EXPR2 son verdaderos; de\n"
"    \t\totra forma es falso\n"
"    \tEXPR1 || EXPR2\tVerdadero si EXPR1 o EXPR2 es verdadero; de\n"
"    \t\totra forma es falso\n"
"    \n"
"    Cuando se usan los operadores `==' y `!=', se usa la cadena a la\n"
"    derecha del operador como un patrón y se realiza una coincidencia de\n"
"    patrones.  Cuando se usa el operador `=~', la cadena a la derecha del\n"
"    operador coincide como una expresión regular.\n"
"    \n"
"    Los operadores && y || no evalúan EXPR2 si EXPR1 es suficiente para\n"
"    determinar el valor de una expresión.    \n"
"    Estado de Salida:\n"
"    0 o 1 dependiendo del valor de la EXPRESIÓN."

#: builtins.c:1697
msgid ""
"Common shell variable names and usage.\n"
"    \n"
"    BASH_VERSION\tVersion information for this Bash.\n"
"    CDPATH\tA colon-separated list of directories to search\n"
"    \t\tfor directories given as arguments to `cd'.\n"
"    GLOBIGNORE\tA colon-separated list of patterns describing filenames to\n"
"    \t\tbe ignored by pathname expansion.\n"
"    HISTFILE\tThe name of the file where your command history is stored.\n"
"    HISTFILESIZE\tThe maximum number of lines this file can contain.\n"
"    HISTSIZE\tThe maximum number of history lines that a running\n"
"    \t\tshell can access.\n"
"    HOME\tThe complete pathname to your login directory.\n"
"    HOSTNAME\tThe name of the current host.\n"
"    HOSTTYPE\tThe type of CPU this version of Bash is running under.\n"
"    IGNOREEOF\tControls the action of the shell on receipt of an EOF\n"
"    \t\tcharacter as the sole input.  If set, then the value\n"
"    \t\tof it is the number of EOF characters that can be seen\n"
"    \t\tin a row on an empty line before the shell will exit\n"
"    \t\t(default 10).  When unset, EOF signifies the end of input.\n"
"    MACHTYPE\tA string describing the current system Bash is running on.\n"
"    MAILCHECK\tHow often, in seconds, Bash checks for new mail.\n"
"    MAILPATH\tA colon-separated list of filenames which Bash checks\n"
"    \t\tfor new mail.\n"
"    OSTYPE\tThe version of Unix this version of Bash is running on.\n"
"    PATH\tA colon-separated list of directories to search when\n"
"    \t\tlooking for commands.\n"
"    PROMPT_COMMAND\tA command to be executed before the printing of each\n"
"    \t\tprimary prompt.\n"
"    PS1\t\tThe primary prompt string.\n"
"    PS2\t\tThe secondary prompt string.\n"
"    PWD\t\tThe full pathname of the current directory.\n"
"    SHELLOPTS\tA colon-separated list of enabled shell options.\n"
"    TERM\tThe name of the current terminal type.\n"
"    TIMEFORMAT\tThe output format for timing statistics displayed by the\n"
"    \t\t`time' reserved word.\n"
"    auto_resume\tNon-null means a command word appearing on a line by\n"
"    \t\titself is first looked for in the list of currently\n"
"    \t\tstopped jobs.  If found there, that job is foregrounded.\n"
"    \t\tA value of `exact' means that the command word must\n"
"    \t\texactly match a command in the list of stopped jobs.  A\n"
"    \t\tvalue of `substring' means that the command word must\n"
"    \t\tmatch a substring of the job.  Any other value means that\n"
"    \t\tthe command must be a prefix of a stopped job.\n"
"    histchars\tCharacters controlling history expansion and quick\n"
"    \t\tsubstitution.  The first character is the history\n"
"    \t\tsubstitution character, usually `!'.  The second is\n"
"    \t\tthe `quick substitution' character, usually `^'.  The\n"
"    \t\tthird is the `history comment' character, usually `#'.\n"
"    HISTIGNORE\tA colon-separated list of patterns used to decide which\n"
"    \t\tcommands should be saved on the history list.\n"
msgstr ""
"Nombres de variables de shell comunes y su uso.\n"
"    \n"
"    BASH_VERSION\tInformación de versión para este Bash.\n"
"    CDPATH\tUna lista de directorios separada por dos puntos\n"
"    \t\tpara buscar directorios dados como argumentos para `cd'.\n"
"    GLOBIGNORE\tUna lista de patrones separada por dos puntos\n"
"    \t\tque describe nombres de fichero a ignorar por la expansión\n"
"    \t\tde rutas de nombre.\n"
"    HISTFILE\tEl nombre del fichero donde se almacena su historia\n"
"    \t\tde órdenes.\n"
"    HISTFILESIZE\tEl número máximo de líneas que puede contener\n"
"    \t\teste fichero.\n"
"    HISTSIZE\tEl número máximo de líneas de líneas de historia que\n"
"    \t\tun shell en ejecución puede acceder.\n"
"    HOME\tLa ruta completa a su directorio de entrada.\n"
"    HOSTNAME\tEl nombre del anfitrión actual.\n"
"    HOSTTYPE\tEl tipo de CPU bajo el cual se ejecuta esta versión de\n"
"    \t\tBash.\n"
"    IGNOREEOF\tControla la acción del shell al recibir un carácter\n"
"    \t\tEOF como la única entrada.  Si está definida, entonces su\n"
"    \t\tvalor es el número de caracteres EOF que se deben leer de\n"
"    \t\tforma consecutiva en una línea vacía antes de que el shell\n"
"    \t\ttermine (por defecto 10).  Cuando no está definida, EOF\n"
"    \t\tsignifica el fin de la entrada.\n"
"    MACHTYPE\tUna cadena que describe el sistema actual donde se\n"
"    \t\tejecuta Bash.\n"
"    MAILCHECK\tLa frecuencia, en segundos, que Bash busca correo nuevo.\n"
"    MAILPATH\tUna lista de nombres de ficheros separada por dos puntos\n"
"    \t\ten la cual Bash busca correo nuevo.\n"
"    OSTYPE\tla versión de Unix en la que se ejecuta esta versión\n"
"    \t\tde Bash.\n"
"    PATH\tUna lista de directorios separada por dos puntos en la que\n"
"    \t\tse buscan órdenes.\n"
"    PROMPT_COMMAND\tUna orden a ejecutar antes de mostrar cada prompt\n"
"    \t\tprimario.\n"
"    PS1\t\tLa cadena primaria de prompt.\n"
"    PS2\t\tLa cadena secundaria de prompt.\n"
"    PWD\t\tLa ruta completa del directorio actual.\n"
"    SHELLOPTS\tUna lista separada por dos puntos de las opciones\n"
"    \t\tde shell activadas.\n"
"    TERM\tEl nombre del tipo actual de terminal.\n"
"    TIMEFORMAT\tEl formato de salida para las estadísticas de tiempo\n"
"    \t\tmostradas por la palabra reservada `time'.\n"
"    auto_resume\tSi no es nulo significa que una palabra de orden que\n"
"    \t\taparece en una línea por sí sola se busca primero en la lista\n"
"    \t\tactual de trabajos detenidos.  Si se encuentra ahí, ese\n"
"    \t\ttrabajo se coloca en primer plano.  Un valor `exact' significa\n"
"    \t\tque la palabra de orden debe coincidir exactamente con una\n"
"    \t\torden en la lista de trabajos detenidos.  Un valor `substring'\n"
"    \t\tsignifica que la palabra de orden debe coincidir con una\n"
"    \t\tsubcadena del trabajo.  Cualquier otro valor significa que\n"
"    \t\tla orden debe ser un prefijo de un trabajo detenido.\n"
"    histchars\tLos caracteres que controlan la expansión de historia\n"
"    \t\ty la sustitución rápida.  El primer carácter es el\n"
"    \t\tcarácter de sustitución de historia, generalmente `!'.  El\n"
"    \t\tsegundo es el carácter de `sustitución rápida', generalmente\n"
"    \t\t`^'.  El tercero es el carácter `comentario de historia',\n"
"    \t\tgeneralmente `#'.\n"
"    HISTIGNORE\tUna lista separada por dos puntos de patrones usados\n"
"    \t\tpara decidir cuáles órdenes se deben guardar en la lista de\n"
"    \t\thistoria.\n"

#: builtins.c:1754
msgid ""
"Add directories to stack.\n"
"    \n"
"    Adds a directory to the top of the directory stack, or rotates\n"
"    the stack, making the new top of the stack the current working\n"
"    directory.  With no arguments, exchanges the top two directories.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when adding\n"
"    \tdirectories to the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the left of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      -N\tRotates the stack so that the Nth directory (counting\n"
"    \tfrom the right of the list shown by `dirs', starting with\n"
"    \tzero) is at the top.\n"
"    \n"
"      dir\tAdds DIR to the directory stack at the top, making it the\n"
"    \tnew current working directory.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Agrega directorios a la pila.\n"
"    \n"
"    Agrega un directorio al tope de la pila de directorios, o rota\n"
"    la pila, haciendo que el nuevo tope de la pila sea el\n"
"    directorio de trabajo actual.  Sin argumentos, intercambia\n"
"    los dos directorios del tope.\n"
"    \n"
"    Opciones:\n"
"      -n\tsuprime el cambio normal de directorio cuando se agregan\n"
"    \tdirectorios a la pila, así sólo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"      +N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tde la izquierda de la lista mostrada por `dirs',comenzando\n"
"    \tdesde cero) esté en el tope.\n"
"    \n"
"      -N\tRota la pila para que el N-ésimo directorio (contando\n"
"    \tde la derecha de la lista mostrada por `dirs', comenzando\n"
"    \tdesde cero) esté en el tope.\n"
"    \n"
"      dir\tagrega DIR a la pila de directorios en el tope,\n"
"    \thaciéndolo el nuevo directorio de trabajo actual.\n"
"    \n"
"    La orden interna `dirs' muestra la pila de directorios.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione un argumento inválido o\n"
"    falle el cambio de directorio."

#: builtins.c:1788
msgid ""
"Remove directories from stack.\n"
"    \n"
"    Removes entries from the directory stack.  With no arguments, removes\n"
"    the top directory from the stack, and changes to the new top directory.\n"
"    \n"
"    Options:\n"
"      -n\tSuppresses the normal change of directory when removing\n"
"    \tdirectories from the stack, so only the stack is manipulated.\n"
"    \n"
"    Arguments:\n"
"      +N\tRemoves the Nth entry counting from the left of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd +0'\n"
"    \tremoves the first directory, `popd +1' the second.\n"
"    \n"
"      -N\tRemoves the Nth entry counting from the right of the list\n"
"    \tshown by `dirs', starting with zero.  For example: `popd -0'\n"
"    \tremoves the last directory, `popd -1' the next to last.\n"
"    \n"
"    The `dirs' builtin displays the directory stack.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid argument is supplied or the directory\n"
"    change fails."
msgstr ""
"Borra directorios de la pila.\n"
"    \n"
"    Borra entradas de la pila de directorios.  Sin argumentos,\n"
"    borra el directorio del tope de la pila, y cambia al\n"
"    nuevo directorio tope.\n"
"    \n"
"    Opciones:\n"
"      -n\tsuprime el cambio normal de directorio cuando se borran\n"
"    \tdirectorios de la pila, así sólo se manipula la pila.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"      +N\tBorra la N-ésima entrada contando de la izquierda de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero.\n"
"    \tPor ejemplo: `popd +0' borra el primer directorio, `popd +1'\n"
"    \tel segundo.\n"
"    \n"
"      -N\tBorra la N-ésima entrada contando de la derecha de\n"
"    \tla lista mostrada por `dirs', comenzando desde cero.\n"
"    \tPor ejemplo: `popd -0' borra el último directorio, `popd -1'\n"
"    \tel penúltimo.\n"
"    \n"
"    La orden interna `dirs' muestra el contenido de la pila.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione un argumento inválido o\n"
"    falle el cambio de directorio."

#: builtins.c:1818
msgid ""
"Display directory stack.\n"
"    \n"
"    Display the list of currently remembered directories.  Directories\n"
"    find their way onto the list with the `pushd' command; you can get\n"
"    back up through the list with the `popd' command.\n"
"    \n"
"    Options:\n"
"      -c\tclear the directory stack by deleting all of the elements\n"
"      -l\tdo not print tilde-prefixed versions of directories relative\n"
"    \tto your home directory\n"
"      -p\tprint the directory stack with one entry per line\n"
"      -v\tprint the directory stack with one entry per line prefixed\n"
"    \twith its position in the stack\n"
"    \n"
"    Arguments:\n"
"      +N\tDisplays the Nth entry counting from the left of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"      -N\tDisplays the Nth entry counting from the right of the list shown "
"by\n"
"    \tdirs when invoked without options, starting with zero.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Muestra la pila de directorios.\n"
"    \n"
"    Muestra la lista de directorios actualmente grabados.  Los directorios\n"
"    se guardan en la lista con la orden `pushd'; pueden ir saliendo de\n"
"    la lista con la orden `popd'.\n"
"    \n"
"    Opciones:\n"
"    \n"
"      -c\tlimpia la pila de directorios, eliminando todos sus elementos.\n"
"      -l\tno muestra versiones con prefijo de tilde de los directorios\n"
"    \trelativos a su directorio inicial.\n"
"      -p\tmuestra la pila de directorios con una entrada por línea\n"
"      -v\tmuestra la pila de directorios con una entrada por línea con\n"
"    \tsu posición en la pila como prefijo\n"
"    \n"
"    Argumentos:      +N\tmuestra la N-ésima entrada contando desde la "
"izquierda de la lista\n"
"    \tmostrada por dirs cuando se invoca sin opciones,\n"
"    \tempezando de cero.\n"
"    \n"
"      -N\tmuestra la N-ésima entrada contando desde la derecha de la lista\n"
"    \tmostrada por dirs cuando se invoca sin opciones,\n"
"    \tempezando de cero.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito, a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:1847
msgid ""
"Set and unset shell options.\n"
"    \n"
"    Change the setting of each shell option OPTNAME.  Without any option\n"
"    arguments, list all shell options with an indication of whether or not "
"each\n"
"    is set.\n"
"    \n"
"    Options:\n"
"      -o\trestrict OPTNAMEs to those defined for use with `set -o'\n"
"      -p\tprint each shell option with an indication of its status\n"
"      -q\tsuppress output\n"
"      -s\tenable (set) each OPTNAME\n"
"      -u\tdisable (unset) each OPTNAME\n"
"    \n"
"    Exit Status:\n"
"    Returns success if OPTNAME is enabled; fails if an invalid option is\n"
"    given or OPTNAME is disabled."
msgstr ""
"Activa y desactiva opciones de shell.\n"
"    \n"
"    Cambia la configuración de cada opción de shell NOMBRE_OPCIÓN. Sin\n"
"    alguna opción como argumento, muestra todas las opciones de shell con\n"
"    una indicación si está activa o no.\n"
"    \n"
"    Opciones:\n"
"      -o\trestringe NOMBRE_OPCIÓN a aquellos definidos con `set -o'\n"
"      -p\tmuestra cada opción de shell con un indicador de su estado\n"
"      -q\tsuprime la salida\n"
"      -s\tactiva (establece) cada NOMBRE_OPCIÓN\n"
"      -u\tdesactiva (borra) cada NOMBRE_OPCIÓN\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito si se activa NOMBRE_OPCIÓN; falla si se proporciona\n"
"    una opción inválida o NOMBRE_OPCIÓN está desactivado."

#: builtins.c:1868
msgid ""
"Formats and prints ARGUMENTS under control of the FORMAT.\n"
"    \n"
"    Options:\n"
"      -v var\tassign the output to shell variable VAR rather than\n"
"    \t\tdisplay it on the standard output\n"
"    \n"
"    FORMAT is a character string which contains three types of objects: "
"plain\n"
"    characters, which are simply copied to standard output; character "
"escape\n"
"    sequences, which are converted and copied to the standard output; and\n"
"    format specifications, each of which causes printing of the next "
"successive\n"
"    argument.\n"
"    \n"
"    In addition to the standard format specifications described in printf"
"(1)\n"
"    and printf(3), printf interprets:\n"
"    \n"
"      %b\texpand backslash escape sequences in the corresponding argument\n"
"      %q\tquote the argument in a way that can be reused as shell input\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or a write or "
"assignment\n"
"    error occurs."
msgstr ""
"Da formato y muestra ARGUMENTOS bajo el control del FORMATO.\n"
"    \n"
"    Opciones:\n"
"      -v var\tasigna la salida a la variable de shell VAR en lugar\n"
"    \t\tde mostrarla en la salida estándar\n"
"    \n"
"    FORMATO es una cadena de caracteres la cual contiene tres tipos de\n"
"    objetos caracteres simples, los cuales solamente se copian a la salida\n"
"    salida estándar; secuencias de escape de caracteres, las cuales\n"
"    se convierten y se copian a la salida estándar; y especificaciones de\n"
"    formato, cada una de las cuales causa la muestra del siguiente "
"argumento\n"
"    consecutivo.\n"
"    \n"
"    Además de las especificaciones de formato estándar descritas en\n"
"    printf(1) y printf(3), printf interpreta:\n"
"      %b\texpande las secuencias de escape de barra invertida en\n"
"    \t\tel argumento correspondiente\n"
"      %q\tcita el argumento de tal forma que se puede reusar como\n"
"    \t\tentrada del shell.\n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    suceda un error de escritura o de asignación."

#: builtins.c:1895
#, fuzzy
msgid ""
"Specify how arguments are to be completed by Readline.\n"
"    \n"
"    For each NAME, specify how arguments are to be completed.  If no "
"options\n"
"    are supplied, existing completion specifications are printed in a way "
"that\n"
"    allows them to be reused as input.\n"
"    \n"
"    Options:\n"
"      -p\tprint existing completion specifications in a reusable format\n"
"      -r\tremove a completion specification for each NAME, or, if no\n"
"    \tNAMEs are supplied, all completion specifications\n"
"      -D\tapply the completions and actions as the default for commands\n"
"    \twithout any specific completion defined\n"
"      -E\tapply the completions and actions to \"empty\" commands --\n"
"    \tcompletion attempted on a blank line\n"
"    \n"
"    When completion is attempted, the actions are applied in the order the\n"
"    uppercase-letter options are listed above.  The -D option takes\n"
"    precedence over -E.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Especifica cuántos argumentos deben ser completados por Readline.\n"
"    \n"
"    Por cada NOMBRE, especifica cuántos argumentos se deben completar.  Si\n"
"    no se proporcionan opciones, se muestran las especificaciones de\n"
"    completado existentes en una forma que permite que se reusen como "
"entrada.\n"
"    \n"
"    Opciones:\n"
"      -p\tmuestra las especificaciones de completado existentes en formato\n"
"    \treusable\n"
"      -r\tborra una especificación de completado para cada NOMBRE,\n"
"    \to, si no se proporcionan NOMBREs, todas las especificaciones\n"
"    \tde completado\n"
"    \n"
"    Cuando se intenta el completado, las acciones se aplican en el orden en\n"
"    que se enlistan las opciones de letra mayúscula antes indicadas.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:1923
msgid ""
"Display possible completions depending on the options.\n"
"    \n"
"    Intended to be used from within a shell function generating possible\n"
"    completions.  If the optional WORD argument is supplied, matches "
"against\n"
"    WORD are generated.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or an error occurs."
msgstr ""
"Muestra los posibles complementos dependiendo de las opciones.\n"
"    \n"
"    Sirve para usarse desde una función de shell que genere complementos\n"
"    posibles.  Si se proporciona el argumento opcional PALABRA, se generan\n"
"    las coincidencias contra PALABRA.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    suceda un error."

#: builtins.c:1938
#, fuzzy
msgid ""
"Modify or display completion options.\n"
"    \n"
"    Modify the completion options for each NAME, or, if no NAMEs are "
"supplied,\n"
"    the completion currently begin executed.  If no OPTIONs are givenm, "
"print\n"
"    the completion options for each NAME or the current completion "
"specification.\n"
"    \n"
"    Options:\n"
"    \t-o option\tSet completion option OPTION for each NAME\n"
"    \t-D\t\tChange options for the \"default\" command completion\n"
"    \t-E\t\tChange options for the \"empty\" command completion\n"
"    \n"
"    Using `+o' instead of `-o' turns off the specified option.\n"
"    \n"
"    Arguments:\n"
"    \n"
"    Each NAME refers to a command for which a completion specification must\n"
"    have previously been defined using the `complete' builtin.  If no NAMEs\n"
"    are supplied, compopt must be called by a function currently generating\n"
"    completions, and the options for that currently-executing completion\n"
"    generator are modified.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is supplied or NAME does not\n"
"    have a completion specification defined."
msgstr ""
"Modifica o muestra las opciones de completado.\n"
"    \n"
"    Modifica las opciones de completado para cada NOMBRE, o, si no se\n"
"    proporcionan NOMBREs, el completado actualmente en ejecución.  Si no se\n"
"    proporcionan OPCIONes, muestra las opciones de completado para cada\n"
"    NOMBRE o la especificación de completado actual.    \n"
"    Opciones:\n"
"    \t-o opción\tEstablece la opción de completado OPCIÓN\n"
"    \t\tpara cada NOMBRE\n"
"    \n"
"    Si usa `+o' en lugar de `-o' desactiva la opción especificada.\n"
"    \n"
"    Argumentos:\n"
"    \n"
"    Cada NOMBRE se refiere a una orden para la cual se definió previamente\n"
"    una especificación de completado usando la orden interna `complete'.\n"
"    Si no se proporcionan NOMBREs, compopt debe llamarse desde una función\n"
"    que genere completados, y se modifican las opciones para ese generador\n"
"    de completados en ejecución.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    el NOMBRE no tenga una especificación de completado definida."

#: builtins.c:1968
#, fuzzy
msgid ""
"Read lines from the standard input into an indexed array variable.\n"
"    \n"
"    Read lines from the standard input into the indexed array variable "
"ARRAY, or\n"
"    from file descriptor FD if the -u option is supplied.  The variable "
"MAPFILE\n"
"    is the default ARRAY.\n"
"    \n"
"    Options:\n"
"      -n count\tCopy at most COUNT lines.  If COUNT is 0, all lines are "
"copied.\n"
"      -O origin\tBegin assigning to ARRAY at index ORIGIN.  The default "
"index is 0.\n"
"      -s count \tDiscard the first COUNT lines read.\n"
"      -t\t\tRemove a trailing newline from each line read.\n"
"      -u fd\t\tRead lines from file descriptor FD instead of the standard "
"input.\n"
"      -C callback\tEvaluate CALLBACK each time QUANTUM lines are read.\n"
"      -c quantum\tSpecify the number of lines read between each call to "
"CALLBACK.\n"
"    \n"
"    Arguments:\n"
"      ARRAY\t\tArray variable name to use for file data.\n"
"    \n"
"    If -C is supplied without -c, the default quantum is 5000.  When\n"
"    CALLBACK is evaluated, it is supplied the index of the next array\n"
"    element to be assigned as an additional argument.\n"
"    \n"
"    If not supplied with an explicit origin, mapfile will clear ARRAY "
"before\n"
"    assigning to it.\n"
"    \n"
"    Exit Status:\n"
"    Returns success unless an invalid option is given or ARRAY is readonly "
"or\n"
"    not an indexed array."
msgstr ""
"Lee líneas de un fichero y las guarda en una variable de matriz.\n"
"    \n"
"    Lee líneas de la entrada estándar y las guarda en la variable de matriz\n"
"    MATRIZ, o desde el descriptor de fichero DF si se proporciona la opción\n"
"    -u.  La variable MAPFILE es la MATRIZ por defecto.\n"
"    \n"
"    Opciones:\n"
"      -n cuenta\tCopia hasta CUENTA líneas.  Si CUENTA es 0, se copian\n"
"    \ttodas las líneas.\n"
"      -O origen\tComienza a asignar a MATRIZ en el índice ORIGEN.  El\n"
"    \tíndice por defecto es 0.\n"
"      -s cuenta \tDescarta las primeras CUENTA líneas leídas.\n"
"      -t\t\tBorra la nueva línea final de cada línea leída.\n"
"      -u df\t\tLee líneas del descriptor de fichero DF en lugar de la\n"
"    \tentrada estándar.\n"
"      -C llamada\tEvalúa LLAMADA cada vez que se leen QUANTUM líneas.\n"
"      -c quantum\tEspecifica el número de líneas a leer entre cada\n"
"    \tllamada a LLAMADA.\n"
"    \n"
"    Argumentos:\n"
"      MATRIZ\t\tNombre de variable de matriz a usar para guardar datos.\n"
"    \n"
"    Si se proporciona -C sin -c, el quantum por defecto es 5000. Cuando\n"
"    se evalúa LLAMADA, se proporciona el índice del siguiente elemento\n"
"    de la matriz a asignar como un argumento adicional.\n"
"    \n"
"    Si no se proporciona un origen explícito, mapfile borrará la MATRIZ\n"
"    antes de usarla para asignación.\n"
"    \n"
"    Estado de Salida:\n"
"    Devuelve con éxito a menos que se proporcione una opción inválida o\n"
"    la MATRIZ sea de sólo lectura."

#: builtins.c:2001
msgid ""
"Read lines from a file into an array variable.\n"
"    \n"
"    A synonym for `mapfile'."
msgstr ""
"Lee líneas de un fichero en una variable de matriz.\n"
"    \n"
"    Un sinónimo de `mapfile'."

#~ msgid "xrealloc: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr "xrealloc: no se pueden reasignar %lu bytes (%lu bytes asignados)"

#~ msgid "xrealloc: cannot allocate %lu bytes"
#~ msgstr "xrealloc: no se pueden reasignar %lu bytes"

#~ msgid "xrealloc: %s:%d: cannot reallocate %lu bytes (%lu bytes allocated)"
#~ msgstr ""
#~ "xrealloc: %s:%d: no se pueden reasignar %lu bytes (%lu bytes asignados)"

#~ msgid " "
#~ msgstr " "

#~ msgid "Without EXPR, returns returns \"$line $filename\".  With EXPR,"
#~ msgstr "Sin EXPR, returns devuelve \"$linea $nombrefichero\".  Con EXPR,"

#~ msgid "returns \"$line $subroutine $filename\"; this extra information"
#~ msgstr "devuelve \"$linea $subrutina $nombrefichero\"; esta información"

#~ msgid "can be used used to provide a stack trace."
#~ msgstr "adicional se puede usar para proveer un volcado de pila."

#~ msgid ""
#~ "The value of EXPR indicates how many call frames to go back before the"
#~ msgstr ""
#~ "El valor de EXPR indica cuántos marcos de llamada se debe retroceder"

#~ msgid "current one; the top frame is frame 0."
#~ msgstr "antes del actual; el marco inicial es el marco 0."

#~ msgid "%s: invalid number"
#~ msgstr "%s: número inválido"

#~ msgid "Shell commands matching keywords `"
#~ msgstr "Órdenes del shell que coinciden con las palabras `"

#~ msgid "Display the list of currently remembered directories.  Directories"
#~ msgstr ""
#~ "Muestra la lista de directorios actualmente grabados.  Los directorios"

#~ msgid "find their way onto the list with the `pushd' command; you can get"
#~ msgstr "se guardan en la lista con la orden `pushd'; pueden ir saliendo de"

#~ msgid "back up through the list with the `popd' command."
#~ msgstr "la lista con la orden `popd'."

#~ msgid ""
#~ "The -l flag specifies that `dirs' should not print shorthand versions"
#~ msgstr ""
#~ "La opción -l especifica que `dirs' no debe mostrar versiones abreviadas"

#~ msgid ""
#~ "of directories which are relative to your home directory.  This means"
#~ msgstr ""
#~ "de los directorios que son relativos a su directorio inicial.  Esto "
#~ "significa"

#~ msgid "that `~/bin' might be displayed as `/homes/bfox/bin'.  The -v flag"
#~ msgstr "que `~/bin' se mostrará como `/homes/bfox/bin'. La opción -v"

#~ msgid "causes `dirs' to print the directory stack with one entry per line,"
#~ msgstr ""
#~ "causa que `dirs' imprima la pila de directorios con una entrada por línea,"

#~ msgid ""
#~ "prepending the directory name with its position in the stack.  The -p"
#~ msgstr ""
#~ "anteponiendo la posición en la pila al nombre del directorio.  La opción"

#~ msgid "flag does the same thing, but the stack position is not prepended."
#~ msgstr "-p hace lo mismo, pero no antepone la posición en la pila."

#~ msgid ""
#~ "The -c flag clears the directory stack by deleting all of the elements."
#~ msgstr ""
#~ "La opción -c limpia la pila de directorios borrando todos sus elementos."

#~ msgid ""
#~ "+N   displays the Nth entry counting from the left of the list shown by"
#~ msgstr ""
#~ "+N   muestra la N-ésima entrada contando desde la izquierda de la lista"

#~ msgid "     dirs when invoked without options, starting with zero."
#~ msgstr ""
#~ "     mostrada por dirs cuando se invoca sin opciones, empezando de cero."

#~ msgid ""
#~ "-N   displays the Nth entry counting from the right of the list shown by"
#~ msgstr ""
#~ "-N   muestra la N-ésima entrada contando desde la derecha de la lista"

#~ msgid "Adds a directory to the top of the directory stack, or rotates"
#~ msgstr "Agrega un directorio al tope de la pila de directorios, o rota"

#~ msgid "the stack, making the new top of the stack the current working"
#~ msgstr "la pila, haciendo que el nuevo tope de la pila sea el directorio de"

#~ msgid "directory.  With no arguments, exchanges the top two directories."
#~ msgstr ""
#~ "trabajo actual.  Sin argumentos, intercambia los dos directorios del tope."

#~ msgid "+N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "+N   Rota la pila para que el N-ésimo directorio (contando"

#~ msgid "     from the left of the list shown by `dirs', starting with"
#~ msgstr ""
#~ "     de la izquierda de la lista mostrada por `dirs', comenzando desde"

#~ msgid "     zero) is at the top."
#~ msgstr "     cero) esté en el tope."

#~ msgid "-N   Rotates the stack so that the Nth directory (counting"
#~ msgstr "-N   Rota la pila para que el N-ésimo directory (contando"

#~ msgid "     from the right of the list shown by `dirs', starting with"
#~ msgstr ""
#~ "     de la derecha de la lista mostrada por `dirs', comenzando desde"

#~ msgid "-n   suppress the normal change of directory when adding directories"
#~ msgstr ""
#~ "-n   suprime el cambio normal de directorio cuando se agregan directorios"

#~ msgid "     to the stack, so only the stack is manipulated."
#~ msgstr "     a la pila, así sólo se manipula la pila."

#~ msgid "dir  adds DIR to the directory stack at the top, making it the"
#~ msgstr "dir  agrega DIR a la pila de directorios en el tope, haciéndolo el"

#~ msgid "     new current working directory."
#~ msgstr "     nuevo directorio de trabajo actual."

#~ msgid "You can see the directory stack with the `dirs' command."
#~ msgstr "Puede ver la pila de directorios con la orden `dirs'."

#~ msgid "Removes entries from the directory stack.  With no arguments,"
#~ msgstr "Borra entradas de la pila de directorios.  Sin argumentos,"

#~ msgid "removes the top directory from the stack, and cd's to the new"
#~ msgstr "borra el directorio del tope de la pila, y cambia al nuevo"

#~ msgid "top directory."
#~ msgstr "directorio tope."

#~ msgid "+N   removes the Nth entry counting from the left of the list"
#~ msgstr ""
#~ "+N   borra la N-ésima entrada contando desde la izquierda de la lista"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd +0'"
#~ msgstr ""
#~ "     mostrada por `dirs', comenzando desde cero.  Por ejemplo: `popd +0'"

#~ msgid "     removes the first directory, `popd +1' the second."
#~ msgstr "     borra el primer directorio, `popd +1' el segundo."

#~ msgid "-N   removes the Nth entry counting from the right of the list"
#~ msgstr "-N   borra la N-ésima entrada contando desde la derecha de la lista"

#~ msgid "     shown by `dirs', starting with zero.  For example: `popd -0'"
#~ msgstr ""
#~ "     mostrada por `dirs', comenzando desde cero.  Por ejemplo: `popd -0'"

#~ msgid "     removes the last directory, `popd -1' the next to last."
#~ msgstr "     borra el último directorio, `popd -1' el penúltimo."

#~ msgid ""
#~ "-n   suppress the normal change of directory when removing directories"
#~ msgstr ""
#~ "-n   suprime el cambio normal de directorio cuando se borran directorios"

#~ msgid "     from the stack, so only the stack is manipulated."
#~ msgstr "     de la pila, así sólo se manipula la pila."

#~ msgid "allocated"
#~ msgstr "asignado"

#~ msgid "freed"
#~ msgstr "liberado"

#~ msgid "requesting resize"
#~ msgstr "solicitando cambio de tamaño"

#~ msgid "just resized"
#~ msgstr "terminó cambio de tamaño"

#~ msgid "bug: unknown operation"
#~ msgstr "bicho: operación desconocida"

#~ msgid "malloc: watch alert: %p %s "
#~ msgstr "malloc: alerta de observación: %p %s "

#~ msgid ""
#~ "Exit from within a FOR, WHILE or UNTIL loop.  If N is specified,\n"
#~ "    break N levels."
#~ msgstr ""
#~ "Sale de un ciclo FOR, WHILE o UNTIL.  Si se especifica N,\n"
#~ "    sale N niveles."

#~ msgid ""
#~ "Run a shell builtin.  This is useful when you wish to rename a\n"
#~ "    shell builtin to be a function, but need the functionality of the\n"
#~ "    builtin within the function itself."
#~ msgstr ""
#~ "Ejecuta una orden interna del shell.  Esto es útil cuando desea "
#~ "renombrar\n"
#~ "    una orden interna del shell para que sea una función, pero necesita\n"
#~ "    la funcionalidad de la orden interna dentro de la misma función."

#~ msgid ""
#~ "Print the current working directory.  With the -P option, pwd prints\n"
#~ "    the physical directory, without any symbolic links; the -L option\n"
#~ "    makes pwd follow symbolic links."
#~ msgstr ""
#~ "Muestra el directorio de trabajo actual.  Con la opción -P, pwd muestra\n"
#~ "    el directorio físico, sin enlaces simbólicos; la opción -L hace que\n"
#~ "    pwd siga los enlaces simbólicos."

#~ msgid "Return a successful result."
#~ msgstr "Devuelve un resultado exitoso."

# es usado -> se usa. sv
# es impresa -> se muestra una cadena em+
# "Si se da la opción -V o -v,..." sv
# De acuerdo. cfuga
#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell\n"
#~ "    function called `ls', and you wish to call the command `ls', you can\n"
#~ "    say \"command ls\".  If the -p option is given, a default value is "
#~ "used\n"
#~ "    for PATH that is guaranteed to find all of the standard utilities.  "
#~ "If\n"
#~ "    the -V or -v option is given, a string is printed describing "
#~ "COMMAND.\n"
#~ "    The -V option produces a more verbose description."
#~ msgstr ""
#~ "Ejecuta COMMAND con ARGS ignorando las funciones del shell.  Si tiene "
#~ "una\n"
#~ "    función de shell llamada `ls', y desea llamar a la orden `ls', puede\n"
#~ "    decir \"command ls\".  Si se da la opción -p, se usa un valor por\n"
#~ "    defecto para PATH que garantiza encontrar todas las herramientas\n"
#~ "    estándar.  Si se da la opción -V o -v, se muestra una cadena que\n"
#~ "    describe COMMAND.  La opción -V produce una descripción más detallada."

# apaga -> desactiva em+
# Corregido en toda la traducción. cfuga
#~ msgid ""
#~ "Declare variables and/or give them attributes.  If no NAMEs are\n"
#~ "    given, then display the values of variables instead.  The -p option\n"
#~ "    will display the attributes and values of each NAME.\n"
#~ "    \n"
#~ "    The flags are:\n"
#~ "    \n"
#~ "      -a\tto make NAMEs arrays (if supported)\n"
#~ "      -f\tto select from among function names only\n"
#~ "      -F\tto display function names (and line number and source file name "
#~ "if\n"
#~ "    \tdebugging) without definitions\n"
#~ "      -i\tto make NAMEs have the `integer' attribute\n"
#~ "      -r\tto make NAMEs readonly\n"
#~ "      -t\tto make NAMEs have the `trace' attribute\n"
#~ "      -x\tto make NAMEs export\n"
#~ "    \n"
#~ "    Variables with the integer attribute have arithmetic evaluation (see\n"
#~ "    `let') done when the variable is assigned to.\n"
#~ "    \n"
#~ "    When displaying values of variables, -f displays a function's name\n"
#~ "    and definition.  The -F option restricts the display to function\n"
#~ "    name only.\n"
#~ "    \n"
#~ "    Using `+' instead of `-' turns off the given attribute instead.  "
#~ "When\n"
#~ "    used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "Declara variables y/o les asigna atributos. Si no se propociona\n"
#~ "    ningún NAME, entonces muestra los valores de las variables.\n"
#~ "    La opción -p mostrará los atributos y valores de cada NAME.\n"
#~ "    \n"
#~ "    Las opciones son:\n"
#~ "    \n"
#~ "      -a\thace a los NAMEs matrices (si tiene soporte)\n"
#~ "      -f\tselecciona solamente nombres de funciones\n"
#~ "      -F\tmuestra nombres de funciones (y número de línea y nombre de\n"
#~ "    \tfichero fuente si se está depurando) sin definiciones\n"
#~ "      -i\tasigna a los NAMEs el atributo `integer'\n"
#~ "      -r\thace a los NAMEs de sólo lectura\n"
#~ "      -t\tasigna a los NAMEs el atributo `trace'\n"
#~ "      -x\thace a los NAMEs exportables\n"
#~ "    \n"
#~ "    Las variables con el atributo integer se les evalúa aritméticamente\n"
#~ "    (vea `let') cuando se asigna la variable.\n"
#~ "    \n"
#~ "    Cuando se muestran los valores de las variables, -f muestra\n"
#~ "    el nombre de una función y su definición.  La opción -F restringe\n"
#~ "    a mostrar solamente el nombre de la función.\n"
#~ "    \n"
#~ "    Al usar `+' en lugar de `-' desactiva el atributo dado.  Cuando se\n"
#~ "    usa en una función, hace a los NAMEs locales, como sucede con la\n"
#~ "    orden `local'."

#~ msgid "Obsolete.  See `declare'."
#~ msgstr "Obsoleto.  Ver `declare'."

# y le da -> y le asigna em+
# sólo se puede usar. sv
# tenga un alcance visible -> sea visible solo para la función y sus los hijos em+
# De acuerdo. cfuga
#~ msgid ""
#~ "Create a local variable called NAME, and give it VALUE.  LOCAL\n"
#~ "    can only be used within a function; it makes the variable NAME\n"
#~ "    have a visible scope restricted to that function and its children."
#~ msgstr ""
#~ "Crea una variable local llamada NAME, y le asigna un VALUE.  LOCAL\n"
#~ "    sólo se puede usar dentro de una función; hace que la variable NAME\n"
#~ "    solamente sea visible a esa función y sus hijos."

#~ msgid ""
#~ "Output the ARGs.  If -n is specified, the trailing newline is suppressed."
#~ msgstr ""
#~ "Muestra los ARGs. Si se especifica -n, se elimina el carácter\n"
#~ "    de fin de línea."

# se puede usar. sv
# Se muestra una lista de órdenes internas. sv
# Hay muchos más mensajes que están en "pasiva" que quedarían mejor en
# forma "reflexiva". No comento más y te dejo que los mires despacio.
# Gracias por la observación. cfuga
#~ msgid ""
#~ "Enable and disable builtin shell commands.  This allows\n"
#~ "    you to use a disk command which has the same name as a shell\n"
#~ "    builtin without specifying a full pathname.  If -n is used, the\n"
#~ "    NAMEs become disabled; otherwise NAMEs are enabled.  For example,\n"
#~ "    to use the `test' found in $PATH instead of the shell builtin\n"
#~ "    version, type `enable -n test'.  On systems supporting dynamic\n"
#~ "    loading, the -f option may be used to load new builtins from the\n"
#~ "    shared object FILENAME.  The -d option will delete a builtin\n"
#~ "    previously loaded with -f.  If no non-option names are given, or\n"
#~ "    the -p option is supplied, a list of builtins is printed.  The\n"
#~ "    -a option means to print every builtin with an indication of whether\n"
#~ "    or not it is enabled.  The -s option restricts the output to the "
#~ "POSIX.2\n"
#~ "    `special' builtins.  The -n option displays a list of all disabled "
#~ "builtins."
#~ msgstr ""
#~ "Activa y desactiva las órdenes internas del shell. Esto le permite\n"
#~ "    usar una orden del sistema que tenga el mismo nombre que una orden\n"
#~ "    interna del shell sin especificar una ruta completa.  Si se usa -n, "
#~ "los\n"
#~ "    NAMEs se desactivan; de otra forma los NAMEs se activan.  Por "
#~ "ejemplo,\n"
#~ "    para usar `test' que se encuentra en $PATH en lugar de la versión "
#~ "interna\n"
#~ "    del shell, teclee `enable -n test'.  En sistemas que soportan\n"
#~ "    carga dinámica, se puede usar la opción -f para cargar nuevas "
#~ "órdenes\n"
#~ "    internas desde el objeto compartido FILENAME.  La opción -d borrará "
#~ "una\n"
#~ "    orden interna cargada previamente con -f.  Si no se propocionan "
#~ "nombres\n"
#~ "    que no sean opciones, o se especifica la opción -p, se muestra una "
#~ "lista\n"
#~ "    de órdenes internas.  La opción -a es para mostrar cada orden "
#~ "interna\n"
#~ "    con una indicación si está o no activada.  La opción -s restringe la\n"
#~ "    salida a las órdenes internas `especiales' de POSIX.2. La opción -n\n"
#~ "    muestra una lista de todas las órdenes internas desactivadas."

#~ msgid ""
#~ "Read ARGs as input to the shell and execute the resulting command(s)."
#~ msgstr ""
#~ "Lee ARGs como entrada del shell y ejecuta el(los) comando(s) resultantes."

#~ msgid ""
#~ "Exec FILE, replacing this shell with the specified program.\n"
#~ "    If FILE is not specified, the redirections take effect in this\n"
#~ "    shell.  If the first argument is `-l', then place a dash in the\n"
#~ "    zeroth arg passed to FILE, as login does.  If the `-c' option\n"
#~ "    is supplied, FILE is executed with a null environment.  The `-a'\n"
#~ "    option means to make set argv[0] of the executed process to NAME.\n"
#~ "    If the file cannot be executed and the shell is not interactive,\n"
#~ "    then the shell exits, unless the shell option `execfail' is set."
#~ msgstr ""
#~ "Ejecuta FILE, reemplazando este shell con el programa especificado.\n"
#~ "    Si no se especifica FILE, las redirecciones toman efecto en este\n"
#~ "    shell.  Si el primer argumento es `-l' entonces coloca un guión\n"
#~ "    en el argumento cero que pasa a FILE, como lo hace login.  Si se\n"
#~ "    proporciona la opción `-c', se ejecuta FILE con un ambiente nulo.\n"
#~ "    La opción `-a' establece el argv[0] del proceso ejecutado a NOMBRE.\n"
#~ "    Si no se puede ejecutar el fichero, y el shell no es intercativo,\n"
#~ "    entonces el shell termina, a menos que esté activa la opción\n"
#~ "    `execfail'."

#~ msgid "Logout of a login shell."
#~ msgstr "Se desconecta de un shell de entrada."

#~ msgid ""
#~ "For each NAME, the full pathname of the command is determined and\n"
#~ "    remembered.  If the -p option is supplied, PATHNAME is used as the\n"
#~ "    full pathname of NAME, and no path search is performed.  The -r\n"
#~ "    option causes the shell to forget all remembered locations.  The -d\n"
#~ "    option causes the shell to forget the remembered location of each "
#~ "NAME.\n"
#~ "    If the -t option is supplied the full pathname to which each NAME\n"
#~ "    corresponds is printed.  If multiple NAME arguments are supplied "
#~ "with\n"
#~ "    -t, the NAME is printed before the hashed full pathname.  The -l "
#~ "option\n"
#~ "    causes output to be displayed in a format that may be reused as "
#~ "input.\n"
#~ "    If no arguments are given, information about remembered commands is "
#~ "displayed."
#~ msgstr ""
#~ "Por cada NOMBRE, se determina la ruta completa de la orden y se graba.\n"
#~ "    Si se especifica la opción -p, se usa PATHNAME como la ruta completa\n"
#~ "    de NAME, y no se realiza la búsqueda de ruta. La opción -r hace que\n"
#~ "    el shell olvide todas las ubicaciones grabadas. La opción -d hace "
#~ "que\n"
#~ "    el shell olvide las ubicaciones grabadas de cada NAME.  Si se\n"
#~ "    proporciona la opción -t se muestra la ruta completa para cada NAME\n"
#~ "    correspondiente.  Si se proporcionan múltiples argumentos NAME con\n"
#~ "    -t, NAME se muestra antes de la ruta completa.  La opción -l hace\n"
#~ "    que la salida se muestre en un formato que se puede reusar como\n"
#~ "    entrada.  Si no se proporcionan argumentos, se muestra la "
#~ "información\n"
#~ "    de las órdenes grabadas."

#~ msgid ""
#~ "Display helpful information about builtin commands.  If PATTERN is\n"
#~ "    specified, gives detailed help on all commands matching PATTERN,\n"
#~ "    otherwise a list of the builtins is printed.  The -s option\n"
#~ "    restricts the output for each builtin command matching PATTERN to\n"
#~ "    a short usage synopsis."
#~ msgstr ""
#~ "Muestra información útil sobre las órdenes internas del shell. Si se\n"
#~ "    especifica un PATRÓN, proporciona ayuda detallada sobre todas las\n"
#~ "    órdenes que coinciden con el PATRÓN, de otra forma se muestra una\n"
#~ "    lista de las órdenes internas.  La opción -s restringe la salida\n"
#~ "    de cada orden interna que concida con el PATRÓN a una breve\n"
#~ "    sinopsis de uso."

#~ msgid ""
#~ "By default, removes each JOBSPEC argument from the table of active jobs.\n"
#~ "    If the -h option is given, the job is not removed from the table, but "
#~ "is\n"
#~ "    marked so that SIGHUP is not sent to the job if the shell receives a\n"
#~ "    SIGHUP.  The -a option, when JOBSPEC is not supplied, means to remove "
#~ "all\n"
#~ "    jobs from the job table; the -r option means to remove only running "
#~ "jobs."
#~ msgstr ""
#~ "Por defecto, elimina cada argumento JOBSPEC de la tabla de trabajos "
#~ "activos.\n"
#~ "    Si se especifica la opción -h, el trabajo no se elimina de la tabla,\n"
#~ "    pero se marca de forma que no se envía SIGHUP al trabajo si el shell\n"
#~ "    recibe un SIGHUP.  La opción -a, cuando no se proporciona JOBSPEC, "
#~ "borra\n"
#~ "    todos los trabajos de la tabla de trabajos; la opción -r borra sólo\n"
#~ "    los trabajos activos."

#~ msgid ""
#~ "Causes a function to exit with the return value specified by N.  If N\n"
#~ "    is omitted, the return status is that of the last command."
#~ msgstr ""
#~ "Causa la salida de una función con el valor de devolución especificado "
#~ "por N.\n"
#~ "    Si se omite N, el estado de devolución será el de la última orden."

#~ msgid ""
#~ "For each NAME, remove the corresponding variable or function.  Given\n"
#~ "    the `-v', unset will only act on variables.  Given the `-f' flag,\n"
#~ "    unset will only act on functions.  With neither flag, unset first\n"
#~ "    tries to unset a variable, and if that fails, then tries to unset a\n"
#~ "    function.  Some variables cannot be unset; also see readonly."
#~ msgstr ""
#~ "Para cada NAME, se borra la variable o función correspondiente.  Al usar\n"
#~ "    `-v', unset sólo actuará sobre variables.  Al usar la opción `-f',\n"
#~ "    unset sólo actuará sobre funciones.  Sin ninguna opción, unset "
#~ "primero\n"
#~ "    intenta borrar una variable, y si esto falla, entonces intenta "
#~ "borrar\n"
#~ "    una función.  Algunas variables no se pueden borrar; vea también "
#~ "readonly."

#~ msgid ""
#~ "NAMEs are marked for automatic export to the environment of\n"
#~ "    subsequently executed commands.  If the -f option is given,\n"
#~ "    the NAMEs refer to functions.  If no NAMEs are given, or if `-p'\n"
#~ "    is given, a list of all names that are exported in this shell is\n"
#~ "    printed.  An argument of `-n' says to remove the export property\n"
#~ "    from subsequent NAMEs.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Se marcan NAMEs para exportación automática al ambiente de las\n"
#~ "    órdenes ejecutadas subsecuentemente.  Si se establece la opción -f,\n"
#~ "    NAMEs se refieren a funciones.  Si no se proporciona ningún NAME,\n"
#~ "    o si se proporciona `-p', se muestra una lista de todos los nombres\n"
#~ "    que se exportan en este shell.  Un argumento `-n' indica eliminar\n"
#~ "    la propiedad de exportación para los NAMEs subsecuentes.  Un "
#~ "argumento\n"
#~ "    `--' desactiva el procesamiento posterior de opciones."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may\n"
#~ "    not be changed by subsequent assignment.  If the -f option is given,\n"
#~ "    then functions corresponding to the NAMEs are so marked.  If no\n"
#~ "    arguments are given, or if `-p' is given, a list of all readonly "
#~ "names\n"
#~ "    is printed.  The `-a' option means to treat each NAME as\n"
#~ "    an array variable.  An argument of `--' disables further option\n"
#~ "    processing."
#~ msgstr ""
#~ "Los NAMEs dados se marcan como sólo lectura y los valores de esos NAMEs\n"
#~ "    no se pueden cambiar por asignaciones posteriores.  Si se propociona\n"
#~ "    la opción -f, entonces también se marcan las funciones que "
#~ "correspondan\n"
#~ "    a los NAMEs.  Si no se proporcionan argumentos, o si se especifica\n"
#~ "    `-p', se muestra una lista de todos los nombres de sólo lectura.\n"
#~ "    La opción `-a' trata cada NAME como una variable de matriz.\n"
#~ "    Un argumento `--' desactiva opciones posteriores."

#~ msgid ""
#~ "The positional parameters from $N+1 ... are renamed to $1 ...  If N is\n"
#~ "    not given, it is assumed to be 1."
#~ msgstr ""
#~ "Los parámetros posicionales de $N+1 ... se renombran a $1 ... Si no se\n"
#~ "    proporciona N, se asume que es 1."

#~ msgid ""
#~ "Suspend the execution of this shell until it receives a SIGCONT\n"
#~ "    signal.  The `-f' if specified says not to complain about this\n"
#~ "    being a login shell if it is; just suspend anyway."
#~ msgstr ""
#~ "Suspende la ejecución de este shell hasta que recibe una señal\n"
#~ "    SIGCONT.  Si se especifica `-f' indica que no se queje si es\n"
#~ "    un shell de login; y se suspende de cualquier forma."

#~ msgid ""
#~ "Print the accumulated user and system times for processes run from\n"
#~ "    the shell."
#~ msgstr ""
#~ "Muestra los tiempos de usuario y de sistema acumulados para los procesos\n"
#~ "    ejecutados desde el shell."

#~ msgid ""
#~ "For each NAME, indicate how it would be interpreted if used as a\n"
#~ "    command name.\n"
#~ "    \n"
#~ "    If the -t option is used, `type' outputs a single word which is one "
#~ "of\n"
#~ "    `alias', `keyword', `function', `builtin', `file' or `', if NAME is "
#~ "an\n"
#~ "    alias, shell reserved word, shell function, shell builtin, disk "
#~ "file,\n"
#~ "    or unfound, respectively.\n"
#~ "    \n"
#~ "    If the -p flag is used, `type' either returns the name of the disk\n"
#~ "    file that would be executed, or nothing if `type -t NAME' would not\n"
#~ "    return `file'.\n"
#~ "    \n"
#~ "    If the -a flag is used, `type' displays all of the places that "
#~ "contain\n"
#~ "    an executable named `file'.  This includes aliases, builtins, and\n"
#~ "    functions, if and only if the -p flag is not also used.\n"
#~ "    \n"
#~ "    The -f flag suppresses shell function lookup.\n"
#~ "    \n"
#~ "    The -P flag forces a PATH search for each NAME, even if it is an "
#~ "alias,\n"
#~ "    builtin, or function, and returns the name of the disk file that "
#~ "would\n"
#~ "    be executed."
#~ msgstr ""
#~ "Para cada NAME, se indica cómo se interpretaría se se usara como\n"
#~ "    el nombre de una orden.\n"
#~ "    \n"
#~ "    Si se usa la opción -t, `type' muestra una sola palabra que es una\n"
#~ "    de `alias', `keyword', `function', `builtin', `file' ó `', si NAME\n"
#~ "    es un alias, palabra reservada del shell, función del shell, orden\n"
#~ "    interna del shell, fichero del disco, o no encontrado, "
#~ "respectivamente.\n"
#~ "    \n"
#~ "    Si se usa la opción -p, `type' devuelve el nombre del fichero del\n"
#~ "    sistema que sería ejecutado, o nada, si `type -t NAME' no devuelve\n"
#~ "    `file'.\n"
#~ "    \n"
#~ "    Si se usa la opción -a, `type' muestra todos los lugares que "
#~ "contienen\n"
#~ "    un ejecutable llamado `file'.  Esto incluye a aliases, órdenes\n"
#~ "    internas, y funciones, si y solo si no se usa la opción -p.\n"
#~ "    \n"
#~ "    La opción -f suprime la búsqueda de funciones de shell.\n"
#~ "    \n"
#~ "    La opción -P fuerza una búsqueda en PATH por cada NAME, aún si es un\n"
#~ "    alias, orden interna, o función, y devuelve el nombre del fichero "
#~ "del\n"
#~ "    disco que se puede ejecutar."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if\n"
#~ "    `-S' is supplied, the current value of the mask is printed.  The `-"
#~ "S'\n"
#~ "    option makes the output symbolic; otherwise an octal number is "
#~ "output.\n"
#~ "    If `-p' is supplied, and MODE is omitted, the output is in a form\n"
#~ "    that may be used as input.  If MODE begins with a digit, it is\n"
#~ "    interpreted as an octal number, otherwise it is a symbolic mode "
#~ "string\n"
#~ "    like that accepted by chmod(1)."
#~ msgstr ""
#~ "La máscara de creación de ficheros se establece a MODE.  Si se omite "
#~ "MODE,\n"
#~ "    o si se proporciona `-S', se muestra el valor actual de la máscara. "
#~ "La\n"
#~ "    opción `-S' hace la salida simbólica; de otra forma la salida es un\n"
#~ "    número octal.  Si se proporciona `-p', y se omite MODE, la salida es\n"
#~ "    en una forma que se puede usar como entrada.  Si MODE empieza con un\n"
#~ "    dígito, se interpreta como un número octal, de otra forma es una "
#~ "cadena\n"
#~ "    de modo simbólico como la que acepta chmod(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If\n"
#~ "    N is not given, all currently active child processes are waited for,\n"
#~ "    and the return code is zero.  N is a process ID; if it is not given,\n"
#~ "    all child processes of the shell are waited for."
#~ msgstr ""
#~ "Espera al proceso especificado y reporta su estado final.  Si no se\n"
#~ "    proporciona N, espera a todos los procesos hijo activos actualmente,\n"
#~ "    y el código de devolución es cero. N es un ID de proceso; si no se\n"
#~ "    proporciona, se espera a todos los procesos hijo del shell."

#~ msgid ""
#~ "Create a simple command invoked by NAME which runs COMMANDS.\n"
#~ "    Arguments on the command line along with NAME are passed to the\n"
#~ "    function as $0 .. $n."
#~ msgstr ""
#~ "Crea una orden simple invocada por NAME que ejecuta COMMMANDS.\n"
#~ "    Se pasan a la función los argumentos en la línea de órdenes\n"
#~ "    junto con NAME como $0 .. $n."

#~ msgid ""
#~ "Toggle the values of variables controlling optional behavior.\n"
#~ "    The -s flag means to enable (set) each OPTNAME; the -u flag\n"
#~ "    unsets each OPTNAME.  The -q flag suppresses output; the exit\n"
#~ "    status indicates whether each OPTNAME is set or unset.  The -o\n"
#~ "    option restricts the OPTNAMEs to those defined for use with\n"
#~ "    `set -o'.  With no options, or with the -p option, a list of all\n"
#~ "    settable options is displayed, with an indication of whether or\n"
#~ "    not each is set."
#~ msgstr ""
#~ "Cambia los valores de las variables que controlan conductas opcionales.\n"
#~ "    La opción -s activa (define) cada OPTNAME; la opción -u desactiva\n"
#~ "    cada OPTNAME.  La opción -q suprime la salida; el estado de salida\n"
#~ "    indica si cada OPTNAME se definió o no.  La opción -o restringe\n"
#~ "    que OPTNAMEs sean aquéllos definidos para usarse con `set -o'.\n"
#~ "    Sin opciones, o con la opción -p, se muestra una lista de todas\n"
#~ "    las opciones definibles, con una indicación si están o no activas."

#~ msgid ""
#~ "For each NAME, specify how arguments are to be completed.\n"
#~ "    If the -p option is supplied, or if no options are supplied, "
#~ "existing\n"
#~ "    completion specifications are printed in a way that allows them to "
#~ "be\n"
#~ "    reused as input.  The -r option removes a completion specification "
#~ "for\n"
#~ "    each NAME, or, if no NAMEs are supplied, all completion "
#~ "specifications."
#~ msgstr ""
#~ "Por cada NAME, especifica cómo se deben completar los argumentos.\n"
#~ "    Si se proporciona la opción -p, o si no se proporcionan opciones, se\n"
#~ "    muestran las especificaciones existentes de completado en una forma\n"
#~ "    que permite que se reusen como entrada.  La opción -r borra una\n"
#~ "    especificación de completado para cada NAME, o, si no se proporciona\n"
#~ "    ningún NAMEs, todas las especificaciones de completado."

#~ msgid "Missing `}'"
#~ msgstr "Faltan `}'"

#~ msgid "brace_expand> "
#~ msgstr "expansión_llave> "

# ¿ a qué se refiere ? em+
# También podría ser la orden de tipo desconocido. sv
# Tiene razón Santiago. Las órdenes se guardan en matrices de caracteres
# en bash. Si bash intenta borrar uno de estos comandos y el tipo del dato
# NO es matriz de caracter, emitiría este mensaje. cfuga
#~ msgid "Attempt to free unknown command type `%d'.\n"
#~ msgstr "Intentando liberar la orden de tipo desconocido `%d'.\n"

#~ msgid "Report this to %s\n"
#~ msgstr "Comunique esto a %s\n"

#~ msgid "Stopping myself..."
#~ msgstr "Deteniéndome..."

#~ msgid "Tell %s to fix this someday.\n"
#~ msgstr "Decir a %s que arregle esto algún día.\n"

#~ msgid "execute_command: bad command type `%d'"
#~ msgstr "execute_command: tipo de orden erróneo `%d'"

#~ msgid "real\t"
#~ msgstr "real\t"

#~ msgid "user\t"
#~ msgstr "usuario\t"

#~ msgid "sys\t"
#~ msgstr "sistema\t"

#~ msgid ""
#~ "real\t0m0.00s\n"
#~ "user\t0m0.00s\n"
#~ "sys\t0m0.00s\n"
#~ msgstr ""
#~ "real\t0m0.00s\n"
#~ "usuario\t0m0.00s\n"
#~ "sistema\t0m0.00s\n"

#~ msgid "cannot duplicate fd %d to fd 1: %s"
#~ msgstr "no se puede duplicar el df %d al df 1: %s"

#~ msgid "%s: output redirection restricted"
#~ msgstr "%s: la redirección de salida está restringida"

#~ msgid "Out of memory!"
#~ msgstr "¡Memoria agotada!"

#~ msgid "You have already added item `%s'\n"
#~ msgstr "Ya se había añadido el elemento `%s'\n"

# Han sido introducidos o quizá , Vd, introdujo em+
#~ msgid "You have entered %d (%d) items.  The distribution is:\n"
#~ msgstr "Introdujo %d (%d) elementos. La distribución es:\n"

#~ msgid "%s: bg background job?"
#~ msgstr "%s: ¿bg trabajo en background?"

#~ msgid ""
#~ "Redirection instruction from yyparse () '%d' is\n"
#~ "out of range in make_redirection ()."
#~ msgstr ""
#~ "La instrucción de redirección de yyparse () '%d' está fuera de rango en \n"
#~ "make_redirection ()."

#~ msgid "clean_simple_command () got a command with type %d."
#~ msgstr "clean_simple_command () tiene una orden del tipo %d."

#~ msgid "got errno %d while waiting for %d"
#~ msgstr "se obtuvo errno %d mientras esperaba a %d"

# algo por el estilo em+
#~ msgid "syntax error near unexpected token `%c'"
#~ msgstr "error sintáctico cerca del elemento inesperado `%c'"

# Por consistencia con mensajes anteriores, sería erróneo (el tipo). sv
# De acuerdo. Corregido. cfuga
#~ msgid "print_command: bad command type `%d'"
#~ msgstr "print_command: tipo de dato de orden `%d' erróneo"

#~ msgid "cprintf: bad `%%' argument (%c)"
#~ msgstr "cprintf: argumento `%%' erróneo (%c)"

#~ msgid "option `%s' requires an argument"
#~ msgstr "la opción `%s' requiere un argumento"

#~ msgid "%s: unrecognized option"
#~ msgstr "%s: la opción no es reconocida"

#~ msgid "`-c' requires an argument"
#~ msgstr "`-c' requiere un argumento"

#~ msgid "%s: cannot execute directories"
#~ msgstr "%s: no se pueden ejecutar directorios"

#~ msgid "Bad code in sig.c: sigprocmask"
#~ msgstr "Código erróneo en sig.c: sigprocmask"

#~ msgid "bad substitution: no ending `}' in %s"
#~ msgstr "sustitución errónea: no hay `}' final en %s"

#~ msgid "%s: bad array subscript"
#~ msgstr "%s: subíndice de matriz erróneo"

#~ msgid "can't make pipes for process substitution: %s"
#~ msgstr ""
#~ "no se pueden crear las tuberías (pipes) para la sustitución del proceso: %"
#~ "s"

#~ msgid "reading"
#~ msgstr "leyendo"

#~ msgid "writing"
#~ msgstr "escribiendo"

# del proceso em+
#~ msgid "process substitution"
#~ msgstr "sustitución de proceso"

#~ msgid "command substitution"
#~ msgstr "sustitución de la orden"

#~ msgid "Can't reopen pipe to command substitution (fd %d): %s"
#~ msgstr ""
#~ "No se puede reabrir la tubería para la sustitución de la orden (df %d): %s"

#~ msgid "$%c: unbound variable"
#~ msgstr "$%c: variable desligada"

#~ msgid "%s: bad arithmetic substitution"
#~ msgstr "%s: sustitución aritmética errónea"

#~ msgid "-%s: binary operator expected"
#~ msgstr "-%s: se esperaba un operador binario"

#~ msgid "%s[%s: bad subscript"
#~ msgstr "%s[%s: subíndice erróneo"

#~ msgid "[%s: bad subscript"
#~ msgstr "[%s: subíndice erróneo"

# Yo pondría "hay dígitos en dos elementos diferentes de argv". sv
# De acuerdo. cfuga
#~ msgid "digits occur in two different argv-elements.\n"
#~ msgstr "hay dígitos en dos elementos diferentes de argv.\n"

#~ msgid "option %c\n"
#~ msgstr "opción %c\n"

#~ msgid "option a\n"
#~ msgstr "opción a\n"

#~ msgid "option b\n"
#~ msgstr "opción b\n"

#~ msgid "option c with value `%s'\n"
#~ msgstr "opción c con el valor `%s'\n"

#~ msgid "?? sh_getopt returned character code 0%o ??\n"
#~ msgstr "?? sh_getopt devolvió el código de carácter 0%o ??\n"

#~ msgid "non-option ARGV-elements: "
#~ msgstr "elementos de ARGV que no son opciones: "

#~ msgid "%s: Unknown flag %s.\n"
#~ msgstr "%s: Indicador desconocido %s.\n"

#~ msgid "Unknown directive `%s'"
#~ msgstr "Directiva desconocida `%s'"

#~ msgid "%s requires an argument"
#~ msgstr "%s requiere un argumento"

#~ msgid "%s must be inside of a $BUILTIN block"
#~ msgstr "%s debe estar dentro de un bloque $BUILTIN"

#~ msgid "%s found before $END"
#~ msgstr "%s encontrado antes de $END"

#~ msgid "%s already has a function (%s)"
#~ msgstr "%s ya tiene una función (%s)"

#~ msgid "%s already had a docname (%s)"
#~ msgstr "%s ya tiene un nombre de documento (%s)"

#~ msgid "%s already has short documentation (%s)"
#~ msgstr "% ya tiene documentación corta (%s)"

# Si traducimos con la gramática española, probablemente sería:
# ...una definición %s". sv
# De acuerdo. cfuga
#~ msgid "%s already has a %s definition"
#~ msgstr "%s ya tiene una definición %s"

#~ msgid "mkbuiltins: Out of virtual memory!\n"
#~ msgstr "mkbuiltins: ¡Memoria agotada!\n"

#~ msgid "read [-r] [-p prompt] [-a array] [-e] [name ...]"
#~ msgstr "read [-r] [-p prompt] [-a matriz] [-e] [nombre ...]"

#~ msgid ". filename"
#~ msgstr ". fichero"

#~ msgid "%[DIGITS | WORD] [&]"
#~ msgstr "%[DÍGITOS | PALABRAS] [&]"

#~ msgid "variables - Some variable names and meanings"
#~ msgstr "variables - Algunos nombres de variables y sus significados"

#~ msgid "`alias' with no arguments or with the -p option prints the list"
#~ msgstr "`alias' sin argumentos o con la opción -p muestra la lista"

#~ msgid "of aliases in the form alias NAME=VALUE on standard output."
#~ msgstr "de aliases en la forma alias NOMBRE=VALOR por la entrada estándar."

# Más en español sería: se define un alias por cada NOMBRE cuyo VALOR se da. sv
# De acuerdo. cfuga
#~ msgid "Otherwise, an alias is defined for each NAME whose VALUE is given."
#~ msgstr ""
#~ "De otra manera, se define un alias por cada NOMBRE cuyo VALOR se da."

#~ msgid "A trailing space in VALUE causes the next word to be checked for"
#~ msgstr ""
#~ "Un espacio final en VALOR causa que la siguiente palabra sea revisada para"

# Lo mismo de antes: el alias es expandido -> el alias se expande. sv
# De acuerdo. cfuga
#~ msgid "alias substitution when the alias is expanded.  Alias returns"
#~ msgstr "la sustitución del alias cuando el alias se expande. Alias devuelve"

# no alias -> ningún alias. sv
# De acuerdo. cfuga
#~ msgid "true unless a NAME is given for which no alias has been defined."
#~ msgstr ""
#~ "verdadero a menos que para un NOMBRE dado no se haya definido ningún "
#~ "alias."

#~ msgid "then remove all alias definitions."
#~ msgstr "entonces borra todas las definiciones de alias."

#~ msgid "Bind a key sequence to a Readline function, or to a macro.  The"
#~ msgstr ""
#~ "Asigna una secuencia de teclas a una función Readline, o a una macro. La"

#~ msgid "syntax is equivalent to that found in ~/.inputrc, but must be"
#~ msgstr ""
#~ "sintaxis es equivalente a la encontrada en ~/.inputrc, pero debe ser"

#~ msgid ""
#~ "passed as a single argument: bind '\"\\C-x\\C-r\": re-read-init-file'."
#~ msgstr ""
#~ "pasada como un solo argumento: bind '\"\\C-x\\C-r\": re-read-init-file'."

#~ msgid "Arguments we accept:"
#~ msgstr "Argumentos que se aceptan:"

#~ msgid ""
#~ "  -m  keymap         Use `keymap' as the keymap for the duration of this"
#~ msgstr ""
#~ "  -m  mapa_teclas    Usa `mapa_teclas' como el mapa de teclas durante esta"

#~ msgid "                     command.  Acceptable keymap names are emacs,"
#~ msgstr ""
#~ "                     orden.  Los nombres de mapas de teclas aceptables son"

#~ msgid ""
#~ "                     emacs-standard, emacs-meta, emacs-ctlx, vi, vi-move,"
#~ msgstr ""
#~ "                     emacs, emacs-standard, emacs-meta, emacs-ctlx, vi,"

#~ msgid "                     vi-command, and vi-insert."
#~ msgstr "                     vi-move, vi-command y vi-insert."

#~ msgid "  -l                 List names of functions."
#~ msgstr "  -l                 Muestra los nombres de las funciones."

#~ msgid "  -P                 List function names and bindings."
#~ msgstr ""
#~ "  -P                 Muestra los nombres de funciones y asignaciones."

#~ msgid ""
#~ "  -p                 List functions and bindings in a form that can be"
#~ msgstr ""
#~ "  -p                 Muestra las funciones y asignaciones en un formato "
#~ "que"

#~ msgid "                     reused as input."
#~ msgstr "                     puede reusarse como entrada."

#~ msgid "  -r  keyseq         Remove the binding for KEYSEQ."
#~ msgstr "  -r  sec_teclas     Borra la asignación para SEC_TECLAS"

# lee 'la'... em+
#~ msgid "  -f  filename       Read key bindings from FILENAME."
#~ msgstr "  -f  fichero        Lee la asignación de teclas de FICHERO."

#~ msgid ""
#~ "  -q  function-name  Query about which keys invoke the named function."
#~ msgstr ""
#~ "  -q  nombre-función Pregunta sobre qué teclas invocan la función "
#~ "nombrada."

#~ msgid "  -V                 List variable names and values"
#~ msgstr "  -V                 Muestra los nombres de variables y valores"

#~ msgid ""
#~ "  -v                 List variable names and values in a form that can"
#~ msgstr ""
#~ "  -v                 Muestra los nombres de variables y valores de una "
#~ "forma que"

#~ msgid "                     be reused as input."
#~ msgstr "                     puede reusarse como entrada."

#~ msgid ""
#~ "  -S                 List key sequences that invoke macros and their "
#~ "values"
#~ msgstr ""
#~ "  -S                 Muestra las secuencias de teclas que invocan macros "
#~ "y sus\n"
#~ "                     valores"

#~ msgid ""
#~ "  -s                 List key sequences that invoke macros and their "
#~ "values in"
#~ msgstr ""
#~ "  -s                 Muestra las secuencias de teclas que invocan macros "
#~ "y sus"

#~ msgid "                     a form that can be reused as input."
#~ msgstr ""
#~ "                     valores en una forma que puede reusarse como entrada."

#~ msgid "break N levels."
#~ msgstr "sale N niveles."

#~ msgid "If N is specified, resume at the N-th enclosing loop."
#~ msgstr "Si se especifica N, retoma en el N-ésimo ciclo."

#~ msgid "Run a shell builtin.  This is useful when you wish to rename a"
#~ msgstr "Ejecuta un shell interno. Esto es útil cuando desea renombrar un"

#~ msgid "shell builtin to be a function, but need the functionality of the"
#~ msgstr ""
#~ "shell interno para que sea una función, pero necesita la funcionalidad"

#~ msgid "builtin within the function itself."
#~ msgstr "interna dentro de la misma función."

#~ msgid "Change the current directory to DIR.  The variable $HOME is the"
#~ msgstr "Cambia el directorio actual a DIR. La variable $HOME es el DIR"

#~ msgid "default DIR.  The variable $CDPATH defines the search path for"
#~ msgstr "por omisión. La variable $CDPATH define la ruta de búsqueda para"

#~ msgid "the directory containing DIR.  Alternative directory names in CDPATH"
#~ msgstr ""
#~ "el directorio que contiene DIR. Los nombres alternativos de directorio en"

#~ msgid "are separated by a colon (:).  A null directory name is the same as"
#~ msgstr ""
#~ "CDPATH son separados por dos puntos (:). Un nombre de directorio nulo es"

# Slash lo venimos traduciendo por barra inclinada , y backslash
# por barra invertida em++
#~ msgid "the current directory, i.e. `.'.  If DIR begins with a slash (/),"
#~ msgstr ""
#~ "igual al directorio actual, p.e. `.'. Si DIR comienza con una barra "
#~ "inclinada"

#~ msgid "then $CDPATH is not used.  If the directory is not found, and the"
#~ msgstr ""
#~ "(/), entonces $CDPATH no se usa. Si el directorio no se encuentra, y"

#~ msgid "shell option `cdable_vars' is set, then try the word as a variable"
#~ msgstr ""
#~ "la opción de shell `cdable_vars' está activa, entonces intenta la palabra"

#~ msgid "name.  If that variable has a value, then cd to the value of that"
#~ msgstr ""
#~ "como nombre de variable. Si esa variable tiene un valor, entonces se "
#~ "cambia al"

#~ msgid ""
#~ "variable.  The -P option says to use the physical directory structure"
#~ msgstr ""
#~ "valor de esa variable. La opción -P indica el uso de la estructura física"

#~ msgid ""
#~ "instead of following symbolic links; the -L option forces symbolic links"
#~ msgstr "del directorio en lugar de seguir enlaces simbólicos; la opción -L"

# forza -> fuerza? cfuga
#~ msgid "to be followed."
#~ msgstr "fuerza que los vínculos simbólicos sean seguidos."

#~ msgid "Print the current working directory.  With the -P option, pwd prints"
#~ msgstr ""
#~ "Imprime el directorio actual de trabajo. Con la opción -P, pwd imprime"

#~ msgid "the physical directory, without any symbolic links; the -L option"
#~ msgstr "el directorio físico, sin ningún enlace simbólico; la opción -L"

#~ msgid "makes pwd follow symbolic links."
#~ msgstr "hace que pwd siga los enlaces simbólicos."

#~ msgid ""
#~ "Runs COMMAND with ARGS ignoring shell functions.  If you have a shell"
#~ msgstr "Ejecuta ORDEN con ARGUMENTOS ignorando las funciones del shell. Si"

#~ msgid "function called `ls', and you wish to call the command `ls', you can"
#~ msgstr ""
#~ "tiene una función de shell llamada `ls', y desea llamar a la orden `ls',"

#~ msgid ""
#~ "say \"command ls\".  If the -p option is given, a default value is used"
#~ msgstr ""
#~ "se puede decir \"command ls\". Si se especifica la opción -p, se usa un "
#~ "valor"

# es usado -> se usa. sv
# De acuerdo. La corrección incluye también la línea anterior. cfuga
#~ msgid ""
#~ "for PATH that is guaranteed to find all of the standard utilities.  If"
#~ msgstr ""
#~ "por omisión para PATH que garantiza encontrar todas las herramientas "
#~ "estándar."

# es impresa -> se muestra una cadena em+
# "Si se da la opcón -V o -v,..." sv
# De acuerdo. cfuga
#~ msgid ""
#~ "the -V or -v option is given, a string is printed describing COMMAND."
#~ msgstr ""
#~ "Si se da la opción -V o -v, se muestra una cadena describiendo la ORDEN."

#~ msgid "The -V option produces a more verbose description."
#~ msgstr "La opción -V produce una descripción más completa."

#~ msgid "Declare variables and/or give them attributes.  If no NAMEs are"
#~ msgstr ""
#~ "Declara variables y/o les da atributos. Si no se proporcionan NOMBREs,"

#~ msgid "given, then display the values of variables instead.  The -p option"
#~ msgstr "entonces muestra los valores de las variables. La opción -p"

#~ msgid "will display the attributes and values of each NAME."
#~ msgstr "mostrará los atributos y valores de cada NOMBRE."

#~ msgid "The flags are:"
#~ msgstr "Los indicadores son:"

#~ msgid "  -a\tto make NAMEs arrays (if supported)"
#~ msgstr "  -a\thacer los NOMBREs matrices (si está soportado)"

#~ msgid "  -f\tto select from among function names only"
#~ msgstr "  -f\tseleccionar sólo entre los nombres de funciones"

#~ msgid "  -F\tto display function names without definitions"
#~ msgstr "  -F\tmostrar los nombres de funciones sin definiciones"

#~ msgid "  -r\tto make NAMEs readonly"
#~ msgstr "  -r\thacer los NOMBREs de sólo lectura"

#~ msgid "  -x\tto make NAMEs export"
#~ msgstr "  -x\thacer los NOMBREs exportables"

#~ msgid "  -i\tto make NAMEs have the `integer' attribute set"
#~ msgstr "  -i\thacer que los NOMBREs tengan el atributo `entero' activado"

#~ msgid "Variables with the integer attribute have arithmetic evaluation (see"
#~ msgstr "Las variables con el atributo entero tienen evaluación aritmética"

#~ msgid "`let') done when the variable is assigned to."
#~ msgstr "(ver `let') cuando la variable es asignada."

#~ msgid "When displaying values of variables, -f displays a function's name"
#~ msgstr "Cuando se muestran valores de variables, -f muestra el nombre y"

#~ msgid "and definition.  The -F option restricts the display to function"
#~ msgstr "la definición de la función. La opción -F evita que se muestre"

#~ msgid "name only."
#~ msgstr "solamente el nombre de la función."

# apaga -> desactiva em+
#~ msgid ""
#~ "Using `+' instead of `-' turns off the given attribute instead.  When"
#~ msgstr ""
#~ "Usar `+' en lugar de `-' desactiva el atributo dado. Cuando es usado"

#~ msgid "used in a function, makes NAMEs local, as with the `local' command."
#~ msgstr ""
#~ "en una función, hace los NOMBREs locales, como con la orden `local'."

# y le da -> y le asigna em+
#~ msgid "Create a local variable called NAME, and give it VALUE.  LOCAL"
#~ msgstr "Crea una variable local llamada NOMBRE, y le asigna un VALOR. LOCAL"

# tenga un alcance visible -> sea visible solo para la función y sus los hijos em+
#~ msgid "have a visible scope restricted to that function and its children."
#~ msgstr "tenga visible sólo para la función y sus hijos."

#~ msgid "Output the ARGs.  If -n is specified, the trailing newline is"
#~ msgstr "Muestra los ARGumentos. Si -n es especificado, el carácter final de"

#~ msgid "suppressed.  If the -e option is given, interpretation of the"
#~ msgstr ""
#~ "fin de línea es eliminado. Si se especifica la opción -e, se activa la"

#~ msgid "following backslash-escaped characters is turned on:"
#~ msgstr "interpretación de estos caracteres de escape con barras invertidas:"

#~ msgid "\t\\a\talert (bell)"
#~ msgstr "\t\\a\talerta (campana)"

#~ msgid "\t\\b\tbackspace"
#~ msgstr "\t\\b\tespacio hacia atrás"

#~ msgid "\t\\c\tsuppress trailing newline"
#~ msgstr "\t\\c\tsuprime el carácter de fin de línea restante"

#~ msgid "\t\\E\tescape character"
#~ msgstr "\t\\E\tcarácter de escape"

#~ msgid "\t\\f\tform feed"
#~ msgstr "\t\\f\talimentación de papel"

#~ msgid "\t\\n\tnew line"
#~ msgstr "\t\\n\tnueva línea"

#~ msgid "\t\\r\tcarriage return"
#~ msgstr "\t\\r\tretorno de carro"

#~ msgid "\t\\t\thorizontal tab"
#~ msgstr "\t\\t\ttabulador horizontal"

#~ msgid "\t\\v\tvertical tab"
#~ msgstr "\t\\v\ttabulador vertical"

#~ msgid "\t\\\\\tbackslash"
#~ msgstr "\t\\\\\tbarra invertida"

#~ msgid "\t\\num\tthe character whose ASCII code is NUM (octal)."
#~ msgstr "\t\\num\tel carácter cuyo código ASCII es NÚM (octal)."

#~ msgid ""
#~ "You can explicitly turn off the interpretation of the above characters"
#~ msgstr "Puede desactivar explícitamente la interpretación de los siguientes"

#~ msgid "with the -E option."
#~ msgstr "caracteres con la opción -E ."

#~ msgid "Enable and disable builtin shell commands.  This allows"
#~ msgstr "Activa y desactiva las órdenes internas del shell. Esto permite"

#~ msgid "you to use a disk command which has the same name as a shell"
#~ msgstr ""
#~ "que use una orden del sistema que tenga el mismo nombre de una orden"

#~ msgid "builtin.  If -n is used, the NAMEs become disabled; otherwise"
#~ msgstr "interna.  Si se usa -n , los NOMBREs se desactivan; de otra forma"

#~ msgid "NAMEs are enabled.  For example, to use the `test' found on your"
#~ msgstr "se activan los NOMBREs.  Por ejemplo, para usar `test' de la"

#~ msgid "path instead of the shell builtin version, type `enable -n test'."
#~ msgstr ""
#~ "ruta de acceso en lugar de la versión interna del shell, teclee\n"
#~ "`enable -n test'."

# se puede usar. sv
#~ msgid "On systems supporting dynamic loading, the -f option may be used"
#~ msgstr "En sistemas que soportan carga dinámica, la opción -f se puede usar"

#~ msgid "to load new builtins from the shared object FILENAME.  The -d"
#~ msgstr "para cargar nuevas órdenes internas del objeto FICHERO compartido."

#~ msgid "option will delete a builtin previously loaded with -f.  If no"
#~ msgstr "La opción -d borrará una orden interna cargada con -f. Si no"

#~ msgid "non-option names are given, or the -p option is supplied, a list"
#~ msgstr ""
#~ "se especifica ninguna opción, o se especifica la opción -p, se muestra "
#~ "una lista"

# Se muestra una lista de órdenes internas. sv
# Hay muchos más mensajes que están en "pasiva" que quedarían mejor en
# forma "reflexiva". No comento más y te dejo que los mires despacio.
# Gracias por la observación. cfuga
#~ msgid "of builtins is printed.  The -a option means to print every builtin"
#~ msgstr ""
#~ "de órdenes internas. La opción -a implica mostrar cada orden interno"

#~ msgid "with an indication of whether or not it is enabled.  The -s option"
#~ msgstr "con una indicación de si está activa o no. La opción -s impide"

#~ msgid "restricts the output to the Posix.2 `special' builtins.  The -n"
#~ msgstr "la salida a las órdenes internas `especiales' Posix.2. La opción -n"

#~ msgid "option displays a list of all disabled builtins."
#~ msgstr "muestra una lista de todos las órdenes internas desactivadas."

#~ msgid "Getopts is used by shell procedures to parse positional parameters."
#~ msgstr ""
#~ "Los procedimientos de shell usan getopts para decodificar parámetros\n"
#~ "de posición."

# "a ser reconocidas" no está en español.
# Yo pondría "las letras de opción que se reconocen". sv
# De acuerdo. cfuga
#~ msgid "OPTSTRING contains the option letters to be recognized; if a letter"
#~ msgstr ""
#~ "La CADENA_OPCIONES contiene las letras de opción que se reconocen; si una"

#~ msgid "is followed by a colon, the option is expected to have an argument,"
#~ msgstr ""
#~ "letra es seguida de dos puntos, se espera que la opción tenga un "
#~ "argumento,"

#~ msgid "which should be separated from it by white space."
#~ msgstr "que debe estar separado por espacios."

#~ msgid "Each time it is invoked, getopts will place the next option in the"
#~ msgstr "Cada vez que se llama, getopts colocará la siguiente opción en"

#~ msgid "shell variable $name, initializing name if it does not exist, and"
#~ msgstr ""
#~ "la variable de shell $nombre, creando nombre si no existe, y el índice"

#~ msgid "the index of the next argument to be processed into the shell"
#~ msgstr ""
#~ "del siguiente argumento para procesarse dentro de la variable del shell"

#~ msgid "variable OPTIND.  OPTIND is initialized to 1 each time the shell or"
#~ msgstr "OPTIND. OPTIND inicia con 1 cada vez que el shell o un guión de"

#~ msgid "a shell script is invoked.  When an option requires an argument,"
#~ msgstr "shell es llamado. Cuando una opción requiere un argumento,"

#~ msgid "getopts places that argument into the shell variable OPTARG."
#~ msgstr "getopts coloca ese argumento en la variable de shell OPTARG."

# en una de dos formas -> en una de las dos formas siguientes em+
#~ msgid "getopts reports errors in one of two ways.  If the first character"
#~ msgstr ""
#~ "getopts comunica errores en una de las dos formas siguientes. Si el "
#~ "primer carácter"

#~ msgid "of OPTSTRING is a colon, getopts uses silent error reporting.  In"
#~ msgstr ""
#~ "de OPTSTRING es dos puntos, getopts usa el aviso de error silencioso."

#~ msgid "this mode, no error messages are printed.  If an illegal option is"
#~ msgstr ""
#~ "En este modo, no se muestran mensajes de error.  Si se encuentra una "
#~ "opción"

#~ msgid "seen, getopts places the option character found into OPTARG.  If a"
#~ msgstr "ilegal, getopts coloca el carácter de opción encontrado en OPTARG."

#~ msgid "required argument is not found, getopts places a ':' into NAME and"
#~ msgstr ""
#~ "Si un argumento necesario no se encuentra, getopts coloca ':' en NOMBRE"

#~ msgid "sets OPTARG to the option character found.  If getopts is not in"
#~ msgstr "y establece a OPTARG con el carácter de opción encontrado.  Si"

#~ msgid "silent mode, and an illegal option is seen, getopts places '?' into"
#~ msgstr ""
#~ "getopts no está en modo silencioso, y se encuentra una opción ilegal,"

#~ msgid "NAME and unsets OPTARG.  If a required option is not found, a '?'"
#~ msgstr "getopts coloca '?' en NOMBRE y borra OPTARG.  Si no se encuentra"

#~ msgid "is placed in NAME, OPTARG is unset, and a diagnostic message is"
#~ msgstr "una opción necesaria, se coloca un '?' en NOMBRE, se borra OPTARG,"

#~ msgid "If the shell variable OPTERR has the value 0, getopts disables the"
#~ msgstr ""
#~ "Si la variable de shell OPTERR tiene el valor 0, getopts deshabilita"

#~ msgid "printing of error messages, even if the first character of"
#~ msgstr "la notificación de mensajes de error, aún si el primer carácter de"

#~ msgid "OPTSTRING is not a colon.  OPTERR has the value 1 by default."
#~ msgstr "OPTSTRING no es ':'.  OPTERR tiene el valor de 1 por omisión."

#~ msgid "Getopts normally parses the positional parameters ($0 - $9), but if"
#~ msgstr ""
#~ "Getopts normalmente compara los parámetros de posición ($0 - $9), pero"

# dar argumentos -> especificar em+
#~ msgid "more arguments are given, they are parsed instead."
#~ msgstr ""
#~ "si se especifican más argumentos, se comparan en lugar de los primeros."

#~ msgid "Exec FILE, replacing this shell with the specified program."
#~ msgstr ""
#~ "Ejecuta el FICHERO, reemplazando este shell con el programa especificado."

#~ msgid "If FILE is not specified, the redirections take effect in this"
#~ msgstr ""
#~ "Si no se especifica un FICHERO, las redirecciones toman efecto en este"

#~ msgid "shell.  If the first argument is `-l', then place a dash in the"
#~ msgstr "shell.  Si el primer argumento es `-l', entonces coloca un guión en"

#~ msgid "zeroth arg passed to FILE, as login does.  If the `-c' option"
#~ msgstr ""
#~ "el argumento 0 pasado al FICHERO, como lo hace login. Si se especifica la "
#~ "opción"

#~ msgid "is supplied, FILE is executed with a null environment.  The `-a'"
#~ msgstr "`-c', el FICHERO se ejecuta en un entorno nulo. La opción `-a'"

#~ msgid "option means to make set argv[0] of the executed process to NAME."
#~ msgstr "hace que cambie el argv[0] del proceso ejecutado a NOMBRE."

#~ msgid "If the file cannot be executed and the shell is not interactive,"
#~ msgstr "Si el fichero no se puede ejecutar y el shell no es interactivo,"

#~ msgid "then the shell exits, unless the variable \"no_exit_on_failed_exec\""
#~ msgstr "entonces el shell termina, a menos que la variable"

#~ msgid "is set."
#~ msgstr "\"no_exit_on_failed_exec\" esté activada."

#~ msgid "is that of the last command executed."
#~ msgstr "es el del último comando ejecutado."

#~ msgid ""
#~ "FIRST and LAST can be numbers specifying the range, or FIRST can be a"
#~ msgstr ""
#~ "PRIMERO y ÚLTIMO pueden ser números especificando el rango, o PRIMERO"

#~ msgid "string, which means the most recent command beginning with that"
#~ msgstr "puede ser una cadena, que representa el comando más reciente que"

#~ msgid "string."
#~ msgstr "comience con dicha cadena."

#~ msgid ""
#~ "   -e ENAME selects which editor to use.  Default is FCEDIT, then EDITOR,"
#~ msgstr ""
#~ "   -e NOMBRE_E escoge qué editor emplear.  Por omisión es FCEDIT, después"

#~ msgid ""
#~ "      then the editor which corresponds to the current readline editing"
#~ msgstr "      EDITOR, después el editor que corresponde a la edición actual"

#~ msgid "      mode, then vi."
#~ msgstr "      del modo de línea de comando, y finalmente vi."

#~ msgid "   -l means list lines instead of editing."
#~ msgstr "   -l significa mostrar líneas en lugar de editarlas."

#~ msgid "   -n means no line numbers listed."
#~ msgstr "   -n significa que no sean mostrados los números de línea."

#~ msgid ""
#~ "   -r means reverse the order of the lines (making it newest listed "
#~ "first)."
#~ msgstr ""
#~ "   -r significa invertir el orden de las líneas (líneas nuevas primero)."

#~ msgid "With the `fc -s [pat=rep ...] [command]' format, the command is"
#~ msgstr "Con el formato `fc -s [pat=rep ...] [orden]', la orden es"

#~ msgid "re-executed after the substitution OLD=NEW is performed."
#~ msgstr ""
#~ "re-ejecutado después de que se realiza la sustitución ANTIGUA=NUEVA."

#~ msgid "A useful alias to use with this is r='fc -s', so that typing `r cc'"
#~ msgstr ""
#~ "Un alias útil para usar con esto es r='fc -s', así que al teclear `r cc'"

#~ msgid "runs the last command beginning with `cc' and typing `r' re-executes"
#~ msgstr ""
#~ "ejecuta la última orden que comenzó con `cc' y tecleando `r' re-ejecuta"

#~ msgid "JOB_SPEC is not present, the shell's notion of the current job is"
#~ msgstr ""
#~ "Si el IDTRABAJO no se encuentra, se usa la noción del shell de trabajo"

#~ msgid "used."
#~ msgstr "actual."

#~ msgid "Place JOB_SPEC in the background, as if it had been started with"
#~ msgstr ""
#~ "Ubica al IDTRABAJO en el background, como si hubiera sido iniciado con"

#~ msgid "`&'.  If JOB_SPEC is not present, the shell's notion of the current"
#~ msgstr "`&'.  Si el IDTRABAJO no se encuentra, se usa la noción del shell"

#~ msgid "job is used."
#~ msgstr "de trabajo actual."

#~ msgid "For each NAME, the full pathname of the command is determined and"
#~ msgstr "Para cada NOMBRE, se determina la ruta completa de la orden y se"

#~ msgid "remembered.  If the -p option is supplied, PATHNAME is used as the"
#~ msgstr "recuerda.  Si se especifica la opción -p, se usa la RUTA_DE_ACCESO"

#~ msgid "full pathname of NAME, and no path search is performed.  The -r"
#~ msgstr ""
#~ "como la ruta completa de NOMBRE y no se realiza la búsqueda de ruta."

#~ msgid "option causes the shell to forget all remembered locations.  If no"
#~ msgstr ""
#~ "  La opción -r hace que el shell olvide todas las ubicaciones recordadas."

#~ msgid ""
#~ "arguments are given, information about remembered commands is displayed."
#~ msgstr ""
#~ "  Si no se especifican argumentos, se muestra la información sobre las "
#~ "órdenes recordadas."

#~ msgid "Display helpful information about builtin commands.  If PATTERN is"
#~ msgstr "Muestra información de ayuda acerca de las órdenes internas.  Si se"

#~ msgid "specified, gives detailed help on all commands matching PATTERN,"
#~ msgstr ""
#~ "especifica la PLANTILLA, da ayuda detallada de todas las órdenes que"

#~ msgid "otherwise a list of the builtins is printed."
#~ msgstr ""
#~ "coinciden con la PLANTILLA, de otra forma se muestra una lista de las "
#~ "órdenes internas."

#~ msgid "Display the history list with line numbers.  Lines listed with"
#~ msgstr ""
#~ "Muestra la lista de la historia con números de línea.  Las líneas "
#~ "mostradas"

#~ msgid "with a `*' have been modified.  Argument of N says to list only"
#~ msgstr ""
#~ "con un `*' han sido modificadas.  Un argumento de N indica que solo se"

#~ msgid "the last N lines.  The -c option causes the history list to be"
#~ msgstr ""
#~ "muestren las últimas N líneas.  La opción -c hace que la lista de la "
#~ "historia"

#~ msgid ""
#~ "cleared by deleting all of the entries.  The `-w' option writes out the"
#~ msgstr ""
#~ "sea borrada eliminando todas las entradas.  La opción `-w' escribe la "
#~ "historia"

#~ msgid ""
#~ "current history to the history file;  `-r' means to read the file and"
#~ msgstr ""
#~ "actual al fichero de historia;  `-r' al contrario, lee el fichero y agrega"

#~ msgid "append the contents to the history list instead.  `-a' means"
#~ msgstr "el contenido a la lista de la historia.  `-a' agrega las"

#~ msgid "to append history lines from this session to the history file."
#~ msgstr "líneas de la historia de esta sesión al fichero de historia."

#~ msgid "Argument `-n' means to read all history lines not already read"
#~ msgstr "El argumento `-n' lee todas las líneas de historia que no han sido"

#~ msgid "from the history file and append them to the history list.  If"
#~ msgstr ""
#~ "leídas aún del fichero de historia y las agrega a la lista de historia."

#~ msgid "FILENAME is given, then that is used as the history file else"
#~ msgstr ""
#~ "  Si se especifica un FICHERO, entonces se usa como el fichero de historia"

#~ msgid "if $HISTFILE has a value, that is used, else ~/.bash_history."
#~ msgstr ""
#~ "de otra manera si $HISTFILE tiene un valor, se utiliza, de otra forma se "
#~ "usa ~/.bash_history."

#~ msgid "If the -s option is supplied, the non-option ARGs are appended to"
#~ msgstr ""
#~ "Si se especifica la opción -s, los ARGumentos que no son opciones se"

#~ msgid "the history list as a single entry.  The -p option means to perform"
#~ msgstr ""
#~ "agregan a la lista de historia como una sola entrada.  La opción -p "
#~ "realiza"

#~ msgid ""
#~ "history expansion on each ARG and display the result, without storing"
#~ msgstr ""
#~ "una expansión de historia en cada ARGumento y muestra el resultado, sin "
#~ "guardar"

#~ msgid "anything in the history list."
#~ msgstr "nada en la lista de historia."

#~ msgid "Lists the active jobs.  The -l option lists process id's in addition"
#~ msgstr ""
#~ "Muestra los trabajos activos.  La opción -l muestra los id's de los "
#~ "procesos además"

#~ msgid "to the normal information; the -p option lists process id's only."
#~ msgstr ""
#~ "de la información normal; la opción -p solamente muestra los id's de los "
#~ "procesos."

#~ msgid ""
#~ "If -n is given, only processes that have changed status since the last"
#~ msgstr ""
#~ "Si se especifica -n, solamente se muestran los procesos que han cambiado"

#~ msgid ""
#~ "notification are printed.  JOBSPEC restricts output to that job.  The"
#~ msgstr ""
#~ "de estado desde la última notificación.  IDJOB limita la salida a ese "
#~ "trabajo.  Las"

#~ msgid "-r and -s options restrict output to running and stopped jobs only,"
#~ msgstr ""
#~ "opciones -r y -s limitan la salida a mostrar sólo trabajos corriendo y "
#~ "detenidos,"

#~ msgid "respectively.  Without options, the status of all active jobs is"
#~ msgstr "respectivamente.  Sin opciones, se muestra el estado de todos los"

#~ msgid ""
#~ "printed.  If -x is given, COMMAND is run after all job specifications"
#~ msgstr ""
#~ "trabajos activos.  Si se especifica -x, la ORDEN se ejecuta después de "
#~ "que todas las especificaciones de trabajos"

#~ msgid ""
#~ "that appear in ARGS have been replaced with the process ID of that job's"
#~ msgstr "que aparecen en ARGS han sido reemplazadas por el ID de proceso del"

#~ msgid "process group leader."
#~ msgstr "líder del grupo de procesos de dicho trabajo."

#~ msgid "Removes each JOBSPEC argument from the table of active jobs."
#~ msgstr "Elimina cada argumento IDJOBS de la tabla de trabajos activos."

#~ msgid "Send the processes named by PID (or JOB) the signal SIGSPEC.  If"
#~ msgstr ""
#~ "Manda a los procesos nombrados por PID (o TRABAJO) la señal SIGSPEC.  Si"

#~ msgid ""
#~ "SIGSPEC is not present, then SIGTERM is assumed.  An argument of `-l'"
#~ msgstr ""
#~ "no se especifica SIGSPEC, entonces se asume SIGTERM.  El argumento `-l'"

#~ msgid "lists the signal names; if arguments follow `-l' they are assumed to"
#~ msgstr ""
#~ "muestra los nombres de señales; si hay argumentos después de `-l', se"

#~ msgid "be signal numbers for which names should be listed.  Kill is a shell"
#~ msgstr ""
#~ "asume que son números de señales cuyos nombres deben mostrarse.  Kill es "
#~ "una orden"

#~ msgid "builtin for two reasons: it allows job IDs to be used instead of"
#~ msgstr ""
#~ "interna de shell por dos razones:  permite que los IDs de trabajos sean "
#~ "usados en lugar de "

#~ msgid "process IDs, and, if you have reached the limit on processes that"
#~ msgstr "IDs de procesos, y, si ha alcanzado el límite de procesos que"

#~ msgid ""
#~ "you can create, you don't have to start a process to kill another one."
#~ msgstr "puede crear, no tiene que iniciar un proceso para eliminar a otro."

# "a ser evaluada" no está en español. sv
# Cierto. ¿Así está mejor? cfuga
#~ msgid "Each ARG is an arithmetic expression to be evaluated.  Evaluation"
#~ msgstr ""
#~ "Cada ARGumento es una expresión aritmética para evaluarse.  La evaluación"

# overflow -> desbordamiento o sobrepasamiento. nunca lo he visto
# traducido como sobreflujo. sv
# Corregido. cfuga
#~ msgid "is done in long integers with no check for overflow, though division"
#~ msgstr ""
#~ "se hace en enteros long sin revisar desbordamientos, aunque la división"

#~ msgid "by 0 is trapped and flagged as an error.  The following list of"
#~ msgstr "por 0 es capturada y marcada como un error.  La siguiente lista de"

# No sé si existe precedencia en español, pero me suena fatal.
# Yo pondría simplemente "prioridad". sv
# Creo que si existe, pero tu sugerencia es mejor. cfuga
#~ msgid "operators is grouped into levels of equal-precedence operators."
#~ msgstr ""
#~ "operadores está agrupada en niveles de operadores de la misma prioridad."

#~ msgid "The levels are listed in order of decreasing precedence."
#~ msgstr "Se muestran los niveles en orden de prioridad decreciente."

#~ msgid "\t-, +\t\tunary minus, plus"
#~ msgstr "\t-, +\t\tmenos unario, más"

#~ msgid "\t!, ~\t\tlogical and bitwise negation"
#~ msgstr "\t!, ~\t\tnegación lógica y basada en bits"

#~ msgid "\t*, /, %\t\tmultiplication, division, remainder"
#~ msgstr "\t*, /, %\t\tmultiplicación, división, residuo"

#~ msgid "\t+, -\t\taddition, subtraction"
#~ msgstr "\t+, -\t\tadición, sustracción"

#~ msgid "\t<<, >>\t\tleft and right bitwise shifts"
#~ msgstr "\t<<, >>\t\tdesplazamientos de bits izquierdo y derecho"

#~ msgid "\t<=, >=, <, >\tcomparison"
#~ msgstr "\t<=, >=, <, >\tcomparación"

#~ msgid "\t==, !=\t\tequality, inequality"
#~ msgstr "\t==, !=\t\tequivalencia, inequivalencia"

#~ msgid "\t&\t\tbitwise AND"
#~ msgstr "\t&\t\tAND de bits"

#~ msgid "\t^\t\tbitwise XOR"
#~ msgstr "\t^\t\tXOR de bits"

#~ msgid "\t|\t\tbitwise OR"
#~ msgstr "\t|\t\tOR de bits"

#~ msgid "\t&&\t\tlogical AND"
#~ msgstr "\t&&\t\tAND lógico"

#~ msgid "\t||\t\tlogical OR"
#~ msgstr "\t||\t\tOR lógico"

#~ msgid "\texpr ? expr : expr"
#~ msgstr "\texpr ? expr : expr"

#~ msgid "\t\t\tconditional expression"
#~ msgstr "\t\t\texpresión condicional"

#~ msgid "\t=, *=, /=, %=,"
#~ msgstr "\t=, *=, /=, %=,"

#~ msgid "\t+=, -=, <<=, >>=,"
#~ msgstr "\t+=, -=, <<=, >>=,"

#~ msgid "\t&=, ^=, |=\tassignment"
#~ msgstr "asignaciones\t&=, ^=, |="

#~ msgid "is replaced by its value (coerced to a long integer) within"
#~ msgstr "de la variable por su valor (asignado a un entero long) dentro de"

#~ msgid "an expression.  The variable need not have its integer attribute"
#~ msgstr "una expresión.  La variable no necesita tener activado su atributo"

#~ msgid "turned on to be used in an expression."
#~ msgstr "entero para que se use en una expresión."

#~ msgid "Operators are evaluated in order of precedence.  Sub-expressions in"
#~ msgstr ""
#~ "Los operadores se evalúan en orden de prioridad.  Se evalúan en primer"

#~ msgid "parentheses are evaluated first and may override the precedence"
#~ msgstr "lugar las sub-expresiones en paréntesis y pueden sobrepasar las"

#~ msgid "rules above."
#~ msgstr "reglas de prioridad anteriores."

#~ msgid "If the last ARG evaluates to 0, let returns 1; 0 is returned"
#~ msgstr "Si el último ARGumento evalua a 0, let regresa 1; de otra manera"

#~ msgid "otherwise."
#~ msgstr "se regresa 0."

#~ msgid "One line is read from the standard input, and the first word is"
#~ msgstr "Una línea se lee de la entrada estándar, y la primera palabra se"

#~ msgid ""
#~ "assigned to the first NAME, the second word to the second NAME, and so"
#~ msgstr ""
#~ "asigna al primer NOMBRE, la segunda palabra al segundo NOMBRE, y así"

#~ msgid ""
#~ "on, with leftover words assigned to the last NAME.  Only the characters"
#~ msgstr ""
#~ "con las palabras restantes asignadas al último NOMBRE.  Solo los "
#~ "caracteres"

#~ msgid "found in $IFS are recognized as word delimiters.  The return code is"
#~ msgstr ""
#~ "que se encuentran en $IFS se reconocen como delimitadores de palabras.  El"

#~ msgid ""
#~ "zero, unless end-of-file is encountered.  If no NAMEs are supplied, the"
#~ msgstr ""
#~ "código de retorno es cero, a menos que se encuentre un fin-de-fichero.  "
#~ "Si no"

#~ msgid ""
#~ "line read is stored in the REPLY variable.  If the -r option is given,"
#~ msgstr ""
#~ "se establece ningún NOMBRE, la línea leída se guarda en la variable "
#~ "REPLY.  Si"

#~ msgid "this signifies `raw' input, and backslash escaping is disabled.  If"
#~ msgstr ""
#~ "se proporciona la opción -r, esto significa entrada `textual', y se "
#~ "desactiva"

#~ msgid "the `-p' option is supplied, the string supplied as an argument is"
#~ msgstr "el escape de la barra invertida.  Si se proporciona la opción `-p',"

#~ msgid ""
#~ "output without a trailing newline before attempting to read.  If -a is"
#~ msgstr ""
#~ "se muestra la cadena proporcionada como argumento sin un fín de línea "
#~ "terminal antes de intentar leerla."

#~ msgid ""
#~ "supplied, the words read are assigned to sequential indices of ARRAY,"
#~ msgstr ""
#~ "Si se da -a, se asignan las palabras leídas a índices secuenciales de "
#~ "MATRIZ"

#~ msgid "starting at zero.  If -e is supplied and the shell is interactive,"
#~ msgstr "iniciando en cero.  Si se da -e y el shell es interactivo,"

#~ msgid "readline is used to obtain the line."
#~ msgstr "se usa readline para obtener la línea."

#~ msgid "is omitted, the return status is that of the last command."
#~ msgstr "se omite N, se utiliza el código de estado de la última orden."

#~ msgid "    -a  Mark variables which are modified or created for export."
#~ msgstr ""
#~ "    -a  Marca las variables que se modifican o crean para exportación."

#~ msgid "    -b  Notify of job termination immediately."
#~ msgstr "    -b  Notifica el término de trabajos inmediatamente."

#~ msgid "    -e  Exit immediately if a command exits with a non-zero status."
#~ msgstr ""
#~ "    -e  Termina inmediatamente si una orden termina con un estado "
#~ "diferente a cero."

#~ msgid "    -f  Disable file name generation (globbing)."
#~ msgstr ""
#~ "    -f  Desactiva la generación de nombres de ficheros (englobamiento)."

#~ msgid "    -h  Remember the location of commands as they are looked up."
#~ msgstr ""
#~ "    -h  Recuerda la ubicación de las órdenes como fueron localizadas."

#~ msgid ""
#~ "    -i  Force the shell to be an \"interactive\" one.  Interactive shells"
#~ msgstr ""
#~ "    -i  Fuerza que el shell sea \"interactive\".  Los shells interactivos"

#~ msgid "        always read `~/.bashrc' on startup."
#~ msgstr "        siempre leen `~/.bashrc' al inicio."

#~ msgid "    -k  All assignment arguments are placed in the environment for a"
#~ msgstr ""
#~ "    -k  Todos los argumentos de asignación se ubican en el ambiente para "
#~ "una"

#~ msgid "        command, not just those that precede the command name."
#~ msgstr ""
#~ "        orden, no solamente aquéllos que preceden al nombre de la orden."

#~ msgid "    -m  Job control is enabled."
#~ msgstr "    -m  Se activa el control de trabajos."

#~ msgid "    -n  Read commands but do not execute them."
#~ msgstr "    -n  Lee órdenes pero no las ejecuta."

#~ msgid "    -o option-name"
#~ msgstr "    -o nombre-opción"

#~ msgid "        Set the variable corresponding to option-name:"
#~ msgstr "        Establece la variable correspondiente a nombre-opción:"

#~ msgid "            allexport    same as -a"
#~ msgstr "            allexport    igual que -a"

#~ msgid "            braceexpand  same as -B"
#~ msgstr "            braceexpand  igual que -B"

#~ msgid "            emacs        use an emacs-style line editing interface"
#~ msgstr ""
#~ "            emacs        usa una interfaz de edición de línea estilo emacs"

#~ msgid "            errexit      same as -e"
#~ msgstr "            errexit      igual que -e"

#~ msgid "            hashall      same as -h"
#~ msgstr "            hashall      igual que -h"

#~ msgid "            histexpand   same as -H"
#~ msgstr "            histexpand   igual que -H"

#~ msgid "            ignoreeof    the shell will not exit upon reading EOF"
#~ msgstr "            ignoreeof    el shell no terminará después de leer EOF"

#~ msgid "            interactive-comments"
#~ msgstr "            interactive-comments"

#~ msgid ""
#~ "                         allow comments to appear in interactive commands"
#~ msgstr ""
#~ "                         permite que los comentarios se muestren en "
#~ "órdenes interactivas"

#~ msgid "            keyword      same as -k"
#~ msgstr "            keyword      igual que -k"

#~ msgid "            monitor      same as -m"
#~ msgstr "            monitor      igual que -m"

#~ msgid "            noclobber    same as -C"
#~ msgstr "            noclobber    igual que -C"

#~ msgid "            noexec       same as -n"
#~ msgstr "            noexec       igual que -n"

#~ msgid "            noglob       same as -f"
#~ msgstr "            noglob       igual que -f"

#~ msgid "            notify       save as -b"
#~ msgstr "            notify       igual que -b"

#~ msgid "            nounset      same as -u"
#~ msgstr "            nounset      igual que -u"

#~ msgid "            onecmd       same as -t"
#~ msgstr "            onecmd       same as -t"

#~ msgid "            physical     same as -P"
#~ msgstr "            physical     same as -P"

#~ msgid ""
#~ "            posix        change the behavior of bash where the default"
#~ msgstr ""
#~ "            posix        cambia la conducta de bash donde por omisión"

#~ msgid ""
#~ "                         operation differs from the 1003.2 standard to"
#~ msgstr ""
#~ "                         la operación difiere del estándar 1003.2 para"

#~ msgid "                         match the standard"
#~ msgstr "                         cumplir el estándar"

#~ msgid "            privileged   same as -p"
#~ msgstr "            privileged   igual que -p"

#~ msgid "            verbose      same as -v"
#~ msgstr "            verbose      igual que -v"

#~ msgid "            vi           use a vi-style line editing interface"
#~ msgstr ""
#~ "            vi           usa una interfaz de edición de línea estilo vi"

#~ msgid "            xtrace       same as -x"
#~ msgstr "            xtrace       igual que -x"

#~ msgid ""
#~ "    -p  Turned on whenever the real and effective user ids do not match."
#~ msgstr ""
#~ "    -p  Se activa cada vez que los ids real y efectivo no coinciden."

# FIXME: $ENV es variable, no fichero. cfuga
#~ msgid "        Disables processing of the $ENV file and importing of shell"
#~ msgstr ""
#~ "        Desactiva el procesamiento del fichero $ENV y la importación de "
#~ "funciones"

#~ msgid ""
#~ "        functions.  Turning this option off causes the effective uid and"
#~ msgstr "        de shell.  Desactivar esta opción causa que el uid y el gid"

#~ msgid "        gid to be set to the real uid and gid."
#~ msgstr "        efectivos sean iguales al uid y al gid reales."

#~ msgid "    -t  Exit after reading and executing one command."
#~ msgstr "    -t  Terminar después de leer y ejecutar una orden."

#~ msgid "    -u  Treat unset variables as an error when substituting."
#~ msgstr ""
#~ "    -u  Tratar las variables no establecidas como un error cuando se hace "
#~ "sustitución."

#~ msgid "    -v  Print shell input lines as they are read."
#~ msgstr "    -v  Muestra las líneas de entrada del shell mientras se leen."

#~ msgid "    -x  Print commands and their arguments as they are executed."
#~ msgstr "    -x  Muestra las órdenes y sus argumentos mientras se ejecutan."

#~ msgid "    -B  the shell will perform brace expansion"
#~ msgstr "    -B  el shell hará expansión de llaves"

#~ msgid "    -H  Enable ! style history substitution.  This flag is on"
#~ msgstr ""
#~ "    -H  Activa el estilo ! de sustitución de la historia.  Este indicador"

#~ msgid "        by default."
#~ msgstr "        está activado por omisión."

#~ msgid "    -C  If set, disallow existing regular files to be overwritten"
#~ msgstr ""
#~ "    -C  Si está establecido, evita que los ficheros regulares existentes "
#~ "sean sobreescritos"

#~ msgid "        by redirection of output."
#~ msgstr "        por una redirección de salida."

#~ msgid "    -P  If set, do not follow symbolic links when executing commands"
#~ msgstr ""
#~ "    -P  Si está establecido, no se siguen los enlaces simbólicos cuando "
#~ "se ejecutan órdenes"

#~ msgid "        such as cd which change the current directory."
#~ msgstr "        como cuando cd cambia al directorio actual."

#~ msgid "Using + rather than - causes these flags to be turned off.  The"
#~ msgstr ""
#~ "Usar + en lugar de - causa que estos indicadores sean desactivados.  Los"

#~ msgid "flags can also be used upon invocation of the shell.  The current"
#~ msgstr ""
#~ "indicadores también se pueden usar durante la invocación del shell.  El "
#~ "conjunto"

#~ msgid ""
#~ "set of flags may be found in $-.  The remaining n ARGs are positional"
#~ msgstr ""
#~ "actual de indicadores se encuentra en $-.  Los ARGumentos n restantes son "
#~ "parámetros"

#~ msgid "parameters and are assigned, in order, to $1, $2, .. $n.  If no"
#~ msgstr "posicionales y se asignan, en orden, a $1, $2, .. $n.  Si no"

#~ msgid "ARGs are given, all shell variables are printed."
#~ msgstr ""
#~ "se establecen ARGumentos, se muestran todas las variables del shell."

#~ msgid "For each NAME, remove the corresponding variable or function.  Given"
#~ msgstr ""
#~ "Para cada NOMBRE, se borra la variable o función correspondiente.  Al usar"

#~ msgid "the `-v', unset will only act on variables.  Given the `-f' flag,"
#~ msgstr "`-v', unset sólo actuará en variables.  Al usar el indicador `-f',"

#~ msgid "unset will only act on functions.  With neither flag, unset first"
#~ msgstr ""
#~ "unset sólo actuará en funciones.  Sin ningún indicador, unset primero"

#~ msgid "tries to unset a variable, and if that fails, then tries to unset a"
#~ msgstr ""
#~ "intenta borrar una variable, y si eso falla, entonces intenta borrar una"

#~ msgid ""
#~ "function.  Some variables (such as PATH and IFS) cannot be unset; also"
#~ msgstr ""
#~ "función.  Algunas variables (como PATH e IFS) no se pueden borrar; vea"

#~ msgid "see readonly."
#~ msgstr "también readonly."

#~ msgid "NAMEs are marked for automatic export to the environment of"
#~ msgstr "los NOMBREs se marcan para exportación automática al ambiente de"

#~ msgid "subsequently executed commands.  If the -f option is given,"
#~ msgstr ""
#~ "las órdenes ejecutadas subsecuentemente.  Si se establece el indicador -f,"

#~ msgid "the NAMEs refer to functions.  If no NAMEs are given, or if `-p'"
#~ msgstr ""
#~ "los NOMBREs se refieren a funciones.  Si no se establecen NOMBREs, o si `-"
#~ "p'"

#~ msgid "is given, a list of all names that are exported in this shell is"
#~ msgstr ""
#~ "se establece, se muestra una lista de todos los nombres que se exportan"

#~ msgid "printed.  An argument of `-n' says to remove the export property"
#~ msgstr ""
#~ "en este shell.  Un argumento `-n' indica que se borre la propiedad de "
#~ "exportación"

#~ msgid "from subsequent NAMEs.  An argument of `--' disables further option"
#~ msgstr ""
#~ "de NOMBREs subsecuentes.  Un argumento `--' desactiva el procesamiento"

#~ msgid "processing."
#~ msgstr "posterior de opciones."

#~ msgid ""
#~ "The given NAMEs are marked readonly and the values of these NAMEs may"
#~ msgstr ""
#~ "Los NOMBREs dados se marcan como sólo-lectura y los valores de esos "
#~ "NOMBREs"

#~ msgid "not be changed by subsequent assignment.  If the -f option is given,"
#~ msgstr ""
#~ "no se pueden cambiar por asignaciones posteriores.  Si se establece el "
#~ "indicador -f,"

#~ msgid "then functions corresponding to the NAMEs are so marked.  If no"
#~ msgstr ""
#~ "entonces también se marcan las funciones correspondientes a los NOMBREs.  "
#~ "Si no"

#~ msgid ""
#~ "arguments are given, or if `-p' is given, a list of all readonly names"
#~ msgstr ""
#~ "se establecen argumentos, o si se establece `-p', se muestra una lista de "
#~ "todos los nombres"

#~ msgid ""
#~ "is printed.  An argument of `-n' says to remove the readonly property"
#~ msgstr ""
#~ "de sólo-lectura.  Un argumento `-n' indica que se borre la propiedad de "
#~ "sólo-lectura"

#~ msgid "from subsequent NAMEs.  The `-a' option means to treat each NAME as"
#~ msgstr "de los NOMBREs subsecuentes.  La opción `-a' trata cada NOMBRE como"

#~ msgid "an array variable.  An argument of `--' disables further option"
#~ msgstr ""
#~ "una variable de matriz.  Un argumento de `--' desactiva opciones "
#~ "posteriores"

#~ msgid "not given, it is assumed to be 1."
#~ msgstr "establece N, se asume que es 1."

#~ msgid "Read and execute commands from FILENAME and return.  The pathnames"
#~ msgstr "Lee y ejecuta órdenes del FICHERO y regresa.  Los nombres de ruta"

#~ msgid "in $PATH are used to find the directory containing FILENAME."
#~ msgstr ""
#~ "en $PATH se utilizan para encontrar al directorio que contiene el FICHERO."

#~ msgid "Suspend the execution of this shell until it receives a SIGCONT"
#~ msgstr "Suspende la ejecución de este shell hasta que recive una señal"

#~ msgid "signal.  The `-f' if specified says not to complain about this"
#~ msgstr "SIGCONT.  Si se especifica `-f' indica que no se queje si"

#~ msgid "being a login shell if it is; just suspend anyway."
#~ msgstr "es un shell de login; y solo suspender de cualquier forma."

#~ msgid "Exits with a status of 0 (trueness) or 1 (falseness) depending on"
#~ msgstr "Termina con un estado de 0 (verdad) ó 1 (falsedad) dependiendo de"

#~ msgid "the evaluation of EXPR.  Expressions may be unary or binary.  Unary"
#~ msgstr ""
#~ "la evaluación de EXPR.  Las expresiones pueden ser unarias o binarias. "
#~ "Las expresiones"

#~ msgid "expressions are often used to examine the status of a file.  There"
#~ msgstr ""
#~ "unarias se utilizan con frecuencia para examinar el estado de un fichero."

#~ msgid "are string operators as well, and numeric comparison operators."
#~ msgstr ""
#~ "Hay operadores de cadenas también, y operadores de comparación numérica."

#~ msgid "File operators:"
#~ msgstr "Operadores de fichero:"

#~ msgid "    -b FILE        True if file is block special."
#~ msgstr "    -b FICHERO     Verdadero si el fichero es especial de bloques."

#~ msgid "    -c FILE        True if file is character special."
#~ msgstr ""
#~ "    -c FICHERO     Verdadero si el fichero es especial de caracteres."

#~ msgid "    -d FILE        True if file is a directory."
#~ msgstr "    -d FICHERO     Verdadero si el fichero es un directorio."

#~ msgid "    -e FILE        True if file exists."
#~ msgstr "    -e FICHERO     Verdadero si el fichero existe."

#~ msgid "    -f FILE        True if file exists and is a regular file."
#~ msgstr ""
#~ "    -f FICHERO     Verdadero si el fichero existe y es un fichero regular."

#~ msgid "    -g FILE        True if file is set-group-id."
#~ msgstr ""
#~ "    -g FICHERO     Verdadero si el fichero tiene activado el set-group-id."

#~ msgid "    -h FILE        True if file is a symbolic link.  Use \"-L\"."
#~ msgstr ""
#~ "    -h FICHERO     Verdadero si el fichero es un enlace simbólico.  Use "
#~ "\"-L\"."

#~ msgid "    -L FILE        True if file is a symbolic link."
#~ msgstr "    -L FICHERO     Verdadero si el fichero es un enlace simbólico."

#~ msgid "    -k FILE        True if file has its \"sticky\" bit set."
#~ msgstr ""
#~ "    -k FICHERO     Verdadero si el fichero tiene el bit \"sticky\" "
#~ "activado."

#~ msgid "    -p FILE        True if file is a named pipe."
#~ msgstr "    -p FICHERO     Verdadero si el fichero es una tubería nombrada."

#~ msgid "    -r FILE        True if file is readable by you."
#~ msgstr "    -r FICHERO     Verdadero si usted puede leer el fichero."

#~ msgid "    -s FILE        True if file exists and is not empty."
#~ msgstr "    -s FICHERO     Verdadero si el fichero existe y no está vacío."

#~ msgid "    -S FILE        True if file is a socket."
#~ msgstr "    -S FICHERO     Verdadero si el fichero es un `socket'."

#~ msgid "    -t FD          True if FD is opened on a terminal."
#~ msgstr "    -t DF          Verdadero si DF está abierto en una terminal."

#~ msgid "    -u FILE        True if the file is set-user-id."
#~ msgstr ""
#~ "    -u FICHERO     Verdadero si el fichero tiene activado el set-user-id."

#~ msgid "    -w FILE        True if the file is writable by you."
#~ msgstr "    -w FICHERO     Verdadero si usted puede modificar el fichero."

#~ msgid "    -x FILE        True if the file is executable by you."
#~ msgstr "    -x FICHERO     Verdadero si usted puede ejecutar el fichero."

#~ msgid "    -O FILE        True if the file is effectively owned by you."
#~ msgstr ""
#~ "    -O FICHERO     Verdadero si usted efectivamente posee el fichero."

#~ msgid ""
#~ "    -G FILE        True if the file is effectively owned by your group."
#~ msgstr ""
#~ "    -G FICHERO     Verdadero si su grupo efectivamente posee el fichero."

#~ msgid "  FILE1 -nt FILE2  True if file1 is newer than (according to"
#~ msgstr ""
#~ "  FICH1 -nt FICH2  Verdadero si fich1 es más nuevo que (de acuerdo a"

#~ msgid "                   modification date) file2."
#~ msgstr "                   la fecha de modificación) el fich2."

#~ msgid "  FILE1 -ot FILE2  True if file1 is older than file2."
#~ msgstr "  FICH1 -ot FICH2  Verdadero si fich1 es más viejo que fich2."

#~ msgid "  FILE1 -ef FILE2  True if file1 is a hard link to file2."
#~ msgstr "  FICH1 -ef FICH2  Verdadero si fich1 es un enlace duro a fich2."

#~ msgid "String operators:"
#~ msgstr "Operadores de cadenas:"

#~ msgid "    -z STRING      True if string is empty."
#~ msgstr "    -z CADENA      Verdadero si la cadena está vacía."

#~ msgid "    -n STRING"
#~ msgstr "    -n CADENA"

#~ msgid "    STRING         True if string is not empty."
#~ msgstr "    CADENA         Verdadero si la cadena no está vacía."

#~ msgid "    STRING1 = STRING2"
#~ msgstr "    CADENA1 = CADENA2"

#~ msgid "                   True if the strings are equal."
#~ msgstr "                   Verdadero si las cadenas son iguales."

#~ msgid "    STRING1 != STRING2"
#~ msgstr "    CADENA1 != CADENA2"

#~ msgid "                   True if the strings are not equal."
#~ msgstr "                   Verdadero si las cadenas no son iguales."

#~ msgid "    STRING1 < STRING2"
#~ msgstr "    CADENA1 < CADENA2"

#~ msgid ""
#~ "                   True if STRING1 sorts before STRING2 lexicographically"
#~ msgstr ""
#~ "                   Verdadero si la CADENA1 se ordena antes que la CADENA2 "
#~ "lexicográficamente"

#~ msgid "    STRING1 > STRING2"
#~ msgstr "    CADENA1 > CADENA2"

#~ msgid ""
#~ "                   True if STRING1 sorts after STRING2 lexicographically"
#~ msgstr ""
#~ "                   Verdadero si la CADENA1 se ordena después que la "
#~ "CADENA2 lexicográficamente"

#~ msgid "Other operators:"
#~ msgstr "Otros operadores:"

#~ msgid "    ! EXPR         True if expr is false."
#~ msgstr "    ! EXPR         Verdadero si la expr es falsa"

#~ msgid "    EXPR1 -a EXPR2 True if both expr1 AND expr2 are true."
#~ msgstr "    EXPR1 -a EXPR2 Verdadero si ambas expr1 Y expr2 son verdaderas."

#~ msgid "    EXPR1 -o EXPR2 True if either expr1 OR expr2 is true."
#~ msgstr ""
#~ "    EXPR1 -o EXPR2  Verdadero si cualquiera de expr1 O expr2 es verdadera."

#~ msgid "    arg1 OP arg2   Arithmetic tests.  OP is one of -eq, -ne,"
#~ msgstr "    arg1 OP arg2   Pruebas aritméticas.  OP es uno de -eq, -ne,"

#~ msgid "                   -lt, -le, -gt, or -ge."
#~ msgstr "                   -lt, -le, -gt, ó -ge."

#~ msgid "Arithmetic binary operators return true if ARG1 is equal, not-equal,"
#~ msgstr ""
#~ "Los operadores binarios aritméticos devuelven verdadero si ARG1 es igual, "
#~ "no igual,"

#~ msgid ""
#~ "less-than, less-than-or-equal, greater-than, or greater-than-or-equal"
#~ msgstr "menor, menor o igual, mayor, ó mayor o igual"

#~ msgid "than ARG2."
#~ msgstr "que ARG2."

#~ msgid "This is a synonym for the \"test\" builtin, but the last"
#~ msgstr "Es un sinónimo para la orden interna \"test\", pero el último"

#~ msgid "the shell."
#~ msgstr "ejecutados desde el shell."

#~ msgid "The command ARG is to be read and executed when the shell receives"
#~ msgstr "La orden ARG se lee y ejecuta cuando el shell recibe la(s)"

#~ msgid "signal(s) SIGNAL_SPEC.  If ARG is absent all specified signals are"
#~ msgstr ""
#~ "señal(es) ID_SEÑAL.  Si ARG no está, todas las señales especificadas son"

#~ msgid "reset to their original values.  If ARG is the null string each"
#~ msgstr ""
#~ "establecidas a sus valores originales.  Si ARG es la cadena nula cada"

#~ msgid "SIGNAL_SPEC is ignored by the shell and by the commands it invokes."
#~ msgstr "ID_SEÑAL es ignorada por el shell y por las órdenes que invoque."

#~ msgid "If SIGNAL_SPEC is EXIT (0) the command ARG is executed on exit from"
#~ msgstr "Si ID_SEÑAL es EXIT (0) la orden ARG se ejecuta al terminar el"

#~ msgid "the shell.  If SIGNAL_SPEC is DEBUG, ARG is executed after every"
#~ msgstr "shell.  Si ID_SEÑAL es DEBUG, ARG se ejecuta después de cada"

#~ msgid "command.  If ARG is `-p' then the trap commands associated with"
#~ msgstr "orden.  Si ARG es `-p' entonces se muestran las órdenes de captura"

#~ msgid "each SIGNAL_SPEC are displayed.  If no arguments are supplied or if"
#~ msgstr "asociadas con cada ID_SEÑAL.  Si no se proporcionan argumentos o si"

#~ msgid "only `-p' is given, trap prints the list of commands associated with"
#~ msgstr ""
#~ "sólo se proporciona `-p', trap muestra la lista de órdenes asociadas"

#~ msgid ""
#~ "each signal number.  SIGNAL_SPEC is either a signal name in <signal.h>"
#~ msgstr ""
#~ "con cada número de señal.  ID_SEÑAL es un nombre de señal en <signal.h>"

#~ msgid ""
#~ "or a signal number.  `trap -l' prints a list of signal names and their"
#~ msgstr ""
#~ "o un número de señal.  `trap -l' muestra una lista de nombres de señal y "
#~ "sus"

#~ msgid "corresponding numbers.  Note that a signal can be sent to the shell"
#~ msgstr ""
#~ "números correspondientes.  Note que una señal se puede enviar al shell"

#~ msgid "with \"kill -signal $$\"."
#~ msgstr "con \"kill -signal $$\"."

#~ msgid "For each NAME, indicate how it would be interpreted if used as a"
#~ msgstr "Para cada NOMBRE, indica cómo sería interpretada si se usara como"

#~ msgid "If the -t option is used, returns a single word which is one of"
#~ msgstr "Si se usa la opción -t, regresa una sola palabra que es una de"

#~ msgid ""
#~ "`alias', `keyword', `function', `builtin', `file' or `', if NAME is an"
#~ msgstr ""
#~ "`alias', `keyword', `function', `builtin', `file' ó `', si el NOMBRE es un"

#~ msgid ""
#~ "alias, shell reserved word, shell function, shell builtin, disk file,"
#~ msgstr ""
#~ "alias, palabra reservada del shell, función del shell, orden interna del "
#~ "shell, fichero del disco,"

#~ msgid "or unfound, respectively."
#~ msgstr "o no encontrada, respectivamente."

#~ msgid "If the -p flag is used, either returns the name of the disk file"
#~ msgstr ""
#~ "Si se usa el indicador -p, regresa el nombre del fichero del sistema"

#~ msgid "that would be executed, or nothing if -t would not return `file'."
#~ msgstr "que sería ejecutado, o nada si -t no regresa algún `fichero'."

#~ msgid "If the -a flag is used, displays all of the places that contain an"
#~ msgstr ""
#~ "Si se usa el indicador -a, muestra todos los lugares que contienen un"

#~ msgid ""
#~ "executable named `file'.  This includes aliases and functions, if and"
#~ msgstr ""
#~ "ejecutable llamado `fichero'  Esto incluye a aliases y funciones, si y"

#~ msgid "only if the -p flag is not also used."
#~ msgstr "sólo si el indicador -p no se especifica también."

#~ msgid "Type accepts -all, -path, and -type in place of -a, -p, and -t,"
#~ msgstr "Type acepta -all, -path, y -type en lugar de -a, -p, y -t,"

#~ msgid "respectively."
#~ msgstr "respectivamente."

#~ msgid "Ulimit provides control over the resources available to processes"
#~ msgstr ""
#~ "ulimit provee control sobre los recursos disponibles para los procesos"

#~ msgid "started by the shell, on systems that allow such control.  If an"
#~ msgstr ""
#~ "iniciados por el shell, en sistemas que permiten dicho control.  Si se"

#~ msgid "option is given, it is interpreted as follows:"
#~ msgstr "establece una opción, se interpreta como sigue:"

#~ msgid "    -S\tuse the `soft' resource limit"
#~ msgstr "    -S\tusa el límite de recurso `suave'"

#~ msgid "    -H\tuse the `hard' resource limit"
#~ msgstr "    -H\tusa el límite de recurso `duro'"

#~ msgid "    -a\tall current limits are reported"
#~ msgstr "    -a\tse muestran todos los límites actuales"

#~ msgid "    -c\tthe maximum size of core files created"
#~ msgstr "    -c\tel tamaño máximo de los ficheros `core' creados"

#~ msgid "    -d\tthe maximum size of a process's data segment"
#~ msgstr "    -d\tel tamaño máximo del segmento de datos de un proceso"

#~ msgid "    -m\tthe maximum resident set size"
#~ msgstr "    -m\tel tamaño máximo para las variables residentes"

#~ msgid "    -s\tthe maximum stack size"
#~ msgstr "    -s\tel tamaño máximo de la pila"

#~ msgid "    -t\tthe maximum amount of cpu time in seconds"
#~ msgstr "    -t\tla cantidad máxima de tiempo de cpu en segundos"

#~ msgid "    -f\tthe maximum size of files created by the shell"
#~ msgstr "    -f\tel número máximo de ficheros creados por el shell"

#~ msgid "    -p\tthe pipe buffer size"
#~ msgstr "    -p\tel tamaño del almacenamiento intermedio para tuberías"

#~ msgid "    -n\tthe maximum number of open file descriptors"
#~ msgstr "    -n\tel número máximo de descriptores de fichero abiertos"

#~ msgid "    -u\tthe maximum number of user processes"
#~ msgstr "    -u\tel número máximo de procesos de usuario"

#~ msgid "    -v\tthe size of virtual memory"
#~ msgstr "    -v\tel tamaño de la memoria virtual"

#~ msgid "If LIMIT is given, it is the new value of the specified resource."
#~ msgstr ""
#~ "Si se establece el LÍMITE, este es el nuevo valor del recurso "
#~ "especificado."

#~ msgid "Otherwise, the current value of the specified resource is printed."
#~ msgstr ""
#~ "De otra forma, se muestra la lista actual de los recursos especificados."

#~ msgid "If no option is given, then -f is assumed.  Values are in 1k"
#~ msgstr ""
#~ "Si no se establece una opción, entonces se asume -f.  Los valores son en "
#~ "incrementos"

#~ msgid "increments, except for -t, which is in seconds, -p, which is in"
#~ msgstr "de 1k, excepto para -t, que es en segundos, -p, que es en"

#~ msgid "increments of 512 bytes, and -u, which is an unscaled number of"
#~ msgstr "incrementos de 512 bytes, y -u, que es un número no escalado de"

#~ msgid "processes."
#~ msgstr "procesos."

#~ msgid ""
#~ "The user file-creation mask is set to MODE.  If MODE is omitted, or if"
#~ msgstr ""
#~ "La máscara de creación de ficheros del usuario se establece a MODO.  Si "
#~ "se omite el MODO, o si"

#~ msgid ""
#~ "`-S' is supplied, the current value of the mask is printed.  The `-S'"
#~ msgstr ""
#~ "se proporciona `-S', se muestra el valor actual de la máscara.  La opción"

#~ msgid ""
#~ "option makes the output symbolic; otherwise an octal number is output."
#~ msgstr ""
#~ "`-S' logra una salida simbólica; de otra forma la salida es un número "
#~ "octal."

#~ msgid "If MODE begins with a digit, it is interpreted as an octal number,"
#~ msgstr ""
#~ "Si el MODO comienza con un dígito, se interpreta como un número octal,"

#~ msgid ""
#~ "otherwise it is a symbolic mode string like that accepted by chmod(1)."
#~ msgstr ""
#~ "de otra forma es una cadena de modo simbólico como la aceptada por chmod"
#~ "(1)."

#~ msgid ""
#~ "Wait for the specified process and report its termination status.  If"
#~ msgstr "Espera al proceso especificado y reporta su estado final.  Si no se"

#~ msgid "N is not given, all currently active child processes are waited for,"
#~ msgstr ""
#~ "proporciona N, espera a todos los procesos hijo activos actualmente,"

#~ msgid "and the return code is zero.  N may be a process ID or a job"
#~ msgstr ""
#~ "y el código de regreso es cero.  N puede ser un ID de proceso o una "
#~ "especificación"

#~ msgid "specification; if a job spec is given, all processes in the job's"
#~ msgstr ""
#~ "de trabajo; si se proporciona una especificación de trabajo, se espera a "
#~ "todos los procesos en la"

#~ msgid "pipeline are waited for."
#~ msgstr "línea de ejecución del trabajo."

#~ msgid "and the return code is zero.  N is a process ID; if it is not given,"
#~ msgstr ""
#~ "y el código de regreso es cero.  N es un ID de proceso; si no se "
#~ "proporcioan,"

#~ msgid "all child processes of the shell are waited for."
#~ msgstr "espera a todos los procesos hijos del shell."

#~ msgid "The `for' loop executes a sequence of commands for each member in a"
#~ msgstr ""
#~ "El ciclo `for' ejecuta una secuencia de órdenes para cada miembro en una"

#~ msgid ""
#~ "list of items.  If `in WORDS ...;' is not present, then `in \"$@\"' is"
#~ msgstr ""
#~ "lista de elementos.  Si `in PALABRAS ...;' no se encuentra, entonces se "
#~ "asume"

#~ msgid ""
#~ "assumed.  For each element in WORDS, NAME is set to that element, and"
#~ msgstr ""
#~ "`in \"$@\"'.  Para cada elemento en PALABRAS, se establece NOMBRE a ese "
#~ "elemento y"

#~ msgid "the COMMANDS are executed."
#~ msgstr "se ejecutan las ÓRDENES."

#~ msgid "The WORDS are expanded, generating a list of words.  The"
#~ msgstr "Las PALABRAS se expanden, generando una lista de palabras.  El"

#~ msgid "set of expanded words is printed on the standard error, each"
#~ msgstr ""
#~ "conjunto de palabras expandidas se muestra en la salida de error estándar"

#~ msgid "preceded by a number.  If `in WORDS' is not present, `in \"$@\"'"
#~ msgstr ""
#~ "cada una precedida por un número.  Si `in PALABRAS' no se encuentra, se "
#~ "asume"

#~ msgid "is assumed.  The PS3 prompt is then displayed and a line read"
#~ msgstr "`in \"$@\"'.  El prompt PS3 se muestra y se lee una línea de"

#~ msgid "from the standard input.  If the line consists of the number"
#~ msgstr "la entrada estándar.  Si la línea consiste del número"

#~ msgid "corresponding to one of the displayed words, then NAME is set"
#~ msgstr ""
#~ "correspondiente a una de las palabras mostradas, entonces se establece "
#~ "NOMBRE"

#~ msgid "to that word.  If the line is empty, WORDS and the prompt are"
#~ msgstr "a esa palabra.  Si la línea está vacía, se muestran de nuevo"

#~ msgid "redisplayed.  If EOF is read, the command completes.  Any other"
#~ msgstr ""
#~ "las PALABRAS y el prompt.  Si se lee EOF, la orden se completa. Cualquier "
#~ "otro"

#~ msgid "value read causes NAME to be set to null.  The line read is saved"
#~ msgstr "valor leído causa que NOMBRE sea nulo.  La línea leída se salva en"

#~ msgid "in the variable REPLY.  COMMANDS are executed after each selection"
#~ msgstr ""
#~ "la variable REPLY.  Las ÓRDENES se ejecutan después de cada selección"

#~ msgid "until a break or return command is executed."
#~ msgstr "hasta que se ejecute una orden break ó return."

#~ msgid "`|' is used to separate multiple patterns."
#~ msgstr "`|' se usa para separar plantillas múltiples."

#~ msgid ""
#~ "The if COMMANDS are executed.  If the exit status is zero, then the then"
#~ msgstr ""
#~ "Las ÓRDENES if se ejecutan.  Si el código de regreso es cero, entonces "
#~ "las ÓRDENES"

#~ msgid ""
#~ "COMMANDS are executed.  Otherwise, each of the elif COMMANDS are executed"
#~ msgstr ""
#~ "then se ejecutan.  De otra forma, cada uno de las ÓRDENES elif se ejecutan"

#~ msgid ""
#~ "in turn, and if the exit status is zero, the corresponding then COMMANDS"
#~ msgstr ""
#~ "en turno, y si el código de regreso es cero, las ÓRDENES then "
#~ "correspondientes"

#~ msgid ""
#~ "are executed and the if command completes.  Otherwise, the else COMMANDS"
#~ msgstr ""
#~ "se ejecutan y la orden if se completa.  De otra forma, las ÓRDENES else"

#~ msgid ""
#~ "are executed, if present.  The exit status is the exit status of the last"
#~ msgstr ""
#~ "se ejecutan, si se encuentran.  El código de salida es el código de "
#~ "salida de la última"

#~ msgid "command executed, or zero if no condition tested true."
#~ msgstr "orden ejecutada, o cero si ninguna condición probada fue verdadera."

#~ msgid "`while' COMMANDS has an exit status of zero."
#~ msgstr "`while' tenga un código de salida de cero."

#~ msgid "`until' COMMANDS has an exit status which is not zero."
#~ msgstr "`until' tenga un código de salida que no sea cero."

#~ msgid "Create a simple command invoked by NAME which runs COMMANDS."
#~ msgstr ""
#~ "Crea un comando simple invocado por el NOMBRE que ejecuta las ÓRDENES."

#~ msgid "Arguments on the command line along with NAME are passed to the"
#~ msgstr ""
#~ "Los argumentos en la línea de comando junto con el NOMBRE se pasan a la"

#~ msgid "function as $0 .. $n."
#~ msgstr "función como $0 .. $n."

#~ msgid "entire set of commands."
#~ msgstr "conjunto completo de órdenes"

#~ msgid "This is similar to the `fg' command.  Resume a stopped or background"
#~ msgstr ""
#~ "Esto es similar a la orden `fg'. Reinicia un trabajo detenido o en el"

#~ msgid "job.  If you specifiy DIGITS, then that job is used.  If you specify"
#~ msgstr ""
#~ "background.  Si especifica DÍGITOS, entonces se usa ese trabajo.  Si "
#~ "proporciona"

#~ msgid ""
#~ "WORD, then the job whose name begins with WORD is used.  Following the"
#~ msgstr ""
#~ "una PALABRA, entonces se usa el trabajo cuyo nombre comience con PALABRA."

#~ msgid "job specification with a `&' places the job in the background."
#~ msgstr ""
#~ "Al colocar una especificación de trabajo seguido de un `&', se coloca al "
#~ "trabajo en el background. "

#~ msgid "BASH_VERSION    The version numbers of this Bash."
#~ msgstr "BASH_VERSION    Los números de versión de este Bash."

#~ msgid "CDPATH          A colon separated list of directories to search"
#~ msgstr "CDPATH         Una lista separada por `:' de directorios a buscar"

#~ msgid "\t\twhen the argument to `cd' is not found in the current"
#~ msgstr "\t\tcuando el argumento para `cd' no se encuentra en el directorio"

#~ msgid "\t\tdirectory."
#~ msgstr "\t\tactual."

#~ msgid ""
#~ "HISTFILE        The name of the file where your command history is stored."
#~ msgstr ""
#~ "HISTFILE        El nombre del fichero donde se guarda la historia de "
#~ "órdenes."

#~ msgid "HISTFILESIZE    The maximum number of lines this file can contain."
#~ msgstr ""
#~ "HISTFILESIZE    El número máximo de líneas que este fichero puede "
#~ "contener."

#~ msgid "HISTSIZE        The maximum number of history lines that a running"
#~ msgstr "HISTSIZE        El número máximo de líneas de historia que un shell"

#~ msgid "\t\tshell can access."
#~ msgstr "\t\ten ejecución puede acceder."

#~ msgid "HOME            The complete pathname to your login directory."
#~ msgstr ""
#~ "HOME            La ruta completa a su directorio de entrada (login)."

#~ msgid ""
#~ "HOSTTYPE        The type of CPU this version of Bash is running under."
#~ msgstr ""
#~ "HOSTTYPE        El tipo de CPU bajo el cual esta versión de Bash corre."

#~ msgid ""
#~ "IGNOREEOF       Controls the action of the shell on receipt of an EOF"
#~ msgstr ""
#~ "IGNOREEOF       Controla la acción del shell al recibir un carácter EOF"

#~ msgid "\t\tcharacter as the sole input.  If set, then the value"
#~ msgstr "\t\tcomo la única entrada.  Si se establece, entonces el valor"

#~ msgid "\t\tof it is the number of EOF characters that can be seen"
#~ msgstr ""
#~ "\t\tde esta variable es el número de caracteres EOF que se pueden recibir"

#~ msgid "\t\tin a row on an empty line before the shell will exit"
#~ msgstr ""
#~ "\t\ten forma seguida en una línea vacía antes de que el shell termine"

#~ msgid "\t\t(default 10).  When unset, EOF signifies the end of input."
#~ msgstr ""
#~ "\t\t(10 por omisión).  Cuando se desactiva, EOF significa el fin de la "
#~ "entrada."

#~ msgid "MAILCHECK\tHow often, in seconds, Bash checks for new mail."
#~ msgstr ""
#~ "MAILCHECK\tQue tan seguido, en segundos, Bash revisa si hay correo nuevo."

#~ msgid "MAILPATH\tA colon-separated list of filenames which Bash checks"
#~ msgstr ""
#~ "MAILPATH\tUna lista de nombres de fichero separados por dos puntos que "
#~ "Bash revisa"

#~ msgid "\t\tfor new mail."
#~ msgstr "\t\tpor correo nuevo."

#~ msgid "OSTYPE\t\tThe version of Unix this version of Bash is running on."
#~ msgstr ""
#~ "OSTYPE\t\tLa versión de Unix bajo la cual esta versión de Bash se ejecuta."

#~ msgid "PATH            A colon-separated list of directories to search when"
#~ msgstr ""
#~ "PATH            Una lista de directorios separada por dos puntos para "
#~ "buscar"

#~ msgid "\t\tlooking for commands."
#~ msgstr "\t\tcuando se requieren órdenes."

#~ msgid "PROMPT_COMMAND  A command to be executed before the printing of each"
#~ msgstr "PROMPT_COMMAND  Una orden a ejecutar antes de mostrar cada"

#~ msgid "\t\tprimary prompt."
#~ msgstr "\t\tprompt primario."

#~ msgid "PS1             The primary prompt string."
#~ msgstr "PS1             La cadena primaria de prompt."

#~ msgid "PS2             The secondary prompt string."
#~ msgstr "PS2             La cadena secundaria de prompt."

#~ msgid "TERM            The name of the current terminal type."
#~ msgstr "TERM            El nombre del tipo de terminal actual."

#~ msgid "auto_resume     Non-null means a command word appearing on a line by"
#~ msgstr ""
#~ "auto_resume     Si no es nulo significa que una palabra de orden que "
#~ "aparece en una línea"

#~ msgid "\t\titself is first looked for in the list of currently"
#~ msgstr "\t\tpor sí mismo se busca primero en la lista de trabajos detenidos"

#~ msgid "\t\tstopped jobs.  If found there, that job is foregrounded."
#~ msgstr ""
#~ "\t\tactualmente.  Si se encuentra ahí, ese trabajo se trae a primer plano."

#~ msgid "\t\tA value of `exact' means that the command word must"
#~ msgstr "\t\tEl valor `exact' significa que la palabra de la orden debe"

#~ msgid "\t\texactly match a command in the list of stopped jobs.  A"
#~ msgstr ""
#~ "\t\tcoincidir exactamente con una orden en la lista de trabajos "
#~ "detenidos.  El"

#~ msgid "\t\tvalue of `substring' means that the command word must"
#~ msgstr "\t\tvalor `substring' significa que la palabra de la orden debe"

#~ msgid "\t\tmatch a substring of the job.  Any other value means that"
#~ msgstr ""
#~ "\t\tcoincidir con una subcadena del trabajo.  Cualquier otro valor "
#~ "significa que"

#~ msgid "\t\tthe command must be a prefix of a stopped job."
#~ msgstr "\t\tla orden debe ser un prefijo de un trabajo detenido."

#~ msgid "command_oriented_history"
#~ msgstr "command_oriented_history"

#~ msgid ""
#~ "                Non-null means to save multiple-line commands together on"
#~ msgstr ""
#~ "                Si no es nulo significa que debe guardar órdenes de "
#~ "varias líneas juntas en"

#~ msgid "                a single history line."
#~ msgstr "                una sola línea de historia."

#~ msgid "histchars       Characters controlling history expansion and quick"
#~ msgstr ""
#~ "histchars       Caracteres que controlan la expansión de la historia y la"

#~ msgid "\t\tsubstitution.  The first character is the history"
#~ msgstr "\t\tsustitución rápida.  El primer carácter es el carácter de"

#~ msgid "\t\tsubstitution character, usually `!'.  The second is"
#~ msgstr "\t\tsustutución de historia, generalmente `!'.  El segundo es"

#~ msgid "\t\tthe `quick substitution' character, usually `^'.  The"
#~ msgstr "\t\tel carácter de `sustitución rápida', generalmente `^'.  El"

#~ msgid "\t\tthird is the `history comment' character, usually `#'."
#~ msgstr ""
#~ "\t\ttercero es el carácter de `comentario de historia', generalmente `#'."

#~ msgid "HISTCONTROL\tSet to a value of `ignorespace', it means don't enter"
#~ msgstr ""
#~ "HISTCONTROL\tEstablecido con el valor `ignorespace', significa que no "
#~ "agrega"

#~ msgid "\t\tlines which begin with a space or tab on the history"
#~ msgstr "\t\tlíneas que inicien con un espacio o tabulador a la lista de"

#~ msgid "\t\tlist.  Set to a value of `ignoredups', it means don't"
#~ msgstr "\t\thistoria.  Con el valor `ignoredups', significa que no agrega"

#~ msgid "\t\tenter lines which match the last entered line.  Set to"
#~ msgstr "\t\tlíneas que coincidan con la última línea introducida.  Con"

#~ msgid "\t\t`ignoreboth' means to combine the two options.  Unset,"
#~ msgstr ""
#~ "\t\t`ignoreboth' significa que combina las dos opciones.  Sin establecer,"

#~ msgid "\t\tor set to any other value than those above means to save"
#~ msgstr ""
#~ "\t\to con cualquier otro valor diferente a los arriba mencionados "
#~ "significa"

#~ msgid "\t\tall lines on the history list."
#~ msgstr "\t\tguardar todas las líneas en la lista de la historia."

#~ msgid "Toggle the values of variables controlling optional behavior."
#~ msgstr ""
#~ "Cambia los valores de las variables que controlan conductas opcionales."

#~ msgid "The -s flag means to enable (set) each OPTNAME; the -u flag"
#~ msgstr ""
#~ "El indicador -s significa establecer cada NOMBRE_OPCIÓN; el indicador -u"

#~ msgid "unsets each OPTNAME.  The -q flag suppresses output; the exit"
#~ msgstr ""
#~ "borra cada NOMBRE_OPCIÓN.  El indicador -q suprime la salida; el estado"

#~ msgid "status indicates whether each OPTNAME is set or unset.  The -o"
#~ msgstr "de salida indica cuál NOMBRE_OPCIÓN está activado o no.  La opción"

#~ msgid "option restricts the OPTNAMEs to those defined for use with"
#~ msgstr ""
#~ "-o restringe a los NOMBRE_OPCIONes a aquéllos definidos para su uso con"

#~ msgid "`set -o'.  With no options, or with the -p option, a list of all"
#~ msgstr ""
#~ "`set -o'.  Sin opciones, o con la opción -p, se muestra una lista de"

#~ msgid "settable options is displayed, with an indication of whether or"
#~ msgstr "todas las opciones activables, con una indicación de si se puede"

#~ msgid "not each is set."
#~ msgstr "o no activar cada una."
