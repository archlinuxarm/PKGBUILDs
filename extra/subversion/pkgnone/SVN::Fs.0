.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "native::Fs 3"
.TH native::Fs 3 "2006-09-13" "perl v5.10.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SVN::Fs \- Subversion filesystem functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SVN::Fs wraps the functions in svn_fs.h.  The actual namespace
for filesystem objects is \f(CW\*(C`_p_svn_fs_t\*(C'\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "SVN::Fs::berkeley_logfiles($path, $only_unused)" 4
.el .IP "SVN::Fs::berkeley_logfiles($path, \f(CW$only_unused\fR)" 4
.IX Item "SVN::Fs::berkeley_logfiles($path, $only_unused)"
.PD 0
.IP "SVN::Fs::berkeley_recover($path)" 4
.IX Item "SVN::Fs::berkeley_recover($path)"
.ie n .IP "SVN::Fs::check_related($id1, $id2)" 4
.el .IP "SVN::Fs::check_related($id1, \f(CW$id2\fR)" 4
.IX Item "SVN::Fs::check_related($id1, $id2)"
.ie n .IP "SVN::Fs::compare_ids($id1, $id2)" 4
.el .IP "SVN::Fs::compare_ids($id1, \f(CW$id2\fR)" 4
.IX Item "SVN::Fs::compare_ids($id1, $id2)"
.ie n .IP "SVN::Fs::contents_changed($root1, $path1, $root2, $path2)" 4
.el .IP "SVN::Fs::contents_changed($root1, \f(CW$path1\fR, \f(CW$root2\fR, \f(CW$path2\fR)" 4
.IX Item "SVN::Fs::contents_changed($root1, $path1, $root2, $path2)"
.ie n .IP "SVN::Fs::create($path, $config)" 4
.el .IP "SVN::Fs::create($path, \f(CW$config\fR)" 4
.IX Item "SVN::Fs::create($path, $config)"
.IP "SVN::Fs::delete_fs($path)" 4
.IX Item "SVN::Fs::delete_fs($path)"
.ie n .IP "SVN::Fs::deltify_revision($fs, $rev)" 4
.el .IP "SVN::Fs::deltify_revision($fs, \f(CW$rev\fR)" 4
.IX Item "SVN::Fs::deltify_revision($fs, $rev)"
.ie n .IP "SVN::Fs::get_file_delta_stream($source_root, $source_path, $target_root, $target_path)" 4
.el .IP "SVN::Fs::get_file_delta_stream($source_root, \f(CW$source_path\fR, \f(CW$target_root\fR, \f(CW$target_path\fR)" 4
.IX Item "SVN::Fs::get_file_delta_stream($source_root, $source_path, $target_root, $target_path)"
.ie n .IP "SVN::Fs::hotcopy($src_path, $dest_path, $clean)" 4
.el .IP "SVN::Fs::hotcopy($src_path, \f(CW$dest_path\fR, \f(CW$clean\fR)" 4
.IX Item "SVN::Fs::hotcopy($src_path, $dest_path, $clean)"
.IP "SVN::Fs::initialize($pool)" 4
.IX Item "SVN::Fs::initialize($pool)"
.ie n .IP "SVN::Fs::merge($source_root, $source_path, $target_root, $target_path, $ancestor_root, $ancestor_path)" 4
.el .IP "SVN::Fs::merge($source_root, \f(CW$source_path\fR, \f(CW$target_root\fR, \f(CW$target_path\fR, \f(CW$ancestor_root\fR, \f(CW$ancestor_path\fR)" 4
.IX Item "SVN::Fs::merge($source_root, $source_path, $target_root, $target_path, $ancestor_root, $ancestor_path)"
.ie n .IP "SVN::Fs::open($path, $config)" 4
.el .IP "SVN::Fs::open($path, \f(CW$config\fR)" 4
.IX Item "SVN::Fs::open($path, $config)"
.IP "SVN::Fs::path($fs)" 4
.IX Item "SVN::Fs::path($fs)"
.IP "SVN::Fs::print_modules($s)" 4
.IX Item "SVN::Fs::print_modules($s)"
.PD
\&\s-1TODO\s0 \- doesn't work, segfaults if \f(CW$s\fR is null, doesn't do anything if
its an empty string
.ie n .IP "SVN::Fs::props_changed($root1, $path1, $root2, $path2)" 4
.el .IP "SVN::Fs::props_changed($root1, \f(CW$path1\fR, \f(CW$root2\fR, \f(CW$path2\fR)" 4
.IX Item "SVN::Fs::props_changed($root1, $path1, $root2, $path2)"
See also \f(CW\*(C`SVN::Fs::contents_changed\*(C'\fR
.ie n .IP "SVN::Fs::purge_txn($fs, $txn_id)" 4
.el .IP "SVN::Fs::purge_txn($fs, \f(CW$txn_id\fR)" 4
.IX Item "SVN::Fs::purge_txn($fs, $txn_id)"
Cleanup the transaction \f(CW$txn_id\fR, removing it completely from
the filesystem \f(CW$fs\fR.
.ie n .IP "SVN::Fs::set_warning_func($fs, $code, $baton)" 4
.el .IP "SVN::Fs::set_warning_func($fs, \f(CW$code\fR, \f(CW$baton\fR)" 4
.IX Item "SVN::Fs::set_warning_func($fs, $code, $baton)"
.PD 0
.IP "SVN::Fs::unparse_id($id)" 4
.IX Item "SVN::Fs::unparse_id($id)"
.PD
Return a string containing the unparsed form of the node or node
revision id \f(CW$id\fR, which must be a \f(CW\*(C`_p_svn_fs_id_t\*(C'\fR object.
.Sp
\&\s-1TODO\s0 \- why isn't this a method of that object?
.IP "\fISVN::Fs::version()\fR" 4
.IX Item "SVN::Fs::version()"
\&\s-1TODO\s0 \- what can we do with the _p_svn_version_t value returned?
.IP "SVN::Fs::create_access($username)" 4
.IX Item "SVN::Fs::create_access($username)"
Return a new \f(CW\*(C`_p_svn_fs_access_t\*(C'\fR object representing \f(CW$username\fR.
\&\f(CW$username\fR is presumed to have been authenticated by the caller.
.SH "_p_svn_fs_t"
.IX Header "_p_svn_fs_t"
.ie n .IP "$fs\->begin_txn($rev)" 4
.el .IP "\f(CW$fs\fR\->begin_txn($rev)" 4
.IX Item "$fs->begin_txn($rev)"
Creates a new transaction in the repository, and returns a
\&\f(CW\*(C`_p_svn_fs_txn_t\*(C'\fR object representing it.  The new transaction's
base revision will be \f(CW$rev\fR, which should be a number.
.ie n .IP "$fs\->change_rev_prop" 4
.el .IP "\f(CW$fs\fR\->change_rev_prop" 4
.IX Item "$fs->change_rev_prop"
.PD 0
.ie n .IP "$fs\->\fIgenerate_lock_token()\fR" 4
.el .IP "\f(CW$fs\fR\->\fIgenerate_lock_token()\fR" 4
.IX Item "$fs->generate_lock_token()"
.PD
Generate a unique lock-token using \f(CW$fs\fR.
.Sp
\&\s-1TODO\s0 \- translate this to apply to Perl:
This can be used in to populate lock\->token before calling
\&\fIsvn_fs_attach_lock()\fR.
.ie n .IP "$fs\->\fIget_access()\fR" 4
.el .IP "\f(CW$fs\fR\->\fIget_access()\fR" 4
.IX Item "$fs->get_access()"
The filesystem's current access context, as a \f(CW\*(C`_p_svn_fs_access_t\*(C'\fR
object.  Returns undef if no access context has been set with
the \f(CW\*(C`set_access()\*(C'\fR method.
.ie n .IP "$fs\->get_lock" 4
.el .IP "\f(CW$fs\fR\->get_lock" 4
.IX Item "$fs->get_lock"
.PD 0
.ie n .IP "$fs\->get_locks" 4
.el .IP "\f(CW$fs\fR\->get_locks" 4
.IX Item "$fs->get_locks"
.ie n .IP "$fs\->\fIget_uuid()\fR" 4
.el .IP "\f(CW$fs\fR\->\fIget_uuid()\fR" 4
.IX Item "$fs->get_uuid()"
.PD
The \s-1UUID\s0 associated with \f(CW$fs\fR.
.ie n .IP "$fs\->\fIlist_transactions()\fR" 4
.el .IP "\f(CW$fs\fR\->\fIlist_transactions()\fR" 4
.IX Item "$fs->list_transactions()"
A reference to an array of all currently active transactions in the
filesystem.  Each one is a string containing the transaction's \s-1ID\s0,
suitable for passing to \f(CW\*(C`$fs\->open_txn()\*(C'\fR.
.ie n .IP "$fs\->lock" 4
.el .IP "\f(CW$fs\fR\->lock" 4
.IX Item "$fs->lock"
.PD 0
.ie n .IP "$fs\->open_txn($name)" 4
.el .IP "\f(CW$fs\fR\->open_txn($name)" 4
.IX Item "$fs->open_txn($name)"
.PD
Get a transaction in the repository by name.  Returns a
\&\f(CW\*(C`_p_svn_fs_txn_t\*(C'\fR object.
.ie n .IP "$fs\->revision_prop($rev, $propname)" 4
.el .IP "\f(CW$fs\fR\->revision_prop($rev, \f(CW$propname\fR)" 4
.IX Item "$fs->revision_prop($rev, $propname)"
The value of revision property \f(CW$propname\fR in revision \f(CW$rev\fR.
.ie n .IP "$fs\->revision_proplist($rev)" 4
.el .IP "\f(CW$fs\fR\->revision_proplist($rev)" 4
.IX Item "$fs->revision_proplist($rev)"
A hashref containing the names and values of all revision properties
from revision \f(CW$rev\fR.
.ie n .IP "$fs\->revision_root" 4
.el .IP "\f(CW$fs\fR\->revision_root" 4
.IX Item "$fs->revision_root"
.PD 0
.ie n .IP "$fs\->set_access($access)" 4
.el .IP "\f(CW$fs\fR\->set_access($access)" 4
.IX Item "$fs->set_access($access)"
.PD
Associate an access context with an open filesystem.
.Sp
This method can be run multiple times on the same open
filesystem, in order to change the filesystem access context for
different filesystem operations.  \f(CW$access\fR should be
a \f(CW\*(C`_p_svn_fs_access_t\*(C'\fR object, or undef to disassociate the
current access context from the filesystem.
.ie n .IP "$fs\->set_uuid($uuid)" 4
.el .IP "\f(CW$fs\fR\->set_uuid($uuid)" 4
.IX Item "$fs->set_uuid($uuid)"
Associate \f(CW$uuid\fR with \f(CW$fs\fR.
.ie n .IP "$fs\->unlock" 4
.el .IP "\f(CW$fs\fR\->unlock" 4
.IX Item "$fs->unlock"
.PD 0
.ie n .IP "$fs\->\fIyoungest_rev()\fR" 4
.el .IP "\f(CW$fs\fR\->\fIyoungest_rev()\fR" 4
.IX Item "$fs->youngest_rev()"
.PD
Return the number of the youngest revision in the filesystem.
The oldest revision in any filesystem is numbered zero.
.SH "_p_svn_fs_root_t"
.IX Header "_p_svn_fs_root_t"
.ie n .IP "$root\->apply_text" 4
.el .IP "\f(CW$root\fR\->apply_text" 4
.IX Item "$root->apply_text"
.PD 0
.ie n .IP "$root\->apply_textdelta" 4
.el .IP "\f(CW$root\fR\->apply_textdelta" 4
.IX Item "$root->apply_textdelta"
.ie n .IP "$root\->change_node_prop($path, $propname, $value)" 4
.el .IP "\f(CW$root\fR\->change_node_prop($path, \f(CW$propname\fR, \f(CW$value\fR)" 4
.IX Item "$root->change_node_prop($path, $propname, $value)"
.ie n .IP "$root\->check_path($path)" 4
.el .IP "\f(CW$root\fR\->check_path($path)" 4
.IX Item "$root->check_path($path)"
.PD
Kind of node at \f(CW$path\fR.  A number which matches one of these constants:
\&\f(CW$SVN::Node::none\fR, \f(CW$SVN::Node::file\fR,
\&\f(CW$SVN::Node::dir\fR, \f(CW$SVN::Node::unknown\fR.
.ie n .IP "$root\->close_root" 4
.el .IP "\f(CW$root\fR\->close_root" 4
.IX Item "$root->close_root"
.PD 0
.ie n .IP "$root\->closest_copy" 4
.el .IP "\f(CW$root\fR\->closest_copy" 4
.IX Item "$root->closest_copy"
.ie n .IP "$root\->copied_from" 4
.el .IP "\f(CW$root\fR\->copied_from" 4
.IX Item "$root->copied_from"
.ie n .IP "$root\->copy" 4
.el .IP "\f(CW$root\fR\->copy" 4
.IX Item "$root->copy"
.ie n .IP "$root\->delete" 4
.el .IP "\f(CW$root\fR\->delete" 4
.IX Item "$root->delete"
.ie n .IP "$root\->dir_entries" 4
.el .IP "\f(CW$root\fR\->dir_entries" 4
.IX Item "$root->dir_entries"
.ie n .IP "$root\->file_contents" 4
.el .IP "\f(CW$root\fR\->file_contents" 4
.IX Item "$root->file_contents"
.ie n .IP "$root\->file_length" 4
.el .IP "\f(CW$root\fR\->file_length" 4
.IX Item "$root->file_length"
.ie n .IP "$root\->file_md5_checksum" 4
.el .IP "\f(CW$root\fR\->file_md5_checksum" 4
.IX Item "$root->file_md5_checksum"
.ie n .IP "$root\->\fIfs()\fR" 4
.el .IP "\f(CW$root\fR\->\fIfs()\fR" 4
.IX Item "$root->fs()"
.PD
The filesystem to which \f(CW$root\fR belongs, as a \f(CW\*(C`_p_svn_fs_t\*(C'\fR object.
.ie n .IP "$root\->is_dir($path)" 4
.el .IP "\f(CW$root\fR\->is_dir($path)" 4
.IX Item "$root->is_dir($path)"
True if there is a node at \f(CW$path\fR which is a directory.
.ie n .IP "$root\->is_file($path)" 4
.el .IP "\f(CW$root\fR\->is_file($path)" 4
.IX Item "$root->is_file($path)"
True if there is a node at \f(CW$path\fR which is a file.
.ie n .IP "$root\->\fIis_revision_root()\fR" 4
.el .IP "\f(CW$root\fR\->\fIis_revision_root()\fR" 4
.IX Item "$root->is_revision_root()"
True if the root comes from a revision (i.e., the contents has already been
committed).
.ie n .IP "$root\->\fIis_txn_root()\fR" 4
.el .IP "\f(CW$root\fR\->\fIis_txn_root()\fR" 4
.IX Item "$root->is_txn_root()"
True if the root comes from a transaction.
.ie n .IP "$root\->make_dir" 4
.el .IP "\f(CW$root\fR\->make_dir" 4
.IX Item "$root->make_dir"
.PD 0
.ie n .IP "$root\->make_file" 4
.el .IP "\f(CW$root\fR\->make_file" 4
.IX Item "$root->make_file"
.ie n .IP "$root\->node_created_path($path)" 4
.el .IP "\f(CW$root\fR\->node_created_path($path)" 4
.IX Item "$root->node_created_path($path)"
.ie n .IP "$root\->node_created_rev($path)" 4
.el .IP "\f(CW$root\fR\->node_created_rev($path)" 4
.IX Item "$root->node_created_rev($path)"
.ie n .IP "$root\->node_history($path)" 4
.el .IP "\f(CW$root\fR\->node_history($path)" 4
.IX Item "$root->node_history($path)"
.PD
\&\s-1TODO\s0 \- _p_svn_fs_history_t
.ie n .IP "$root\->node_id($path)" 4
.el .IP "\f(CW$root\fR\->node_id($path)" 4
.IX Item "$root->node_id($path)"
.PD 0
.ie n .IP "$root\->node_prop($path, $propname)" 4
.el .IP "\f(CW$root\fR\->node_prop($path, \f(CW$propname\fR)" 4
.IX Item "$root->node_prop($path, $propname)"
.ie n .IP "$root\->node_proplist($path)" 4
.el .IP "\f(CW$root\fR\->node_proplist($path)" 4
.IX Item "$root->node_proplist($path)"
.ie n .IP "$root\->\fIpaths_changed()\fR" 4
.el .IP "\f(CW$root\fR\->\fIpaths_changed()\fR" 4
.IX Item "$root->paths_changed()"
.PD
A reference to a hash indicating what changes are made in the root.
The keys are the paths of the files changed, starting with \f(CW\*(C`/\*(C'\fR to
indicate the top-level directory of the repository.  The values
are \f(CW\*(C`_p_svn_fs_path_change_t\*(C'\fR objects which contain information about
what kind of changes are made.
.ie n .IP "$root\->revision_link" 4
.el .IP "\f(CW$root\fR\->revision_link" 4
.IX Item "$root->revision_link"
.PD 0
.ie n .IP "$root\->revision_root_revision" 4
.el .IP "\f(CW$root\fR\->revision_root_revision" 4
.IX Item "$root->revision_root_revision"
.PD
Revision number of the revision the root comes from.
For transaction roots, returns \f(CW$SVN::Core::INVALID_REVNUM\fR.
.SH "_p_svn_fs_history_t"
.IX Header "_p_svn_fs_history_t"
.ie n .IP "$history\->\fIlocation()\fR" 4
.el .IP "\f(CW$history\fR\->\fIlocation()\fR" 4
.IX Item "$history->location()"
In list context, a list of two items: the path to the node whose history
this is, and the revision number in which it exists.  In scalar context
returns only the revision number.
.ie n .IP "$history\->prev($cross_copies)" 4
.el .IP "\f(CW$history\fR\->prev($cross_copies)" 4
.IX Item "$history->prev($cross_copies)"
.SH "_p_svn_fs_txn_t"
.IX Header "_p_svn_fs_txn_t"
.PD 0
.ie n .IP "$txn\->\fIabort()\fR" 4
.el .IP "\f(CW$txn\fR\->\fIabort()\fR" 4
.IX Item "$txn->abort()"
.PD
Abort the transaction.  Any changes made in \f(CW$txn\fR are discarded, and
the filesystem is left unchanged.
.Sp
Note: This function first sets the state of \f(CW$txn\fR to 'dead', and
then attempts to purge it and any related data from the filesystem.
If some part of the cleanup process fails, \f(CW$txn\fR and some portion
of its data may remain in the database after this function returns.
Use \f(CW\*(C`$fs\->purge_txn()\*(C'\fR to retry the transaction cleanup.
.ie n .IP "$txn\->\fIbase_revision()\fR" 4
.el .IP "\f(CW$txn\fR\->\fIbase_revision()\fR" 4
.IX Item "$txn->base_revision()"
The transaction's base revision number.
.ie n .IP "$txn\->change_prop($name, $value)" 4
.el .IP "\f(CW$txn\fR\->change_prop($name, \f(CW$value\fR)" 4
.IX Item "$txn->change_prop($name, $value)"
Add, change, or remove a property from the transaction.
If \f(CW$value\fR is \f(CW\*(C`undef\*(C'\fR then the property \f(CW$name\fR is removed,
if it exists.  Otherwise the property \f(CW$name\fR is set to the
new value.
.ie n .IP "$txn\->commit" 4
.el .IP "\f(CW$txn\fR\->commit" 4
.IX Item "$txn->commit"
.PD 0
.ie n .IP "$txn\->\fIname()\fR" 4
.el .IP "\f(CW$txn\fR\->\fIname()\fR" 4
.IX Item "$txn->name()"
.PD
Full name of the revision, in the same format as can be passed
to \f(CW\*(C`$fs\->open_txn()\*(C'\fR.
.ie n .IP "$txn\->prop($name)" 4
.el .IP "\f(CW$txn\fR\->prop($name)" 4
.IX Item "$txn->prop($name)"
The value of the transaction's \f(CW$name\fR property.
.ie n .IP "$txn\->\fIproplist()\fR" 4
.el .IP "\f(CW$txn\fR\->\fIproplist()\fR" 4
.IX Item "$txn->proplist()"
A reference to a hash containing all the transaction's properties,
keyed by name.
.ie n .IP "$txn\->\fIroot()\fR" 4
.el .IP "\f(CW$txn\fR\->\fIroot()\fR" 4
.IX Item "$txn->root()"
The root directory of the transaction, as a \f(CW\*(C`_p_svn_fs_root_t\*(C'\fR object.
.SH "_p_svn_fs_access_t"
.IX Header "_p_svn_fs_access_t"
.SS "\s-1SYNOPSIS\s0"
.IX Subsection "SYNOPSIS"
.Vb 1
\&    my $access = SVN::Fs::create_access($username);
\&
\&    my $access = $fs\->get_access;
\&    $fs\->set_access($access);
\&
\&    my $username = $access\->get_username;
\&
\&    $access\->add_lock_token($token);
.Ve
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "$access\->add_lock_token($token)" 4
.el .IP "\f(CW$access\fR\->add_lock_token($token)" 4
.IX Item "$access->add_lock_token($token)"
Push a lock-token into the access context.  The
context remembers all tokens it receives, and makes them available
to fs functions.
.ie n .IP "$access\->get_username" 4
.el .IP "\f(CW$access\fR\->get_username" 4
.IX Item "$access->get_username"
The username represented by the access context.
.SH "svn_fs_dirent_t"
.IX Header "svn_fs_dirent_t"
An object representing a directory entry.  Values of this type are returned
as the values in the hash returned by \f(CW\*(C`$root\->dir_entries()\*(C'\fR.  They
are like svn_dirent_t objects, but have less
information.
.ie n .IP "$dirent\->\fIid()\fR" 4
.el .IP "\f(CW$dirent\fR\->\fIid()\fR" 4
.IX Item "$dirent->id()"
\&\s-1TODO\s0
.ie n .IP "$dirent\->\fIkind()\fR" 4
.el .IP "\f(CW$dirent\fR\->\fIkind()\fR" 4
.IX Item "$dirent->kind()"
Node kind.  A number which matches one of these constants:
\&\f(CW$SVN::Node::none\fR, \f(CW$SVN::Node::file\fR,
\&\f(CW$SVN::Node::dir\fR, \f(CW$SVN::Node::unknown\fR.
.ie n .IP "$dirent\->\fIname()\fR" 4
.el .IP "\f(CW$dirent\fR\->\fIname()\fR" 4
.IX Item "$dirent->name()"
The filename of the directory entry.
.SH "_p_svn_fs_path_change_t"
.IX Header "_p_svn_fs_path_change_t"
.ie n .IP "$change\->\fIchange_kind()\fR" 4
.el .IP "\f(CW$change\fR\->\fIchange_kind()\fR" 4
.IX Item "$change->change_kind()"
The type of change made.  A number which matches one of the following:
.RS 4
.ie n .IP "$SVN::Fs::PathChange::modify" 4
.el .IP "\f(CW$SVN::Fs::PathChange::modify\fR" 4
.IX Item "$SVN::Fs::PathChange::modify"
Content at path modified.
.ie n .IP "$SVN::Fs::PathChange::add" 4
.el .IP "\f(CW$SVN::Fs::PathChange::add\fR" 4
.IX Item "$SVN::Fs::PathChange::add"
Path added in transaction.
.ie n .IP "$SVN::Fs::PathChange::delete" 4
.el .IP "\f(CW$SVN::Fs::PathChange::delete\fR" 4
.IX Item "$SVN::Fs::PathChange::delete"
Path removed in transaction.
.ie n .IP "$SVN::Fs::PathChange::replace" 4
.el .IP "\f(CW$SVN::Fs::PathChange::replace\fR" 4
.IX Item "$SVN::Fs::PathChange::replace"
Path removed and re-added in transaction.
.ie n .IP "$SVN::Fs::PathChange::reset" 4
.el .IP "\f(CW$SVN::Fs::PathChange::reset\fR" 4
.IX Item "$SVN::Fs::PathChange::reset"
Ignore all previous change items for path (internal-use only).
.RE
.RS 4
.RE
.ie n .IP "$change\->\fInode_rev_id()\fR" 4
.el .IP "\f(CW$change\fR\->\fInode_rev_id()\fR" 4
.IX Item "$change->node_rev_id()"
Node revision id of changed path.  A \f(CW\*(C`_p_svn_fs_id_t\*(C'\fR object.
.ie n .IP "$change\->\fIprop_mod()\fR" 4
.el .IP "\f(CW$change\fR\->\fIprop_mod()\fR" 4
.IX Item "$change->prop_mod()"
True if the properties were modified.
.ie n .IP "$change\->\fItext_mod()\fR" 4
.el .IP "\f(CW$change\fR\->\fItext_mod()\fR" 4
.IX Item "$change->text_mod()"
True if the text (content) was modified.
