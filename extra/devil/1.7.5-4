
--- devil-1.7.5.orig/debian/control
+++ devil-1.7.5/debian/control
@@ -0,0 +1,39 @@
+Source: devil
+Section: devel
+Priority: optional
+Maintainer: Bradley Smith <bradsmith@debian.org>
+Build-Depends: debhelper (>= 7), libpng12-dev, zlib1g-dev, libjpeg62-dev, libtiff4-dev, libmng-dev, liblcms1-dev, freeglut3-dev, libgl1-mesa-dev | libgl-dev, libsdl1.2-dev, quilt
+Standards-Version: 3.8.0
+Homepage: http://openil.sourceforge.net/
+Vcs-Git: http://git.brad-smith.co.uk/git/debian/pkg-devil.git
+Vcs-Browser: http://git.brad-smith.co.uk/?p=debian/pkg-devil.git
+
+Package: libdevil1c2
+Section: libs
+Architecture: any
+Replaces: libdevil1
+Conflicts: libdevil1
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Description: Cross-platform image loading and manipulation toolkit
+ Developer's Image Library (DevIL) is a programmer's toolkit which can load,
+ save and convert a wide variety of image formats. It also offers basic
+ manipulation and filtering capabilities.
+ .
+ DevIL presents a simple programming interface similar to OpenGL's, which is
+ easy for a developer to learn and use. Ultimate control of the images is
+ left to the developer.
+
+Package: libdevil-dev
+Section: libdevel
+Architecture: any
+Depends: libdevil1c2 (= ${binary:Version}), ${misc:Depends}
+Description: Cross-platform image loading and manipulation toolkit
+ Developer's Image Library (DevIL) is a programmer's toolkit which can
+ load, save and convert a wide variety of image formats.  It also offers
+ basic manipulation and filtering capabilities.
+ .
+ DevIL presents a simple programming interface similar to OpenGL's, which is
+ easy for a developer to learn and use.  Ultimate control of the images is
+ left to the developer.
+ .
+ This package contains the development files.
--- devil-1.7.5.orig/debian/libdevil1c2.install
+++ devil-1.7.5/debian/libdevil1c2.install
@@ -0,0 +1 @@
+debian/tmp/usr/lib/*.so.*
--- devil-1.7.5.orig/debian/compat
+++ devil-1.7.5/debian/compat
@@ -0,0 +1 @@
+7
--- devil-1.7.5.orig/debian/copyright
+++ devil-1.7.5/debian/copyright
@@ -0,0 +1,38 @@
+Author: Denton Woods
+Download: http://openil.sf.net/
+
+Files: *
+Copyright: (C) 2000-2002 by Denton Woods
+License: LGPL-2+
+ This package is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Lesser General Public
+ License as published by the Free Software Foundation; either
+ version 2 of the License, or (at your option) any later version.
+ .
+ This package is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Lesser General Public License for more details.
+
+Files: debian/*
+Copyright: (C) 2008 Bradley Smith <brad@brad-smith.co.uk>
+License: GPL-2+.
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ .
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ .
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+
+On Debian systems, the complete text of the GNU General Public License
+can be found in `/usr/share/common-licenses/GPL-2'.
+
+On Debian GNU/Linux systems, the complete text of the GNU Lesser General
+Public License can be found in `/usr/share/common-licenses/LGPL-2'.
--- devil-1.7.5.orig/debian/libdevil1c2.lintian-overrides
+++ devil-1.7.5/debian/libdevil1c2.lintian-overrides
@@ -0,0 +1,3 @@
+# There are multiple libraries in this package, and I don't think we would
+# gain anything by splitting them up.
+libdevil1c2: package-name-doesnt-match-sonames libIL1 libILU1 libILUT1
--- devil-1.7.5.orig/debian/watch
+++ devil-1.7.5/debian/watch
@@ -0,0 +1,2 @@
+version=3
+http://sf.net/openil/DevIL-([\d.]+)\.tar.gz
--- devil-1.7.5.orig/debian/libdevil-dev.docs
+++ devil-1.7.5/debian/libdevil-dev.docs
@@ -0,0 +1,4 @@
+Libraries.txt
+NEWS
+README
+README.unix
--- devil-1.7.5.orig/debian/changelog
+++ devil-1.7.5/debian/changelog
@@ -0,0 +1,206 @@
+devil (1.7.5-4) unstable; urgency=low
+
+  * Actually fix CVE-2008-5262. Closes: #512122.
+
+ -- Bradley Smith <bradsmith@debian.org>  Sat, 17 Jan 2009 15:01:18 +0000
+
+devil (1.7.5-3) unstable; urgency=low
+
+  * 03_CVE-2008-5262.diff - Backport fix for CVE-2008-5262.
+    Closes: #511844.
+
+ -- Bradley Smith <bradsmith@debian.org>  Thu, 15 Jan 2009 18:50:11 +0000
+
+devil (1.7.5-2) unstable; urgency=low
+
+  * add_missing_files.diff - Add files missed from tarball. Closes: #511297
+
+ -- Bradley Smith <bradsmith@debian.org>  Sat, 10 Jan 2009 20:47:32 +0000
+
+devil (1.7.5-1) unstable; urgency=low
+
+  * New upstream release.
+
+ -- Bradley Smith <bradsmith@debian.org>  Wed, 31 Dec 2008 12:38:16 +0000
+
+devil (1.7.4-1) experimental; urgency=low
+
+  * New upstream release.
+  * Update maintainer email.
+  * 00_endian_and_ILvoid_fixes.diff - Refresh.
+  * 01_fix_as-needed.diff - Refresh.
+
+ -- Bradley Smith <bradsmith@debian.org>  Tue, 30 Dec 2008 21:16:58 +0000
+
+devil (1.7.2-1) experimental; urgency=low
+
+  * New upstream release. Closes: #499626
+  * Refresh 00_misc_fixes.diff and rename to 00_endian_and_ILvoid_fixes.diff
+  * Refresh 01_fix_as-needed.diff
+  * Re-add debian/watch file.
+  * Add Homepage field.
+  * Add Vcs-* fields.
+  * Adjust descriptions to make the -dev package match the non-dev package.
+  * Convert copyright to machine readable format.
+  * Update compat version to 7 and upgrade debhelper build-depend to (>= 7).
+  * Remove unneeded docs from installation.
+  * Add descriptions to lintian override and patches.
+
+ -- Bradley Smith <brad@brad-smith.co.uk>  Fri, 26 Sep 2008 15:25:45 +0100
+
+devil (1.6.8-rc2-3) unstable; urgency=low
+
+  * Fix typo in 00_misc_fixes.diff.
+  * Remove broken watch file. Not adding a new one since upstreams
+    repository is full of broken versioning.
+
+ -- Bradley Smith <brad@brad-smith.co.uk>  Wed, 23 Jul 2008 21:45:53 +0100
+
+devil (1.6.8-rc2-2) unstable; urgency=low
+
+  * Build with -DGLX_GLXEXT_LEGACY to avoid implicit pointer conversion.
+    Closes: #490975
+  * Fix il_endian.h patch to fix FTBFS's on big endian machines.
+
+ -- Bradley Smith <brad@brad-smith.co.uk>  Sun, 20 Jul 2008 14:21:18 +0100
+
+devil (1.6.8-rc2-1) unstable; urgency=low
+
+  * New Upstream Release.
+  * New Maintainer. Closes: #471982.
+  * Overhaul Packaging.
+   - Update Standards-Version to 3.8.0.
+    + Support parallel=N in DEB_BUILD_OPTIONS.
+   - Correct section for libdevil-dev.
+   - Remove autotools dependency, not longer needed.
+   - Add quilt patch system.
+    + 00_misc_fixes.diff - Move changes to top srcdir to patch.
+    + 01_fix_as-needed.diff - Fix --as-needed flag in libtool.
+   - Correct debian/copyright
+   - Add watch file.
+   - Replace obsolete dependency (libglut3-dev). Closes: #394488.
+
+ -- Bradley Smith <brad@brad-smith.co.uk>  Sun, 06 Jul 2008 19:27:50 +0100
+
+devil (1.6.7-5.2) unstable; urgency=low
+
+  * NMU.
+  * debian/control: Build-Depend on automake1.9 instead of automake1.8, to
+    stop blocking the removal of automake1.8. (Closes: #472594)
+
+ -- Eric Dorland <eric@debian.org>  Sat, 03 May 2008 00:23:33 -0400
+
+devil (1.6.7-5.1) unstable; urgency=low
+
+  * Non-maintainer upload.
+  * Turned the ILvoid type into the void type, as suggested by tbm (thanks to
+    Per Hansen as well for the proposed patch). Closes: #376620.
+  * Made the package binNMu-safe by using binary:Version instead of
+    Source-Version.
+
+ -- Cyril Brulebois <cyril.brulebois@enst-bretagne.fr>  Sat, 29 Sep 2007 14:37:27 +0200
+
+devil (1.6.7-5) unstable; urgency=low
+
+  * Ack NMU
+  * debian/compat, debian/control: use debhelper 5
+  * debian/control: build-depend on libpng12-dev
+  * debian/control: build-depend on automake1.8
+  * debian/control: build-depend on libgl1-mesa-dev
+  * We are getting exceedingly good at handling changes in the worst
+    possible way ever.  I want back to 1999!  See all the above entries.
+    closes: bug#358089
+  * src-IL/src/il_png.c: Fix AMD64 problems.  Thanks Mike McLean.  closes:
+    bug#314829
+  * debian/control: standards version 3.7.2; no other changes seem to be
+    required
+  * debian/control: add Section to source package
+  * debian/rules: funny... move code that copies autofoo stuff AFTER the line
+    that removes it
+  * src-IL/src/Makefile.am: remove @LIBGIF@; autoconf test does not exist, so
+    it never actually worked, methinks.
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Fri, 05 May 2006 08:27:12 -0600
+
+devil (1.6.7-4.1) unstable; urgency=medium
+  
+  * NMU (with maintainer permission.)
+  * Recompiled with gcc 4.0 and changed library package name to
+    libdevil1c2 (the big C++ ABI change.)
+
+ -- Federico Di Gregorio <fog@debian.org>  Thu, 21 Jul 2005 11:50:41 +0200
+
+devil (1.6.7-4) unstable; urgency=medium
+
+  * dinstall is being a jerk.
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Mon, 24 Jan 2005 21:25:22 -0600
+
+devil (1.6.7-3) unstable; urgency=medium
+
+  * src-IL/include/il_endian.h: patch from Federico Di Gregorio to fix
+    endianess issues.  Sorry about the delay and misunderstandings!  Thanks
+    Federico. (closes: bug#288314)
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Sun, 23 Jan 2005 21:06:34 -0600
+
+devil (1.6.7-2) unstable; urgency=medium
+
+  * debian/rules: hideous hack to work around the fact that the upstream
+    tarball is dirty.  Thanks Federico Di Gregorio (closes: bug#288314)
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Mon, 03 Jan 2005 19:57:42 -0600
+
+devil (1.6.7-1) unstable; urgency=medium
+
+  * New upstream release
+  * debian/rules: very fscked up hack to get libtool working.
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Tue, 02 Nov 2004 16:53:45 -0600
+
+devil (1.6.5-5.1) unstable; urgency=medium
+
+  * Non-Maintainer Upload.
+  * debian/control: switch to libtiff4-dev (closes: #262795).
+  * src-IL/include/il_endian.h: patch from Michel DÃ¤nzer to fix
+    endianness detection (closes: #222608).
+
+ -- Jordi Mallach <jordi@debian.org>  Thu,  5 Aug 2004 01:42:43 +0200
+
+devil (1.6.5-5) unstable; urgency=low
+
+  * build and install libIL_wrap.a (closes: bug#192633)
+  * debian/rules: strip out -L flags from dependency_libs in .la files (-L
+    flags should not be needed at all) (closes: bug#192554)
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Sun, 11 May 2003 22:47:23 +0200
+
+devil (1.6.5-4) unstable; urgency=low
+
+  * rebuild, for some reason OpenGL support is missing from -3 on i386.
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Wed, 12 Mar 2003 22:41:52 +0100
+
+devil (1.6.5-3) unstable; urgency=low
+
+  * src-IL/src/il_pal.c, src-IL/src/il_psd.c: fixed signedness related
+    warnings.
+  * include/IL/il.h: typedef ILbyte as 'signed char' (closes: bug#181226)
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Mon, 17 Feb 2003 13:10:16 +0100
+
+devil (1.6.5-2) unstable; urgency=low
+
+  * debian/control: changed description (closes: bug#177997)
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Sun, 09 Feb 2003 17:34:30 +0100
+
+devil (1.6.5-1) unstable; urgency=low
+
+  * Initial Release.
+  * src-ILU/include/ilu_region.h: fetched out of CVS, missing in upstream
+    tarball
+  * src-ILU/src/Makefile.am: it's top_builddir, not top_srcdir
+
+ -- Marcelo E. Magallon <mmagallo@debian.org>  Sun, 19 Jan 2003 13:18:49 +0100
+
--- devil-1.7.5.orig/debian/libdevil-dev.install
+++ devil-1.7.5/debian/libdevil-dev.install
@@ -0,0 +1,4 @@
+debian/tmp/usr/lib/*.so
+debian/tmp/usr/lib/*.la
+debian/tmp/usr/lib/*.a
+debian/tmp/usr/include/
--- devil-1.7.5.orig/debian/rules
+++ devil-1.7.5/debian/rules
@@ -0,0 +1,82 @@
+#!/usr/bin/make -f
+
+include /usr/share/quilt/quilt.make
+
+DEB_HOST_GNU_TYPE   ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+DEB_BUILD_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+
+
+CFLAGS = -Wall -g -DGLX_GLXEXT_LEGACY
+LDFLAGS = -lm -lGL -Wl,--as-needed
+
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -O0
+else
+	CFLAGS += -O2
+endif
+
+ifneq (,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
+	NUMJOBS = $(patsubst parallel=%,%,$(filter parallel=%,$(DEB_BUILD_OPTIONS)))
+MAKEFLAGS += -j$(NUMJOBS)
+endif
+
+
+ifneq (,$(findstring debug,$(DEB_BUILD_OPTIONS)))
+DEBUG_FLAGS = --disable-release
+endif
+
+configure: configure-stamp
+configure-stamp: $(QUILT_STAMPFN)
+	dh_testdir
+	CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" \
+		./configure --prefix=/usr --mandir=\$${prefix}/share/man \
+		--infodir=\$${prefix}/share/info --enable-static=yes \
+		--enable-shared=yes --host=$(DEB_HOST_GNU_TYPE) \
+		--build=$(DEB_BUILD_GNU_TYPE) $(DEBUG_FLAGS) \
+		--enable-IL=yes --enable-ILU=yes --enable-ILUT=yes
+	touch "$@"
+
+build: build-stamp
+build-stamp: configure
+	dh_testdir
+	$(MAKE)
+	touch "$@"
+
+clean: unpatch
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+	[ ! -f Makefile ] || $(MAKE) distclean
+	dh_clean
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_prep
+	$(MAKE) install DESTDIR=$(CURDIR)/debian/tmp
+	rm debian/tmp/usr/share/info/DevIL_manual.info
+	mkdir -p debian/libdevil1c2/usr/share/lintian/overrides/
+	cp -a debian/libdevil1c2.lintian-overrides \
+		debian/libdevil1c2/usr/share/lintian/overrides/libdevil1c2
+
+binary-indep: build install
+
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs ChangeLog
+	dh_installdocs
+	dh_install --fail-missing
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+	dh_makeshlibs
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure
--- devil-1.7.5.orig/debian/patches/00_endian_and_ILvoid_fixes.diff
+++ devil-1.7.5/debian/patches/00_endian_and_ILvoid_fixes.diff
@@ -0,0 +1,15 @@
+# Fixes FTBFS with GCC 4.2: '<anonymous>' has incomplete type
+# Fixes FTBFS on big endian architectures.
+Index: devil/src-IL/include/il_endian.h
+===================================================================
+--- devil.orig/src-IL/include/il_endian.h	2008-12-30 21:05:37.000000000 +0000
++++ devil/src-IL/include/il_endian.h	2008-12-30 21:08:10.000000000 +0000
+@@ -17,7 +17,7 @@
+ 
+ #ifdef WORDS_BIGENDIAN //this is defined by ./configure
+ 	#ifndef __BIG_ENDIAN__
+-	#define __BIG_ENDIAN__
++	#define __BIG_ENDIAN__	1
+ 	#endif
+ #endif
+ 
--- devil-1.7.5.orig/debian/patches/02_add_missing_files.diff
+++ devil-1.7.5/debian/patches/02_add_missing_files.diff
@@ -0,0 +1,894 @@
+Index: devil/lib/Makefile.am
+===================================================================
+--- devil.orig/lib/Makefile.am	2009-01-10 20:43:26.000000000 +0000
++++ devil/lib/Makefile.am	2009-01-10 20:54:27.000000000 +0000
+@@ -69,8 +69,8 @@
+ 
+ libIL_la_CPPFLAGS = -I $(il_include) -I $(all_include)
+ libIL_la_CFLAGS = $(CFLAGS) @IL_CFLAGS@
+-libIL_la_SOURCES = $(il_src)/il_alloc.c $(il_src)/il_doom.c $(il_src)/il_stack.c $(il_src)/il_pcx.c $(il_src)/il_rle.c $(il_src)/il_bits.c $(il_src)/il_endian.c $(il_src)/il_jpeg.c $(il_src)/il_pic.c $(il_src)/il_sgi.c $(il_src)/il_bmp.c $(il_src)/il_error.c $(il_src)/il_lif.c $(il_src)/il_png.c $(il_src)/il_states.c $(il_src)/il_convbuff.c $(il_src)/il_files.c $(il_src)/il_main.c $(il_src)/il_pnm.c $(il_src)/il_targa.c $(il_src)/il_wdp.c $(il_src)/il_convert.c $(il_src)/il_gif.c $(il_src)/il_manip.c $(il_src)/il_profiles.c $(il_src)/il_tiff.c $(il_src)/il_cut.c $(il_src)/il_header.c $(il_src)/il_mdl.c $(il_src)/il_quantizer.c $(il_src)/il_utility.c $(il_src)/il_dcx.c $(il_src)/il_icon.c $(il_src)/il_mng.c $(il_src)/il_raw.c $(il_src)/il_wal.c $(il_src)/il_dds.c $(il_src)/il_internal.c $(il_src)/il_pal.c $(il_src)/il_rawdata.c $(il_src)/il_devil.c $(il_src)/il_io.c $(il_src)/il_pcd.c $(il_src)/il_register.c $(il_src)/il_psd.c $(il_src)/il_fastconv.c $(il_src)/il_neuquant.c $(il_src)/il_dds-save.c $(il_src)/il_psp.c $(il_src)/il_pix.c $(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c $(il_src)/il_icns.c $(il_src)/il_jp2.c $(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c
+-libIL_la_SOURCES += $(il_include)/altivec_common.h $(il_include)/altivec_typeconversion.h $(il_include)/il_alloc.h $(il_include)/il_bits.h $(il_include)/il_bmp.h $(il_include)/il_dcx.h $(il_include)/il_dds.h $(il_include)/il_doompal.h $(il_include)/il_endian.h $(il_include)/il_exr.h $(il_include)/il_files.h $(il_include)/il_gif.h $(il_include)/il_hdr.h $(il_include)/il_icns.h $(il_include)/il_icon.h $(il_include)/il_internal.h $(il_include)/il_jp2.h $(il_include)/il_jpeg.h $(il_include)/il_lif.h $(il_include)/il_manip.h $(il_include)/il_mdl.h $(il_include)/il_pal.h $(il_include)/il_pcx.h $(il_include)/il_pic.h $(il_include)/il_pnm.h $(il_include)/il_psd.h $(il_include)/il_psp.h $(il_include)/il_q2pal.h $(il_include)/il_register.h $(il_include)/il_rle.h $(il_include)/il_sgi.h $(il_include)/il_stack.h $(il_include)/il_states.h $(il_include)/il_targa.h $(il_include)/il_wdp.h $(all_include)/IL/devil_internal_exports.h
++libIL_la_SOURCES = $(il_src)/il_alloc.c $(il_src)/il_doom.c $(il_src)/il_stack.c $(il_src)/il_pcx.c $(il_src)/il_rle.c $(il_src)/il_bits.c $(il_src)/il_endian.c $(il_src)/il_jpeg.c $(il_src)/il_pic.c $(il_src)/il_sgi.c $(il_src)/il_bmp.c $(il_src)/il_error.c $(il_src)/il_lif.c $(il_src)/il_png.c $(il_src)/il_states.c $(il_src)/il_convbuff.c $(il_src)/il_files.c $(il_src)/il_main.c $(il_src)/il_pnm.c $(il_src)/il_targa.c $(il_src)/il_wdp.c $(il_src)/il_convert.c $(il_src)/il_gif.c $(il_src)/il_manip.c $(il_src)/il_profiles.c $(il_src)/il_tiff.c $(il_src)/il_cut.c $(il_src)/il_header.c $(il_src)/il_mdl.c $(il_src)/il_quantizer.c $(il_src)/il_utility.c $(il_src)/il_dcx.c $(il_src)/il_icon.c $(il_src)/il_mng.c $(il_src)/il_raw.c $(il_src)/il_wal.c $(il_src)/il_dds.c $(il_src)/il_internal.c $(il_src)/il_pal.c $(il_src)/il_rawdata.c $(il_src)/il_devil.c $(il_src)/il_io.c $(il_src)/il_pcd.c $(il_src)/il_register.c $(il_src)/il_psd.c $(il_src)/il_fastconv.c $(il_src)/il_neuquant.c $(il_src)/il_dds-save.c $(il_src)/il_psp.c $(il_src)/il_pix.c $(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c $(il_src)/il_icns.c $(il_src)/il_jp2.c $(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c $(il_src)/il_vtf.c
++libIL_la_SOURCES += $(il_include)/altivec_common.h $(il_include)/altivec_typeconversion.h $(il_include)/il_alloc.h $(il_include)/il_bits.h $(il_include)/il_bmp.h $(il_include)/il_dcx.h $(il_include)/il_dds.h $(il_include)/il_doompal.h $(il_include)/il_endian.h $(il_include)/il_exr.h $(il_include)/il_files.h $(il_include)/il_gif.h $(il_include)/il_hdr.h $(il_include)/il_icns.h $(il_include)/il_icon.h $(il_include)/il_internal.h $(il_include)/il_jp2.h $(il_include)/il_jpeg.h $(il_include)/il_lif.h $(il_include)/il_manip.h $(il_include)/il_mdl.h $(il_include)/il_pal.h $(il_include)/il_pcx.h $(il_include)/il_pic.h $(il_include)/il_pnm.h $(il_include)/il_psd.h $(il_include)/il_psp.h $(il_include)/il_q2pal.h $(il_include)/il_register.h $(il_include)/il_rle.h $(il_include)/il_sgi.h $(il_include)/il_stack.h $(il_include)/il_states.h $(il_include)/il_targa.h $(il_include)/il_wdp.h $(all_include)/IL/devil_internal_exports.h $(il_include)/il_vtf.h
+ libIL_la_LDFLAGS = @IL_LIBS@ $(AM_LDFLAGS)
+ 
+ libILU_la_CPPFLAGS = -I $(ilu_include) -I $(all_include)
+Index: devil/src-IL/include/il_vtf.h
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ devil/src-IL/include/il_vtf.h	2009-01-10 20:54:27.000000000 +0000
+@@ -0,0 +1,130 @@
++//-----------------------------------------------------------------------------
++//
++// ImageLib Sources
++// Copyright (C) 2000-2008 by Denton Woods
++// Last modified: 12/27/2008
++//
++// Filename: src-IL/include/il_vtf.h
++//
++// Description: Reads from and writes to a Valve Texture Format (.vtf) file.
++//                These are used in Valve's Source games.  VTF specs available
++//                from http://developer.valvesoftware.com/wiki/VTF.
++//
++//-----------------------------------------------------------------------------
++
++
++#ifndef VTF_H
++#define VTF_H
++
++#include "il_internal.h"
++
++#ifdef _MSC_VER
++#pragma pack(push, vtf_struct, 1)
++#elif defined(MACOSX) || defined(__GNUC__)
++#pragma pack(1)
++#endif
++
++typedef struct VTFHEAD
++{
++	ILubyte		Signature[4];		// File signature ("VTF\0").
++	ILuint		Version[2];			// version[0].version[1] (currently 7.2).
++	ILuint		HeaderSize;			// Size of the header struct (16 byte aligned; currently 80 bytes).
++	ILushort	Width;				// Width of the largest mipmap in pixels. Must be a power of 2.
++	ILushort	Height;				// Height of the largest mipmap in pixels. Must be a power of 2.
++	ILuint		Flags;				// VTF flags.
++	ILushort	Frames;				// Number of frames, if animated (1 for no animation).
++	ILushort	FirstFrame;			// First frame in animation (0 based).
++	ILubyte		Padding0[4];		// reflectivity padding (16 byte alignment).
++	ILfloat		Reflectivity[3];	// reflectivity vector.
++	ILubyte		Padding1[4];		// reflectivity padding (8 byte packing).
++	ILfloat		BumpmapScale;		// Bumpmap scale.
++	ILuint		HighResImageFormat;	// High resolution image format.
++	ILubyte		MipmapCount;		// Number of mipmaps.
++	ILint		LowResImageFormat;	// Low resolution image format (always DXT1).
++	ILubyte		LowResImageWidth;	// Low resolution image width.
++	ILubyte		LowResImageHeight;	// Low resolution image height.
++	ILushort	Depth;				// Depth of the largest mipmap in pixels.
++									// Must be a power of 2. Can be 0 or 1 for a 2D texture (v7.2 only).
++} IL_PACKSTRUCT VTFHEAD;
++
++#if defined(MACOSX) || defined(__GNUC__)
++#pragma pack()
++#elif _MSC_VER
++#pragma pack(pop, vtf_struct)
++#endif
++
++enum
++{
++	IMAGE_FORMAT_NONE = -1,
++	IMAGE_FORMAT_RGBA8888 = 0,
++	IMAGE_FORMAT_ABGR8888,
++	IMAGE_FORMAT_RGB888,
++	IMAGE_FORMAT_BGR888,
++	IMAGE_FORMAT_RGB565,
++	IMAGE_FORMAT_I8,
++	IMAGE_FORMAT_IA88,
++	IMAGE_FORMAT_P8,
++	IMAGE_FORMAT_A8,
++	IMAGE_FORMAT_RGB888_BLUESCREEN,
++	IMAGE_FORMAT_BGR888_BLUESCREEN,
++	IMAGE_FORMAT_ARGB8888,
++	IMAGE_FORMAT_BGRA8888,
++	IMAGE_FORMAT_DXT1,
++	IMAGE_FORMAT_DXT3,
++	IMAGE_FORMAT_DXT5,
++	IMAGE_FORMAT_BGRX8888,
++	IMAGE_FORMAT_BGR565,
++	IMAGE_FORMAT_BGRX5551,
++	IMAGE_FORMAT_BGRA4444,
++	IMAGE_FORMAT_DXT1_ONEBITALPHA,
++	IMAGE_FORMAT_BGRA5551,
++	IMAGE_FORMAT_UV88,
++	IMAGE_FORMAT_UVWQ8888,
++	IMAGE_FORMAT_RGBA16161616F,
++	IMAGE_FORMAT_RGBA16161616,
++	IMAGE_FORMAT_UVLX8888
++};
++
++enum
++{
++	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
++	TEXTUREFLAGS_TRILINEAR = 0x00000002,
++	TEXTUREFLAGS_CLAMPS = 0x00000004,
++	TEXTUREFLAGS_CLAMPT = 0x00000008,
++	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
++	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
++	TEXTUREFLAGS_NOCOMPRESS = 0x00000040,
++	TEXTUREFLAGS_NORMAL = 0x00000080,
++	TEXTUREFLAGS_NOMIP = 0x00000100,
++	TEXTUREFLAGS_NOLOD = 0x00000200,
++	TEXTUREFLAGS_MINMIP = 0x00000400,
++	TEXTUREFLAGS_PROCEDURAL = 0x00000800,
++	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
++	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,
++	TEXTUREFLAGS_ENVMAP = 0x00004000,
++	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
++	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
++	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
++	TEXTUREFLAGS_SINGLECOPY = 0x00040000,
++	TEXTUREFLAGS_ONEOVERMIPLEVELINALPHA = 0x00080000,
++	TEXTUREFLAGS_PREMULTCOLORBYONEOVERMIPLEVEL = 0x00100000,
++	TEXTUREFLAGS_NORMALTODUDV = 0x00200000,
++	TEXTUREFLAGS_ALPHATESTMIPGENERATION = 0x00400000,
++	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
++	TEXTUREFLAGS_NICEFILTERED = 0x01000000,
++	TEXTUREFLAGS_CLAMPU = 0x02000000
++};
++
++
++
++// Internal functions
++ILboolean	iIsValidVtf(void);
++ILboolean	iGetVtfHead(VTFHEAD *Header);
++ILboolean	iCheckVtf(VTFHEAD *Header);
++ILboolean	iLoadVtfInternal(void);
++ILboolean	VtfInitMipmaps(ILimage *BaseImage, VTFHEAD *Header);
++ILboolean	VtfReadData(void);
++ILboolean	VtfDecompressDXT1(ILimage *Image);
++ILboolean	VtfDecompressDXT5(ILimage *Image);
++
++#endif//VTF_H
+Index: devil/src-IL/src/il_vtf.c
+===================================================================
+--- /dev/null	1970-01-01 00:00:00.000000000 +0000
++++ devil/src-IL/src/il_vtf.c	2009-01-10 20:54:27.000000000 +0000
+@@ -0,0 +1,612 @@
++//-----------------------------------------------------------------------------
++//
++// ImageLib Sources
++// Copyright (C) 2000-2008 by Denton Woods
++// Last modified: 12/29/2008
++//
++// Filename: src-IL/src/il_vtf.c
++//
++// Description: Reads from and writes to a Valve Texture Format (.vtf) file.
++//                These are used in Valve's Source games.  VTF specs available
++//                from http://developer.valvesoftware.com/wiki/VTF.
++//
++//-----------------------------------------------------------------------------
++
++
++#include "il_internal.h"
++#ifndef IL_NO_VTF
++#include "il_vtf.h"
++#include "il_dds.h"
++
++// the max and min functions are not present, at least not on unixes
++#ifndef max
++	#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )
++#endif
++
++#ifndef min
++	#define min( a, b ) ( ((a) < (b)) ? (a) : (b) )
++#endif
++
++//@TODO: Get rid of these globals.
++//static VTFHEAD Head;
++
++
++//! Checks if the file specified in FileName is a valid VTF file.
++ILboolean ilIsValidVtf(ILconst_string FileName)
++{
++	ILHANDLE	VtfFile;
++	ILboolean	bVtf = IL_FALSE;
++	
++	if (!iCheckExtension(FileName, IL_TEXT("vtf"))) {
++		ilSetError(IL_INVALID_EXTENSION);
++		return bVtf;
++	}
++	
++	VtfFile = iopenr(FileName);
++	if (VtfFile == NULL) {
++		ilSetError(IL_COULD_NOT_OPEN_FILE);
++		return bVtf;
++	}
++	
++	bVtf = ilIsValidVtfF(VtfFile);
++	icloser(VtfFile);
++	
++	return bVtf;
++}
++
++
++//! Checks if the ILHANDLE contains a valid VTF file at the current position.
++ILboolean ilIsValidVtfF(ILHANDLE File)
++{
++	ILuint		FirstPos;
++	ILboolean	bRet;
++	
++	iSetInputFile(File);
++	FirstPos = itell();
++	bRet = iIsValidVtf();
++	iseek(FirstPos, IL_SEEK_SET);
++	
++	return bRet;
++}
++
++
++//! Checks if Lump is a valid VTF lump.
++ILboolean ilIsValidVtfL(const void *Lump, ILuint Size)
++{
++	iSetInputLump(Lump, Size);
++	return iIsValidVtf();
++}
++
++
++// Internal function used to get the VTF header from the current file.
++ILboolean iGetVtfHead(VTFHEAD *Header)
++{
++	iread(Header->Signature, 1, 4);
++	Header->Version[0] = GetLittleUInt();
++	Header->Version[1] = GetLittleUInt();
++	Header->HeaderSize = GetLittleUInt();
++	Header->Width = GetLittleUShort();
++	Header->Height = GetLittleUShort();
++	Header->Flags = GetLittleUInt();
++	Header->Frames = GetLittleUShort();
++	Header->FirstFrame = GetLittleUShort();
++	iseek(4, IL_SEEK_CUR);  // Padding
++	Header->Reflectivity[0] = GetLittleFloat();
++	Header->Reflectivity[1] = GetLittleFloat();
++	Header->Reflectivity[2] = GetLittleFloat();
++	iseek(4, IL_SEEK_CUR);  // Padding
++	Header->BumpmapScale = GetLittleFloat();
++	Header->HighResImageFormat = GetLittleUInt();
++	Header->MipmapCount = (ILubyte)igetc();
++	Header->LowResImageFormat = GetLittleInt();
++	Header->LowResImageWidth = (ILubyte)igetc();
++	Header->LowResImageHeight = (ILubyte)igetc();
++	Header->Depth = GetLittleUShort();
++
++	iseek(Header->HeaderSize - sizeof(VTFHEAD), IL_SEEK_CUR);
++
++	return IL_TRUE;
++}
++
++
++// Internal function to get the header and check it.
++ILboolean iIsValidVtf()
++{
++	VTFHEAD Head;
++
++	if (!iGetVtfHead(&Head))
++		return IL_FALSE;
++	iseek(-(ILint)sizeof(VTFHEAD), IL_SEEK_CUR);
++	
++	return iCheckVtf(&Head);
++}
++
++
++//@TODO: Add more checks.
++// Should we check for Frames, MipmapCount and Depth != 0?
++
++// Internal function used to check if the HEADER is a valid VTF header.
++ILboolean iCheckVtf(VTFHEAD *Header)
++{
++	// The file signature is "VTF\0".
++	if ((Header->Signature[0] != 'V') || (Header->Signature[1] != 'T') || (Header->Signature[2] != 'F')
++		|| (Header->Signature[3] != 0))
++		return IL_FALSE;
++	// Are there other versions available yet?
++	if (Header->Version[0] != 7)
++		return IL_FALSE;
++	// We have 7.0 through 7.4 as of 12/27/2008.
++	if (Header->Version[1] > 4)
++		return IL_FALSE;
++	// May change in future version of the specifications.
++	//  80 is through version 7.2, and 96/104 are through 7.4.
++	//  This must be 16-byte aligned, but something is outputting headers with 104.
++	if ((Header->HeaderSize != 80) && (Header->HeaderSize != 96) && (Header->HeaderSize != 104))
++		return IL_FALSE;
++
++	// 0 is an invalid dimension
++	if (Header->Width == 0 || Header->Height == 0)
++		return IL_FALSE;
++	// Width and Height must be powers of 2.
++	if ((ilNextPower2(Header->Width) != Header->Width) || (ilNextPower2(Header->Height) != Header->Height))
++		return IL_FALSE;
++	if ((ilNextPower2(Header->LowResImageWidth) != Header->LowResImageWidth)
++		|| (ilNextPower2(Header->LowResImageHeight) != Header->LowResImageHeight))
++		return IL_FALSE;
++	// In addition, the LowResImage has to have dimensions no greater than 16.
++	if ((Header->LowResImageWidth > 16) || (Header->LowResImageHeight > 16)
++		|| (Header->LowResImageWidth == 0) || (Header->LowResImageHeight == 0))
++		return IL_FALSE;
++	// And the LowResImage has to have dimensions less than or equal to the main image.
++	if ((Header->LowResImageWidth > Header->Width) || (Header->LowResImageHeight > Header->Height))
++		return IL_FALSE;
++	// The LowResImage must be in DXT1 format.
++	if (Header->LowResImageFormat != IMAGE_FORMAT_DXT1)
++		return IL_FALSE;
++	
++	return IL_TRUE;
++}
++
++
++//! Reads a VTF file
++ILboolean ilLoadVtf(ILconst_string FileName)
++{
++	ILHANDLE	VtfFile;
++	ILboolean	bVtf = IL_FALSE;
++	
++	VtfFile = iopenr(FileName);
++	if (VtfFile == NULL) {
++		ilSetError(IL_COULD_NOT_OPEN_FILE);
++		return bVtf;
++	}
++
++	bVtf = ilLoadVtfF(VtfFile);
++	icloser(VtfFile);
++
++	return bVtf;
++}
++
++
++//! Reads an already-opened VTF file
++ILboolean ilLoadVtfF(ILHANDLE File) {
++	ILuint		FirstPos;
++	ILboolean	bRet;
++	
++	iSetInputFile(File);
++	FirstPos = itell();
++	bRet = iLoadVtfInternal();
++	iseek(FirstPos, IL_SEEK_SET);
++	
++	return bRet;
++}
++
++
++//! Reads from a memory "lump" that contains a VTF
++ILboolean ilLoadVtfL(const void *Lump, ILuint Size)
++{
++	iSetInputLump(Lump, Size);
++	return iLoadVtfInternal();
++}
++
++
++// Internal function used to load the VTF.
++ILboolean iLoadVtfInternal()
++{
++	ILboolean	bVtf = IL_TRUE;
++	ILimage		*Image, *BaseImage;
++	ILenum		Format, Type;
++	ILint		Frame, Mipmap;
++	ILuint		SizeOfData, Channels, k;
++	ILubyte		*CompData = NULL, SwapVal, *Data16Bit, *Temp;
++	VTFHEAD		Head;
++	ILuint		CurName;
++
++	if (iCurImage == NULL) {
++		ilSetError(IL_ILLEGAL_OPERATION);
++		return IL_FALSE;
++	}
++	CurName = ilGetCurName();
++	
++	if (!iGetVtfHead(&Head))
++		return IL_FALSE;
++	if (!iCheckVtf(&Head)) {
++		ilSetError(IL_INVALID_FILE_HEADER);
++		return IL_FALSE;
++	}
++
++	//@TODO: Take care of animation chains soon.
++	//if (Head.Frames > 1) {
++	//	ilSetError(IL_FORMAT_NOT_SUPPORTED);
++	//	return IL_FALSE;
++	//}
++	//@TODO: Find out how to tell whether the environment map is cubic or spherical.
++	if (Head.Flags & TEXTUREFLAGS_ENVMAP) {
++		ilSetError(IL_FORMAT_NOT_SUPPORTED);
++		return IL_FALSE;
++	}
++
++	// Skip the low resolution image.  This is just a thumbnail.
++	//  The block size is 8, and the compression ratio is 6:1.
++	SizeOfData = max(Head.LowResImageWidth * Head.LowResImageHeight / 2, 8);
++	iseek(SizeOfData, IL_SEEK_CUR);
++
++	//@TODO: Make this a helper function that set channels, bpc and format.
++	switch (Head.HighResImageFormat)
++	{
++		case IMAGE_FORMAT_DXT1:  //@TODO: Should we make DXT1 channels = 3?
++		case IMAGE_FORMAT_DXT1_ONEBITALPHA:
++		case IMAGE_FORMAT_DXT3:
++		case IMAGE_FORMAT_DXT5:
++			Channels = 4;
++			Format = IL_RGBA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGR888:
++		case IMAGE_FORMAT_BGR888_BLUESCREEN:
++			Channels = 3;
++			Format = IL_BGR;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGRA8888:
++			Channels = 4;
++			Format = IL_BGRA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGRX8888:
++			Channels = 3;
++			Format = IL_BGR;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_RGB888:
++		case IMAGE_FORMAT_RGB888_BLUESCREEN:
++			Channels = 3;
++			Format = IL_RGB;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_RGBA8888:
++			Channels = 4;
++			Format = IL_RGBA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_RGBA16161616:  // 16-bit shorts
++			Channels = 4;
++			Format = IL_RGBA;
++			Type = IL_UNSIGNED_SHORT;
++			break;
++		case IMAGE_FORMAT_RGBA16161616F:  // 16-bit floats
++			Channels = 4;
++			Format = IL_RGBA;
++			Type = IL_FLOAT;
++			break;
++		case IMAGE_FORMAT_I8:  // 8-bit luminance data
++			Channels = 1;
++			Format = IL_LUMINANCE;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_IA88:  // 8-bit luminance and alpha data
++			Channels = 2;
++			Format = IL_LUMINANCE_ALPHA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_A8:  // 8-bit alpha data
++			Channels = 1;
++			Format = IL_ALPHA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_ARGB8888:
++			Channels = 4;
++			Format = IL_BGRA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_ABGR8888:
++			Channels = 4;
++			Format = IL_RGBA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_RGB565:
++			Channels = 3;
++			Format = IL_RGB;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGR565:
++			Channels = 3;
++			Format = IL_BGR;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGRA5551:
++			Channels = 4;
++			Format = IL_BGRA;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++		case IMAGE_FORMAT_BGRX5551:  // Unused alpha channel
++			Channels = 3;
++			Format = IL_BGR;
++			Type = IL_UNSIGNED_BYTE;
++			break;
++
++		default:
++			ilSetError(IL_FORMAT_NOT_SUPPORTED);
++			return IL_FALSE;
++	}
++
++	if (!ilTexImage(Head.Width, Head.Height, Head.Depth, Channels, Format, Type, NULL))
++		return IL_FALSE;
++	// The origin should be in the upper left.
++	iCurImage->Origin = IL_ORIGIN_UPPER_LEFT;
++	// Create any mipmaps.
++	VtfInitMipmaps(iCurImage, &Head);
++
++	// Create our animation chain
++	BaseImage = Image = iCurImage;  // Top-level image
++	for (Frame = 1; Frame < Head.Frames; Frame++) {
++		Image->Next = ilNewImageFull(Head.Width, Head.Height, Head.Depth, Channels, Format, Type, NULL);
++		if (Image->Next == NULL)
++			return IL_FALSE;
++		Image = Image->Next;
++		// The origin should be in the upper left.
++		Image->Origin = IL_ORIGIN_UPPER_LEFT;
++
++		// Create our mipmaps for each frame.
++		VtfInitMipmaps(Image, &Head);
++	}
++
++	// We want to put the smallest mipmap at the end, but it is first in the file, so we count backwards.
++	for (Mipmap = Head.MipmapCount - 1; Mipmap >= 0; Mipmap--) {
++		// Frames are in the normal order.
++		for (Frame = 0; Frame < Head.Frames; Frame++) {
++			//@TODO: Would probably be quicker to do the linked list traversal manually here.
++			ilBindImage(CurName);
++			ilActiveImage(Frame);
++			ilActiveMipmap(Mipmap);
++			Image = iCurImage;
++
++			switch (Head.HighResImageFormat)
++			{
++				// DXT1 compression
++				case IMAGE_FORMAT_DXT1:
++				case IMAGE_FORMAT_DXT1_ONEBITALPHA:
++					// The block size is 8.
++					SizeOfData = max(Image->Width * Image->Height * Image->Depth / 2, 8);
++					CompData = ialloc(SizeOfData);  // Gives a 6:1 compression ratio (or 8:1 for DXT1 with alpha)
++					iread(CompData, 1, SizeOfData);
++					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
++						Image->DxtcSize = SizeOfData;
++						Image->DxtcData = CompData;
++						Image->DxtcFormat = IL_DXT5;
++						CompData = NULL;
++					}
++					bVtf = DecompressDXT1(Image, CompData);
++					break;
++
++				// DXT3 compression
++				case IMAGE_FORMAT_DXT3:
++					// The block size is 16.
++					SizeOfData = max(Image->Width * Image->Height * Image->Depth, 16);
++					CompData = ialloc(SizeOfData);  // Gives a 4:1 compression ratio
++					iread(CompData, 1, SizeOfData);
++					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
++						Image->DxtcSize = SizeOfData;
++						Image->DxtcData = CompData;
++						Image->DxtcFormat = IL_DXT3;
++						CompData = NULL;
++					}
++					bVtf = DecompressDXT3(Image, CompData);
++					break;
++
++				// DXT5 compression
++				case IMAGE_FORMAT_DXT5:
++					// The block size is 16.
++					SizeOfData = max(Image->Width * Image->Height * Image->Depth, 16);
++					CompData = ialloc(SizeOfData);  // Gives a 4:1 compression ratio
++					iread(CompData, 1, SizeOfData);
++					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
++						Image->DxtcSize = SizeOfData;
++						Image->DxtcData = CompData;
++						Image->DxtcFormat = IL_DXT5;
++						CompData = NULL;
++					}
++					bVtf = DecompressDXT5(Image, CompData);
++					break;
++
++				// Uncompressed BGR(A) data (24-bit and 32-bit)
++				case IMAGE_FORMAT_BGR888:
++				case IMAGE_FORMAT_BGRA8888:
++				// Uncompressed RGB(A) data (24-bit and 32-bit)
++				case IMAGE_FORMAT_RGB888:
++				case IMAGE_FORMAT_RGBA8888:
++				// Uncompressed 16-bit shorts
++				case IMAGE_FORMAT_RGBA16161616:
++				// Luminance data only
++				case IMAGE_FORMAT_I8:
++				// Luminance and alpha data
++				case IMAGE_FORMAT_IA88:
++				// Alpha data only
++				case IMAGE_FORMAT_A8:
++				// We will ignore the part about the bluescreen right now.
++				//   I could not find any information about it.
++				case IMAGE_FORMAT_RGB888_BLUESCREEN:
++				case IMAGE_FORMAT_BGR888_BLUESCREEN:
++					// Just copy the data over - no compression.
++					if (iread(Image->Data, 1, Image->SizeOfData) != Image->SizeOfData)
++						bVtf = IL_FALSE;
++					else
++						bVtf = IL_TRUE;
++					break;
++
++				// Uncompressed 24-bit data with an unused alpha channel (we discard it)
++				case IMAGE_FORMAT_BGRX8888:
++					SizeOfData = Image->Width * Image->Height * Image->Depth * 3;
++					Temp = CompData = ialloc(SizeOfData / 3 * 4);  // Not compressed data
++					if (iread(CompData, 1, SizeOfData / 3 * 4) != SizeOfData / 3 * 4) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					for (k = 0; k < SizeOfData; k += 3) {
++						Image->Data[k]   = Temp[0];
++						Image->Data[k+1] = Temp[1];
++						Image->Data[k+2] = Temp[2];
++						Temp += 4;
++					}
++
++					break;
++
++				// Uncompressed 16-bit floats (must be converted to 32-bit)
++				case IMAGE_FORMAT_RGBA16161616F:
++					SizeOfData = Image->Width * Image->Height * Image->Depth * Image->Bpp * 2;
++					CompData = ialloc(SizeOfData);  // Not compressed data
++					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					bVtf = iConvFloat16ToFloat32((ILuint*)Image->Data, (ILushort*)CompData, SizeOfData / 2);
++					break;
++
++				// Uncompressed 32-bit ARGB and ABGR data.  DevIL does not handle this
++				//   internally, so we have to swap values.
++				case IMAGE_FORMAT_ARGB8888:
++				case IMAGE_FORMAT_ABGR8888:
++					if (iread(Image->Data, 1, Image->SizeOfData) != Image->SizeOfData) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					else {
++						bVtf = IL_TRUE;
++					}
++					// Swap the data
++					for (k = 0; k < Image->SizeOfData; k += 4) {
++						SwapVal = Image->Data[k];
++						Image->Data[k]   = Image->Data[k+3];
++						Image->Data[k+3] = SwapVal;
++						SwapVal = Image->Data[k+1];
++						Image->Data[k+1] = Image->Data[k+2];
++						Image->Data[k+2] = SwapVal;
++					}
++					break;
++
++				// Uncompressed 16-bit RGB and BGR data.  We have to expand this to 24-bit, since
++				//   DevIL does not handle this internally.
++				//   The data is in the file as: gggbbbbb rrrrrrggg
++				case IMAGE_FORMAT_RGB565:
++				case IMAGE_FORMAT_BGR565:
++					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
++					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
++					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					for (k = 0; k < Image->SizeOfData; k += 3) {
++						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
++						Image->Data[k+1] = ((Data16Bit[1] & 0x07) << 5) | ((Data16Bit[0] & 0xE0) >> 3);
++						Image->Data[k+2] =   Data16Bit[1] & 0xF8;
++						Data16Bit += 2;
++					}
++					break;
++
++				// Uncompressed 16-bit BGRA data (1-bit alpha).  We have to expand this to 32-bit,
++				//   since DevIL does not handle this internally.
++				//   Something seems strange with this one, but this is how VTFEdit outputs.
++				//   The data is in the file as: gggbbbbb arrrrrgg
++				case IMAGE_FORMAT_BGRA5551:
++					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
++					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
++					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					for (k = 0; k < Image->SizeOfData; k += 4) {
++						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
++						Image->Data[k+1] = ((Data16Bit[0] & 0xE0) >> 2) | ((Data16Bit[1] & 0x03) << 6);
++						Image->Data[k+2] =  (Data16Bit[1] & 0x7C) << 1;
++						// 1-bit alpha is either off or on.
++						Image->Data[k+3] = ((Data16Bit[0] & 0x80) == 0x80) ? 0xFF : 0x00;
++						Data16Bit += 2;
++					}
++					break;
++
++				// Same as above, but the alpha channel is unused.
++				case IMAGE_FORMAT_BGRX5551:
++					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
++					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
++					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
++						bVtf = IL_FALSE;
++						break;
++					}
++					for (k = 0; k < Image->SizeOfData; k += 3) {
++						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
++						Image->Data[k+1] = ((Data16Bit[0] & 0xE0) >> 2) | ((Data16Bit[1] & 0x03) << 6);
++						Image->Data[k+2] =  (Data16Bit[1] & 0x7C) << 1;
++						Data16Bit += 2;
++					}
++					break;
++			}
++
++			ifree(CompData);
++			CompData = NULL;
++			if (bVtf == IL_FALSE)  //@TODO: Do we need to do any cleanup here?
++				return IL_FALSE;
++		}
++	}
++
++	ilBindImage(CurName);  // Set to parent image first.
++	return ilFixImage();
++}
++
++
++ILboolean VtfInitMipmaps(ILimage *BaseImage, VTFHEAD *Header)
++{
++	ILimage *Image;
++	ILuint Width, Height, Depth, Mipmap;
++
++	Image = BaseImage;
++	Width = BaseImage->Width;  Height = BaseImage->Height;  Depth = BaseImage->Depth;
++
++	for (Mipmap = 1; Mipmap < Header->MipmapCount; Mipmap++) {
++		// 1 is the smallest dimension possible.
++		Width = (Width >> 1) == 0 ? 1 : (Width >> 1);
++		Height = (Height >> 1) == 0 ? 1 : (Height >> 1);
++		Depth = (Depth >> 1) == 0 ? 1 : (Depth >> 1);
++
++		if (Mipmap == 1) {  // Our first mipmap is at Mipmap.
++			Image->Mipmaps = ilNewImage(Width, Height, Depth, BaseImage->Bpp, BaseImage->Bpc);
++			if (Image->Mipmaps == NULL)
++				return IL_FALSE;
++			Image = Image->Mipmaps;
++		}
++		else {  // The other mipmaps are at Mipmap->Next.
++			Image->Next = ilNewImage(Width, Height, Depth, BaseImage->Bpp, BaseImage->Bpc);
++			if (Image->Next == NULL)
++				return IL_FALSE;
++			Image = Image->Next;
++		}
++
++		// ilNewImage does not set these.
++		Image->Format = BaseImage->Format;
++		Image->Type = BaseImage->Type;
++		// The origin should be in the upper left.
++		Image->Origin = IL_ORIGIN_UPPER_LEFT;
++	}
++
++	return IL_TRUE;
++}
++
++#endif//IL_NO_VTF
+Index: devil/lib/Makefile.in
+===================================================================
+--- devil.orig/lib/Makefile.in	2009-01-10 20:54:50.000000000 +0000
++++ devil/lib/Makefile.in	2009-01-10 20:55:39.000000000 +0000
+@@ -111,7 +111,7 @@
+ 	$(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c \
+ 	$(il_src)/il_icns.c $(il_src)/il_jp2.c \
+ 	$(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c \
+-	$(il_include)/altivec_common.h \
++	$(il_src)/il_vtf.c $(il_include)/altivec_common.h \
+ 	$(il_include)/altivec_typeconversion.h \
+ 	$(il_include)/il_alloc.h $(il_include)/il_bits.h \
+ 	$(il_include)/il_bmp.h $(il_include)/il_dcx.h \
+@@ -131,18 +131,19 @@
+ 	$(il_include)/il_states.h $(il_include)/il_targa.h \
+ 	$(il_include)/il_wdp.h \
+ 	$(all_include)/IL/devil_internal_exports.h \
+-	$(ilu_src)/ilu_alloc.c $(ilu_src)/ilu_internal.c \
+-	$(ilu_src)/ilu_noise.c $(ilu_src)/ilu_scale.c \
+-	$(ilu_src)/ilu_error.c $(ilu_src)/ilu_main.c \
+-	$(ilu_src)/ilu_rotate.c $(ilu_src)/ilu_scaling.c \
+-	$(ilu_src)/ilu_filter.c $(ilu_src)/ilu_manip.c \
+-	$(ilu_src)/ilu_scale2d.c $(ilu_src)/ilu_states.c \
+-	$(ilu_src)/ilu_filter_rcg.c $(ilu_src)/ilu_mipmap.c \
+-	$(ilu_src)/ilu_scale3d.c $(ilu_src)/ilu_utilities.c \
+-	$(ilu_src)/ilu_region.c $(ilu_include)/ilu_alloc.h \
+-	$(ilu_include)/ilu_filter.h $(ilu_include)/ilu_internal.h \
+-	$(ilu_include)/ilu_mipmap.h $(ilu_include)/ilu_region.h \
+-	$(ilu_include)/ilu_states.h $(all_include)/IL/ilu_region.h \
++	$(il_include)/il_vtf.h $(ilu_src)/ilu_alloc.c \
++	$(ilu_src)/ilu_internal.c $(ilu_src)/ilu_noise.c \
++	$(ilu_src)/ilu_scale.c $(ilu_src)/ilu_error.c \
++	$(ilu_src)/ilu_main.c $(ilu_src)/ilu_rotate.c \
++	$(ilu_src)/ilu_scaling.c $(ilu_src)/ilu_filter.c \
++	$(ilu_src)/ilu_manip.c $(ilu_src)/ilu_scale2d.c \
++	$(ilu_src)/ilu_states.c $(ilu_src)/ilu_filter_rcg.c \
++	$(ilu_src)/ilu_mipmap.c $(ilu_src)/ilu_scale3d.c \
++	$(ilu_src)/ilu_utilities.c $(ilu_src)/ilu_region.c \
++	$(ilu_include)/ilu_alloc.h $(ilu_include)/ilu_filter.h \
++	$(ilu_include)/ilu_internal.h $(ilu_include)/ilu_mipmap.h \
++	$(ilu_include)/ilu_region.h $(ilu_include)/ilu_states.h \
++	$(all_include)/IL/ilu_region.h \
+ 	$(ilu_include)/ilu_error/ilu_err-arabic.h \
+ 	$(ilu_include)/ilu_error/ilu_err-dutch.h \
+ 	$(ilu_include)/ilu_error/ilu_err-english.h \
+@@ -184,7 +185,7 @@
+ 	libDevIL_la-il_pxr.lo libDevIL_la-il_xpm.lo \
+ 	libDevIL_la-il_hdr.lo libDevIL_la-il_icns.lo \
+ 	libDevIL_la-il_jp2.lo libDevIL_la-altivec_common.lo \
+-	libDevIL_la-altivec_typeconversion.lo
++	libDevIL_la-altivec_typeconversion.lo libDevIL_la-il_vtf.lo
+ @BUILD_IL_TRUE@@BUILD_MONOLITHIC_TRUE@am__objects_2 =  \
+ @BUILD_IL_TRUE@@BUILD_MONOLITHIC_TRUE@	$(am__objects_1)
+ am__objects_3 = libDevIL_la-ilu_alloc.lo libDevIL_la-ilu_internal.lo \
+@@ -240,7 +241,8 @@
+ 	libIL_la-il_dds-save.lo libIL_la-il_psp.lo libIL_la-il_pix.lo \
+ 	libIL_la-il_pxr.lo libIL_la-il_xpm.lo libIL_la-il_hdr.lo \
+ 	libIL_la-il_icns.lo libIL_la-il_jp2.lo \
+-	libIL_la-altivec_common.lo libIL_la-altivec_typeconversion.lo
++	libIL_la-altivec_common.lo libIL_la-altivec_typeconversion.lo \
++	libIL_la-il_vtf.lo
+ libIL_la_OBJECTS = $(am_libIL_la_OBJECTS)
+ libIL_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+ 	--mode=link $(CCLD) $(libIL_la_CFLAGS) $(CFLAGS) \
+@@ -505,7 +507,7 @@
+ 	$(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c \
+ 	$(il_src)/il_icns.c $(il_src)/il_jp2.c \
+ 	$(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c \
+-	$(il_include)/altivec_common.h \
++	$(il_src)/il_vtf.c $(il_include)/altivec_common.h \
+ 	$(il_include)/altivec_typeconversion.h \
+ 	$(il_include)/il_alloc.h $(il_include)/il_bits.h \
+ 	$(il_include)/il_bmp.h $(il_include)/il_dcx.h \
+@@ -524,7 +526,8 @@
+ 	$(il_include)/il_sgi.h $(il_include)/il_stack.h \
+ 	$(il_include)/il_states.h $(il_include)/il_targa.h \
+ 	$(il_include)/il_wdp.h \
+-	$(all_include)/IL/devil_internal_exports.h
++	$(all_include)/IL/devil_internal_exports.h \
++	$(il_include)/il_vtf.h
+ libIL_la_LDFLAGS = @IL_LIBS@ $(AM_LDFLAGS)
+ libILU_la_CPPFLAGS = -I $(ilu_include) -I $(all_include)
+ libILU_la_CFLAGS = $(CFLAGS) @ILU_CFLAGS@
+@@ -689,6 +692,7 @@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_targa.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_tiff.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_utility.Plo@am__quote@
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_vtf.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_wal.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_wdp.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_xpm.Plo@am__quote@
+@@ -800,6 +804,7 @@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_targa.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_tiff.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_utility.Plo@am__quote@
++@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_vtf.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_wal.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_wdp.Plo@am__quote@
+ @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_xpm.Plo@am__quote@
+@@ -1224,6 +1229,13 @@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -c -o libDevIL_la-altivec_typeconversion.lo `test -f '$(il_src)/altivec_typeconversion.c' || echo '$(srcdir)/'`$(il_src)/altivec_typeconversion.c
+ 
++libDevIL_la-il_vtf.lo: $(il_src)/il_vtf.c
++@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -MT libDevIL_la-il_vtf.lo -MD -MP -MF $(DEPDIR)/libDevIL_la-il_vtf.Tpo -c -o libDevIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
++@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libDevIL_la-il_vtf.Tpo $(DEPDIR)/libDevIL_la-il_vtf.Plo
++@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(il_src)/il_vtf.c' object='libDevIL_la-il_vtf.lo' libtool=yes @AMDEPBACKSLASH@
++@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
++@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -c -o libDevIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
++
+ libDevIL_la-ilu_alloc.lo: $(ilu_src)/ilu_alloc.c
+ @am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -MT libDevIL_la-ilu_alloc.lo -MD -MP -MF $(DEPDIR)/libDevIL_la-ilu_alloc.Tpo -c -o libDevIL_la-ilu_alloc.lo `test -f '$(ilu_src)/ilu_alloc.c' || echo '$(srcdir)/'`$(ilu_src)/ilu_alloc.c
+ @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libDevIL_la-ilu_alloc.Tpo $(DEPDIR)/libDevIL_la-ilu_alloc.Plo
+@@ -1812,6 +1824,13 @@
+ @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -c -o libIL_la-altivec_typeconversion.lo `test -f '$(il_src)/altivec_typeconversion.c' || echo '$(srcdir)/'`$(il_src)/altivec_typeconversion.c
+ 
++libIL_la-il_vtf.lo: $(il_src)/il_vtf.c
++@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -MT libIL_la-il_vtf.lo -MD -MP -MF $(DEPDIR)/libIL_la-il_vtf.Tpo -c -o libIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
++@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libIL_la-il_vtf.Tpo $(DEPDIR)/libIL_la-il_vtf.Plo
++@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(il_src)/il_vtf.c' object='libIL_la-il_vtf.lo' libtool=yes @AMDEPBACKSLASH@
++@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
++@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -c -o libIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
++
+ libILU_la-ilu_alloc.lo: $(ilu_src)/ilu_alloc.c
+ @am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libILU_la_CPPFLAGS) $(CPPFLAGS) $(libILU_la_CFLAGS) $(CFLAGS) -MT libILU_la-ilu_alloc.lo -MD -MP -MF $(DEPDIR)/libILU_la-ilu_alloc.Tpo -c -o libILU_la-ilu_alloc.lo `test -f '$(ilu_src)/ilu_alloc.c' || echo '$(srcdir)/'`$(ilu_src)/ilu_alloc.c
+ @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libILU_la-ilu_alloc.Tpo $(DEPDIR)/libILU_la-ilu_alloc.Plo
--- devil-1.7.5.orig/debian/patches/01_fix_as-needed.diff
+++ devil-1.7.5/debian/patches/01_fix_as-needed.diff
@@ -0,0 +1,32 @@
+Index: devil/build-aux/ltmain.sh
+===================================================================
+--- devil.orig/build-aux/ltmain.sh	2008-12-30 21:05:37.000000000 +0000
++++ devil/build-aux/ltmain.sh	2008-12-30 21:09:12.000000000 +0000
+@@ -4189,6 +4189,11 @@
+ 	arg=$func_stripname_result
+ 	;;
+ 
++    -Wl,--as-needed)
++        deplibs="$deplibs $arg"
++        continue
++    ;;
++
+       -Wl,*)
+ 	func_stripname '-Wl,' '' "$arg"
+ 	args=$func_stripname_result
+@@ -4543,6 +4548,15 @@
+ 	lib=
+ 	found=no
+ 	case $deplib in
++    -Wl,--as-needed)
++        if test "$linkmode,$pass" = "prog,link"; then
++            compile_deplibs="$deplib $compile_deplibs"
++            finalize_deplibs="$deplib $finalize_deplibs"
++        else
++            deplibs="$deplib $deplibs"
++        fi
++        continue
++    ;;
+ 	-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)
+ 	  if test "$linkmode,$pass" = "prog,link"; then
+ 	    compile_deplibs="$deplib $compile_deplibs"
--- devil-1.7.5.orig/debian/patches/series
+++ devil-1.7.5/debian/patches/series
@@ -0,0 +1,4 @@
+00_endian_and_ILvoid_fixes.diff
+01_fix_as-needed.diff
+02_add_missing_files.diff
+03_CVE-2008-5262.diff
--- devil-1.7.5.orig/debian/patches/03_CVE-2008-5262.diff
+++ devil-1.7.5/debian/patches/03_CVE-2008-5262.diff
@@ -0,0 +1,36 @@
+Index: devil/src-IL/src/il_hdr.c
+===================================================================
+--- devil.orig/src-IL/src/il_hdr.c	2009-01-15 18:47:34.000000000 +0000
++++ devil/src-IL/src/il_hdr.c	2009-01-15 18:47:46.000000000 +0000
+@@ -85,7 +85,7 @@
+ 	if (iread(&a, 1, 1) != 1)
+ 		return IL_FALSE;
+ 
+-	while(!done) {
++	while (!done) {
+ 		if (iread(&b, 1, 1) != 1)
+ 			return IL_FALSE;
+ 		if (b == '\n' && a == '\n')
+@@ -98,6 +98,10 @@
+ 	if (iread(&a, 1, 1) != 1)
+ 		return IL_FALSE;
+ 	while (a != '\n') {
++		if (count >= sizeof(buff) - 1) {  // Line shouldn't be this long at all.
++			ilSetError(IL_INVALID_FILE_HEADER);
++			return IL_FALSE;
++		}
+ 		buff[count] = a;
+ 		if (iread(&a, 1, 1) != 1)
+ 			return IL_FALSE;
+@@ -113,8 +117,9 @@
+ 	//nothing that really changes the appearance of the loaded image...
+ 	//(The code as it is now assumes that y contains "-Y" and x contains
+ 	//"+X" after the following line)
+-	//Furthermore, this crashes if the read strings are longer than 2 chars o_O
+-	sscanf(buff, "%s %d %s %d", y, &Header->Height, x, &Header->Width);
++
++	// The 2 has to be in the %s format specifier to prevent buffer overruns.
++	sscanf(buff, "%2s %d %2s %d", y, &Header->Height, x, &Header->Width);
+ 
+ 	return IL_TRUE;
+ }

