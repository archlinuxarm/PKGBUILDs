
Index: devil/lib/Makefile.am
===================================================================
--- devil.orig/lib/Makefile.am	2009-01-10 20:43:26.000000000 +0000
+++ devil/lib/Makefile.am	2009-01-10 20:54:27.000000000 +0000
@@ -69,8 +69,8 @@
 
 libIL_la_CPPFLAGS = -I $(il_include) -I $(all_include)
 libIL_la_CFLAGS = $(CFLAGS) @IL_CFLAGS@
-libIL_la_SOURCES = $(il_src)/il_alloc.c $(il_src)/il_doom.c $(il_src)/il_stack.c $(il_src)/il_pcx.c $(il_src)/il_rle.c $(il_src)/il_bits.c $(il_src)/il_endian.c $(il_src)/il_jpeg.c $(il_src)/il_pic.c $(il_src)/il_sgi.c $(il_src)/il_bmp.c $(il_src)/il_error.c $(il_src)/il_lif.c $(il_src)/il_png.c $(il_src)/il_states.c $(il_src)/il_convbuff.c $(il_src)/il_files.c $(il_src)/il_main.c $(il_src)/il_pnm.c $(il_src)/il_targa.c $(il_src)/il_wdp.c $(il_src)/il_convert.c $(il_src)/il_gif.c $(il_src)/il_manip.c $(il_src)/il_profiles.c $(il_src)/il_tiff.c $(il_src)/il_cut.c $(il_src)/il_header.c $(il_src)/il_mdl.c $(il_src)/il_quantizer.c $(il_src)/il_utility.c $(il_src)/il_dcx.c $(il_src)/il_icon.c $(il_src)/il_mng.c $(il_src)/il_raw.c $(il_src)/il_wal.c $(il_src)/il_dds.c $(il_src)/il_internal.c $(il_src)/il_pal.c $(il_src)/il_rawdata.c $(il_src)/il_devil.c $(il_src)/il_io.c $(il_src)/il_pcd.c $(il_src)/il_register.c $(il_src)/il_psd.c $(il_src)/il_fastconv.c $(il_src)/il_neuquant.c $(il_src)/il_dds-save.c $(il_src)/il_psp.c $(il_src)/il_pix.c $(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c $(il_src)/il_icns.c $(il_src)/il_jp2.c $(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c
-libIL_la_SOURCES += $(il_include)/altivec_common.h $(il_include)/altivec_typeconversion.h $(il_include)/il_alloc.h $(il_include)/il_bits.h $(il_include)/il_bmp.h $(il_include)/il_dcx.h $(il_include)/il_dds.h $(il_include)/il_doompal.h $(il_include)/il_endian.h $(il_include)/il_exr.h $(il_include)/il_files.h $(il_include)/il_gif.h $(il_include)/il_hdr.h $(il_include)/il_icns.h $(il_include)/il_icon.h $(il_include)/il_internal.h $(il_include)/il_jp2.h $(il_include)/il_jpeg.h $(il_include)/il_lif.h $(il_include)/il_manip.h $(il_include)/il_mdl.h $(il_include)/il_pal.h $(il_include)/il_pcx.h $(il_include)/il_pic.h $(il_include)/il_pnm.h $(il_include)/il_psd.h $(il_include)/il_psp.h $(il_include)/il_q2pal.h $(il_include)/il_register.h $(il_include)/il_rle.h $(il_include)/il_sgi.h $(il_include)/il_stack.h $(il_include)/il_states.h $(il_include)/il_targa.h $(il_include)/il_wdp.h $(all_include)/IL/devil_internal_exports.h
+libIL_la_SOURCES = $(il_src)/il_alloc.c $(il_src)/il_doom.c $(il_src)/il_stack.c $(il_src)/il_pcx.c $(il_src)/il_rle.c $(il_src)/il_bits.c $(il_src)/il_endian.c $(il_src)/il_jpeg.c $(il_src)/il_pic.c $(il_src)/il_sgi.c $(il_src)/il_bmp.c $(il_src)/il_error.c $(il_src)/il_lif.c $(il_src)/il_png.c $(il_src)/il_states.c $(il_src)/il_convbuff.c $(il_src)/il_files.c $(il_src)/il_main.c $(il_src)/il_pnm.c $(il_src)/il_targa.c $(il_src)/il_wdp.c $(il_src)/il_convert.c $(il_src)/il_gif.c $(il_src)/il_manip.c $(il_src)/il_profiles.c $(il_src)/il_tiff.c $(il_src)/il_cut.c $(il_src)/il_header.c $(il_src)/il_mdl.c $(il_src)/il_quantizer.c $(il_src)/il_utility.c $(il_src)/il_dcx.c $(il_src)/il_icon.c $(il_src)/il_mng.c $(il_src)/il_raw.c $(il_src)/il_wal.c $(il_src)/il_dds.c $(il_src)/il_internal.c $(il_src)/il_pal.c $(il_src)/il_rawdata.c $(il_src)/il_devil.c $(il_src)/il_io.c $(il_src)/il_pcd.c $(il_src)/il_register.c $(il_src)/il_psd.c $(il_src)/il_fastconv.c $(il_src)/il_neuquant.c $(il_src)/il_dds-save.c $(il_src)/il_psp.c $(il_src)/il_pix.c $(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c $(il_src)/il_icns.c $(il_src)/il_jp2.c $(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c $(il_src)/il_vtf.c
+libIL_la_SOURCES += $(il_include)/altivec_common.h $(il_include)/altivec_typeconversion.h $(il_include)/il_alloc.h $(il_include)/il_bits.h $(il_include)/il_bmp.h $(il_include)/il_dcx.h $(il_include)/il_dds.h $(il_include)/il_doompal.h $(il_include)/il_endian.h $(il_include)/il_exr.h $(il_include)/il_files.h $(il_include)/il_gif.h $(il_include)/il_hdr.h $(il_include)/il_icns.h $(il_include)/il_icon.h $(il_include)/il_internal.h $(il_include)/il_jp2.h $(il_include)/il_jpeg.h $(il_include)/il_lif.h $(il_include)/il_manip.h $(il_include)/il_mdl.h $(il_include)/il_pal.h $(il_include)/il_pcx.h $(il_include)/il_pic.h $(il_include)/il_pnm.h $(il_include)/il_psd.h $(il_include)/il_psp.h $(il_include)/il_q2pal.h $(il_include)/il_register.h $(il_include)/il_rle.h $(il_include)/il_sgi.h $(il_include)/il_stack.h $(il_include)/il_states.h $(il_include)/il_targa.h $(il_include)/il_wdp.h $(all_include)/IL/devil_internal_exports.h $(il_include)/il_vtf.h
 libIL_la_LDFLAGS = @IL_LIBS@ $(AM_LDFLAGS)
 
 libILU_la_CPPFLAGS = -I $(ilu_include) -I $(all_include)
Index: devil/src-IL/include/il_vtf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ devil/src-IL/include/il_vtf.h	2009-01-10 20:54:27.000000000 +0000
@@ -0,0 +1,130 @@
+//-----------------------------------------------------------------------------
+//
+// ImageLib Sources
+// Copyright (C) 2000-2008 by Denton Woods
+// Last modified: 12/27/2008
+//
+// Filename: src-IL/include/il_vtf.h
+//
+// Description: Reads from and writes to a Valve Texture Format (.vtf) file.
+//                These are used in Valve's Source games.  VTF specs available
+//                from http://developer.valvesoftware.com/wiki/VTF.
+//
+//-----------------------------------------------------------------------------
+
+
+#ifndef VTF_H
+#define VTF_H
+
+#include "il_internal.h"
+
+#ifdef _MSC_VER
+#pragma pack(push, vtf_struct, 1)
+#elif defined(MACOSX) || defined(__GNUC__)
+#pragma pack(1)
+#endif
+
+typedef struct VTFHEAD
+{
+	ILubyte		Signature[4];		// File signature ("VTF\0").
+	ILuint		Version[2];			// version[0].version[1] (currently 7.2).
+	ILuint		HeaderSize;			// Size of the header struct (16 byte aligned; currently 80 bytes).
+	ILushort	Width;				// Width of the largest mipmap in pixels. Must be a power of 2.
+	ILushort	Height;				// Height of the largest mipmap in pixels. Must be a power of 2.
+	ILuint		Flags;				// VTF flags.
+	ILushort	Frames;				// Number of frames, if animated (1 for no animation).
+	ILushort	FirstFrame;			// First frame in animation (0 based).
+	ILubyte		Padding0[4];		// reflectivity padding (16 byte alignment).
+	ILfloat		Reflectivity[3];	// reflectivity vector.
+	ILubyte		Padding1[4];		// reflectivity padding (8 byte packing).
+	ILfloat		BumpmapScale;		// Bumpmap scale.
+	ILuint		HighResImageFormat;	// High resolution image format.
+	ILubyte		MipmapCount;		// Number of mipmaps.
+	ILint		LowResImageFormat;	// Low resolution image format (always DXT1).
+	ILubyte		LowResImageWidth;	// Low resolution image width.
+	ILubyte		LowResImageHeight;	// Low resolution image height.
+	ILushort	Depth;				// Depth of the largest mipmap in pixels.
+									// Must be a power of 2. Can be 0 or 1 for a 2D texture (v7.2 only).
+} IL_PACKSTRUCT VTFHEAD;
+
+#if defined(MACOSX) || defined(__GNUC__)
+#pragma pack()
+#elif _MSC_VER
+#pragma pack(pop, vtf_struct)
+#endif
+
+enum
+{
+	IMAGE_FORMAT_NONE = -1,
+	IMAGE_FORMAT_RGBA8888 = 0,
+	IMAGE_FORMAT_ABGR8888,
+	IMAGE_FORMAT_RGB888,
+	IMAGE_FORMAT_BGR888,
+	IMAGE_FORMAT_RGB565,
+	IMAGE_FORMAT_I8,
+	IMAGE_FORMAT_IA88,
+	IMAGE_FORMAT_P8,
+	IMAGE_FORMAT_A8,
+	IMAGE_FORMAT_RGB888_BLUESCREEN,
+	IMAGE_FORMAT_BGR888_BLUESCREEN,
+	IMAGE_FORMAT_ARGB8888,
+	IMAGE_FORMAT_BGRA8888,
+	IMAGE_FORMAT_DXT1,
+	IMAGE_FORMAT_DXT3,
+	IMAGE_FORMAT_DXT5,
+	IMAGE_FORMAT_BGRX8888,
+	IMAGE_FORMAT_BGR565,
+	IMAGE_FORMAT_BGRX5551,
+	IMAGE_FORMAT_BGRA4444,
+	IMAGE_FORMAT_DXT1_ONEBITALPHA,
+	IMAGE_FORMAT_BGRA5551,
+	IMAGE_FORMAT_UV88,
+	IMAGE_FORMAT_UVWQ8888,
+	IMAGE_FORMAT_RGBA16161616F,
+	IMAGE_FORMAT_RGBA16161616,
+	IMAGE_FORMAT_UVLX8888
+};
+
+enum
+{
+	TEXTUREFLAGS_POINTSAMPLE = 0x00000001,
+	TEXTUREFLAGS_TRILINEAR = 0x00000002,
+	TEXTUREFLAGS_CLAMPS = 0x00000004,
+	TEXTUREFLAGS_CLAMPT = 0x00000008,
+	TEXTUREFLAGS_ANISOTROPIC = 0x00000010,
+	TEXTUREFLAGS_HINT_DXT5 = 0x00000020,
+	TEXTUREFLAGS_NOCOMPRESS = 0x00000040,
+	TEXTUREFLAGS_NORMAL = 0x00000080,
+	TEXTUREFLAGS_NOMIP = 0x00000100,
+	TEXTUREFLAGS_NOLOD = 0x00000200,
+	TEXTUREFLAGS_MINMIP = 0x00000400,
+	TEXTUREFLAGS_PROCEDURAL = 0x00000800,
+	TEXTUREFLAGS_ONEBITALPHA = 0x00001000,
+	TEXTUREFLAGS_EIGHTBITALPHA = 0x00002000,
+	TEXTUREFLAGS_ENVMAP = 0x00004000,
+	TEXTUREFLAGS_RENDERTARGET = 0x00008000,
+	TEXTUREFLAGS_DEPTHRENDERTARGET = 0x00010000,
+	TEXTUREFLAGS_NODEBUGOVERRIDE = 0x00020000,
+	TEXTUREFLAGS_SINGLECOPY = 0x00040000,
+	TEXTUREFLAGS_ONEOVERMIPLEVELINALPHA = 0x00080000,
+	TEXTUREFLAGS_PREMULTCOLORBYONEOVERMIPLEVEL = 0x00100000,
+	TEXTUREFLAGS_NORMALTODUDV = 0x00200000,
+	TEXTUREFLAGS_ALPHATESTMIPGENERATION = 0x00400000,
+	TEXTUREFLAGS_NODEPTHBUFFER = 0x00800000,
+	TEXTUREFLAGS_NICEFILTERED = 0x01000000,
+	TEXTUREFLAGS_CLAMPU = 0x02000000
+};
+
+
+
+// Internal functions
+ILboolean	iIsValidVtf(void);
+ILboolean	iGetVtfHead(VTFHEAD *Header);
+ILboolean	iCheckVtf(VTFHEAD *Header);
+ILboolean	iLoadVtfInternal(void);
+ILboolean	VtfInitMipmaps(ILimage *BaseImage, VTFHEAD *Header);
+ILboolean	VtfReadData(void);
+ILboolean	VtfDecompressDXT1(ILimage *Image);
+ILboolean	VtfDecompressDXT5(ILimage *Image);
+
+#endif//VTF_H
Index: devil/src-IL/src/il_vtf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ devil/src-IL/src/il_vtf.c	2009-01-10 20:54:27.000000000 +0000
@@ -0,0 +1,612 @@
+//-----------------------------------------------------------------------------
+//
+// ImageLib Sources
+// Copyright (C) 2000-2008 by Denton Woods
+// Last modified: 12/29/2008
+//
+// Filename: src-IL/src/il_vtf.c
+//
+// Description: Reads from and writes to a Valve Texture Format (.vtf) file.
+//                These are used in Valve's Source games.  VTF specs available
+//                from http://developer.valvesoftware.com/wiki/VTF.
+//
+//-----------------------------------------------------------------------------
+
+
+#include "il_internal.h"
+#ifndef IL_NO_VTF
+#include "il_vtf.h"
+#include "il_dds.h"
+
+// the max and min functions are not present, at least not on unixes
+#ifndef max
+	#define max( a, b ) ( ((a) > (b)) ? (a) : (b) )
+#endif
+
+#ifndef min
+	#define min( a, b ) ( ((a) < (b)) ? (a) : (b) )
+#endif
+
+//@TODO: Get rid of these globals.
+//static VTFHEAD Head;
+
+
+//! Checks if the file specified in FileName is a valid VTF file.
+ILboolean ilIsValidVtf(ILconst_string FileName)
+{
+	ILHANDLE	VtfFile;
+	ILboolean	bVtf = IL_FALSE;
+	
+	if (!iCheckExtension(FileName, IL_TEXT("vtf"))) {
+		ilSetError(IL_INVALID_EXTENSION);
+		return bVtf;
+	}
+	
+	VtfFile = iopenr(FileName);
+	if (VtfFile == NULL) {
+		ilSetError(IL_COULD_NOT_OPEN_FILE);
+		return bVtf;
+	}
+	
+	bVtf = ilIsValidVtfF(VtfFile);
+	icloser(VtfFile);
+	
+	return bVtf;
+}
+
+
+//! Checks if the ILHANDLE contains a valid VTF file at the current position.
+ILboolean ilIsValidVtfF(ILHANDLE File)
+{
+	ILuint		FirstPos;
+	ILboolean	bRet;
+	
+	iSetInputFile(File);
+	FirstPos = itell();
+	bRet = iIsValidVtf();
+	iseek(FirstPos, IL_SEEK_SET);
+	
+	return bRet;
+}
+
+
+//! Checks if Lump is a valid VTF lump.
+ILboolean ilIsValidVtfL(const void *Lump, ILuint Size)
+{
+	iSetInputLump(Lump, Size);
+	return iIsValidVtf();
+}
+
+
+// Internal function used to get the VTF header from the current file.
+ILboolean iGetVtfHead(VTFHEAD *Header)
+{
+	iread(Header->Signature, 1, 4);
+	Header->Version[0] = GetLittleUInt();
+	Header->Version[1] = GetLittleUInt();
+	Header->HeaderSize = GetLittleUInt();
+	Header->Width = GetLittleUShort();
+	Header->Height = GetLittleUShort();
+	Header->Flags = GetLittleUInt();
+	Header->Frames = GetLittleUShort();
+	Header->FirstFrame = GetLittleUShort();
+	iseek(4, IL_SEEK_CUR);  // Padding
+	Header->Reflectivity[0] = GetLittleFloat();
+	Header->Reflectivity[1] = GetLittleFloat();
+	Header->Reflectivity[2] = GetLittleFloat();
+	iseek(4, IL_SEEK_CUR);  // Padding
+	Header->BumpmapScale = GetLittleFloat();
+	Header->HighResImageFormat = GetLittleUInt();
+	Header->MipmapCount = (ILubyte)igetc();
+	Header->LowResImageFormat = GetLittleInt();
+	Header->LowResImageWidth = (ILubyte)igetc();
+	Header->LowResImageHeight = (ILubyte)igetc();
+	Header->Depth = GetLittleUShort();
+
+	iseek(Header->HeaderSize - sizeof(VTFHEAD), IL_SEEK_CUR);
+
+	return IL_TRUE;
+}
+
+
+// Internal function to get the header and check it.
+ILboolean iIsValidVtf()
+{
+	VTFHEAD Head;
+
+	if (!iGetVtfHead(&Head))
+		return IL_FALSE;
+	iseek(-(ILint)sizeof(VTFHEAD), IL_SEEK_CUR);
+	
+	return iCheckVtf(&Head);
+}
+
+
+//@TODO: Add more checks.
+// Should we check for Frames, MipmapCount and Depth != 0?
+
+// Internal function used to check if the HEADER is a valid VTF header.
+ILboolean iCheckVtf(VTFHEAD *Header)
+{
+	// The file signature is "VTF\0".
+	if ((Header->Signature[0] != 'V') || (Header->Signature[1] != 'T') || (Header->Signature[2] != 'F')
+		|| (Header->Signature[3] != 0))
+		return IL_FALSE;
+	// Are there other versions available yet?
+	if (Header->Version[0] != 7)
+		return IL_FALSE;
+	// We have 7.0 through 7.4 as of 12/27/2008.
+	if (Header->Version[1] > 4)
+		return IL_FALSE;
+	// May change in future version of the specifications.
+	//  80 is through version 7.2, and 96/104 are through 7.4.
+	//  This must be 16-byte aligned, but something is outputting headers with 104.
+	if ((Header->HeaderSize != 80) && (Header->HeaderSize != 96) && (Header->HeaderSize != 104))
+		return IL_FALSE;
+
+	// 0 is an invalid dimension
+	if (Header->Width == 0 || Header->Height == 0)
+		return IL_FALSE;
+	// Width and Height must be powers of 2.
+	if ((ilNextPower2(Header->Width) != Header->Width) || (ilNextPower2(Header->Height) != Header->Height))
+		return IL_FALSE;
+	if ((ilNextPower2(Header->LowResImageWidth) != Header->LowResImageWidth)
+		|| (ilNextPower2(Header->LowResImageHeight) != Header->LowResImageHeight))
+		return IL_FALSE;
+	// In addition, the LowResImage has to have dimensions no greater than 16.
+	if ((Header->LowResImageWidth > 16) || (Header->LowResImageHeight > 16)
+		|| (Header->LowResImageWidth == 0) || (Header->LowResImageHeight == 0))
+		return IL_FALSE;
+	// And the LowResImage has to have dimensions less than or equal to the main image.
+	if ((Header->LowResImageWidth > Header->Width) || (Header->LowResImageHeight > Header->Height))
+		return IL_FALSE;
+	// The LowResImage must be in DXT1 format.
+	if (Header->LowResImageFormat != IMAGE_FORMAT_DXT1)
+		return IL_FALSE;
+	
+	return IL_TRUE;
+}
+
+
+//! Reads a VTF file
+ILboolean ilLoadVtf(ILconst_string FileName)
+{
+	ILHANDLE	VtfFile;
+	ILboolean	bVtf = IL_FALSE;
+	
+	VtfFile = iopenr(FileName);
+	if (VtfFile == NULL) {
+		ilSetError(IL_COULD_NOT_OPEN_FILE);
+		return bVtf;
+	}
+
+	bVtf = ilLoadVtfF(VtfFile);
+	icloser(VtfFile);
+
+	return bVtf;
+}
+
+
+//! Reads an already-opened VTF file
+ILboolean ilLoadVtfF(ILHANDLE File) {
+	ILuint		FirstPos;
+	ILboolean	bRet;
+	
+	iSetInputFile(File);
+	FirstPos = itell();
+	bRet = iLoadVtfInternal();
+	iseek(FirstPos, IL_SEEK_SET);
+	
+	return bRet;
+}
+
+
+//! Reads from a memory "lump" that contains a VTF
+ILboolean ilLoadVtfL(const void *Lump, ILuint Size)
+{
+	iSetInputLump(Lump, Size);
+	return iLoadVtfInternal();
+}
+
+
+// Internal function used to load the VTF.
+ILboolean iLoadVtfInternal()
+{
+	ILboolean	bVtf = IL_TRUE;
+	ILimage		*Image, *BaseImage;
+	ILenum		Format, Type;
+	ILint		Frame, Mipmap;
+	ILuint		SizeOfData, Channels, k;
+	ILubyte		*CompData = NULL, SwapVal, *Data16Bit, *Temp;
+	VTFHEAD		Head;
+	ILuint		CurName;
+
+	if (iCurImage == NULL) {
+		ilSetError(IL_ILLEGAL_OPERATION);
+		return IL_FALSE;
+	}
+	CurName = ilGetCurName();
+	
+	if (!iGetVtfHead(&Head))
+		return IL_FALSE;
+	if (!iCheckVtf(&Head)) {
+		ilSetError(IL_INVALID_FILE_HEADER);
+		return IL_FALSE;
+	}
+
+	//@TODO: Take care of animation chains soon.
+	//if (Head.Frames > 1) {
+	//	ilSetError(IL_FORMAT_NOT_SUPPORTED);
+	//	return IL_FALSE;
+	//}
+	//@TODO: Find out how to tell whether the environment map is cubic or spherical.
+	if (Head.Flags & TEXTUREFLAGS_ENVMAP) {
+		ilSetError(IL_FORMAT_NOT_SUPPORTED);
+		return IL_FALSE;
+	}
+
+	// Skip the low resolution image.  This is just a thumbnail.
+	//  The block size is 8, and the compression ratio is 6:1.
+	SizeOfData = max(Head.LowResImageWidth * Head.LowResImageHeight / 2, 8);
+	iseek(SizeOfData, IL_SEEK_CUR);
+
+	//@TODO: Make this a helper function that set channels, bpc and format.
+	switch (Head.HighResImageFormat)
+	{
+		case IMAGE_FORMAT_DXT1:  //@TODO: Should we make DXT1 channels = 3?
+		case IMAGE_FORMAT_DXT1_ONEBITALPHA:
+		case IMAGE_FORMAT_DXT3:
+		case IMAGE_FORMAT_DXT5:
+			Channels = 4;
+			Format = IL_RGBA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGR888:
+		case IMAGE_FORMAT_BGR888_BLUESCREEN:
+			Channels = 3;
+			Format = IL_BGR;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGRA8888:
+			Channels = 4;
+			Format = IL_BGRA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGRX8888:
+			Channels = 3;
+			Format = IL_BGR;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_RGB888:
+		case IMAGE_FORMAT_RGB888_BLUESCREEN:
+			Channels = 3;
+			Format = IL_RGB;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_RGBA8888:
+			Channels = 4;
+			Format = IL_RGBA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_RGBA16161616:  // 16-bit shorts
+			Channels = 4;
+			Format = IL_RGBA;
+			Type = IL_UNSIGNED_SHORT;
+			break;
+		case IMAGE_FORMAT_RGBA16161616F:  // 16-bit floats
+			Channels = 4;
+			Format = IL_RGBA;
+			Type = IL_FLOAT;
+			break;
+		case IMAGE_FORMAT_I8:  // 8-bit luminance data
+			Channels = 1;
+			Format = IL_LUMINANCE;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_IA88:  // 8-bit luminance and alpha data
+			Channels = 2;
+			Format = IL_LUMINANCE_ALPHA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_A8:  // 8-bit alpha data
+			Channels = 1;
+			Format = IL_ALPHA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_ARGB8888:
+			Channels = 4;
+			Format = IL_BGRA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_ABGR8888:
+			Channels = 4;
+			Format = IL_RGBA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_RGB565:
+			Channels = 3;
+			Format = IL_RGB;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGR565:
+			Channels = 3;
+			Format = IL_BGR;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGRA5551:
+			Channels = 4;
+			Format = IL_BGRA;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+		case IMAGE_FORMAT_BGRX5551:  // Unused alpha channel
+			Channels = 3;
+			Format = IL_BGR;
+			Type = IL_UNSIGNED_BYTE;
+			break;
+
+		default:
+			ilSetError(IL_FORMAT_NOT_SUPPORTED);
+			return IL_FALSE;
+	}
+
+	if (!ilTexImage(Head.Width, Head.Height, Head.Depth, Channels, Format, Type, NULL))
+		return IL_FALSE;
+	// The origin should be in the upper left.
+	iCurImage->Origin = IL_ORIGIN_UPPER_LEFT;
+	// Create any mipmaps.
+	VtfInitMipmaps(iCurImage, &Head);
+
+	// Create our animation chain
+	BaseImage = Image = iCurImage;  // Top-level image
+	for (Frame = 1; Frame < Head.Frames; Frame++) {
+		Image->Next = ilNewImageFull(Head.Width, Head.Height, Head.Depth, Channels, Format, Type, NULL);
+		if (Image->Next == NULL)
+			return IL_FALSE;
+		Image = Image->Next;
+		// The origin should be in the upper left.
+		Image->Origin = IL_ORIGIN_UPPER_LEFT;
+
+		// Create our mipmaps for each frame.
+		VtfInitMipmaps(Image, &Head);
+	}
+
+	// We want to put the smallest mipmap at the end, but it is first in the file, so we count backwards.
+	for (Mipmap = Head.MipmapCount - 1; Mipmap >= 0; Mipmap--) {
+		// Frames are in the normal order.
+		for (Frame = 0; Frame < Head.Frames; Frame++) {
+			//@TODO: Would probably be quicker to do the linked list traversal manually here.
+			ilBindImage(CurName);
+			ilActiveImage(Frame);
+			ilActiveMipmap(Mipmap);
+			Image = iCurImage;
+
+			switch (Head.HighResImageFormat)
+			{
+				// DXT1 compression
+				case IMAGE_FORMAT_DXT1:
+				case IMAGE_FORMAT_DXT1_ONEBITALPHA:
+					// The block size is 8.
+					SizeOfData = max(Image->Width * Image->Height * Image->Depth / 2, 8);
+					CompData = ialloc(SizeOfData);  // Gives a 6:1 compression ratio (or 8:1 for DXT1 with alpha)
+					iread(CompData, 1, SizeOfData);
+					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
+						Image->DxtcSize = SizeOfData;
+						Image->DxtcData = CompData;
+						Image->DxtcFormat = IL_DXT5;
+						CompData = NULL;
+					}
+					bVtf = DecompressDXT1(Image, CompData);
+					break;
+
+				// DXT3 compression
+				case IMAGE_FORMAT_DXT3:
+					// The block size is 16.
+					SizeOfData = max(Image->Width * Image->Height * Image->Depth, 16);
+					CompData = ialloc(SizeOfData);  // Gives a 4:1 compression ratio
+					iread(CompData, 1, SizeOfData);
+					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
+						Image->DxtcSize = SizeOfData;
+						Image->DxtcData = CompData;
+						Image->DxtcFormat = IL_DXT3;
+						CompData = NULL;
+					}
+					bVtf = DecompressDXT3(Image, CompData);
+					break;
+
+				// DXT5 compression
+				case IMAGE_FORMAT_DXT5:
+					// The block size is 16.
+					SizeOfData = max(Image->Width * Image->Height * Image->Depth, 16);
+					CompData = ialloc(SizeOfData);  // Gives a 4:1 compression ratio
+					iread(CompData, 1, SizeOfData);
+					if (ilGetInteger(IL_KEEP_DXTC_DATA) == IL_TRUE) {
+						Image->DxtcSize = SizeOfData;
+						Image->DxtcData = CompData;
+						Image->DxtcFormat = IL_DXT5;
+						CompData = NULL;
+					}
+					bVtf = DecompressDXT5(Image, CompData);
+					break;
+
+				// Uncompressed BGR(A) data (24-bit and 32-bit)
+				case IMAGE_FORMAT_BGR888:
+				case IMAGE_FORMAT_BGRA8888:
+				// Uncompressed RGB(A) data (24-bit and 32-bit)
+				case IMAGE_FORMAT_RGB888:
+				case IMAGE_FORMAT_RGBA8888:
+				// Uncompressed 16-bit shorts
+				case IMAGE_FORMAT_RGBA16161616:
+				// Luminance data only
+				case IMAGE_FORMAT_I8:
+				// Luminance and alpha data
+				case IMAGE_FORMAT_IA88:
+				// Alpha data only
+				case IMAGE_FORMAT_A8:
+				// We will ignore the part about the bluescreen right now.
+				//   I could not find any information about it.
+				case IMAGE_FORMAT_RGB888_BLUESCREEN:
+				case IMAGE_FORMAT_BGR888_BLUESCREEN:
+					// Just copy the data over - no compression.
+					if (iread(Image->Data, 1, Image->SizeOfData) != Image->SizeOfData)
+						bVtf = IL_FALSE;
+					else
+						bVtf = IL_TRUE;
+					break;
+
+				// Uncompressed 24-bit data with an unused alpha channel (we discard it)
+				case IMAGE_FORMAT_BGRX8888:
+					SizeOfData = Image->Width * Image->Height * Image->Depth * 3;
+					Temp = CompData = ialloc(SizeOfData / 3 * 4);  // Not compressed data
+					if (iread(CompData, 1, SizeOfData / 3 * 4) != SizeOfData / 3 * 4) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					for (k = 0; k < SizeOfData; k += 3) {
+						Image->Data[k]   = Temp[0];
+						Image->Data[k+1] = Temp[1];
+						Image->Data[k+2] = Temp[2];
+						Temp += 4;
+					}
+
+					break;
+
+				// Uncompressed 16-bit floats (must be converted to 32-bit)
+				case IMAGE_FORMAT_RGBA16161616F:
+					SizeOfData = Image->Width * Image->Height * Image->Depth * Image->Bpp * 2;
+					CompData = ialloc(SizeOfData);  // Not compressed data
+					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					bVtf = iConvFloat16ToFloat32((ILuint*)Image->Data, (ILushort*)CompData, SizeOfData / 2);
+					break;
+
+				// Uncompressed 32-bit ARGB and ABGR data.  DevIL does not handle this
+				//   internally, so we have to swap values.
+				case IMAGE_FORMAT_ARGB8888:
+				case IMAGE_FORMAT_ABGR8888:
+					if (iread(Image->Data, 1, Image->SizeOfData) != Image->SizeOfData) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					else {
+						bVtf = IL_TRUE;
+					}
+					// Swap the data
+					for (k = 0; k < Image->SizeOfData; k += 4) {
+						SwapVal = Image->Data[k];
+						Image->Data[k]   = Image->Data[k+3];
+						Image->Data[k+3] = SwapVal;
+						SwapVal = Image->Data[k+1];
+						Image->Data[k+1] = Image->Data[k+2];
+						Image->Data[k+2] = SwapVal;
+					}
+					break;
+
+				// Uncompressed 16-bit RGB and BGR data.  We have to expand this to 24-bit, since
+				//   DevIL does not handle this internally.
+				//   The data is in the file as: gggbbbbb rrrrrrggg
+				case IMAGE_FORMAT_RGB565:
+				case IMAGE_FORMAT_BGR565:
+					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
+					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
+					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					for (k = 0; k < Image->SizeOfData; k += 3) {
+						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
+						Image->Data[k+1] = ((Data16Bit[1] & 0x07) << 5) | ((Data16Bit[0] & 0xE0) >> 3);
+						Image->Data[k+2] =   Data16Bit[1] & 0xF8;
+						Data16Bit += 2;
+					}
+					break;
+
+				// Uncompressed 16-bit BGRA data (1-bit alpha).  We have to expand this to 32-bit,
+				//   since DevIL does not handle this internally.
+				//   Something seems strange with this one, but this is how VTFEdit outputs.
+				//   The data is in the file as: gggbbbbb arrrrrgg
+				case IMAGE_FORMAT_BGRA5551:
+					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
+					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
+					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					for (k = 0; k < Image->SizeOfData; k += 4) {
+						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
+						Image->Data[k+1] = ((Data16Bit[0] & 0xE0) >> 2) | ((Data16Bit[1] & 0x03) << 6);
+						Image->Data[k+2] =  (Data16Bit[1] & 0x7C) << 1;
+						// 1-bit alpha is either off or on.
+						Image->Data[k+3] = ((Data16Bit[0] & 0x80) == 0x80) ? 0xFF : 0x00;
+						Data16Bit += 2;
+					}
+					break;
+
+				// Same as above, but the alpha channel is unused.
+				case IMAGE_FORMAT_BGRX5551:
+					SizeOfData = Image->Width * Image->Height * Image->Depth * 2;
+					Data16Bit = CompData = ialloc(SizeOfData);  // Not compressed data
+					if (iread(CompData, 1, SizeOfData) != SizeOfData) {
+						bVtf = IL_FALSE;
+						break;
+					}
+					for (k = 0; k < Image->SizeOfData; k += 3) {
+						Image->Data[k]   =  (Data16Bit[0] & 0x1F) << 3;
+						Image->Data[k+1] = ((Data16Bit[0] & 0xE0) >> 2) | ((Data16Bit[1] & 0x03) << 6);
+						Image->Data[k+2] =  (Data16Bit[1] & 0x7C) << 1;
+						Data16Bit += 2;
+					}
+					break;
+			}
+
+			ifree(CompData);
+			CompData = NULL;
+			if (bVtf == IL_FALSE)  //@TODO: Do we need to do any cleanup here?
+				return IL_FALSE;
+		}
+	}
+
+	ilBindImage(CurName);  // Set to parent image first.
+	return ilFixImage();
+}
+
+
+ILboolean VtfInitMipmaps(ILimage *BaseImage, VTFHEAD *Header)
+{
+	ILimage *Image;
+	ILuint Width, Height, Depth, Mipmap;
+
+	Image = BaseImage;
+	Width = BaseImage->Width;  Height = BaseImage->Height;  Depth = BaseImage->Depth;
+
+	for (Mipmap = 1; Mipmap < Header->MipmapCount; Mipmap++) {
+		// 1 is the smallest dimension possible.
+		Width = (Width >> 1) == 0 ? 1 : (Width >> 1);
+		Height = (Height >> 1) == 0 ? 1 : (Height >> 1);
+		Depth = (Depth >> 1) == 0 ? 1 : (Depth >> 1);
+
+		if (Mipmap == 1) {  // Our first mipmap is at Mipmap.
+			Image->Mipmaps = ilNewImage(Width, Height, Depth, BaseImage->Bpp, BaseImage->Bpc);
+			if (Image->Mipmaps == NULL)
+				return IL_FALSE;
+			Image = Image->Mipmaps;
+		}
+		else {  // The other mipmaps are at Mipmap->Next.
+			Image->Next = ilNewImage(Width, Height, Depth, BaseImage->Bpp, BaseImage->Bpc);
+			if (Image->Next == NULL)
+				return IL_FALSE;
+			Image = Image->Next;
+		}
+
+		// ilNewImage does not set these.
+		Image->Format = BaseImage->Format;
+		Image->Type = BaseImage->Type;
+		// The origin should be in the upper left.
+		Image->Origin = IL_ORIGIN_UPPER_LEFT;
+	}
+
+	return IL_TRUE;
+}
+
+#endif//IL_NO_VTF
Index: devil/lib/Makefile.in
===================================================================
--- devil.orig/lib/Makefile.in	2009-01-10 20:54:50.000000000 +0000
+++ devil/lib/Makefile.in	2009-01-10 20:55:39.000000000 +0000
@@ -111,7 +111,7 @@
 	$(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c \
 	$(il_src)/il_icns.c $(il_src)/il_jp2.c \
 	$(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c \
-	$(il_include)/altivec_common.h \
+	$(il_src)/il_vtf.c $(il_include)/altivec_common.h \
 	$(il_include)/altivec_typeconversion.h \
 	$(il_include)/il_alloc.h $(il_include)/il_bits.h \
 	$(il_include)/il_bmp.h $(il_include)/il_dcx.h \
@@ -131,18 +131,19 @@
 	$(il_include)/il_states.h $(il_include)/il_targa.h \
 	$(il_include)/il_wdp.h \
 	$(all_include)/IL/devil_internal_exports.h \
-	$(ilu_src)/ilu_alloc.c $(ilu_src)/ilu_internal.c \
-	$(ilu_src)/ilu_noise.c $(ilu_src)/ilu_scale.c \
-	$(ilu_src)/ilu_error.c $(ilu_src)/ilu_main.c \
-	$(ilu_src)/ilu_rotate.c $(ilu_src)/ilu_scaling.c \
-	$(ilu_src)/ilu_filter.c $(ilu_src)/ilu_manip.c \
-	$(ilu_src)/ilu_scale2d.c $(ilu_src)/ilu_states.c \
-	$(ilu_src)/ilu_filter_rcg.c $(ilu_src)/ilu_mipmap.c \
-	$(ilu_src)/ilu_scale3d.c $(ilu_src)/ilu_utilities.c \
-	$(ilu_src)/ilu_region.c $(ilu_include)/ilu_alloc.h \
-	$(ilu_include)/ilu_filter.h $(ilu_include)/ilu_internal.h \
-	$(ilu_include)/ilu_mipmap.h $(ilu_include)/ilu_region.h \
-	$(ilu_include)/ilu_states.h $(all_include)/IL/ilu_region.h \
+	$(il_include)/il_vtf.h $(ilu_src)/ilu_alloc.c \
+	$(ilu_src)/ilu_internal.c $(ilu_src)/ilu_noise.c \
+	$(ilu_src)/ilu_scale.c $(ilu_src)/ilu_error.c \
+	$(ilu_src)/ilu_main.c $(ilu_src)/ilu_rotate.c \
+	$(ilu_src)/ilu_scaling.c $(ilu_src)/ilu_filter.c \
+	$(ilu_src)/ilu_manip.c $(ilu_src)/ilu_scale2d.c \
+	$(ilu_src)/ilu_states.c $(ilu_src)/ilu_filter_rcg.c \
+	$(ilu_src)/ilu_mipmap.c $(ilu_src)/ilu_scale3d.c \
+	$(ilu_src)/ilu_utilities.c $(ilu_src)/ilu_region.c \
+	$(ilu_include)/ilu_alloc.h $(ilu_include)/ilu_filter.h \
+	$(ilu_include)/ilu_internal.h $(ilu_include)/ilu_mipmap.h \
+	$(ilu_include)/ilu_region.h $(ilu_include)/ilu_states.h \
+	$(all_include)/IL/ilu_region.h \
 	$(ilu_include)/ilu_error/ilu_err-arabic.h \
 	$(ilu_include)/ilu_error/ilu_err-dutch.h \
 	$(ilu_include)/ilu_error/ilu_err-english.h \
@@ -184,7 +185,7 @@
 	libDevIL_la-il_pxr.lo libDevIL_la-il_xpm.lo \
 	libDevIL_la-il_hdr.lo libDevIL_la-il_icns.lo \
 	libDevIL_la-il_jp2.lo libDevIL_la-altivec_common.lo \
-	libDevIL_la-altivec_typeconversion.lo
+	libDevIL_la-altivec_typeconversion.lo libDevIL_la-il_vtf.lo
 @BUILD_IL_TRUE@@BUILD_MONOLITHIC_TRUE@am__objects_2 =  \
 @BUILD_IL_TRUE@@BUILD_MONOLITHIC_TRUE@	$(am__objects_1)
 am__objects_3 = libDevIL_la-ilu_alloc.lo libDevIL_la-ilu_internal.lo \
@@ -240,7 +241,8 @@
 	libIL_la-il_dds-save.lo libIL_la-il_psp.lo libIL_la-il_pix.lo \
 	libIL_la-il_pxr.lo libIL_la-il_xpm.lo libIL_la-il_hdr.lo \
 	libIL_la-il_icns.lo libIL_la-il_jp2.lo \
-	libIL_la-altivec_common.lo libIL_la-altivec_typeconversion.lo
+	libIL_la-altivec_common.lo libIL_la-altivec_typeconversion.lo \
+	libIL_la-il_vtf.lo
 libIL_la_OBJECTS = $(am_libIL_la_OBJECTS)
 libIL_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
 	--mode=link $(CCLD) $(libIL_la_CFLAGS) $(CFLAGS) \
@@ -505,7 +507,7 @@
 	$(il_src)/il_pxr.c $(il_src)/il_xpm.c $(il_src)/il_hdr.c \
 	$(il_src)/il_icns.c $(il_src)/il_jp2.c \
 	$(il_src)/altivec_common.c $(il_src)/altivec_typeconversion.c \
-	$(il_include)/altivec_common.h \
+	$(il_src)/il_vtf.c $(il_include)/altivec_common.h \
 	$(il_include)/altivec_typeconversion.h \
 	$(il_include)/il_alloc.h $(il_include)/il_bits.h \
 	$(il_include)/il_bmp.h $(il_include)/il_dcx.h \
@@ -524,7 +526,8 @@
 	$(il_include)/il_sgi.h $(il_include)/il_stack.h \
 	$(il_include)/il_states.h $(il_include)/il_targa.h \
 	$(il_include)/il_wdp.h \
-	$(all_include)/IL/devil_internal_exports.h
+	$(all_include)/IL/devil_internal_exports.h \
+	$(il_include)/il_vtf.h
 libIL_la_LDFLAGS = @IL_LIBS@ $(AM_LDFLAGS)
 libILU_la_CPPFLAGS = -I $(ilu_include) -I $(all_include)
 libILU_la_CFLAGS = $(CFLAGS) @ILU_CFLAGS@
@@ -689,6 +692,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_targa.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_tiff.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_utility.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_vtf.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_wal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_wdp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libDevIL_la-il_xpm.Plo@am__quote@
@@ -800,6 +804,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_targa.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_tiff.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_utility.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_vtf.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_wal.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_wdp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libIL_la-il_xpm.Plo@am__quote@
@@ -1224,6 +1229,13 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -c -o libDevIL_la-altivec_typeconversion.lo `test -f '$(il_src)/altivec_typeconversion.c' || echo '$(srcdir)/'`$(il_src)/altivec_typeconversion.c
 
+libDevIL_la-il_vtf.lo: $(il_src)/il_vtf.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -MT libDevIL_la-il_vtf.lo -MD -MP -MF $(DEPDIR)/libDevIL_la-il_vtf.Tpo -c -o libDevIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libDevIL_la-il_vtf.Tpo $(DEPDIR)/libDevIL_la-il_vtf.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(il_src)/il_vtf.c' object='libDevIL_la-il_vtf.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -c -o libDevIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
+
 libDevIL_la-ilu_alloc.lo: $(ilu_src)/ilu_alloc.c
 @am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libDevIL_la_CPPFLAGS) $(CPPFLAGS) $(libDevIL_la_CFLAGS) $(CFLAGS) -MT libDevIL_la-ilu_alloc.lo -MD -MP -MF $(DEPDIR)/libDevIL_la-ilu_alloc.Tpo -c -o libDevIL_la-ilu_alloc.lo `test -f '$(ilu_src)/ilu_alloc.c' || echo '$(srcdir)/'`$(ilu_src)/ilu_alloc.c
 @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libDevIL_la-ilu_alloc.Tpo $(DEPDIR)/libDevIL_la-ilu_alloc.Plo
@@ -1812,6 +1824,13 @@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -c -o libIL_la-altivec_typeconversion.lo `test -f '$(il_src)/altivec_typeconversion.c' || echo '$(srcdir)/'`$(il_src)/altivec_typeconversion.c
 
+libIL_la-il_vtf.lo: $(il_src)/il_vtf.c
+@am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -MT libIL_la-il_vtf.lo -MD -MP -MF $(DEPDIR)/libIL_la-il_vtf.Tpo -c -o libIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
+@am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libIL_la-il_vtf.Tpo $(DEPDIR)/libIL_la-il_vtf.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$(il_src)/il_vtf.c' object='libIL_la-il_vtf.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libIL_la_CPPFLAGS) $(CPPFLAGS) $(libIL_la_CFLAGS) $(CFLAGS) -c -o libIL_la-il_vtf.lo `test -f '$(il_src)/il_vtf.c' || echo '$(srcdir)/'`$(il_src)/il_vtf.c
+
 libILU_la-ilu_alloc.lo: $(ilu_src)/ilu_alloc.c
 @am__fastdepCC_TRUE@	$(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(libILU_la_CPPFLAGS) $(CPPFLAGS) $(libILU_la_CFLAGS) $(CFLAGS) -MT libILU_la-ilu_alloc.lo -MD -MP -MF $(DEPDIR)/libILU_la-ilu_alloc.Tpo -c -o libILU_la-ilu_alloc.lo `test -f '$(ilu_src)/ilu_alloc.c' || echo '$(srcdir)/'`$(ilu_src)/ilu_alloc.c
 @am__fastdepCC_TRUE@	mv -f $(DEPDIR)/libILU_la-ilu_alloc.Tpo $(DEPDIR)/libILU_la-ilu_alloc.Plo

