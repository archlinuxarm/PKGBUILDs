diff -ur source.orig/texk/web2c/luatexdir/image/pdftoepdf.w source/texk/web2c/luatexdir/image/pdftoepdf.w
--- source.orig/texk/web2c/luatexdir/image/pdftoepdf.w	2017-05-08 22:39:36.639375783 +0200
+++ source/texk/web2c/luatexdir/image/pdftoepdf.w	2017-09-19 11:23:36.586768739 +0200
@@ -224,7 +224,7 @@
         free(checksum);
     }
     if (pdf_doc->doc == NULL) {
-        docmemstream = new MemStream( docstream,0,streamsize, obj.initNull() );
+        docmemstream = new MemStream( docstream,0,streamsize, Object(objNull) );
         doc = new PDFDoc(docmemstream); /* takes ownership of docmemstream */
         pdf_doc->pc++;
         if (!doc->isOk() || !doc->okToPrint()) {
@@ -408,9 +408,8 @@
     Object obj1;
     pdf_begin_array(pdf);
     for (i = 0, l = array->getLength(); i < l; ++i) {
-        array->getNF(i, &obj1);
+        obj1 = array->getNF(i);
         copyObject(pdf, pdf_doc, &obj1);
-        obj1.free();
     }
     pdf_end_array(pdf);
 }
@@ -422,9 +421,8 @@
     pdf_begin_dict(pdf);
     for (i = 0, l = dict->getLength(); i < l; ++i) {
         copyName(pdf, dict->getKey(i));
-        dict->getValNF(i, &obj1);
+        obj1 = dict->getValNF(i);
         copyObject(pdf, pdf_doc, &obj1);
-        obj1.free();
     }
     pdf_end_dict(pdf);
 }
@@ -510,13 +508,12 @@
     PDFDoc *doc = pdf_doc->doc;
     xref = doc->getXRef();
     for (r = pdf_doc->inObjList; r != NULL;) {
-        xref->fetch(r->ref.num, r->ref.gen, &obj1);
+        obj1 = xref->fetch(r->ref.num, r->ref.gen);
         if (obj1.isStream())
             pdf_begin_obj(pdf, r->num, OBJSTM_NEVER);
         else
             pdf_begin_obj(pdf, r->num, 2);
         copyObject(pdf, pdf_doc, &obj1);
-        obj1.free();
         pdf_end_obj(pdf);
         n = r->next;
         delete r;
@@ -740,7 +737,7 @@
     catalog = doc->getCatalog();
     page = catalog->getPage(img_pagenum(idict));
     pageref = catalog->getPageRef(img_pagenum(idict));
-    doc->getXRef()->fetch(pageref->num, pageref->gen, &pageobj);
+    pageobj = doc->getXRef()->fetch(pageref->num, pageref->gen);
     pageDict = pageobj.getDict();
     /* write the Page header */
     pdf_begin_obj(pdf, img_objnum(idict), OBJSTM_NEVER);
@@ -757,12 +754,11 @@
         pdf_dict_add_int(pdf, "PTEX.PageNumber", (int) img_pagenum(idict));
     }
     if ((suppress_optional_info & 8) == 0) {
-        doc->getDocInfoNF(&obj1);
+        obj1 = doc->getDocInfoNF();
         if (obj1.isRef()) {
             /* the info dict must be indirect (PDF Ref p. 61) */
             pdf_dict_add_ref(pdf, "PTEX.InfoDict", addInObj(pdf, pdf_doc, obj1.getRef()));
         }
-        obj1.free();
     }
     if (img_is_bbox(idict)) {
         bbox[0] = sp2bp(img_bbox(idict)[0]);
@@ -788,19 +784,17 @@
         Now all relevant parts of the Page dictionary are copied. Metadata validity
         check is needed(as a stream it must be indirect).
     */
-    pageDict->lookupNF("Metadata", &obj1);
+    obj1 = pageDict->lookupNF("Metadata");
     if (!obj1.isNull() && !obj1.isRef())
         formatted_warning("pdf inclusion","/Metadata must be indirect object");
-    obj1.free();
     /* copy selected items in Page dictionary */
     for (i = 0; pagedictkeys[i] != NULL; i++) {
-        pageDict->lookupNF(pagedictkeys[i], &obj1);
+        obj1 = pageDict->lookupNF(pagedictkeys[i]);
         if (!obj1.isNull()) {
             pdf_add_name(pdf, pagedictkeys[i]);
             /* preserves indirection */
             copyObject(pdf, pdf_doc, &obj1);
         }
-        obj1.free();
     }
     /*
         If there are no Resources in the Page dict of the embedded page,
@@ -808,32 +802,28 @@
         PDF file, climbing up the tree until the Resources are found.
         (This fixes a problem with Scribus 1.3.3.14.)
     */
-    pageDict->lookupNF("Resources", &obj1);
+    obj1 = pageDict->lookupNF("Resources");
     if (obj1.isNull()) {
         op1 = &pagesobj1;
         op2 = &pagesobj2;
-        pageDict->lookup("Parent", op1);
+        *op1 = pageDict->lookup("Parent");
         while (op1->isDict()) {
-            obj1.free();
-            op1->dictLookupNF("Resources", &obj1);
+            obj1 = op1->dictLookupNF("Resources");
             if (!obj1.isNull()) {
                 pdf_add_name(pdf, "Resources");
                 copyObject(pdf, pdf_doc, &obj1);
                 break;
             }
-            op1->dictLookup("Parent", op2);
+            *op2 = op1->dictLookup("Parent");
             optmp = op1;
             op1 = op2;
             op2 = optmp;
-            op2->free();
         };
         if (!op1->isDict())
             formatted_warning("pdf inclusion","Page /Resources missing");
-        op1->free();
     }
-    obj1.free();
     /* Write the Page contents. */
-    page->getContents(&contents);
+    contents = page->getContents();
     if (contents.isStream()) {
         /*
             Variant A: get stream and recompress under control of \pdfcompresslevel
@@ -844,27 +834,23 @@
 
             Variant B: copy stream without recompressing
         */
-        contents.streamGetDict()->lookup("F", &obj1);
+        obj1 = contents.streamGetDict()->lookup("F");
         if (!obj1.isNull()) {
             normal_error("pdf inclusion","unsupported external stream");
         }
-        obj1.free();
-        contents.streamGetDict()->lookup("Length", &obj1);
+        obj1 = contents.streamGetDict()->lookup("Length");
         pdf_add_name(pdf, "Length");
         copyObject(pdf, pdf_doc, &obj1);
-        obj1.free();
-        contents.streamGetDict()->lookup("Filter", &obj1);
+        obj1 = contents.streamGetDict()->lookup("Filter");
         if (!obj1.isNull()) {
             pdf_add_name(pdf, "Filter");
             copyObject(pdf, pdf_doc, &obj1);
-            obj1.free();
-            contents.streamGetDict()->lookup("DecodeParms", &obj1);
+            obj1 = contents.streamGetDict()->lookup("DecodeParms");
             if (!obj1.isNull()) {
                 pdf_add_name(pdf, "DecodeParms");
                 copyObject(pdf, pdf_doc, &obj1);
             }
         }
-        obj1.free();
         pdf_end_dict(pdf);
         pdf_begin_stream(pdf);
         copyStreamStream(pdf, contents.getStream()->getUndecodedStream());
@@ -875,8 +861,8 @@
         pdf_end_dict(pdf);
         pdf_begin_stream(pdf);
         for (i = 0, l = contents.arrayGetLength(); i < l; ++i) {
-            copyStreamStream(pdf, (contents.arrayGet(i, &obj1))->getStream());
-            obj1.free();
+            obj1 = contents.arrayGet(i);
+            copyStreamStream(pdf, obj1.getStream());
             if (i < (l - 1)) {
                 /*
                     Put a space between streams to be on the safe side (streams
@@ -897,8 +883,6 @@
     }
     /* write out all indirect objects */
     writeRefs(pdf, pdf_doc);
-    contents.free();
-    pageobj.free();
     /*
         unrefPdfDocument() must come after contents.free() and pageobj.free()!
         TH: The next line makes repeated pdf inclusion unacceptably slow
diff -ur source.orig/texk/web2c/luatexdir/lua/lepdflib.cc source/texk/web2c/luatexdir/lua/lepdflib.cc
--- source.orig/texk/web2c/luatexdir/lua/lepdflib.cc	2017-05-08 22:39:36.689375107 +0200
+++ source/texk/web2c/luatexdir/lua/lepdflib.cc	2017-09-19 09:48:19.658021769 +0200
@@ -538,7 +538,7 @@
         pdfdoc_changed_error(L);                               \
     uout = new_Object_userdata(L);                             \
     uout->d = new Object();                                    \
-    ((in *) uin->d)->function((Object *) uout->d);             \
+    *((Object *)uout->d) = ((in *) uin->d)->function();                  \
     uout->atype = ALLOC_LEPDF;                                 \
     uout->pc = uin->pc;                                        \
     uout->pd = uin->pd;                                        \
@@ -668,13 +668,11 @@
 
 static int m_Array_incRef(lua_State * L)
 {
-    int i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = ((Array *) uin->d)->incRef();
-    lua_pushinteger(L, i);
+    lua_pushinteger(L, 1);
     return 1;
 }
 
@@ -685,8 +683,7 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = ((Array *) uin->d)->decRef();
-    lua_pushinteger(L, i);
+    lua_pushinteger(L, 1);
     return 1;
 }
 
@@ -702,7 +699,7 @@
     if ((uin->pd != NULL && uin->pd->pc != uin->pc)
         || (uobj->pd != NULL && uobj->pd->pc != uobj->pc))
         pdfdoc_changed_error(L);
-    ((Array *) uin->d)->add(((Object *) uobj->d));
+    ((Array *) uin->d)->add(std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -718,7 +715,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Array *) uin->d)->get(i - 1, (Object *) uout->d);
+        *((Object *) uout->d) = ((Array *) uin->d)->get(i - 1);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -739,7 +736,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Array *) uin->d)->getNF(i - 1, (Object *) uout->d);
+        *((Object *) uout->d) = ((Array *) uin->d)->getNF(i - 1);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -953,25 +950,21 @@
 
 static int m_Dict_incRef(lua_State * L)
 {
-    int i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = ((Dict *) uin->d)->incRef();
-    lua_pushinteger(L, i);
+    lua_pushinteger(L, 1);
     return 1;
 }
 
 static int m_Dict_decRef(lua_State * L)
 {
-    int i;
     udstruct *uin;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    i = ((Dict *) uin->d)->decRef();
-    lua_pushinteger(L, i);
+    lua_pushinteger(L, 1);
     return 1;
 }
 
@@ -986,7 +979,7 @@
         pdfdoc_changed_error(L);
     s = copyString(luaL_checkstring(L, 2));
     uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
-    ((Dict *) uin->d)->add(s, ((Object *) uobj->d));
+    ((Dict *) uin->d)->add(s, std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -999,7 +992,7 @@
         pdfdoc_changed_error(L);
     s = luaL_checkstring(L, 2);
     uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
-    ((Dict *) uin->d)->set(s, ((Object *) uobj->d));
+    ((Dict *) uin->d)->set(s, std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -1027,7 +1020,7 @@
     s = luaL_checkstring(L, 2);
     uout = new_Object_userdata(L);
     uout->d = new Object();
-    ((Dict *) uin->d)->lookup(s, (Object *) uout->d);
+    *((Object *) uout->d) = ((Dict *) uin->d)->lookup(s);
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
@@ -1044,7 +1037,7 @@
     s = luaL_checkstring(L, 2);
     uout = new_Object_userdata(L);
     uout->d = new Object();
-    ((Dict *) uin->d)->lookupNF(s, (Object *) uout->d);
+    *((Object *) uout->d) = ((Dict *) uin->d)->lookupNF(s);
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
@@ -1096,7 +1089,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Dict *) uin->d)->getVal(i - 1, (Object *) uout->d);
+        *((Object *) uout->d) = ((Dict *) uin->d)->getVal(i - 1);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -1117,7 +1110,7 @@
     if (i > 0 && i <= len) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Dict *) uin->d)->getValNF(i - 1, (Object *) uout->d);
+        *((Object *) uout->d) = ((Dict *) uin->d)->getValNF(i - 1);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -1381,9 +1374,9 @@
         pdfdoc_changed_error(L);
     luaL_checktype(L, 2, LUA_TBOOLEAN);
     if (lua_toboolean(L, 2) != 0)
-        ((Object *) uin->d)->initBool(gTrue);
+        *((Object *) uin->d) = Object(gTrue);
     else
-        ((Object *) uin->d)->initBool(gFalse);
+        *((Object *) uin->d) = Object(gFalse);
     return 0;
 }
 
@@ -1395,7 +1388,7 @@
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
     i = luaL_checkint(L, 2);
-    ((Object *) uin->d)->initInt(i);
+    *((Object *) uin->d) = Object(i);
     return 0;
 }
 
@@ -1407,7 +1400,7 @@
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
     d = luaL_checknumber(L, 2);
-    ((Object *) uin->d)->initReal(d);
+    *((Object *) uin->d) = Object(d);
     return 0;
 }
 
@@ -1422,7 +1415,7 @@
         pdfdoc_changed_error(L);
     s = luaL_checklstring(L, 2, &len);
     gs = new GooString(s, len);
-    ((Object *) uin->d)->initString(gs);
+    *((Object *) uin->d) = Object(gs);
     return 0;
 }
 
@@ -1434,7 +1427,7 @@
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
     s = luaL_checkstring(L, 2);
-    ((Object *) uin->d)->initName(s);
+    *((Object *) uin->d) = Object(objName, s);
     return 0;
 }
 
@@ -1444,13 +1437,14 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initNull();
+    *((Object *) uin->d) = Object(objNull);
     return 0;
 }
 
 static int m_Object_initArray(lua_State * L)
 {
     udstruct *uin, *uxref;
+    Array *a;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
     uxref = (udstruct *) luaL_checkudata(L, 2, M_XRef);
     if (uin->pd != NULL && uxref->pd != NULL && uin->pd != uxref->pd)
@@ -1458,7 +1452,8 @@
     if ((uin->pd != NULL && uin->pd->pc != uin->pc)
         || (uxref->pd != NULL && uxref->pd->pc != uxref->pc))
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initArray((XRef *) uxref->d);
+    a = new Array((XRef *) uxref->d);
+    *((Object *) uin->d) = Object(a);
     return 0;
 }
 
@@ -1469,6 +1464,7 @@
 static int m_Object_initDict(lua_State * L)
 {
     udstruct *uin, *uxref;
+    Dict *d;
     uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
     uxref = (udstruct *) luaL_checkudata(L, 2, M_XRef);
     if (uin->pd != NULL && uxref->pd != NULL && uin->pd != uxref->pd)
@@ -1476,7 +1472,8 @@
     if ((uin->pd != NULL && uin->pd->pc != uin->pc)
         || (uxref->pd != NULL && uxref->pd->pc != uxref->pc))
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initDict((XRef *) uxref->d);
+    d = new Dict((XRef *) uxref->d);
+    *((Object *) uin->d) = Object(d);
     return 0;
 }
 
@@ -1490,7 +1487,7 @@
     if ((uin->pd != NULL && uin->pd->pc != uin->pc)
         || (ustream->pd != NULL && ustream->pd->pc != ustream->pc))
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initStream((Stream *) ustream->d);
+    *((Object *) uin->d) = Object((Stream *) ustream->d);
     return 0;
 }
 
@@ -1503,7 +1500,7 @@
         pdfdoc_changed_error(L);
     num = luaL_checkint(L, 2);
     gen = luaL_checkint(L, 3);
-    ((Object *) uin->d)->initRef(num, gen);
+    *((Object *) uin->d) = Object(num, gen);
     return 0;
 }
 
@@ -1515,7 +1512,7 @@
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
     s = luaL_checkstring(L, 2);
-    ((Object *) uin->d)->initCmd(CHARP_CAST s);
+    *((Object *) uin->d) = Object(objCmd, CHARP_CAST s);
     return 0;
 }
 
@@ -1525,7 +1522,7 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initError();
+    *((Object *) uin->d) = Object(objError);
     return 0;
 }
 
@@ -1535,7 +1532,7 @@
     uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
     if (uin->pd != NULL && uin->pd->pc != uin->pc)
         pdfdoc_changed_error(L);
-    ((Object *) uin->d)->initEOF();
+    *((Object *) uin->d) = Object(objEOF);
     return 0;
 }
 
@@ -1551,7 +1548,7 @@
         pdfdoc_changed_error(L);
     uout = new_Object_userdata(L);
     uout->d = new Object();
-    ((Object *) uin->d)->fetch((XRef *) uxref->d, (Object *) uout->d);
+    *((Object *) uout->d) = ((Object *) uin->d)->fetch((XRef *) uxref->d);
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
@@ -1816,7 +1813,7 @@
         pdfdoc_changed_error(L);
     if (!((Object *) uin->d)->isArray())
         luaL_error(L, "Object is not an Array");
-    ((Object *) uin->d)->arrayAdd((Object *) uobj->d);
+    ((Object *) uin->d)->arrayAdd(std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -1833,7 +1830,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            ((Object *) uin->d)->arrayGet(i - 1, (Object *) uout->d);
+            *((Object *) uout->d) = ((Object *) uin->d)->arrayGet(i - 1);
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -1857,7 +1854,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            ((Object *) uin->d)->arrayGetNF(i - 1, (Object *) uout->d);
+            *((Object *) uout->d) = ((Object *) uin->d)->arrayGetNF(i - 1);
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -1897,7 +1894,7 @@
         pdfdoc_changed_error(L);
     if (!((Object *) uin->d)->isDict())
         luaL_error(L, "Object is not a Dict");
-    ((Object *) uin->d)->dictAdd(copyString(s), (Object *) uobj->d);
+    ((Object *) uin->d)->dictAdd(copyString(s), std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -1915,7 +1912,7 @@
         pdfdoc_changed_error(L);
     if (!((Object *) uin->d)->isDict())
         luaL_error(L, "Object is not a Dict");
-    ((Object *) uin->d)->dictSet(s, (Object *) uobj->d);
+    ((Object *) uin->d)->dictSet(s, std::move(*((Object *) uobj->d)));
     return 0;
 }
 
@@ -1930,7 +1927,7 @@
     if (((Object *) uin->d)->isDict()) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Object *) uin->d)->dictLookup(s, (Object *) uout->d);
+        *((Object *) uout->d) = ((Object *) uin->d)->dictLookup(s);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -1950,7 +1947,7 @@
     if (((Object *) uin->d)->isDict()) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((Object *) uin->d)->dictLookupNF(s, (Object *) uout->d);
+        *((Object *) uout->d) = ((Object *) uin->d)->dictLookupNF(s);
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -1991,7 +1988,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            ((Object *) uin->d)->dictGetVal(i - 1, (Object *) uout->d);
+	    *((Object *) uout->d) = ((Object *) uin->d)->dictGetVal(i - 1);
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -2015,7 +2012,7 @@
         if (i > 0 && i <= len) {
             uout = new_Object_userdata(L);
             uout->d = new Object();
-            ((Object *) uin->d)->dictGetValNF(i - 1, (Object *) uout->d);
+            *((Object *) uout->d) = ((Object *) uin->d)->dictGetValNF(i - 1);
             uout->atype = ALLOC_LEPDF;
             uout->pc = uin->pc;
             uout->pd = uin->pd;
@@ -2243,7 +2240,7 @@
 m_poppler_get_poppler(Page, Dict, getPieceInfo);
 m_poppler_get_poppler(Page, Dict, getSeparationInfo);
 m_poppler_get_poppler(Page, Dict, getResourceDict);
-m_poppler_get_OBJECT(Page, getAnnots);
+m_poppler_get_OBJECT(Page, getAnnotsObject);
 
 m_poppler_get_OBJECT(Page, getContents);
 
@@ -2270,7 +2267,7 @@
     {"getPieceInfo", m_Page_getPieceInfo},
     {"getSeparationInfo", m_Page_getSeparationInfo},
     {"getResourceDict", m_Page_getResourceDict},
-    {"getAnnots", m_Page_getAnnots},
+    {"getAnnots", m_Page_getAnnotsObject},
     {"getContents", m_Page_getContents},
     {"__tostring", m_Page__tostring},
     {NULL, NULL}                // sentinel
@@ -2520,7 +2517,7 @@
     if (((PdfDocument *) uin->d)->doc->getXRef()->isOk()) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((PdfDocument *) uin->d)->doc->getDocInfo((Object *) uout->d);
+        *((Object *) uout->d) = ((PdfDocument *) uin->d)->doc->getDocInfo();
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -2538,7 +2535,7 @@
     if (((PdfDocument *) uin->d)->doc->getXRef()->isOk()) {
         uout = new_Object_userdata(L);
         uout->d = new Object();
-        ((PdfDocument *) uin->d)->doc->getDocInfoNF((Object *) uout->d);
+        *((Object *) uout->d) = ((PdfDocument *) uin->d)->doc->getDocInfoNF();
         uout->atype = ALLOC_LEPDF;
         uout->pc = uin->pc;
         uout->pd = uin->pd;
@@ -2841,7 +2838,7 @@
     uout = new_Object_userdata(L);
     uout->d = new Object();
     origin = (Object *) (((Attribute *) uin->d)->getValue());
-    origin->copy ( ((Object *)uout->d) );
+    *((Object *) uout->d) = origin->copy();
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
@@ -3320,7 +3317,7 @@
     parent = root->findParentElement(i-1);
     if (parent != NULL) {
        uout = new_StructElement_userdata(L);
-       uout->d = new StructElement( *parent );
+       uout->d = (StructElement *) parent;
        uout->atype = ALLOC_LEPDF;
        uout->pc = uin->pc;
        uout->pd = uin->pd;
@@ -3370,7 +3367,7 @@
     gen = luaL_checkint(L, 3);
     uout = new_Object_userdata(L);
     uout->d = new Object();
-    ((XRef *) uin->d)->fetch(num, gen, (Object *) uout->d);
+    *((Object *) uout->d) = ((XRef *) uin->d)->fetch(num, gen);
     uout->atype = ALLOC_LEPDF;
     uout->pc = uin->pc;
     uout->pd = uin->pd;
diff -ur source.orig/texk/web2c/luatexdir/lua/lpdfscannerlib.cc source/texk/web2c/luatexdir/lua/lpdfscannerlib.cc
--- source.orig/texk/web2c/luatexdir/lua/lpdfscannerlib.cc	2017-05-08 22:39:36.692708395 +0200
+++ source/texk/web2c/luatexdir/lua/lpdfscannerlib.cc	2017-09-19 09:48:19.658021769 +0200
@@ -634,7 +634,7 @@
       int i;
       for (i=0;i<count;i++) {
 	Object *val = new Object();
-	arrayref->get(i, val);
+	*val = arrayref->get(i);
 	if (val->isStream()) {
 	  ObjectList *rover = self->_streams;
 	  ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
diff -ur source.orig/texk/web2c/pdftexdir/pdftoepdf.cc source/texk/web2c/pdftexdir/pdftoepdf.cc
--- source.orig/texk/web2c/pdftexdir/pdftoepdf.cc	2017-06-16 21:49:09.293857387 +0200
+++ source/texk/web2c/pdftexdir/pdftoepdf.cc	2017-09-19 09:48:19.661355046 +0200
@@ -84,31 +84,6 @@
 #define MASK_SUPPRESS_PTEX_PAGENUMBER 0x04
 #define MASK_SUPPRESS_PTEX_INFODICT   0x08
 
-// PdfObject encapsulates the xpdf Object type,
-// and properly frees its resources on destruction.
-// Use obj-> to access members of the Object,
-// and &obj to get a pointer to the object.
-// It is no longer necessary to call Object::free explicitely.
-
-class PdfObject {
-  public:
-    PdfObject() {               // nothing
-    } ~PdfObject() {
-        iObject.free();
-    }
-    Object *operator->() {
-        return &iObject;
-    }
-    Object *operator&() {
-        return &iObject;
-    }
-  private:                     // no copying or assigning
-    PdfObject(const PdfObject &);
-    void operator=(const PdfObject &);
-  public:
-    Object iObject;
-};
-
 // When copying the Resources of the selected page, all objects are copied
 // recusively top-down. Indirect objects however are not fetched during
 // copying, but get a new object number from pdfTeX and then will be
@@ -212,18 +187,6 @@
     delete pdf_doc;
 }
 
-// Replacement for
-//      Object *initDict(Dict *dict1){ initObj(objDict); dict = dict1; return this; }
-
-static void initDictFromDict(PdfObject & obj, Dict * dict)
-{
-    obj->initDict(xref);
-    for (int i = 0, l = dict->getLength(); i < l; i++) {
-        Object obj1;
-        obj->dictAdd(copyString(dict->getKey(i)), dict->getValNF(i, &obj1));
-    }
-}
-
 // --------------------------------------------------------------------
 
 static int addEncoding(GfxFont * gfont)
@@ -320,10 +283,10 @@
 
 static void copyDictEntry(Object * obj, int i)
 {
-    PdfObject obj1;
+    Object obj1;
     copyName(obj->dictGetKey(i));
     pdf_puts(" ");
-    obj->dictGetValNF(i, &obj1);
+    obj1 = obj->dictGetValNF(i);
     copyObject(&obj1);
     pdf_puts("\n");
 }
@@ -376,17 +339,17 @@
 static void copyProcSet(Object * obj)
 {
     int i, l;
-    PdfObject procset;
+    Object procset;
     if (!obj->isArray())
         pdftex_fail("PDF inclusion: invalid ProcSet array type <%s>",
                     obj->getTypeName());
     pdf_puts("/ProcSet [ ");
     for (i = 0, l = obj->arrayGetLength(); i < l; ++i) {
-        obj->arrayGetNF(i, &procset);
-        if (!procset->isName())
+        procset = obj->arrayGetNF(i);
+        if (!procset.isName())
             pdftex_fail("PDF inclusion: invalid ProcSet entry type <%s>",
-                        procset->getTypeName());
-        copyName(procset->getName());
+                        procset.getTypeName());
+        copyName(procset.getName());
         pdf_puts(" ");
     }
     pdf_puts("]\n");
@@ -394,10 +357,29 @@
 
 #define REPLACE_TYPE1C true
 
+static bool embeddableFont(Object * fontdesc)
+{
+    Object fontfile, ffsubtype;
+
+    if (!fontdesc->isDict())
+        return false;
+    fontfile = fontdesc->dictLookup("FontFile");
+    if (fontfile.isStream())
+        return true;
+    if (REPLACE_TYPE1C) {
+        fontfile = fontdesc->dictLookup("FontFile3");
+        if (!fontfile.isStream())
+            return false;
+        ffsubtype = fontfile.streamGetDict()->lookup("Subtype");
+        return ffsubtype.isName() && !strcmp(ffsubtype.getName(), "Type1C");
+    }
+    return false;
+}
+
 static void copyFont(char *tag, Object * fontRef)
 {
-    PdfObject fontdict, subtype, basefont, fontdescRef, fontdesc, charset,
-        fontfile, ffsubtype, stemV;
+    Object fontdict, subtype, basefont, fontdescRef, fontdesc, charset,
+        stemV;
     GfxFont *gfont;
     fd_entry *fd;
     fm_entry *fontmap;
@@ -413,33 +395,39 @@
     }
     // Only handle included Type1 (and Type1C) fonts; anything else will be copied.
     // Type1C fonts are replaced by Type1 fonts, if REPLACE_TYPE1C is true.
-    if (!fixedinclusioncopyfont && fontRef->fetch(xref, &fontdict)->isDict()
-        && fontdict->dictLookup("Subtype", &subtype)->isName()
-        && !strcmp(subtype->getName(), "Type1")
-        && fontdict->dictLookup("BaseFont", &basefont)->isName()
-        && fontdict->dictLookupNF("FontDescriptor", &fontdescRef)->isRef()
-        && fontdescRef->fetch(xref, &fontdesc)->isDict()
-        && (fontdesc->dictLookup("FontFile", &fontfile)->isStream()
-            || (REPLACE_TYPE1C
-                && fontdesc->dictLookup("FontFile3", &fontfile)->isStream()
-                && fontfile->streamGetDict()->lookup("Subtype",
-                                                     &ffsubtype)->isName()
-                && !strcmp(ffsubtype->getName(), "Type1C")))
-        && (fontmap = lookup_fontmap(basefont->getName())) != NULL) {
+    fontdict = fontRef->fetch(xref);
+    fontdesc = Object(objNull);
+    if (fontdict.isDict()) {
+        subtype = fontdict.dictLookup("Subtype");
+        basefont = fontdict.dictLookup("BaseFont");
+        fontdescRef = fontdict.dictLookupNF("FontDescriptor");
+        if (fontdescRef.isRef()) {
+            fontdesc = fontdescRef.fetch(xref);
+        }
+    }
+    if (!fixedinclusioncopyfont && fontdict.isDict()
+        && subtype.isName()
+        && !strcmp(subtype.getName(), "Type1")
+        && basefont.isName()
+        && fontdescRef.isRef()
+        && fontdesc.isDict()
+        && embeddableFont(&fontdesc)
+        && (fontmap = lookup_fontmap(basefont.getName())) != NULL) {
         // round /StemV value, since the PDF input is a float
         // (see Font Descriptors in PDF reference), but we only store an
         // integer, since we don't want to change the struct.
-        fontdesc->dictLookup("StemV", &stemV);
-        fd = epdf_create_fontdescriptor(fontmap, zround(stemV->getNum()));
-        if (fontdesc->dictLookup("CharSet", &charset) &&
-            charset->isString() && is_subsetable(fontmap))
-            epdf_mark_glyphs(fd, charset->getString()->getCString());
+        stemV = fontdesc.dictLookup("StemV");
+        fd = epdf_create_fontdescriptor(fontmap, zround(stemV.getNum()));
+        charset = fontdesc.dictLookup("CharSet");
+        if (!charset.isNull() &&
+            charset.isString() && is_subsetable(fontmap))
+            epdf_mark_glyphs(fd, charset.getString()->getCString());
         else
             embed_whole_font(fd);
-        addFontDesc(fontdescRef->getRef(), fd);
+        addFontDesc(fontdescRef.getRef(), fd);
         copyName(tag);
         gfont = GfxFont::makeFont(xref, tag, fontRef->getRef(),
-                                  fontdict->getDict());
+                                  fontdict.getDict());
         pdf_printf(" %d 0 R ", addFont(fontRef->getRef(), fd,
                                        addEncoding(gfont)));
     } else {
@@ -451,24 +439,24 @@
 
 static void copyFontResources(Object * obj)
 {
-    PdfObject fontRef;
+    Object fontRef;
     int i, l;
     if (!obj->isDict())
         pdftex_fail("PDF inclusion: invalid font resources dict type <%s>",
                     obj->getTypeName());
     pdf_puts("/Font << ");
     for (i = 0, l = obj->dictGetLength(); i < l; ++i) {
-        obj->dictGetValNF(i, &fontRef);
-        if (fontRef->isRef())
+        fontRef = obj->dictGetValNF(i);
+        if (fontRef.isRef())
             copyFont(obj->dictGetKey(i), &fontRef);
-        else if (fontRef->isDict()) {   // some programs generate pdf with embedded font object
+        else if (fontRef.isDict()) {   // some programs generate pdf with embedded font object
             copyName(obj->dictGetKey(i));
             pdf_puts(" ");
             copyObject(&fontRef);
         }
         else
             pdftex_fail("PDF inclusion: invalid font in reference type <%s>",
-                        fontRef->getTypeName());
+                        fontRef.getTypeName());
     }
     pdf_puts(">>\n");
 }
@@ -557,7 +545,7 @@
 
 static void copyObject(Object * obj)
 {
-    PdfObject obj1;
+    Object obj1;
     int i, l, c;
     Ref ref;
     char *p;
@@ -601,8 +589,8 @@
     } else if (obj->isArray()) {
         pdf_puts("[");
         for (i = 0, l = obj->arrayGetLength(); i < l; ++i) {
-            obj->arrayGetNF(i, &obj1);
-            if (!obj1->isName())
+            obj1 = obj->arrayGetNF(i);
+            if (!obj1.isName())
                 pdf_puts(" ");
             copyObject(&obj1);
         }
@@ -612,9 +600,8 @@
         copyDict(obj);
         pdf_puts(">>");
     } else if (obj->isStream()) {
-        initDictFromDict(obj1, obj->streamGetDict());
         pdf_puts("<<\n");
-        copyDict(&obj1);
+        copyDict(obj->getStream()->getDictObject());
         pdf_puts(">>\n");
         pdf_puts("stream\n");
         copyStream(obj->getStream()->getUndecodedStream());
@@ -638,9 +625,8 @@
     InObj *r;
     for (r = inObjList; r != 0; r = r->next) {
         if (!r->written) {
-            Object obj1;
             r->written = 1;
-            xref->fetch(r->ref.num, r->ref.gen, &obj1);
+            Object obj1 = xref->fetch(r->ref.num, r->ref.gen);
             if (r->type == objFont) {
                 assert(!obj1.isStream());
                 pdfbeginobj(r->num, 2);         // \pdfobjcompresslevel = 2 is for this
@@ -656,7 +642,6 @@
                 pdf_puts("\n");
                 pdfendobj();
             }
-            obj1.free();
         }
     }
 }
@@ -839,8 +824,8 @@
     Page *page;
     Ref *pageRef;
     Dict *pageDict;
-    PdfObject contents, obj1, obj2, pageObj, dictObj;
-    PdfObject groupDict;
+    Object contents, obj1, obj2, pageObj, dictObj;
+    Object groupDict;
     bool writeSepGroup = false;
     Object info;
     char *key;
@@ -867,8 +852,8 @@
     encodingList = 0;
     page = pdf_doc->doc->getCatalog()->getPage(epdf_selected_page);
     pageRef = pdf_doc->doc->getCatalog()->getPageRef(epdf_selected_page);
-    xref->fetch(pageRef->num, pageRef->gen, &pageObj);
-    pageDict = pageObj->getDict();
+    pageObj = xref->fetch(pageRef->num, pageRef->gen);
+    pageDict = pageObj.getDict();
     rotate = page->getRotate();
     PDFRectangle *pagebox;
     // write the Page header
@@ -886,7 +871,7 @@
         pdf_printf("/%s.PageNumber %i\n", pdfkeyprefix, (int) epdf_selected_page);
     }
     if ((suppress_ptex_info & MASK_SUPPRESS_PTEX_INFODICT) == 0) {
-        pdf_doc->doc->getDocInfoNF(&info);
+        info = pdf_doc->doc->getDocInfoNF();
         if (info.isRef()) {
             // the info dict must be indirect (PDF Ref p. 61)
             pdf_printf("/%s.InfoDict ", pdfkeyprefix);
@@ -942,14 +927,14 @@
     pdf_puts(stripzeros(s));
 
     // Metadata validity check (as a stream it must be indirect)
-    pageDict->lookupNF("Metadata", &dictObj);
-    if (!dictObj->isNull() && !dictObj->isRef())
+    dictObj = pageDict->lookupNF("Metadata");
+    if (!dictObj.isNull() && !dictObj.isRef())
         pdftex_warn("PDF inclusion: /Metadata must be indirect object");
 
     // copy selected items in Page dictionary except Resources & Group
     for (i = 0; pageDictKeys[i] != NULL; i++) {
-        pageDict->lookupNF(pageDictKeys[i], &dictObj);
-        if (!dictObj->isNull()) {
+        dictObj = pageDict->lookupNF(pageDictKeys[i]);
+        if (!dictObj.isNull()) {
             pdf_newline();
             pdf_printf("/%s ", pageDictKeys[i]);
             copyObject(&dictObj); // preserves indirection
@@ -957,8 +942,8 @@
     } 
 
     // handle page group
-    pageDict->lookupNF("Group", &dictObj);
-    if (!dictObj->isNull()) {
+    dictObj = pageDict->lookupNF("Group");
+    if (!dictObj.isNull()) {
         if (pdfpagegroupval == 0) { 
             // another pdf with page group was included earlier on the
             // same page; copy the Group entry as is.  See manual for
@@ -972,11 +957,11 @@
             copyObject(&dictObj);
         } else {
             // write Group dict as a separate object, since the Page dict also refers to it
-            pageDict->lookup("Group", &dictObj);
-            if (!dictObj->isDict())
+            dictObj = pageDict->lookup("Group");
+            if (!dictObj.isDict())
                 pdftex_fail("PDF inclusion: /Group dict missing");
             writeSepGroup = true;
-            initDictFromDict(groupDict, page->getGroup());
+            groupDict = Object(page->getGroup());
             pdf_printf("/Group %ld 0 R\n", (long)pdfpagegroupval);
         }
     }
@@ -989,14 +974,14 @@
         pdftex_warn
             ("PDF inclusion: /Resources missing. 'This practice is not recommended' (PDF Ref)");
     } else {
-        initDictFromDict(obj1, page->getResourceDict());
+        Object *obj1 = page->getResourceDictObject();
         if (!obj1->isDict())
             pdftex_fail("PDF inclusion: invalid resources dict type <%s>",
                         obj1->getTypeName());
         pdf_newline();
         pdf_puts("/Resources <<\n");
         for (i = 0, l = obj1->dictGetLength(); i < l; ++i) {
-            obj1->dictGetVal(i, &obj2);
+            obj2 = obj1->dictGetVal(i);
             key = obj1->dictGetKey(i);
             if (strcmp("Font", key) == 0)
                 copyFontResources(&obj2);
@@ -1009,8 +994,8 @@
     }
 
     // write the page contents
-    page->getContents(&contents);
-    if (contents->isStream()) {
+    contents = page->getContents();
+    if (contents.isStream()) {
 
         // Variant A: get stream and recompress under control
         // of \pdfcompresslevel
@@ -1021,36 +1006,35 @@
 
         // Variant B: copy stream without recompressing
         //
-        contents->streamGetDict()->lookup("F", &obj1);
-        if (!obj1->isNull()) {
+        obj1 = contents.streamGetDict()->lookup("F");
+        if (!obj1.isNull()) {
             pdftex_fail("PDF inclusion: Unsupported external stream");
         }
-        contents->streamGetDict()->lookup("Length", &obj1);
-        assert(!obj1->isNull());
+        obj1 = contents.streamGetDict()->lookup("Length");
+        assert(!obj1.isNull());
         pdf_puts("/Length ");
         copyObject(&obj1);
         pdf_puts("\n");
-        contents->streamGetDict()->lookup("Filter", &obj1);
-        if (!obj1->isNull()) {
+        obj1 = contents.streamGetDict()->lookup("Filter");
+        if (!obj1.isNull()) {
             pdf_puts("/Filter ");
             copyObject(&obj1);
             pdf_puts("\n");
-            contents->streamGetDict()->lookup("DecodeParms", &obj1);
-            if (!obj1->isNull()) {
+            obj1 = contents.streamGetDict()->lookup("DecodeParms");
+            if (!obj1.isNull()) {
                 pdf_puts("/DecodeParms ");
                 copyObject(&obj1);
                 pdf_puts("\n");
             }
         }
         pdf_puts(">>\nstream\n");
-        copyStream(contents->getStream()->getUndecodedStream());
+        copyStream(contents.getStream()->getUndecodedStream());
         pdfendstream();
-    } else if (contents->isArray()) {
+    } else if (contents.isArray()) {
         pdfbeginstream();
-        for (i = 0, l = contents->arrayGetLength(); i < l; ++i) {
-            Object contentsobj;
-            copyStream((contents->arrayGet(i, &contentsobj))->getStream());
-            contentsobj.free();
+        for (i = 0, l = contents.arrayGetLength(); i < l; ++i) {
+            Object contentsobj = contents.arrayGet(i);
+            copyStream(contentsobj.getStream());
             if (i < l - 1)
                 pdf_newline();  // add a newline after each stream except the last
         }
diff -ur source.orig/texk/web2c/pdftexdir/pdftosrc.cc source/texk/web2c/pdftexdir/pdftosrc.cc
--- source.orig/texk/web2c/pdftexdir/pdftosrc.cc	2017-06-16 21:49:09.297190679 +0200
+++ source/texk/web2c/pdftexdir/pdftosrc.cc	2017-09-19 09:48:19.661355046 +0200
@@ -86,22 +86,20 @@
             objgen = atoi(argv[3]);
     }
     xref = doc->getXRef();
-    catalogDict.initNull();
-    xref->getCatalog(&catalogDict);
+    catalogDict = xref->getCatalog();
     if (!catalogDict.isDict("Catalog")) {
         fprintf(stderr, "No Catalog found\n");
         exit(1);
     }
-    srcStream.initNull();
+    srcStream = Object(objNull);
     if (objnum == 0) {
-        catalogDict.dictLookup("SourceObject", &srcStream);
+        srcStream = catalogDict.dictLookup("SourceObject");
         static char const_SourceFile[] = "SourceFile";
         if (!srcStream.isStream(const_SourceFile)) {
             fprintf(stderr, "No SourceObject found\n");
             exit(1);
         }
-        srcName.initNull();
-        srcStream.getStream()->getDict()->lookup("SourceName", &srcName);
+        srcName = srcStream.getStream()->getDict()->lookup("SourceName");
         if (!srcName.isString()) {
             fprintf(stderr, "No SourceName found\n");
             exit(1);
@@ -110,7 +108,7 @@
         // We cannot free srcName, as objname shares its string.
         // srcName.free();
     } else if (objnum > 0) {
-        xref->fetch(objnum, objgen, &srcStream);
+        srcStream = xref->fetch(objnum, objgen);
         if (!srcStream.isStream()) {
             fprintf(stderr, "Not a Stream object\n");
             exit(1);
@@ -159,29 +157,26 @@
                 int localOffset = 0;
                 Guint firstOffset;
 
-                assert(xref->fetch(e->offset, 0, &objStr)->isStream());
-                nObjects = objStr.streamGetDict()->lookup("N", &obj1)->getInt();
-                obj1.free();
-                first = objStr.streamGetDict()->lookup("First", &obj1)->getInt();
-                obj1.free();
+                objStr = xref->fetch(e->offset, 0);
+                assert(objStr.isStream());
+                obj1 = objStr.streamGetDict()->lookup("N");
+                nObjects = obj1.getInt();
+                obj1 = objStr.streamGetDict()->lookup("First");
+                first = obj1.getInt();
                 firstOffset = objStr.getStream()->getBaseStream()->getStart() + first;
 
                 // parse the header: object numbers and offsets
                 objStr.streamReset();
-                obj1.initNull();
-                str = new EmbedStream(objStr.getStream(), &obj1, gTrue, first);
+                str = new EmbedStream(objStr.getStream(), Object(objNull), gTrue, first);
                 parser = new Parser(xref, new Lexer(xref, str), gFalse);
                 for (n = 0; n < nObjects; ++n) {
-                    parser->getObj(&obj1);
-                    parser->getObj(&obj2);
+                    obj1 = parser->getObj();
+                    obj2 = parser->getObj();
                     if (n == e->gen)
                         localOffset = obj2.getInt();
-                    obj1.free();
-                    obj2.free();
                 }
                 while (str->getChar() != EOF) ;
                 delete parser;
-                objStr.free();
 
                 fprintf(outfile, "%.10lu 00000 n\n",
                         (long unsigned)(firstOffset + localOffset));
@@ -192,7 +187,6 @@
         s->reset();
         while ((c = s->getChar()) != EOF)
             fputc(c, outfile);
-        srcStream.free();
     }
     if (objnum == 0)
         fprintf(stderr, "Source file extracted to %s\n", outname);
@@ -201,7 +195,6 @@
     else
         fprintf(stderr, "Cross-reference table extracted to %s\n", outname);
     fclose(outfile);
-    catalogDict.free();
     delete doc;
     delete globalParams;
 }
