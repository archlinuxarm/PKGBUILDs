#!/usr/bin/env python
# coding= UTF-8
#
# Created by Mika 'ighea' Hynn√§ <ighea[at]iki[dot]fi>

# Set the ABS and GIT directories here:
git_dir="/media/Plugbox/builder/plugapps/"
abs_dir="/media/Plugbox/builder/abs/"

import os
import sys
import distutils
from distutils import version
import subprocess
import time

abs_updater_version="2010.04.28"

class UpdateCheck:

	def __init__(self, git_dir="/media/Plugbox/builder/plugapps/",abs_dir="/media/Plugbox/builder/abs/"):
		self.abs_dir=abs_dir
		self.git_dir=git_dir
		return

	def is_greater(self, ver1, ver2):
		# Checks if ver2 is greater than ver1

		v1,r1 = ver1.split("-")
		v2,r2 = ver2.split("-")
		if (v1 == v2 and int(r1) < int(r2)):
			return True

		v1 = v1.split(".")
		v2 = v2.split(".")

		for i in range(0, len(v2)):
			if (int(v1[i]) == int(v2[i])):
				#print v1[i], "==", v2[i]
				continue
			else:
				if (int(v1[i]) < int(v2[i])):
					#print v1[i], "<", v2[i]
					return True
				else:
					#print v1[i], ">=", v2[i]
					return False

		return False

	def get_local_database_items(self):
		repopackages = []
		# Fetch available packages
		pipe = os.popen("pacman -Sl", "r")
		for line in pipe:
			data = line.replace(os.linesep,"")
			repo, name, version = data.split(" ")
			repopackages.append((repo,name,version))
		pipe.close()

		return repopackages

	def pretify_pkgbuild_line(self, line):
		charp=line.find('#')
		if charp != -1:
			line = line[:charp].strip()
		line = line.replace(' ', '').replace(os.linesep,'')
		return line

	def get_version(self, pkgbuild, verbose=False):
		# Returns the PKGBUILD's version string (pkgver-pkgrel)
		version = "0"

		p = subprocess.Popen("source "+pkgbuild+"; echo -n version:$pkgver-$pkgrel", shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, close_fds=True)
		datain, err = p.communicate()
		if (len(datain) > 0):
			vstart = datain.find("version:")
			if (vstart != -1):
				version = datain[vstart+len("version:"):]
		
		if (verbose and err != None and len(err.strip()) > 0):
			print "ERR:", err
		return version

	def check_package(self, repo, name, version,verbose=False):

		pkgbuild_path = self.abs_dir+os.path.sep+repo+os.path.sep+name+os.path.sep+"PKGBUILD"
		pkgbuild_git_path = self.git_dir+os.path.sep+repo+os.path.sep+name+os.path.sep+"PKGBUILD"
		
		# First check git path
		if os.path.exists(pkgbuild_git_path):
			git_version = self.get_version(pkgbuild_path)
			current = distutils.version.LooseVersion(version)
			gitver = distutils.version.LooseVersion(git_version)
			if (current < gitver):
				return git_version
		# If pkgbuild was not found or it was not newer than current pacman database item
		# check the ABS database for item
		if os.path.exists(pkgbuild_path):
			abs_version = self.get_version(pkgbuild_path)
			current = distutils.version.LooseVersion(version)
			absver = distutils.version.LooseVersion(abs_version)
			if (current < absver):
				return abs_version
		elif(verbose):
			print "Couldn't find ABS entry for package: "+repo+"/"+name+""	
		return None
	
	def get_updates(self, verbose=False):
		# Returns array of tuples (repo, name, current_version, new_version)
		updates=[]
		newversion=""
		# Go through all local database packages and check if there's a newer package in abs (abs_dir)
		for repo, name, version in self.get_local_database_items():
			newversion = self.check_package(repo, name, version, verbose)
			if (newversion != None):
				if (verbose):
					print repo+"/"+name, "current:", version, "version in abs:", newversion
				updates.append((repo,name,version,newversion))
		return updates

	def updates(self, verbose=False, outputfile=None, replaceoutputfile=False):
		updates = self.get_updates(verbose)
		if (len(updates) > 0):
			print "Package\tCurrent\t-\tNew"
			for repo, name, current, new in updates:
				print repo+"/"+name+" "+current+" --> "+new

			if (outputfile != None):
				data = ""
				olddata=""

				if (replaceoutputfile == False):
					if (os.path.exists(outputfile)):
						try:
							FILE = open(outputfile, "r")
							olddata = FILE.read()
							FILE.close()
						except:
							print "Error while opening outputfile: "+outputfile
	
				data = "<p><table id=\"checker_table\">\n"
				data += "<caption>Checked on "+time.ctime(time.time())+"</caption>\n"
				data += "<tr>"
				data += "<th class=\"checker_header\">Package</th>"
				data += "<th class=\"checker_header\">Current</th>"
				data += "<th class=\"checker_header\">Available</th>"
				data += "</tr>\n"
				for repo, name, current, new in updates:
					data += "<tr>"
					data += "<td class=\"checker_repository\">"+repo+"/"+name+"</td>"
					data += "<td class=\"checker_current\">"+current+"</td>"
					data += "<td class=\"checker_new\">"+new+"</td>"
					data += "</tr>\n"
				data += "</table></p>\n"
	
				try:
					FILE = open(outputfile, "w")
					FILE.write(data)
					FILE.write(olddata)
					FILE.close()
				except:
					print "ERROR: Couldn't write to outputfile: "+outputfile
		else:
			print "Everything is up-to-date!"
		
		return

if __name__ == "__main__":
	verbose = False
	outputfile = None
	replaceoutputfile = False
	if (len(sys.argv) <= 1):
		print "ABSChecker v"+abs_updater_version
		print ""
		print "Checks packages in current pacman repository database against PKGBUILDs in local ABS database and returns list of out-of-date packages."
		print ""
		print " Usage: abschecker command [-v] [outputfile]"
		print "  commands:"
		print "    check\t\t check for updates"
		print "  flags:"
		print "    -v\t\t very verbose mode"
		print "    -r\t\t do not append to outputfile, replace instead"
		print ""
		print " If 'outputfile' is specified abschecker will dump a html output in it."
		print ""
	else:
		if (sys.argv[1] == "check"):
			counter=0
			for arg in sys.argv:
				counter+=1
				if (arg.startswith("-")):
					if (arg == "-v"):
						verbose = True
						print "Verbose mode ON"
					elif (arg == "-r"):
						replaceoutputfile = True
						print "Output file set to be replaced if specified"
				elif (counter > 2):
					if (len(sys.argv) >= 3 and len(sys.argv[2]) > 0):
						outputfile = arg
						print "Output to: "+outputfile

			uc = UpdateCheck(git_dir, abs_dir)
			uc.updates(verbose, outputfile, replaceoutputfile)
		else:
			print "Invalid command!"







