diff -ruN a/arch/arm/boot/dts/kirkwood-dockstar.dts b/arch/arm/boot/dts/kirkwood-dockstar.dts
--- a/arch/arm/boot/dts/kirkwood-dockstar.dts	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-dockstar.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,57 +0,0 @@
-/dts-v1/;
-
-/include/ "kirkwood.dtsi"
-
-/ {
-	model = "Seagate FreeAgent Dockstar";
-	compatible = "seagate,dockstar", "marvell,kirkwood-88f6281", "marvell,kirkwood";
-
-	memory {
-		device_type = "memory";
-		reg = <0x00000000 0x8000000>;
-	};
-
-	chosen {
-		bootargs = "console=ttyS0,115200n8 earlyprintk root=/dev/sda1 rootdelay=10";
-	};
-
-	ocp@f1000000 {
-		serial@12000 {
-			clock-frequency = <200000000>;
-			status = "ok";
-		};
-
-		nand@3000000 {
-			status = "okay";
-
-			partition@0 {
-				label = "u-boot";
-				reg = <0x0000000 0x100000>;
-				read-only;
-			};
-
-			partition@100000 {
-				label = "uImage";
-				reg = <0x0100000 0x400000>;
-			};
-
-			partition@500000 {
-				label = "data";
-				reg = <0x0500000 0xfb00000>;
-			};
-		};
-	};
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		health {
-			label = "status:green:health";
-			gpios = <&gpio1 14 1>;
-			linux,default-trigger = "default-on";
-		};
-		fault {
-			label = "status:orange:fault";
-			gpios = <&gpio1 15 1>;
-		};
-	};
-};
diff -ruN a/arch/arm/boot/dts/kirkwood-goflexnet.dts b/arch/arm/boot/dts/kirkwood-goflexnet.dts
--- a/arch/arm/boot/dts/kirkwood-goflexnet.dts	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-goflexnet.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,99 +0,0 @@
-/dts-v1/;
-
-/include/ "kirkwood.dtsi"
-
-/ {
-	model = "Seagate GoFlex Net";
-	compatible = "seagate,goflexnet", "marvell,kirkwood-88f6281", "marvell,kirkwood";
-
-	memory {
-		device_type = "memory";
-		reg = <0x00000000 0x8000000>;
-	};
-
-	chosen {
-		bootargs = "console=ttyS0,115200n8 earlyprintk root=/dev/sda1 rootdelay=10";
-	};
-
-	ocp@f1000000 {
-		serial@12000 {
-			clock-frequency = <200000000>;
-			status = "ok";
-		};
-
-		nand@3000000 {
-			status = "okay";
-
-			partition@0 {
-				label = "u-boot";
-				reg = <0x0000000 0x100000>;
-				read-only;
-			};
-
-			partition@100000 {
-				label = "uImage";
-				reg = <0x0100000 0x400000>;
-			};
-
-			partition@500000 {
-				label = "pogoplug";
-				reg = <0x0500000 0x2000000>;
-			};
-
-			partition@2500000 {
-				label = "root";
-				reg = <0x02500000 0xd800000>;
-			};
-		};
-		sata@80000 {
-			status = "okay";
-			nr-ports = <2>;
-		};
-
-	};
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		health {
-			label = "status:green:health";
-			gpios = <&gpio1 14 1>;
-			linux,default-trigger = "default-on";
-		};
-		fault {
-			label = "status:orange:fault";
-			gpios = <&gpio1 15 1>;
-		};
-		left0 {
-			label = "status:white:left0";
-			gpios = <&gpio1 10 0>;
-		};
-		left1 {
-			label = "status:white:left1";
-			gpios = <&gpio1 11 0>;
-		};
-		left2 {
-			label = "status:white:left2";
-			gpios = <&gpio1 12 0>;
-		};
-		left3 {
-			label = "status:white:left3";
-			gpios = <&gpio1 13 0>;
-		};
-		right0 {
-			label = "status:white:right0";
-			gpios = <&gpio1 6 0>;
-		};
-		right1 {
-			label = "status:white:right1";
-			gpios = <&gpio1 7 0>;
-		};
-		right2 {
-			label = "status:white:right2";
-			gpios = <&gpio1 8 0>;
-		};
-		right3 {
-			label = "status:white:right3";
-			gpios = <&gpio1 9 0>;
-		};
-	};
-};
diff -ruN a/arch/arm/boot/dts/kirkwood-iconnect.dts b/arch/arm/boot/dts/kirkwood-iconnect.dts
--- a/arch/arm/boot/dts/kirkwood-iconnect.dts	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-iconnect.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,120 +0,0 @@
-/dts-v1/;
-
-/include/ "kirkwood.dtsi"
-
-/ {
-	model = "Iomega Iconnect";
-	compatible = "iom,iconnect-1.1", "iom,iconnect", "marvell,kirkwood-88f6281", "marvell,kirkwood";
-
-	memory {
-		device_type = "memory";
-		reg = <0x00000000 0x10000000>;
-	};
-
-	chosen {
-		bootargs = "console=ttyS0,115200n8 earlyprintk";
-		linux,initrd-start = <0x4500040>;
-		linux,initrd-end   = <0x4800000>;
-	};
-
-	ocp@f1000000 {
-		i2c@11000 {
-			status = "okay";
-
-			lm63: lm63@4c {
-				compatible = "national,lm63";
-				reg = <0x4c>;
-			};
-		};
-		serial@12000 {
-			clock-frequency = <200000000>;
-			status = "ok";
-		};
-
-		nand@3000000 {
-			status = "okay";
-
-			partition@0 {
-				label = "uboot";
-				reg = <0x0000000 0xc0000>;
-			};
-
-			partition@a0000 {
-				label = "env";
-				reg = <0xa0000 0x20000>;
-			};
-
-			partition@100000 {
-				label = "zImage";
-				reg = <0x100000 0x300000>;
-			};
-
-			partition@540000 {
-				label = "initrd";
-				reg = <0x540000 0x300000>;
-			};
-
-			partition@980000 {
-				label = "boot";
-				reg = <0x980000 0x1f400000>;
-			};
-		};
-	};
-
-	gpio-leds {
-		compatible = "gpio-leds";
-
-		led-level {
-			label = "led_level";
-			gpios = <&gpio1 9 0>;
-			linux,default-trigger = "default-on";
-		};
-		power-blue {
-			label = "power:blue";
-			gpios = <&gpio1 10 0>;
-			linux,default-trigger = "timer";
-		};
-		power-red {
-			label = "power:red";
-			gpios = <&gpio1 11 0>;
-		};
-		usb1 {
-			label = "usb1:blue";
-			gpios = <&gpio1 12 0>;
-		};
-		usb2 {
-			label = "usb2:blue";
-			gpios = <&gpio1 13 0>;
-		};
-		usb3 {
-			label = "usb3:blue";
-			gpios = <&gpio1 14 0>;
-		};
-		usb4 {
-			label = "usb4:blue";
-			gpios = <&gpio1 15 0>;
-		};
-		otb {
-			label = "otb:blue";
-			gpios = <&gpio1 16 0>;
-		};
-	};
-
-	gpio_keys {
-		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		button@1 {
-			label = "OTB Button";
-			linux,code = <133>;
-			gpios = <&gpio1 3 1>;
-			debounce-interval = <100>;
-		};
-		button@2 {
-			label = "Reset";
-			linux,code = <0x198>;
-			gpios = <&gpio0 12 1>;
-			debounce-interval = <100>;
-		};
-	};
-};
diff -ruN a/arch/arm/boot/dts/kirkwood-ts219-6281.dts b/arch/arm/boot/dts/kirkwood-ts219-6281.dts
--- a/arch/arm/boot/dts/kirkwood-ts219-6281.dts	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-ts219-6281.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/dts-v1/;
-
-/include/ "kirkwood-ts219.dtsi"
-
-/ {
-	gpio_keys {
-		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		button@1 {
-			label = "USB Copy";
-			linux,code = <133>;
-			gpios = <&gpio0 15 1>;
-		};
-		button@2 {
-			label = "Reset";
-			linux,code = <0x198>;
-			gpios = <&gpio0 16 1>;
-		};
-	};
-};
\ Kein Zeilenumbruch am Dateiende.
diff -ruN a/arch/arm/boot/dts/kirkwood-ts219-6282.dts b/arch/arm/boot/dts/kirkwood-ts219-6282.dts
--- a/arch/arm/boot/dts/kirkwood-ts219-6282.dts	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-ts219-6282.dts	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
-/dts-v1/;
-
-/include/ "kirkwood-ts219.dtsi"
-
-/ {
-	gpio_keys {
-		compatible = "gpio-keys";
-		#address-cells = <1>;
-		#size-cells = <0>;
-		button@1 {
-			label = "USB Copy";
-			linux,code = <133>;
-			gpios = <&gpio1 11 1>;
-		};
-		button@2 {
-			label = "Reset";
-			linux,code = <0x198>;
-			gpios = <&gpio1 5 1>;
-		};
-	};
-};
\ Kein Zeilenumbruch am Dateiende.
diff -ruN a/arch/arm/boot/dts/kirkwood-ts219.dtsi b/arch/arm/boot/dts/kirkwood-ts219.dtsi
--- a/arch/arm/boot/dts/kirkwood-ts219.dtsi	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/boot/dts/kirkwood-ts219.dtsi	1970-01-01 01:00:00.000000000 +0100
@@ -1,78 +0,0 @@
-/include/ "kirkwood.dtsi"
-
-/ {
-	model = "QNAP TS219 family";
-	compatible = "qnap,ts219", "marvell,kirkwood";
-
-	memory {
-		device_type = "memory";
-		reg = <0x00000000 0x20000000>;
-	};
-
-	chosen {
-		bootargs = "console=ttyS0,115200n8";
-	};
-
-	ocp@f1000000 {
-		i2c@11000 {
-			status = "okay";
-			clock-frequency = <400000>;
-
-			s35390a: s35390a@30 {
-				compatible = "s35390a";
-				reg = <0x30>;
-			};
-		};
-		serial@12000 {
-			clock-frequency = <200000000>;
-			status = "okay";
-		};
-		serial@12100 {
-			clock-frequency = <200000000>;
-			status = "okay";
-		};
-		spi@10600 {
-			status = "okay";
-
-			m25p128@0 {
-				#address-cells = <1>;
-				#size-cells = <1>;
-				compatible = "m25p128";
-				reg = <0>;
-				spi-max-frequency = <20000000>;
-				mode = <0>;
-
-				partition@0000000 {
-					reg = <0x00000000 0x00080000>;
-					label = "U-Boot";
-				};
-
-				partition@00200000 {
-					reg = <0x00200000 0x00200000>;
-					label = "Kernel";
-				};
-
-				partition@00400000 {
-					reg = <0x00400000 0x00900000>;
-					label = "RootFS1";
-				};
-				partition@00d00000 {
-					reg = <0x00d00000 0x00300000>;
-					label = "RootFS2";
-				};
-				partition@00040000 {
-					reg = <0x00080000 0x00040000>;
-					label = "U-Boot Config";
-				};
-				partition@000c0000 {
-					reg = <0x000c0000 0x00140000>;
-					label = "NAS Config";
-				};
-			};
-		};
-		sata@80000 {
-			status = "okay";
-			nr-ports = <2>;
-		};
-	};
-};
diff -ruN a/arch/arm/mach-kirkwood/board-goflexnet.c b/arch/arm/mach-kirkwood/board-goflexnet.c
--- a/arch/arm/mach-kirkwood/board-goflexnet.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/board-goflexnet.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
-/*
- * Copyright 2012 (C), Jason Cooper <jason@lakedaemon.net>
- *
- * arch/arm/mach-kirkwood/board-goflexnet.c
- *
- * Seagate GoFlext Net Board Init for drivers not converted to
- * flattened device tree yet.
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- *
- * Copied and modified for Seagate GoFlex Net support by
- * Joshua Coombs <josh.coombs@gmail.com> based on ArchLinux ARM's
- * GoFlex kernel patches.
- *
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/ata_platform.h>
-#include <linux/mv643xx_eth.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_fdt.h>
-#include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/gpio.h>
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/map.h>
-#include <mach/kirkwood.h>
-#include <mach/bridge-regs.h>
-#include <linux/platform_data/mmc-mvsdio.h>
-#include "common.h"
-#include "mpp.h"
-
-static struct mv643xx_eth_platform_data goflexnet_ge00_data = {
-	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
-};
-
-static unsigned int goflexnet_mpp_config[] __initdata = {
-	MPP29_GPIO,	/* USB Power Enable */
-	MPP47_GPIO,	/* LED Orange */
-	MPP46_GPIO,	/* LED Green */
-	MPP45_GPIO,	/* LED Left Capacity 3 */
-	MPP44_GPIO,	/* LED Left Capacity 2 */
-	MPP43_GPIO,	/* LED Left Capacity 1 */
-	MPP42_GPIO,	/* LED Left Capacity 0 */
-	MPP41_GPIO,	/* LED Right Capacity 3 */
-	MPP40_GPIO,	/* LED Right Capacity 2 */
-	MPP39_GPIO,	/* LED Right Capacity 1 */
-	MPP38_GPIO,	/* LED Right Capacity 0 */
-	0
-};
-
-void __init goflexnet_init(void)
-{
-	/*
-	 * Basic setup. Needs to be called early.
-	 */
-	kirkwood_mpp_conf(goflexnet_mpp_config);
-
-	if (gpio_request(29, "USB Power Enable") != 0 ||
-	    gpio_direction_output(29, 1) != 0)
-		pr_err("can't setup GPIO 29 (USB Power Enable)\n");
-	kirkwood_ehci_init();
-
-	kirkwood_ge00_init(&goflexnet_ge00_data);
-}
diff -ruN a/arch/arm/mach-kirkwood/board-iconnect.c b/arch/arm/mach-kirkwood/board-iconnect.c
--- a/arch/arm/mach-kirkwood/board-iconnect.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/board-iconnect.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,58 +0,0 @@
-/*
- * arch/arm/mach-kirkwood/board-iconnect.c
- *
- * Iomega i-connect Board Setup
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2.  This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/of.h>
-#include <linux/of_address.h>
-#include <linux/of_fdt.h>
-#include <linux/of_irq.h>
-#include <linux/of_platform.h>
-#include <linux/mv643xx_eth.h>
-#include <linux/gpio.h>
-#include <asm/mach/arch.h>
-#include <mach/kirkwood.h>
-#include "common.h"
-#include "mpp.h"
-
-static struct mv643xx_eth_platform_data iconnect_ge00_data = {
-	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
-};
-
-static unsigned int iconnect_mpp_config[] __initdata = {
-	MPP12_GPIO,
-	MPP35_GPIO,
-	MPP41_GPIO,
-	MPP42_GPIO,
-	MPP43_GPIO,
-	MPP44_GPIO,
-	MPP45_GPIO,
-	MPP46_GPIO,
-	MPP47_GPIO,
-	MPP48_GPIO,
-	0
-};
-
-void __init iconnect_init(void)
-{
-	kirkwood_mpp_conf(iconnect_mpp_config);
-
-	kirkwood_ehci_init();
-	kirkwood_ge00_init(&iconnect_ge00_data);
-}
-
-static int __init iconnect_pci_init(void)
-{
-	if (of_machine_is_compatible("iom,iconnect"))
-		kirkwood_pcie_init(KW_PCIE0);
-	return 0;
-}
-subsys_initcall(iconnect_pci_init);
diff -ruN a/arch/arm/mach-kirkwood/common.h b/arch/arm/mach-kirkwood/common.h
--- a/arch/arm/mach-kirkwood/common.h	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/common.h	2012-12-11 18:35:14.634683186 +0100
@@ -70,12 +70,6 @@
 static inline void dnskw_init(void) {};
 #endif
 
-#ifdef CONFIG_MACH_ICONNECT_DT
-void iconnect_init(void);
-#else
-static inline void iconnect_init(void) {};
-#endif
-
 #ifdef CONFIG_MACH_IB62X0_DT
 void ib62x0_init(void);
 #else
@@ -88,12 +82,6 @@
 static inline void dockstar_dt_init(void) {};
 #endif
 
-#ifdef CONFIG_MACH_GOFLEXNET_DT
-void goflexnet_init(void);
-#else
-static inline void goflexnet_init(void) {};
-#endif
-
 #ifdef CONFIG_MACH_LSXL_DT
 void lsxl_init(void);
 #else
diff -ruN a/arch/arm/mach-kirkwood/dockstar-setup.c b/arch/arm/mach-kirkwood/dockstar-setup.c
--- a/arch/arm/mach-kirkwood/dockstar-setup.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/dockstar-setup.c	2012-12-11 18:34:46.744502480 +0100
@@ -29,6 +29,10 @@
 		.offset = 0,
 		.size = SZ_1M
 	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
 		.name = "uImage",
 		.offset = MTDPART_OFS_NXTBLK,
 		.size = SZ_4M
@@ -45,17 +49,17 @@
 
 static struct gpio_led dockstar_led_pins[] = {
 	{
-		.name			= "dockstar:green:health",
+		.name			= "status:green:health",
 		.default_trigger	= "default-on",
 		.gpio			= 46,
 		.active_low		= 1,
 	},
 	{
-		.name			= "dockstar:orange:misc",
+		.name			= "status:orange:fault",
 		.default_trigger	= "none",
 		.gpio			= 47,
 		.active_low		= 1,
-	},
+	}
 };
 
 static struct gpio_led_platform_data dockstar_led_data = {
@@ -73,8 +77,8 @@
 
 static unsigned int dockstar_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
-	MPP46_GPIO,	/* LED green */
-	MPP47_GPIO,	/* LED orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP47_GPIO,	/* LED Orange */
 	0
 };
 
diff -ruN a/arch/arm/mach-kirkwood/goflexhome-setup.c b/arch/arm/mach-kirkwood/goflexhome-setup.c
--- a/arch/arm/mach-kirkwood/goflexhome-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/goflexhome-setup.c	2012-12-11 18:34:46.745502504 +0100
@@ -0,0 +1,124 @@
+/*
+ * arch/arm/mach-kirkwood/goflexhome-setup.c
+ *
+ * Seagate GoFlex Home Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexhome_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_2M + SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexhome_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexhome_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_led goflexhome_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:misc",
+		.default_trigger	= "none",
+		.gpio			= 40,
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexhome_led_data = {
+	.leds		= goflexhome_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexhome_led_pins),
+};
+
+static struct platform_device goflexhome_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexhome_led_data,
+	}
+};
+
+static unsigned int goflexhome_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP40_GPIO,	/* LED White */
+	0
+};
+
+static void __init goflexhome_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexhome_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexhome_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexhome_ge00_data);
+	kirkwood_sata_init(&goflexhome_sata_data);
+
+	platform_device_register(&goflexhome_leds);
+}
+
+MACHINE_START(GOFLEXHOME, "Seagate GoFlex Home")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= goflexhome_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
+
diff -ruN a/arch/arm/mach-kirkwood/goflexnet-setup.c b/arch/arm/mach-kirkwood/goflexnet-setup.c
--- a/arch/arm/mach-kirkwood/goflexnet-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/goflexnet-setup.c	2012-12-11 18:34:46.745502504 +0100
@@ -0,0 +1,177 @@
+/*
+ * arch/arm/mach-kirkwood/goflexnet-setup.c
+ *
+ * Seagate GoFlex Net Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexnet_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexnet_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexnet_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led goflexnet_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46, // 0x4000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47, // 0x8000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:left0",
+		.default_trigger	= "none",
+		.gpio			= 42, // 0x0400
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left1",
+		.default_trigger	= "none",
+		.gpio			= 43, // 0x0800
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left2",
+		.default_trigger	= "none",
+		.gpio			= 44, // 0x1000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left3",
+		.default_trigger	= "none",
+		.gpio			= 45, // 0x2000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right0",
+		.default_trigger	= "none",
+		.gpio			= 38, // 0x0040
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right1",
+		.default_trigger	= "none",
+		.gpio			= 39, // 0x0080
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right2",
+		.default_trigger	= "none",
+		.gpio			= 40, // 0x0100
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right3",
+		.default_trigger	= "none",
+		.gpio			= 41, // 0x0200
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexnet_led_data = {
+	.leds		= goflexnet_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexnet_led_pins),
+};
+
+static struct platform_device goflexnet_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexnet_led_data,
+	}
+};
+
+static unsigned int goflexnet_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP45_GPIO,	/* LED Left Capacity 3 */
+	MPP44_GPIO,	/* LED Left Capacity 2 */
+	MPP43_GPIO,	/* LED Left Capacity 1 */
+	MPP42_GPIO,	/* LED Left Capacity 0 */
+	MPP41_GPIO,	/* LED Right Capacity 3 */
+	MPP40_GPIO,	/* LED Right Capacity 2 */
+	MPP39_GPIO,	/* LED Right Capacity 1 */
+	MPP38_GPIO,	/* LED Right Capacity 0 */
+	0
+};
+
+static void __init goflexnet_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexnet_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexnet_nand_parts), 40);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexnet_ge00_data);
+	kirkwood_sata_init(&goflexnet_sata_data);
+
+	platform_device_register(&goflexnet_leds);
+}
+
+MACHINE_START(GOFLEXNET, "Seagate GoFlex Net")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= goflexnet_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
+
diff -ruN a/arch/arm/mach-kirkwood/guruplug-setup.c b/arch/arm/mach-kirkwood/guruplug-setup.c
--- a/arch/arm/mach-kirkwood/guruplug-setup.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/guruplug-setup.c	2012-12-11 18:34:46.745502504 +0100
@@ -57,22 +57,24 @@
 
 static struct gpio_led guruplug_led_pins[] = {
 	{
-		.name			= "guruplug:red:health",
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
 		.gpio			= 46,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:green:health",
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
 		.gpio			= 47,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:red:wmode",
+		.name			= "status:red:wmode",
 		.gpio			= 48,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:green:wmode",
+		.name			= "status:green:wmode",
 		.gpio			= 49,
 		.active_low		= 1,
 	},
diff -ruN a/arch/arm/mach-kirkwood/iconnect-setup.c b/arch/arm/mach-kirkwood/iconnect-setup.c
--- a/arch/arm/mach-kirkwood/iconnect-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/iconnect-setup.c	2012-12-11 18:34:46.745502504 +0100
@@ -0,0 +1,204 @@
+/*
+ * arch/arm/mach-kirkwood/iconnect-setup.c
+ *
+ * Iomega iConnect Wireless
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition iconnect_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_1M + SZ_2M
+	}, {
+		.name = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M,
+	}, {
+		.name = "data",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data iconnect_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
+};
+
+static struct gpio_led iconnect_led_pins[] = {
+	{
+		.name			= "iconnect:led_level",
+		.default_trigger	= "default-on",
+		.gpio			= 41,
+	},
+	{
+		.name			= "iconnect:blue:power",
+		.default_trigger	= "default-on",
+		.gpio			= 42,
+	},
+	{
+		.name			= "iconnect:red:power",
+		.gpio			= 43,
+	},
+	{
+		.name			= "iconnect:blue:usb1",
+		.gpio			= 44,
+	},
+	{
+		.name			= "iconnect:blue:usb2",
+		.gpio			= 45,
+	},
+	{
+		.name			= "iconnect:blue:usb3",
+		.gpio			= 46,
+	},
+	{
+		.name			= "iconnect:blue:usb4",
+		.gpio			= 47,
+	},
+	{
+		.name			= "iconnect:blue:otb",
+		.gpio			= 48,
+	},
+};
+
+static struct gpio_led_platform_data iconnect_led_data = {
+	.leds		= iconnect_led_pins,
+	.num_leds	= ARRAY_SIZE(iconnect_led_pins),
+};
+
+static struct platform_device iconnect_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &iconnect_led_data,
+	}
+};
+
+#define ICONNECT_GPIO_KEY_RESET		12
+#define ICONNECT_GPIO_KEY_OTB		35
+
+#define ICONNECT_SW_RESET		0x00
+#define ICONNECT_SW_OTB			0x01
+
+static struct gpio_keys_button iconnect_buttons[] = {
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_RESET,
+		.gpio		= ICONNECT_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		}, 
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_OTB,
+		.gpio		= ICONNECT_GPIO_KEY_OTB,
+		.desc		= "OTB Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		},
+};
+
+static struct gpio_keys_platform_data iconnect_button_data = {
+	.buttons	= iconnect_buttons,
+	.nbuttons	= ARRAY_SIZE(iconnect_buttons),
+};
+
+static struct platform_device iconnect_button_device = {
+	.name	   = "gpio-keys",
+	.id	     = -1,
+	.num_resources	= 0,
+	.dev	    =	{
+					.platform_data  = &iconnect_button_data,
+					},
+};
+
+static unsigned int iconnect_mpp_config[] __initdata = {
+	MPP12_GPIO, /*Input for reset button*/
+	MPP35_GPIO, /*Input for OTB button*/
+	MPP41_GPIO,
+	MPP42_GPIO,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	0
+};
+
+static struct i2c_board_info __initdata iconnect_i2c_rtc = {
+	I2C_BOARD_INFO("lm63", 0x4c),
+};
+
+static void __init iconnect_init(void)
+{
+	u32 dev, rev;
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(iconnect_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(iconnect_nand_parts), 40);
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&iconnect_ge00_data);
+	kirkwood_pcie_id(&dev, &rev);
+
+	kirkwood_uart0_init();
+
+	platform_device_register(&iconnect_leds);
+	platform_device_register(&iconnect_button_device);
+	
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &iconnect_i2c_rtc, 1);
+
+}
+
+static int __init iconnect_pci_init(void)
+{
+	if (machine_is_iconnect())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(iconnect_pci_init);
+
+
+MACHINE_START(ICONNECT, "Iomega iConnect Wireless")
+	.atag_offset	= 0x100,
+	.init_machine	= iconnect_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/ionics-stratus-setup.c b/arch/arm/mach-kirkwood/ionics-stratus-setup.c
--- a/arch/arm/mach-kirkwood/ionics-stratus-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/ionics-stratus-setup.c	2012-12-11 22:47:53.032899067 +0100
@@ -0,0 +1,137 @@
+/*
+ * arch/arm/mach-kirkwood/ionics-stratus-setup.c
+ *
+ * Ionics Stratus Board Setup arcNumber 4184
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition ionics_stratus_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data ionics_stratus_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mvsdio_platform_data ionics_stratus_mvsdio_data = {
+	/* unfortunately the CD signal has not been connected */
+};
+
+static struct gpio_led ionics_stratus_led_pins[] = {
+	{
+		.name			= "status:green:led1",
+		.default_trigger	= "none",
+		.gpio			= 44,
+		.active_low		= 1,
+	},
+	{
+		.name           	= "status:green:led2",
+		.default_trigger    	= "none",
+		.gpio           	= 40,
+		.active_low     	= 1,
+	},
+	{
+		.name           	= "status:green:led3",
+		.default_trigger	= "default-on",
+		.gpio			= 36,
+		.active_low		= 1,
+	},
+        {
+                .name                   = "status:green:led4",
+                .default_trigger        = "default-on",
+                .gpio                   = 39,
+                .active_low             = 1,
+        },
+
+};
+
+static struct gpio_led_platform_data ionics_stratus_led_data = {
+	.leds		= ionics_stratus_led_pins,
+	.num_leds	= ARRAY_SIZE(ionics_stratus_led_pins),
+};
+
+static struct platform_device ionics_stratus_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+	.platform_data	= &ionics_stratus_led_data,
+	}
+};
+
+static unsigned int ionics_stratus_mpp_config[] __initdata = {
+	MPP21_GPIO,	/* USB PORT 1 Pw Enable */
+	MPP32_GPIO,	/* USB PORT 2 Pw Enable */
+	MPP48_GPIO,	/* WIFI Power Down */
+	MPP49_GPIO,	/* WIFI Host Wakeup */
+	MPP42_GPIO,	/* WIFI MAC Wakeup */
+	MPP44_GPIO,	/* LED 1 */
+	MPP40_GPIO,	/* LED 2 */
+	MPP36_GPIO,	/* LED 3 */
+	MPP39_GPIO,	/* LED 4 */
+	MPP23_GPIO,	/* BTN 1 */
+	MPP37_GPIO,	/* BTN 2 */
+	MPP38_GPIO,	/* BTN 3 */
+	0
+};
+
+static void __init ionics_stratus_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(ionics_stratus_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(ionics_stratus_nand_parts), 25);
+
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&ionics_stratus_ge00_data);
+	kirkwood_sdio_init(&ionics_stratus_mvsdio_data);
+
+	platform_device_register(&ionics_stratus_leds);
+}
+
+MACHINE_START(IONICS_STRATUS, "Ionics Plug Computer Plus - Stratus")
+	/* Maintainer: Mike Brown <mbrown@archlinuxarm.org> */
+	.atag_offset	= 0x100,
+	.init_machine	= ionics_stratus_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
--- a/arch/arm/mach-kirkwood/Kconfig	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/Kconfig	2012-12-11 18:34:42.668479244 +0100
@@ -58,12 +58,6 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell DreamPlug (Flattened Device Tree).
 
-config MACH_ICONNECT_DT
-	bool "Iomega Iconnect (Flattened Device Tree)"
-	select ARCH_KIRKWOOD_DT
-	help
-	  Say 'Y' here to enable Iomega Iconnect support.
-
 config MACH_DLINK_KIRKWOOD_DT
 	bool "D-Link Kirkwood-based NAS (Flattened Device Tree)"
 	select ARCH_KIRKWOOD_DT
@@ -80,34 +74,6 @@
 	  RaidSonic IB-NAS6210 & IB-NAS6220 devices, using
 	  Flattened Device Tree.
 
-config MACH_TS219_DT
-	bool "Device Tree for QNAP TS-11X, TS-21X NAS"
-	select ARCH_KIRKWOOD_DT
-	select ARM_APPENDED_DTB
-	select ARM_ATAG_DTB_COMPAT
-	help
-	  Say 'Y' here if you want your kernel to support the QNAP
-	  TS-110, TS-119, TS-119P+, TS-210, TS-219, TS-219P and
-	  TS-219P+ Turbo NAS devices using Fattened Device Tree.
-	  There are two different Device Tree descriptions, depending
-	  on if the device is based on an if the board uses the MV6281
-	  or MV6282. If you have the wrong one, the buttons will not
-	  work.
-
-config MACH_DOCKSTAR_DT
-	bool "Seagate FreeAgent Dockstar (Flattened Device Tree)"
-	select ARCH_KIRKWOOD_DT
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Seagate FreeAgent Dockstar (Flattened Device Tree).
-
-config MACH_GOFLEXNET_DT
-	bool "Seagate GoFlex Net (Flattened Device Tree)"
-	select ARCH_KIRKWOOD_DT
-	help
-	  Say 'Y' here if you want your kernel to support the
-	  Seagate GoFlex Net (Flattened Device Tree).
-
 config MACH_LSXL_DT
 	bool "Buffalo Linkstation LS-XHL, LS-CHLv2 (Flattened Device Tree)"
 	select ARCH_KIRKWOOD_DT
@@ -150,6 +116,54 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Seagate FreeAgent DockStar.
 
+config MACH_GOFLEXNET
+	bool "Seagate GoFlex Net"
+	help
+		Say 'Y' here if you want your kernel to support the
+		Seagate GoFlex Net.
+
+config MACH_GOFLEXHOME
+	bool "Seagate GoFlex Home"
+	help
+		Say 'Y' here if you want your kernel to support the
+		Seagate GoFlex Home.
+
+config MACH_ICONNECT
+	bool "Iomega iConnect Wireless"
+	help
+		Say 'Y' here if you want your kernel to support the
+		Iomega iConnect Wireless.
+
+config MACH_POGOPLUGV4
+	bool "Pogoplug Series 4"
+	help
+		Say 'Y' here if you want your kernel to support the
+		Pogoplug Series 4.
+
+config MACH_POGO_E02
+	bool "CE Pogoplug E02"
+	help
+		Say 'Y' here if you want your kernel to support the
+		CloudEngines Pogoplug e02.
+
+config MACH_NAS6210
+	bool "RaidSonic ICY BOX IB-NAS6210"
+	help
+		Say 'Y' here if you want your kernel to support the
+		RaidSonic ICY BOX IB-NAS6210 device.
+
+config MACH_TOPKICK
+	bool "USI Topkick"
+	help
+		Say 'Y' here if you want your kernel to support the
+		USI Topkick.
+
+config MACH_IONICS_STRATUS
+	bool "Ionics Stratus"
+	help
+		Say 'Y' here if you want your kernel to support the
+		Ionics Stratus.
+
 config MACH_OPENRD
         bool
 
@@ -216,6 +230,18 @@
 	  Say 'Y' here if you want your kernel to support the
 	  HP t5325 Thin Client.
 
+config MACH_NSA310
+   bool "ZyXEL NSA310 1-Bay Power Media Server"
+   help
+     Say 'Y' here if you want your kernel to support the
+     ZyXEL NSA310.
+
+config MACH_NSA320
+   bool "ZyXEL NSA320 2-Bay Power Media Server"
+   help
+     Say 'Y' here if you want your kernel to support the
+     ZyXel NSA320.
+
 endmenu
 
 endif
diff -ruN a/arch/arm/mach-kirkwood/Makefile b/arch/arm/mach-kirkwood/Makefile
--- a/arch/arm/mach-kirkwood/Makefile	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/Makefile	2012-12-11 18:36:03.060009252 +0100
@@ -8,6 +8,14 @@
 obj-$(CONFIG_MACH_ESATA_SHEEVAPLUG)	+= sheevaplug-setup.o
 obj-$(CONFIG_MACH_GURUPLUG)		+= guruplug-setup.o
 obj-$(CONFIG_MACH_DOCKSTAR)		+= dockstar-setup.o
+obj-$(CONFIG_MACH_GOFLEXNET)		+= goflexnet-setup.o
+obj-$(CONFIG_MACH_GOFLEXHOME)		+= goflexhome-setup.o
+obj-$(CONFIG_MACH_ICONNECT)		+= iconnect-setup.o
+obj-$(CONFIG_MACH_POGOPLUGV4)		+= pogoplugv4-setup.o
+obj-$(CONFIG_MACH_POGO_E02)		+= pogo_e02-setup.o
+obj-$(CONFIG_MACH_NAS6210)		+= nas6210-setup.o
+obj-$(CONFIG_MACH_TOPKICK)		+= topkick-setup.o
+obj-$(CONFIG_MACH_IONICS_STRATUS)	+= ionics-stratus-setup.o
 obj-$(CONFIG_MACH_TS219)		+= ts219-setup.o tsx1x-common.o
 obj-$(CONFIG_MACH_TS41X)		+= ts41x-setup.o tsx1x-common.o
 obj-$(CONFIG_MACH_OPENRD)		+= openrd-setup.o
@@ -18,16 +26,15 @@
 obj-$(CONFIG_MACH_NET2BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_NET5BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_T5325)		+= t5325-setup.o
+obj-$(CONFIG_MACH_NSA310)		+= nsa310-setup.o
+obj-$(CONFIG_MACH_NSA320)		+= nsa320-setup.o
 
 obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
 obj-$(CONFIG_ARCH_KIRKWOOD_DT)		+= board-dt.o
 obj-$(CONFIG_MACH_DREAMPLUG_DT)		+= board-dreamplug.o
-obj-$(CONFIG_MACH_ICONNECT_DT)		+= board-iconnect.o
 obj-$(CONFIG_MACH_DLINK_KIRKWOOD_DT)	+= board-dnskw.o
 obj-$(CONFIG_MACH_IB62X0_DT)		+= board-ib62x0.o
-obj-$(CONFIG_MACH_TS219_DT)		+= board-ts219.o tsx1x-common.o
 obj-$(CONFIG_MACH_DOCKSTAR_DT)		+= board-dockstar.o
-obj-$(CONFIG_MACH_GOFLEXNET_DT)		+= board-goflexnet.o
 obj-$(CONFIG_MACH_LSXL_DT)		+= board-lsxl.o
 obj-$(CONFIG_MACH_IOMEGA_IX2_200_DT)	+= board-iomega_ix2_200.o
 obj-$(CONFIG_MACH_KM_KIRKWOOD_DT)	+= board-km_kirkwood.o
diff -ruN a/arch/arm/mach-kirkwood/nas6210-setup.c b/arch/arm/mach-kirkwood/nas6210-setup.c
--- a/arch/arm/mach-kirkwood/nas6210-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/nas6210-setup.c	2012-12-11 18:34:46.746502525 +0100
@@ -0,0 +1,186 @@
+/*
+ * arch/arm/mach-kirkwood/nas6210-setup.c
+ *
+ * Raidsonic ICYBOX NAS6210 Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+#define NAS6210_GPIO_POWER_OFF	24
+
+static struct mtd_partition nas6210_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 6*SZ_1M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data nas6210_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(8),
+};
+
+static struct mv_sata_platform_data nas6210_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led nas6210_led_pins[] = {
+	{
+		.name			= "status:green:power",
+		.default_trigger	= "default-on",
+		.gpio			= 25,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:power",
+		.default_trigger	= "none",
+		.gpio			= 22,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:usb_copy",
+		.default_trigger	= "none",
+		.gpio			= 27,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_led_platform_data nas6210_led_data = {
+	.leds		= nas6210_led_pins,
+	.num_leds	= ARRAY_SIZE(nas6210_led_pins),
+};
+
+static struct platform_device nas6210_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nas6210_led_data,
+	}
+};
+
+static struct gpio_keys_button nas6210_buttons[] = {
+	{
+		.code		= KEY_COPY,
+		.gpio		= 29,
+		.desc		= "USB Copy",
+		.active_low	= 1,
+	},
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 28,
+		.desc		= "Reset",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data nas6210_button_data = {
+	.buttons	= nas6210_buttons,
+	.nbuttons	= ARRAY_SIZE(nas6210_buttons),
+};
+
+static struct platform_device nas6210_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nas6210_button_data,
+	}
+};
+
+static unsigned int nas6210_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+ 	MPP22_GPIO,	/* Power LED red */
+	MPP24_GPIO,	/* Power off device */
+	MPP25_GPIO,	/* Power LED green */
+	MPP27_GPIO,	/* USB transfer LED */
+	MPP28_GPIO,	/* Reset button */
+	MPP29_GPIO,	/* USB Copy button */
+	0
+};
+
+static void nas6210_power_off(void)
+{
+	gpio_set_value(NAS6210_GPIO_POWER_OFF, 1);
+}
+
+static void __init nas6210_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(nas6210_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(nas6210_nand_parts), 25);
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&nas6210_ge00_data);
+	kirkwood_sata_init(&nas6210_sata_data);
+	kirkwood_uart0_init();
+	platform_device_register(&nas6210_leds);
+	platform_device_register(&nas6210_button_device);
+	if (gpio_request(NAS6210_GPIO_POWER_OFF, "power-off") == 0 &&
+	    gpio_direction_output(NAS6210_GPIO_POWER_OFF, 0) == 0)
+		pm_power_off = nas6210_power_off;
+	else
+		pr_err("nas6210: failed to configure power-off GPIO\n");
+}
+
+static int __init nas6210_pci_init(void)
+{
+	if (machine_is_nas6210()) {
+		u32 dev, rev;
+ 
+		kirkwood_pcie_id(&dev, &rev);
+		if (dev == MV88F6282_DEV_ID)
+			kirkwood_pcie_init(KW_PCIE1 | KW_PCIE0);
+		else
+			kirkwood_pcie_init(KW_PCIE0);
+	}
+
+	return 0;
+}
+subsys_initcall(nas6210_pci_init);
+
+MACHINE_START(NAS6210, "RaidSonic ICY BOX IB-NAS6210")
+	/* Maintainer: <gmbnomis at gmail dot com> */
+	.atag_offset	= 0x100,
+	.init_machine	= nas6210_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/nsa310-setup.c b/arch/arm/mach-kirkwood/nsa310-setup.c
--- a/arch/arm/mach-kirkwood/nsa310-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/nsa310-setup.c	2012-12-11 18:34:46.746502525 +0100
@@ -0,0 +1,299 @@
+/*
+ * arch/arm/mach-kirkwood/nsa310-setup.c
+ *
+ * ZyXEL NSA310 1-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ethtool.h>  /* for SPEED_1000, DUPLEX_FULL */
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa310_nand_parts[] = {
+	{
+		.name = "uboot",
+		.offset = 0,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE
+	}, {
+		.name = "uboot_env",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "key_store",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "info",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "etc",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "kernel_1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	}, {
+		.name = "kernel_2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	},
+};
+
+static struct mv_sata_platform_data nsa310_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_keys_button nsa310_button_pins[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 36,
+		.desc		= "Reset",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_COPY,
+		.gpio		= 37,
+		.desc		= "Copy",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= 46,
+		.desc		= "Power",
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_platform_data nsa310_button_data = {
+	.buttons	= nsa310_button_pins,
+	.nbuttons	= ARRAY_SIZE(nsa310_button_pins),
+};
+
+static struct platform_device nsa310_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa310_button_data,
+	},
+};
+
+static struct gpio_led nsa310_led_pins[] = {
+	{
+		.name			= "nsa310:green:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 12,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:red:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 13,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:green:usb",
+		.default_trigger	= "default-off",
+		.gpio			= 15,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:green:sys",
+		.default_trigger	= "default-off",
+		.gpio			= 28,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:orange:sys",
+		.default_trigger	= "default-on",
+		.gpio			= 29,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:green:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 39,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:red:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 40,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:green:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 41,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa310:red:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 42,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_led_platform_data nsa310_led_data = {
+	.leds		= nsa310_led_pins,
+	.num_leds	= ARRAY_SIZE(nsa310_led_pins),
+};
+
+static struct platform_device nsa310_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nsa310_led_data,
+	},
+};
+
+static struct nsa3xx_hwmon_platform_data nsa310_hwmon_data = {
+	/* GPIOs connected to Holtek HT46R065 MCU */
+	.act_pin  = 17,
+	.clk_pin  = 16,
+	.data_pin = 14,
+};
+
+static struct platform_device nsa310_hwmon = {
+	.name		= "nsa3xx-hwmon",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa310_hwmon_data,
+	},
+};
+
+static unsigned int nsa310_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP6_SYSRST_OUTn,
+	MPP7_GPO,
+	MPP8_TW0_SDA,	/* PCF8563 RTC chip   */
+	MPP9_TW0_SCK,	/* connected to TWSI  */
+	MPP10_UART0_TXD,
+	MPP11_UART0_RXD,
+	MPP12_GPO,	/* HDD2 LED (green)   */
+	MPP13_GPIO,	/* HDD2 LED (red)     */
+	MPP14_GPIO,	/* MCU DATA pin (in)  */
+	MPP15_GPIO,	/* USB LED (green)    */
+	MPP16_GPIO,	/* MCU CLK pin (out)  */
+	MPP17_GPIO,	/* MCU ACT pin (out)  */
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+	MPP20_GPIO,
+	MPP21_GPIO,	/* USB power          */
+	MPP22_GPIO,
+	MPP23_GPIO,
+	MPP24_GPIO,
+	MPP25_GPIO,
+	MPP26_GPIO,
+	MPP27_GPIO,
+	MPP28_GPIO,	/* SYS LED (green)    */
+	MPP29_GPIO,	/* SYS LED (orange)   */
+	MPP30_GPIO,
+	MPP31_GPIO,
+	MPP32_GPIO,
+	MPP33_GPO,
+	MPP34_GPIO,
+	MPP35_GPIO,
+	MPP36_GPIO,	/* reset button       */
+	MPP37_GPIO,	/* copy button        */
+	MPP38_GPIO,	/* VID B0             */
+	MPP39_GPIO,	/* COPY LED (green)   */
+	MPP40_GPIO,	/* COPY LED (red)     */
+	MPP41_GPIO,	/* HDD1 LED (green)   */
+	MPP42_GPIO,	/* HDD1 LED (red)     */
+	MPP43_GPIO,	/* HTP pin            */
+	MPP44_GPIO,	/* buzzer             */
+	MPP45_GPIO,	/* VID B1             */
+	MPP46_GPIO,	/* power button       */
+	MPP47_GPIO,	/* power resume data  */
+	MPP48_GPIO,	/* power off          */
+	MPP49_GPIO,	/* power resume clock */
+	0
+};
+
+#define NSA310_GPIO_USB_POWER	21
+#define NSA310_GPIO_POWER_OFF	48
+
+static void nsa310_power_off(void)
+{
+	gpio_set_value(NSA310_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa310_usb_power(char *str)
+{
+	usb_power = strncmp(str, "off", 3) ? 1 : 0;
+	return 1;
+}
+/* Parse boot_command_line string nsa310_usb_power=on|off */
+__setup("nsa310_usb_power=", nsa310_usb_power);
+
+static void __init nsa310_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(nsa310_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(nsa310_nand_parts), 40);
+
+	kirkwood_i2c_init();
+
+	if (gpio_request(NSA310_GPIO_USB_POWER, "USB Power Enable") ||
+	    gpio_direction_output(NSA310_GPIO_USB_POWER, usb_power))
+		pr_err("nsa310: failed to configure USB power enable GPIO)\n");
+	gpio_free(NSA310_GPIO_USB_POWER);
+
+	kirkwood_ehci_init();
+	kirkwood_sata_init(&nsa310_sata_data);
+	platform_device_register(&nsa310_leds);
+	platform_device_register(&nsa310_buttons);
+	platform_device_register(&nsa310_hwmon);
+
+	if (gpio_request(NSA310_GPIO_POWER_OFF, "power-off") ||
+	    gpio_direction_output(NSA310_GPIO_POWER_OFF, 0))
+		pr_err("nsa310: failed to configure power-off GPIO\n");
+	else
+		pm_power_off = nsa310_power_off;
+}
+
+MACHINE_START(NSA310, "ZyXEL NSA310 1-Bay Power Media Server")
+	/* Maintainer: Peter Oostewechel <peter_oostewechel@hotmail.com> */
+	.atag_offset	= 0x100,
+	.init_machine	= nsa310_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/nsa320-setup.c b/arch/arm/mach-kirkwood/nsa320-setup.c
--- a/arch/arm/mach-kirkwood/nsa320-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/nsa320-setup.c	2012-12-11 22:22:38.684227039 +0100
@@ -0,0 +1,305 @@
+/*
+ * arch/arm/mach-kirkwood/nsa320-setup.c
+ *
+ * ZyXEL NSA320 2-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/orion-gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa320_nand_parts[] = {
+	{
+		.name = "uboot",
+		.offset = 0,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE
+	}, {
+		.name = "uboot_env",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "key_store",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "info",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "etc",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "kernel_1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	}, {
+		.name = "kernel_2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	},
+};
+
+static struct i2c_board_info __initdata nsa320_i2c_rtc = {
+	I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa320_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data nsa320_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_keys_button nsa320_button_pins[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 36,
+		.desc		= "Reset",
+		.active_low	= 1,
+		.debounce_interval	= 1000,
+	}, {
+		.code		= KEY_COPY,
+		.gpio		= 37,
+		.desc		= "Copy",
+		.active_low	= 1,
+		.debounce_interval	= 1000,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= 46,
+		.desc		= "Power",
+		.active_low	= 0,
+		.debounce_interval	= 1000,
+	},
+};
+
+static struct gpio_keys_platform_data nsa320_button_data = {
+	.buttons	= nsa320_button_pins,
+	.nbuttons	= ARRAY_SIZE(nsa320_button_pins),
+};
+
+static struct platform_device nsa320_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_button_data,
+	},
+};
+
+static struct gpio_led nsa320_led_pins[] = {
+	{
+		.name			= "nsa320:green:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 12,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 13,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:usb",
+		.default_trigger	= "default-off",
+		.gpio			= 15,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:sys",
+		.default_trigger	= "default-off",
+		.gpio			= 28,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:orange:sys",
+		.default_trigger	= "default-on",
+		.gpio			= 29,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 39,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 40,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 41,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 42,
+		.active_low		= 0,
+	},
+};
+
+static int nsa320_gpio_blink_set(unsigned gpio, int state,
+	unsigned long *delay_on, unsigned long *delay_off)
+{
+	switch(state) {
+		case GPIO_LED_NO_BLINK_LOW:
+		case GPIO_LED_NO_BLINK_HIGH:
+			orion_gpio_set_blink(gpio, 0);
+			gpio_set_value(gpio, state);
+		break;
+		case GPIO_LED_BLINK:
+			orion_gpio_set_blink(gpio, 1);
+		break;
+	}
+	return 0;
+}
+
+static struct gpio_led_platform_data nsa320_led_data = {
+	.leds		= nsa320_led_pins,
+	.num_leds	= ARRAY_SIZE(nsa320_led_pins),
+	.gpio_blink_set	= nsa320_gpio_blink_set,
+};
+
+static struct platform_device nsa320_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nsa320_led_data,
+	},
+};
+
+static struct nsa3xx_hwmon_platform_data nsa320_hwmon_data = {
+	/* GPIOs connected to Holtek HT46R065 MCU */
+	.act_pin  = 17,
+	.clk_pin  = 16,
+	.data_pin = 14,
+};
+
+static struct platform_device nsa320_hwmon = {
+	.name		= "nsa3xx-hwmon",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_hwmon_data,
+	},
+};
+
+static unsigned int nsa320_mpp_config[] __initdata = {
+	MPP8_TW0_SDA,	/* PCF8563 RTC chip   */
+	MPP9_TW0_SCK,	/* connected to TWSI  */
+	MPP12_GPO,	/* HDD2 LED (green)   */
+	MPP13_GPIO,	/* HDD2 LED (red)     */
+	MPP14_GPIO,	/* MCU DATA pin (in)  */
+	MPP15_GPIO,	/* USB LED (green)    */
+	MPP16_GPIO,	/* MCU CLK pin (out)  */
+	MPP17_GPIO,	/* MCU ACT pin (out)  */
+	MPP21_GPIO,	/* USB power          */
+	MPP28_GPIO,	/* SYS LED (green)    */
+	MPP29_GPIO,	/* SYS LED (orange)   */
+	MPP36_GPIO,	/* reset button       */
+	MPP37_GPIO,	/* copy button        */
+	MPP38_GPIO,	/* VID B0             */
+	MPP39_GPIO,	/* COPY LED (green)   */
+	MPP40_GPIO,	/* COPY LED (red)     */
+	MPP41_GPIO,	/* HDD1 LED (green)   */
+	MPP42_GPIO,	/* HDD1 LED (red)     */
+	MPP43_GPIO,	/* HTP pin            */
+	MPP44_GPIO,	/* buzzer             */
+	MPP45_GPIO,	/* VID B1             */
+	MPP46_GPIO,	/* power button       */
+	MPP47_GPIO,	/* power resume data  */
+	MPP48_GPIO,	/* power off          */
+	MPP49_GPIO,	/* power resume clock */
+	0
+};
+
+#define NSA320_GPIO_USB_POWER	21
+#define NSA320_GPIO_POWER_OFF	48
+
+static void nsa320_power_off(void)
+{
+	gpio_set_value(NSA320_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa320_usb_power(char *str)
+{
+	usb_power = strncmp(str, "off", 3) ? 1 : 0;
+	return 1;
+}
+/* Parse boot_command_line string nsa320_usb_power=on|off */
+__setup("nsa320_usb_power=", nsa320_usb_power);
+
+static void __init nsa320_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_mpp_conf(nsa320_mpp_config);
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(nsa320_nand_parts), 40);
+	kirkwood_ge00_init(&nsa320_ge00_data);
+	kirkwood_sata_init(&nsa320_sata_data);
+
+	platform_device_register(&nsa320_leds);
+	platform_device_register(&nsa320_buttons);
+	platform_device_register(&nsa320_hwmon);
+
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &nsa320_i2c_rtc, 1);
+
+       if (gpio_request(NSA320_GPIO_USB_POWER, "USB Power Enable") ||
+           gpio_direction_output(NSA320_GPIO_USB_POWER, usb_power))
+               pr_err("nsa320: failed to configure USB power enable GPIO)\n");
+       gpio_free(NSA320_GPIO_USB_POWER);
+
+	kirkwood_ehci_init();
+
+	if (gpio_request(NSA320_GPIO_POWER_OFF, "power-off") ||
+	    gpio_direction_output(NSA320_GPIO_POWER_OFF, 0))
+		pr_err("nsa320: failed to configure power-off GPIO\n");
+	else
+		pm_power_off = nsa320_power_off;
+}
+
+MACHINE_START(NSA320, "ZyXEL NSA320 2-Bay Power Media Server")
+	/* Maintainer: Peter Schildmann <linux@schildmann.info> */
+	.atag_offset	= 0x100,
+	.init_machine	= nsa320_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/pogo_e02-setup.c b/arch/arm/mach-kirkwood/pogo_e02-setup.c
--- a/arch/arm/mach-kirkwood/pogo_e02-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/pogo_e02-setup.c	2012-12-11 18:34:46.747502539 +0100
@@ -0,0 +1,115 @@
+/*
+ * arch/arm/mach-kirkwood/pogo_e02-setup.c
+ *
+ * CloudEngines Pogoplug E02 support
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition pogo_e02_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogo_e02_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct gpio_led pogo_e02_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 49,
+		.active_low		= 1,
+	}
+};
+
+static struct gpio_led_platform_data pogo_e02_led_data = {
+	.leds		= pogo_e02_led_pins,
+	.num_leds	= ARRAY_SIZE(pogo_e02_led_pins),
+};
+
+static struct platform_device pogo_e02_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogo_e02_led_data,
+	}
+};
+
+static unsigned int pogo_e02_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Orange */
+	0
+};
+
+static void __init pogo_e02_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(pogo_e02_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(pogo_e02_nand_parts), 25);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&pogo_e02_ge00_data);
+
+	platform_device_register(&pogo_e02_leds);
+}
+
+MACHINE_START(POGO_E02, "Pogoplug E02")
+	.atag_offset	= 0x100,
+	.init_machine	= pogo_e02_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/pogoplugv4-setup.c b/arch/arm/mach-kirkwood/pogoplugv4-setup.c
--- a/arch/arm/mach-kirkwood/pogoplugv4-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/pogoplugv4-setup.c	2012-12-11 22:21:55.149950301 +0100
@@ -0,0 +1,195 @@
+/*
+ * arch/arm/mach-kirkwood/pogoplugv4-setup.c
+ *
+ * Pogoplug Series 4 Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/input.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include <plat/orion-gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+#define POGOPLUGV4_GPIO_USB_VBUS		10
+
+static struct mtd_partition ppv4_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 2 * SZ_1M
+	}, {
+		.name	= "uImage",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "uImage2",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "failsafe",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= SZ_8M
+	}, {
+		.name	= "root",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogoplugv4_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data pogoplugv4_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_keys_button pogoplugv4_button_pins[] = {
+	{
+		.code		= KEY_EJECTCD,
+		.gpio		= 29,
+		.desc		= "Eject Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data pogoplugv4_button_data = {
+	.buttons	= pogoplugv4_button_pins,
+	.nbuttons	= ARRAY_SIZE(pogoplugv4_button_pins),
+};
+
+static struct platform_device pogoplugv4_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,   
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data  = &pogoplugv4_button_data,
+	},
+};
+
+static struct gpio_led pogoplugv4_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 22,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 24,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data pogoplugv4_led_data = {
+	.leds		= pogoplugv4_led_pins,
+	.num_leds	= ARRAY_SIZE(pogoplugv4_led_pins),
+};
+
+static struct platform_device pogoplugv4_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogoplugv4_led_data,
+	}
+};
+
+static struct mvsdio_platform_data ppv4_mvsdio_data = {
+	.gpio_card_detect = 27,
+};
+
+static unsigned int ppv4_mpp_config[] __initdata = {
+	MPP27_GPIO,	/* SD card detect */
+	MPP29_GPIO,	/* Eject button */
+	MPP22_GPIO,	/* Green LED */
+	MPP24_GPIO,	/* Red LED */
+	MPP12_SD_CLK,
+	MPP13_SD_CMD,
+	MPP14_SD_D0,
+	MPP15_SD_D1,
+	MPP16_SD_D2,
+	MPP17_SD_D3,
+	0
+};
+
+static const struct flash_platform_data pogoplugv4_spi_slave_data = {
+	.type		= "m25p05-nonjedec",
+};
+
+static struct spi_board_info __initdata pogoplugv4_spi_slave_info[] = {
+	{
+		.modalias	= "m25p05-nonjedec",
+		.platform_data	= &pogoplugv4_spi_slave_data,
+		.irq		= -1,
+		.max_speed_hz	= 20000000,
+		.bus_num	= 0,
+		.chip_select	= 0,
+	},
+};
+
+static void __init pogoplugv4_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(ppv4_mpp_config);
+
+	orion_gpio_set_valid(POGOPLUGV4_GPIO_USB_VBUS, 1);
+	if (gpio_request(POGOPLUGV4_GPIO_USB_VBUS, "USB VBUS") != 0 ||
+	    gpio_direction_output(POGOPLUGV4_GPIO_USB_VBUS, 1) != 0)
+		pr_err("POGOPLUGV4: failed to setup USB VBUS GPIO\n");
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&pogoplugv4_ge00_data);
+	kirkwood_sata_init(&pogoplugv4_sata_data);
+	spi_register_board_info(pogoplugv4_spi_slave_info,
+				ARRAY_SIZE(pogoplugv4_spi_slave_info));
+	kirkwood_spi_init();
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(ppv4_nand_parts), 25);
+	kirkwood_sdio_init(&ppv4_mvsdio_data);
+	platform_device_register(&pogoplugv4_leds);
+	platform_device_register(&pogoplugv4_buttons);
+}
+
+static int __init pogoplugv4_pci_init(void)
+{
+	if (machine_is_pogoplugv4())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(pogoplugv4_pci_init);
+
+MACHINE_START(POGOPLUGV4, "Pogoplug V4")
+	/* Maintainer: Kevin Mihelich <kevin@archlinuxarm.org> */
+	.atag_offset	= 0x100,
+	.init_machine	= pogoplugv4_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/sheevaplug-setup.c b/arch/arm/mach-kirkwood/sheevaplug-setup.c
--- a/arch/arm/mach-kirkwood/sheevaplug-setup.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/mach-kirkwood/sheevaplug-setup.c	2012-12-11 18:34:46.748502553 +0100
@@ -43,7 +43,7 @@
 	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
 };
 
-static struct mv_sata_platform_data sheeva_esata_sata_data = {
+static struct mv_sata_platform_data esata_sheevaplug_sata_data = {
 	.n_ports	= 2,
 };
 
@@ -51,7 +51,7 @@
 	/* unfortunately the CD signal has not been connected */
 };
 
-static struct mvsdio_platform_data sheeva_esata_mvsdio_data = {
+static struct mvsdio_platform_data esata_sheevaplug_mvsdio_data = {
 	.gpio_write_protect = 44, /* MPP44 used as SD write protect */
 	.gpio_card_detect = 47,	  /* MPP47 used as SD card detect */
 };
@@ -64,7 +64,13 @@
 		.active_low		= 1,
 	},
 	{
-		.name			= "plug:green:health",
+		.name           	= "status:green:health",
+		.default_trigger    	= "none",
+		.gpio           	= 48,
+		.active_low     	= 1,
+	},
+	{
+		.name           	= "status:blue:health",
 		.default_trigger	= "default-on",
 		.gpio			= 49,
 		.active_low		= 1,
@@ -87,15 +93,18 @@
 static unsigned int sheevaplug_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
 	MPP46_GPIO,	/* LED Red */
-	MPP49_GPIO,	/* LED */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
 	0
 };
 
-static unsigned int sheeva_esata_mpp_config[] __initdata = {
+static unsigned int esata_sheevaplug_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
 	MPP44_GPIO,	/* SD Write Protect */
 	MPP47_GPIO,	/* SD Card Detect */
-	MPP49_GPIO,	/* LED Green */
+	MPP46_GPIO,	/* LED Red */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
 	0
 };
 
@@ -108,7 +117,7 @@
 
 	/* setup gpio pin select */
 	if (machine_is_esata_sheevaplug())
-		kirkwood_mpp_conf(sheeva_esata_mpp_config);
+		kirkwood_mpp_conf(esata_sheevaplug_mpp_config);
 	else
 		kirkwood_mpp_conf(sheevaplug_mpp_config);
 
@@ -124,11 +133,11 @@
 
 	/* honor lower power consumption for plugs with out eSATA */
 	if (machine_is_esata_sheevaplug())
-		kirkwood_sata_init(&sheeva_esata_sata_data);
+		kirkwood_sata_init(&esata_sheevaplug_sata_data);
 
 	/* enable sd wp and sd cd on plugs with esata */
 	if (machine_is_esata_sheevaplug())
-		kirkwood_sdio_init(&sheeva_esata_mvsdio_data);
+		kirkwood_sdio_init(&esata_sheevaplug_mvsdio_data);
 	else
 		kirkwood_sdio_init(&sheevaplug_mvsdio_data);
 
diff -ruN a/arch/arm/mach-kirkwood/topkick-setup.c b/arch/arm/mach-kirkwood/topkick-setup.c
--- a/arch/arm/mach-kirkwood/topkick-setup.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/arm/mach-kirkwood/topkick-setup.c	2012-12-11 22:48:38.712199378 +0100
@@ -0,0 +1,165 @@
+/*
+ * arch/arm/mach-kirkwood/topkick-setup.c
+ *
+ * USI Topkick Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <linux/platform_data/mmc-mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition topkick_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 0x180000
+	}, {
+		.name	= "u-boot-env",
+		.offset	= 0x180000,
+		.size	= 128 * 1024
+	}, {
+		.name	= "uImage",
+		.offset	= 2 * 1024 * 1024,
+		.size	= 6 * 1024 * 1024
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data topkick_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data topkick_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct mvsdio_platform_data topkick_mvsdio_data = {
+	.gpio_card_detect = 47, /* MPP47 used as SD card detect */
+};
+
+
+static struct gpio_led topkick_led_pins[] = {
+	{
+		.name			= "status:blue:disk",
+		.default_trigger	= "none",
+		.gpio			= 21,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 37,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:blue:health",
+		.default_trigger	= "default-on",
+		.gpio			= 38,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:green:misc",
+		.default_trigger	= "none",
+		.gpio			= 39,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:misc",
+		.default_trigger	= "none",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data topkick_led_data = {
+	.leds		= topkick_led_pins,
+	.num_leds	= ARRAY_SIZE(topkick_led_pins),
+};
+
+static struct platform_device topkick_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &topkick_led_data,
+	}
+};
+
+static unsigned int topkick_mpp_config[] __initdata = {
+	MPP12_SD_CLK,	/* SDIO Clock */
+	MPP13_SD_CMD,	/* SDIO Cmd */
+	MPP14_SD_D0,	/* SDIO Data 0 */
+	MPP15_SD_D1,	/* SDIO Data 1 */
+	MPP16_SD_D2,	/* SDIO Data 2 */
+	MPP17_SD_D3,	/* SDIO Data 3 */
+	MPP21_GPIO,	/* LED Blue SATA */
+	MPP35_GPIO,	/* USB Power Enable */
+	MPP36_GPIO,	/* SATA Power Enable */
+	MPP37_GPIO,	/* LED Red  System */
+	MPP38_GPIO,	/* LED Blue System */
+	MPP39_GPIO,	/* LED Green Misc/WiFi */
+	MPP43_GPIO,	/* WOL Eth WOL */
+	MPP44_GPIO,	/* SW GW Mode */
+	MPP45_GPIO,	/* SW AP Mode */
+	MPP46_GPIO,	/* SW Power Off */
+	MPP47_GPIO,	/* SDIO Detect */
+	MPP48_GPIO,	/* LED Orange Misc/WiFi */
+	0
+};
+
+static void __init topkick_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(topkick_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(topkick_nand_parts), 40);
+
+	if (gpio_request(35, "USB Power Enable") != 0 ||
+	    gpio_direction_output(35, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 35 (USB Power Enable)\n");
+	if (gpio_request(36, "SATA Power Enable") != 0 ||
+	    gpio_direction_output(36, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 36 (SATA Power Enable)\n");
+	kirkwood_ge00_init(&topkick_ge00_data);
+	kirkwood_ehci_init();
+	kirkwood_sata_init(&topkick_sata_data);
+	kirkwood_sdio_init(&topkick_mvsdio_data);
+
+	platform_device_register(&topkick_leds);
+}
+
+MACHINE_START(TOPKICK, "USI Topkick")
+	/* Maintainer: Mike Brown <mbrown@archlinuxarm.org> */
+	.atag_offset	= 0x100,
+	.init_machine	= topkick_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+	.restart	= kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
--- a/arch/arm/plat-orion/common.c	2012-12-11 04:30:57.000000000 +0100
+++ b/arch/arm/plat-orion/common.c	2012-12-11 18:34:46.749502575 +0100
@@ -253,7 +253,9 @@
 /*****************************************************************************
  * GE00
  ****************************************************************************/
-struct mv643xx_eth_shared_platform_data orion_ge00_shared_data;
+struct mv643xx_eth_shared_platform_data orion_ge00_shared_data = {
+	.tx_csum_limit	= 1600,
+};
 
 static struct resource orion_ge00_shared_resources[] = {
 	{
diff -ruN a/drivers/ata/sata_mv.c b/drivers/ata/sata_mv.c
--- a/drivers/ata/sata_mv.c	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/ata/sata_mv.c	2012-12-11 18:34:46.750502591 +0100
@@ -71,6 +71,7 @@
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <linux/libata.h>
+#include <linux/leds.h>
 
 #define DRV_NAME	"sata_mv"
 #define DRV_VERSION	"1.28"
@@ -1156,6 +1157,8 @@
 {
 	int want_ncq = (protocol == ATA_PROT_NCQ);
 
+	ledtrig_ide_activity();
+
 	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
 		int using_ncq = ((pp->pp_flags & MV_PP_FLAG_NCQ_EN) != 0);
 		if (want_ncq != using_ncq)
diff -ruN a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
--- a/drivers/hwmon/Kconfig	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/hwmon/Kconfig	2012-12-11 18:34:46.751502596 +0100
@@ -1421,6 +1421,19 @@
         help
           Support for the A/D converter on MC13783 and MC13892 PMIC.
 
+config SENSORS_NSA3XX
+	tristate "ZyXEL NSA3xx fan speed and temperature sensors"
+	depends on (MACH_NSA310 || MACH_NSA320) && GENERIC_GPIO
+	help
+	  If you say yes here you get support for hardware monitoring
+	  for the ZyXEL NSA3XX Media Servers.
+
+	  The sensor data is taken from a Holtek HT46R065 microcontroller
+	  connected to GPIO lines.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called nsa3xx-hwmon.
+
 if ACPI
 
 comment "ACPI drivers"
diff -ruN a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
--- a/drivers/hwmon/Makefile	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/hwmon/Makefile	2012-12-11 18:34:46.751502596 +0100
@@ -99,6 +99,7 @@
 obj-$(CONFIG_SENSORS_MAX6642)	+= max6642.o
 obj-$(CONFIG_SENSORS_MAX6650)	+= max6650.o
 obj-$(CONFIG_SENSORS_MC13783_ADC)+= mc13783-adc.o
+obj-$(CONFIG_SENSORS_NSA3XX)	+= nsa3xx-hwmon.o
 obj-$(CONFIG_SENSORS_MCP3021)	+= mcp3021.o
 obj-$(CONFIG_SENSORS_NTC_THERMISTOR)	+= ntc_thermistor.o
 obj-$(CONFIG_SENSORS_PC87360)	+= pc87360.o
diff -ruN a/drivers/hwmon/nsa3xx-hwmon.c b/drivers/hwmon/nsa3xx-hwmon.c
--- a/drivers/hwmon/nsa3xx-hwmon.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/hwmon/nsa3xx-hwmon.c	2012-12-11 18:34:46.752502597 +0100
@@ -0,0 +1,251 @@
+/*
+ * drivers/hwmon/nsa3xx-hwmon.c
+ *
+ * ZyXEL NSA3xx Media Servers
+ * hardware monitoring
+ *
+ * Copyright (C) 2012 Peter Schildmann <linux@schildmann.info>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+
+#define MAGIC_NUMBER 0x55
+
+struct nsa3xx_hwmon {
+	struct platform_device	*pdev;
+	struct device		*classdev;
+	struct mutex		update_lock;	/* lock GPIO operations */
+	unsigned long		last_updated;	/* jiffies */
+	unsigned long		mcu_data;
+};
+
+enum nsa3xx_inputs {
+	NSA3XX_FAN = 1,
+	NSA3XX_TEMP = 0,
+};
+
+static const char *nsa3xx_input_names[] = {
+	[NSA3XX_FAN] = "Chassis Fan",
+	[NSA3XX_TEMP] = "System Temperature",
+};
+
+static unsigned long nsa3xx_hwmon_update(struct device *dev)
+{
+	int i;
+	unsigned long mcu_data;
+	struct nsa3xx_hwmon *hwmon = dev_get_drvdata(dev);
+	struct nsa3xx_hwmon_platform_data *pdata = hwmon->pdev->dev.platform_data;
+
+	mutex_lock(&hwmon->update_lock);
+
+	mcu_data = hwmon->mcu_data;
+
+	if (time_after(jiffies, hwmon->last_updated + (3 * HZ)) || mcu_data == 0) {
+		dev_dbg(dev, "Reading MCU data\n");
+
+		gpio_set_value(pdata->act_pin, 0);
+		msleep(100);
+
+		for (i = 31; i >= 0; i--) {
+			gpio_set_value(pdata->clk_pin, 0);
+			udelay(100);
+
+			gpio_set_value(pdata->clk_pin, 1);
+			udelay(100);
+
+			mcu_data |= gpio_get_value(pdata->data_pin) ? (1 << i) : 0;
+		}
+
+		gpio_set_value(pdata->act_pin, 1);
+
+		if ((mcu_data & 0xff000000) != (MAGIC_NUMBER << 24)) {
+			dev_err(dev, "Failed to read MCU data\n");
+			mcu_data = 0;
+		}
+
+		hwmon->mcu_data = mcu_data;
+		hwmon->last_updated = jiffies;
+	}
+
+	mutex_unlock(&hwmon->update_lock);
+
+	return mcu_data;
+}
+
+static ssize_t show_name(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "nsa3xx\n");
+}
+
+static ssize_t show_label(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	return sprintf(buf, "%s\n", nsa3xx_input_names[channel]);
+}
+
+static ssize_t show_value(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	unsigned long mcu_data = nsa3xx_hwmon_update(dev);
+	unsigned long value = 0;
+	switch(channel) {
+	case NSA3XX_TEMP:
+		value = (mcu_data & 0xffff) * 100;
+		break;
+	case NSA3XX_FAN:
+		value = ((mcu_data & 0xff0000) >> 16) * 100;
+		break;
+	}
+	return sprintf(buf, "%lu\n", value);
+}
+
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_label, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_value, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(fan1_label, S_IRUGO, show_label, NULL, NSA3XX_FAN);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_value, NULL, NSA3XX_FAN);
+
+static struct attribute *nsa3xx_attributes[] = {
+	&dev_attr_name.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_label.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group nsa3xx_attr_group = {
+	.attrs	= nsa3xx_attributes,
+};
+
+static int nsa3xx_hwmon_request_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	int ret;
+
+	if ((ret = gpio_request(pdata->act_pin, "act pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->clk_pin, "clk pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->data_pin, "data pin")))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->act_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->clk_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_input(pdata->data_pin)))
+		return ret;
+
+	return 0;
+}
+
+static void nsa3xx_hwmon_free_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	gpio_free(pdata->act_pin);
+	gpio_free(pdata->clk_pin);
+	gpio_free(pdata->data_pin);
+}
+
+static int __devinit nsa3xx_hwmon_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct nsa3xx_hwmon *hwmon;
+	struct nsa3xx_hwmon_platform_data *pdata = pdev->dev.platform_data;
+
+	hwmon = kzalloc(sizeof(struct nsa3xx_hwmon), GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hwmon);
+	hwmon->pdev = pdev;
+	hwmon->mcu_data = 0;
+	mutex_init(&hwmon->update_lock);
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	if (ret)
+		goto err;
+
+	hwmon->classdev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon->classdev)) {
+		ret = PTR_ERR(hwmon->classdev);
+		goto err_sysfs;
+	}
+
+	ret = nsa3xx_hwmon_request_gpios(pdata);
+	if (ret)
+		goto err_free_gpio;
+
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+err_free_gpio:
+	nsa3xx_hwmon_free_gpios(pdata);
+	hwmon_device_unregister(hwmon->classdev);
+err_sysfs:
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+err:
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+	return ret;
+}
+
+static int __devexit nsa3xx_hwmon_remove(struct platform_device *pdev)
+{
+	struct nsa3xx_hwmon *hwmon = platform_get_drvdata(pdev);
+
+	nsa3xx_hwmon_free_gpios(pdev->dev.platform_data);
+	hwmon_device_unregister(hwmon->classdev);
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+
+	return 0;
+}
+
+static struct platform_driver nsa3xx_hwmon_driver = {
+	.probe = nsa3xx_hwmon_probe,
+	.remove = __devexit_p(nsa3xx_hwmon_remove),
+	.driver = {
+		.name = "nsa3xx-hwmon",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(nsa3xx_hwmon_driver);
+
+MODULE_AUTHOR("Peter Schildmann <linux@schildmann.info>");
+MODULE_DESCRIPTION("NSA3XX Hardware Monitoring");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nsa3xx-hwmon");
diff -ruN a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/leds/Kconfig	2012-12-11 18:34:46.752502597 +0100
@@ -494,7 +494,6 @@
 
 config LEDS_TRIGGER_IDE_DISK
 	bool "LED IDE Disk Trigger"
-	depends on IDE_GD_ATA
 	depends on LEDS_TRIGGERS
 	help
 	  This allows LEDs to be controlled by IDE disk activity.
diff -ruN a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
--- a/drivers/mmc/core/core.c	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/mmc/core/core.c	2012-12-11 18:34:46.753502597 +0100
@@ -684,7 +684,7 @@
 			 */
 			limit_us = 3000000;
 		else
-			limit_us = 100000;
+			limit_us = 200000;
 
 		/*
 		 * SDHC cards always use these fixed values.
diff -ruN a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
--- a/drivers/mmc/core/sd.c	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/mmc/core/sd.c	2012-12-11 18:34:46.753502597 +0100
@@ -355,6 +355,15 @@
 		return -ENOMEM;
 	}
 
+	/*
+	 * Some SDHC cards, notably those with a Sandisk SD controller
+	 * (also found in Kingston products) need a bit of slack
+	 * before successfully handling the SWITCH command.  So far,
+	 * cards identifying themselves as "SD04G" and "SD08G" are
+	 * affected
+	 */
+	udelay(100);
+
 	err = mmc_sd_switch(card, 1, 0, 1, status);
 	if (err)
 		goto out;
diff -ruN a/drivers/mmc/host/mvsdio.c b/drivers/mmc/host/mvsdio.c
--- a/drivers/mmc/host/mvsdio.c	2012-12-11 04:30:57.000000000 +0100
+++ b/drivers/mmc/host/mvsdio.c	2012-12-11 18:34:46.754502597 +0100
@@ -22,6 +22,7 @@
 #include <linux/clk.h>
 #include <linux/gpio.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/sd.h>
 
 #include <asm/sizes.h>
 #include <asm/unaligned.h>
@@ -150,6 +151,7 @@
 
 	dev_dbg(host->dev, "cmd %d (hw state 0x%04x)\n",
 		cmd->opcode, mvsd_read(MVSD_HW_STATE));
+	if (cmd->opcode == SD_SWITCH) mdelay(1); /* Voodoo */
 
 	cmdreg = MVSD_CMD_INDEX(cmd->opcode);
 
diff -ruN a/include/linux/nsa3xx-hwmon.h b/include/linux/nsa3xx-hwmon.h
--- a/include/linux/nsa3xx-hwmon.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/linux/nsa3xx-hwmon.h	2012-12-11 18:34:46.754502597 +0100
@@ -0,0 +1,21 @@
+/*
+ * include/linux/nsa3xx.hwmon.h
+ *
+ * Platform data structure for ZyXEL NSA3xx hwmon driver
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __LINUX_NSA3XX_HWMON_H
+#define __LINUX_NSA3XX_HWMON_H
+
+struct nsa3xx_hwmon_platform_data {
+	/* GPIO pins */
+	unsigned act_pin;
+	unsigned clk_pin;
+	unsigned data_pin;
+};
+
+#endif /* __LINUX_NSA3XX_HWMON_H */
