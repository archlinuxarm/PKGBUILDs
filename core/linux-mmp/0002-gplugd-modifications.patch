From e3ac39121d2feed4e701ac45dad68fb7af556121 Mon Sep 17 00:00:00 2001
From: Ashokkumar G <0xfee1dead.sa@gmail.com>
Date: Thu, 27 Jun 2013 17:49:39 -0600
Subject: [PATCH] GPLUGD: These modifications are for testing and in single big
 file. Still need to create individual peripheral patches for maintainers

Signed-off-by: Ashokkumar G <0xfee1dead.sa@gmail.com>
---
 arch/arm/configs/gplugd_defconfig                  |  988 ++-
 arch/arm/mach-mmp/devices.c                        |   36 +
 arch/arm/mach-mmp/include/mach/pxa168.h            |   52 +
 arch/arm/mach-mmp/pxa168.c                         |   14 +
 drivers/clk/mmp/clk-pxa168.c                       |  610 +-
 drivers/i2c/busses/i2c-pxa.c                       |    6 +-
 drivers/mmc/host/Kconfig                           |    5 +-
 drivers/mmc/host/sdhci.c                           |   14 +
 drivers/mmc/host/sdhci.h                           |    1 +
 drivers/net/ethernet/marvell/pxa168_eth.c          |   20 +-
 drivers/rtc/Kconfig                                |    2 +-
 drivers/spi/Kconfig                                |    4 +-
 drivers/video/Kconfig                              |    3 +
 drivers/video/Makefile                             |    2 +-
 drivers/video/hdmi/Kconfig                         |    7 +
 drivers/video/hdmi/MakeModules                     |   55 +
 drivers/video/hdmi/Makefile                        |  202 +
 .../hdmi/comps/tmbslHdmiTx/inc/tmbslHdmiTx_types.h | 1799 +++++
 .../hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx.h      | 4202 +++++++++++
 .../hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx_app.h  |  551 ++
 .../hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_1.c    | 5520 ++++++++++++++
 .../hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_2.c    | 2404 ++++++
 .../comps/tmbslTDA9983/src/tmbslHdmiTx_local.c     |  898 +++
 .../comps/tmbslTDA9983/src/tmbslHdmiTx_local.h     | 1967 +++++
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.c    | 1062 +++
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h    |  297 +
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c |  423 ++
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.c   |  298 +
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.h   |   94 +
 .../hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCecCfg.def  |   16 +
 .../video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC.h |   46 +
 .../comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Functions.h  | 3147 ++++++++
 .../hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Types.h | 1114 +++
 .../video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c | 7969 ++++++++++++++++++++
 .../hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.c |  286 +
 .../hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.h |  208 +
 .../hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.c     |  659 ++
 .../hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.h     |  281 +
 .../hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_Linux.c  |  924 +++
 .../hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.c    |  797 ++
 .../hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.h    |  246 +
 .../video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx.h  |   54 +
 .../comps/tmdlTDA9983/inc/tmdlHdmiTx_Functions.h   | 1446 ++++
 .../hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Types.h  |  839 +++
 .../video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx.c  | 5163 +++++++++++++
 .../hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx_local.h  |  802 ++
 drivers/video/hdmi/inc/tmNxCompId.h                |  287 +
 drivers/video/hdmi/inc/tmNxTypes.h                 |  177 +
 drivers/video/hdmi/release_note.txt                |  305 +
 drivers/video/hdmi/tda998x.c                       | 2481 ++++++
 drivers/video/hdmi/tda998x.h                       |  139 +
 drivers/video/hdmi/tda998x_cec.c                   | 2629 +++++++
 drivers/video/hdmi/tda998x_cec.h                   |  140 +
 drivers/video/hdmi/tda998x_ioctl.h                 | 1142 +++
 drivers/video/hdmi/tda998x_version.h               |   16 +
 drivers/video/pxa168fb.c                           | 1029 ++-
 drivers/video/pxa168fb.h                           |    7 +
 drivers/video/pxa168fb_ovly.c                      | 2209 ++++++
 include/linux/pxa168_eth.h                         |    2 +
 include/linux/pxa2xx_ssp.h                         |    3 +-
 include/video/pxa168fb.h                           |  279 +
 61 files changed, 55957 insertions(+), 421 deletions(-)
 create mode 100644 drivers/video/hdmi/Kconfig
 create mode 100644 drivers/video/hdmi/MakeModules
 create mode 100644 drivers/video/hdmi/Makefile
 create mode 100755 drivers/video/hdmi/comps/tmbslHdmiTx/inc/tmbslHdmiTx_types.h
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx.h
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx_app.h
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_1.c
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_2.c
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.c
 create mode 100755 drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.c
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.c
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCecCfg.def
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Functions.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Types.h
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.c
 create mode 100755 drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.c
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_Linux.c
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.c
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Functions.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Types.h
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx.c
 create mode 100755 drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx_local.h
 create mode 100644 drivers/video/hdmi/inc/tmNxCompId.h
 create mode 100644 drivers/video/hdmi/inc/tmNxTypes.h
 create mode 100644 drivers/video/hdmi/release_note.txt
 create mode 100644 drivers/video/hdmi/tda998x.c
 create mode 100644 drivers/video/hdmi/tda998x.h
 create mode 100644 drivers/video/hdmi/tda998x_cec.c
 create mode 100644 drivers/video/hdmi/tda998x_cec.h
 create mode 100644 drivers/video/hdmi/tda998x_ioctl.h
 create mode 100644 drivers/video/hdmi/tda998x_version.h
 create mode 100644 drivers/video/pxa168fb_ovly.c

diff --git a/arch/arm/configs/gplugd_defconfig b/arch/arm/configs/gplugd_defconfig
index 154e4f8..24b0e6d 100755
--- a/arch/arm/configs/gplugd_defconfig
+++ b/arch/arm/configs/gplugd_defconfig
@@ -1,30 +1,26 @@
 #
 # Automatically generated file; DO NOT EDIT.
-# Linux/arm 3.4.35 Kernel Configuration
+# Linux/arm 3.8.11 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
-# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
-CONFIG_GENERIC_CLOCKEVENTS=y
-CONFIG_KTIME_SCALAR=y
 CONFIG_HAVE_PROC_CPU=y
 CONFIG_STACKTRACE_SUPPORT=y
 CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_LOCKDEP_SUPPORT=y
 CONFIG_TRACE_IRQFLAGS_SUPPORT=y
-CONFIG_HARDIRQS_SW_RESEND=y
-CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
-CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_NEED_DMA_MAP_STATE=y
 CONFIG_VECTORS_BASE=0xffff0000
 CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_NEED_MACH_GPIO_H=y
 CONFIG_GENERIC_BUG=y
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 CONFIG_HAVE_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
 
 #
 # General setup
@@ -33,8 +29,8 @@ CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
 CONFIG_CROSS_COMPILE=""
-CONFIG_LOCALVERSION=""
-CONFIG_LOCALVERSION_AUTO=y
+CONFIG_LOCALVERSION="-gplugd"
+# CONFIG_LOCALVERSION_AUTO is not set
 CONFIG_HAVE_KERNEL_GZIP=y
 CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_XZ=y
@@ -48,9 +44,7 @@ CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
-# CONFIG_BSD_PROCESS_ACCT is not set
 # CONFIG_FHANDLE is not set
-# CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
 CONFIG_HAVE_GENERIC_HARDIRQS=y
 
@@ -58,8 +52,29 @@ CONFIG_HAVE_GENERIC_HARDIRQS=y
 # IRQ subsystem
 #
 CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
 CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
 
 #
 # RCU Subsystem
@@ -68,14 +83,22 @@ CONFIG_TINY_PREEMPT_RCU=y
 CONFIG_PREEMPT_RCU=y
 # CONFIG_TREE_RCU_TRACE is not set
 # CONFIG_RCU_BOOST is not set
-# CONFIG_IKCONFIG is not set
-CONFIG_LOG_BUF_SHIFT=14
-# CONFIG_CGROUPS is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
 # CONFIG_CHECKPOINT_RESTORE is not set
 CONFIG_NAMESPACES=y
 CONFIG_UTS_NS=y
 CONFIG_IPC_NS=y
-CONFIG_USER_NS=y
 CONFIG_PID_NS=y
 CONFIG_NET_NS=y
 # CONFIG_SCHED_AUTOGROUP is not set
@@ -86,6 +109,7 @@ CONFIG_NET_NS=y
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
 # CONFIG_EXPERT is not set
+CONFIG_HAVE_UID16=y
 CONFIG_UID16=y
 # CONFIG_SYSCTL_SYSCALL is not set
 CONFIG_KALLSYMS=y
@@ -110,25 +134,35 @@ CONFIG_PERF_USE_VMALLOC=y
 # Kernel Performance Events And Counters
 #
 # CONFIG_PERF_EVENTS is not set
-# CONFIG_PERF_COUNTERS is not set
 CONFIG_VM_EVENT_COUNTERS=y
 CONFIG_COMPAT_BRK=y
 CONFIG_SLAB=y
 # CONFIG_SLUB is not set
-# CONFIG_PROFILING is not set
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=m
 CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
 # CONFIG_JUMP_LABEL is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
 CONFIG_HAVE_CLK=y
 CONFIG_HAVE_DMA_API_DEBUG=y
 CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
 
 #
 # GCOV-based kernel profiling
 #
+# CONFIG_GCOV_KERNEL is not set
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -139,6 +173,7 @@ CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
 # CONFIG_MODVERSIONS is not set
 # CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
 CONFIG_BLOCK=y
 CONFIG_LBDAF=y
 # CONFIG_BLK_DEV_BSG is not set
@@ -150,6 +185,7 @@ CONFIG_LBDAF=y
 #
 # CONFIG_PARTITION_ADVANCED is not set
 CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
 
 #
 # IO Schedulers
@@ -161,76 +197,42 @@ CONFIG_IOSCHED_CFQ=y
 CONFIG_DEFAULT_CFQ=y
 # CONFIG_DEFAULT_NOOP is not set
 CONFIG_DEFAULT_IOSCHED="cfq"
-# CONFIG_INLINE_SPIN_TRYLOCK is not set
-# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
-# CONFIG_INLINE_SPIN_LOCK is not set
-# CONFIG_INLINE_SPIN_LOCK_BH is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
-# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
 CONFIG_UNINLINE_SPIN_UNLOCK=y
-# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
-# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
-# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_READ_TRYLOCK is not set
-# CONFIG_INLINE_READ_LOCK is not set
-# CONFIG_INLINE_READ_LOCK_BH is not set
-# CONFIG_INLINE_READ_LOCK_IRQ is not set
-# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_READ_UNLOCK is not set
-# CONFIG_INLINE_READ_UNLOCK_BH is not set
-# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
-# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
-# CONFIG_INLINE_WRITE_TRYLOCK is not set
-# CONFIG_INLINE_WRITE_LOCK is not set
-# CONFIG_INLINE_WRITE_LOCK_BH is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
-# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
-# CONFIG_INLINE_WRITE_UNLOCK is not set
-# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
-# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
-# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
-# CONFIG_MUTEX_SPIN_ON_OWNER is not set
-# CONFIG_FREEZER is not set
+CONFIG_FREEZER=y
 
 #
 # System Type
 #
 CONFIG_MMU=y
+# CONFIG_ARCH_MULTIPLATFORM is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_REALVIEW is not set
 # CONFIG_ARCH_VERSATILE is not set
-# CONFIG_ARCH_VEXPRESS is not set
 # CONFIG_ARCH_AT91 is not set
-# CONFIG_ARCH_BCMRING is not set
-# CONFIG_ARCH_HIGHBANK is not set
-# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_BCM2835 is not set
 # CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_CLPS711X is not set
 # CONFIG_ARCH_GEMINI is not set
-# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_SIRF is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
-# CONFIG_ARCH_MXC is not set
 # CONFIG_ARCH_MXS is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
 # CONFIG_ARCH_IOP13XX is not set
 # CONFIG_ARCH_IOP32X is not set
 # CONFIG_ARCH_IOP33X is not set
-# CONFIG_ARCH_IXP23XX is not set
-# CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP4XX is not set
 # CONFIG_ARCH_DOVE is not set
 # CONFIG_ARCH_KIRKWOOD is not set
-# CONFIG_ARCH_LPC32XX is not set
 # CONFIG_ARCH_MV78XX0 is not set
 # CONFIG_ARCH_ORION5X is not set
 CONFIG_ARCH_MMP=y
 # CONFIG_ARCH_KS8695 is not set
 # CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
 # CONFIG_ARCH_TEGRA is not set
-# CONFIG_ARCH_PICOXCELL is not set
-# CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_MSM is not set
 # CONFIG_ARCH_SHMOBILE is not set
@@ -246,25 +248,28 @@ CONFIG_ARCH_MMP=y
 # CONFIG_ARCH_U300 is not set
 # CONFIG_ARCH_U8500 is not set
 # CONFIG_ARCH_NOMADIK is not set
+# CONFIG_PLAT_SPEAR is not set
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
-# CONFIG_PLAT_SPEAR is not set
-# CONFIG_ARCH_VT8500 is not set
-# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_ARCH_VT8500_SINGLE is not set
+CONFIG_GPIO_PCA953X=y
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_MACH_TAVOREVB is not set
 CONFIG_PXA_SSP=y
 
 #
 # Marvell PXA168/910/MMP2 Implmentations
 #
-# CONFIG_MACH_MMP_DT is not set
 # CONFIG_MACH_ASPENITE is not set
 # CONFIG_MACH_ZYLONITE2 is not set
 # CONFIG_MACH_AVENGERS_LITE is not set
-# CONFIG_MACH_TAVOREVB is not set
 # CONFIG_MACH_TTC_DKB is not set
 # CONFIG_MACH_TETON_BGA is not set
 CONFIG_MACH_GPLUGD=y
+# CONFIG_MACH_MMP_DT is not set
 CONFIG_CPU_PXA168=y
+CONFIG_USB_EHCI_MV_U2O=y
+# CONFIG_ARCH_VT8500 is not set
 CONFIG_PLAT_PXA=y
 
 #
@@ -300,16 +305,11 @@ CONFIG_IWMMXT=y
 # Bus support
 #
 # CONFIG_PCI_SYSCALL is not set
-# CONFIG_ARCH_SUPPORTS_MSI is not set
 # CONFIG_PCCARD is not set
 
 #
 # Kernel Features
 #
-CONFIG_TICK_ONESHOT=y
-CONFIG_NO_HZ=y
-CONFIG_HIGH_RES_TIMERS=y
-CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
 CONFIG_VMSPLIT_3G=y
 # CONFIG_VMSPLIT_2G is not set
 # CONFIG_VMSPLIT_1G is not set
@@ -339,34 +339,41 @@ CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_KSM is not set
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
 CONFIG_NEED_PER_CPU_KM=y
 # CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
 CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
 # CONFIG_SECCOMP is not set
 # CONFIG_CC_STACKPROTECTOR is not set
-# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 
 #
 # Boot options
 #
 # CONFIG_USE_OF is not set
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
-CONFIG_CMDLINE="root=/dev/nfs rootfstype=nfs nfsroot=192.168.2.100:/nfsroot/ ip=192.168.2.101:192.168.2.100::255.255.255.0::eth0:on console=ttyS0,115200 mem=128M"
+CONFIG_CMDLINE="root=/dev/mmcblk0p2 console=ttyS2,115200 uart_dma rootwait"
 CONFIG_CMDLINE_FROM_BOOTLOADER=y
 # CONFIG_CMDLINE_EXTEND is not set
 # CONFIG_CMDLINE_FORCE is not set
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
-# CONFIG_CRASH_DUMP is not set
+CONFIG_CRASH_DUMP=y
 # CONFIG_AUTO_ZRELADDR is not set
 
 #
 # CPU Power Management
 #
-# CONFIG_CPU_IDLE is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
 
 #
 # Floating point emulation
@@ -388,18 +395,31 @@ CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
 CONFIG_HAVE_AOUT=y
 # CONFIG_BINFMT_AOUT is not set
 # CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
 
 #
 # Power management options
 #
-# CONFIG_PM_RUNTIME is not set
-# CONFIG_ARM_CPU_SUSPEND is not set
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
 CONFIG_NET=y
 
 #
 # Networking options
 #
 CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
 CONFIG_UNIX=y
 # CONFIG_UNIX_DIAG is not set
 CONFIG_XFRM=y
@@ -412,13 +432,14 @@ CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
 # CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_PNP=y
-# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_DHCP=y
 # CONFIG_IP_PNP_BOOTP is not set
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE_DEMUX is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
@@ -446,7 +467,7 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_ATM is not set
 # CONFIG_L2TP is not set
 # CONFIG_BRIDGE is not set
-# CONFIG_NET_DSA is not set
+CONFIG_HAVE_NET_DSA=y
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
@@ -454,7 +475,6 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_ATALK is not set
 # CONFIG_X25 is not set
 # CONFIG_LAPB is not set
-# CONFIG_ECONET is not set
 # CONFIG_WAN_ROUTER is not set
 # CONFIG_PHONET is not set
 # CONFIG_IEEE802154 is not set
@@ -463,8 +483,8 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 CONFIG_DNS_RESOLVER=y
 # CONFIG_BATMAN_ADV is not set
 # CONFIG_OPENVSWITCH is not set
+# CONFIG_NETPRIO_CGROUP is not set
 CONFIG_BQL=y
-CONFIG_HAVE_BPF_JIT=y
 # CONFIG_BPF_JIT is not set
 
 #
@@ -477,18 +497,25 @@ CONFIG_HAVE_BPF_JIT=y
 # CONFIG_BT is not set
 # CONFIG_AF_RXRPC is not set
 CONFIG_WIRELESS=y
-# CONFIG_CFG80211 is not set
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
 # CONFIG_LIB80211 is not set
-
-#
-# CFG80211 needs to be enabled for MAC80211
-#
+# CONFIG_MAC80211 is not set
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
 # CONFIG_CAIF is not set
 # CONFIG_CEPH_LIB is not set
 # CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
 
 #
 # Device Drivers
@@ -498,18 +525,28 @@ CONFIG_WIRELESS=y
 # Generic Driver Options
 #
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
-# CONFIG_DEVTMPFS is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
 # CONFIG_STANDALONE is not set
 # CONFIG_PREVENT_FIRMWARE_BUILD is not set
 CONFIG_FW_LOADER=y
 CONFIG_FIRMWARE_IN_KERNEL=y
 CONFIG_EXTRA_FIRMWARE=""
-# CONFIG_DEBUG_DRIVER is not set
-# CONFIG_DEBUG_DEVRES is not set
+CONFIG_DEBUG_DRIVER=y
+CONFIG_DEBUG_DEVRES=y
 # CONFIG_SYS_HYPERVISOR is not set
 # CONFIG_GENERIC_CPU_DEVICES is not set
-# CONFIG_DMA_SHARED_BUFFER is not set
-# CONFIG_CONNECTOR is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_CMA is not set
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
 CONFIG_MTD=y
 # CONFIG_MTD_TESTS is not set
 # CONFIG_MTD_REDBOOT_PARTS is not set
@@ -521,6 +558,7 @@ CONFIG_MTD=y
 # User Modules And Translation Layers
 #
 CONFIG_MTD_CHAR=y
+CONFIG_HAVE_MTD_OTP=y
 # CONFIG_MTD_BLKDEVS is not set
 # CONFIG_MTD_BLOCK is not set
 # CONFIG_MTD_BLOCK_RO is not set
@@ -563,7 +601,7 @@ CONFIG_MTD_CFI_I2=y
 #
 CONFIG_MTD_DATAFLASH=y
 # CONFIG_MTD_DATAFLASH_WRITE_VERIFY is not set
-# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_DATAFLASH_OTP=y
 # CONFIG_MTD_M25P80 is not set
 # CONFIG_MTD_SST25L is not set
 # CONFIG_MTD_SLRAM is not set
@@ -604,7 +642,8 @@ CONFIG_MTD_DATAFLASH=y
 # CONFIG_HMC6352 is not set
 # CONFIG_DS1682 is not set
 # CONFIG_TI_DAC7512 is not set
-# CONFIG_BMP085 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
 # CONFIG_USB_SWITCH_FSA9480 is not set
 # CONFIG_C2PORT is not set
 
@@ -617,7 +656,6 @@ CONFIG_MTD_DATAFLASH=y
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EEPROM_93CX6 is not set
 # CONFIG_EEPROM_93XX46 is not set
-# CONFIG_IWMC3200TOP is not set
 
 #
 # Texas Instruments shared transport line discipline
@@ -655,7 +693,6 @@ CONFIG_SCSI_MULTI_LUN=y
 # CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
 # CONFIG_SCSI_SCAN_ASYNC is not set
-CONFIG_SCSI_WAIT_SCAN=m
 
 #
 # SCSI Transports
@@ -693,6 +730,7 @@ CONFIG_ATA_BMDMA=y
 #
 # SATA SFF controllers with BMDMA
 #
+# CONFIG_SATA_HIGHBANK is not set
 # CONFIG_SATA_MV is not set
 
 #
@@ -716,6 +754,7 @@ CONFIG_NET_CORE=y
 CONFIG_MII=y
 # CONFIG_NET_TEAM is not set
 # CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
 # CONFIG_NETCONSOLE is not set
 # CONFIG_NETPOLL is not set
 # CONFIG_NET_POLL_CONTROLLER is not set
@@ -725,46 +764,43 @@ CONFIG_MII=y
 #
 # CAIF transport drivers
 #
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
 CONFIG_ETHERNET=y
-CONFIG_NET_VENDOR_BROADCOM=y
-# CONFIG_B44 is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
 # CONFIG_NET_CALXEDA_XGMAC is not set
-CONFIG_NET_VENDOR_CHELSIO=y
-CONFIG_NET_VENDOR_CIRRUS=y
-# CONFIG_CS89x0 is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
 # CONFIG_DM9000 is not set
 # CONFIG_DNET is not set
-CONFIG_NET_VENDOR_FARADAY=y
-# CONFIG_FTMAC100 is not set
-# CONFIG_FTGMAC100 is not set
-CONFIG_NET_VENDOR_INTEL=y
-CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
 CONFIG_NET_VENDOR_MARVELL=y
+CONFIG_MVMDIO=y
 CONFIG_PXA168_ETH=y
-CONFIG_NET_VENDOR_MICREL=y
-# CONFIG_KS8851 is not set
-# CONFIG_KS8851_MLL is not set
-CONFIG_NET_VENDOR_MICROCHIP=y
-# CONFIG_ENC28J60 is not set
-CONFIG_NET_VENDOR_NATSEMI=y
-CONFIG_NET_VENDOR_8390=y
-# CONFIG_AX88796 is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
 # CONFIG_ETHOC is not set
-CONFIG_NET_VENDOR_SEEQ=y
-# CONFIG_SEEQ8005 is not set
-CONFIG_NET_VENDOR_SMSC=y
-CONFIG_SMC91X=y
-# CONFIG_SMC911X is not set
-# CONFIG_SMSC911X is not set
-CONFIG_NET_VENDOR_STMICRO=y
-# CONFIG_STMMAC_ETH is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
 CONFIG_PHYLIB=y
 
 #
 # MII PHY device drivers
 #
+# CONFIG_AT803X_PHY is not set
 # CONFIG_AMD_PHY is not set
-# CONFIG_MARVELL_PHY is not set
+CONFIG_MARVELL_PHY=y
 # CONFIG_DAVICOM_PHY is not set
 # CONFIG_QSEMI_PHY is not set
 # CONFIG_LXT_PHY is not set
@@ -772,6 +808,7 @@ CONFIG_PHYLIB=y
 # CONFIG_VITESSE_PHY is not set
 # CONFIG_SMSC_PHY is not set
 # CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_REALTEK_PHY is not set
 # CONFIG_NATIONAL_PHY is not set
@@ -795,7 +832,13 @@ CONFIG_PHYLIB=y
 # CONFIG_USB_IPHETH is not set
 CONFIG_WLAN=y
 # CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_ATH_CARDS is not set
+# CONFIG_BRCMFMAC is not set
 # CONFIG_HOSTAP is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_WL_TI is not set
+# CONFIG_MWIFIEX is not set
 
 #
 # Enable WiMAX (Networking options) to see the WiMAX drivers
@@ -807,9 +850,10 @@ CONFIG_WLAN=y
 # Input device support
 #
 CONFIG_INPUT=y
-# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_FF_MEMLESS=y
 # CONFIG_INPUT_POLLDEV is not set
-# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_SPARSEKMAP=y
+CONFIG_INPUT_MATRIXKMAP=y
 
 #
 # Userland interfaces
@@ -819,23 +863,119 @@ CONFIG_INPUT_MOUSEDEV=y
 CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
 CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 # CONFIG_INPUT_JOYDEV is not set
-# CONFIG_INPUT_EVDEV is not set
+CONFIG_INPUT_EVDEV=y
 # CONFIG_INPUT_EVBUG is not set
 
 #
 # Input Device Drivers
 #
-# CONFIG_INPUT_KEYBOARD is not set
-# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+CONFIG_KEYBOARD_PXA27x=y
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
 # CONFIG_INPUT_JOYSTICK is not set
 # CONFIG_INPUT_TABLET is not set
-# CONFIG_INPUT_TOUCHSCREEN is not set
-# CONFIG_INPUT_MISC is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+CONFIG_TOUCHSCREEN_TSC2007=y
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
 
 #
 # Hardware I/O ports
 #
-# CONFIG_SERIO is not set
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
 # CONFIG_GAMEPORT is not set
 
 #
@@ -844,8 +984,9 @@ CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
 CONFIG_VT=y
 CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
 CONFIG_HW_CONSOLE=y
-# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
 CONFIG_UNIX98_PTYS=y
 # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
 # CONFIG_LEGACY_PTYS is not set
@@ -863,29 +1004,37 @@ CONFIG_DEVKMEM=y
 # Non-8250 serial port support
 #
 # CONFIG_SERIAL_MAX3100 is not set
-# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MAX310X is not set
 CONFIG_SERIAL_PXA=y
 CONFIG_SERIAL_PXA_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
 # CONFIG_SERIAL_TIMBERDALE is not set
 # CONFIG_SERIAL_ALTERA_JTAGUART is not set
 # CONFIG_SERIAL_ALTERA_UART is not set
 # CONFIG_SERIAL_IFX6X60 is not set
-# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
 # CONFIG_HVC_DCC is not set
 # CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
-# CONFIG_RAMOOPS is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_COMPAT=y
-# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_CHARDEV=y
 # CONFIG_I2C_MUX is not set
-CONFIG_I2C_HELPER_AUTO=y
+# CONFIG_I2C_HELPER_AUTO is not set
+CONFIG_I2C_SMBUS=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCF=y
+CONFIG_I2C_ALGOPCA=y
 
 #
 # I2C Hardware Bus support
@@ -894,6 +1043,7 @@ CONFIG_I2C_HELPER_AUTO=y
 #
 # I2C system bus drivers (mostly embedded / system-on-chip)
 #
+# CONFIG_I2C_CBUS_GPIO is not set
 # CONFIG_I2C_DESIGNWARE_PLATFORM is not set
 # CONFIG_I2C_GPIO is not set
 # CONFIG_I2C_OCORES is not set
@@ -932,6 +1082,8 @@ CONFIG_SPI_MASTER=y
 # CONFIG_SPI_OC_TINY is not set
 CONFIG_SPI_PXA2XX=y
 # CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_XCOMM is not set
 # CONFIG_SPI_XILINX is not set
 # CONFIG_SPI_DESIGNWARE is not set
 
@@ -954,10 +1106,25 @@ CONFIG_SPI_PXA2XX=y
 #
 # PTP clock support
 #
+# CONFIG_PTP_1588_CLOCK is not set
 
 #
-# Enable Device Drivers -> PPS to see the PTP clock options.
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_PINCTRL=y
+
 #
+# Pin controllers
+#
+# CONFIG_PINMUX is not set
+# CONFIG_PINCONF is not set
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_MMP2 is not set
+# CONFIG_PINCTRL_PXA168 is not set
+# CONFIG_PINCTRL_PXA910 is not set
+# CONFIG_PINCTRL_EXYNOS5440 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
 CONFIG_ARCH_REQUIRE_GPIOLIB=y
 CONFIG_GPIOLIB=y
 # CONFIG_DEBUG_GPIO is not set
@@ -967,14 +1134,16 @@ CONFIG_GPIOLIB=y
 # Memory mapped GPIO drivers:
 #
 # CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_EM is not set
 CONFIG_GPIO_PXA=y
+# CONFIG_GPIO_TS5500 is not set
 
 #
 # I2C GPIO expanders:
 #
 # CONFIG_GPIO_MAX7300 is not set
 # CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
+CONFIG_GPIO_PCA953X_IRQ=y
 # CONFIG_GPIO_PCF857X is not set
 # CONFIG_GPIO_SX150X is not set
 # CONFIG_GPIO_ADP5588 is not set
@@ -998,8 +1167,13 @@ CONFIG_GPIO_PXA=y
 #
 # MODULbus GPIO expanders:
 #
+
+#
+# USB GPIO expanders:
+#
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
+# CONFIG_POWER_AVS is not set
 # CONFIG_HWMON is not set
 # CONFIG_THERMAL is not set
 # CONFIG_WATCHDOG is not set
@@ -1019,13 +1193,17 @@ CONFIG_BCMA_POSSIBLE=y
 #
 # Multifunction device drivers
 #
-# CONFIG_MFD_CORE is not set
+CONFIG_MFD_CORE=m
 # CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
 # CONFIG_MFD_SM501 is not set
 # CONFIG_MFD_ASIC3 is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
 # CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
 # CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_LM3533 is not set
 # CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
 # CONFIG_TPS6507X is not set
@@ -1034,54 +1212,335 @@ CONFIG_BCMA_POSSIBLE=y
 # CONFIG_MFD_TPS65910 is not set
 # CONFIG_MFD_TPS65912_I2C is not set
 # CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
 # CONFIG_TWL4030_CORE is not set
 # CONFIG_TWL6040_CORE is not set
 # CONFIG_MFD_STMPE is not set
 # CONFIG_MFD_TC3589X is not set
 # CONFIG_MFD_TMIO is not set
 # CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_SMSC is not set
 # CONFIG_MFD_TC6387XB is not set
 # CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
 # CONFIG_MFD_DA9052_SPI is not set
 # CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
 # CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
 # CONFIG_MFD_MAX8925 is not set
 # CONFIG_MFD_MAX8997 is not set
 # CONFIG_MFD_MAX8998 is not set
-# CONFIG_MFD_S5M_CORE is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
 # CONFIG_MFD_WM8400 is not set
 # CONFIG_MFD_WM831X_I2C is not set
 # CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_MC13XXX is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
 # CONFIG_ABX500_CORE is not set
 # CONFIG_EZX_PCAP is not set
 # CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_MFD_TPS65090 is not set
 # CONFIG_MFD_AAT2870_CORE is not set
 # CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_AS3711 is not set
 # CONFIG_REGULATOR is not set
-# CONFIG_MEDIA_SUPPORT is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_MMP_CAMERA is not set
+# CONFIG_SOC_CAMERA is not set
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+
+#
+# Audio decoders, processors and mixers
+#
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+
+#
+# Video and audio decoders
+#
+
+#
+# MPEG video encoders
+#
+
+#
+# Video encoders
+#
+
+#
+# Camera sensor devices
+#
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+
+#
+# Miscelaneous helper chips
+#
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
 
 #
 # Graphics support
 #
-# CONFIG_DRM is not set
+CONFIG_DRM=y
+# CONFIG_DRM_UDL is not set
 # CONFIG_VGASTATE is not set
-# CONFIG_VIDEO_OUTPUT_CONTROL is not set
-# CONFIG_FB is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_TDA9981=y
+CONFIG_TDA9950=y
+CONFIG_FB_PXA168=y
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+CONFIG_FB_VIRTUAL=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
 # CONFIG_EXYNOS_VIDEO is not set
-# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
 
 #
 # Console display driver support
 #
 CONFIG_DUMMY_CONSOLE=y
-# CONFIG_SOUND is not set
-# CONFIG_HID_SUPPORT is not set
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+CONFIG_SND_DUMMY=y
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_DESIGNWARE_I2S is not set
+# CONFIG_SND_MMP_SOC is not set
+# CONFIG_SND_PXA910_SOC is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+CONFIG_UHID=y
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+CONFIG_HID_ACRUX=m
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_AUREAL=m
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_PRODIKEYS=m
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_DRAGONRISE=m
+CONFIG_DRAGONRISE_FF=y
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_EZKEY=y
+CONFIG_HID_HOLTEK=m
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LCPOWER=m
+CONFIG_HID_LENOVO_TPKBD=m
+CONFIG_HID_LOGITECH=y
+CONFIG_HID_LOGITECH_DJ=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWHEELS_FF=y
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_BACKLIGHT=y
+CONFIG_HID_PICOLCD_LCD=y
+CONFIG_HID_PICOLCD_LEDS=y
+CONFIG_HID_PRIMAX=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_SAITEK=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TIVO=m
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=m
+CONFIG_HID_SENSOR_HUB=m
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# I2C HID support
+#
+CONFIG_I2C_HID=y
 # CONFIG_USB_ARCH_HAS_OHCI is not set
 CONFIG_USB_ARCH_HAS_EHCI=y
 # CONFIG_USB_ARCH_HAS_XHCI is not set
@@ -1089,16 +1548,19 @@ CONFIG_USB_SUPPORT=y
 CONFIG_USB_COMMON=y
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB=y
-# CONFIG_USB_DEBUG is not set
-# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 
 #
 # Miscellaneous USB options
 #
-# CONFIG_USB_DEVICEFS is not set
-CONFIG_USB_DEVICE_CLASS=y
-# CONFIG_USB_DYNAMIC_MINORS is not set
-# CONFIG_USB_MON is not set
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_SUSPEND=y
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_WHITELIST=y
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_DWC3 is not set
+CONFIG_USB_MON=y
 # CONFIG_USB_WUSB_CBAF is not set
 
 #
@@ -1116,6 +1578,9 @@ CONFIG_USB_EHCI_MV=y
 # CONFIG_USB_EHCI_HCD_PLATFORM is not set
 # CONFIG_USB_SL811_HCD is not set
 # CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_RENESAS_USBHS is not set
 
 #
 # USB Device Class drivers
@@ -1133,21 +1598,21 @@ CONFIG_USB_WDM=y
 # also be needed; see USB_STORAGE Help for more info
 #
 CONFIG_USB_STORAGE=y
-# CONFIG_USB_STORAGE_DEBUG is not set
-# CONFIG_USB_STORAGE_REALTEK is not set
-# CONFIG_USB_STORAGE_DATAFAB is not set
-# CONFIG_USB_STORAGE_FREECOM is not set
-# CONFIG_USB_STORAGE_ISD200 is not set
-# CONFIG_USB_STORAGE_USBAT is not set
-# CONFIG_USB_STORAGE_SDDR09 is not set
-# CONFIG_USB_STORAGE_SDDR55 is not set
-# CONFIG_USB_STORAGE_JUMPSHOT is not set
-# CONFIG_USB_STORAGE_ALAUDA is not set
-# CONFIG_USB_STORAGE_ONETOUCH is not set
-# CONFIG_USB_STORAGE_KARMA is not set
-# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
-# CONFIG_USB_STORAGE_ENE_UB6250 is not set
-# CONFIG_USB_LIBUSUAL is not set
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_STORAGE_REALTEK=m
+CONFIG_REALTEK_AUTOPM=y
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+CONFIG_USB_STORAGE_USBAT=m
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+CONFIG_USB_STORAGE_ALAUDA=m
+CONFIG_USB_STORAGE_ONETOUCH=m
+CONFIG_USB_STORAGE_KARMA=m
+CONFIG_USB_STORAGE_CYPRESS_ATACB=m
+CONFIG_USB_STORAGE_ENE_UB6250=m
 
 #
 # USB Imaging devices
@@ -1159,8 +1624,7 @@ CONFIG_USB_STORAGE=y
 # USB port drivers
 #
 CONFIG_USB_SERIAL=y
-# CONFIG_USB_SERIAL_CONSOLE is not set
-# CONFIG_USB_EZUSB is not set
+CONFIG_USB_SERIAL_CONSOLE=y
 CONFIG_USB_SERIAL_GENERIC=y
 # CONFIG_USB_SERIAL_AIRCABLE is not set
 # CONFIG_USB_SERIAL_ARK3116 is not set
@@ -1210,7 +1674,9 @@ CONFIG_USB_SERIAL_PL2303=y
 # CONFIG_USB_SERIAL_OPTICON is not set
 # CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
 # CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_ZTE is not set
 # CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
 # CONFIG_USB_SERIAL_DEBUG is not set
 
 #
@@ -1222,8 +1688,8 @@ CONFIG_USB_SERIAL_PL2303=y
 # CONFIG_USB_SEVSEG is not set
 # CONFIG_USB_RIO500 is not set
 # CONFIG_USB_LEGOTOWER is not set
-# CONFIG_USB_LCD is not set
-# CONFIG_USB_LED is not set
+CONFIG_USB_LCD=y
+CONFIG_USB_LED=y
 # CONFIG_USB_CYPRESS_CY7C63 is not set
 # CONFIG_USB_CYTHERM is not set
 # CONFIG_USB_IDMOUSE is not set
@@ -1236,14 +1702,59 @@ CONFIG_USB_SERIAL_PL2303=y
 # CONFIG_USB_TEST is not set
 # CONFIG_USB_ISIGHTFW is not set
 # CONFIG_USB_YUREX is not set
-# CONFIG_USB_GADGET is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_RCAR_PHY is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_R8A66597 is not set
+CONFIG_USB_MV_UDC=y
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=m
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+CONFIG_USB_GADGETFS=m
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+CONFIG_USB_G_PRINTER=m
+# CONFIG_USB_CDC_COMPOSITE is not set
+CONFIG_USB_G_ACM_MS=m
+CONFIG_USB_G_MULTI=m
+CONFIG_USB_G_MULTI_RNDIS=y
+CONFIG_USB_G_MULTI_CDC=y
+CONFIG_USB_G_HID=m
+CONFIG_USB_G_DBGP=m
+CONFIG_USB_G_DBGP_PRINTK=y
+# CONFIG_USB_G_DBGP_SERIAL is not set
+CONFIG_USB_G_WEBCAM=m
 
 #
 # OTG and related infrastructure
 #
-# CONFIG_USB_GPIO_VBUS is not set
+CONFIG_USB_OTG_UTILS=y
+CONFIG_USB_GPIO_VBUS=y
 # CONFIG_USB_ULPI is not set
 # CONFIG_NOP_USB_XCEIV is not set
+CONFIG_USB_MV_OTG=y
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
 # CONFIG_MMC_UNSAFE_RESUME is not set
@@ -1269,10 +1780,37 @@ CONFIG_MMC_SDHCI_PXAV2=y
 # CONFIG_MMC_SPI is not set
 # CONFIG_MMC_DW is not set
 # CONFIG_MMC_VUB300 is not set
-# CONFIG_MMC_USHC is not set
+CONFIG_MMC_USHC=m
 # CONFIG_MEMSTICK is not set
-# CONFIG_NEW_LEDS is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=m
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA9633 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_OT200 is not set
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_TRIGGERS is not set
+
+#
+# LED Triggers
+#
 # CONFIG_ACCESSIBILITY is not set
+# CONFIG_EDAC is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
 CONFIG_RTC_HCTOSYS=y
@@ -1300,6 +1838,7 @@ CONFIG_RTC_INTF_DEV=y
 CONFIG_RTC_DRV_ISL1208=y
 # CONFIG_RTC_DRV_ISL12022 is not set
 # CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
 # CONFIG_RTC_DRV_PCF8563 is not set
 # CONFIG_RTC_DRV_PCF8583 is not set
 # CONFIG_RTC_DRV_M41T80 is not set
@@ -1340,6 +1879,7 @@ CONFIG_RTC_DRV_ISL1208=y
 # CONFIG_RTC_DRV_BQ4802 is not set
 # CONFIG_RTC_DRV_RP5C01 is not set
 # CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
 
 #
 # on-CPU RTC drivers
@@ -1353,7 +1893,6 @@ CONFIG_RTC_DRV_ISL1208=y
 #
 # Virtio drivers
 #
-# CONFIG_VIRTIO_BALLOON is not set
 # CONFIG_VIRTIO_MMIO is not set
 
 #
@@ -1361,6 +1900,13 @@ CONFIG_RTC_DRV_ISL1208=y
 #
 # CONFIG_STAGING is not set
 CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_DEBUG=y
 
 #
 # Hardware Spinlock drivers
@@ -1370,12 +1916,18 @@ CONFIG_IOMMU_SUPPORT=y
 #
 # Remoteproc drivers (EXPERIMENTAL)
 #
+# CONFIG_STE_MODEM_RPROC is not set
 
 #
 # Rpmsg drivers (EXPERIMENTAL)
 #
 # CONFIG_VIRT_DRIVERS is not set
 # CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
 
 #
 # File systems
@@ -1389,12 +1941,13 @@ CONFIG_EXT3_FS_XATTR=y
 # CONFIG_EXT3_FS_POSIX_ACL is not set
 # CONFIG_EXT3_FS_SECURITY is not set
 CONFIG_EXT4_FS=y
-CONFIG_EXT4_FS_XATTR=y
 # CONFIG_EXT4_FS_POSIX_ACL is not set
 # CONFIG_EXT4_FS_SECURITY is not set
 # CONFIG_EXT4_DEBUG is not set
 CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
 CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
@@ -1433,12 +1986,15 @@ CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_FAT_DEFAULT_CODEPAGE=437
 CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
-# CONFIG_NTFS_FS is not set
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
 
 #
 # Pseudo filesystems
 #
 CONFIG_PROC_FS=y
+CONFIG_PROC_VMCORE=y
 CONFIG_PROC_SYSCTL=y
 CONFIG_PROC_PAGE_MONITOR=y
 CONFIG_SYSFS=y
@@ -1470,11 +2026,14 @@ CONFIG_CRAMFS=y
 # CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
 CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
 CONFIG_NFS_V3=y
 CONFIG_NFS_V3_ACL=y
 CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
 # CONFIG_NFS_V4_1 is not set
 CONFIG_ROOT_NFS=y
 # CONFIG_NFS_USE_LEGACY_DNS is not set
@@ -1531,6 +2090,17 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_ISO8859_15 is not set
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
 # CONFIG_NLS_UTF8 is not set
 
 #
@@ -1543,20 +2113,23 @@ CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
 CONFIG_MAGIC_SYSRQ=y
 # CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
 # CONFIG_UNUSED_SYMBOLS is not set
-# CONFIG_DEBUG_FS is not set
+CONFIG_DEBUG_FS=y
 # CONFIG_HEADERS_CHECK is not set
 # CONFIG_DEBUG_SECTION_MISMATCH is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
 # CONFIG_LOCKUP_DETECTOR is not set
-# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
 # CONFIG_DETECT_HUNG_TASK is not set
 CONFIG_SCHED_DEBUG=y
 # CONFIG_SCHEDSTATS is not set
 # CONFIG_TIMER_STATS is not set
 # CONFIG_DEBUG_OBJECTS is not set
 # CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
 # CONFIG_DEBUG_KMEMLEAK is not set
 # CONFIG_DEBUG_PREEMPT is not set
 # CONFIG_DEBUG_RT_MUTEXES is not set
@@ -1565,6 +2138,7 @@ CONFIG_SCHED_DEBUG=y
 # CONFIG_DEBUG_MUTEXES is not set
 # CONFIG_DEBUG_LOCK_ALLOC is not set
 # CONFIG_PROVE_LOCKING is not set
+# CONFIG_PROVE_RCU_DELAY is not set
 # CONFIG_SPARSE_RCU_POINTER is not set
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_ATOMIC_SLEEP is not set
@@ -1588,6 +2162,8 @@ CONFIG_DEBUG_MEMORY_INIT=y
 # CONFIG_BACKTRACE_SELF_TEST is not set
 # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
 # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+CONFIG_LKDTM=y
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 # CONFIG_DEBUG_PAGEALLOC is not set
@@ -1595,7 +2171,11 @@ CONFIG_HAVE_FUNCTION_TRACER=y
 CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
 CONFIG_HAVE_DYNAMIC_FTRACE=y
 CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
 CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
 CONFIG_TRACING_SUPPORT=y
 CONFIG_FTRACE=y
 # CONFIG_FUNCTION_TRACER is not set
@@ -1603,11 +2183,17 @@ CONFIG_FTRACE=y
 # CONFIG_PREEMPT_TRACER is not set
 # CONFIG_SCHED_TRACER is not set
 # CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
 CONFIG_BRANCH_PROFILE_NONE=y
 # CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
 # CONFIG_PROFILE_ALL_BRANCHES is not set
 # CONFIG_STACK_TRACER is not set
 # CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_PROBE_EVENTS is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+CONFIG_DYNAMIC_DEBUG=y
 # CONFIG_DMA_API_DEBUG is not set
 # CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
@@ -1618,11 +2204,13 @@ CONFIG_HAVE_ARCH_KGDB=y
 CONFIG_ARM_UNWIND=y
 CONFIG_DEBUG_USER=y
 CONFIG_DEBUG_LL=y
+# CONFIG_DEBUG_MMP_UART2 is not set
+CONFIG_DEBUG_MMP_UART3=y
 # CONFIG_DEBUG_LL_UART_NONE is not set
-CONFIG_DEBUG_MMP_UART2=y
 # CONFIG_DEBUG_ICEDCC is not set
 # CONFIG_DEBUG_SEMIHOSTING is not set
-# CONFIG_EARLY_PRINTK is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_EARLY_PRINTK=y
 
 #
 # Security options
@@ -1640,11 +2228,22 @@ CONFIG_CRYPTO=y
 #
 # Crypto core or helper
 #
-# CONFIG_CRYPTO_MANAGER is not set
-# CONFIG_CRYPTO_MANAGER2 is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
 # CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
 # CONFIG_CRYPTO_CRYPTD is not set
 # CONFIG_CRYPTO_AUTHENC is not set
 # CONFIG_CRYPTO_TEST is not set
@@ -1659,7 +2258,7 @@ CONFIG_CRYPTO=y
 #
 # Block modes
 #
-# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CBC=y
 # CONFIG_CRYPTO_CTR is not set
 # CONFIG_CRYPTO_CTS is not set
 # CONFIG_CRYPTO_ECB is not set
@@ -1677,16 +2276,17 @@ CONFIG_CRYPTO=y
 #
 # Digest
 #
-# CONFIG_CRYPTO_CRC32C is not set
+CONFIG_CRYPTO_CRC32C=y
 # CONFIG_CRYPTO_GHASH is not set
 # CONFIG_CRYPTO_MD4 is not set
-# CONFIG_CRYPTO_MD5 is not set
+CONFIG_CRYPTO_MD5=y
 # CONFIG_CRYPTO_MICHAEL_MIC is not set
 # CONFIG_CRYPTO_RMD128 is not set
 # CONFIG_CRYPTO_RMD160 is not set
 # CONFIG_CRYPTO_RMD256 is not set
 # CONFIG_CRYPTO_RMD320 is not set
 # CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
 # CONFIG_CRYPTO_SHA256 is not set
 # CONFIG_CRYPTO_SHA512 is not set
 # CONFIG_CRYPTO_TGR192 is not set
@@ -1695,14 +2295,15 @@ CONFIG_CRYPTO=y
 #
 # Ciphers
 #
-# CONFIG_CRYPTO_AES is not set
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_ARM=y
 # CONFIG_CRYPTO_ANUBIS is not set
 # CONFIG_CRYPTO_ARC4 is not set
 # CONFIG_CRYPTO_BLOWFISH is not set
 # CONFIG_CRYPTO_CAMELLIA is not set
 # CONFIG_CRYPTO_CAST5 is not set
 # CONFIG_CRYPTO_CAST6 is not set
-# CONFIG_CRYPTO_DES is not set
+CONFIG_CRYPTO_DES=y
 # CONFIG_CRYPTO_FCRYPT is not set
 # CONFIG_CRYPTO_KHAZAD is not set
 # CONFIG_CRYPTO_SALSA20 is not set
@@ -1714,9 +2315,9 @@ CONFIG_CRYPTO=y
 #
 # Compression
 #
-# CONFIG_CRYPTO_DEFLATE is not set
+CONFIG_CRYPTO_DEFLATE=y
 # CONFIG_CRYPTO_ZLIB is not set
-# CONFIG_CRYPTO_LZO is not set
+CONFIG_CRYPTO_LZO=y
 
 #
 # Random Number Generation
@@ -1725,14 +2326,18 @@ CONFIG_CRYPTO=y
 # CONFIG_CRYPTO_USER_API_HASH is not set
 # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
 CONFIG_CRYPTO_HW=y
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
 # CONFIG_BINARY_PRINTF is not set
 
 #
 # Library routines
 #
 CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
 CONFIG_GENERIC_PCI_IOMAP=y
 CONFIG_GENERIC_IO=y
+CONFIG_PERCPU_RWSEM=y
 CONFIG_CRC_CCITT=y
 CONFIG_CRC16=y
 # CONFIG_CRC_T10DIF is not set
@@ -1747,6 +2352,9 @@ CONFIG_CRC32_SLICEBY8=y
 # CONFIG_LIBCRC32C is not set
 # CONFIG_CRC8 is not set
 CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
 # CONFIG_XZ_DEC is not set
 # CONFIG_XZ_DEC_BCJ is not set
 CONFIG_GENERIC_ALLOCATOR=y
@@ -1756,5 +2364,7 @@ CONFIG_HAS_DMA=y
 CONFIG_DQL=y
 CONFIG_NLATTR=y
 CONFIG_GENERIC_ATOMIC64=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
 # CONFIG_AVERAGE is not set
 # CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
diff --git a/arch/arm/mach-mmp/devices.c b/arch/arm/mach-mmp/devices.c
index dd2d8b1..1030c91 100644
--- a/arch/arm/mach-mmp/devices.c
+++ b/arch/arm/mach-mmp/devices.c
@@ -241,6 +241,42 @@ void pxa_usb_phy_deinit(void __iomem *phy_reg)
 #ifdef CONFIG_USB_SUPPORT
 static u64 usb_dma_mask = ~(u32)0;
 
+#ifdef CONFIG_USB_EHCI_MV
+struct resource pxa168_u2h_resources[] = {
+	/* regbase */
+	[0] = {
+		.start  = PXA168_U2H_REGBASE + U2x_CAPREGS_OFFSET,
+		.end    = PXA168_U2H_REGBASE + USB_REG_RANGE,
+		.flags  = IORESOURCE_MEM,
+		.name   = "capregs",
+	},
+	/* phybase */
+	[1] = {
+		.start  = PXA168_U2H_PHYBASE,
+		.end    = PXA168_U2H_PHYBASE + USB_PHY_RANGE,
+		.flags  = IORESOURCE_MEM,
+		.name   = "phyregs",
+	},
+	[2] = {
+		.start  = IRQ_PXA168_USB2,
+		.end    = IRQ_PXA168_USB2,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device pxa168_device_u2h = {
+	.name = "pxa-sph",
+	.id   = -1,
+	.resource      = pxa168_u2h_resources,
+	.num_resources = ARRAY_SIZE(pxa168_u2h_resources),
+	.dev  = {
+		.dma_mask = &usb_dma_mask,
+		.coherent_dma_mask = 0xffffffff,
+		/*.release = ehci_hcd_pxa_device_release,*/
+	},
+};
+#endif
+
 #ifdef CONFIG_USB_MV_UDC
 struct resource pxa168_u2o_resources[] = {
 	/* regbase */
diff --git a/arch/arm/mach-mmp/include/mach/pxa168.h b/arch/arm/mach-mmp/include/mach/pxa168.h
index 7ed1df2..eb3ffcb 100644
--- a/arch/arm/mach-mmp/include/mach/pxa168.h
+++ b/arch/arm/mach-mmp/include/mach/pxa168.h
@@ -14,6 +14,7 @@
 #include <linux/platform_data/keypad-pxa27x.h>
 #include <mach/cputype.h>
 #include <linux/pxa168_eth.h>
+#include <linux/platform_data/pxa_sdhci.h>
 #include <linux/platform_data/mv_usb.h>
 
 extern struct pxa_device_desc pxa168_device_uart1;
@@ -34,6 +35,25 @@
 extern struct pxa_device_desc pxa168_device_fb;
 extern struct pxa_device_desc pxa168_device_keypad;
 extern struct pxa_device_desc pxa168_device_eth;
+extern struct pxa_device_desc pxa168_device_sdh1;
+extern struct pxa_device_desc pxa168_device_sdh2;
+extern struct pxa_device_desc pxa168_device_sdh3;
+extern struct pxa_device_desc pxa168_device_sdh4;
+
+extern struct platform_device pxa168_device_u2o;
+extern struct platform_device pxa168_device_u2h;
+extern struct platform_device pxa168_device_u2oehci;
+extern struct platform_device pxa168_device_u2ootg;
+extern struct pxa_device_desc pxa168_device_fb_ovly;
+extern struct pxa_device_desc pxa168_device_onenand;
+extern struct pxa_device_desc pxa168_device_pcie;
+extern struct platform_device pxa168_device_freq;
+extern struct platform_device pxa168_device_cir;
+extern struct pxa_device_desc pxa168_device_camera;
+extern struct pxa_device_desc pxa168_device_ov529;
+extern struct pxa_device_desc pxa168_device_msp;
+extern struct pxa_device_desc pxa168_device_cf;
+extern struct pxa_device_desc pxa168_device_icr;
 
 /* pdata can be NULL */
 extern int __init pxa168_add_usb_host(struct mv_usb_platform_data *pdata);
@@ -119,6 +139,23 @@ static inline int pxa168_add_fb(struct pxa168fb_mach_info *mi)
 	return pxa_register_device(&pxa168_device_fb, mi, sizeof(*mi));
 }
 
+static inline int pxa168_add_fb_ovly(struct pxa168fb_mach_info *mi)
+{
+	return pxa_register_device(&pxa168_device_fb_ovly, mi, sizeof(*mi));
+}
+
+static inline int pxa168_add_cam(void)
+{
+	return pxa_register_device(&pxa168_device_camera, NULL, 0);
+}
+
+#if 0
+static inline int pxa168_add_ov529(struct ov529_platform_data *pd)
+{
+	return pxa_register_device(&pxa168_device_ov529, pd, sizeof(*pd));
+}
+#endif
+
 static inline int pxa168_add_keypad(struct pxa27x_keypad_platform_data *data)
 {
 	if (cpu_is_pxa168())
@@ -131,4 +168,19 @@ static inline int pxa168_add_eth(struct pxa168_eth_platform_data *data)
 {
 	return pxa_register_device(&pxa168_device_eth, data, sizeof(*data));
 }
+
+static inline int pxa168_add_sdh(int id, struct sdhci_pxa_platdata *data)
+{
+	struct pxa_device_desc *d = NULL;
+
+	switch (id) {
+	case 1: d = &pxa168_device_sdh1; break;
+	case 2: d = &pxa168_device_sdh2; break;
+	case 3: d = &pxa168_device_sdh3; break;
+	case 4: d = &pxa168_device_sdh4; break;
+	default:
+		return -EINVAL;
+	}
+	return pxa_register_device(d, data, sizeof(*data));
+}
 #endif /* __ASM_MACH_PXA168_H */
diff --git a/arch/arm/mach-mmp/pxa168.c b/arch/arm/mach-mmp/pxa168.c
index a30dcf3..9ea674e 100644
--- a/arch/arm/mach-mmp/pxa168.c
+++ b/arch/arm/mach-mmp/pxa168.c
@@ -108,8 +108,22 @@ void pxa168_clear_keypad_wakeup(void)
 PXA168_DEVICE(ssp4, "pxa168-ssp", 3, SSP4, 0xd4020000, 0x40, 58, 59);
 PXA168_DEVICE(ssp5, "pxa168-ssp", 4, SSP5, 0xd4021000, 0x40, 60, 61);
 PXA168_DEVICE(fb, "pxa168-fb", -1, LCD, 0xd420b000, 0x1c8);
+PXA168_DEVICE(fb_ovly, "pxa168fb_ovly", -1, LCD, 0xd420b000, 0x1c8);
 PXA168_DEVICE(keypad, "pxa27x-keypad", -1, KEYPAD, 0xd4012000, 0x4c);
 PXA168_DEVICE(eth, "pxa168-eth", -1, MFU, 0xc0800000, 0x0fff);
+PXA168_DEVICE(sdh1, "sdhci-pxav2", 0, SDH1, 0xd4280000, 0x100);
+PXA168_DEVICE(sdh2, "sdhci-pxav2", 1, SDH1, 0xd4281000, 0x100);
+PXA168_DEVICE(sdh3, "sdhci-pxav2", 2, SDH2, 0xd427e000, 0x100);
+PXA168_DEVICE(sdh4, "sdhci-pxav2", 3, SDH2, 0xd427f000, 0x100);
+PXA168_DEVICE(cf, "pxa168-cf", -1, CF, 0xd4285000, 0x800);	/*Compact Flash*/
+PXA168_DEVICE(onenand, "onenand", -1, NONE, 0x80000000, 0x100000);	/*NOR Flash*/
+/*PXA168_DEVICE(pcie, "pxa168-pcie", -1, PCIE_CORE, 0xd1200000, 0x0FFF);*/	/*PCIe DMA*/
+PXA168_DEVICE(camera, "pxa168-camera", -1, CI, 0xd420a000, 0xfff);
+PXA168_DEVICE(ov529, "pxa168-ov529", -1, NONE, SMC_CS0_PHYS_BASE, 0x100); /*NOR Flash PHY Base*/
+PXA168_DEVICE(msp, "pxa168-msp", -1, MSP, 0xd4286000, 0x0FFF);	/*MS/MSPRO Memory Stick*/
+/*PXA168_DEVICE(icr, "pxa168-icr", -1, ICR, 0xC0802000, 0x1000);*/	/*CMU Color Management Unit*/
+
+/***********/
 
 struct resource pxa168_resource_gpio[] = {
 	{
diff --git a/drivers/clk/mmp/clk-pxa168.c b/drivers/clk/mmp/clk-pxa168.c
index 28b3b51..321a9ed 100644
--- a/drivers/clk/mmp/clk-pxa168.c
+++ b/drivers/clk/mmp/clk-pxa168.c
@@ -20,30 +20,137 @@
 
 #include "clk.h"
 
-#define APBC_RTC	0x28
-#define APBC_TWSI0	0x2c
-#define APBC_KPC	0x30
-#define APBC_UART0	0x0
-#define APBC_UART1	0x4
-#define APBC_GPIO	0x8
-#define APBC_PWM0	0xc
-#define APBC_PWM1	0x10
-#define APBC_PWM2	0x14
-#define APBC_PWM3	0x18
-#define APBC_SSP0	0x81c
-#define APBC_SSP1	0x820
-#define APBC_SSP2	0x84c
-#define APBC_SSP3	0x858
-#define APBC_SSP4	0x85c
-#define APBC_TWSI1	0x6c
-#define APBC_UART2	0x70
-#define APMU_SDH0	0x54
-#define APMU_SDH1	0x58
-#define APMU_USB	0x5c
-#define APMU_DISP0	0x4c
-#define APMU_CCIC0	0x50
-#define APMU_DFC	0x60
-#define MPMU_UART_PLL	0x14
+#define APBC_UART0	0x0000
+#define APBC_UART1	0x0004
+#define APBC_GPIO	0x0008
+#define APBC_PWM0	0x000c
+#define APBC_PWM1	0x0010
+#define APBC_PWM2	0x0014
+#define APBC_PWM3	0x0018
+#define APBC_RTC	0x0028
+#define APBC_TWSI0	0x002c
+#define APBC_KPC	0x0030
+#define APBC_TWSI1	0x006c
+#define APBC_UART2	0x0070
+#define APBC_SSP0	0x081c
+#define APBC_SSP1	0x0820
+#define APBC_SSP2	0x084c
+#define APBC_SSP3	0x0858
+#define APBC_SSP4	0x085c
+
+#define	APBC_UART1_CLK_RST	0x0000	/*UART1 Clock/Reset Control*/
+#define	APBC_UART2_CLK_RST	0x0004	/*UART2 Clock/Reset Control*/
+#define	APBC_GPIO_CLK_RST	0x0008	/*GPIO Clock/Reset Control*/
+#define	APBC_PWM1_CLK_RST	0x000C	/*PWM1 Clock/Reset Control*/
+#define	APBC_PWM2_CLK_RST	0x0010	/*PWM2 Clock/Reset Control*/
+#define	APBC_PWM3_CLK_RST	0x0014	/*PWM3 Clock/Reset Control*/
+#define	APBC_PWM4_CLK_RST	0x0018	/*PWM4 Clock/Reset Control*/
+#define	APBC_RTC_CLK_RST	0x0028	/*RTC Clock/Reset Control*/
+#define	APBC_TWSI0_CLK_RST	0x002C	/*TWSI0 Clock/Reset Control*/
+#define	APBC_KPC_CLK_RST	0x0030	/*Keypad Controller Clock/Reset
+					  Control*/
+#define	APBC_TIMERS_CLK_RST	0x0034	/*Timers Clock/Reset Control*/
+#define	APBC_AIB_CLK_RST	0x003C	/*AIB Clock/Reset Control*/
+#define	APBC_SW_JTAG_CLK_RST	0x0040	/*Software emulated JTAG
+					  Clock/Reset Control*/
+#define	APBC_ONEWIRE_CLK_RST	0x0048	/*OneWire Clock/Reset
+					  Control*/
+#define	APBC_PWR_TWSI_CLK_RST	0x006C	/*PWR_TWSI Clock/Reset
+					  Control*/
+#define	APBC_UART3_CLK_RST	0x0070	/*UART3 Clock/Reset Control*/
+#define	APBC_AC97_CLK_RST	0x0084	/*AC97 Clock/Reset Control*/
+
+#define	APBC_SSP0_CLK_RST	0x081C	/*SSP1 Clock/Reset Control*/
+#define	APBC_SSP1_CLK_RST	0x0820	/*SSP2 Clock/Reset Control*/
+#define	APBC_SSP2_CLK_RST	0x084C	/*SSP3 Clock/Reset Control*/
+#define	APBC_SSP3_CLK_RST	0x0858	/*SSP4 Clock/Reset Control*/
+#define	APBC_SSP4_CLK_RST	0x085C	/*SSP5 Clock/Reset Control*/
+
+#define MPMU_UART_PLL	0x0014
+
+#define APMU_CCIC_GATE	0x0028
+#define APMU_IRE	0x0048
+#define APMU_DISP0	0x004c
+#define APMU_CCIC0	0x0050
+#define APMU_SDH0	0x0054
+#define APMU_SDH1	0x0058
+#define APMU_USB	0x005c
+#define APMU_DFC	0x0060
+#define APMU_DMA	0x0064
+#define APMU_GEU	0x0068
+#define APMU_BUS	0x006c
+#define APMU_WAKE_CLR	0x007c
+#define APMU_CCIC_DBG	0x0088
+#define APMU_GC		0x00cc
+#define APMU_GC_PD	0x00d0
+#define APMU_SMC	0x00d4
+#define APMU_SDH2	0x00e0
+#define APMU_SDH3	0x00e4
+#define APMU_CF         0x00f0
+#define APMU_ICR	0x00f8
+#define	APMU_ETH	0x00fc
+
+#define APMU_PCR		0x0000
+#define APMU_CCR		0x0004
+#define APMU_CCSR		0x000c
+#define APMU_FC_TIMER		0x0010
+#define APMU_CP_IDLE_CFG	0x0014	/*Not listed in PXA16X
+					  Document*/
+#define APMU_IDLE_CFG		0x0018
+#define APMU_LCD_CLK_RES_CTRL	0x004c
+#define APMU_CCIC_CLK_RES_CTRL	0x0050
+#define APMU_SDH0_CLK_RES_CTRL	0x0054	/*SD1*/
+#define APMU_SDH1_CLK_RES_CTRL	0x0058	/*SD2*/
+#define APMU_SDH2_CLK_RES_CTRL	0x00e0	/*SD3*/
+#define APMU_SDH3_CLK_RES_CTRL	0x00e4	/*SD4*/
+#define APMU_USB_CLK_RES_CTRL	0x005c
+#define APMU_NFC_CLK_RES_CTRL	0x0060	/*NAND Flash Controller 
+					  Clock/Reset*/
+#define APMU_DMA_CLK_RES_CTRL	0x0064	/*DMA Clock/Reset Control*/
+#define APMU_BUS_CLK_RES_CTRL	0x006c	/*Bus Clock/Reste Control*/
+#define APMU_WAKE_CLK		0x007c	/*Wake Clear*/
+#define APMU_PWR_STBL_TIMER	0x0084	/*Not listed in PXA16X
+					  Document*/
+#define APMU_SRAM_PWR_DWN	0x008c	/*Not listed in PXA16X
+					  Document*/
+#define APMU_CORE_STATUS	0x0090	/*Core Status*/
+#define APMU_RES_FRM_SLP_CLR	0x0094	/*Resume from Sleep clear*/
+#define APMU_IMR		0x0098	/*PMU Interrupt Mask*/
+#define APMU_IRWC		0x009c	/*Interrupt RD/WR Clear*/
+#define APMU_ISR		0x00a0	/*Interrupt Status*/
+#define APMU_DX8_CLK_RES_CTRL	0x00a4	/*Not listed in PXA16X
+					  Document*/
+#define APMU_DTC_CLK_RES_CTRL	0x00ac	/*Not listed in PXA16X
+                                          Document*/
+#define APMU_MC_HW_SLP_TYPE	0x00b0	/*Memory Controller Hardware
+					  Sleep Type*/
+#define APMU_MC_SLP_REQ		0x00b4	/*Memory Controller Sleep
+					  Request*/
+#define APMU_MC_SW_SLP_TYPE	0x00c0	/*Memory Controller Software
+                                          Sleep Type*/
+#define APMU_PLL_SEL_STATUS	0x00c4	/*PLL Clock select status*/
+#define	APMU_SYNC_MODE_BYPASS	0x00c8	/*Sync Mode Bypass*/
+#define APMU_GC_CLK_RES_CTRL	0x00cc	/*GC300 2D Graphics Controller
+					  Clock/Reset control*/
+#define APMU_SMC_CLK_RES_CTRL	0x00d4	/*Static Memory controller
+					  Clock/Reset control*/
+#define APMU_XD_CLK_RES_CTRL	0x00dc	/*XD Controller clock/reset
+					  control*/
+#define APMU_CF_CLK_RES_CTRL	0x00f0	/*Compact Flash controller
+					  clock/reset control*/
+#define APMU_MSP_CLK_RES_CTRL	0x00f4	/*Memory Stick Pro clock/reset
+					  control*/
+#define APMU_CMU_CLK_RES_CTRL	0x00f8	/*CMU clock/reset control*/
+#define APMU_MFU_CLK_RES_CTRL	0x00fc	/*FE(Fast Ethernet) 
+					  clock/reset control*/
+#define APMU_PCIe_CLK_RES_CTRL	0x0100	/*PCIe clock/reset control*/
+#define APMU_EPD_CLK_RES_CTRL	0x0104	/*EPD clock/reset control*/
+
+#define APMU_GC_156M            0x0
+#define APMU_GC_312M            0x40
+#define APMU_GC_PLL2            0x80
+#define APMU_GC_PLL2_DIV2       0xc0
+#define APMU_GC_624M            0xc0 /* added according to Aspen SW spec v2.8*/
 
 static DEFINE_SPINLOCK(clk_lock);
 
@@ -59,15 +166,122 @@
 	{.num = 8125, .den = 1536},	/*14.745MHZ */
 };
 
+#if 0
+struct gc_rate_table {
+	unsigned long   rate;
+	unsigned int    flag;
+};
+
+static struct gc_rate_table gc300_rates [] = {
+	/* put highest rate at the top of the table */
+	{
+		.rate	=	624000000,
+		.flag	=	APMU_GC_624M,
+	},
+	{
+		.rate	=	312000000,
+		.flag	=	APMU_GC_312M,
+	},
+	{
+		.rate	=	156000000,
+		.flag	=	APMU_GC_156M,
+	},
+};
+
+static int gc_lookaround_rate(int target_rate, u32 *flag)
+{
+	int i;
+
+	for (i=0; i<ARRAY_SIZE(gc300_rates); i++) {
+		if (target_rate >= gc300_rates[i].rate)
+			break;
+        }
+	if (i==ARRAY_SIZE(gc300_rates)) i--;
+	*flag = gc300_rates[i].flag;
+	return gc300_rates[i].rate;
+}
+
+static void gc300_clk_enable(struct clk *clk)
+{
+	u32 tmp = __raw_readl(clk->clk_rst), flag;
+
+	/* reset gc clock */
+	__raw_writel(tmp & ~0x07, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+	udelay(1);
+
+	/* select GC clock source */
+	gc_lookaround_rate(clk->rate, &flag);
+	tmp &= ~0xc0;
+	tmp |= flag;
+	__raw_writel(tmp, clk->clk_rst);
+
+	/* enable GC CLK EN */
+	__raw_writel(tmp | 0x10, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+
+	/* enable GC HCLK EN */
+	__raw_writel(tmp | 0x08, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+
+	/* enable GC ACLK EN */
+	__raw_writel(tmp | 0x20, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+
+	/* reset GC */
+	__raw_writel(tmp & ~0x07, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+
+	/* pull GC out of reset */
+	__raw_writel(tmp | 0x2, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+
+	/* delay 48 cycles */
+	udelay(1);
+
+	/* pull GC AXI/AHB out of reset */
+	__raw_writel(tmp | 0x5, clk->clk_rst);
+	tmp = __raw_readl(clk->clk_rst);
+}
+
+static void gc300_clk_disable(struct clk *clk)
+{
+	__raw_writel(0, clk->clk_rst);
+}
+
+static int gc300_clk_setrate(struct clk *clk, unsigned long target_rate)
+{
+	u32 flag;
+
+	clk->rate = gc_lookaround_rate(target_rate, &flag);
+
+	return 0;
+}
+
+static unsigned long gc300_clk_getrate(struct clk *clk)
+{
+	return clk->rate;
+}
+
+struct clkops gc300_clk_ops = {
+	.enable		= gc300_clk_enable,
+	.disable	= gc300_clk_disable,
+	.setrate	= gc300_clk_setrate,
+	.getrate	= gc300_clk_getrate,
+};
+#endif
+
 static const char *uart_parent[] = {"pll1_3_16", "uart_pll"};
 static const char *ssp_parent[] = {"pll1_96", "pll1_48", "pll1_24", "pll1_12"};
 static const char *sdh_parent[] = {"pll1_12", "pll1_13"};
 static const char *disp_parent[] = {"pll1_2", "pll1_12"};
 static const char *ccic_parent[] = {"pll1_2", "pll1_12"};
 static const char *ccic_phy_parent[] = {"pll1_6", "pll1_12"};
+static const char *usb_sph_otg_parent[] = {"pll1_2_1_5"};
 
 void __init pxa168_clk_init(void)
 {
+#if !defined(CONFIG_MACH_GPLUGD)
 	struct clk *clk;
 	struct clk *uart_pll;
 	void __iomem *mpmu_base;
@@ -343,4 +557,352 @@ void __init pxa168_clk_init(void)
 	clk = mmp_clk_register_apmu("ccic0_sphy", "ccic0_sphy_div",
 				apmu_base + APMU_CCIC0, 0x300, &clk_lock);
 	clk_register_clkdev(clk, "sphyclk", "mmp-ccic.0");
+#else
+	struct clk *clk;
+	struct clk *uart_pll;
+	void __iomem *mpmu_base;
+	void __iomem *apmu_base;
+	void __iomem *apbc_base;
+
+	mpmu_base = ioremap(APB_PHYS_BASE + 0x50000, SZ_4K);
+	if (mpmu_base == NULL) {
+		pr_err("error to ioremap MPMU base\n");
+		return;
+	}
+
+	apmu_base = ioremap(AXI_PHYS_BASE + 0x82800, SZ_4K);
+	if (apmu_base == NULL) {
+		pr_err("error to ioremap APMU base\n");
+		return;
+	}
+
+	apbc_base = ioremap(APB_PHYS_BASE + 0x15000, SZ_4K);
+	if (apbc_base == NULL) {
+		pr_err("error to ioremap APBC base\n");
+		return;
+	}
+
+	clk = clk_register_fixed_rate(NULL, "clk32", NULL, CLK_IS_ROOT, 3200);
+	clk_register_clkdev(clk, "clk32", NULL);
+
+	clk = clk_register_fixed_rate(NULL, "vctcxo", NULL, CLK_IS_ROOT,
+				26000000);
+	clk_register_clkdev(clk, "vctcxo", NULL);
+
+	clk = clk_register_fixed_rate(NULL, "pll1", NULL, CLK_IS_ROOT,
+				624000000);
+	clk_register_clkdev(clk, "pll1", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_2", "pll1",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_2", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_4", "pll1_2",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_4", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_8", "pll1_4",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_8", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_16", "pll1_8",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_16", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_6", "pll1_2",
+				CLK_SET_RATE_PARENT, 1, 3);
+	clk_register_clkdev(clk, "pll1_6", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_12", "pll1_6",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_12", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_24", "pll1_12",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_24", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_48", "pll1_24",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_48", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_96", "pll1_48",
+				CLK_SET_RATE_PARENT, 1, 2);
+	clk_register_clkdev(clk, "pll1_96", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_13", "pll1",
+				CLK_SET_RATE_PARENT, 1, 13);
+	clk_register_clkdev(clk, "pll1_13", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_13_1_5", "pll1",
+				CLK_SET_RATE_PARENT, 2, 3);
+	clk_register_clkdev(clk, "pll1_13_1_5", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_2_1_5", "pll1",
+				CLK_SET_RATE_PARENT, 2, 3);
+	clk_register_clkdev(clk, "pll1_2_1_5", NULL);
+
+	clk = clk_register_fixed_factor(NULL, "pll1_3_16", "pll1",
+				CLK_SET_RATE_PARENT, 3, 16);
+	clk_register_clkdev(clk, "pll1_3_16", NULL);
+
+	uart_pll = mmp_clk_register_factor("uart_pll", "pll1_4", 0,
+				mpmu_base + MPMU_UART_PLL,
+				&uart_factor_masks, uart_factor_tbl,
+				ARRAY_SIZE(uart_factor_tbl));
+	clk_set_rate(uart_pll, 14745600);
+	clk_register_clkdev(uart_pll, "uart_pll", NULL);
+
+	clk = mmp_clk_register_apbc("twsi0", "pll1_13_1_5",
+				apbc_base + APBC_TWSI0, 0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa2xx-i2c.0");
+
+	clk = mmp_clk_register_apbc("twsi1", "pll1_13_1_5",
+				apbc_base + APBC_TWSI1, 0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa2xx-i2c.1");
+
+	clk = mmp_clk_register_apbc("gpio", "vctcxo",
+				apbc_base + APBC_GPIO, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa-gpio");
+
+	clk = mmp_clk_register_apbc("kpc", "clk32",
+				apbc_base + APBC_KPC, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa27x-keypad");
+
+	clk = mmp_clk_register_apbc("rtc", "clk32",
+				apbc_base + APBC_RTC, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "sa1100-rtc");
+
+	clk = mmp_clk_register_apbc("pwm0", "pll1_48",
+				apbc_base + APBC_PWM0, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-pwm.0");
+
+	clk = mmp_clk_register_apbc("pwm1", "pll1_48",
+				apbc_base + APBC_PWM1, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-pwm.1");
+
+	clk = mmp_clk_register_apbc("pwm2", "pll1_48",
+				apbc_base + APBC_PWM2, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-pwm.2");
+
+	clk = mmp_clk_register_apbc("pwm3", "pll1_48",
+				apbc_base + APBC_PWM3, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-pwm.3");
+
+	clk = clk_register_mux(NULL, "uart0_mux", uart_parent,
+				ARRAY_SIZE(uart_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_UART0, 4, 3, 0, &clk_lock);
+	clk_set_parent(clk, uart_pll);
+	clk_register_clkdev(clk, "uart_mux.0", NULL);
+
+	clk = mmp_clk_register_apbc("uart0", "uart0_mux",
+				apbc_base + APBC_UART0, 10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa2xx-uart.0");
+
+	clk = clk_register_mux(NULL, "uart1_mux", uart_parent,
+				ARRAY_SIZE(uart_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_UART1, 4, 3, 0, &clk_lock);
+	clk_set_parent(clk, uart_pll);
+	clk_register_clkdev(clk, "uart_mux.1", NULL);
+
+	clk = mmp_clk_register_apbc("uart1", "uart1_mux",
+				apbc_base + APBC_UART1,	10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa2xx-uart.1");
+
+	clk = clk_register_mux(NULL, "uart2_mux", uart_parent,
+				ARRAY_SIZE(uart_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_UART2, 4, 3, 0, &clk_lock);
+	clk_set_parent(clk, uart_pll);
+	clk_register_clkdev(clk, "uart_mux.2", NULL);
+
+	clk = mmp_clk_register_apbc("uart2", "uart2_mux",
+				apbc_base + APBC_UART2,	10, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa2xx-uart.2");
+
+	clk = clk_register_mux(NULL, "ssp0_mux", ssp_parent,
+				ARRAY_SIZE(ssp_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_SSP0, 4, 3, 0, &clk_lock);
+	clk_register_clkdev(clk, "ssp_mux.0", NULL);
+
+	clk = mmp_clk_register_apbc("ssp0", "ssp0_mux", apbc_base + APBC_SSP0,
+				0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-ssp.0");
+
+	clk = clk_register_mux(NULL, "ssp1_mux", ssp_parent,
+				ARRAY_SIZE(ssp_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_SSP1, 4, 3, 0, &clk_lock);
+	clk_register_clkdev(clk, "ssp_mux.1", NULL);
+
+	clk = mmp_clk_register_apbc("ssp1", "ssp1_mux", apbc_base + APBC_SSP1,
+				0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-ssp.1");
+
+	clk = clk_register_mux(NULL, "ssp2_mux", ssp_parent,
+				ARRAY_SIZE(ssp_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_SSP2, 4, 3, 0, &clk_lock);
+	clk_register_clkdev(clk, "ssp_mux.2", NULL);
+
+	clk = mmp_clk_register_apbc("ssp2", "ssp2_mux", apbc_base + APBC_SSP2,
+				0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-ssp.2");
+
+	clk = clk_register_mux(NULL, "ssp3_mux", ssp_parent,
+				ARRAY_SIZE(ssp_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_SSP3, 4, 3, 0, &clk_lock);
+	clk_register_clkdev(clk, "ssp_mux.3", NULL);
+
+	clk = mmp_clk_register_apbc("ssp3", "ssp3_mux", apbc_base + APBC_SSP3,
+				0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-ssp.3");
+
+	clk = clk_register_mux(NULL, "ssp4_mux", ssp_parent,
+				ARRAY_SIZE(ssp_parent), CLK_SET_RATE_PARENT,
+				apbc_base + APBC_SSP4, 4, 3, 0, &clk_lock);
+	clk_register_clkdev(clk, "ssp_mux.4", NULL);
+
+	clk = mmp_clk_register_apbc("ssp4", "ssp4_mux", apbc_base + APBC_SSP4,
+				0, 0, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa168-ssp.4");
+
+	clk = mmp_clk_register_apmu("dfc", "pll1_4", apmu_base + APMU_DFC,
+				0x19b, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa3xx-nand.0");
+
+	clk = clk_register_mux(NULL, "PXA-SDHCLK", sdh_parent,
+				ARRAY_SIZE(sdh_parent), CLK_SET_RATE_PARENT,
+				apmu_base + APMU_SDH0, 6, 1, 0, &clk_lock);
+	clk_register_clkdev(clk, "PXA-SDHCLK", NULL);
+
+	clk = mmp_clk_register_apmu("sdh0", "PXA-SDHCLK", apmu_base + APMU_SDH0,
+				0x1b, &clk_lock);
+	clk_register_clkdev(clk, NULL, "sdhci-pxav2.0");
+
+	clk = mmp_clk_register_apmu("sdh1", "PXA-SDHCLK", apmu_base + APMU_SDH1,
+				0x1b, &clk_lock);
+	clk_register_clkdev(clk, NULL, "sdhci-pxav2.1");
+
+	clk = mmp_clk_register_apmu("sdh2", "PXA-SDHCLK", apmu_base + APMU_SDH2,
+				0x1b, &clk_lock);
+	clk_register_clkdev(clk, NULL, "sdhci-pxav2.2");
+
+	clk = mmp_clk_register_apmu("sdh3", "PXA-SDHCLK", apmu_base + APMU_SDH3,
+				0x1b, &clk_lock);
+	clk_register_clkdev(clk, NULL, "sdhci-pxav2.3");
+
+#if 0
+	clk = mmp_clk_register_apmu("usb", "usb_pll", apmu_base + APMU_USB,
+				0x9, &clk_lock);
+	clk_register_clkdev(clk, "usb_clk", NULL);
+
+	clk = mmp_clk_register_apmu("sph", "usb_pll", apmu_base + APMU_USB,
+				0x12, &clk_lock);
+	clk_register_clkdev(clk, "sph_clk", NULL);
+#endif
+
+	clk = mmp_clk_register_apmu("sph", "U2HCLK", apmu_base + APMU_USB,
+				0x12, &clk_lock);
+	clk_register_clkdev(clk, "U2HCLK", NULL);
+
+	clk = mmp_clk_register_apmu("usb", "U2OCLK", apmu_base + APMU_USB,
+				0x09, &clk_lock);
+	clk_register_clkdev(clk, "U2OCLK", NULL);
+
+#if 0
+	/*Check USB clock start*/
+	/*clk = mmp_clk_register_apmu("u2h", "PXA168-U2HCLK", apmu_base + APMU_USB,*/
+	clk = clk_register_mux(NULL, "PXA168-U2HCLK", usb_sph_otg_parent/*"pll1_2_1_5"*/,
+				ARRAY_SIZE(usb_sph_otg_parent)/*1*/, CLK_SET_RATE_PARENT,
+				apmu_base + APMU_USB, 0, 5, 0, &clk_lock);
+	clk_register_clkdev(clk, "PXA168-U2HCLK", NULL);
+
+	clk = mmp_clk_register_apmu("pxa-sph", "PXA168-U2HCLK", apmu_base + APMU_USB,
+				0x12, &clk_lock);
+	clk_register_clkdev(clk, "pxa-sph", NULL);
+
+	clk = clk_register_mux(NULL, "PXA168-U2OCLK", usb_sph_otg_parent/*"pll1_2_1_5"*/,
+				ARRAY_SIZE(usb_sph_otg_parent)/*1*/, CLK_SET_RATE_PARENT,
+				apmu_base + APMU_USB, 0, 5, 0, &clk_lock);
+	clk_register_clkdev(clk, "PXA168-U2OCLK", NULL);
+
+	clk = mmp_clk_register_apmu("mv-otg", "PXA168-U2OCLK", apmu_base + APMU_USB,
+				0x09, &clk_lock);
+	clk_register_clkdev(clk, NULL, "mv-otg");
+#if 1
+	clk = clk_register_mux(NULL, "PXA168-U2OEHCICLK", usb_sph_otg_parent/*"pll1_2_1_5"*/,
+				ARRAY_SIZE(usb_sph_otg_parent)/*1*/, CLK_SET_RATE_PARENT,
+				apmu_base + APMU_USB, 0, 5, 0, &clk_lock);
+	clk_register_clkdev(clk, "PXA168-U2OCLK", NULL);
+
+	clk = mmp_clk_register_apmu("pxa-sph.0", "PXA168-U2OEHCICLK", apmu_base + APMU_USB,
+				0x09, &clk_lock);
+	clk_register_clkdev(clk, NULL, "pxa-sph.0");
+
+	/*clk = mmp_clk_register_apmu("PXA168-U2OEHCICLK", "PXA168-U2HCLK", apmu_base + APMU_USB,
+				0x12, &clk_lock);
+	clk_register_clkdev(clk, "PXA168-U2OEHCICLK", NULL);*/
+
+	clk = clk_register_mux(NULL, "PXA168-U2OGADGETCLK", usb_sph_otg_parent/*"pll1_2_1_5"*/,
+				ARRAY_SIZE(usb_sph_otg_parent)/*1*/, CLK_SET_RATE_PARENT,
+				apmu_base + APMU_USB, 0, 5, 0, &clk_lock);
+	clk_register_clkdev(clk, "PXA168-U2OGADGETCLK", NULL);
+	clk = mmp_clk_register_apmu("mv-udc", "PXA168-U2OGADGETCLK", apmu_base + APMU_USB,
+				0x09, &clk_lock);
+	clk_register_clkdev(clk, NULL, "mv-udc");
+	/*clk_register_clkdev(clk, "PXA168-U2OGADGETCLK", NULL);*/
+#endif
+
+		/*Check USB clock End*/
+#endif
+
+	/*clk = clk_register_mux(NULL, "disp0_mux", disp_parent,*/
+	clk = clk_register_mux(NULL, "LCDCLK", disp_parent,
+				ARRAY_SIZE(disp_parent), CLK_SET_RATE_PARENT,
+				apmu_base + APMU_DISP0, 0, 7, 0, &clk_lock);
+				/*apmu_base + APMU_DISP0, 6, 1, 0, &clk_lock);*/
+	/*clk_register_clkdev(clk, "disp_mux.0", NULL);*/
+	clk_register_clkdev(clk, "LCDCLK", NULL);
+
+	clk = mmp_clk_register_apmu("disp0", "LCDCLK",
+				apmu_base + APMU_DISP0, 0x7f, &clk_lock);
+				/*apmu_base + APMU_DISP0, 0x1b, &clk_lock);*/
+	clk_register_clkdev(clk, NULL, "pxa168-fb");
+
+	clk = clk_register_mux(NULL, "ccic0_mux", ccic_parent,
+				ARRAY_SIZE(ccic_parent), CLK_SET_RATE_PARENT,
+				apmu_base + APMU_CCIC0, 6, 1, 0, &clk_lock);
+	clk_register_clkdev(clk, "ccic_mux.0", NULL);
+
+	clk = mmp_clk_register_apmu("ccic0", "ccic0_mux",
+				apmu_base + APMU_CCIC0, 0x1b, &clk_lock);
+	clk_register_clkdev(clk, "fnclk", "mmp-ccic.0");
+
+	clk = clk_register_mux(NULL, "ccic0_phy_mux", ccic_phy_parent,
+				ARRAY_SIZE(ccic_phy_parent),
+				CLK_SET_RATE_PARENT, apmu_base + APMU_CCIC0,
+				7, 1, 0, &clk_lock);
+	clk_register_clkdev(clk, "ccic_phy_mux.0", NULL);
+
+	clk = mmp_clk_register_apmu("ccic0_phy", "ccic0_phy_mux",
+				apmu_base + APMU_CCIC0, 0x24, &clk_lock);
+	clk_register_clkdev(clk, "phyclk", "mmp-ccic.0");
+
+	clk = clk_register_divider(NULL, "ccic0_sphy_div", "ccic0_mux",
+				CLK_SET_RATE_PARENT, apmu_base + APMU_CCIC0,
+				10, 5, 0, &clk_lock);
+	clk_register_clkdev(clk, "sphyclk_div", NULL);
+
+	clk = mmp_clk_register_apmu("ccic0_sphy", "ccic0_sphy_div",
+				apmu_base + APMU_CCIC0, 0x300, &clk_lock);
+	clk_register_clkdev(clk, "sphyclk", "mmp-ccic.0");
+
+#if 0
+	clk = clk_register_mux(NULL, "GCCLK", "pll1_16",
+				1, CLK_SET_RATE_PARENT, apmu_base + APMU_GC,
+				0, 8, 0, &clk_lock);
+	/*clk->ops = gc300_clk_ops;*/
+	clk_register_clkdev(clk, "GCCLK", NULL);
+#endif
+	clk = mmp_clk_register_apmu("pxa168-eth", "MFUCLK", apmu_base + APMU_ETH,
+				0x9, &clk_lock);
+	clk_register_clkdev(clk, "MFUCLK", NULL);
+#endif
 }
diff --git a/drivers/i2c/busses/i2c-pxa.c b/drivers/i2c/busses/i2c-pxa.c
index ea6d45d..e525151 100644
--- a/drivers/i2c/busses/i2c-pxa.c
+++ b/drivers/i2c/busses/i2c-pxa.c
@@ -1160,7 +1160,8 @@ static int i2c_pxa_probe(struct platform_device *dev)
 		i2c->adap.class = plat->class;
 	}
 
-	clk_enable(i2c->clk);
+	/*clk_enable(i2c->clk);*/
+	clk_prepare_enable(i2c->clk);
 
 	if (i2c->use_pio) {
 		i2c->adap.algo = &i2c_pxa_pio_algorithm;
@@ -1202,7 +1203,8 @@ static int i2c_pxa_probe(struct platform_device *dev)
 	if (!i2c->use_pio)
 		free_irq(irq, i2c);
 ereqirq:
-	clk_disable(i2c->clk);
+	/*clk_disable(i2c->clk);*/
+	clk_disable_unprepare(i2c->clk);
 	iounmap(i2c->reg_base);
 eremap:
 	clk_put(i2c->clk);
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 9ab8f8d..d6fd06b 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -219,10 +219,11 @@ config MMC_SDHCI_PXAV2
 	depends on CLKDEV_LOOKUP
 	select MMC_SDHCI
 	select MMC_SDHCI_PLTFM
-	default CPU_PXA910
+	select MMC_SDHCI_IO_ACCESSORS
+	default y if (CPU_PXA910 || CPU_PXA168)
 	help
 	  This selects the Marvell(R) PXAV2 SD Host Controller.
-	  If you have a PXA9XX platform with SD Host Controller
+	  If you have a PXAXXX platform with SD Host Controller
 	  and a card slot, say Y or M here.
 
 	  If unsure, say N.
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index 2ea429c..346d384 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -1002,6 +1002,9 @@ static void sdhci_send_command(struct sdhci_host *host, struct mmc_command *cmd)
 		mdelay(1);
 	}
 
+	if (host->ops->platform_specific_completion)
+		host->ops->platform_specific_completion(host);
+
 	mod_timer(&host->timer, jiffies + 10 * HZ);
 
 	host->cmd = cmd;
@@ -1162,6 +1165,16 @@ static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 		 * Mode.
 		 */
 		if (host->clk_mul) {
+			u16 ctrl;
+
+			/*
+			 * We need to figure out whether the Host Driver needs
+			 * to select Programmable Clock Mode, or the value can
+			 * be set automatically by the Host Controller based on
+			 * the Preset Value registers.
+			 */
+			ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);
+			if (!(ctrl & SDHCI_CTRL_PRESET_VAL_ENABLE)) {
 			for (div = 1; div <= 1024; div++) {
 				if ((host->max_clk * host->clk_mul / div)
 					<= clock)
@@ -1175,6 +1188,7 @@ static void sdhci_set_clock(struct sdhci_host *host, unsigned int clock)
 			real_div = div;
 			clk_mul = host->clk_mul;
 			div--;
+			}
 		} else {
 			/* Version 3.00 divisors must be a multiple of 2. */
 			if (host->max_clk <= clock)
diff --git a/drivers/mmc/host/sdhci.h b/drivers/mmc/host/sdhci.h
index 379e09d..08e60e0 100644
--- a/drivers/mmc/host/sdhci.h
+++ b/drivers/mmc/host/sdhci.h
@@ -292,6 +292,7 @@ struct sdhci_ops {
 	void	(*hw_reset)(struct sdhci_host *host);
 	void	(*platform_suspend)(struct sdhci_host *host);
 	void	(*platform_resume)(struct sdhci_host *host);
+	void	(*platform_specific_completion)(struct sdhci_host *host);
 	void    (*adma_workaround)(struct sdhci_host *host, u32 intmask);
 	void	(*platform_init)(struct sdhci_host *host);
 };
diff --git a/drivers/net/ethernet/marvell/pxa168_eth.c b/drivers/net/ethernet/marvell/pxa168_eth.c
index 1c8af8b..d66e10c 100644
--- a/drivers/net/ethernet/marvell/pxa168_eth.c
+++ b/drivers/net/ethernet/marvell/pxa168_eth.c
@@ -1482,7 +1482,8 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 			DRIVER_NAME);
 		return -ENODEV;
 	}
-	clk_enable(clk);
+	/*clk_enable(clk);*/
+	clk_prepare_enable(clk);
 
 	dev = alloc_etherdev(sizeof(struct pxa168_eth_private));
 	if (!dev) {
@@ -1514,10 +1515,18 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 
 	INIT_WORK(&pep->tx_timeout_task, pxa168_eth_tx_timeout_task);
 
-	printk(KERN_INFO "%s:Using random mac address\n", DRIVER_NAME);
-	eth_hw_addr_random(dev);
-
 	pep->pd = pdev->dev.platform_data;
+
+	if (pep->pd->init)
+		pep->pd->init();
+
+	if (is_valid_ether_addr(pep->pd->mac_addr))
+		memcpy(dev->dev_addr, pep->pd->mac_addr, 6);
+	else {
+		printk(KERN_INFO "%s:Using random mac address\n", DRIVER_NAME);
+		eth_hw_addr_random(dev);
+	}
+
 	pep->rx_ring_size = NUM_RX_DESCS;
 	if (pep->pd->rx_queue_size)
 		pep->rx_ring_size = pep->pd->rx_queue_size;
@@ -1572,7 +1581,8 @@ static int pxa168_eth_probe(struct platform_device *pdev)
 err_netdev:
 	free_netdev(dev);
 err_clk:
-	clk_disable(clk);
+	/*clk_disable(clk);*/
+	clk_disable_unprepare(clk);
 	clk_put(clk);
 	return err;
 }
diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index b983813..c6d0b63 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -1044,7 +1044,7 @@ config RTC_DRV_GENERIC
 
 config RTC_DRV_PXA
        tristate "PXA27x/PXA3xx"
-       depends on ARCH_PXA
+       depends on (ARCH_PXA || ARCH_MMP)
        help
          If you say Y here you will get access to the real time clock
          built into your PXA27x or PXA3xx CPU.
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 92a9345..b155c02 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -329,8 +329,8 @@ config SPI_PXA2XX_DMA
 
 config SPI_PXA2XX
 	tristate "PXA2xx SSP SPI master"
-	depends on (ARCH_PXA || PCI || ACPI) && GENERIC_HARDIRQS
-	select PXA_SSP if ARCH_PXA
+	depends on (ARCH_PXA || ARCH_MMP || PCI || ACPI) && GENERIC_HARDIRQS
+	select PXA_SSP if (ARCH_PXA || ARCH_MMP)
 	help
 	  This enables using a PXA2xx or Sodaville SSP port as a SPI master
 	  controller. The driver can be configured to use any SSP port and
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index 2e937bd..2d9516b 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -1879,12 +1879,15 @@ config FB_68328
 	  Say Y here if you want to support the built-in frame buffer of
 	  the Motorola 68328 CPU family.
 
+source "drivers/video/hdmi/Kconfig"
 config FB_PXA168
 	tristate "PXA168/910 LCD framebuffer support"
 	depends on FB && (CPU_PXA168 || CPU_PXA910)
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
+	select TDA9981
+	select TDA9950
 	---help---
 	  Frame buffer driver for the built-in LCD controller in the Marvell
 	  MMP processor.
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index e8bae8d..c42bb09 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -105,7 +105,7 @@ obj-$(CONFIG_FB_GBE)              += gbefb.o
 obj-$(CONFIG_FB_CIRRUS)		  += cirrusfb.o
 obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o
 obj-$(CONFIG_FB_PXA)		  += pxafb.o
-obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o
+obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o pxa168fb_ovly.o hdmi/
 obj-$(CONFIG_PXA3XX_GCU)	  += pxa3xx-gcu.o
 obj-$(CONFIG_MMP_DISP)           += mmp/
 obj-$(CONFIG_FB_W100)		  += w100fb.o
diff --git a/drivers/video/hdmi/Kconfig b/drivers/video/hdmi/Kconfig
new file mode 100644
index 0000000..e6aeb5f
--- /dev/null
+++ b/drivers/video/hdmi/Kconfig
@@ -0,0 +1,7 @@
+config TDA9981
+	tristate
+	default n
+
+config TDA9950
+	tristate
+	default n
diff --git a/drivers/video/hdmi/MakeModules b/drivers/video/hdmi/MakeModules
new file mode 100644
index 0000000..2fdc1db
--- /dev/null
+++ b/drivers/video/hdmi/MakeModules
@@ -0,0 +1,55 @@
+PACKAGE_NAME:=hdmi
+
+RULES:=compile
+
+ARCH:=arm
+CROSS_COMPILE:=arm-none-linux-gnueabi-
+# CROSS_COMPILE:=arm-marvell-linux-gnueabi-
+VARS:= ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)
+# VARS:= V=1 ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)
+
+# module to be put in driver/video/hdmi
+
+LINUX_DIR=../../..
+LINUXKERNEL_SRC=$(LINUX_DIR)
+
+all: $(RULES)
+
+compile:
+	@echo "\t-----> $(PACKAGE_NAME):$@"
+	@rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+# 	@mv tda998x_version.h temp && cat temp | awk '$$2~"PATCHLEVEL" {$$3=$$3+1};{print};' >tda998x_version.h && rm temp
+	$(MAKE) -C $(LINUXKERNEL_SRC) M=`pwd` $(VARS) modules
+#	@touch $@
+
+uptx:
+	adb shell rm hdmitx.ko
+	adb shell rmmod hdmitx
+	adb push hdmitx.ko hdmitx.ko
+	adb shell insmod hdmitx.ko verbose=1
+#	adb shell insmod hdmitx.ko
+
+upcec:
+	adb shell rm hdmicec.ko
+	adb shell rmmod hdmicec
+	adb push hdmicec.ko hdmicec.ko
+	adb shell insmod hdmicec.ko verbose=1 device=4
+
+strip:
+	strip -g -I elf32-little hdmitx.ko -o hdmitx_striped.ko
+	strip -g -I elf32-little hdmicec.ko -o hdmicec_striped.ko
+
+clean:
+	@echo "\t-----> $(PACKAGE_NAME):$@"
+	@rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.* *.symvers *.order
+	@cd comps/tmdlHdmiCEC/src && rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+	@cd comps/tmdlHdmiCEC/cfg && rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+	@cd comps/tmdlTDA9983/src && rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+	@cd comps/tmdlTDA9983/cfg && rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+	@cd comps/tmbslTDA9983/src && rm -rf *.o *.ko *.mod.c .*.cmd .tmp_versions *.c.* *.h.*
+
+	@if [ -e .compiled ]; then rm .compiled; fi
+
+# install: .install
+# .install:
+# 	cp ....
diff --git a/drivers/video/hdmi/Makefile b/drivers/video/hdmi/Makefile
new file mode 100644
index 0000000..cfc132a
--- /dev/null
+++ b/drivers/video/hdmi/Makefile
@@ -0,0 +1,202 @@
+
+
+############### select your chip + platform here ###################
+
+# TDA_TX := TDA9984
+# TDA_TX := TDA9983
+
+#HDMICEC := $(TDA9950)
+#CONFIG_TDA9981 := m
+#CONFIG_TDA9950 := m
+
+ifneq ($(CONFIG_TDA9981),)
+TDA_TX := TDA9981
+HDMITX := $(CONFIG_TDA9981)
+#HDMICEC := $(CONFIG_TDA9950)
+else ifneq ($(CONFIG_TDA19989),)
+TDA_TX  := TDA19989
+HDMITX  := $(CONFIG_TDA19989)
+HDMICEC := $(CONFIG_TDA19989)
+endif
+
+# TDA_PLATFORM := ZOOMII
+TDA_PLATFORM := OTHERS
+
+TDA_HDCP := 0
+# TDA_HDCP := TMFL_HDCP_SUPPORT
+
+####################################################################
+
+EXTRA_CFLAGS += -DFUNC_PTR=" " -DCONST_DAT="const " -DRAM_DAT=" "
+EXTRA_CFLAGS += -DTDA_NAME=$(TDA_TX)
+EXTRA_CFLAGS += -DTMFL_NO_RTOS -DIRQ
+EXTRA_CFLAGS += "-Dinit_MUTEX(sem)=sema_init(sem,1)"
+
+ifeq ($(TDA_PLATFORM),ZOOMII)
+EXTRA_CFLAGS += -DZOOMII_PATCH
+EXTRA_CFLAGS += -DTWL4030_HACK
+EXTRA_CFLAGS += -DANDROID_DSS
+EXTRA_CFLAGS += -DGUI_OVER_HDMI
+endif
+
+ifeq ($(TDA_TX),TDA19989)
+EXTRA_CFLAGS += -DTMFL_TDA19989 -DTMFL_TDA9989
+ifeq ($(TDA_HDCP),TMFL_HDCP_SUPPORT)
+EXTRA_CFLAGS += -D$(TDA_HDCP)
+else
+EXTRA_CFLAGS += -DNO_HDCP
+endif
+endif
+
+ifeq ($(TDA_TX),TDA9984)
+EXTRA_CFLAGS += -DNO_HDCP
+endif
+
+ifeq ($(TDA_TX),TDA9981)
+EXTRA_CFLAGS += -DTMFL_TDA9981_SUPPORT -DTMFL_RX_SENSE_ON
+endif
+
+########## devlib ##################################################
+
+ifeq ($(TDA_TX),TDA19989)
+TXSRC := comps/tmdlHdmiTx/src
+TXCFG := comps/tmdlHdmiTx/cfg/TDA9989
+CECSRC := comps/tmdlHdmiCEC/src
+CECCFG := comps/tmdlHdmiCEC/cfg
+endif
+
+ifeq ($(TDA_TX),TDA9984)
+TXSRC := comps/tmdlHdmiTx/src
+TXCFG := comps/tmdlHdmiTx/cfg/TDA9989
+endif
+
+ifeq ($(TDA_TX),TDA9983)
+TXSRC := comps/tmdlTDA9983/src
+TXCFG := comps/tmdlTDA9983/cfg
+endif
+
+ifeq ($(TDA_TX),TDA9981)
+TXSRC := comps/tmdlTDA9983/src
+TXCFG := comps/tmdlTDA9983/cfg
+CECSRC := comps/tmdlHdmiCEC/src
+CECCFG := comps/tmdlHdmiCEC/cfg
+endif
+
+########## board service layer #####################################
+
+ifeq ($(TDA_TX),TDA19989)
+BSL := comps/tmbslTDA9989NoHdcp/src/TDA9989n2
+endif
+
+ifeq ($(TDA_TX),TDA9984)
+BSL := comps/tmbslTDA9984NoHdcp/src
+endif
+
+ifeq ($(TDA_TX),TDA9983)
+BSL := comps/tmbslTDA9983/src
+endif
+
+ifeq ($(TDA_TX),TDA9981)
+BSL := comps/tmbslTDA9983/src
+endif
+
+####################################################################
+
+obj-$(HDMITX) += hdmitx.o
+obj-$(HDMICEC) += hdmicec.o
+
+# Linux module
+hdmitx-objs := tda998x.o
+hdmicec-objs := tda998x_cec.o
+
+# NXP comps
+ifeq ($(TDA_TX),TDA19989)
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx.o
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx_local.o
+hdmitx-objs += $(TXCFG)/tmdlHdmiTx_Linux.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_local.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_InOut.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_HDCP.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_State.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_Misc.o
+hdmitx-objs += $(BSL)/tmbslTDA9989_Edid.o
+hdmicec-objs += $(CECSRC)/tmdlHdmiCEC.o
+hdmicec-objs += $(CECSRC)/tmdlHdmiCEC_local.o
+hdmicec-objs += $(CECCFG)/tmdlHdmiCEC_Linux.o
+endif
+
+ifeq ($(TDA_TX),TDA9984)
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx.o
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx_local.o
+hdmitx-objs += $(TXCFG)/tmdlHdmiTx_Linux.o
+hdmitx-objs += $(BSL)/tmbslTDA9984_local.o 
+hdmitx-objs += $(BSL)/tmbslTDA9984_InOut.o
+hdmitx-objs += $(BSL)/tmbslTDA9984_HDCP.o
+hdmitx-objs += $(BSL)/tmbslTDA9984_State.o
+hdmitx-objs += $(BSL)/tmbslTDA9984_Misc.o
+hdmitx-objs += $(BSL)/tmbslTDA9984_Edid.o
+endif
+
+ifeq ($(TDA_TX),TDA9983)
+hdmitx-objs += $(BSL)/tmbslHdmiTx_2.o
+hdmitx-objs += $(BSL)/tmbslHdmiTx_1.o
+hdmitx-objs += $(BSL)/tmbslHdmiTx_local.o
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx.o
+hdmitx-objs += $(TXCFG)/tmdlHdmiTx_Linux.o
+endif
+
+ifeq ($(TDA_TX),TDA9981)
+hdmitx-objs += $(BSL)/tmbslHdmiTx_2.o
+hdmitx-objs += $(BSL)/tmbslHdmiTx_1.o
+hdmitx-objs += $(BSL)/tmbslHdmiTx_local.o
+hdmitx-objs += $(TXSRC)/tmdlHdmiTx.o
+hdmitx-objs += $(TXCFG)/tmdlHdmiTx_Linux.o
+hdmicec-objs += $(CECSRC)/tmdlHdmiCEC.o
+hdmicec-objs += $(CECSRC)/tmdlHdmiCEC_local.o
+hdmicec-objs += $(CECCFG)/tmdlHdmiCEC_Linux.o
+endif
+
+####################################################################
+
+EXTRA_CFLAGS += -I$(obj)
+EXTRA_CFLAGS += -I$(obj)/inc
+
+ifeq ($(TDA_TX),TDA19989)
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslHdmiTx/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/cfg
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9989NoHdcp/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9989NoHdcp/src/TDA9989n2
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/cfg
+endif
+
+ifeq ($(TDA_TX),TDA9984)
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslHdmiTx/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/cfg
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiTx/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9984NoHdcp/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9984NoHdcp/src
+endif
+
+ifeq ($(TDA_TX),TDA9983)
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9983/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/cfg
+endif
+
+ifeq ($(TDA_TX),TDA9981)
+EXTRA_CFLAGS += -I$(obj)/comps/tmbslTDA9983/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlTDA9983/cfg
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/inc
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/src
+EXTRA_CFLAGS += -I$(obj)/comps/tmdlHdmiCEC/cfg
+endif
+
+
diff --git a/drivers/video/hdmi/comps/tmbslHdmiTx/inc/tmbslHdmiTx_types.h b/drivers/video/hdmi/comps/tmbslHdmiTx/inc/tmbslHdmiTx_types.h
new file mode 100755
index 0000000..a03593e
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslHdmiTx/inc/tmbslHdmiTx_types.h
@@ -0,0 +1,1799 @@
+/**
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          bsl_types.h
+ *
+ * \version       $Revision: 18 $
+ *
+ * \date          $Date: 17/03/08 $
+ *
+ * \brief         HDMI Transmitter common types
+ *
+ * \section refs  Reference Documents
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: bsl_types.h $
+ *
+ *
+ * **************** Version 18  ******************
+ * User: G.Burnouf     Date: 01/04/08
+ * Updated in $/Source/bsl/inc
+ * PR1468 : add new function bslTDA9984GetSinkCategory
+ *
+ *
+ * **************** Version 17  ******************
+ * User: G.Burnouf     Date: 17/03/08
+ * Updated in $/Source/bsl/inc
+ * PR1430 : Increase size of table for
+ *          Short Audio Descriptor
+ *
+ * **************** Version 16  ******************
+ * User: G.Burnouf     Date: 06/03/08
+ * Updated in $/Source/bsl/inc
+ * PR1406 : new reset audio fifo sequence
+ *
+ * **************** Version 15  ******************
+ * User: G.Burnouf     Date: 05/02/08
+ * Updated in $/Source/bsl/inc
+ * PR1251 : add new type for function
+ *          bslTDA9984EdidGetBasicDisplayParam
+ *
+ ******************  version 14  ******************
+ * User: G.Burnouf     Date: 14/01/08
+ * Updated in $/Source/bsl/inc
+ * PR580 - Change BSL error base address
+ *
+ ******************  version 13  ******************
+ * User: G.Burnouf     Date: 10/01/08
+ * Updated in $/Source/bsl/inc
+ * PR606 - Apply audio port config in function
+ *         of audio format
+ *
+ * **************** Version 12  ******************
+ * User: G.Burnouf     Date: 10/12/07   Time: 08:30
+ * Updated in $/Source/bsl/inc
+ * PR1145 : return DTD and monitor description
+ *
+ * *****************  Version 11  *****************
+ * User: G.Burnouf     Date: 04/12/07
+ * Updated in $/Source/bsl/inc
+ * PR948 : add new formats, 1080p24/25/30
+ *
+ * *****************  Version 10 *****************
+ * User: C. Diehl	  Date: 27/11/07
+ * Updated in $/Source/bsl/inc
+ * PR1030 : - Align with the common interface
+ *            reworked for the LIPP4200
+ *
+ * *****************  Version 9  *****************
+ * User: J.Lamotte	  Date: 23/11/07   Time: 09:35
+ * Updated in $/Source/bsl/src
+ * PR1078 : - update HDMI_TX_SVD_MAX_CNT from 30
+ *            to 113
+ *
+ * *****************  Version 8  *****************
+ * User: G.Burnouf	  Date: 13/11/07   Time: 09:29
+ * Updated in $/Source/bsl/src
+ * PR1008 : - update type bslHwFeature_t
+ *
+ * *****************  Version 7  *****************
+ * User: G.Burnouf	  Date: 16/10/07   Time: 14:32
+ * Updated in $/Source/bsl/src
+ * PR882 : - add type bslPowerState_t
+ *         - add type bslPktGmt_t for gamut
+ *         - add new interrupt callback for VS
+ *
+ * *****************  Version 6  *****************
+ * User: G.Burnouf	  Date: 05/10/07   Time: 14:32
+ * Updated in $/Source/bsl/src
+ * PR824 : add type for enum _bslCallbackInt
+ *
+ * *****************  Version 5  *****************
+ * User: J.Turpin	  Date: 13/09/07   Time: 14:32
+ * Updated in $/Source/bsl/src
+ * PR693 : add black pattern functionality
+ *		 - add HDMITX_PATTERN_BLACK in
+ *			enum bslTestPattern_t
+ *
+ * *****************  Version 4  *****************
+ * User: G.Burnouf   Date: 06/09/07   Time: 17:22
+ * Updated in $/Source/bslTDA9984/Inc
+ * PR656 : - add HBR format
+ *         - add format I2s Philips left and right justified
+ *
+ * *****************  Version 3  *****************
+ * User: G. Burnouf      Date: 07/08/07   Time: 10:30
+ * Updated in $/Source/bslTDA9984/Inc
+ * PR572 - change type name of bslTDA9984_ to bsl_
+ *
+ * *****************  Version 2  *****************
+ * User: B.Vereecke      Date: 07/08/07   Time: 10:30
+ * Updated in $/Source/bslTDA9984/Inc
+ * PR551 - Add a new Pattern type in bslTestPattern_t
+ *			it is used for set the bluescreen
+ *
+ * *****************  Version 1  *****************
+ * User: G. Burnouf    Date: 05/07/07   Time: 17:00
+ * Updated in $/Source/bslTDA9984/Inc
+ * PR 414 : Add new edid management
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef BSLHDMITX_TYPES_H
+#define BSLHDMITX_TYPES_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#include "tmNxCompId.h"
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/**
+ * The maximum number of supported HDMI Transmitter units
+ * */
+#define HDMITX_UNITS_MAX       2
+
+/** \name Errors
+ *  The group of error codes returned by all API and internal functions
+ * */
+/*@{*/
+/** The base offset for all error codes.
+ *  This needs defining as non-zero if this component is integrated with others
+ *  and all component error ranges are to be kept separate.
+ * */
+#define ERR_HDMI_BASE	CID_BSL_HDMITX
+
+/** Define the OK code if not defined already */
+#ifndef TM_OK
+#define TM_OK   0
+#endif
+
+/** SW interface compatibility error */
+#define ERR_HDMI_COMPATIBILITY            (ERR_HDMI_BASE + 0x001U)
+
+/** SW major version error */
+#define ERR_HDMI_MAJOR_VERSION            (ERR_HDMI_BASE + 0x002U)
+
+/** SW component version error */
+#define ERR_HDMI_COMP_VERSION             (ERR_HDMI_BASE + 0x003U)
+
+/** Invalid device unit number */
+#define ERR_HDMI_BAD_UNIT_NUMBER          (ERR_HDMI_BASE + 0x005U)
+
+/** Invalid input parameter other than unit number */
+#define ERR_HDMI_BAD_PARAMETER            (ERR_HDMI_BASE + 0x009U)
+
+/* Ressource not available */
+#define ERR_HDMI_RESOURCE_NOT_AVAILABLE   (ERR_HDMI_BASE + 0x00CU)
+
+/** Inconsistent input parameters */
+#define ERR_HDMI_INCONSISTENT_PARAMS      (ERR_HDMI_BASE + 0x010U)
+
+/** Component is not initialized */
+#define ERR_HDMI_NOT_INITIALIZED          (ERR_HDMI_BASE + 0x011U)
+
+/** Command not supported for current device */
+#define ERR_HDMI_NOT_SUPPORTED            (ERR_HDMI_BASE + 0x013U)
+
+/** Initialization failed */
+#define ERR_HDMI_INIT_FAILED              (ERR_HDMI_BASE + 0x014U)
+
+/** Component is busy and cannot do a new operation */
+#define ERR_HDMI_BUSY                     (ERR_HDMI_BASE + 0x015U)
+
+/** I2C read error */
+#define ERR_HDMI_I2C_READ                 (ERR_HDMI_BASE + 0x017U)
+
+/** I2C write error */
+#define ERR_HDMI_I2C_WRITE                (ERR_HDMI_BASE + 0x018U)
+
+/** Assertion failure */
+#define ERR_HDMI_ASSERTION                (ERR_HDMI_BASE + 0x049U)
+
+/** Bad EDID block checksum */
+#define ERR_HDMI_INVALID_STATE            (ERR_HDMI_BASE + 0x066U)
+#define ERR_HDMI_INVALID_CHECKSUM         ERR_HDMI_INVALID_STATE
+
+/** No connection to HPD pin */
+#define ERR_HDMI_NULL_CONNECTION          (ERR_HDMI_BASE + 0x067U)
+
+/** Not allowed in DVI mode */
+#define ERR_HDMI_OPERATION_NOT_PERMITTED  (ERR_HDMI_BASE + 0x068U)
+
+/** Maximum error code defined */
+#define ERR_HDMI_MAX              ERR_HDMI_OPERATION_NOT_PERMITTED
+
+/*============================================================================*/
+
+#define HDMITX_ENABLE_VP_TABLE_LEN	3
+#define HDMITX_GROUND_VP_TABLE_LEN	3
+
+/** EDID block size */
+#define EDID_BLOCK_SIZE		    128
+
+/** size descriptor block of monitor descriptor */
+#define EDID_MONITOR_DESCRIPTOR_SIZE   13
+
+/*@}*/
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/**
+ * \brief TX IP/IC versions
+ * */
+typedef enum {
+	BSLHDMITX_UNKNOWN = 0x00, /**< IC/IP is not recognized */
+	BSLHDMITX_TDA9984,        /**< IC is a TDA9984         */
+	/**< IC is a TDA9989 (TDA9989N2 64 balls)         */
+	BSLHDMITX_TDA9989,
+	BSLHDMITX_TDA9981,        /**< IC is a TDA9981         */
+	BSLHDMITX_TDA9983,        /**< IC is a TDA9983         */
+	BSLHDMITX_TDA19989        /**< IC is a TDA19989        */
+} bsl_version_t;
+
+/**
+ * \brief System function pointer type, to call user I2C read/write functions
+ * \param slaveAddr     The I2C slave address
+ * \param firstRegister The first device register address to read or write
+ * \param lenData       Length of data to read or write (i.e. no. of registers)
+ * \param pData         Pointer to data to write, or to buffer to receive data
+ * \return              The call result:
+ *                      - 0: the call was successful
+ *                      - ERR_HDMI_I2C_WRITE: failed when writing
+ *                      - ERR_HDMI_I2C_READ:  failed when reading
+ * */
+typedef struct _bsl_sys_args_t {
+	u8 slave_addr;
+	u8 first_register;
+	u8 len_data;
+	u8 *p_data;
+} bsl_sys_args_t;
+typedef error_code_t (FUNC_PTR *pbsl_sys_func_t)
+(bsl_sys_args_t *p_sys_args);
+
+/**
+ * \brief System function pointer type, to call user I2C EDID read function
+ * \param segPtrAddr    The EDID segment pointer address 0 to 7Fh
+ * \param segPtr        The EDID segment pointer 0 to 7Fh
+ * \param dataRegAddr   The EDID data register address 0 to 7Fh
+ * \param wordOffset    The first word offset 0 to FFh to read
+ * \param lenData       Length of data to read (i.e. number of registers),
+ *                        1 to max starting at wordOffset
+ * \param pData         Pointer to buffer to receive lenData data bytes
+ * \return              The call result:
+ *                      - 0: the call was successful
+ *                      - ERR_HDMI_I2C_WRITE: failed when writing
+ *                      - ERR_HDMI_I2C_READ:  failed when reading
+ * */
+typedef struct _bsl_sys_args_edid_t {
+	u8 seg_ptr_addr;
+	u8 seg_ptr;
+	u8 data_reg_addr;
+	u8 word_offset;
+	u8 len_data;
+	u8 *p_data;
+} bsl_sys_args_edid_t;
+
+/**
+ * \brief EDID function pointer type, to call application EDID read function
+ * \param pSysArgs pointer to the structure containing necessary information to read EDID
+ * */
+typedef error_code_t (FUNC_PTR *pbsl_sys_func_edid_t)
+(bsl_sys_args_edid_t *p_sys_args);
+
+/**
+ * \brief Timer function pointer type, to call an application timer
+ * \param ms delay in milliseconds
+ * */
+typedef void(FUNC_PTR *pbsl_sys_func_timer_t)(u16 ms);
+
+/*============================================================================*/
+/**
+ * \brief Callback function pointer type, to call a user interrupt handler
+ * \param txUnit: The transmitter unit that interrupted, 0 to max
+ * */
+typedef void(FUNC_PTR *pbsl_callback_t)(unit_select_t tx_unit);
+
+/*============================================================================*/
+/**
+ * EIA/CEA-861B video format type
+ * */
+typedef enum {
+	/**< Not a valid format...        */
+	HDMITX_VFMT_NULL               = 0,
+	/**< ...or no change required     */
+	HDMITX_VFMT_NO_CHANGE          = 0,
+	/**< Lowest valid format          */
+	HDMITX_VFMT_MIN                = 1,
+	/**< Lowest valid TV format       */
+	HDMITX_VFMT_TV_MIN             = 1,
+	/**< Format 01 640  x 480p  60Hz  */
+	hdmitx_vfmt_01_640x480p_60hz   = 1,
+	/**< Format 02 720  x 480p  60Hz  */
+	hdmitx_vfmt_02_720x480p_60hz   = 2,
+	/**< Format 03 720  x 480p  60Hz  */
+	hdmitx_vfmt_03_720x480p_60hz   = 3,
+	/**< Format 04 1280 x 720p  60Hz  */
+	hdmitx_vfmt_04_1280x720p_60hz  = 4,
+	/**< Format 05 1920 x 1080i 60Hz  */
+	hdmitx_vfmt_05_1920x1080i_60hz = 5,
+	/**< Format 06 720  x 480i  60Hz  */
+	hdmitx_vfmt_06_720x480i_60hz   = 6,
+	/**< Format 07 720  x 480i  60Hz  */
+	hdmitx_vfmt_07_720x480i_60hz   = 7,
+	/**< Format 08 720  x 240p  60Hz  */
+	hdmitx_vfmt_08_720x240p_60hz   = 8,
+	/**< Format 09 720  x 240p  60Hz  */
+	hdmitx_vfmt_09_720x240p_60hz   = 9,
+	/**< Format 10 720  x 480i  60Hz  */
+	hdmitx_vfmt_10_720x480i_60hz   = 10,
+	/**< Format 11 720  x 480i  60Hz  */
+	hdmitx_vfmt_11_720x480i_60hz   = 11,
+	/**< Format 12 720  x 240p  60Hz  */
+	hdmitx_vfmt_12_720x240p_60hz   = 12,
+	/**< Format 13 720  x 240p  60Hz  */
+	hdmitx_vfmt_13_720x240p_60hz   = 13,
+	/**< Format 14 1440 x 480p  60Hz  */
+	hdmitx_vfmt_14_1440x480p_60hz  = 14,
+	/**< Format 15 1440 x 480p  60Hz  */
+	hdmitx_vfmt_15_1440x480p_60hz  = 15,
+	/**< Format 16 1920 x 1080p 60Hz  */
+	hdmitx_vfmt_16_1920x1080p_60hz = 16,
+	/**< Format 17 720  x 576p  50Hz  */
+	hdmitx_vfmt_17_720x576p_50hz   = 17,
+	/**< Format 18 720  x 576p  50Hz  */
+	hdmitx_vfmt_18_720x576p_50hz   = 18,
+	/**< Format 19 1280 x 720p  50Hz  */
+	hdmitx_vfmt_19_1280x720p_50hz  = 19,
+	/**< Format 20 1920 x 1080i 50Hz  */
+	hdmitx_vfmt_20_1920x1080i_50hz = 20,
+	/**< Format 21 720  x 576i  50Hz  */
+	hdmitx_vfmt_21_720x576i_50hz   = 21,
+	/**< Format 22 720  x 576i  50Hz  */
+	hdmitx_vfmt_22_720x576i_50hz   = 22,
+	/**< Format 23 720  x 288p  50Hz  */
+	hdmitx_vfmt_23_720x288p_50hz   = 23,
+	/**< Format 24 720  x 288p  50Hz  */
+	hdmitx_vfmt_24_720x288p_50hz   = 24,
+	/**< Format 25 720  x 576i  50Hz  */
+	hdmitx_vfmt_25_720x576i_50hz   = 25,
+	/**< Format 26 720  x 576i  50Hz  */
+	hdmitx_vfmt_26_720x576i_50hz   = 26,
+	/**< Format 27 720  x 288p  50Hz  */
+	hdmitx_vfmt_27_720x288p_50hz   = 27,
+	/**< Format 28 720  x 288p  50Hz  */
+	hdmitx_vfmt_28_720x288p_50hz   = 28,
+	/**< Format 29 1440 x 576p  50Hz  */
+	hdmitx_vfmt_29_1440x576p_50hz  = 29,
+	/**< Format 30 1440 x 576p  50Hz  */
+	hdmitx_vfmt_30_1440x576p_50hz  = 30,
+	/**< Format 31 1920 x 1080p 50Hz  */
+	hdmitx_vfmt_31_1920x1080p_50hz = 31,
+
+	/**< Format 32 1920 x 1080p 24Hz  */
+	hdmitx_vfmt_32_1920x1080p_24hz = 32,
+	/**< Format 33 1920 x 1080p 25Hz  */
+	hdmitx_vfmt_33_1920x1080p_25hz = 33,
+	/**< Format 34 1920 x 1080p 30Hz  */
+	hdmitx_vfmt_34_1920x1080p_30hz = 34,
+
+	/**< Format 35 2880 x 480p  60Hz 4:3  */
+	hdmitx_vfmt_35_2880x480p_60hz  = 35,
+	/**< Format 36 2880 x 480p  60Hz 16:9 */
+	hdmitx_vfmt_36_2880x480p_60hz  = 36,
+	/**< Format 37 2880 x 576p  50Hz 4:3  */
+	hdmitx_vfmt_37_2880x576p_50hz  = 37,
+	/**< Format 38 2880 x 576p  50Hz 16:9 */
+	hdmitx_vfmt_38_2880x576p_50hz  = 38,
+
+	/**< Highest valid TV format      */
+	HDMITX_VFMT_TV_MAX             = 38,
+	/**< Lowest TV format without prefetched table */
+	HDMITX_VFMT_TV_NO_REG_MIN      = 32,
+	/**< Number of TV formats & null  */
+	HDMITX_VFMT_TV_NUM             = 39,
+
+	/**< Lowest valid PC format       */
+	HDMITX_VFMT_PC_MIN             = 128,
+	/**< PC format 128                */
+	hdmitx_vfmt_pc_640x480p_60hz   = 128,
+	/**< PC format 129                */
+	hdmitx_vfmt_pc_800x600p_60hz   = 129,
+	/**< PC format 130                */
+	hdmitx_vfmt_pc_1152x960p_60hz  = 130,
+	/**< PC format 131                */
+	hdmitx_vfmt_pc_1024x768p_60hz  = 131,
+	/**< PC format 132                */
+	hdmitx_vfmt_pc_1280x768p_60hz  = 132,
+	/**< PC format 133                */
+	hdmitx_vfmt_pc_1280x1024p_60hz = 133,
+	/**< PC format 134                */
+	hdmitx_vfmt_pc_1360x768p_60hz  = 134,
+	/**< PC format 135                */
+	hdmitx_vfmt_pc_1400x1050p_60hz  = 135,
+	/**< PC format 136                */
+	hdmitx_vfmt_pc_1600x1200p_60hz = 136,
+	/**< PC format 137                */
+	hdmitx_vfmt_pc_1024x768p_70hz  = 137,
+	/**< PC format 138                */
+	hdmitx_vfmt_pc_640x480p_72hz   = 138,
+	/**< PC format 139                */
+	hdmitx_vfmt_pc_800x600p_72hz   = 139,
+	/**< PC format 140                */
+	hdmitx_vfmt_pc_640x480p_75hz   = 140,
+	/**< PC format 141                */
+	hdmitx_vfmt_pc_1024x768p_75hz  = 141,
+	/**< PC format 142                */
+	hdmitx_vfmt_pc_800x600p_75hz   = 142,
+	/**< PC format 143                */
+	hdmitx_vfmt_pc_1024x864p_75hz  = 143,
+	/**< PC format 144                */
+	hdmitx_vfmt_pc_1280x1024p_75hz = 144,
+	/**< PC format 145                */
+	hdmitx_vfmt_pc_640x350p_85hz   = 145,
+	/**< PC format 146                */
+	hdmitx_vfmt_pc_640x400p_85hz   = 146,
+	/**< PC format 147                */
+	hdmitx_vfmt_pc_720x400p_85hz   = 147,
+	/**< PC format 148                */
+	hdmitx_vfmt_pc_640x480p_85hz   = 148,
+	/**< PC format 149                */
+	hdmitx_vfmt_pc_800x600p_85hz   = 149,
+	/**< PC format 150                */
+	hdmitx_vfmt_pc_1024x768p_85hz  = 150,
+	/**< PC format 151                */
+	hdmitx_vfmt_pc_1152x864p_85hz  = 151,
+	/**< PC format 152                */
+	hdmitx_vfmt_pc_1280x960p_85hz  = 152,
+	/**< PC format 153                */
+	hdmitx_vfmt_pc_1280x1024p_85hz = 153,
+	/**< PC format 154                */
+	hdmitx_vfmt_pc_1024x768i_87hz  = 154,
+	/**< Highest valid PC format      */
+	HDMITX_VFMT_PC_MAX             = 154,
+	/**< Number of PC formats         */
+	HDMITX_VFMT_PC_NUM     = (1 + 154 - 128)
+} bsl_vid_fmt_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984AudioInSetConfig() parameter types
+ * */
+/** Audio input formats */
+typedef enum {
+	HDMITX_AFMT_SPDIF      = 0,         /**< SPDIF               */
+	HDMITX_AFMT_I2S        = 1,         /**< I2S                 */
+	HDMITX_AFMT_OBA        = 2,         /**< One bit audio / DSD */
+	HDMITX_AFMT_DST        = 3,         /**< DST                 */
+	HDMITX_AFMT_HBR        = 4,         /**< HBR                 */
+	HDMITX_AFMT_NUM        = 5,         /**< Number of Audio input format */
+	HDMITX_AFMT_INVALID    = 5          /**< Invalid format      */
+} bsla_fmt_t;
+
+/** I2s formats */
+typedef enum {
+	HDMITX_I2SFOR_PHILIPS_L   = 0,	/**< Philips like format */
+	HDMITX_I2SFOR_OTH_L       = 2,	/**< Other non Philips left justified */
+	HDMITX_I2SFOR_OTH_R	      = 3,	/**< Other non Philips right justified */
+	HDMITX_I2SFOR_INVALID     = 4	/**< Invalid format*/
+} bsl_i2s_for_t;
+
+/** DSD clock polarities */
+typedef enum {
+	HDMITX_CLKPOLDSD_ACLK       = 0,    /**< Same as ACLK */
+	HDMITX_CLKPOLDSD_NACLK      = 1,    /**< Not ACLK, i.e. inverted */
+	HDMITX_CLKPOLDSD_NO_CHANGE  = 2,    /**< No change    */
+	HDMITX_CLKPOLDSD_INVALID    = 3     /**< Invalid      */
+} bsl_clk_pol_dsd_t;
+
+/** DSD data swap values */
+typedef enum {
+	HDMITX_SWAPDSD_OFF          = 0,    /**< No swap   */
+	HDMITX_SWAPDSD_ON           = 1,    /**< Swap      */
+	HDMITX_SWAPDSD_NO_CHANGE    = 2,    /**< No change */
+	HDMITX_SWAPDSD_INVALID      = 3     /**< Invalid   */
+} bsl_swap_dsd_t;
+
+/** DST data transfer rates */
+typedef enum {
+	HDMITX_DSTRATE_SINGLE       = 0,    /**< Single transfer rate */
+	HDMITX_DSTRATE_DOUBLE       = 1,    /**< Double data rate */
+	HDMITX_DSTRATE_NO_CHANGE    = 2,    /**< No change */
+	HDMITX_DSTRATE_INVALID      = 3     /**< Invalid   */
+} bsl_dst_rate_t;
+
+/** I2S, SPDIF and DSD channel allocation values */
+enum _bsl_chan {
+	HDMITX_CHAN_MIN        = 0,
+	HDMITX_CHAN_MAX        = 31,
+	HDMITX_CHAN_NO_CHANGE  = 32,
+	HDMITX_CHAN_INVALID    = 33
+};
+
+/** Audio layout values */
+enum _bsl_layout {
+	HDMITX_LAYOUT_MIN       = 0,
+	HDMITX_LAYOUT_MAX       = 1,
+	HDMITX_LAYOUT_NO_CHANGE = 2,
+	HDMITX_LAYOUT_INVALID   = 3
+};
+
+/** Audio FIFO read latency values */
+enum _bsllatency_rd {
+	HDMITX_LATENCY_MIN         = 0x000,
+	HDMITX_LATENCY_CURRENT     = 0x080,
+	HDMITX_LATENCY_MAX         = 0x0FF,
+	HDMITX_LATENCY_NO_CHANGE   = 0x100,
+	HDMITX_LATENCY_INVALID     = 0x101
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984AudioInSetCts() parameter types
+ * */
+/** Clock Time Stamp reference source */
+typedef enum {
+	HDMITX_CTSREF_ACLK      = 0,    /**< Clock input pin for I2S       */
+	HDMITX_CTSREF_MCLK      = 1,    /**< Clock input pin for EXTREF    */
+	HDMITX_CTSREF_FS64SPDIF = 2,    /**< 64xsample rate, for SPDIF     */
+	HDMITX_CTSREF_INVALID   = 3     /**< Invalid value                 */
+} bslcts_ref_t;
+
+/** Audio sample rate kHz indexes */
+typedef enum {
+	hdmitx_afs_32k           = 0,     /**< 32kHz    */
+	hdmitx_afs_44_1k         = 1,     /**< 44.1kHz  */
+	HDMITX_AFS_48K           = 2,     /**< 48kHz    */
+	HDMITX_AFS_88_2K         = 3,     /**< 88.2kHz  */
+	HDMITX_AFS_96K           = 4,     /**< 96kHz    */
+	HDMITX_AFS_176_4K        = 5,     /**< 176.4kHz */
+	HDMITX_AFS_192K          = 6,     /**< 192kHz   */
+	HDMITX_AFS_768K          = 7,     /**< 768kHz   */
+	HDMITX_AFS_NOT_INDICATED = 8,     /**< Not Indicated (Channel Status) */
+	HDMITX_AFS_INVALID       = 8,     /**< Invalid  */
+	HDMITX_AFS_NUM           = 8      /**< # rates  */
+} bslafs_t;
+
+/** Vertical output frequencies */
+typedef enum {
+	hdmitx_vfreq_24hz      = 0,     /**< 24Hz          */
+	hdmitx_vfreq_25hz      = 1,     /**< 25Hz          */
+	hdmitx_vfreq_30hz      = 2,     /**< 30Hz          */
+	hdmitx_vfreq_50hz      = 3,     /**< 50Hz          */
+	hdmitx_vfreq_59hz      = 4,     /**< 59.94Hz       */
+	hdmitx_vfreq_60hz      = 5,     /**< 60Hz          */
+#ifndef FORMAT_PC
+	HDMITX_VFREQ_INVALID   = 6,     /**< Invalid       */
+	HDMITX_VFREQ_NUM       = 6      /**< No. of values */
+#else /* FORMAT_PC */
+	hdmitx_vfreq_70hz      = 6,     /**< 70Hz          */
+	hdmitx_vfreq_72hz      = 7,     /**< 72Hz          */
+	hdmitx_vfreq_75hz      = 8,     /**< 75Hz          */
+	hdmitx_vfreq_85hz      = 9,     /**< 85Hz          */
+	hdmitx_vfreq_87hz      = 10,    /**< 87Hz          */
+	HDMITX_VFREQ_INVALID   = 11,    /**< Invalid       */
+	HDMITX_VFREQ_NUM       = 11     /**< No. of values */
+#endif /* FORMAT_PC */
+} bsl_vfreq_t;
+
+/** Clock Time Stamp predivider - scales N */
+typedef enum {
+	HDMITX_CTSK1           = 0,     /**< k=1 */
+	HDMITX_CTSK2           = 1,     /**< k=2 */
+	HDMITX_CTSK3           = 2,     /**< k=3 */
+	HDMITX_CTSK4           = 3,     /**< k=4 */
+	HDMITX_CTSK8           = 4,     /**< k=8 */
+	HDMITX_CTSK_USE_CTSX   = 5,     /**< Calculate from ctsX factor */
+	HDMITX_CTSK_INVALID    = 6      /**< Invalid */
+} bslcts_k_t;
+
+/** Clock Time Stamp postdivider measured time stamp */
+typedef enum {
+	HDMITX_CTSMTS          = 0,     /**< =mts   */
+	HDMITX_CTSMTS2         = 1,     /**< =mts%2 */
+	HDMITX_CTSMTS4         = 2,     /**< =mts%4 */
+	HDMITX_CTSMTS8         = 3,     /**< =mts%8 */
+	HDMITX_CTSMTS_USE_CTSX = 4,     /**< Calculate from ctsX factor */
+	HDMITX_CTSMTS_INVALID  = 5      /**< Invalid */
+} bslcts_m_t;
+
+/** Cycle Time Stamp values */
+enum _bsl_cts {
+	HDMITX_CTS_AUTO        = 0,
+	HDMITX_CTS_MIN         = 0x000001
+};
+
+/** Cycle Time Stamp X factors */
+enum _bsl_cts_x {
+	HDMITX_CTSX_16         = 0,
+	HDMITX_CTSX_32         = 1,
+	HDMITX_CTSX_48         = 2,
+	HDMITX_CTSX_64         = 3,
+	HDMITX_CTSX_128        = 4,
+	HDMITX_CTSX_NUM        = 5,
+	/**< CTX value unused when K and Mts used */
+	HDMITX_CTSX_UNUSED     = 5,
+	HDMITX_CTSX_INVALID    = 6
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984AudioOutSetChanStatus() parameter types
+ * */
+
+typedef enum {
+	/**< Main data field represents linear PCM samples.    */
+	HDMITX_AUDIO_DATA_PCM     = 0,
+	/**< Main data field used for purposes other purposes. */
+	HDMITX_AUDIO_DATA_OTHER   = 1,
+	HDMITX_AUDIO_DATA_INVALID = 2   /**< Invalid value */
+} bsl_audio_data_t;
+
+/** BYTE 0: Channel Status Format information */
+typedef enum {
+	/**< PCM 2 channels without pre-emphasis           */
+	HDMITX_CSFI_PCM_2CHAN_NO_PRE    = 0,
+	/**< PCM 2 channels with 50us/15us pre-emphasis    */
+	HDMITX_CSFI_PCM_2CHAN_PRE       = 1,
+	/**< PCM Reserved for 2 channels with pre-emphasis */
+	HDMITX_CSFI_PCM_2CHAN_PRE_RSVD1 = 2,
+	/**< PCM Reserved for 2 channels with pre-emphasis */
+	HDMITX_CSFI_PCM_2CHAN_PRE_RSVD2 = 3,
+	/**< Non-PCM Default state                         */
+	HDMITX_CSFI_NOTPCM_DEFAULT      = 4,
+	/**< Invalid value                                 */
+	HDMITX_CSFI_INVALID             = 5
+} bsl_csformat_info_t;
+
+/** BYTE 0: Channel Status Copyright assertion */
+typedef enum {
+	HDMITX_CSCOPYRIGHT_PROTECTED   = 0,  /**< Copyright protected     */
+	HDMITX_CSCOPYRIGHT_UNPROTECTED = 1,  /**< Not copyright protected */
+	HDMITX_CSCOPYRIGHT_INVALID     = 2   /**< Invalid value           */
+} bsl_cscopyright_t;
+
+/** BYTE 3: Channel Status Clock Accuracy */
+typedef enum {
+	HDMITX_CSCLK_LEVEL_II    = 0,     /**< Level II                     */
+	HDMITX_CSCLK_LEVEL_I     = 1,     /**< Level I                      */
+	HDMITX_CSCLK_LEVEL_III   = 2,     /**< Level III                    */
+	HDMITX_CSCLK_NOT_MATCHED = 3,     /**< Not matched to sample freq.  */
+	HDMITX_CSCLK_INVALID     = 4      /**< Invalid                      */
+} bsl_csclk_acc_t;
+
+/** BYTE 4: Channel Status Maximum sample word length */
+typedef enum {
+	HDMITX_CSMAX_LENGTH_20   = 0,  /**< Max word length is 20 bits   */
+	HDMITX_CSMAX_LENGTH_24   = 1,  /**< Max word length is 24 bits   */
+	HDMITX_CSMAX_INVALID     = 2   /**< Invalid value                */
+} bsl_csmax_word_length_t;
+
+/** BYTE 4: Channel Status Sample word length */
+typedef enum {
+	/**< Word length is not indicated                    */
+	HDMITX_CSWORD_DEFAULT          = 0,
+	/**< Sample length is 20 bits out of max 24 possible */
+	HDMITX_CSWORD_20_OF_24         = 1,
+	/**< Sample length is 16 bits out of max 20 possible */
+	HDMITX_CSWORD_16_OF_20         = 1,
+	/**< Sample length is 22 bits out of max 24 possible */
+	HDMITX_CSWORD_22_OF_24         = 2,
+	/**< Sample length is 18 bits out of max 20 possible */
+	HDMITX_CSWORD_18_OF_20         = 2,
+	/**< Reserved - shall not be used */
+	HDMITX_CSWORD_RESVD            = 3,
+	/**< Sample length is 23 bits out of max 24 possible */
+	HDMITX_CSWORD_23_OF_24         = 4,
+	/**< Sample length is 19 bits out of max 20 possible */
+	HDMITX_CSWORD_19_OF_20         = 4,
+	/**< Sample length is 24 bits out of max 24 possible */
+	HDMITX_CSWORD_24_OF_24         = 5,
+	/**< Sample length is 20 bits out of max 20 possible */
+	HDMITX_CSWORD_20_OF_20         = 5,
+	/**< Sample length is 21 bits out of max 24 possible */
+	HDMITX_CSWORD_21_OF_24         = 6,
+	/**< Sample length is 17 bits out of max 20 possible */
+	HDMITX_CSWORD_17_OF_20         = 6,
+	HDMITX_CSWORD_INVALID          = 7      /**< Invalid */
+} bsl_csword_length_t;
+
+/** BYTE 4: Channel Status Original sample frequency */
+typedef enum {
+	HDMITX_CSOFREQ_NOT_INDICATED = 0,   /**< Not Indicated */
+	hdmitx_csofreq_192k          = 1,   /**< 192kHz        */
+	hdmitx_csofreq_12k           = 2,   /**< 12kHz         */
+	hdmitx_csofreq_176_4k        = 3,   /**< 176.4kHz      */
+	HDMITX_CSOFREQ_RSVD1         = 4,   /**< Reserved      */
+	hdmitx_csofreq_96k           = 5,   /**< 96kHz         */
+	hdmitx_csofreq_8k            = 6,   /**< 8kHz          */
+	hdmitx_csofreq_88_2k         = 7,   /**< 88.2kHz       */
+	hdmitx_csofreq_16k           = 8,   /**< 16kHz         */
+	hdmitx_csofreq_24k           = 9,   /**< 24kHz         */
+	hdmitx_csofreq_11_025k       = 10,  /**< 11.025kHz     */
+	hdmitx_csofreq_22_05k        = 11,  /**< 22.05kHz      */
+	hdmitx_csofreq_32k           = 12,  /**< 32kHz         */
+	hdmitx_csofreq_48k           = 13,  /**< 48kHz         */
+	HDMITX_CSOFREQ_RSVD2         = 14,  /**< Reserved      */
+	hdmitx_csofreq_44_1k         = 15,  /**< 44.1kHz       */
+	HDMITX_CSAFS_INVALID         = 16   /**< Invalid value */
+} bsl_csorig_afs_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984AudioOutSetChanStatusMapping() parameter types
+ * */
+/** Channel Status source/channel number limits */
+enum _bsl_chan_status_chan_limits {
+	HDMITX_CS_CHANNELS_MAX  = 0x0F,
+	HDMITX_CS_SOURCES_MAX   = 0x0F
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984AudioOutSetMute() parameter type
+ * */
+/** Audio mute state */
+typedef enum {
+	HDMITX_AMUTE_OFF       = 0,    /**< Mute off */
+	HDMITX_AMUTE_ON        = 1,    /**< Mute on  */
+	HDMITX_AMUTE_INVALID   = 2     /**< Invalid  */
+} bsla_mute_t;
+
+/** Number of 3 byte Short Audio Descriptors stored in pEdidAFmts */
+#define HDMI_TX_SAD_MAX_CNT     30
+
+/*============================================================================*/
+/**
+ * bslTDA9984EdidGetBlockData() parameter types
+ * */
+/** An enum to represent the current EDID status */
+enum _bsl_edid_sta_t {
+	HDMITX_EDID_READ                = 0,    /* All blocks read OK */
+	/* All blocks read OK but buffer too
+	 *	 HDMITX_EDID_READ_INCOMPLETE     = 1,
+	 *                                               small to return all of them */
+	HDMITX_EDID_ERROR_CHK_BLOCK_0   = 2,    /* Block 0 checksum error */
+
+	/* Block 0 OK, checksum error in one
+	 *	 HDMITX_EDID_ERROR_CHK           = 3,
+	 *                                               or more other blocks */
+	HDMITX_EDID_NOT_READ            = 4,    /* EDID not read */
+
+	HDMITX_EDID_STATUS_INVALID      = 5     /**< Invalid   */
+
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984EdidGetSinkType() parameter types
+ * */
+/** Sink device type */
+typedef enum {
+	HDMITX_SINK_DVI                = 0,    /**< DVI  */
+	HDMITX_SINK_HDMI               = 1,    /**< HDMI */
+	HDMITX_SINK_EDID               = 2,    /**< As currently defined in EDID */
+	HDMITX_SINK_INVALID            = 3     /**< Invalid   */
+} bsl_sink_type_t;
+
+/*============================================================================*/
+/**
+ * \brief The bslTDA9984EdidGetVideoPreferred() parameter type
+ * Detailed timining description structure
+ * */
+typedef struct _bsl_edid_dtd_t {
+	u16  u_pixel_clock;        /**< Pixel Clock/10,000         */
+	u16  u_hactive_pixels;     /**< Horizontal Active Pixels   */
+	u16  u_hblank_pixels;      /**< Horizontal Blanking Pixels */
+	u16  u_vactive_lines;      /**< Vertical Active Lines      */
+	u16  u_vblank_lines;       /**< Vertical Blanking Lines    */
+	u16  u_hsync_offset;       /**< Horizontal Sync Offset     */
+	u16  u_hsync_width;        /**< Horiz. Sync Pulse Width    */
+	u16  u_vsync_offset;       /**< Vertical Sync Offset       */
+	u16  u_vsync_width;        /**< Vertical Sync Pulse Width  */
+	u16  u_himage_size;        /**< Horizontal Image Size      */
+	u16  u_vimage_size;        /**< Vertical Image Size        */
+	u16  u_hborder_pixels;     /**< Horizontal Border          */
+	u16  u_vborder_pixels;     /**< Vertical Border            */
+	u8   flags;              /**< Interlace/sync info        */
+} bsl_edid_dtd_t;
+
+/*============================================================================*/
+/**
+ * First monitor descriptor structure
+ * */
+typedef struct _bsl_edid_first_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Monitor Name                                   */
+	u8   u_monitor_name[EDID_MONITOR_DESCRIPTOR_SIZE];
+} bsl_edid_first_md_t;
+
+/*============================================================================*/
+/**
+ * Second monitor descriptor structure
+ * */
+typedef struct _bsl_edid_second_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Min vertical rate in Hz                        */
+	u8   u_min_vertical_rate;
+	/**< Max vertical rate in Hz                        */
+	u8   u_max_vertical_rate;
+	/**< Min horizontal rate in Hz                      */
+	u8   u_min_horizontal_rate;
+	/**< Max horizontal rate in Hz                      */
+	u8   u_max_horizontal_rate;
+	/**< Max suuported pixel clock rate in MHz          */
+	u8   u_max_supported_pixel_clk;
+} bsl_edid_second_md_t;
+
+/*============================================================================*/
+/**
+ * Other monitor descriptor structure
+ * */
+typedef struct _bsl_edid_other_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Other monitor Descriptor                       */
+	u8   u_other_descriptor[EDID_MONITOR_DESCRIPTOR_SIZE];
+} bsl_edid_other_md_t;
+
+/*============================================================================*/
+/**
+ * basic display parameters structure
+ * */
+typedef struct _bsl_edid_bdparam_t {
+	/**< Video Input Definition                       */
+	u8   u_video_input_def;
+	/**< Max. Horizontal Image Size in cm             */
+	u8   u_max_horizontal_size;
+	/**< Max. Vertical Image Size in cm               */
+	u8   u_max_vertical_size;
+	/**< Gamma                                        */
+	u8   u_gamma;
+	/**< Feature support                              */
+	u8   u_feature_support;
+} bsl_edid_bdparam_t;
+
+/*============================================================================*/
+/**
+ * \brief The bslTDA9984EdidGetAudioCapabilities() parameter type
+ * */
+typedef struct _bsl_edid_sad_t {
+	u8   mode_chans;  /* Bits[6:3]: EIA/CEA861 mode; Bits[2:0]: channels */
+	u8   freqs;      /* Bits for each supported frequency */
+	u8   byte3;      /* EIA/CEA861B p83: data depending on audio mode */
+} bsl_edid_sad_t;
+
+/*============================================================================*/
+/**
+ * \brief struc to store parameter provide by function bslTDA9984EdidRequestBlockData()
+ * */
+typedef struct _bsl_edid_to_app_t {
+	/* pointer on a tab to store edid requested by application */
+	u8   *p_raw_edid;
+	int     num_blocks;  /* number of edid block requested by application */
+} bsl_edid_to_app_t;
+
+/*============================================================================*/
+/**
+ *  bslTDA9984EdidGetVideoCapabilities() parameter types
+ * */
+/** Number of 1 byte Short Video Descriptors stored in pEdidVFmts */
+#define HDMI_TX_SVD_MAX_CNT     113
+
+/** number of detailed timing descriptor stored in BSL */
+#define NUMBER_DTD_STORED       10
+
+/** Flag set in Short Video Descriptor to indicate native format */
+#define HDMI_TX_SVD_NATIVE_MASK 0x80
+#define HDMI_TX_SVD_NATIVE_NOT  0x7F
+
+/** Video capability flags */
+enum _bsl_vid_cap_t {
+	HDMITX_VIDCAP_UNDERSCAN   = 0x80,   /**< Underscan supported */
+	HDMITX_VIDCAP_YUV444      = 0x40,   /**< YCbCr 4:4:4 supported */
+	HDMITX_VIDCAP_YUV422      = 0x20,   /**< YCbCr 4:2:2 supported */
+	HDMITX_VIDCAP_UNUSED      = 0x1F    /**< Unused flags */
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984HdcpCheck() parameter type
+ * */
+/** HDCP check result */
+typedef enum {
+	HDMITX_HDCP_CHECK_NOT_STARTED       = 0,    /**< Check not started */
+	HDMITX_HDCP_CHECK_IN_PROGRESS       = 1,    /**< No failures, more to do */
+	HDMITX_HDCP_CHECK_PASS              = 2,    /**< Final check has passed */
+	/**< First check failure code */
+	HDMITX_HDCP_CHECK_FAIL_FIRST        = 3,
+	/**< Driver not AUTHENTICATED */
+	HDMITX_HDCP_CHECK_FAIL_DRIVER_STATE = 3,
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_T0    = 4,    /**< A T0 interrupt occurred */
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_RI    = 5,    /**< Device RI changed */
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM   = 6,    /**< Device FSM not 10h */
+	HDMITX_HDCP_CHECK_NUM               = 7     /**< Number of check results */
+} bsl_hdcp_check_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984HdcpConfigure() parameter type
+ * */
+/** HDCP DDC slave addresses */
+enum _bsl_hdcp_slave_address {
+	HDMITX_HDCP_SLAVE_PRIMARY    = 0x74,
+	HDMITX_HDCP_SLAVE_SECONDARY  = 0x76
+};
+
+/** HDCP transmitter modes */
+typedef enum {
+	HDMITX_HDCP_TXMODE_NOT_SET   = 0,
+	HDMITX_HDCP_TXMODE_REPEATER  = 1,
+	HDMITX_HDCP_TXMODE_TOP_LEVEL = 2,
+	HDMITX_HDCP_TXMODE_MAX       = 2
+} bsl_hdcp_tx_mode_t;
+
+/** HDCP option flags */
+typedef enum {
+	/* Not set: obey PJ result     */
+	HDMITX_HDCP_OPTION_FORCE_PJ_IGNORED = 0x01,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_SLOW_DDC   = 0x02,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_NO_1_1     = 0x04,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_REPEATER   = 0x08,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_NO_REPEATER = 0x10,
+	/* Not set: obey V=V' result   */
+	HDMITX_HDCP_OPTION_FORCE_V_EQU_VBAR = 0x20,
+	HDMITX_HDCP_OPTION_FORCE_VSLOW_DDC  = 0x40,/* Set: 50kHz DDC */
+	HDMITX_HDCP_OPTION_DEFAULT          = 0x00,/* All the above Not Set vals */
+	/* Only these bits are allowed */
+	HDMITX_HDCP_OPTION_MASK             = 0x7F,
+	/* These bits are not allowed  */
+	HDMITX_HDCP_OPTION_MASK_BAD         = 0x80
+} bsl_hdcp_options_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984HdcpDownloadKeys() parameter type
+ * */
+/** HDCP decryption mode */
+typedef enum {
+	HDMITX_HDCP_DECRYPT_DISABLE  = 0,
+	HDMITX_HDCP_DECRYPT_ENABLE   = 1,
+	HDMITX_HDCP_DECRYPT_MAX      = 1
+} bsl_decrypt_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984HdcpHandleBSTATUS() parameter type
+ * */
+/** BSTATUS bit fields */
+enum _bsl_hdcp_handle_bstatus {
+	HDMITX_HDCP_BSTATUS_HDMI_MODE               = 0x1000,
+	HDMITX_HDCP_BSTATUS_MAX_CASCADE_EXCEEDED    = 0x0800,
+	HDMITX_HDCP_BSTATUS_CASCADE_DEPTH           = 0x0700,
+	HDMITX_HDCP_BSTATUS_MAX_DEVS_EXCEEDED       = 0x0080,
+	HDMITX_HDCP_BSTATUS_DEVICE_COUNT            = 0x007F
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984HdcpHandleSHA_1() parameter types
+ * */
+/** KSV list sizes */
+enum _bsl_hdcp_handle_sha_1 {
+	HDMITX_KSV_LIST_MAX_DEVICES = 128,
+	HDMITX_KSV_BYTES_PER_DEVICE = 5
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984HotPlugGetStatus() parameter type
+ * */
+/** Current hotplug status */
+typedef enum {
+	HDMITX_HOTPLUG_INACTIVE    = 0,    /**< Hotplug inactive */
+	HDMITX_HOTPLUG_ACTIVE      = 1,    /**< Hotplug active   */
+	HDMITX_HOTPLUG_INVALID     = 2     /**< Invalid Hotplug  */
+} bsl_hot_plug_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984RxSenseGetStatus() parameter type
+ * */
+/** Current RX Sense status */
+typedef enum {
+	HDMITX_RX_SENSE_INACTIVE    = 0,    /**< RxSense inactive */
+	HDMITX_RX_SENSE_ACTIVE      = 1,    /**< RxSense active   */
+	HDMITX_RX_SENSE_INVALID     = 2     /**< Invalid RxSense  */
+} bsl_rx_sense_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984HwGetCapabilities() parameter type
+ * */
+/** List of HW features that may be supported by HW */
+typedef enum {
+	HDMITX_FEATURE_HW_HDCP             = 0,  /**< HDCP   feature */
+	HDMITX_FEATURE_HW_SCALER           = 1,  /**< Scaler feature */
+	HDMITX_FEATURE_HW_AUDIO_OBA        = 2,  /**< One Bit Audio feature */
+	HDMITX_FEATURE_HW_AUDIO_DST        = 3,  /**< DST Audio feature */
+	HDMITX_FEATURE_HW_AUDIO_HBR        = 4,  /**< HBR Audio feature */
+	HDMITX_FEATURE_HW_HDMI_1_1         = 5,  /**< HDMI 1.1 feature */
+	HDMITX_FEATURE_HW_HDMI_1_2A        = 6,  /**< HDMI 1.2a feature */
+	HDMITX_FEATURE_HW_HDMI_1_3A        = 7,  /**< HDMI 1.3a feature */
+	HDMITX_FEATURE_HW_DEEP_COLOR_30    = 8,  /**< 30 bits deep color support */
+	HDMITX_FEATURE_HW_DEEP_COLOR_36    = 9,  /**< 36 bits deep color support */
+	HDMITX_FEATURE_HW_DEEP_COLOR_48    = 11, /**< 48 bits deep color support */
+	HDMITX_FEATURE_HW_UPSAMPLER        = 12, /**< Up sampler feature */
+	HDMITX_FEATURE_HW_DOWNSAMPLER      = 13, /**< Down sampler feature */
+	HDMITX_FEATURE_HW_COLOR_CONVERSION = 14  /**< Color conversion matrix */
+} bsl_hw_feature_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984Init() parameter types
+ * */
+/** Supported range of I2C slave addresses */
+enum _bsl_slave_address {
+	HDMITX_SLAVE_ADDRESS_MIN    = 1,
+	HDMITX_SLAVE_ADDRESS_MAX    = 127
+};
+
+/**
+ * Indexes into the funcCallback[] array of interrupt callback function pointers
+ * */
+typedef enum _bsl_callback_int {
+	/**< HDCP encryption switched off     */
+	HDMITX_CALLBACK_INT_SECURITY        = 0,
+	/**< HDCP encrypt as above (Obsolete) */
+	HDMITX_CALLBACK_INT_ENCRYPT         = 0,
+	/**< Transition on HPD input          */
+	HDMITX_CALLBACK_INT_HPD             = 1,
+	/**< HDCP state machine in state T0   */
+	HDMITX_CALLBACK_INT_T0              = 2,
+	/**< BCAPS available                  */
+	HDMITX_CALLBACK_INT_BCAPS           = 3,
+	/**< BSTATUS available                */
+	HDMITX_CALLBACK_INT_BSTATUS         = 4,
+	/**< sha-1(ksv,bstatus,m0)=V'         */
+	HDMITX_CALLBACK_INT_SHA_1           = 5,
+	/**< pj=pj' check fails               */
+	HDMITX_CALLBACK_INT_PJ              = 6,
+	/**< R0 interrupt                     */
+	HDMITX_CALLBACK_INT_R0              = 7,
+	/**< SW DEBUG interrupt               */
+	HDMITX_CALLBACK_INT_SW_INT          = 8,
+	/**< RX SENSE interrupt               */
+	HDMITX_CALLBACK_INT_RX_SENSE        = 9,
+	/**< EDID BLK READ interrupt          */
+	HDMITX_CALLBACK_INT_EDID_BLK_READ   = 10,
+	/**< Pll Lock (Serial or Formatter)   */
+	HDMITX_CALLBACK_INT_PLL_LOCK        = 11,
+	/**< VS Interrupt for Gamut packets   */
+	HDMITX_CALLBACK_INT_VS_RPT          = 12,
+	/**< Number of callbacks              */
+	HDMITX_CALLBACK_INT_NUM             = 13
+} bsl_callback_int_t;
+
+/** Pixel rate */
+typedef enum {
+	HDMITX_PIXRATE_DOUBLE               = 0,        /**< Double pixel rate */
+	HDMITX_PIXRATE_SINGLE               = 1,        /**< Single pixel rate */
+	/**< Single pixel repeated */
+	HDMITX_PIXRATE_SINGLE_REPEATED      = 2,
+	HDMITX_PIXRATE_NO_CHANGE            = 3,        /**< No Change */
+	HDMITX_PIXRATE_INVALID              = 4         /**< Invalid   */
+} bsl_pix_rate_t;
+
+/**
+ * \brief The bslTDA9984Init() parameter structure
+ * */
+typedef struct _bsl_callback_list_t {
+	/** Interrupt callback function pointers (each ptr if null = not used) */
+	pbsl_callback_t func_callback[HDMITX_CALLBACK_INT_NUM];
+
+} bsl_callback_list_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984MatrixSetCoeffs() parameter type
+ * */
+/** Parameter structure array size */
+enum _bsl_mat_coeff {
+	HDMITX_MAT_COEFF_NUM = 9
+};
+
+/** \brief The bslTDA9984MatrixSetCoeffs() parameter structure */
+/** Array of coefficients (values -1024 to +1023) */
+typedef struct _bsl_mat_coeff_t {
+	/** Array of coefficients (values -1024 to +1023) */
+	s16 coeff[HDMITX_MAT_COEFF_NUM];
+} bsl_mat_coeff_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984MatrixSetConversion() parameter type
+ * */
+/** Video input mode */
+typedef enum {
+	HDMITX_VINMODE_CCIR656     = 0,    /**< ccir656  */
+	HDMITX_VINMODE_RGB444      = 1,    /**< RGB444    */
+	HDMITX_VINMODE_YUV444      = 2,    /**< YUV444    */
+	HDMITX_VINMODE_YUV422      = 3,    /**< YUV422    */
+	HDMITX_VINMODE_NO_CHANGE   = 4,    /**< No change */
+	HDMITX_VINMODE_INVALID     = 5     /**< Invalid   */
+} bsl_vin_mode_t;
+
+/** Video output mode */
+typedef enum {
+	HDMITX_VOUTMODE_RGB444      = 0,    /**< RGB444    */
+	HDMITX_VOUTMODE_YUV422      = 1,    /**< YUV422    */
+	HDMITX_VOUTMODE_YUV444      = 2,    /**< YUV444    */
+	HDMITX_VOUTMODE_NO_CHANGE   = 3,    /**< No change */
+	HDMITX_VOUTMODE_INVALID     = 4     /**< Invalid   */
+} bsl_vout_mode_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984MatrixSetMode() parameter types
+ * */
+/** Matrix  control values */
+typedef enum {
+	HDMITX_MCNTRL_ON        = 0,   /**< Matrix on  */
+	HDMITX_MCNTRL_OFF       = 1,   /**< Matrix off */
+	HDMITX_MCNTRL_NO_CHANGE = 2,   /**< Matrix unchanged */
+	HDMITX_MCNTRL_MAX       = 2,   /**< Max value  */
+	HDMITX_MCNTRL_INVALID   = 3    /**< Invalid    */
+} bslm_cntrl_t;
+
+/** Matrix  scale values */
+typedef enum {
+	HDMITX_MSCALE_256       = 0,   /**< Factor 1/256  */
+	HDMITX_MSCALE_512       = 1,   /**< Factor 1/512  */
+	HDMITX_MSCALE_1024      = 2,   /**< Factor 1/1024 */
+	HDMITX_MSCALE_NO_CHANGE = 3,   /**< Factor unchanged */
+	HDMITX_MSCALE_MAX       = 3,   /**< Max value     */
+	HDMITX_MSCALE_INVALID   = 4    /**< Invalid value */
+} bslm_scale_t;
+
+/*============================================================================*/
+/**
+ * Data Island Packet structure
+ * */
+/** Parameter structure array sizes */
+enum _bsl_pkt {
+	HDMITX_PKT_DATA_BYTE_CNT = 28
+};
+
+/** \brief The parameter structure for bslTDA9984Pkt*() APIs */
+typedef struct _bsl_pkt_t {
+	u8 data_byte[HDMITX_PKT_DATA_BYTE_CNT];       /**< Packet Data   */
+} bsl_pkt_t;
+
+/*============================================================================*/
+/**
+ * \brief The Audio Infoframe Parameter structure
+ * */
+typedef struct _bsl_pkt_aif_t {
+	u8 coding_type;       /**< Coding Type 0 to 0Fh */
+	u8 channel_count;     /**< Channel Count 0 to 07h */
+	u8 sample_freq;       /**< Sample Frequency 0 to 07h */
+	u8 sample_size;       /**< Sample Size 0 to 03h */
+	u8 channel_alloc;     /**< Channel Allocation 0 to FFh */
+	bool  down_mix_inhibit;   /**< Downmix inhibit flag 0/1 */
+	u8 level_shift;       /**< Level Shift 0 to 0Fh */
+} bsl_pkt_aif_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984PktSetMpegInfoframe() parameter types
+ * */
+/** MPEG frame types */
+typedef enum {
+	HDMITX_MPEG_FRAME_UNKNOWN   = 0,    /**< Unknown  */
+	HDMITX_MPEG_FRAME_I         = 1,    /**< i-frame   */
+	HDMITX_MPEG_FRAME_B         = 2,    /**< b-frame */
+	HDMITX_MPEG_FRAME_P         = 3,    /**< p-frame */
+	HDMITX_MPEG_FRAME_INVALID   = 4     /**< Invalid   */
+} bsl_mpeg_frame_t;
+
+/** \brief The MPEG Infoframe Parameter structure */
+typedef struct _bsl_pkt_mpeg_t {
+	u32                  bit_rate;        /**< MPEG bit rate in Hz */
+	bsl_mpeg_frame_t  frame_type;      /**< MPEG frame type */
+	/**< 0: new field, 1:repeated field */
+	bool                    b_field_repeat;
+} bsl_pkt_mpeg_t;
+
+/*============================================================================*/
+/**
+ * Source Product Description Infoframe Parameter types
+ *  */
+/** SDI frame types */
+typedef enum {
+	HDMITX_SPD_INFO_UNKNOWN     = 0,
+	HDMITX_SPD_INFO_DIGITAL_STB = 1,
+	HDMITX_SPD_INFO_DVD         = 2,
+	HDMITX_SPD_INFO_DVHS        = 3,
+	HDMITX_SPD_INFO_HDD_VIDEO   = 4,
+	HDMITX_SPD_INFO_DVC         = 5,
+	HDMITX_SPD_INFO_DSC         = 6,
+	HDMITX_SPD_INFO_VIDEO_CD    = 7,
+	HDMITX_SPD_INFO_GAME        = 8,
+	HDMITX_SPD_INFO_PC          = 9,
+	HDMITX_SPD_INFO_INVALID     = 10
+} bsl_source_dev_t;
+
+#define HDMI_TX_SPD_VENDOR_SIZE 8
+#define HDMI_TX_SPD_DESCR_SIZE  16
+#define HDMI_TX_SPD_LENGTH      25
+
+/** \brief The Source Product Description Infoframe Parameter structure */
+typedef struct _bsl_pkt_spd_t {
+	/**< Vendor name */
+	u8                   vendor_name[HDMI_TX_SPD_VENDOR_SIZE];
+	/**< Product Description */
+	u8                   prod_descr[HDMI_TX_SPD_DESCR_SIZE];
+	/**< Source Device Info */
+	bsl_source_dev_t  source_dev_info;
+} bsl_pkt_spd_t;
+
+/*============================================================================*/
+/**
+ * \brief The Video Infoframe Parameter structure
+ *  */
+typedef struct _bsl_pkt_vif_t {
+	u8  colour;               /**< 0 to 03h */
+	bool   active_info;           /**< 0/1 */
+	u8  bar_info;              /**< 0 to 03h */
+	u8  scan_info;             /**< 0 to 03h */
+	u8  colorimetry;          /**< 0 to 03h */
+	u8  picture_aspect_ratio;   /**< 0 to 03h */
+	u8  active_format_ratio;    /**< 0 to 0Fh */
+	u8  scaling;              /**< 0 to 03h */
+	u8  vid_format;            /**< 0 to 7Fh */
+	u8  pixel_repeat;          /**< 0 to 0Fh */
+	u16 end_top_bar_line;
+	u16 start_bottom_bar_line;
+	u16 end_left_bar_pixel;
+	u16 start_right_bar_pixel;
+} bsl_pkt_vif_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerGetMode() parameter types
+ * */
+/** Scaler modes */
+typedef enum {
+	HDMITX_SCAMODE_OFF       = 0,    /**< Off  */
+	HDMITX_SCAMODE_ON        = 1,    /**< On   */
+	HDMITX_SCAMODE_AUTO      = 2,    /**< Auto */
+	HDMITX_SCAMODE_NO_CHANGE = 3,    /**< No change */
+	HDMITX_SCAMODE_INVALID   = 4     /**< Invalid   */
+} bsl_sca_mode_t;
+
+/*============================================================================*/
+/**
+ * \brief The bslTDA9984ScalerGet() parameter type
+ * */
+typedef struct _bsl_scaler_diag_t {
+	u16 max_buffill_p;     /**< Filling primary video buffer           */
+	u16 max_buffill_d;     /**< Filling video deinterlaced buffer      */
+	u8 max_fifofill_pi;    /**< Filling primary video input FIFO       */
+	u8 min_fifofill_po1;   /**< Filling primary video output FIFO #1   */
+	u8 min_fifofill_po2;   /**< Filling primary video output FIFO #2   */
+	u8 min_fifofill_po3;   /**< Filling primary video output FIFO #3   */
+	u8 min_fifofill_po4;   /**< Filling primary video output FIFO #4   */
+	u8 max_fifofill_di;    /**< Filling deinterlaced video input FIFO  */
+	u8 max_fifofill_do;    /**< Filling deinterlaced video output FIFO */
+} bsl_scaler_diag_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerSetCoeffs() parameter types
+ * */
+/** Scaler lookup table selection */
+typedef enum {
+	HDMITX_SCALUT_DEFAULT_TAB1     = 0,    /**< Use default table 1 */
+	HDMITX_SCALUT_DEFAULT_TAB2     = 1,    /**< Use default table 2 */
+	HDMITX_SCALUT_USE_VSLUT        = 2,    /**< Use vsLut parameter */
+	HDMITX_SCALUT_INVALID          = 3     /**< Invalid value       */
+} bsl_sca_lut_t;
+
+/** Scaler control parameter structure array size */
+enum _bslvs_lut {
+	HDMITX_VSLUT_COEFF_NUM         = 45
+};
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerSetFieldOrder() parameter types
+ * */
+/** IntExt values */
+typedef enum {
+	HDMITX_INTEXT_INTERNAL         = 0,    /**< Internal  */
+	HDMITX_INTEXT_EXTERNAL         = 1,    /**< External  */
+	HDMITX_INTEXT_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_INTEXT_INVALID          = 3     /**< Invalid   */
+} bsl_int_ext_t;
+
+/** TopSel values */
+typedef enum {
+	HDMITX_TOPSEL_INTERNAL         = 0,    /**< Internal  */
+	HDMITX_TOPSEL_VRF              = 1,    /**< VRF       */
+	HDMITX_TOPSEL_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_TOPSEL_INVALID          = 3     /**< Invalid   */
+} bsl_top_sel_t;
+
+/** TopTgl values */
+typedef enum {
+	HDMITX_TOPTGL_NO_ACTION        = 0,    /**< NO action */
+	HDMITX_TOPTGL_TOGGLE           = 1,    /**< Toggle    */
+	HDMITX_TOPTGL_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_TOPTGL_INVALID          = 3     /**< Invalid   */
+} bsl_top_tgl_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerSetPhase() parameter types
+ * */
+/** Phases_h values */
+typedef enum {
+	HDMITX_H_PHASES_16        = 0,    /**< 15 horizontal phases */
+	HDMITX_H_PHASES_15        = 1,    /**< 16 horizontal phases */
+	HDMITX_H_PHASES_INVALID   = 2     /**< Invalid   */
+} bsl_hphases_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerSetFine() parameter types
+ * */
+/** Reference pixel values */
+enum _bsl_scaler_fine_pixel_limits {
+	HDMITX_SCALER_FINE_PIXEL_MIN        = 0x0000,
+	HDMITX_SCALER_FINE_PIXEL_MAX        = 0x1FFF,
+	HDMITX_SCALER_FINE_PIXEL_NO_CHANGE  = 0x2000,
+	HDMITX_SCALER_FINE_PIXEL_INVALID    = 0x2001
+};
+
+/** Reference line values */
+enum _bsl_scaler_fine_line_limits {
+	HDMITX_SCALER_FINE_LINE_MIN         = 0x0000,
+	HDMITX_SCALER_FINE_LINE_MAX         = 0x07FF,
+	HDMITX_SCALER_FINE_LINE_NO_CHANGE   = 0x0800,
+	HDMITX_SCALER_FINE_LINE_INVALID     = 0x0801
+};
+/*============================================================================*/
+/**
+ * bslTDA9984ScalerSetSync() parameter types
+ * */
+/** Video sync method */
+typedef enum {
+	HDMITX_VSMETH_V_H          = 0,    /**< V and H    */
+	HDMITX_VSMETH_V_XDE        = 1,    /**< V and X-DE */
+	HDMITX_VSMETH_NO_CHANGE    = 2,    /**< No change  */
+	HDMITX_VSMETH_INVALID      = 3     /**< Invalid    */
+} bsl_vs_meth_t;
+
+/** Line/pixel counters sync */
+typedef enum {
+	HDMITX_VSONCE_EACH_FRAME   = 0,    /**< Sync on each frame */
+	HDMITX_VSONCE_ONCE         = 1,    /**< Sync once only     */
+	HDMITX_VSONCE_NO_CHANGE    = 2,    /**< No change  */
+	HDMITX_VSONCE_INVALID      = 3     /**< Invalid    */
+} bsl_vs_once_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984TmdsSetOutputs() parameter types
+ * */
+/** TMDS output mode */
+typedef enum {
+	HDMITX_TMDSOUT_NORMAL      = 0,    /**< Normal outputs   */
+	HDMITX_TMDSOUT_NORMAL1     = 1,    /**< Normal outputs, same as 0  */
+	HDMITX_TMDSOUT_FORCED0     = 2,    /**< Forced 0 outputs */
+	HDMITX_TMDSOUT_FORCED1     = 3,    /**< Forced 1 outputs */
+	HDMITX_TMDSOUT_INVALID     = 4     /**< Invalid          */
+} bsl_tmds_out_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984TmdsSetSerializer() parameter types
+ * */
+/** Serializer phase limits */
+enum _bsl_tmds_phase {
+	HDMITX_TMDSPHASE_MIN       = 0,
+	HDMITX_TMDSPHASE_MAX       = 15,
+	HDMITX_TMDSPHASE_INVALID   = 16
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984TestSetPattern() parameter types
+ * */
+/** Test pattern types */
+typedef enum {
+	HDMITX_PATTERN_OFF     = 0, /**< Insert test pattern     */
+	HDMITX_PATTERN_CBAR4   = 1, /**< Insert 4-bar colour bar */
+	HDMITX_PATTERN_CBAR8   = 2, /**< Insert 8-bar colour bar */
+	HDMITX_PATTERN_BLUE	   = 3, /**< Insert Blue screen		 */
+	HDMITX_PATTERN_BLACK   = 4, /**< Insert Blue screen		 */
+	HDMITX_PATTERN_INVALID = 5  /**< Invalid pattern		 */
+} bsl_test_pattern_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984TestSetMode() parameter types
+ * */
+/** Test modes */
+typedef enum {
+	HDMITX_TESTMODE_PAT     = 0,/**< Insert test pattern                    */
+	HDMITX_TESTMODE_656     = 1,/**< Inject CCIR-656 video via audio port   */
+	HDMITX_TESTMODE_SERPHOE = 2,/**< Activate srl_tst_ph2_o & srl_tst_ph3_o */
+	HDMITX_TESTMODE_NOSC    = 3,/**< Input nosc predivider = PLL-ref input  */
+	HDMITX_TESTMODE_HVP     = 4,/**< Test high voltage protection cells     */
+	HDMITX_TESTMODE_PWD     = 5,/**< Test PLLs in sleep mode                */
+	HDMITX_TESTMODE_DIVOE   = 6,/**< Enable scaler PLL divider test output  */
+	HDMITX_TESTMODE_INVALID = 7 /**< Invalid test */
+} bsl_test_mode_t;
+
+/** Test states */
+typedef enum {
+	HDMITX_TESTSTATE_OFF     = 0,  /**< Disable the selected test */
+	HDMITX_TESTSTATE_ON      = 1,  /**< Enable the selected test  */
+	HDMITX_TESTSTATE_INVALID = 2   /**< Invalid value */
+} bsl_test_state_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetBlanking() parameter types
+ * */
+/** Blankit Source */
+typedef enum {
+	HDMITX_BLNKSRC_NOT_DE       = 0,       /**< Source=Not DE        */
+	HDMITX_BLNKSRC_VS_HS        = 1,       /**< Source=VS And HS     */
+	HDMITX_BLNKSRC_VS_NOT_HS    = 2,       /**< Source=VS And Not HS */
+	HDMITX_BLNKSRC_VS_HEMB_VEMB = 3,       /**< Source=Hemb And Vemb */
+	HDMITX_BLNKSRC_NO_CHANGE    = 4,       /**< No change */
+	HDMITX_BLNKSRC_INVALID      = 5        /**< Invalid   */
+} bsl_blnk_src_t;
+
+/** Blanking Codes */
+typedef enum {
+	HDMITX_BLNKCODE_ALL_0       = 0,       /**< Code=All Zero */
+	HDMITX_BLNKCODE_RGB444      = 1,       /**< Code=RGB444   */
+	HDMITX_BLNKCODE_YUV444      = 2,       /**< Code=YUV444   */
+	HDMITX_BLNKCODE_YUV422      = 3,       /**< Code=YUV422   */
+	HDMITX_BLNKCODE_NO_CHANGE   = 4,       /**< No change */
+	HDMITX_BLNKCODE_INVALID     = 5        /**< Invalid   */
+} bsl_blnk_code_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetConfig() parameter types
+ * */
+/** Sample edge */
+typedef enum {
+	HDMITX_PIXEDGE_CLK_POS      = 0,        /**< Pixel Clock Positive Edge */
+	HDMITX_PIXEDGE_CLK_NEG      = 1,        /**< Pixel Clock Negative Edge */
+	HDMITX_PIXEDGE_NO_CHANGE    = 2,        /**< No Change */
+	HDMITX_PIXEDGE_INVALID      = 3         /**< Invalid   */
+} bsl_pix_edge_t;
+
+/** Upsample modes */
+typedef enum {
+	HDMITX_UPSAMPLE_BYPASS      = 0,        /**< Bypass */
+	HDMITX_UPSAMPLE_COPY        = 1,        /**< Copy */
+	HDMITX_UPSAMPLE_INTERPOLATE = 2,        /**< Interpolate */
+	/**< Auto: driver chooses best value */
+	HDMITX_UPSAMPLE_AUTO        = 3,
+	HDMITX_UPSAMPLE_NO_CHANGE   = 4,        /**< No Change */
+	HDMITX_UPSAMPLE_INVALID     = 5         /**< Invalid   */
+} bsl_upsample_mode_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetFine() parameter types
+ * */
+/** Subpacket count */
+typedef enum {
+	HDMITX_PIXSUBPKT_FIX_0      = 0,        /**< Fix At 0 */
+	HDMITX_PIXSUBPKT_FIX_1      = 1,        /**< Fix At 1 */
+	HDMITX_PIXSUBPKT_FIX_2      = 2,        /**< Fix At 2 */
+	HDMITX_PIXSUBPKT_FIX_3      = 3,        /**< Fix At 3 */
+	HDMITX_PIXSUBPKT_SYNC_FIRST = 4,        /**< First Sync value */
+	HDMITX_PIXSUBPKT_SYNC_HEMB  = 4,        /**< Sync By Hemb */
+	HDMITX_PIXSUBPKT_SYNC_DE    = 5,        /**< Sync By Rising Edge DE */
+	HDMITX_PIXSUBPKT_SYNC_HS    = 6,        /**< Sync By Rising Edge HS */
+	HDMITX_PIXSUBPKT_NO_CHANGE  = 7,        /**< No Change */
+	HDMITX_PIXSUBPKT_INVALID    = 8,        /**< Invalid   */
+	HDMITX_PIXSUBPKT_SYNC_FIXED = 3         /**< Not used as a parameter value,
+ *  but used internally when
+ *  Fix at 0/1/2/3 values are set */
+} bsl_pix_subpkt_t;
+
+/** Toggling */
+typedef enum {
+	HDMITX_PIXTOGL_NO_ACTION    = 0,        /**< No Action  */
+	HDMITX_PIXTOGL_ENABLE       = 1,        /**< Toggle     */
+	HDMITX_PIXTOGL_NO_CHANGE    = 2,        /**< No Change  */
+	HDMITX_PIXTOGL_INVALID      = 3         /**< Invalid    */
+} bsl_pix_togl_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetMapping() parameter types
+ * */
+/** Video input port parameter structure array size and limits */
+enum _bsl_vin_port_map {
+	HDMITX_VIN_PORT_MAP_TABLE_LEN    = 6,
+
+	HDMITX_VIN_PORT_SWAP_NO_CHANGE   = 6,
+	HDMITX_VIN_PORT_SWAP_INVALID     = 7,
+
+	HDMITX_VIN_PORT_MIRROR_NO_CHANGE = 2,
+	HDMITX_VIN_PORT_MIRROR_INVALID   = 3
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetSyncAuto() parameter types
+ * */
+/** Sync source - was Embedded sync HDMITX_PIXEMBSYNC_ */
+typedef enum {
+	HDMITX_SYNCSRC_EMBEDDED  = 0,        /**< Embedded sync */
+	HDMITX_SYNCSRC_EXT_VREF  = 1,        /**< External sync Vref, Href, Fref */
+	HDMITX_SYNCSRC_EXT_VS    = 2,        /**< External sync Vs, Hs */
+	HDMITX_SYNCSRC_NO_CHANGE = 3,        /**< No Change     */
+	HDMITX_SYNCSRC_INVALID   = 4         /**< Invalid       */
+} bsl_sync_source_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoInSetSyncManual() parameter types
+ * */
+/** Video output frame pixel values */
+enum _bsl_vout_fine_pixel_limits {
+	HDMITX_VOUT_FINE_PIXEL_MIN        = 0x0000,
+	HDMITX_VOUT_FINE_PIXEL_MAX        = 0x1FFF,
+	HDMITX_VOUT_FINE_PIXEL_NO_CHANGE  = 0x2000,
+	HDMITX_VOUT_FINE_PIXEL_INVALID    = 0x2001
+};
+
+/** Video output frame line values */
+enum _bsl_vout_fine_line_limits {
+	HDMITX_VOUT_FINE_LINE_MIN         = 0x0000,
+	HDMITX_VOUT_FINE_LINE_MAX         = 0x07FF,
+	HDMITX_VOUT_FINE_LINE_NO_CHANGE   = 0x0800,
+	HDMITX_VOUT_FINE_LINE_INVALID     = 0x0801
+};
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoOutSetConfig() parameter types
+ * */
+/** Prefilter */
+typedef enum {
+	HDMITX_VOUT_PREFIL_OFF         = 0,    /**< Off */
+	HDMITX_VOUT_PREFIL_121         = 1,    /**< 121 */
+	HDMITX_VOUT_PREFIL_109         = 2,    /**< 109 */
+	HDMITX_VOUT_PREFIL_CCIR601     = 3,    /**< CCIR601   */
+	HDMITX_VOUT_PREFIL_NO_CHANGE   = 4,    /**< No Change */
+	HDMITX_VOUT_PREFIL_INVALID     = 5     /**< Invalid   */
+} bsl_vout_prefil_t;
+
+/** YUV blanking */
+typedef enum {
+	HDMITX_VOUT_YUV_BLNK_16        = 0,    /**< 16 */
+	HDMITX_VOUT_YUV_BLNK_0         = 1,    /**< 0  */
+	HDMITX_VOUT_YUV_BLNK_NO_CHANGE = 2,    /**< No Change */
+	HDMITX_VOUT_YUV_BLNK_INVALID   = 3     /**< Invalid   */
+} bsl_vout_yuv_blnk_t;
+
+/** Video quantization range */
+typedef enum {
+	HDMITX_VOUT_QRANGE_FS          = 0,    /**< Full Scale */
+	HDMITX_VOUT_QRANGE_RGB_YUV     = 1,    /**< RGB Or YUV */
+	HDMITX_VOUT_QRANGE_YUV         = 2,    /**< YUV        */
+	HDMITX_VOUT_QRANGE_NO_CHANGE   = 3,    /**< No Change  */
+	HDMITX_VOUT_QRANGE_INVALID     = 4     /**< Invalid    */
+} bsl_vout_qrange_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoOutSetSync() parameter types
+ * */
+/** Video sync source */
+typedef enum {
+	HDMITX_VSSRC_INTERNAL      = 0,    /**< Internal  */
+	HDMITX_VSSRC_EXTERNAL      = 1,    /**< External  */
+	HDMITX_VSSRC_NO_CHANGE     = 2,    /**< No change */
+	HDMITX_VSSRC_INVALID       = 3     /**< Invalid   */
+} bsl_vs_src_t;
+
+/** Video sync toggle */
+typedef enum {
+	HDMITX_VSTGL_TABLE         = 0,    /**< Vs/Hs polarity from table */
+	HDMITX_VSTGL_UNUSED_1      = 1,    /**< Unused          */
+	HDMITX_VSTGL_UNUSED_2      = 2,    /**< Unused          */
+	HDMITX_VSTGL_UNUSED_3      = 3,    /**< Unused          */
+	HDMITX_VSTGL_NO_ACTION     = 4,    /**< No toggle       */
+	HDMITX_VSTGL_HS            = 5,    /**< Toggle Hs       */
+	HDMITX_VSTGL_VS            = 6,    /**< Toggle Vs       */
+	HDMITX_VSTGL_HS_VS         = 7,    /**< Toggle Hs & Vs  */
+	HDMITX_VSTGL_NO_CHANGE     = 8,    /**< No change       */
+	HDMITX_VSTGL_INVALID       = 9     /**< Invalid         */
+} bsl_vs_tgl_t;
+
+/*============================================================================*/
+/**
+ * bslTDA9984VideoSetInOut() parameter types
+ * */
+/** Pixel repetition values */
+enum _bsl_pix_repeat {
+	HDMITX_PIXREP_NONE       = 0,    /**< No repetition  */
+	HDMITX_PIXREP_MIN        = 0,    /**< 1 repetition   */
+
+	HDMITX_PIXREP_0 = 0,
+	HDMITX_PIXREP_1 = 1,
+	HDMITX_PIXREP_2 = 2,
+	HDMITX_PIXREP_3 = 3,
+	HDMITX_PIXREP_4 = 4,
+	HDMITX_PIXREP_5 = 5,
+	HDMITX_PIXREP_6 = 6,
+	HDMITX_PIXREP_7 = 7,
+	HDMITX_PIXREP_8 = 8,
+	HDMITX_PIXREP_9 = 9,
+
+	HDMITX_PIXREP_MAX        = 9,    /**< 10 repetitions */
+	/**< Default repetitions for output format */
+	HDMITX_PIXREP_DEFAULT    = 10,
+	HDMITX_PIXREP_NO_CHANGE  = 11,   /**< No change */
+	HDMITX_PIXREP_INVALID    = 12    /**< Invalid   */
+};
+
+/** Matrix modes */
+typedef enum {
+	HDMITX_MATMODE_OFF       = 0,    /**< Off  */
+	HDMITX_MATMODE_AUTO      = 1,    /**< Auto */
+	HDMITX_MATMODE_NO_CHANGE = 2,    /**< No change */
+	HDMITX_MATMODE_INVALID   = 3     /**< Invalid   */
+} bsl_mat_mode_t;
+
+/** Datapath bitwidth */
+typedef enum {
+	HDMITX_VOUT_DBITS_12           = 0,    /**< 12 bits */
+	HDMITX_VOUT_DBITS_8            = 1,    /**< 8 bits  */
+	HDMITX_VOUT_DBITS_10           = 2,    /**< 10 bits */
+	HDMITX_VOUT_DBITS_NO_CHANGE    = 3,    /**< No change */
+	HDMITX_VOUT_DBITS_INVALID      = 4     /**< Invalid   */
+} bsl_vout_dbits_t;
+
+/** Color depth */
+typedef enum {
+	HDMITX_COLORDEPTH_24           = 0,    /**< 24 bits per pixel */
+	HDMITX_COLORDEPTH_30           = 1,    /**< 30 bits per pixel */
+	HDMITX_COLORDEPTH_36           = 2,    /**< 36 bits per pixel */
+	HDMITX_COLORDEPTH_48           = 3,    /**< 48 bits per pixel */
+	HDMITX_COLORDEPTH_NO_CHANGE    = 4,    /**< No change */
+	HDMITX_COLORDEPTH_INVALID      = 5     /**< Invalid   */
+} bsl_color_depth;
+
+/*============================================================================*/
+/**
+ * bslTDA9984MatrixSetInputOffset() parameter type
+ * */
+/** Parameter structure array size */
+enum _bsl_mat_offset {
+	HDMITX_MAT_OFFSET_NUM = 3
+};
+
+/** \brief The bslTDA9984MatrixSetInputOffset() parameter structure */
+typedef struct _bsl_mat_offset_t {
+	/** Offset array  (values -1024 to +1023) */
+	s16 offset[HDMITX_MAT_OFFSET_NUM];
+} bsl_mat_offset_t;
+
+/** Matrix numeric limits */
+enum _bsl_mat_limits {
+	HDMITX_MAT_OFFSET_MIN      = -1024,
+	HDMITX_MAT_OFFSET_MAX      = 1023
+};
+
+/*============================================================================*/
+/**
+ * tdaPowerSetState() and tdaPowerGetState() parameter types
+ * */
+typedef enum {
+	HDMITX_POWER_STATE_STAND_BY             = 0,   /**< Stand by mode        */
+	HDMITX_POWER_STATE_SLEEP_MODE           = 1,   /**< Sleep mode           */
+	HDMITX_POWER_STATE_ON                   = 2,   /**< On mode      */
+	HDMITX_POWER_STATE_INVALID              = 3    /**< Invalid format       */
+} bsl_power_state_t;
+
+/**
+ * \brief Structure describing gamut metadata packet (P0 or P1 profiles)
+ * */
+typedef struct {
+	u8  HB[3];  /**< Header bytes (HB0, HB1 & HB2) */
+	u8  PB[28]; /**< Payload bytes 0..27 */
+} bsl_pkt_gamut_t;
+
+/**
+ * \brief Structure describing RAW AVI infoframe
+ * */
+typedef struct {
+	u8  HB[3];  /**< Header bytes (HB0, HB1 & HB2) */
+	u8  PB[28]; /**< Payload bytes 0..27 */
+} bsl_pkt_raw_avi_t;
+
+/** Sink category */
+typedef enum {
+	HDMITX_SINK_CAT_NOT_REPEATER    = 0, /**< Not repeater  */
+	HDMITX_SINK_CAT_REPEATER        = 1, /**< repeater      */
+	HDMITX_SINK_CAT_INVALID         = 3  /**< Invalid       */
+} bsl_sink_category_t;
+
+typedef struct {
+	bool   latency_available;
+	bool   ilatency_available;
+	u8  edidvideo_latency;
+	u8  edidaudio_latency;
+	u8  edid_ivideo_latency;
+	u8  edid_iaudio_latency;
+
+} bsl_edid_latency_t;
+
+/**
+ * \brief Structure defining additional VSDB data
+ * */
+typedef struct {
+	u8 max_tmds_clock;      /* maximum supported TMDS clock */
+	u8 cnc0;              /* content type Graphics (text) */
+	u8 cnc1;              /* content type Photo */
+	u8 cnc2;              /* content type Cinema */
+	u8 cnc3;              /* content type Game */
+	u8 hdmi_video_present;  /* additional video format */
+	u8 h3dpresent;        /* 3D support by the HDMI Sink */
+	u8 h3dmulti_present;   /* 3D multi strctures present */
+	/* additional info for the values in the image size area */
+	u8 image_size;
+	u8 hdmi3dlen;         /* total length of 3D video formats */
+	u8 hdmi_vic_len;        /* total length of extended video formats */
+	u8 ext3ddata[21];     /* max_len-10, ie: 31-10=21 */
+} bsl_edid_extra_vsdb_data_t;
+
+/**
+ * \brief Enum defining possible quantization range
+ * */
+typedef enum {
+	HDMITX_VQR_DEFAULT = 0, /* Follow HDMI spec. */
+	HDMITX_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
+	HDMITX_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
+} bsl_vqr_t;
+
+#endif /* BSLHDMITX_TYPES_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx.h b/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx.h
new file mode 100755
index 0000000..2fc9b53
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx.h
@@ -0,0 +1,4202 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl.h
+ *
+ * \version       $Revision: 41 $
+ *
+ * \date          $Date: 17/10/07 14:11 $
+ *
+ * \brief         BSL driver component API for the TDA998x HDMI Transmitter
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc,
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: bsl.h $
+ *
+ * *****************  Version 41  ****************
+ * User: B.Vereecke     Date: 17/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR872 : add new formats, 1080p24/25/30
+ *
+ * *****************  Version 40  *****************
+ * User: B.Vereecke      Date: 17/07/07   Time: 10:30
+ * Updated in $/Source/bsl/Inc
+ * PR217 - Add a new Pattern type in bslTestPattern_t
+ *			it is used for set the bluescreen
+ *
+ * *****************  Version 39  *****************
+ * User: J. Lamotte      Date: 13/06/07   Time: 12:00
+ * Updated in $/Source/bsl/Inc
+ * PR397 - Merge with PR322
+ *       add 9981 API definitions for 9983
+ *       (return NOT_SUPPORTED)
+ *
+ * *****************  Version 38  *****************
+ * User: G. BURNOUF      Date: 08/06/07   Time: 10:40
+ * Updated in $/Source/bsl/Inc
+ * PR347 - Add new formatPC
+ *
+ * *****************  Version 37  *****************
+ * User: J/ Lamotte         Date: 24/04/07   Time: 10:40
+ * Updated in $/Source/bsl/Inc
+ * PR50 - Change comment for bslSetAudioPortConfig
+ *        and bslSetVideoPortConfig functions (TDA9981)
+ *
+ * *****************  Version 36  *****************
+ * User: Burnouf         Date: 16/04/07   Time: 11:30
+ * Updated in $/Source/bsl/Inc
+ * PR50 - add new API bslRxSenseGetStatus for TDA9981
+ *      - add new API only for debug bslFlagSwInt for TDA9981
+ *      - add new index for the new callback interrupt of TDA9981
+ *
+ * *****************  Version 35  *****************
+ * User: J. Lamotte      Date: 16/04/07   Time: 11:30
+ * Updated in $/Source/bsl/Inc
+ * PR50 - add video and audio port configuration for TDA9981
+ *        bslSetAudioPortConfig and
+ *        bslSetVideoPortConfig
+ *      - define HDMITX_UNITS_MAX (in bsl_local.h before)
+ *
+ * *****************  Version 34  *****************
+ * User: J. Lamotte    Date: 25/04/07   Time: 14:40
+ * Updated in $/Source/bsl/Inc
+ * PR273 - add PLL configuration before soft reset
+ *         in function bslInit (2 more parameters)
+ *
+ * *****************  Version 33  *****************
+ * User: C. Logiou      Date: 08/03/07   Time: 16:52
+ * Updated in $/Source/bsl/Inc
+ * PR214 - add new input format repeated 480i/576i
+ *
+ * *****************  Version 32  *****************
+ * User: burnouf      Date: 06/02/07   Time: 16:52
+ * Updated in $/Source/bsl/Inc
+ * PR49 - add PC Formats
+ *
+ * *****************  Version 31  *****************
+ * User: burnouf      Date: 08/01/07   Time: 15:33
+ * Updated in $/Source/bsl/Inc
+ * PR72 - add function bslHwGetCapabilities
+ *
+ * *****************  Version 30  *****************
+ * User: Djw          Date: 17/11/06   Time: 18:48
+ * Updated in $/Source/bsl/Inc
+ * PNF72 - Corrections to doxygen info for
+ * bslAudioOutSetChanStatus
+ *
+ * *****************  Version 28  *****************
+ * User: Mayhew       Date: 10/11/06   Time: 10:35
+ * Updated in $/Source/bsl/Inc
+ * PNF68 Add note to bslHdcpConfigure for disabling authentication
+ * checking
+ *
+ * *****************  Version 27  *****************
+ * User: Mayhew       Date: 10/11/06   Time: 10:03
+ * Updated in $/Source/bsl/Inc
+ * PNF68 HdcpCheck params thisCheck and maxChecks replaced by
+ * uTimeSinceLastCallMs, and Check_t values reordered
+ * PNF68 Params uCheckIntervalMs and uChecksToDo added to
+ * bslHdcpConfigure
+ * PNF68 bslHwHandleTimer prototype removed
+ *
+ * *****************  Version 26  *****************
+ * User: Djw          Date: 9/11/06    Time: 18:05
+ * Updated in $/Source/bsl/Inc
+ * PNF69 Add bslAudioOutSetChanStatus and
+ * bslAudioOutSetChanStatusMapping
+ *
+ * *****************  Version 25  *****************
+ * User: Mayhew       Date: 6/11/06    Time: 17:46
+ * Updated in $/Source/bsl/Inc
+ * PNF68 Add bslHwHandleTimer
+ *
+ * *****************  Version 23  *****************
+ * User: Djw          Date: 25/10/06   Time: 13:41
+ * Updated in $/Source/bsl/Inc
+ * PNF58 Added vinMode parameter to bslVideoInSetSyncAuto
+ *
+ * *****************  Version 21  *****************
+ * User: Mayhew       Date: 13/10/06   Time: 11:01
+ * Updated in $/Source/bsl/Inc
+ * PNF37 Move arguments from bslVideoInSetConfig,
+ * bslVideoOutSetSync and bslVideoOutSetFine (deleted)
+ * to new APIs bslVideoInSetSyncAuto/Manual
+ *
+ * *****************  Version 19  *****************
+ * User: Mayhew       Date: 15/09/06   Time: 15:54
+ * Updated in $/Source/bsl/Inc
+ * PNF22 Add HdcpCheck API
+ * PNF23 Add GetOtp API
+ *
+ * *****************  Version 17  *****************
+ * User: Mayhew       Date: 4/09/06    Time: 10:03
+ * Updated in $/Source/bsl/Inc
+ * PNF20: Add HDMITX_HDCP_OPTION_FORCE_VSLOW_DDC
+ *
+ * *****************  Version 15  *****************
+ * User: Djw          Date: 23/08/06   Time: 18:18
+ * Updated in $/Source/bsl/Inc
+ * Updated comments for bslctsRef_t enum.
+ *
+ * *****************  Version 14  *****************
+ * User: Djw          Date: 21/08/06   Time: 14:02
+ * Updated in $/Source/bsl/Inc
+ * Correction to bslTmdsOut_t enum.
+ *
+ * *****************  Version 13  *****************
+ * User: Mayhew       Date: 10/07/06   Time: 12:31
+ * Updated in $/Source/bsl/Inc
+ * Fix Doxygen comment warnings
+ *
+ * *****************  Version 11  *****************
+ * User: Mayhew       Date: 30/06/06   Time: 12:40
+ * Updated in $/Source/bsl/Inc
+ * HDMITX_EDID_SINK_ type replaced with HDMITX_SINK_ type for clarity
+ *
+ * *****************  Version 9  *****************
+ * User: Djw          Date: 16/06/06   Time: 12:05
+ * Updated in $/Source/bsl/Inc
+ * Added flag to Init to support use of alternate i2c address for EDID.
+ *
+ * *****************  Version 7  *****************
+ * User: Mayhew       Date: 5/06/06    Time: 14:28
+ * Updated in $/Source/bsl/Inc
+ * Add bslHdcpGetT0FailState, bslSysTimerWait. Move error
+ * codes from _local.h.
+ *
+ * *****************  Version 5  *****************
+ * User: Djw          Date: 24/05/06   Time: 11:15
+ * Updated in $/Source/bsl/Inc
+ * Added Infoframe packet APIs
+ *
+ * *****************  Version 4  *****************
+ * User: Mayhew       Date: 15/05/06   Time: 15:56
+ * Updated in $/Source/bsl/Inc
+ * Correct the order of values in bslVoutDbits_t. Add mask to
+ * bslHdcpOptions_t.
+ *
+ * *****************  Version 3  *****************
+ * User: Mayhew       Date: 10/05/06   Time: 16:58
+ * Updated in $/Source/bsl/Inc
+ * Added HDCP APIs, ScalerGetMode and HwStartup
+ *
+ * *****************  Version 2  *****************
+ * User: Mayhew       Date: 11/04/06   Time: 14:20
+ * Updated in $/Source/bsl/Inc
+ * Add HDMITX_UPSAMPLE_AUTO
+ *
+ * *****************  Version 1  *****************
+ * User: Mayhew       Date: 4/04/06    Time: 16:27
+ * Created in $/Source/bsl/Inc
+ * Driver API phase 2
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef BSLHDMITX_H
+#define BSLHDMITX_H
+
+/*============================================================================*/
+/*                       COMPILER COMMAND LINE BUILD OPTIONS                  */
+/*                                                                            */
+/* #define          PC Build            8051 Build                            */
+/* CONST_DAT        const               code                                  */
+/* RAM_DAT          (blank)             xdata                                 */
+/* FUNC_PTR         (blank)             code                                  */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+#include "tmNxCompId.h"
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/**
+ * The maximum number of supported HDMI Transmitter units
+ * */
+#define HDMITX_UNITS_MAX       2
+
+/** \name Errors
+ *  The group of error codes returned by all API and internal functions
+ * */
+/*@{*/
+/** The base offset for all error codes.
+ *  This needs defining as non-zero if this component is integrated with others
+ *  and all component error ranges are to be kept separate.
+ * */
+#define ERR_HDMI_BASE	0x00
+
+/** Define the OK code if not defined already */
+#ifndef TM_OK
+#define TM_OK   0
+#endif
+
+/** SW interface compatibility error */
+#define ERR_HDMI_COMPATIBILITY            (ERR_HDMI_BASE + 0x001U)
+
+/** SW major version error */
+#define ERR_HDMI_MAJOR_VERSION            (ERR_HDMI_BASE + 0x002U)
+
+/** SW component version error */
+#define ERR_HDMI_COMP_VERSION             (ERR_HDMI_BASE + 0x003U)
+
+/** Invalid device unit number */
+#define ERR_HDMI_BAD_UNIT_NUMBER          (ERR_HDMI_BASE + 0x005U)
+
+/** Invalid input parameter other than unit number */
+#define ERR_HDMI_BAD_PARAMETER            (ERR_HDMI_BASE + 0x009U)
+
+/** Inconsistent input parameters */
+#define ERR_HDMI_INCONSISTENT_PARAMS      (ERR_HDMI_BASE + 0x010U)
+
+/** Component is not initialized */
+#define ERR_HDMI_NOT_INITIALIZED          (ERR_HDMI_BASE + 0x011U)
+
+/** Command not supported for current device */
+#define ERR_HDMI_NOT_SUPPORTED            (ERR_HDMI_BASE + 0x013U)
+
+/** Initialization failed */
+#define ERR_HDMI_INIT_FAILED              (ERR_HDMI_BASE + 0x014U)
+
+/** Component is busy and cannot do a new operation */
+#define ERR_HDMI_BUSY                     (ERR_HDMI_BASE + 0x015U)
+
+/** I2C read error */
+#define ERR_HDMI_I2C_READ                 (ERR_HDMI_BASE + 0x017U)
+
+/** I2C write error */
+#define ERR_HDMI_I2C_WRITE                (ERR_HDMI_BASE + 0x018U)
+
+/** Assertion failure */
+#define ERR_HDMI_ASSERTION                (ERR_HDMI_BASE + 0x049U)
+
+/** Bad EDID block checksum */
+#define ERR_HDMI_INVALID_STATE            (ERR_HDMI_BASE + 0x066U)
+#define ERR_HDMI_INVALID_CHECKSUM         ERR_HDMI_INVALID_STATE
+
+/** No connection to HPD pin */
+#define ERR_HDMI_NULL_CONNECTION          (ERR_HDMI_BASE + 0x067U)
+
+/** Not allowed in DVI mode */
+#define ERR_HDMI_OPERATION_NOT_PERMITTED  (ERR_HDMI_BASE + 0x068U)
+
+/* Maximum error code defined */
+#define ERR_HDMI_MAX              ERR_HDMI_OPERATION_NOT_PERMITTED
+
+/*@}*/
+
+/** size descriptor block of monitor descriptor */
+#define EDID_MONITOR_DESCRIPTOR_SIZE   13
+
+#define NUMBER_DTD_STORED       10
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/** Sink category */
+typedef enum {
+	HDMITX_SINK_CAT_NOT_REPEATER    = 0, /**< Not repeater  */
+	HDMITX_SINK_CAT_REPEATER        = 1, /**< repeater      */
+	HDMITX_SINK_CAT_INVALID         = 3  /**< Invalid       */
+} bsl_sink_category_t;
+
+/*============================================================================*/
+/**
+ * basic display parameters structure
+ * */
+typedef struct _bsl_edid_bdparam_t {
+	/**< Video Input Definition                       */
+	u8   u_video_input_def;
+	/**< Max. Horizontal Image Size in cm             */
+	u8   u_max_horizontal_size;
+	/**< Max. Vertical Image Size in cm               */
+	u8   u_max_vertical_size;
+	/**< Gamma                                        */
+	u8   u_gamma;
+	/**< Feature support                              */
+	u8   u_feature_support;
+} bsl_edid_bdparam_t;
+
+/*============================================================================*/
+/**
+ * First monitor descriptor structure
+ * */
+typedef struct _bsl_edid_first_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Monitor Name                                   */
+	u8   u_monitor_name[EDID_MONITOR_DESCRIPTOR_SIZE];
+} bsl_edid_first_md_t;
+
+/*============================================================================*/
+/**
+ * Second monitor descriptor structure
+ * */
+typedef struct _bsl_edid_second_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Min vertical rate in Hz                        */
+	u8   u_min_vertical_rate;
+	/**< Max vertical rate in Hz                        */
+	u8   u_max_vertical_rate;
+	/**< Min horizontal rate in Hz                      */
+	u8   u_min_horizontal_rate;
+	/**< Max horizontal rate in Hz                      */
+	u8   u_max_horizontal_rate;
+	/**< Max suuported pixel clock rate in MHz          */
+	u8   u_max_supported_pixel_clk;
+} bsl_edid_second_md_t;
+
+/*============================================================================*/
+/**
+ * Other monitor descriptor structure
+ * */
+typedef struct _bsl_edid_other_md_t {
+	/**< true when parameters of struct are available   */
+	bool    b_desc_record;
+	/**< Other monitor Descriptor                       */
+	u8   u_other_descriptor[EDID_MONITOR_DESCRIPTOR_SIZE];
+} bsl_edid_other_md_t;
+
+/**
+ * \brief System function pointer type, to call user I2C read/write functions
+ * \param slaveAddr     The I2C slave address
+ * \param firstRegister The first device register address to read or write
+ * \param lenData       Length of data to read or write (i.e. no. of registers)
+ * \param pData         Pointer to data to write, or to buffer to receive data
+ * \return              The call result:
+ *                      - 0: the call was successful
+ *                      - ERR_HDMI_I2C_WRITE: failed when writing
+ *                      - ERR_HDMI_I2C_READ:  failed when reading
+ * */
+typedef struct _bsl_sys_args_t {
+	u8 slave_addr;
+	u8 first_register;
+	u8 len_data;
+	u8 *p_data;
+} bsl_sys_args_t;
+typedef error_code_t (FUNC_PTR *pbsl_sys_func_t)
+(bsl_sys_args_t *p_sys_args);
+
+/**
+ * \brief System function pointer type, to call user I2C EDID read function
+ * \param segPtrAddr    The EDID segment pointer address 0 to 7Fh
+ * \param segPtr        The EDID segment pointer 0 to 7Fh
+ * \param dataRegAddr   The EDID data register address 0 to 7Fh
+ * \param wordOffset    The first word offset 0 to FFh to read
+ * \param lenData       Length of data to read (i.e. number of registers),
+ *                        1 to max starting at wordOffset
+ * \param pData         Pointer to buffer to receive lenData data bytes
+ * \return              The call result:
+ *                      - 0: the call was successful
+ *                      - ERR_HDMI_I2C_WRITE: failed when writing
+ *                      - ERR_HDMI_I2C_READ:  failed when reading
+ * */
+typedef struct _bsl_sys_args_edid_t {
+	u8 seg_ptr_addr;
+	u8 seg_ptr;
+	u8 data_reg_addr;
+	u8 word_offset;
+	u8 len_data;
+	u8 *p_data;
+} bsl_sys_args_edid_t;
+typedef error_code_t (FUNC_PTR *pbsl_sys_func_edid_t)
+(bsl_sys_args_edid_t *p_sys_args);
+
+/*============================================================================*/
+/*
+ * Timer function pointer type, to call an application timer
+ * Parameter ms: Delay in milliseconds required
+ * */
+typedef void(FUNC_PTR *pbsl_sys_func_timer_t)(u16 ms);
+
+/*============================================================================*/
+/*
+ * Callback function pointer type, to call a user interrupt handler
+ * Parameter txUnit: The transmitter unit that interrupted, 0 to max
+ * */
+typedef void(FUNC_PTR *pbsl_callback_t)(unit_select_t tx_unit);
+
+/*============================================================================*/
+/**
+ * EIA/CEA-861B video format type
+ * */
+typedef enum {
+	/**< Not a valid format...        */
+	HDMITX_VFMT_NULL               = 0,
+	/**< ...or no change required     */
+	HDMITX_VFMT_NO_CHANGE          = 0,
+	/**< Lowest valid format          */
+	HDMITX_VFMT_MIN                = 1,
+	/**< Lowest valid TV format       */
+	HDMITX_VFMT_TV_MIN             = 1,
+	/**< Format 01 640  x 480p  60Hz  */
+	hdmitx_vfmt_01_640x480p_60hz   = 1,
+	/**< Format 02 720  x 480p  60Hz  */
+	hdmitx_vfmt_02_720x480p_60hz   = 2,
+	/**< Format 03 720  x 480p  60Hz  */
+	hdmitx_vfmt_03_720x480p_60hz   = 3,
+	/**< Format 04 1280 x 720p  60Hz  */
+	hdmitx_vfmt_04_1280x720p_60hz  = 4,
+	/**< Format 05 1920 x 1080i 60Hz  */
+	hdmitx_vfmt_05_1920x1080i_60hz = 5,
+	/**< Format 06 720  x 480i  60Hz  */
+	hdmitx_vfmt_06_720x480i_60hz   = 6,
+	/**< Format 07 720  x 480i  60Hz  */
+	hdmitx_vfmt_07_720x480i_60hz   = 7,
+	/**< Format 08 720  x 240p  60Hz  */
+	hdmitx_vfmt_08_720x240p_60hz   = 8,
+	/**< Format 09 720  x 240p  60Hz  */
+	hdmitx_vfmt_09_720x240p_60hz   = 9,
+	/**< Format 10 720  x 480i  60Hz  */
+	hdmitx_vfmt_10_720x480i_60hz   = 10,
+	/**< Format 11 720  x 480i  60Hz  */
+	hdmitx_vfmt_11_720x480i_60hz   = 11,
+	/**< Format 12 720  x 240p  60Hz  */
+	hdmitx_vfmt_12_720x240p_60hz   = 12,
+	/**< Format 13 720  x 240p  60Hz  */
+	hdmitx_vfmt_13_720x240p_60hz   = 13,
+	/**< Format 14 1440 x 480p  60Hz  */
+	hdmitx_vfmt_14_1440x480p_60hz  = 14,
+	/**< Format 15 1440 x 480p  60Hz  */
+	hdmitx_vfmt_15_1440x480p_60hz  = 15,
+	/**< Format 16 1920 x 1080p 60Hz  */
+	hdmitx_vfmt_16_1920x1080p_60hz = 16,
+	/**< Format 17 720  x 576p  50Hz  */
+	hdmitx_vfmt_17_720x576p_50hz   = 17,
+	/**< Format 18 720  x 576p  50Hz  */
+	hdmitx_vfmt_18_720x576p_50hz   = 18,
+	/**< Format 19 1280 x 720p  50Hz  */
+	hdmitx_vfmt_19_1280x720p_50hz  = 19,
+	/**< Format 20 1920 x 1080i 50Hz  */
+	hdmitx_vfmt_20_1920x1080i_50hz = 20,
+	/**< Format 21 720  x 576i  50Hz  */
+	hdmitx_vfmt_21_720x576i_50hz   = 21,
+	/**< Format 22 720  x 576i  50Hz  */
+	hdmitx_vfmt_22_720x576i_50hz   = 22,
+	/**< Format 23 720  x 288p  50Hz  */
+	hdmitx_vfmt_23_720x288p_50hz   = 23,
+	/**< Format 24 720  x 288p  50Hz  */
+	hdmitx_vfmt_24_720x288p_50hz   = 24,
+	/**< Format 25 720  x 576i  50Hz  */
+	hdmitx_vfmt_25_720x576i_50hz   = 25,
+	/**< Format 26 720  x 576i  50Hz  */
+	hdmitx_vfmt_26_720x576i_50hz   = 26,
+	/**< Format 27 720  x 288p  50Hz  */
+	hdmitx_vfmt_27_720x288p_50hz   = 27,
+	/**< Format 28 720  x 288p  50Hz  */
+	hdmitx_vfmt_28_720x288p_50hz   = 28,
+	/**< Format 29 1440 x 576p  50Hz  */
+	hdmitx_vfmt_29_1440x576p_50hz  = 29,
+	/**< Format 30 1440 x 576p  50Hz  */
+	hdmitx_vfmt_30_1440x576p_50hz  = 30,
+	/**< Format 31 1920 x 1080p 50Hz  */
+	hdmitx_vfmt_31_1920x1080p_50hz = 31,
+	/**< Format 32 1920 x 1080p 24Hz  */
+	hdmitx_vfmt_32_1920x1080p_24hz = 32,
+	/**< Format 33 1920 x 1080p 25Hz  */
+	hdmitx_vfmt_33_1920x1080p_25hz = 33,
+	/**< Format 34 1920 x 1080p 30Hz  */
+	hdmitx_vfmt_34_1920x1080p_30hz = 34,
+	/**< Highest valid TV format      */
+	HDMITX_VFMT_TV_MAX             = 34,
+	/**< Lowest TV format without prefetched table */
+	HDMITX_VFMT_TV_NO_REG_MIN	   = 32,
+	/**< Number of TV formats & null  */
+	HDMITX_VFMT_TV_NUM             = 35,
+	/**< Lowest valid PC format       */
+	HDMITX_VFMT_PC_MIN             = 128,
+	/**< PC format 128                */
+	hdmitx_vfmt_pc_640x480p_60hz   = 128,
+	/**< PC format 129                */
+	hdmitx_vfmt_pc_800x600p_60hz   = 129,
+	/**< PC format 130                */
+	hdmitx_vfmt_pc_1152x960p_60hz  = 130,
+	/**< PC format 131                */
+	hdmitx_vfmt_pc_1024x768p_60hz  = 131,
+	/**< PC format 132                */
+	hdmitx_vfmt_pc_1280x768p_60hz  = 132,
+	/**< PC format 133                */
+	hdmitx_vfmt_pc_1280x1024p_60hz = 133,
+	/**< PC format 134                */
+	hdmitx_vfmt_pc_1360x768p_60hz  = 134,
+	/**< PC format 135                */
+	hdmitx_vfmt_pc_1400x1050p_60hz  = 135,
+	/**< PC format 136                */
+	hdmitx_vfmt_pc_1600x1200p_60hz = 136,
+	/**< PC format 137                */
+	hdmitx_vfmt_pc_1024x768p_70hz  = 137,
+	/**< PC format 138                */
+	hdmitx_vfmt_pc_640x480p_72hz   = 138,
+	/**< PC format 139                */
+	hdmitx_vfmt_pc_800x600p_72hz   = 139,
+	/**< PC format 140                */
+	hdmitx_vfmt_pc_640x480p_75hz   = 140,
+	/**< PC format 141                */
+	hdmitx_vfmt_pc_1024x768p_75hz  = 141,
+	/**< PC format 142                */
+	hdmitx_vfmt_pc_800x600p_75hz   = 142,
+	/**< PC format 143                */
+	hdmitx_vfmt_pc_1024x864p_75hz  = 143,
+	/**< PC format 144                */
+	hdmitx_vfmt_pc_1280x1024p_75hz = 144,
+	/**< PC format 145                */
+	hdmitx_vfmt_pc_640x350p_85hz   = 145,
+	/**< PC format 146                */
+	hdmitx_vfmt_pc_640x400p_85hz   = 146,
+	/**< PC format 147                */
+	hdmitx_vfmt_pc_720x400p_85hz   = 147,
+	/**< PC format 148                */
+	hdmitx_vfmt_pc_640x480p_85hz   = 148,
+	/**< PC format 149                */
+	hdmitx_vfmt_pc_800x600p_85hz   = 149,
+	/**< PC format 150                */
+	hdmitx_vfmt_pc_1024x768p_85hz  = 150,
+	/**< PC format 151                */
+	hdmitx_vfmt_pc_1152x864p_85hz  = 151,
+	/**< PC format 152                */
+	hdmitx_vfmt_pc_1280x960p_85hz  = 152,
+	/**< PC format 153                */
+	hdmitx_vfmt_pc_1280x1024p_85hz = 153,
+	/**< PC format 154                */
+	hdmitx_vfmt_pc_1024x768i_87hz  = 154,
+	/**< Highest valid PC format      */
+	HDMITX_VFMT_PC_MAX             = 154,
+	/**< Number of PC formats         */
+	HDMITX_VFMT_PC_NUM     = (1 + 154 - 128)
+} bsl_vid_fmt_t;
+
+/*============================================================================*/
+/*                       EXTERN DATA DEFINITIONS                              */
+/*============================================================================*/
+
+typedef enum {
+	BSLHDMITX_UNKNOWN = 0x00, /**< IC/IP is not recognized */
+	BSLHDMITX_TDA9984,        /**< IC is a TDA9984         */
+	BSLHDMITX_TDA9989,        /**< IC is a TDA9989         */
+	BSLHDMITX_LIPP4200,       /**< IP is a LIPP4200        */
+	BSLHDMITX_TDA9981,        /**< IC is a TDA9981         */
+	BSLHDMITX_TDA9983         /**< IC is a TDA9983         */
+} bsl_version_t;
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+/*============================================================================*/
+/**
+ *    \brief      Reset the Clock Time Stamp generator in HDMI mode only
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ * */
+error_code_t
+bsl_audio_in_reset_cts
+(
+    unit_select_t      tx_unit
+);
+
+/*============================================================================*/
+/**
+ * bslAudioInSetConfig() parameter types
+ * */
+/** Audio input formats */
+typedef enum {
+	HDMITX_AFMT_SPDIF      = 0,         /**< SPDIF */
+	HDMITX_AFMT_I2S        = 1,         /**< I2S   */
+	HDMITX_AFMT_OBA        = 2,         /**< One bit audio */
+	HDMITX_AFMT_DSD        = 3,         /**< DSD           */
+	HDMITX_AFMT_INVALID    = 4          /**< Invalid format*/
+} bsla_fmt_t;
+
+/** DSD clock polarities */
+typedef enum {
+	HDMITX_CLKPOLDSD_ACLK       = 0,    /**< Same as ACLK */
+	HDMITX_CLKPOLDSD_NACLK      = 1,    /**< Not ACLK, i.e. inverted */
+	HDMITX_CLKPOLDSD_NO_CHANGE  = 2,    /**< No change    */
+	HDMITX_CLKPOLDSD_INVALID    = 3     /**< Invalid      */
+} bsl_clk_pol_dsd_t;
+
+/** DSD data swap values */
+typedef enum {
+	HDMITX_SWAPDSD_OFF          = 0,    /**< No swap   */
+	HDMITX_SWAPDSD_ON           = 1,    /**< Swap      */
+	HDMITX_SWAPDSD_NO_CHANGE    = 2,    /**< No change */
+	HDMITX_SWAPDSD_INVALID      = 3     /**< Invalid   */
+} bsl_swap_dsd_t;
+
+/** I2S and DSD channel allocation values */
+enum _bsl_chan {
+	HDMITX_CHAN_MIN        = 0,
+	HDMITX_CHAN_MAX        = 31,
+	HDMITX_CHAN_NO_CHANGE  = 32,
+	HDMITX_CHAN_INVALID    = 33
+};
+
+/** Audio layout values */
+enum _bsl_layout {
+	HDMITX_LAYOUT_MIN       = 0,
+	HDMITX_LAYOUT_MAX       = 1,
+	HDMITX_LAYOUT_NO_CHANGE = 2,
+	HDMITX_LAYOUT_INVALID   = 3
+};
+
+/** Audio FIFO read latency values */
+enum _bsllatency_rd {
+	HDMITX_LATENCY_MIN         = 0x000,
+	HDMITX_LATENCY_MAX         = 0x0FF,
+	HDMITX_LATENCY_NO_CHANGE   = 0x100,
+	HDMITX_LATENCY_INVALID     = 0x101
+};
+
+/**
+ *    \brief      Set audio input configuration in HDMI mode only
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  aFmt        Audio input format
+ *    \param[in]  chanI2s     I2S channel allocation
+ *    \param[in]  chanDsd     DSD channel allocation
+ *    \param[in]  clkPolDsd   DSD clock polarity
+ *    \param[in]  swapDsd     DSD data swap
+ *    \param[in]  layout      Sample layout
+ *    \param[in]  latency_rd  Audio FIFO read latency
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ * */
+error_code_t
+bsl_audio_in_set_config
+(
+    unit_select_t           tx_unit,
+    bsla_fmt_t        a_fmt,
+    u8                    chan_i2s,
+    u8                    chan_dsd,
+    bsl_clk_pol_dsd_t   clk_pol_dsd,
+    bsl_swap_dsd_t     swap_dsd,
+    u8                    layout,
+    u16                   latency_rd
+);
+
+/*============================================================================*/
+/**
+ * bslAudioInSetCts() parameter types
+ * */
+/** Clock Time Stamp reference source */
+typedef enum {
+	HDMITX_CTSREF_ACLK      = 0,    /**< Clock input pin for I2S       */
+	HDMITX_CTSREF_MCLK      = 1,    /**< Clock input pin for EXTREF    */
+	HDMITX_CTSREF_FS64SPDIF = 2,    /**< 64xsample rate, for SPDIF     */
+	HDMITX_CTSREF_INVALID   = 3     /**< Invalid value                 */
+} bslcts_ref_t;
+
+/** Audio sample rate kHz indexes */
+typedef enum {
+	hdmitx_afs_32k           = 0,     /**< 32kHz    */
+	hdmitx_afs_44_1k         = 1,     /**< 44.1kHz  */
+	HDMITX_AFS_48K           = 2,     /**< 48kHz    */
+	HDMITX_AFS_88_2K         = 3,     /**< 88.2kHz  */
+	HDMITX_AFS_96K           = 4,     /**< 96kHz    */
+	HDMITX_AFS_176_4K        = 5,     /**< 176.4kHz */
+	HDMITX_AFS_192K          = 6,     /**< 192kHz   */
+	HDMITX_AFS_NOT_INDICATED = 7,     /**< Not Indicated (Channel Status) */
+	HDMITX_AFS_INVALID       = 7,     /**< Invalid  */
+	HDMITX_AFS_NUM           = 7      /**< # rates  */
+} bslafs_t;
+
+/** Vertical output frequencies */
+typedef enum {
+	hdmitx_vfreq_24hz      = 0,     /**< 24Hz          */
+	hdmitx_vfreq_25hz      = 1,     /**< 25Hz          */
+	hdmitx_vfreq_30hz      = 2,     /**< 30Hz          */
+	hdmitx_vfreq_50hz      = 3,     /**< 50Hz         0 */
+	hdmitx_vfreq_59hz      = 4,     /**< 59.94Hz      1 */
+	hdmitx_vfreq_60hz      = 5,     /**< 60Hz         2 */
+#ifndef FORMAT_PC
+	HDMITX_VFREQ_INVALID   = 6,     /**< Invalid       */
+	HDMITX_VFREQ_NUM       = 6      /**< No. of values */
+#else /* FORMAT_PC */
+	hdmitx_vfreq_70hz      = 6,     /**< 70Hz          */
+	hdmitx_vfreq_72hz      = 7,     /**< 72Hz          */
+	hdmitx_vfreq_75hz      = 8,     /**< 75Hz          */
+	hdmitx_vfreq_85hz      = 9,     /**< 85Hz          */
+	hdmitx_vfreq_87hz      = 10,     /**< 87Hz          */
+	HDMITX_VFREQ_INVALID   = 11,     /**< Invalid       */
+	HDMITX_VFREQ_NUM       = 11      /**< No. of values */
+#endif /* FORMAT_PC */
+} bsl_vfreq_t;
+
+/** Clock Time Stamp predivider - scales N */
+typedef enum {
+	HDMITX_CTSK1           = 0,     /**< k=1 */
+	HDMITX_CTSK2           = 1,     /**< k=2 */
+	HDMITX_CTSK3           = 2,     /**< k=3 */
+	HDMITX_CTSK4           = 3,     /**< k=4 */
+	HDMITX_CTSK8           = 4,     /**< k=8 */
+	HDMITX_CTSK_USE_CTSX   = 5,     /**< Calculate from ctsX factor */
+	HDMITX_CTSK_INVALID    = 6      /**< Invalid */
+} bslcts_k_t;
+
+/** Clock Time Stamp postdivider measured time stamp */
+typedef enum {
+	HDMITX_CTSMTS          = 0,     /**< =mts   */
+	HDMITX_CTSMTS2         = 1,     /**< =mts%2 */
+	HDMITX_CTSMTS4         = 2,     /**< =mts%4 */
+	HDMITX_CTSMTS8         = 3,     /**< =mts%8 */
+	HDMITX_CTSMTS_USE_CTSX = 4,     /**< Calculate from ctsX factor */
+	HDMITX_CTSMTS_INVALID  = 5      /**< Invalid */
+} bslcts_m_t;
+
+/** Cycle Time Stamp values */
+enum _bsl_cts {
+	HDMITX_CTS_AUTO        = 0,
+	HDMITX_CTS_MIN         = 0x000001
+};
+
+/** Cycle Time Stamp X factors */
+enum _bsl_cts_x {
+	HDMITX_CTSX_16         = 0,
+	HDMITX_CTSX_32         = 1,
+	HDMITX_CTSX_48         = 2,
+	HDMITX_CTSX_64         = 3,
+	HDMITX_CTSX_128        = 4,
+	HDMITX_CTSX_NUM        = 5,
+	/**< CTX value unused when K and Mts used */
+	HDMITX_CTSX_UNUSED     = 5,
+	HDMITX_CTSX_INVALID    = 6
+};
+
+/**
+ *    \brief      Set the Clock Time Stamp generator in HDMI mode only
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  ctsRef      Clock Time Stamp reference source
+ *    \param[in]  afs         Audio input sample frequency
+ *    \param[in]  voutFmt     Video output format
+ *    \param[in]  voutFreq    Vertical output frequency
+ *    \param[in]  uCts        Manual Cycle Time Stamp
+ *    \param[in]  uCtsX       Clock Time Stamp factor x
+ *    \param[in]  ctsK        Clock Time Stamp predivider k
+ *    \param[in]  ctsM        Clock Time Stamp postdivider m
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ * */
+error_code_t
+bsl_audio_in_set_cts
+(
+    unit_select_t       tx_unit,
+    bslcts_ref_t  cts_ref,
+    bslafs_t     afs,
+    bsl_vid_fmt_t  vout_fmt,
+    bsl_vfreq_t   vout_freq,
+    u32               u_cts,
+    u16               u_cts_x,
+    bslcts_k_t    cts_k,
+    bslcts_m_t    cts_m
+);
+
+/*============================================================================*/
+/**
+ * bslAudioOutSetChanStatus() parameter types
+ * */
+/** BYTE 0: Channel Status Format information */
+typedef enum {
+	/**< PCM 2 channels without pre-emphasis           */
+	HDMITX_CSFI_PCM_2CHAN_NO_PRE    = 0,
+	/**< PCM 2 channels with 50us/15us pre-emphasis    */
+	HDMITX_CSFI_PCM_2CHAN_PRE       = 1,
+	/**< PCM Reserved for 2 channels with pre-emphasis */
+	HDMITX_CSFI_PCM_2CHAN_PRE_RSVD1 = 2,
+	/**< PCM Reserved for 2 channels with pre-emphasis */
+	HDMITX_CSFI_PCM_2CHAN_PRE_RSVD2 = 3,
+	/**< Non-PCM Default state                         */
+	HDMITX_CSFI_NOTPCM_DEFAULT      = 4,
+	/**< Invalid value                                 */
+	HDMITX_CSFI_INVALID             = 5
+} bsl_csformat_info_t;
+
+/** BYTE 0: Channel Status Copyright assertion */
+typedef enum {
+	HDMITX_CSCOPYRIGHT_PROTECTED   = 0,  /**< Copyright protected     */
+	HDMITX_CSCOPYRIGHT_UNPROTECTED = 1,  /**< Not copyright protected */
+	HDMITX_CSCOPYRIGHT_INVALID     = 2   /**< Invalid value           */
+} bsl_cscopyright_t;
+
+/** BYTE 3: Channel Status Clock Accuracy */
+typedef enum {
+	HDMITX_CSCLK_LEVEL_II    = 0,     /**< Level II                     */
+	HDMITX_CSCLK_LEVEL_I     = 1,     /**< Level I                      */
+	HDMITX_CSCLK_LEVEL_III   = 2,     /**< Level III                    */
+	HDMITX_CSCLK_NOT_MATCHED = 3,     /**< Not matched to sample freq.  */
+	HDMITX_CSCLK_INVALID     = 4      /**< Invalid                      */
+} bsl_csclk_acc_t;
+
+/** BYTE 4: Channel Status Maximum sample word length */
+typedef enum {
+	HDMITX_CSMAX_LENGTH_20   = 0,  /**< Max word length is 20 bits   */
+	HDMITX_CSMAX_LENGTH_24   = 1,  /**< Max word length is 24 bits   */
+	HDMITX_CSMAX_INVALID     = 2   /**< Invalid value                */
+} bsl_csmax_word_length_t;
+
+/** BYTE 4: Channel Status Sample word length */
+typedef enum {
+	/**< Word length is not indicated                    */
+	HDMITX_CSWORD_DEFAULT          = 0,
+	/**< Sample length is 20 bits out of max 24 possible */
+	HDMITX_CSWORD_20_OF_24         = 1,
+	/**< Sample length is 16 bits out of max 20 possible */
+	HDMITX_CSWORD_16_OF_20         = 1,
+	/**< Sample length is 22 bits out of max 24 possible */
+	HDMITX_CSWORD_22_OF_24         = 2,
+	/**< Sample length is 18 bits out of max 20 possible */
+	HDMITX_CSWORD_18_OF_20         = 2,
+	/**< Reserved - shall not be used */
+	HDMITX_CSWORD_RESVD            = 3,
+	/**< Sample length is 23 bits out of max 24 possible */
+	HDMITX_CSWORD_23_OF_24         = 4,
+	/**< Sample length is 19 bits out of max 20 possible */
+	HDMITX_CSWORD_19_OF_20         = 4,
+	/**< Sample length is 24 bits out of max 24 possible */
+	HDMITX_CSWORD_24_OF_24         = 5,
+	/**< Sample length is 20 bits out of max 20 possible */
+	HDMITX_CSWORD_20_OF_20         = 5,
+	/**< Sample length is 21 bits out of max 24 possible */
+	HDMITX_CSWORD_21_OF_24         = 6,
+	/**< Sample length is 17 bits out of max 20 possible */
+	HDMITX_CSWORD_17_OF_20         = 6,
+	HDMITX_CSWORD_INVALID          = 7      /**< Invalid */
+} bsl_csword_length_t;
+
+/** BYTE 4: Channel Status Original sample frequency */
+typedef enum {
+	HDMITX_CSOFREQ_NOT_INDICATED = 0,   /**< Not Indicated */
+	hdmitx_csofreq_192k          = 1,   /**< 192kHz        */
+	hdmitx_csofreq_12k           = 2,   /**< 12kHz         */
+	hdmitx_csofreq_176_4k        = 3,   /**< 176.4kHz      */
+	HDMITX_CSOFREQ_RSVD1         = 4,   /**< Reserved      */
+	hdmitx_csofreq_96k           = 5,   /**< 96kHz         */
+	hdmitx_csofreq_8k            = 6,   /**< 8kHz          */
+	hdmitx_csofreq_88_2k         = 7,   /**< 88.2kHz       */
+	hdmitx_csofreq_16k           = 8,   /**< 16kHz         */
+	hdmitx_csofreq_24k           = 9,   /**< 24kHz         */
+	hdmitx_csofreq_11_025k       = 10,  /**< 11.025kHz     */
+	hdmitx_csofreq_22_05k        = 11,  /**< 22.05kHz      */
+	hdmitx_csofreq_32k           = 12,  /**< 32kHz         */
+	hdmitx_csofreq_48k           = 13,  /**< 48kHz         */
+	HDMITX_CSOFREQ_RSVD2         = 14,  /**< Reserved      */
+	hdmitx_csofreq_44_1k         = 15,  /**< 44.1kHz       */
+	HDMITX_CSAFS_INVALID         = 16   /**< Invalid value */
+} bsl_csorig_afs_t;
+
+/**
+ *    \brief      Set the Channel Status Bytes 0,1,3 & 4
+ *
+ *    \param[in]  txUnit              Transmitter unit number
+ *    \param[in]  copyright           Byte 0 Copyright bit (bit2)
+ *    \param[in]  formatInfo          Byte 0 Audio sample format (bit1) and additional info (bit345)
+ *    \param[in]  categoryCode        Byte 1 Category code (bits8-15)
+ *    \param[in]  sampleFreq          Byte 3 Sample Frequency (bits24-27)
+ *    \param[in]  clockAccuracy       Byte 3 Clock Accuracy (bits38-31)
+ *    \param[in]  maxWordLength       Byte 4 Maximum word length (bit32)
+ *    \param[in]  wordLength          Byte 4 Word length (bits33-35)
+ *    \param[in]  origSampleFreq      Byte 4 Original Sample Frequency (bits36-39)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ *
+ *    \note       The consumer use bit (bit0) and Mode bits (bits6-7) are forced to zero.
+ *                Use bslAudioOutSetChanStatusMapping to set CS Byte 2.
+ *
+ * */
+error_code_t
+bsl_audio_out_set_chan_status
+(
+    unit_select_t               tx_unit,
+    bsl_csformat_info_t    format_info,
+    bsl_cscopyright_t     copyright,
+    u8                        category_code,
+    bslafs_t             sample_freq,
+    bsl_csclk_acc_t        clock_accuracy,
+    bsl_csmax_word_length_t max_word_length,
+    bsl_csword_length_t    word_length,
+    bsl_csorig_afs_t       orig_sample_freq
+);
+
+/*============================================================================*/
+/**
+ * bslAudioOutSetChanStatusMapping() parameter types
+ * */
+/** Channel Status source/channel number limits */
+enum _bsl_chan_status_chan_limits {
+	HDMITX_CS_CHANNELS_MAX  = 0x0F,
+	HDMITX_CS_SOURCES_MAX   = 0x0F
+};
+
+/**
+ *    \brief      Set the Channel Status Byte2 for Audio Port 0
+ *
+ *    \param[in]  txUnit              Transmitter unit number
+ *    \param[in]  sourceLeft          L Source Number: 0 don't take into account, 1-15
+ *    \param[in]  channelLeft         L Channel Number: 0 don't take into account, 1-15
+ *    \param[in]  sourceRight         R Source Number: 0 don't take into account, 1-15
+ *    \param[in]  channelRight        R Channel Number: 0 don't take into account, 1-15
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ *
+ *    \note       Use bslAudioOutSetChanStatus to set all other CS bytes
+ *                This function only sets the mapping for Audio Port 0.
+ *
+ * */
+error_code_t
+bsl_audio_out_set_chan_status_mapping
+(
+    unit_select_t  tx_unit,
+    u8           source_left,
+    u8           channel_left,
+    u8           source_right,
+    u8           channel_right
+);
+
+/*============================================================================*/
+/**
+ * bslAudioOutSetMute() parameter type
+ * */
+typedef enum {
+	HDMITX_AMUTE_OFF       = 0,    /**< Mute off */
+	HDMITX_AMUTE_ON        = 1,    /**< Mute on  */
+	HDMITX_AMUTE_INVALID   = 2     /**< Invalid  */
+} bsla_mute_t;
+
+/**
+ *    \brief      Mute or un-mute the audio output by controlling the audio FIFO,
+ *                in HDMI mode only
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  aMute       Audio mute: On, Off
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: in DVI mode
+ *
+ *    \note       bslPktSetGeneralCntrl must be used to control the audio
+ *                mute in outgoing data island packets
+ *
+ * */
+error_code_t
+bsl_audio_out_set_mute
+(
+    unit_select_t      tx_unit,
+    bsla_mute_t a_mute
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Disable an HDMI Transmitter output and destroy its driver
+ *                instance
+ *
+ *    \param[in]  txUnit Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: the unit is not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_deinit
+(
+    unit_select_t      tx_unit
+);
+
+/*============================================================================*/
+/**
+ * \brief The bslEdidGetAudioCapabilities() parameter type
+ * */
+typedef struct _bsl_edid_sad_t {
+	u8   mode_chans;  /* Bits[6:3]: EIA/CEA861 mode; Bits[2:0]: channels */
+	u8   freqs;      /* Bits for each supported frequency */
+	u8   byte3;      /* EIA/CEA861B p83: data depending on audio mode */
+} bsl_edid_sad_t;
+
+/** Number of 3 byte Short Audio Descriptors stored in pEdidAFmts */
+#define HDMI_TX_SAD_MAX_CNT     10
+
+/**
+ *    \brief      Get supported audio format(s) from previously read EDID
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pEdidAFmts  Pointer to the array of structures to receive the
+ *                            supported Short Audio Descriptors
+ *    \param[in]  aFmtLength  Number of SADs supported in buffer pEdidAFmts,
+ *                            up to HDMI_TX_SAD_MAX_CNT
+ *    \param[out] pAFmtsAvail Pointer to receive the number of SADs available
+ *    \param[out] pAudioFlags Pointer to the byte to receive the Audio Capability
+ *                            Flags
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \note \verbatim
+ *                Supported Short Audio Descriptors array:
+ *                EdidAFmts[0].ModeChans      SAD 1  - Mode byte
+ *                EdidAFmts[0].Freqs	        SAD 1  - Frequencies byte
+ *                EdidAFmts[0].Byte3          SAD 1  - Byte 3
+ *                ...
+ *                EdidAFmts[n-1].ModeChans    SAD n  - Mode byte
+ *                EdidAFmts[n-1].Freqs	    SAD n  - Frequencies byte
+ *                EdidAFmts[n-1].Byte3        SAD n  - Byte 3
+ *                (Where n is the smaller of aFmtLength and pAFmtAvail)
+ *    \endverbatim
+ * */
+error_code_t
+bsl_edid_get_audio_capabilities
+(
+    unit_select_t          tx_unit,
+    bsl_edid_sad_t    *p_edid_afmts,
+    uint                    a_fmt_length,
+    uint                    *p_afmts_avail,
+    u8                   *p_audio_flags
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the EDID block count
+ *
+ *    \param[in]  txUnit              Transmitter unit number
+ *    \param[out] puEdidBlockCount    Pointer to data byte in which to return the
+ *                                    block count
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ * */
+error_code_t
+bsl_edid_get_block_count
+(
+    unit_select_t  tx_unit,
+    u8           *pu_edid_block_count
+);
+
+/*============================================================================*/
+/**
+ * bslEdidGetBlockData() parameter types
+ * */
+/** An enum to represent the current EDID status */
+enum _bsl_edid_sta_t {
+	HDMITX_EDID_READ                = 0,
+	HDMITX_EDID_READ_INCOMPLETE     = 1,
+	HDMITX_EDID_ERROR               = 2,
+	HDMITX_EDID_ERROR_INCOMPLETE    = 3,
+	HDMITX_EDID_NOT_READ            = 4};
+
+/**
+ *    \brief      Get raw EDID blocks from the sink device via DDC
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pRawEdid    Pointer to a buffer supplied by the caller to accept
+ *                            the raw EDID data
+ *    \param[in]  numBlocks   Number of blocks to read
+ *    \param[in]  lenRawEdid  Length in bytes of the supplied buffer
+ *    \param[out] pEdidStatus Pointer to status value E_EDID_READ or E_EDID_ERROR
+ *                            valid only when the return value is 0
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \note       NA
+ *
+ *    \sa         bslEdidGetVideoPreferred,
+ *                bslEdidGetVideoCapabilities
+ * */
+error_code_t
+bsl_edid_get_block_data
+(
+    unit_select_t          tx_unit,
+    u8                   *p_raw_edid,
+    int                     num_blocks,
+    int                     len_raw_edid,
+    u8                   *p_edid_status
+);
+
+/*============================================================================*/
+/**
+ * bslEdidGetSinkType() parameter types
+ * */
+/** Sink device type */
+typedef enum {
+	HDMITX_SINK_DVI                = 0,    /**< DVI  */
+	HDMITX_SINK_HDMI               = 1,    /**< HDMI */
+	HDMITX_SINK_EDID               = 2,    /**< As currently defined in EDID */
+	HDMITX_SINK_INVALID            = 3     /**< Invalid   */
+} bsl_sink_type_t;
+
+/**
+ *    \brief      Get Sink Type by analysis of EDID content
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pSinkType   Pointer to returned Sink Type: DVI or HDMI
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \sa         bslEdidGetBlockData
+ * */
+error_code_t
+bsl_edid_get_sink_type
+(
+    unit_select_t              tx_unit,
+    bsl_sink_type_t      *p_sink_type
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get Source Physical Address by analysis of EDID content
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pSourceAddress  Pointer to returned Source Physical Address (ABCDh)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \sa         bslEdidGetBlockData
+ * */
+error_code_t
+bsl_edid_get_source_address
+(
+    unit_select_t  tx_unit,
+    u16          *p_source_address
+);
+
+/*============================================================================*/
+/**
+ *  bslEdidGetVideoCapabilities() parameter types
+ * */
+/** Number of 1 byte Short Video Descriptors stored in pEdidVFmts */
+#define HDMI_TX_SVD_MAX_CNT     30
+
+/** Flag set in Short Video Descriptor to indicate native format */
+#define HDMI_TX_SVD_NATIVE_MASK 0x80
+#define HDMI_TX_SVD_NATIVE_NOT  0x7F
+
+/** Video capability flags */
+enum _bsl_vid_cap_t {
+	HDMITX_VIDCAP_UNDERSCAN   = 0x80,   /**< Underscan supported */
+	HDMITX_VIDCAP_YUV444      = 0x40,   /**< YCbCr 4:4:4 supported */
+	HDMITX_VIDCAP_YUV422      = 0x20,   /**< YCbCr 4:2:2 supported */
+	HDMITX_VIDCAP_UNUSED      = 0x1F    /**< Unused flags */
+};
+
+/**
+ *    \brief      Get supported video format(s) from previously read EDID
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pEdidVFmts  Pointer to the array to receive the supported Short
+ *                            Video Descriptors
+ *    \param[in]  vFmtLength  Number of SVDs supported in buffer pEdidVFmts,
+ *                            up to HDMI_TX_SVD_MAX_CNT
+ *    \param[out] pVFmtsAvail Pointer to receive the number of SVDs available
+ *    \param[out] pVidFlags   Ptr to the byte to receive Video Capability Flags
+ *                            b7: underscan supported
+ *                            b6: YCbCr 4:4:4 supported
+ *                            b5: YCbCr 4:2:2 supported
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \note \verbatim
+ *                Supported Short Video Descriptors array:
+ *                    (HDMI_TX_SVD_NATIVE_MASK bit set to indicate native format)
+ *                EdidVFmts[0]   EIA/CEA Short Video Descriptor 1, or 0
+ *                ...
+ *                EdidVFmts[n-1]  EIA/CEA Short Video Descriptor 32, or 0
+ *                (Where n is the smaller of vFmtLength and pVFmtAvail)
+ *    \endverbatim
+ *    \sa         bslEdidGetBlockData
+ * */
+error_code_t
+bsl_edid_get_video_capabilities
+(
+    unit_select_t  tx_unit,
+    u8           *p_edid_vfmts,
+    uint            v_fmt_length,
+    uint            *p_vfmts_avail,
+    u8           *p_vid_flags
+);
+
+/*============================================================================*/
+/**
+ * \brief The bslEdidGetVideoPreferred() parameter type
+ * */
+typedef struct _bsl_edid_dtd_t {
+	u16  u_pixel_clock;        /**< Pixel Clock/10,000         */
+	u16  u_hactive_pixels;     /**< Horizontal Active Pixels   */
+	u16  u_hblank_pixels;      /**< Horizontal Blanking Pixels */
+	u16  u_vactive_lines;      /**< Vertical Active Lines      */
+	u16  u_vblank_lines;       /**< Vertical Blanking Lines    */
+	u16  u_hsync_offset;       /**< Horizontal Sync Offset     */
+	u16  u_hsync_width;        /**< Horiz. Sync Pulse Width    */
+	u16  u_vsync_offset;       /**< Vertical Sync Offset       */
+	u16  u_vsync_width;        /**< Vertical Sync Pulse Width  */
+	u16  u_himage_size;        /**< Horizontal Image Size      */
+	u16  u_vimage_size;        /**< Vertical Image Size        */
+	u16  u_hborder_pixels;     /**< Horizontal Border          */
+	u16  u_vborder_pixels;     /**< Vertical Border            */
+	u8   flags;              /**< Interlace/sync info        */
+} bsl_edid_dtd_t;
+
+/**
+ *    \brief      Get preferred video format from previously read EDID
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pEdidDTD    Pointer to the structure to receive the Detailed
+ *                            Timing Descriptor parameters of the preferred video
+ *                            format
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_INVALID_STATE: EDID checksum failure
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NULL_CONNECTION: HPD pin is inactive
+ *
+ *    \note \verbatim
+ *                Detailed Timing Descriptor parameters output structure:
+ *                u16 uPixelClock      Pixel Clock (MHz/10,000)
+ *                u16 uHActivePixels   Horizontal Active Pixels
+ *                u16 uHBlankPixels    Horizontal Blanking Pixels
+ *                u16 uVActiveLines    Vertical Active Lines
+ *                u16 uVBlankLines     Vertical Blanking Lines
+ *                u16 uHSyncOffset     Horizontal Sync Offset (Pixels)
+ *                u16 uHSyncWidth      Horizontal Sync Pulse Width (Pixels)
+ *                u16 uVSyncOffset     Vertical Sync Offset (Lines)
+ *                u16 uVSyncWidth      Vertical Sync Pulse Width (Lines)
+ *                u16 uHImageSize      Horizontal Image Size (mm)
+ *                u16 uVImageSize      Vertical Image Size (mm)
+ *                u16 uHBorderPixels   Horizontal Border (Pixels)
+ *                u16 uVborderPixels   Vertical Border (Pixels)
+ *                u8 Flags             Interlace/sync info
+ *    \endverbatim
+ *    \sa         bslEdidGetBlockData
+ * */
+error_code_t
+bsl_edid_get_video_preferred
+(
+    unit_select_t          tx_unit,
+    bsl_edid_dtd_t    *p_edid_dtd
+);
+
+/**
+ *    \brief      Get detailed timing descriptor from previously read EDID
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pEdidDTD    Pointer to the array to receive the Detailed timing descriptor
+ *
+ *    \param[in]  nb_size     Number of DTD supported in buffer pEdidDTD
+ *
+ *    \param[out] pDTDAvail Pointer to receive the number of DTD available
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_INVALID_STATE: EDID not read
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_edid_get_detailed_timing_descriptors
+(
+    unit_select_t          tx_unit,
+    bsl_edid_dtd_t    *p_edid_dtd,
+    u8                   nb_size,
+    u8                   *p_dtda_vail
+);
+
+/*============================================================================*/
+/**
+ * bslHdcpCheck() parameter type
+ * */
+/** HDCP check result */
+typedef enum {
+	HDMITX_HDCP_CHECK_NOT_STARTED       = 0,    /**< Check not started */
+	HDMITX_HDCP_CHECK_IN_PROGRESS       = 1,    /**< No failures, more to do */
+	HDMITX_HDCP_CHECK_PASS              = 2,    /**< Final check has passed */
+	/**< First check failure code */
+	HDMITX_HDCP_CHECK_FAIL_FIRST        = 3,
+	/**< Driver not AUTHENTICATED */
+	HDMITX_HDCP_CHECK_FAIL_DRIVER_STATE = 3,
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_T0    = 4,    /**< A T0 interrupt occurred */
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_RI    = 5,    /**< Device RI changed */
+	HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM   = 6,    /**< Device FSM not 10h */
+	HDMITX_HDCP_CHECK_NUM               = 7     /**< Number of check results */
+} bsl_hdcp_check_t;
+
+/**
+ *    \brief      Check the result of an HDCP encryption attempt, called at
+ *                intervals (set by uTimeSinceLastCallMs) after bslHdcpRun
+ *
+ *    \param[in]  txUnit                  Transmitter unit number
+ *    \param[in]  uTimeSinceLastCallMs    Time in ms since this was last called
+ *    \param[out] pResult                 The outcome of the check
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ * */
+error_code_t
+bsl_hdcp_check
+(
+    unit_select_t	        tx_unit,
+    u16                  u_time_since_last_call_ms,
+    bsl_hdcp_check_t  *p_result
+);
+
+/*============================================================================*/
+/**
+ * bslHdcpConfigure() parameter type
+ * */
+/** HDCP DDC slave addresses */
+enum _bsl_hdcp_slave_address {
+	HDMITX_HDCP_SLAVE_PRIMARY    = 0x74,
+	HDMITX_HDCP_SLAVE_SECONDARY  = 0x76
+};
+
+/** HDCP transmitter modes */
+typedef enum {
+	HDMITX_HDCP_TXMODE_NOT_SET   = 0,
+	HDMITX_HDCP_TXMODE_REPEATER  = 1,
+	HDMITX_HDCP_TXMODE_TOP_LEVEL = 2,
+	HDMITX_HDCP_TXMODE_MAX       = 2
+} bsl_hdcp_tx_mode_t;
+
+/** HDCP option flags */
+typedef enum {
+	/* Not set: obey PJ result     */
+	HDMITX_HDCP_OPTION_FORCE_PJ_IGNORED = 0x01,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_SLOW_DDC   = 0x02,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_NO_1_1     = 0x04,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_REPEATER   = 0x08,
+	/* Not set: obey BCAPS setting */
+	HDMITX_HDCP_OPTION_FORCE_NO_REPEATER = 0x10,
+	/* Not set: obey V=V' result   */
+	HDMITX_HDCP_OPTION_FORCE_V_EQU_VBAR = 0x20,
+	HDMITX_HDCP_OPTION_FORCE_VSLOW_DDC  = 0x40,/* Set: 50kHz DDC */
+	HDMITX_HDCP_OPTION_DEFAULT          = 0x00,/* All the above Not Set vals */
+	/* Only these bits are allowed */
+	HDMITX_HDCP_OPTION_MASK             = 0x7F,
+	/* These bits are not allowed  */
+	HDMITX_HDCP_OPTION_MASK_BAD         = 0x80
+} bsl_hdcp_options_t;
+
+/**
+ *    \brief      Configure various HDCP parameters
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  slaveAddress    DDC I2C slave address
+ *    \param[in]  txMode          Mode of our transmitter device
+ *    \param[in]  options         Options flags to control behaviour of HDCP
+ *    \param[in]  uCheckIntervalMs HDCP check interval in milliseconds
+ *    \param[in]  uChecksToDo     Number of HDCP checks to do after HDCP starts
+ *                                A value of 2 or more is valid for checking
+ *                                May be set to 0 to disabling checking
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ *    \note       Must be called before all other HDCP APIs
+ * */
+error_code_t
+bsl_hdcp_configure
+(
+    unit_select_t	         tx_unit,
+    u8                    slave_address,
+    bsl_hdcp_tx_mode_t  tx_mode,
+    bsl_hdcp_options_t options,
+    u16                   u_check_interval_ms,
+    u8                    u_checks_to_do
+);
+
+/*============================================================================*/
+/**
+ * bslHdcpDownloadKeys() parameter type
+ * */
+/** HDCP decryption mode */
+typedef enum {
+	HDMITX_HDCP_DECRYPT_DISABLE  = 0,
+	HDMITX_HDCP_DECRYPT_ENABLE   = 1,
+	HDMITX_HDCP_DECRYPT_MAX      = 1
+} bsl_decrypt_t;
+
+/**
+ *    \brief      Download keys and AKSV data from OTP memory to the device
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  seed            Seed value
+ *    \param[in]  keyDecryption   State of key decryption 0 to 1 (disabled, enabled)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ * */
+error_code_t
+bsl_hdcp_download_keys
+(
+    unit_select_t	        tx_unit,
+    u16                  seed,
+    bsl_decrypt_t    key_decryption
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Switch HDCP encryption on or off without disturbing Infoframes
+ *                (Not normally used)
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *    \param[in]  bOn     Encryption state: 1=on, 0=off
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ * */
+error_code_t
+bsl_hdcp_encryption_on
+(
+    unit_select_t	tx_unit,
+    bool            b_on
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get HDCP OTP registers
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  otpAddress  OTP start address 0-FF
+ *    \param[out] pOtpData    Ptr to a three-byte array to hold the data read:
+ *                            [0] = OTP_DATA_MSB
+ *                            [1] = OTP_DATA_ISB
+ *                            [2] = OTP_DATA_LSB
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ * */
+error_code_t
+bsl_hdcp_get_otp
+(
+    unit_select_t	        tx_unit,
+    u8                   otp_address,
+    u8                   *p_otp_data
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Return the failure state that caused the last T0 interrupt
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pFailState  Ptr to the unit's last T0 fail state
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ * */
+error_code_t
+bsl_hdcp_get_t0fail_state
+(
+    unit_select_t	tx_unit,
+    u8           *p_fail_state
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle BCAPS interrupt
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       The user BCAPS interrupt handler (registered with
+ *                bslInit) calls this API before calling
+ *                bslHdcpHandleBKSV
+ * */
+error_code_t
+bsl_hdcp_handle_bcaps
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Read BKSV registers
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pBksv           Pointer to 5-byte BKSV array returned to caller
+ *                                (1st byte is MSB)
+ *    \param[out] pbCheckRequired Pointer to a result variable to tell the caller
+ *                                whether to check for BKSV in a revocation list:
+ *                                0 or 1 (check not required, check required)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       The user BCAPS interrupt handler (registered with
+ *                bslInit) calls this API after calling
+ *                bslHdcpHandleBCAPS
+ * */
+error_code_t
+bsl_hdcp_handle_bksv
+(
+    unit_select_t	tx_unit,
+    u8           *p_bksv,
+    bool            *pb_check_required
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Declare BKSV result to be secure or not secure
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  bSecure         Result of user's check of BKSV against a
+ *                                revocation list:
+ *                                0 (not secure: BKSV found in revocation list)
+ *                                1 (secure: BKSV not found in revocation list)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       The user BCAPS interrupt handler (registered with
+ *                bslInit) calls this API after calling
+ *                bslHdcpHandleBKSV
+ * */
+error_code_t
+bsl_hdcp_handle_bksvresult
+(
+    unit_select_t	tx_unit,
+    bool            b_secure
+);
+
+/*============================================================================*/
+/**
+ * bslHdcpHandleBSTATUS() parameter type
+ * */
+/** BSTATUS bit fields */
+enum _bsl_hdcp_handle_bstatus {
+	HDMITX_HDCP_BSTATUS_HDMI_MODE               = 0x1000,
+	HDMITX_HDCP_BSTATUS_MAX_CASCADE_EXCEEDED    = 0x0800,
+	HDMITX_HDCP_BSTATUS_CASCADE_DEPTH           = 0x0700,
+	HDMITX_HDCP_BSTATUS_MAX_DEVS_EXCEEDED       = 0x0080,
+	HDMITX_HDCP_BSTATUS_DEVICE_COUNT            = 0x007F
+};
+
+/**
+ *    \brief      Handle BSTATUS interrupt
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pBstatus    Pointer to 16-bit BSTATUS value returned to caller
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       Called by user's BSTATUS interrupt handler registered with
+ *                bslInit
+ * */
+error_code_t
+bsl_hdcp_handle_bstatus
+(
+    unit_select_t	tx_unit,
+    u16          *p_bstatus
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle ENCRYPT interrupt
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       Called by user's ENCRYPT interrupt handler registered with
+ *                bslInit
+ * */
+error_code_t
+bsl_hdcp_handle_encrypt
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle PJ interrupt
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       Called by user's PJ interrupt handler registered with
+ *                bslInit
+ * */
+error_code_t
+bsl_hdcp_handle_pj
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ * bslHdcpHandleSHA_1() parameter types
+ * */
+
+/** KSV list sizes */
+enum _bsl_hdcp_handle_sha_1 {
+	HDMITX_KSV_LIST_MAX_DEVICES = 128,
+	HDMITX_KSV_BYTES_PER_DEVICE = 5
+};
+
+/**
+ *    \brief      Handle SHA-1 interrupt
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  maxKsvDevices   Maximum number of 5-byte devices that will fit
+ *                                in *pKsvList: 0 to 128 devices
+ *                                If 0, no KSV read is done and it is treated as
+ *                                secure
+ *    \param[out] pKsvList        Pointer to KSV list array supplied by caller:
+ *                                Sets of 5-byte KSVs, 1 per device, 1st byte is
+ *                                LSB of 1st device
+ *                                May be null if maxKsvDevices is 0
+ *    \param[out] pnKsvDevices    Pointer to number of KSV devices copied to
+ *p_ksv_list: 0 to 128
+ *                                If 0, no KSV check is needed and it is treated
+ *                                as secure
+ *                                May be null if maxKsvDevices is 0
+ *
+ *    \param[out] pDepth          Connection tree depth
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: two parameters disagree
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       Called by user's SHA-1 interrupt handler registered with
+ *                bslInit
+ * */
+error_code_t
+bsl_hdcp_handle_sha_1
+(
+    unit_select_t	tx_unit,
+    u8           max_ksv_devices,
+    u8           *p_ksv_list,
+    u8           *pn_ksv_devices,
+    /* Connection tree depth returned with KSV list */
+    u8           *p_depth
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Declare KSV list result to be secure or not secure
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  bSecure         Result of user's check of KSV list against a
+ *                                revocation list:
+ *                                0 (not secure: one or more KSVs are in r.list)
+ *                                1 (secure: no KSV found in revocation list)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       The user SHA_1 interrupt handler (registered with
+ *                bslInit) calls this API after calling
+ *                bslHdcpHandleSHA_1
+ * */
+error_code_t
+bsl_hdcp_handle_sha_1result
+(
+    unit_select_t	tx_unit,
+    bool            b_secure
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle T0 interrupt
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *
+ *    \note       Called by user's T0 interrupt handler registered with
+ *                bslInit
+ * */
+error_code_t
+bsl_hdcp_handle_t0
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Prepare for HDCP operation
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  voutFmt     Video output format
+ *    \param[in]  voutFreq    Vertical output frequency
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ *    \note       Must be called before bslHdcpRun
+ * */
+error_code_t
+bsl_hdcp_init
+(
+    unit_select_t	    tx_unit,
+    bsl_vid_fmt_t vout_fmt,
+    bsl_vfreq_t  vout_freq
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Start HDCP operation
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ *    \note       Must be called after bslHdcpInit
+ * */
+error_code_t
+bsl_hdcp_run
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Stop HDCP operation, and cease encrypting the output
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *                  - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ *    \note       This will trigger an Encrypt interrupt
+ * */
+error_code_t
+bsl_hdcp_stop
+(
+    unit_select_t	tx_unit
+);
+
+/*============================================================================*/
+/**
+ * bslHotPlugGetStatus() parameter type
+ * */
+typedef enum {
+	HDMITX_HOTPLUG_INACTIVE    = 0,    /**< Hotplug inactive */
+	HDMITX_HOTPLUG_ACTIVE      = 1,    /**< Hotplug active   */
+	HDMITX_HOTPLUG_INVALID     = 2     /**< Invalid Hotplug  */
+} bsl_hot_plug_t;
+
+/**
+ *    \brief      Get the hot plug input status last read by bslInit
+ *                or bslHwHandleInterrupt
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pHotPlugStatus  Pointer to returned Hot Plug Detect status
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_hot_plug_get_status
+(
+    unit_select_t        tx_unit,
+    bsl_hot_plug_t *p_hot_plug_status
+);
+
+/*============================================================================*/
+/**
+ * bslRxSenseGetStatus() parameter type
+ * */
+typedef enum {
+	HDMITX_RX_SENSE_INACTIVE    = 0,    /**< RxSense inactive */
+	HDMITX_RX_SENSE_ACTIVE      = 1,    /**< RxSense active   */
+	HDMITX_RX_SENSE_INVALID     = 2     /**< Invalid RxSense  */
+} bsl_rx_sense_t;
+
+/**
+ *    \brief      Get the rx sense input status last read by bslInit
+ *                or bslHwHandleInterrupt
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pRxSenseStatus  Pointer to returned Rx Sense Detect status
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_rx_sense_get_status
+(
+    unit_select_t        tx_unit,
+    bsl_rx_sense_t *p_rx_sense_status
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get one or more hardware I2C register values
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  regPage     The device register's page: 00h, 01h, 02h, 11h, 12h
+ *    \param[in]  regAddr     The starting register address on the page: 0 to FFh
+ *    \param[out] pRegBuf     Pointer to buffer to receive the register data
+ *    \param[in]  nRegs       Number of contiguous registers to read: 1 to 254
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ * */
+error_code_t
+bsl_hw_get_registers
+(
+    unit_select_t	tx_unit,
+    int             reg_page,
+    int             reg_addr,
+    u8          *p_reg_buf,
+    int             n_regs
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the transmitter device version read at initialization
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] puDeviceVersion Pointer to returned hardware version
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_hw_get_version
+(
+    unit_select_t  tx_unit,
+    u8          *pu_device_version
+);
+
+/*============================================================================*/
+/**
+ * bslHwGetCapabilities() parameter type
+ * */
+typedef enum {
+	bsl_hw_none       = 0,    /**< None           feature */
+	bsl_hw_hdcp       = 1,    /**< HDCP           feature */
+	bsl_hw_scaler     = 2,    /**< Scaler         feature */
+	bsl_hw_hdcpscaler = 3,    /**< HDCP & Scaler  feature  */
+	bsl_hw_all        = 3     /**< All            feature  */
+} bsl_hw_feature_t;
+
+/**
+ *    \brief      Get the transmitter device feature read at initialization
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pDeviceFeature  Pointer to returned hardware feature
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_hw_get_capabilities
+(
+    unit_select_t          tx_unit,
+    bsl_hw_feature_t  *p_device_capabilities
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle all hardware interrupts from a transmitter unit
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *    \note       This function must be called at task level not interrupt level,
+ *                as I2C access is required
+ * */
+error_code_t
+bsl_hw_handle_interrupt
+(
+    unit_select_t      tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set one or more hardware I2C registers
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  regPage     The device register's page: 00h, 01h, 02h, 11h, 12h
+ *    \param[in]  regAddr     The starting register address on the page: 0 to FFh
+ *    \param[in]  pRegBuf     Ptr to buffer from which to write the register data
+ *    \param[in]  nRegs       Number of contiguous registers to write: 0 to 254.
+ *                            The page register (255) may not be written - it is
+ *                            written to automatically here. If nRegs is 0, the
+ *                            page register is the only register written.
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_hw_set_registers
+(
+    unit_select_t	tx_unit,
+    int             reg_page,
+    int             reg_addr,
+    u8          *p_reg_buf,
+    int             n_regs
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle hardware startup by resetting Device Instance Data
+ * */
+void
+bsl_hw_startup
+(
+    void
+);
+
+/*============================================================================*/
+/**
+ * bslInit() parameter types
+ * */
+/**
+ * Supported range of I2C slave addresses
+ * */
+enum _bsl_slave_address {
+	HDMITX_SLAVE_ADDRESS_MIN    = 1,
+	HDMITX_SLAVE_ADDRESS_MAX    = 127
+};
+
+/**
+ * Indexes into the funcCallback[] array of interrupt callback function pointers
+ * */
+enum _bsl_callback_int {
+	HDMITX_CALLBACK_INT_ENCRYPT  = 0,  /**< HDCP encryption switched off     */
+	HDMITX_CALLBACK_INT_HPD      = 1,  /**< Transition on HPD input          */
+	HDMITX_CALLBACK_INT_T0       = 2,  /**< HDCP state machine in state T0   */
+	HDMITX_CALLBACK_INT_BCAPS    = 3,  /**< BCAPS available                  */
+	HDMITX_CALLBACK_INT_BSTATUS  = 4,  /**< BSTATUS available                */
+	HDMITX_CALLBACK_INT_SHA_1    = 5,  /**< sha-1(ksv,bstatus,m0)=V'         */
+	HDMITX_CALLBACK_INT_PJ       = 6,  /**< pj=pj' check fails               */
+#ifndef TMFL_TDA9981_SUPPORT
+	HDMITX_CALLBACK_INT_UNUSED7  = 7,  /**< Unused interrupt                 */
+	HDMITX_CALLBACK_INT_NUM      = 8   /**< Number of callbacks              */
+#else /* TMFL_TDA9981_SUPPORT */
+	HDMITX_CALLBACK_INT_R0	     = 7,  /**< R0 interrupt                     */
+	HDMITX_CALLBACK_INT_SW_INT   = 8,  /**< SW DEBUG interrupt               */
+#ifdef TMFL_RX_SENSE_ON
+	HDMITX_CALLBACK_INT_RX_SENSE = 9,  /**< RX SENSE interrupt               */
+	HDMITX_CALLBACK_INT_NUM      = 10   /**< Number of callbacks             */
+#else /* TMFL_RX_SENSE_ON */
+	HDMITX_CALLBACK_INT_NUM      = 9   /**< Number of callbacks             */
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+};
+
+/** Pixel rate */
+typedef enum {
+	HDMITX_PIXRATE_DOUBLE               = 0,        /**< Double pixel rate */
+	HDMITX_PIXRATE_SINGLE               = 1,        /**< Single pixel rate */
+	/**< Single pixel repeated */
+	HDMITX_PIXRATE_SINGLE_REPEATED      = 2,
+	HDMITX_PIXRATE_NO_CHANGE            = 3,        /**< No Change */
+	HDMITX_PIXRATE_INVALID              = 4         /**< Invalid   */
+} bsl_pix_rate_t;
+
+/**
+ * \brief The bslInit() parameter structure
+ * */
+typedef struct _bsl_callback_list_t {
+	/** Interrupt callback function pointers (each ptr if null = not used) */
+	pbsl_callback_t func_callback[HDMITX_CALLBACK_INT_NUM];
+
+} bsl_callback_list_t;
+
+/**
+ *    \brief      Create an instance of an HDMI Transmitter: initialize the
+ *                driver, reset the transmitter device and get the current
+ *                Hot Plug state
+ *
+ *    \param[in]  txUnit           Transmitter unit number
+ *    \param[in]  uHwAddress       Device I2C slave address
+ *    \param[in]  sysFuncWrite     System function to write I2C
+ *    \param[in]  sysFuncRead      System function to read I2C
+ *    \param[in]  sysFuncEdidRead  System function to read EDID blocks via I2C
+ *    \param[in]  sysFuncTimer     System function to run a timer
+ *    \param[in]  funcIntCallbacks Pointer to interrupt callback function list
+ *                                 The list pointer is null for no callbacks;
+ *                                 each pointer in the list may also be null.
+ *    \param[in]  bEdidAltAddr     Use alternative i2c address for EDID data
+ *                                 register between Driver and TDA9983/2:
+ *                                 0 - use default address (A0)
+ *                                 1 - use alternative address (A2)
+ *    \param[in]  vinFmt           EIA/CEA Video input format: 1 to 31, 0 = No Change
+ *    \param[in]  pixRate          Single data (repeated or not) or double data rate
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: the unit number is wrong or
+ *                    the transmitter instance is already initialised
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter is invalid or out
+ *                    of range
+ *                  - ERR_HDMI_INIT_FAILED: the unit instance is already
+ *                    initialised
+ *                  - ERR_HDMI_COMPATIBILITY: the driver is not compatiable
+ *                    with the internal device version code
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ * */
+error_code_t
+bsl_init
+(
+    unit_select_t	           tx_unit,
+    u8                      u_hw_address,
+    pbsl_sys_func_t      sys_func_write,
+    pbsl_sys_func_t      sys_func_read,
+    pbsl_sys_func_edid_t  sys_func_edid_read,
+    pbsl_sys_func_timer_t sys_func_timer,
+    bsl_callback_list_t *func_int_callbacks,
+    bool                       b_edid_alt_addr,
+    bsl_vid_fmt_t        vin_fmt,
+    bsl_pix_rate_t       pix_rate
+);
+
+/*============================================================================*/
+/**
+ * bslMatrixSetCoeffs() parameter type
+ * */
+/** Parameter structure array size */
+enum _bsl_mat_coeff {
+	HDMITX_MAT_COEFF_NUM = 9
+};
+
+/** \brief The bslMatrixSetCoeffs() parameter structure */
+typedef struct _bsl_mat_coeff_t {
+	/** Array of coefficients (values -1024 to +1023) */
+	s16 coeff[HDMITX_MAT_COEFF_NUM];
+} bsl_mat_coeff_t;
+
+/**
+ *    \brief      Set colour space converter matrix coefficients
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pMatCoeff   Pointer to Matrix Coefficient structure
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       Matrix Coefficient parameter structure:
+ *                s16 Coeff[9]: Array of coefficients (values -1024 to +1023)
+ * */
+error_code_t
+bsl_matrix_set_coeffs
+(
+    unit_select_t          tx_unit,
+    bsl_mat_coeff_t   *p_mat_coeff
+);
+
+/*============================================================================*/
+/**
+ * bslMatrixSetConversion() parameter type
+ * */
+/** Video input mode */
+typedef enum {
+	HDMITX_VINMODE_CCIR656     = 0,    /**< ccir656  */
+	HDMITX_VINMODE_RGB444      = 1,    /**< RGB444    */
+	HDMITX_VINMODE_YUV444      = 2,    /**< YUV444    */
+	HDMITX_VINMODE_YUV422      = 3,    /**< YUV422    */
+	HDMITX_VINMODE_NO_CHANGE   = 4,    /**< No change */
+	HDMITX_VINMODE_INVALID     = 5     /**< Invalid   */
+} bsl_vin_mode_t;
+
+/** Video output mode */
+typedef enum {
+	HDMITX_VOUTMODE_RGB444      = 0,    /**< RGB444    */
+	HDMITX_VOUTMODE_YUV422      = 1,    /**< YUV422    */
+	HDMITX_VOUTMODE_YUV444      = 2,    /**< YUV444    */
+	HDMITX_VOUTMODE_NO_CHANGE   = 3,    /**< No change */
+	HDMITX_VOUTMODE_INVALID     = 4     /**< Invalid   */
+} bsl_vout_mode_t;
+
+/**
+ * \brief Enum defining possible quantization range
+ * */
+typedef enum {
+	HDMITX_VQR_DEFAULT = 0, /* Follow HDMI spec. */
+	HDMITX_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
+	HDMITX_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
+} bsl_vqr_t;
+
+/**
+ *    \brief      Set colour space conversion using preset values
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  vinFmt          Input video format
+ *    \param[in]  vinMode         Input video mode
+ *    \param[in]  voutFmt         Output video format
+ *    \param[in]  voutMode        Output video mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_matrix_set_conversion
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vin_fmt,
+    bsl_vin_mode_t    vin_mode,
+    bsl_vid_fmt_t     vout_fmt,
+    bsl_vout_mode_t   vout_mode,
+    bsl_vqr_t        dvi_vqr
+);
+
+/*============================================================================*/
+/**
+ * bslMatrixSetInputOffset() parameter type
+ * */
+/** Parameter structure array size */
+enum _bsl_mat_offset {
+	HDMITX_MAT_OFFSET_NUM = 3
+};
+
+/** \brief The bslMatrixSetInputOffset() parameter structure */
+typedef struct _bsl_mat_offset_t {
+	/** Offset array  (values -1024 to +1023) */
+	s16 offset[HDMITX_MAT_OFFSET_NUM];
+} bsl_mat_offset_t;
+
+/** Matrix numeric limits */
+enum _bsl_mat_limits {
+	HDMITX_MAT_OFFSET_MIN      = -1024,
+	HDMITX_MAT_OFFSET_MAX      = 1023
+};
+
+/**
+ *    \brief      Set colour space converter matrix offset at input
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pMatOffset  Pointer to Matrix Offset structure
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ *    \note       Matrix Offset structure parameter structure:
+ *                s16 Offset[3]: Offset array (values -1024 to +1023)
+ * */
+error_code_t
+bsl_matrix_set_input_offset
+(
+    unit_select_t          tx_unit,
+    bsl_mat_offset_t  *p_mat_offset
+);
+
+/*============================================================================*/
+/**
+ * bslMatrixSetMode() parameter types
+ * */
+/** Matrix  control values */
+typedef enum {
+	HDMITX_MCNTRL_ON        = 0,   /**< Matrix on  */
+	HDMITX_MCNTRL_OFF       = 1,   /**< Matrix off */
+	HDMITX_MCNTRL_NO_CHANGE = 2,   /**< Matrix unchanged */
+	HDMITX_MCNTRL_MAX       = 2,   /**< Max value  */
+	HDMITX_MCNTRL_INVALID   = 3    /**< Invalid    */
+} bslm_cntrl_t;
+
+/** Matrix  scale values */
+typedef enum {
+	HDMITX_MSCALE_256       = 0,   /**< Factor 1/256  */
+	HDMITX_MSCALE_512       = 1,   /**< Factor 1/512  */
+	HDMITX_MSCALE_1024      = 2,   /**< Factor 1/1024 */
+	HDMITX_MSCALE_NO_CHANGE = 3,   /**< Factor unchanged */
+	HDMITX_MSCALE_MAX       = 3,   /**< Max value     */
+	HDMITX_MSCALE_INVALID   = 4    /**< Invalid value */
+} bslm_scale_t;
+
+/**
+ *    \brief      Set colour space converter matrix mode
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  mControl    Matrix Control: On, Off, No change
+ *    \param[in]  mScale      Matrix Scale Factor: 1/256, 1/512, 1/1024, No change
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ *    \note       NA
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_matrix_set_mode
+(
+    unit_select_t      tx_unit,
+    bslm_cntrl_t m_control,
+    bslm_scale_t m_scale
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set colour space converter matrix offset at output
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pMatOffset  Pointer to Matrix Offset structure
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ *    \note       Matrix Offset parameter structure:
+ *                nt16 Offset[3]: Offset array (values -1024 to +1023)
+ * */
+error_code_t
+bsl_matrix_set_output_offset
+(
+    unit_select_t          tx_unit,
+    bsl_mat_offset_t  *p_mat_offset
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Enable audio clock recovery packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: when in DVI mode
+ *
+ *    \note       bslAudioInSetCts sets CTS and N values
+ * */
+error_code_t
+bsl_pkt_set_aclk_recovery
+(
+    unit_select_t	tx_unit,
+    bool            b_enable
+);
+
+/*============================================================================*/
+/**
+ * Data Island Packet structure
+ * */
+/** Parameter structure array sizes */
+enum _bsl_pkt {
+	HDMITX_PKT_DATA_BYTE_CNT = 28
+};
+
+/** \brief The parameter structure for bslPkt*() APIs */
+typedef struct _bsl_pkt_t {
+	u8 data_byte[HDMITX_PKT_DATA_BYTE_CNT];       /**< Packet Data   */
+} bsl_pkt_t;
+
+/**
+ *    \brief      Set audio content protection packet & enable/disable packet
+ *                insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pPkt        Pointer to Data Island Packet structure
+ *    \param[in]  byteCnt     Packet buffer byte count
+ *    \param[in]  uAcpType    Content protection type
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: pointer suppied with byte count of zero
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Data Island Packet parameter structure:
+ *                u8 dataByte[28]      Packet Data
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_pkt_set_acp
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    u8               u_acp_type,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ * \brief The Audio Infoframe Parameter structure
+ * */
+typedef struct _bsl_pkt_aif_t {
+	u8 coding_type;       /**< Coding Type 0 to 0Fh */
+	u8 channel_count;     /**< Channel Count 0 to 07h */
+	u8 sample_freq;       /**< Sample Frequency 0 to 07h */
+	u8 sample_size;       /**< Sample Size 0 to 03h */
+	u8 channel_alloc;     /**< Channel Allocation 0 to FFh */
+	bool  down_mix_inhibit;   /**< Downmix inhibit flag 0/1 */
+	u8 level_shift;       /**< Level Shift 0 to 0Fh */
+} bsl_pkt_aif_t;
+
+/**
+ *    \brief      Set audio info frame packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *    \param[in]  pPkt    Pointer to Audio Infoframe structure
+ *    \param[in]  bEnable Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Audio Infoframe structure:
+ *                u8 CodingType
+ *                u8 ChannelCount
+ *                u8 SampleFreq
+ *                u8 SampleSize
+ *                u8 ChannelAlloc
+ *                bool DownMixInhibit
+ *                u8 LevelShift
+ * */
+error_code_t
+bsl_pkt_set_audio_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_aif_t *p_pkt,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set contents of general control packet & enable/disable
+ *                packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  paMute      Pointer to Audio Mute; if NULL, no change to packet
+ *                            contents is made
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       bslAudioOutSetMute must be used to mute the audio output
+ * */
+error_code_t
+bsl_pkt_set_general_cntrl
+(
+    unit_select_t      tx_unit,
+    bsla_mute_t  *pa_mute,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set ISRC1 packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pPkt        Pointer to Data Island Packet structure
+ *    \param[in]  byteCnt     Packet buffer byte count
+ *    \param[in]  bIsrcCont   ISRC continuation flag
+ *    \param[in]  bIsrcValid  ISRC valid flag
+ *    \param[in]  uIsrcStatus ISRC Status
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: pointer suppied with byte count of zero
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Data Island Packet parameter structure:
+ *                u8 dataByte[28]  Packet Data
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_pkt_set_isrc1
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    bool                b_isrc_cont,
+    bool                b_isrc_valid,
+    u8               u_isrc_status,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set ISRC2 packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pPkt        Pointer to Data Island Packet structure
+ *    \param[in]  byteCnt     Packet buffer byte count
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: pointer suppied with byte count of zero
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Data Island Packet parameter structure:
+ *                u8 dataByte[28]      Packet Data
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_pkt_set_isrc2
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ * bslPktSetMpegInfoframe() parameter types
+ * */
+/** MPEG frame types */
+typedef enum {
+	HDMITX_MPEG_FRAME_UNKNOWN   = 0,    /**< Unknown  */
+	HDMITX_MPEG_FRAME_I         = 1,    /**< i-frame   */
+	HDMITX_MPEG_FRAME_B         = 2,    /**< b-frame */
+	HDMITX_MPEG_FRAME_P         = 3,    /**< p-frame */
+	HDMITX_MPEG_FRAME_INVALID   = 4     /**< Invalid   */
+} bsl_mpeg_frame_t;
+
+/** \brief The MPEG Infoframe Parameter structure */
+typedef struct _bsl_pkt_mpeg_t {
+	u32                  bit_rate;        /**< MPEG bit rate in Hz */
+	bsl_mpeg_frame_t  frame_type;      /**< MPEG frame type */
+	/**< 0: new field, 1:repeated field */
+	bool                    b_field_repeat;
+} bsl_pkt_mpeg_t;
+
+/**
+ *    \brief      Set MPEG infoframe packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  pPkt            Pointer to MPEG Infoframe structure
+ *    \param[in]  bEnable         Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       MPEG Infoframe structure:
+ *                u32                  bitRate
+ *                bslMpegFrame_t  frameType
+ *                bool                    bFieldRepeat
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_pkt_set_mpeg_infoframe
+(
+    unit_select_t          tx_unit,
+    bsl_pkt_mpeg_t    *p_pkt,
+    bool                    b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Enable NULL packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ * */
+error_code_t
+bsl_pkt_set_null_insert
+(
+    unit_select_t  tx_unit,
+    bool            b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set single NULL packet insertion (flag auto-resets after
+ *                transmission)
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Operation resets after single transmission
+ * */
+error_code_t
+bsl_pkt_set_null_single
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ * Source Product Description Infoframe Parameter types
+ *  */
+/** SDI frame types */
+typedef enum {
+	HDMITX_SPD_INFO_UNKNOWN     = 0,
+	HDMITX_SPD_INFO_DIGITAL_STB = 1,
+	HDMITX_SPD_INFO_DVD         = 2,
+	HDMITX_SPD_INFO_DVHS        = 3,
+	HDMITX_SPD_INFO_HDD_VIDEO   = 4,
+	HDMITX_SPD_INFO_DVC         = 5,
+	HDMITX_SPD_INFO_DSC         = 6,
+	HDMITX_SPD_INFO_VIDEO_CD    = 7,
+	HDMITX_SPD_INFO_GAME        = 8,
+	HDMITX_SPD_INFO_PC          = 9,
+	HDMITX_SPD_INFO_INVALID     = 10
+} bsl_source_dev_t;
+
+#define HDMI_TX_SPD_VENDOR_SIZE 8
+#define HDMI_TX_SPD_DESCR_SIZE  16
+#define HDMI_TX_SPD_LENGTH      25
+
+/** \brief The Source Product Description Infoframe Parameter structure */
+typedef struct _bsl_pkt_spd_t {
+	/**< Vendor name */
+	u8                   vendor_name[HDMI_TX_SPD_VENDOR_SIZE];
+	/**< Product Description */
+	u8                   prod_descr[HDMI_TX_SPD_DESCR_SIZE];
+	/**< Source Device Info */
+	bsl_source_dev_t  source_dev_info;
+} bsl_pkt_spd_t;
+
+/**
+ *    \brief      Set audio info frame packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *    \param[in]  pPkt    Pointer to Audio Infoframe structure
+ *    \param[in]  bEnable Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Audio Infoframe structure:
+ *                u8                   VendorName[8]
+ *                u8                   ProdDescr[16]
+ *                bslSourceDev_t  SourceDevInfo
+ * */
+error_code_t
+bsl_pkt_set_spd_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_spd_t *p_pkt,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ * \brief The Video Infoframe Parameter structure
+ *  */
+typedef struct _bsl_pkt_vif_t {
+	u8  colour;               /**< 0 to 03h */
+	bool   active_info;           /**< 0/1 */
+	u8  bar_info;              /**< 0 to 03h */
+	u8  scan_info;             /**< 0 to 03h */
+	u8  colorimetry;          /**< 0 to 03h */
+	u8  picture_aspect_ratio;   /**< 0 to 03h */
+	u8  active_format_ratio;    /**< 0 to 0Fh */
+	u8  scaling;              /**< 0 to 03h */
+	u8  vid_format;            /**< 0 to 7Fh */
+	u8  pixel_repeat;          /**< 0 to 0Fh */
+	u16 end_top_bar_line;
+	u16 start_bottom_bar_line;
+	u16 end_left_bar_pixel;
+	u16 start_right_bar_pixel;
+} bsl_pkt_vif_t;
+
+/**
+ *    \brief      Set video infoframe packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit  Transmitter unit number
+ *    \param[in]  pPkt    Pointer to Video Infoframe structure
+ *    \param[in]  bEnable Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Video Infoframe structure:
+ *                u8 Colour
+ *                bool ActiveInfo
+ *                u8 BarInfo
+ *                u8 ScanInfo
+ *                u8 Colorimetry
+ *                u8 PictureAspectRatio
+ *                u8 ActiveFormatRatio
+ *                u8 Scaling
+ *                u8 VidFormat
+ *                u8 PixelRepeat
+ *                u16 EndTopBarLine
+ *                u16 StartBottomBarLine
+ *                u16 EndLeftBarPixel
+ *                u16 StartRightBarPixel   (incorrectly named in [HDMI1.2])
+ * */
+error_code_t
+bsl_pkt_set_video_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_vif_t *p_pkt,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set Vendor Specific Infoframe packet & enable/disable packet insertion
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  pPkt        Pointer to Data Island Packet structure
+ *    \param[in]  byteCnt     Packet buffer byte count
+ *    \param[in]  uVersion    Version number for packet header
+ *    \param[in]  bEnable     Enable or disable packet insertion
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: pointer suppied with byte count of zero
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_NOT_SUPPORTED: not possible with this device
+ *                  - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ *    \note       Data Island Packet parameter structure:
+ *                u8 dataByte[28]      Packet Data (only use 27 bytes max)
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_pkt_set_vs_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    u8               u_version,
+    bool                b_enable
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the power state of the transmitter
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[out] pePowerState Pointer to the power state of the device now
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ *    \note       Power states:
+ *                - tmPowerOn
+ *                - tmPowerStandby
+ * */
+error_code_t
+bsl_power_get_state
+(
+    unit_select_t      tx_unit,
+    p_power_state_t		pe_power_state
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set the power state of the transmitter
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  ePowerState Power state to set
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       Power states (Off and Suspend are treated the same as Standby):
+ *                - tmPowerOn
+ *                - tmPowerStandby
+ *                - tmPowerSuspend
+ *                - tmPowerOff
+ * */
+error_code_t
+bsl_power_set_state
+(
+    unit_select_t      tx_unit,
+    power_state_t      e_power_state
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Reset the HDMI transmitter
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       NA
+ *
+ *    \sa         bslInit
+ * */
+error_code_t
+bsl_reset
+(
+    unit_select_t      tx_unit
+);
+
+/*============================================================================*/
+/**
+ * \brief The bslScalerGet() parameter type
+ * */
+typedef struct _bsl_scaler_diag_t {
+	u16 max_buffill_p;     /**< Filling primary video buffer           */
+	u16 max_buffill_d;     /**< Filling video deinterlaced buffer      */
+	u8 max_fifofill_pi;    /**< Filling primary video input FIFO       */
+	u8 min_fifofill_po1;   /**< Filling primary video output FIFO #1   */
+	u8 min_fifofill_po2;   /**< Filling primary video output FIFO #2   */
+	u8 min_fifofill_po3;   /**< Filling primary video output FIFO #3   */
+	u8 min_fifofill_po4;   /**< Filling primary video output FIFO #4   */
+	u8 max_fifofill_di;    /**< Filling deinterlaced video input FIFO  */
+	u8 max_fifofill_do;    /**< Filling deinterlaced video output FIFO */
+} bsl_scaler_diag_t;
+
+/**
+ *    \brief      Get diagnostic counters from the scaler
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pScalerDiag Pointer to structure to receive scaler diagnostic
+ *                            registers
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ *    \note       scaler diagnostic registers structure:
+ *                u16 maxBuffill_p     Filling primary video buffer
+ *                u16 maxBuffill_d     Filling video deinterlaced buffer
+ *                u8  maxFifofill_pi   Filling primary video input FIFO
+ *                u8  minFifofill_po1  Filling primary video output FIFO #1
+ *                u8  minFifofill_po2  Filling primary video output FIFO #2
+ *                u8  minFifofill_po3  Filling primary video output FIFO #3
+ *                u8  minFifofill_po4  Filling primary video output FIFO #4
+ *                u8  maxFifofill_di   Filling deinterlaced video input FIFO
+ *                u8  maxFifofill_do   Filling deinterlaced video output FIFO
+ * */
+error_code_t
+bsl_scaler_get
+(
+    unit_select_t           tx_unit,
+    bsl_scaler_diag_t *p_scaler_diag
+);
+
+/*============================================================================*/
+/**
+ * bslScalerGetMode() parameter types
+ * */
+/** Scaler modes */
+typedef enum {
+	HDMITX_SCAMODE_OFF       = 0,    /**< Off  */
+	HDMITX_SCAMODE_ON        = 1,    /**< On   */
+	HDMITX_SCAMODE_AUTO      = 2,    /**< Auto */
+	HDMITX_SCAMODE_NO_CHANGE = 3,    /**< No change */
+	HDMITX_SCAMODE_INVALID   = 4     /**< Invalid   */
+} bsl_sca_mode_t;
+
+/**
+ *    \brief      Get the current scaler mode
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[out] pScalerMode Pointer to variable to receive scaler mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_scaler_get_mode
+(
+    unit_select_t		      tx_unit,
+    bsl_sca_mode_t      *p_scaler_mode
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Enable or disable scaler input frame
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  bDisable    Enable or disable scaler input
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_scaler_in_disable
+(
+    unit_select_t  tx_unit,
+    bool            b_disable
+);
+
+/*============================================================================*/
+/**
+ * bslScalerSetCoeffs() parameter types
+ * */
+/** Scaler lookup table selection */
+typedef enum {
+	HDMITX_SCALUT_DEFAULT_TAB1     = 0,    /**< Use default table 1 */
+	HDMITX_SCALUT_DEFAULT_TAB2     = 1,    /**< Use default table 2 */
+	HDMITX_SCALUT_USE_VSLUT        = 2,    /**< Use vsLut parameter */
+	HDMITX_SCALUT_INVALID          = 3     /**< Invalid value       */
+} bsl_sca_lut_t;
+
+/** Scaler control parameter structure array size */
+enum _bslvs_lut {
+	HDMITX_VSLUT_COEFF_NUM         = 45
+};
+
+/**
+ *    \brief      Set the active coefficient lookup table for the vertical scaler
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  lutSel      Coefficient lookup table selection
+ *    \param[in]  pVsLut      Table of HDMITX_VSLUT_COEFF_NUM coefficient values
+ *                            (may be null if lutSel not HDMITX_SCALUT_USE_VSLUT)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: two parameters disagree
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_scaler_set_coeffs
+(
+    unit_select_t        tx_unit,
+    bsl_sca_lut_t   lut_sel,
+    u8                *p_vs_lut
+);
+
+/*============================================================================*/
+/**
+ * bslScalerSetFieldOrder() parameter types
+ * */
+/** IntExt values */
+typedef enum {
+	HDMITX_INTEXT_INTERNAL         = 0,    /**< Internal  */
+	HDMITX_INTEXT_EXTERNAL         = 1,    /**< External  */
+	HDMITX_INTEXT_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_INTEXT_INVALID          = 3     /**< Invalid   */
+} bsl_int_ext_t;
+
+/** TopSel values */
+typedef enum {
+	HDMITX_TOPSEL_INTERNAL         = 0,    /**< Internal  */
+	HDMITX_TOPSEL_VRF              = 1,    /**< VRF       */
+	HDMITX_TOPSEL_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_TOPSEL_INVALID          = 3     /**< Invalid   */
+} bsl_top_sel_t;
+
+/** TopTgl values */
+typedef enum {
+	HDMITX_TOPTGL_NO_ACTION        = 0,    /**< NO action */
+	HDMITX_TOPTGL_TOGGLE           = 1,    /**< Toggle    */
+	HDMITX_TOPTGL_NO_CHANGE        = 2,    /**< No change */
+	HDMITX_TOPTGL_INVALID          = 3     /**< Invalid   */
+} bsl_top_tgl_t;
+
+/**
+ *    \brief      Set scaler field positions
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  topExt      Internal, External, No Change
+ *    \param[in]  deExt       Internal, External, No Change
+ *    \param[in]  topSel      Internal, VRF, No Change
+ *    \param[in]  topTgl      No Action, Toggle, No Change
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_scaler_set_field_order
+(
+    unit_select_t      tx_unit,
+    bsl_int_ext_t top_ext,
+    bsl_int_ext_t de_ext,
+    bsl_top_sel_t top_sel,
+    bsl_top_tgl_t top_tgl
+);
+
+/*============================================================================*/
+/**
+ * bslScalerSetFine() parameter types
+ * */
+/** Reference pixel values */
+enum _bsl_scaler_fine_pixel_limits {
+	HDMITX_SCALER_FINE_PIXEL_MIN        = 0x0000,
+	HDMITX_SCALER_FINE_PIXEL_MAX        = 0x1FFF,
+	HDMITX_SCALER_FINE_PIXEL_NO_CHANGE  = 0x2000,
+	HDMITX_SCALER_FINE_PIXEL_INVALID    = 0x2001
+};
+
+/** Reference line values */
+enum _bsl_scaler_fine_line_limits {
+	HDMITX_SCALER_FINE_LINE_MIN         = 0x0000,
+	HDMITX_SCALER_FINE_LINE_MAX         = 0x07FF,
+	HDMITX_SCALER_FINE_LINE_NO_CHANGE   = 0x0800,
+	HDMITX_SCALER_FINE_LINE_INVALID     = 0x0801
+};
+
+/**
+ *    \brief      Set scaler fine adjustment options
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  uRefPix      Ref. pixel preset 0 to 1FFFh (2000h = No Change)
+ *    \param[in]  uRefLine     Ref. line preset 0 to 7FFh (800h = No Change)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_scaler_set_fine
+(
+    unit_select_t  tx_unit,
+    u16          u_ref_pix,
+    u16          u_ref_line
+);
+
+/*============================================================================*/
+/**
+ * bslScalerSetSync() parameter types
+ * */
+/** Video sync method */
+typedef enum {
+	HDMITX_VSMETH_V_H          = 0,    /**< V and H    */
+	HDMITX_VSMETH_V_XDE        = 1,    /**< V and X-DE */
+	HDMITX_VSMETH_NO_CHANGE    = 2,    /**< No change  */
+	HDMITX_VSMETH_INVALID      = 3     /**< Invalid    */
+} bsl_vs_meth_t;
+
+/** Line/pixel counters sync */
+typedef enum {
+	HDMITX_VSONCE_EACH_FRAME   = 0,    /**< Sync on each frame */
+	HDMITX_VSONCE_ONCE         = 1,    /**< Sync once only     */
+	HDMITX_VSONCE_NO_CHANGE    = 2,    /**< No change  */
+	HDMITX_VSONCE_INVALID      = 3     /**< Invalid    */
+} bsl_vs_once_t;
+
+/**
+ *    \brief      Set scaler synchronization options
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  method       Sync. combination method
+ *    \param[in]  once         Line/pixel counters sync once or each frame
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_scaler_set_sync
+(
+    unit_select_t      tx_unit,
+    bsl_vs_meth_t method,
+    bsl_vs_once_t once
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the driver software version and compatibility numbers
+ *
+ *    \param[out] pSWVersion   Pointer to the software version structure returned
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_sw_get_version
+(
+    p_swversion_t      p_swversion
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the driver software version and compatibility numbers
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  waitMs       Period in milliseconds to wait
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_sys_timer_wait
+(
+    unit_select_t      tx_unit,
+    u16              wait_ms
+);
+
+/*============================================================================*/
+/**
+ * bslTmdsSetOutputs() parameter types
+ * */
+/** TMDS output mode */
+typedef enum {
+	HDMITX_TMDSOUT_NORMAL      = 0,    /**< Normal outputs   */
+	HDMITX_TMDSOUT_NORMAL1     = 1,    /**< Normal outputs, same as 0  */
+	HDMITX_TMDSOUT_FORCED0     = 2,    /**< Forced 0 outputs */
+	HDMITX_TMDSOUT_FORCED1     = 3,    /**< Forced 1 outputs */
+	HDMITX_TMDSOUT_INVALID     = 4     /**< Invalid          */
+} bsl_tmds_out_t;
+
+/**
+ *    \brief      Set the TMDS outputs to normal active operation or to a forced
+ *                state
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  tmdsOut     TMDS output mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_tmds_set_outputs
+(
+    unit_select_t          tx_unit,
+    bsl_tmds_out_t    tmds_out
+);
+
+/*============================================================================*/
+/**
+ * bslTmdsSetSerializer() parameter types
+ * */
+/** Serializer phase limits */
+enum _bsl_tmds_phase {
+	HDMITX_TMDSPHASE_MIN       = 0,
+	HDMITX_TMDSPHASE_MAX       = 15,
+	HDMITX_TMDSPHASE_INVALID   = 16
+};
+
+/**
+ *    \brief      Fine-tune the TMDS serializer
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  uPhase2     Serializer phase 2
+ *    \param[in]  uPhase3     Serializer phase 3
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ * */
+error_code_t
+bsl_tmds_set_serializer
+(
+    unit_select_t  tx_unit,
+    u8           u_phase2,
+    u8           u_phase3
+);
+
+/*============================================================================*/
+/**
+ * bslTestSetPattern() parameter types
+ * */
+/** Test pattern types */
+typedef enum {
+	HDMITX_PATTERN_OFF     = 0, /**< Insert test pattern     */
+	HDMITX_PATTERN_CBAR4   = 1, /**< Insert 4-bar colour bar */
+	HDMITX_PATTERN_CBAR8   = 2, /**< Insert 8-bar colour bar */
+	HDMITX_PATTERN_BLUE	   = 3, /**< Insert Blue screen		 */
+	HDMITX_PATTERN_INVALID = 4  /**< Invalid pattern		 */
+} bsl_test_pattern_t;
+
+/*
+ *    \brief      Set a colour bar test pattern
+ *
+ *    \param[in]  txUnit     Transmitter unit number
+ *    \param[in]  pattern    Test pattern
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_test_set_pattern
+(
+    unit_select_t           tx_unit,
+    bsl_test_pattern_t pattern
+);
+
+/*============================================================================*/
+/**
+ * bslTestSetMode() parameter types
+ * */
+/** Test modes */
+typedef enum {
+	HDMITX_TESTMODE_PAT     = 0,/**< Insert test pattern                    */
+	HDMITX_TESTMODE_656     = 1,/**< Inject CCIR-656 video via audio port   */
+	HDMITX_TESTMODE_SERPHOE = 2,/**< Activate srl_tst_ph2_o & srl_tst_ph3_o */
+	HDMITX_TESTMODE_NOSC    = 3,/**< Input nosc predivider = PLL-ref input  */
+	HDMITX_TESTMODE_HVP     = 4,/**< Test high voltage protection cells     */
+	HDMITX_TESTMODE_PWD     = 5,/**< Test PLLs in sleep mode                */
+	HDMITX_TESTMODE_DIVOE   = 6,/**< Enable scaler PLL divider test output  */
+	HDMITX_TESTMODE_INVALID = 7 /**< Invalid test							*/
+} bsl_test_mode_t;
+
+/** Test states */
+typedef enum {
+	HDMITX_TESTSTATE_OFF     = 0,  /**< Disable the selected test */
+	HDMITX_TESTSTATE_ON      = 1,  /**< Enable the selected test  */
+	HDMITX_TESTSTATE_INVALID = 2   /**< Invalid value */
+} bsl_test_state_t;
+
+/**
+ *    \brief      Set or clear one or more simultaneous test modes
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  testMode    Mode: tst_pat, tst_656, tst_serphoe, tst_nosc,
+ *                            tst_hvp, tst_pwd, tst_divoe
+ *    \param[in]  testState   State: 1=On, 0=Off
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_test_set_mode
+(
+    unit_select_t          tx_unit,
+    bsl_test_mode_t   test_mode,
+    bsl_test_state_t  test_state
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetBlanking() parameter types
+ * */
+/** Blankit Source */
+typedef enum {
+	HDMITX_BLNKSRC_NOT_DE       = 0,       /**< Source=Not DE        */
+	HDMITX_BLNKSRC_VS_HS        = 1,       /**< Source=VS And HS     */
+	HDMITX_BLNKSRC_VS_NOT_HS    = 2,       /**< Source=VS And Not HS */
+	HDMITX_BLNKSRC_VS_HEMB_VEMB = 3,       /**< Source=Hemb And Vemb */
+	HDMITX_BLNKSRC_NO_CHANGE    = 4,       /**< No change */
+	HDMITX_BLNKSRC_INVALID      = 5        /**< Invalid   */
+} bsl_blnk_src_t;
+
+/** Blanking Codes */
+typedef enum {
+	HDMITX_BLNKCODE_ALL_0       = 0,       /**< Code=All Zero */
+	HDMITX_BLNKCODE_RGB444      = 1,       /**< Code=RGB444   */
+	HDMITX_BLNKCODE_YUV444      = 2,       /**< Code=YUV444   */
+	HDMITX_BLNKCODE_YUV422      = 3,       /**< Code=YUV422   */
+	HDMITX_BLNKCODE_NO_CHANGE   = 4,       /**< No change */
+	HDMITX_BLNKCODE_INVALID     = 5        /**< Invalid   */
+} bsl_blnk_code_t;
+
+/**
+ *    \brief      Enable blanking between active data
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  blankitSource   Blankit Source: Not DE, VS And HS,
+ *                                VS And Not HS, Hemb And Vemb, No Change
+ *    \param[in]  blankingCodes   Blanking Codes: All Zero, RGB444, YUV444,
+ *                                YUV422, No Change
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       NA
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_video_in_set_blanking
+(
+    unit_select_t         tx_unit,
+    bsl_blnk_src_t   blankit_source,
+    bsl_blnk_code_t  blanking_codes
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetConfig() parameter types
+ * */
+/** Sample edge */
+typedef enum {
+	HDMITX_PIXEDGE_CLK_POS      = 0,        /**< Pixel Clock Positive Edge */
+	HDMITX_PIXEDGE_CLK_NEG      = 1,        /**< Pixel Clock Negative Edge */
+	HDMITX_PIXEDGE_NO_CHANGE    = 2,        /**< No Change */
+	HDMITX_PIXEDGE_INVALID      = 3         /**< Invalid   */
+} bsl_pix_edge_t;
+
+/** Upsample modes */
+typedef enum {
+	HDMITX_UPSAMPLE_BYPASS      = 0,        /**< Bypass */
+	HDMITX_UPSAMPLE_COPY        = 1,        /**< Copy */
+	HDMITX_UPSAMPLE_INTERPOLATE = 2,        /**< Interpolate */
+	/**< Auto: driver chooses best value */
+	HDMITX_UPSAMPLE_AUTO        = 3,
+	HDMITX_UPSAMPLE_NO_CHANGE   = 4,        /**< No Change */
+	HDMITX_UPSAMPLE_INVALID     = 5         /**< Invalid   */
+} bsl_upsample_mode_t;
+
+/**
+ *    \brief      Configure video input options and control the upsampler
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  vinMode         Video input mode
+ *    \param[in]  sampleEdge      Sample edge:
+ *                                Pixel Clock Positive Edge,
+ *                                Pixel Clock Negative Edge, No Change
+ *    \param[in]  pixRate         Single data or double data rate
+ *    \param[in]  upsampleMode    Upsample mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_in_set_config
+(
+    unit_select_t            tx_unit,
+    bsl_vin_mode_t      vin_mode,
+    bsl_pix_edge_t      sample_edge,
+    bsl_pix_rate_t      pix_rate,
+    bsl_upsample_mode_t upsample_mode
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetFine() parameter types
+ * */
+/** Subpacket count */
+typedef enum {
+	HDMITX_PIXSUBPKT_FIX_0      = 0,        /**< Fix At 0 */
+	HDMITX_PIXSUBPKT_FIX_1      = 1,        /**< Fix At 1 */
+	HDMITX_PIXSUBPKT_FIX_2      = 2,        /**< Fix At 2 */
+	HDMITX_PIXSUBPKT_FIX_3      = 3,        /**< Fix At 3 */
+	HDMITX_PIXSUBPKT_SYNC_FIRST = 4,        /**< First Sync value */
+	HDMITX_PIXSUBPKT_SYNC_HEMB  = 4,        /**< Sync By Hemb */
+	HDMITX_PIXSUBPKT_SYNC_DE    = 5,        /**< Sync By Rising Edge DE */
+	HDMITX_PIXSUBPKT_SYNC_HS    = 6,        /**< Sync By Rising Edge HS */
+	HDMITX_PIXSUBPKT_NO_CHANGE  = 7,        /**< No Change */
+	HDMITX_PIXSUBPKT_INVALID    = 8,        /**< Invalid   */
+	HDMITX_PIXSUBPKT_SYNC_FIXED = 3         /**< Not used as a parameter value,
+ *  but used internally when
+ *  Fix at 0/1/2/3 values are set */
+} bsl_pix_subpkt_t;
+
+/** Toggling */
+typedef enum {
+	HDMITX_PIXTOGL_NO_ACTION    = 0,        /**< No Action  */
+	HDMITX_PIXTOGL_ENABLE       = 1,        /**< Toggle     */
+	HDMITX_PIXTOGL_NO_CHANGE    = 2,        /**< No Change  */
+	HDMITX_PIXTOGL_INVALID      = 3         /**< Invalid    */
+} bsl_pix_togl_t;
+
+/**
+ *    \brief      Set fine image position
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  subpacketCount  Subpacket Count fixed values and sync options
+ *    \param[in]  toggleClk1      Toggle clock 1 phase w.r.t. clock 2
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       NA
+ *
+ *    \sa         NA
+ * */
+error_code_t
+bsl_video_in_set_fine
+(
+    unit_select_t            tx_unit,
+    bsl_pix_subpkt_t    subpacket_count,
+    bsl_pix_togl_t      toggle_clk1
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetMapping() parameter types
+ * */
+/** Video input port parameter structure array size and limits */
+enum _bsl_vin_port_map {
+	HDMITX_VIN_PORT_MAP_TABLE_LEN    = 6,
+
+	HDMITX_VIN_PORT_SWAP_NO_CHANGE   = 6,
+	HDMITX_VIN_PORT_SWAP_INVALID     = 7,
+
+	HDMITX_VIN_PORT_MIRROR_NO_CHANGE = 2,
+	HDMITX_VIN_PORT_MIRROR_INVALID   = 3
+};
+
+/**
+ *    \brief      Set video input port swapping and mirroring
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[in]  pSwapTable      Pointer to 6-byte port swap table
+ *    \param[in]  pMirrorTable    Pointer to 6-byte port mirror table
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       u8 pSwapTable[6]
+ *
+ *                Each table position 0 to 5 represents a group of 4 port bits:
+ *                [0]=23:20, [1]=16:19, [2]=15:12, [3]=11:8, [4]=4:7, [5]=0:3
+ *                Table position values are 0 to 6, denoting the group of 4 port
+ *                bits to swap to: 0=23:20, 1=16:19, 2=15:12, 3=11:8, 4=4:7, 5=0:3.
+ *                For example, to swap port bits 15:12 to bits 4:7: pSwapTable[2]=4
+ *
+ *                u8 pMirrorTable[6]
+ *
+ *                Each table position 0 to 5 represents a group of 4 port bits:
+ *                [0]=23:20, [1]=16:19, [2]=15:12, [3]=11:8, [4]=4:7, [5]=0:3.
+ *                Cell values are 0 to 2 (Not Mirrored, Mirrored, No Change).
+ *                For example, to mirror port bits 11:8 to bits 8:11:
+ *                pMirrorTable[3]=1.
+ * */
+error_code_t
+bsl_video_in_set_mapping
+(
+    unit_select_t  tx_unit,
+    u8           *p_swap_table,
+    u8           *p_mirror_table
+);
+
+/*============================================================================*/
+
+#define HDMITX_ENABLE_VP_TABLE_LEN	3
+#define HDMITX_GROUND_VP_TABLE_LEN	3
+
+/**
+ *    \brief      Set video input port (enable, ground)
+ *
+ *    \param[in]  txUnit                Transmitter unit number
+ *    \param[in]  pEnaVideoPortTable    Pointer to 3-byte video port enable table
+ *    \param[in]  pGndVideoPortTable    Pointer to 3-byte video port ground table
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       u8 pEnaVideoPortTable[3]
+ *
+ *                Each table position 0 to 2 represents a group of 8 port bits:
+ *                [0]=7:0, [1]=15:8, [2]=23:16
+ *                bitn = '1' means enable port n
+ *				bitn = '0' means disable port n
+ *				For example, to enable port 0 to 7 only : pEnaVideoPortTable[0]= 0xFF
+ *                pEnaVideoPortTable[1]= 0x00, pEnaVideoPortTable[2]= 0x00
+ *
+ *				u8 pGndVideoPortTable[3]
+ *
+ *                Each table position 0 to 2 represents a group of 8 port bits:
+ *                [0]=7:0, [1]=15:8, [2]=23:16
+ *                bitn = '1' means pulldown port n
+ *				bitn = '0' means not pulldown port n
+ *				For example, to pulldown port 8 to 15 only : pEnaVideoPortTable[0]= 0x00
+ *                pEnaVideoPortTable[1]= 0xFF, pEnaVideoPortTable[2]= 0x00
+ * */
+error_code_t
+bsl_set_video_port_config
+(
+    unit_select_t  tx_unit,
+    u8			*p_ena_video_port_table,
+    u8			*p_gnd_video_port_table
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set audio input port (enable, ground)
+ *
+ *    \param[in]  txUnit                Transmitter unit number
+ *    \param[in]  pEnaAudioPortTable    Pointer to 1-byte audio port enable configuration
+ *    \param[in]  pGndAudioPortTable    Pointer to 1-byte audio port ground configuration
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ *    \note       u8 pEnaAudioPortTable[1]
+ *                bitn = '1' means enable port n
+ *				bitn = '0' means disable port n
+ *				For example, to enable all audio port (0:7) : pEnaAudioPortTable[0]= 0xFF
+ *
+ *				u8 pGndAudioPortTable[1]
+ *                bitn = '1' means pulldown port n
+ *				bitn = '0' means not pulldown port n
+ *				For example, to pulldown audio port (0:7) : pEnaAudioPortTable[0]= 0xFF
+ * */
+error_code_t
+bsl_set_audio_port_config
+(
+    unit_select_t  tx_unit,
+    u8			*p_ena_audio_port_table,
+    u8			*p_gnd_audio_port_table
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetSyncAuto() parameter types
+ * */
+/** Sync source - was Embedded sync HDMITX_PIXEMBSYNC_ */
+typedef enum {
+	HDMITX_SYNCSRC_EMBEDDED  = 0,        /**< Embedded sync */
+	HDMITX_SYNCSRC_EXT_VREF  = 1,        /**< External sync Vref, Href, Fref */
+	HDMITX_SYNCSRC_EXT_VS    = 2,        /**< External sync Vs, Hs */
+	HDMITX_SYNCSRC_NO_CHANGE = 3,        /**< No Change     */
+	HDMITX_SYNCSRC_INVALID   = 4         /**< Invalid       */
+} bsl_sync_source_t;
+
+/**
+ *    \brief      Configure video input sync automatically
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  syncSource   Sync Source:
+ *                             Embedded, External Vref, External Vs
+ *                             No Change
+ *    \param[in]  vinFmt       EIA/CEA Video input format: 1 to 31, 0 = No Change
+ *    \param[in]  vinMode      Input video mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_in_set_sync_auto
+(
+    unit_select_t            tx_unit,
+    bsl_sync_source_t   sync_source,
+    bsl_vid_fmt_t       vin_fmt,
+    bsl_vin_mode_t      vin_mode
+
+);
+
+/*============================================================================*/
+/**
+ * bslVideoInSetSyncManual() parameter types
+ * */
+/** Video output frame pixel values */
+enum _bsl_vout_fine_pixel_limits {
+	HDMITX_VOUT_FINE_PIXEL_MIN        = 0x0000,
+	HDMITX_VOUT_FINE_PIXEL_MAX        = 0x1FFF,
+	HDMITX_VOUT_FINE_PIXEL_NO_CHANGE  = 0x2000,
+	HDMITX_VOUT_FINE_PIXEL_INVALID    = 0x2001
+};
+
+/** Video output frame line values */
+enum _bsl_vout_fine_line_limits {
+	HDMITX_VOUT_FINE_LINE_MIN         = 0x0000,
+	HDMITX_VOUT_FINE_LINE_MAX         = 0x07FF,
+	HDMITX_VOUT_FINE_LINE_NO_CHANGE   = 0x0800,
+	HDMITX_VOUT_FINE_LINE_INVALID     = 0x0801
+};
+/**
+ *    \brief      Configure video input sync with manual parameters
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  syncSource   Sync Source:
+ *                             Embedded, External Vref, External Vs
+ *                             No Change
+ *    \param[in]  syncMethod   Sync method: V And H, V And X-DE, No Change
+ *    \param[in]  toggleV      VS Toggle:
+ *                             No Action, Toggle VS/Vref, No Change
+ *    \param[in]  toggleH      HS Toggle:
+ *                             No Action, Toggle HS/Href, No Change
+ *    \param[in]  toggleX      DE/FREF Toggle:
+ *                             No Action, Toggle DE/Fref, No Change
+ *    \param[in]  uRefPix      Ref. pixel preset 0 to 1FFFh (2000h = No Change)
+ *    \param[in]  uRefLine     Ref. line preset 0 to 7FFh (800h = No Change)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_in_set_sync_manual
+(
+    unit_select_t            tx_unit,
+    bsl_sync_source_t   sync_source,
+    bsl_vs_meth_t       sync_method,
+    bsl_pix_togl_t      toggle_v,
+    bsl_pix_togl_t      toggle_h,
+    bsl_pix_togl_t      toggle_x,
+    u16                    u_ref_pix,
+    u16                    u_ref_line
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Enable or disable output video frame
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  bDisable    Enable or disable scaler input
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_out_disable
+(
+    unit_select_t  tx_unit,
+    bool            b_disable
+);
+
+/*============================================================================*/
+/**
+ * bslVideoOutSetConfig() parameter types
+ * */
+/** Prefilter */
+typedef enum {
+	HDMITX_VOUT_PREFIL_OFF         = 0,    /**< Off */
+	HDMITX_VOUT_PREFIL_121         = 1,    /**< 121 */
+	HDMITX_VOUT_PREFIL_109         = 2,    /**< 109 */
+	HDMITX_VOUT_PREFIL_CCIR601     = 3,    /**< CCIR601   */
+	HDMITX_VOUT_PREFIL_NO_CHANGE   = 4,    /**< No Change */
+	HDMITX_VOUT_PREFIL_INVALID     = 5     /**< Invalid   */
+} bsl_vout_prefil_t;
+
+/** YUV blanking */
+typedef enum {
+	HDMITX_VOUT_YUV_BLNK_16        = 0,    /**< 16 */
+	HDMITX_VOUT_YUV_BLNK_0         = 1,    /**< 0  */
+	HDMITX_VOUT_YUV_BLNK_NO_CHANGE = 2,    /**< No Change */
+	HDMITX_VOUT_YUV_BLNK_INVALID   = 3     /**< Invalid   */
+} bsl_vout_yuv_blnk_t;
+
+/** Video quantization range */
+typedef enum {
+	HDMITX_VOUT_QRANGE_FS          = 0,    /**< Full Scale */
+	HDMITX_VOUT_QRANGE_RGB_YUV     = 1,    /**< RGB Or YUV */
+	HDMITX_VOUT_QRANGE_YUV         = 2,    /**< YUV        */
+	HDMITX_VOUT_QRANGE_NO_CHANGE   = 3,    /**< No Change  */
+	HDMITX_VOUT_QRANGE_INVALID     = 4     /**< Invalid    */
+} bsl_vout_qrange_t;
+
+/**
+ *    \brief      Configure sink type, configure video output colour and
+ *                quantization, control the downsampler, and force RGB output
+ *                and mute audio in DVI mode
+ *
+ *    \param[in]  txUnit          Transmitter unit number:
+ *    \param[in]  sinkType        Sink device type: DVI or HDMI or copy from EDID
+ *    \param[in]  voutMode        Video output mode
+ *    \param[in]  preFilter       Prefilter: Off, 121, 109, CCIR601, No Change
+ *    \param[in]  yuvBlank        YUV blanking: 16, 0, No Change
+ *    \param[in]  quantization    Video quantization range:
+ *                                Full Scale, RGB Or YUV, YUV, No Change
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_out_set_config
+(
+    unit_select_t            tx_unit,
+    bsl_sink_type_t     sink_type,
+    bsl_vout_mode_t     vout_mode,
+    bsl_vout_prefil_t   pre_filter,
+    bsl_vout_yuv_blnk_t  yuv_blank,
+    bsl_vout_qrange_t   quantization
+);
+
+/*============================================================================*/
+/**
+ * bslVideoOutSetSync() parameter types
+ * */
+/** Video sync source */
+typedef enum {
+	HDMITX_VSSRC_INTERNAL      = 0,    /**< Internal  */
+	HDMITX_VSSRC_EXTERNAL      = 1,    /**< External  */
+	HDMITX_VSSRC_NO_CHANGE     = 2,    /**< No change */
+	HDMITX_VSSRC_INVALID       = 3     /**< Invalid   */
+} bsl_vs_src_t;
+
+/** Video sync toggle */
+typedef enum {
+	HDMITX_VSTGL_TABLE         = 0,    /**< Vs/Hs polarity from table */
+	HDMITX_VSTGL_UNUSED_1      = 1,    /**< Unused          */
+	HDMITX_VSTGL_UNUSED_2      = 2,    /**< Unused          */
+	HDMITX_VSTGL_UNUSED_3      = 3,    /**< Unused          */
+	HDMITX_VSTGL_NO_ACTION     = 4,    /**< No toggle       */
+	HDMITX_VSTGL_HS            = 5,    /**< Toggle Hs       */
+	HDMITX_VSTGL_VS            = 6,    /**< Toggle Vs       */
+	HDMITX_VSTGL_HS_VS         = 7,    /**< Toggle Hs & Vs  */
+	HDMITX_VSTGL_NO_CHANGE     = 8,    /**< No change       */
+	HDMITX_VSTGL_INVALID       = 9     /**< Invalid         */
+} bsl_vs_tgl_t;
+
+/**
+ *    \brief      Set video synchronization
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  srcH        Horizontal sync source: Internal, Exter'l, No Change
+ *    \param[in]  srcV        Vertical sync source: Internal, Exter'l, No Change
+ *    \param[in]  srcX        X sync source: Internal, Exter'l, No Change
+ *    \param[in]  toggle      Sync toggle: Hs, Vs, Off, No Change
+ *    \param[in]  once        Line/pixel counters sync once or each frame
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_out_set_sync
+(
+    unit_select_t          tx_unit,
+    bsl_vs_src_t      src_h,
+    bsl_vs_src_t      src_v,
+    bsl_vs_src_t      src_x,
+    bsl_vs_tgl_t      toggle,
+    bsl_vs_once_t     once
+);
+
+/*============================================================================*/
+/**
+ * bslVideoSetInOut() parameter types
+ * */
+/** Pixel repetition values */
+enum _bsl_pix_repeat {
+	HDMITX_PIXREP_NONE       = 0,    /**< No repetition  */
+	HDMITX_PIXREP_MIN        = 0,    /**< 1 repetition   */
+	HDMITX_PIXREP_MAX        = 9,    /**< 10 repetitions */
+	/**< Default repetitions for output format */
+	HDMITX_PIXREP_DEFAULT    = 10,
+	HDMITX_PIXREP_NO_CHANGE  = 11,   /**< No change */
+	HDMITX_PIXREP_INVALID    = 12    /**< Invalid   */
+};
+
+/** Matrix modes */
+typedef enum {
+	HDMITX_MATMODE_OFF       = 0,    /**< Off  */
+	HDMITX_MATMODE_AUTO      = 1,    /**< Auto */
+	HDMITX_MATMODE_NO_CHANGE = 2,    /**< No change */
+	HDMITX_MATMODE_INVALID   = 3     /**< Invalid   */
+} bsl_mat_mode_t;
+
+/** Datapath bitwidth */
+typedef enum {
+	HDMITX_VOUT_DBITS_12           = 0,    /**< 12 bits */
+	HDMITX_VOUT_DBITS_8            = 1,    /**< 8 bits  */
+	HDMITX_VOUT_DBITS_10           = 2,    /**< 10 bits */
+	HDMITX_VOUT_DBITS_NO_CHANGE    = 3,    /**< No change */
+	HDMITX_VOUT_DBITS_INVALID      = 4     /**< Invalid   */
+} bsl_vout_dbits_t;
+
+/**
+ *    \brief      Set main video input and output parameters
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  vinFmt       EIA/CEA Video input format: 1 to 31, 0 = No Change
+ *    \param[in]  scaMode      Scaler mode: Off, On, Auto, No Change
+ *    \param[in]  voutFmt      EIA/CEA Video output format: 1 to 31, 0 = No Change
+ *    \param[in]  uPixelRepeat Pixel repetition factor: 0 to 9, 10 = default,
+ *                             11 = no change
+ *    \param[in]  matMode      Matrix mode: 0 = off, 1 = auto
+ *    \param[in]  datapathBits Datapath bitwidth: 0 to 3 (8, 10, 12, No Change)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_INCONSISTENT_PARAMS: params are inconsistent
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_video_set_in_out
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vin_fmt,
+    bsl_sca_mode_t    sca_mode,
+    bsl_vid_fmt_t     vout_fmt,
+    u8                   u_pixel_repeat,
+    bsl_mat_mode_t    mat_mode,
+    bsl_vout_dbits_t  datapath_bits,
+    bsl_vqr_t        dvi_vqr
+);
+
+/**
+ *    \brief      Use only for debug to flag the software debug interrupt
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected:
+ *                  - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *                  - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *                  - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ * */
+error_code_t
+bsl_flag_sw_int
+(
+    unit_select_t	            tx_unit
+)
+;
+
+/**
+ *    \brief Return the category of equipement connected
+ *
+ *    \param txUnit   Transmitter unit number
+ *    \param category return category type
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_HDMI_INCONSISTENT_PARAMS: params are inconsistent
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED hdcp not started
+ *
+ * */
+error_code_t
+bsl_hdcp_get_sink_category
+(
+    unit_select_t              tx_unit,
+    bsl_sink_category_t   *category
+);
+
+#endif /* BSLHDMITX_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx_app.h b/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx_app.h
new file mode 100755
index 0000000..660e0ac
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/inc/tmbslHdmiTx_app.h
@@ -0,0 +1,551 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl_app.h
+ *
+ * \version       $Revision: 23 $
+ *
+ * \date          $Date: 10/10/07 11:11 $
+ *
+ * \brief         Application-level API for BSL driver component for the
+ *                TDA998x HDMI Transmitter
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc,
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: bsl_app.h $
+ *
+ ******************  version 23  ****************
+ * User: G. Burnouf     Date: 18/02/08
+ * Updated in $/Source/bsl/Inc
+ * PR1355 : Set audio channel allocation
+ *
+ * ****************  Version 22  ****************
+ * User: B.Vereecke     Date: 10/10/07   Time: 11:11
+ * Updated in $/Source/bsl/Inc
+ * PR815 : Update bluescreen infoframes
+ *         According to the output mode
+ *
+ * * **************  Version 21  *****************
+ * User: B.Vereecke   Date: 30/08/07   Time: 14:45
+ * Updated in $/Source/bsl/Inc
+ * PR4   - add new appHdmiTx_ReadEdidAtPowerOn()
+ *		   function, calling result after resuming
+ *		   from power_down is an EDID reading.
+ *
+ * * **************  Version 20  *****************
+ * User: B.Vereecke   Date: 20/07/07   Time: 17:30
+ * Updated in $/Source/bsl/Inc
+ * PR502 - Add new appHdmiTx_setAudio() function
+ *		   for change Audio parameters without update
+ *		   video input/output
+ *
+ *****************  version 19  ******************
+ * User: B.Vereecke   Date: 19/07/07   Time: 10:30
+ * Updated in $/Source/bsl/Inc
+ * PR511 - add new PixelEdge argument in
+ *			appHdmiTx_setInputOutput
+ *
+ * *****************  Version 18  ******************
+ * User: B.Vereecke   Date: 17/07/07   Time: 10:30
+ * Updated in $/Source/bsl/Inc
+ * PR217 - Add Pattern type parameter to
+ *         appHdmiTx_test_pattern_on API in order
+ *         to add blue pattern functionality
+ *
+ * *****************  Version 17  ******************
+ * User: J. Lamotte   Date: 29/06/07   Time: 15:50
+ * Updated in $/Source/bsl/Inc
+ * PR210 - Add video output format parameter to
+ *         appHdmiTx_test_pattern_on API in order
+ *         to update AVI info frame for color bar.
+ *
+ * *****************  Version 16  *****************
+ * User: Mayhew       Date: 27/10/06   Time: 12:34
+ * Updated in $/Source/bsl/Inc
+ * PNF59 Test pattern API split into _on and _off APIs
+ * PNF59 appHdmiTx_handleBCAPS has new pbBksvSecure parameter
+ *
+ * *****************  Version 14  *****************
+ * User: Mayhew       Date: 13/10/06   Time: 11:02
+ * Updated in $/Source/bsl/Inc
+ * PNF37 appHdmiTx_setInputOutput syncIn arg. is now syncSource
+ *
+ * *****************  Version 12  *****************
+ * User: Mayhew       Date: 15/09/06   Time: 15:56
+ * Updated in $/Source/bsl/Inc
+ * PNF19 Add i2sQualifier arg to setInputOutput
+ * PNF25 Add pEdidVidFlags arg to handleHPD
+ *
+ * *****************  Version 11  *****************
+ * User: Mayhew       Date: 10/07/06   Time: 12:33
+ * Updated in $/Source/bsl/Inc
+ * Add pbVerified parameter to _setInputOutput. Fix Doxygen comment
+ * warnings.
+ *
+ * *****************  Version 9  *****************
+ * User: Mayhew       Date: 30/06/06   Time: 12:42
+ * Updated in $/Source/bsl/Inc
+ * Add audioFmt parameter to appHdmiTx_setInputOutput
+ *
+ * *****************  Version 7  *****************
+ * User: Mayhew       Date: 5/06/06    Time: 14:38
+ * Updated in $/Source/bsl/Inc
+ * Rename syncSrc to syncIn. Remove 2nd param from handleBCAPS. Add
+ * pVidFmtNew param to appHdmiTx_nextEdidVidFmt.
+ *
+ * *****************  Version 5  *****************
+ * User: Mayhew       Date: 22/05/06   Time: 15:55
+ * Updated in $/Source/bsl/Inc
+ * Add pixRate to appHdmiTx_setInputOutput. Add appHdmiTx_nextEdidVidFmt.
+ *
+ * *****************  Version 3  *****************
+ * User: Mayhew       Date: 19/05/06   Time: 11:29
+ * Updated in $/Source/bsl/Inc
+ * Add options parameter to appHdmiTx_Hdcp_On
+ *
+ * *****************  Version 2  *****************
+ * User: Mayhew       Date: 10/05/06   Time: 17:01
+ * Updated in $/Source/bsl/Inc
+ * New APIs for HDCP and parameterised format setting
+ *
+ * *****************  Version 1  *****************
+ * User: Mayhew       Date: 4/04/06    Time: 16:27
+ * Created in $/Source/bsl/Inc
+ * Driver demo app API phase 2
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef BSLHDMITX_APP_H
+#define BSLHDMITX_APP_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       EXTERN DATA DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+/*============================================================================*/
+/**
+ *    \brief      Initialise demo application
+ * */
+void
+app_hdmi_tx_init(void);
+
+/*============================================================================*/
+/**
+ *    \brief      Set colourbar test pattern on with RGB infoframe
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *    \param[in]  voutFmt     Video output format
+ *	\param[in]  pattern		type of pattern
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_test_pattern_on
+(
+    unit_select_t				tx_unit,
+    bsl_vid_fmt_t			vout_fmt,
+    bsl_vout_mode_t       vout_mode,
+    bsl_test_pattern_t	pattern
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set colourbar test pattern off with previous infoframe
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  voutFmt      Video output format
+ *    \param[in]  voutMode     Video output mode
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_test_pattern_off
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vout_fmt,
+    bsl_vout_mode_t   vout_mode
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set input and output formats, modes, sync source, sink type
+ *                and audio rate
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  vinFmt       Video input format
+ *    \param[in]  vinMode      Video input mode
+ *    \param[in]  voutFmt      Video output format
+ *    \param[in]  voutMode     Video output mode
+ *    \param[in]  syncSource   Video input sync source
+ *    \param[in]  sinkType     Downstream receiver sink type
+ *    \param[in]  audioFmt     Audio format
+ *    \param[in]  audioRate    Audio sample rate
+ *    \param[in]  i2sQualifier Audio I2S qualifier: 8=channels; 16,32=bits
+ *    \param[in]  pixRate      Pixel rate
+ *	\param[in]  pixelEdge    Pixel edge
+ *    \param[out] pbVerified   Pointer to flag set when the requested combination
+ *                             of formats and modes has previously been verified
+ *                             during testing
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_set_input_output
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vin_fmt,
+    bsl_vin_mode_t    vin_mode,
+    bsl_vid_fmt_t     vout_fmt,
+    bsl_vout_mode_t   vout_mode,
+    bsl_sync_source_t sync_source,
+    bsl_sink_type_t   sink_type,
+    bsla_fmt_t       audio_fmt,
+    bslafs_t        audio_rate,
+    u8                   i2s_qualifier,
+    bsl_pix_rate_t    pix_rate,
+    bsl_pix_edge_t    pixel_edge,
+    /* Returns true if requested combination
+     *     bool                    *pb_verified
+     * has been verified */
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set audio format and audio rate
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \param[in]  sinkType     Downstream receiver sink type
+ *    \param[in]  audioFmt     Audio format
+ *    \param[in]  audioRate    Audio sample rate
+ *    \param[in]  i2sQualifier Audio I2S qualifier: 8=channels; 16,32=bits
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_set_audio
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vout_fmt,
+    bsl_sink_type_t   sink_type,
+    bsla_fmt_t       audio_fmt,
+    bslafs_t        audio_rate,
+    u8                   i2s_qualifier
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Set audio channel allocation
+ *
+ *    \param[in]  ChannelAllocation     audio channel allocation
+ *
+ *    \return     The call result:
+ *                - void
+ * */
+void
+app_hdmi_tx_set_audio_channel_allocation
+(
+    u8					channel_allocation
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Switch on HDCP
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[in]  voutFmt      Current CEA output format
+ *    \param[in]  options      HDCP options (HDMITX_HDCP_OPTION_FORCE_ values)
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_hdcp_on
+(
+    unit_select_t           tx_unit,
+    bsl_vid_fmt_t      vout_fmt,
+    bsl_hdcp_options_t options
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Switch off HDCP
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_hdcp_off
+(
+    unit_select_t      tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP BCAPS interrupt as a callback
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *    \param[out] pbBksvSecure BKSV check result
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_bcaps
+(
+    unit_select_t tx_unit,
+    bool *pb_bksv_secure
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP BSTATUS interrupt as a callback
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_bstatus
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP ENCRYPT interrupt as a callback
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_encrypt
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP PJ interrupt as a callback
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_pj
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP SHA_1 interrupt as a callback
+ *
+ *    \param[in]  txUnit       Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_sha_1
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle HDCP T0 interrupt as a callback
+ *
+ *    \param[in]  txUnit      Transmitter unit number
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_t0
+(
+    unit_select_t  tx_unit
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Handle Hot Plug Detect interrupt as a callback
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pHotPlugStatus  Pointer to hot plug status
+ *    \param[out] pEdidStatus     Copy of pDis->EdidStatus
+ *    \param[out] pEdidVidFlags   Ptr to video capability flags
+ *                                See enum _bslVidCap_t
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_handle_hpd
+(
+    unit_select_t          tx_unit,
+    bsl_hot_plug_t    *p_hot_plug_status,
+    u8                   *p_edid_status,
+    u8                   *p_edid_vid_flags
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the pointer to the KSV list used by the App unit
+ *
+ *    \param[in]  ppKsvList      Pointer to pointer to KSV list
+ *    \param[in]  pKsvDevices    Pointer to device count 0 to 128
+ *
+ *    \return     None
+ * */
+void
+app_hdmi_tx_get_ksv_list
+(
+    u8          **pp_ksv_list,
+    u8          *p_ksv_devices
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Get the pointer to the BKSV used by the App unit
+ *
+ *    \param[in]  ppBksv      Pointer to pointer to BKSV
+ *
+ *    \return     None
+ * */
+void
+app_hdmi_tx_get_bksv
+(
+    u8          **pp_bksv
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Check a video format against the Short Video
+ *                Descriptors last read from EDID
+ *
+ *    \param[in]  vidFmt  Video format to check
+ *
+ *    \return     The call result:
+ *                - true:  vidFmt is in SVD list
+ *                - false: not in list
+ * */
+bool
+app_hdmi_tx_check_vid_fmt
+(
+    bsl_vid_fmt_t     vid_fmt
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Find the next video format in the Short Video Descriptors list
+ *                last read from the EDID
+ *
+ *    \param[in]  vidFmtOld      Video format whose successor must be found
+ *    \param[in]  *pVidFmtNew    Ptr to a variable to receive the next higher
+ *                               video format or the first format in SVD list
+ *
+ *    \return     The call result:
+ *                - true:  a format was found
+ *                - false: no format was found because the list was empty
+ * */
+bool
+app_hdmi_tx_next_edid_vid_fmt
+(
+    bsl_vid_fmt_t     vid_fmt_old,
+    bsl_vid_fmt_t     *p_vid_fmt_new
+);
+
+/*============================================================================*/
+/**
+ *    \brief      Read Edid after PowerOn
+ *
+ *    \param[in]  txUnit          Transmitter unit number
+ *    \param[out] pEdidStatus     Copy of pDis->EdidStatus
+ *    \param[out] pEdidVidFlags   Ptr to video capability flags
+ *                                See enum _bslVidCap_t
+ *
+ *    \return     The call result:
+ *                - 0: the call was successful
+ *                - Else a problem has been detected
+ * */
+error_code_t
+app_hdmi_tx_read_edid_at_power_on
+(
+    unit_select_t          tx_unit,
+    u8                   *p_edid_status,
+    u8                   *p_edid_vid_flags
+);
+
+/*============================================================================*/
+/**
+ *    \brief      set revocation list
+ *
+ *    \param[in]  listPtr                 pointer on revocation list
+ *    \param[in]  Length                  number of bksv in revocation list
+ * */
+error_code_t
+app_hdmi_tx_set_hdcprevocation_list
+(
+    void           *list_ptr,
+    u32          length
+);
+
+#endif /* BSLHDMITX_APP_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_1.c b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_1.c
new file mode 100755
index 0000000..fe78bd4
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_1.c
@@ -0,0 +1,5520 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl_1.c
+ *
+ * \version       $Revision: 85 $
+ *
+ * \date          $Date: 21/01/08 $
+ *
+ * \brief         BSL driver component for the TDA998x HDMI Transmitter
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * */
+
+/*============================================================================*/
+/*                   FILE CONFIGURATION                                       */
+/*============================================================================*/
+
+#include <linux/kernel.h>
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_BADPARAM */
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_REG_FAIL */
+
+/* Defining this symbol on the compiler command line excludes unused code */
+/* #define DEMO_BUILD */
+
+/* Defining this symbol on the compiler command line adapts code for testing */
+/* #define UNIT_TEST */
+
+/*============================================================================*/
+/*                   STANDARD INCLUDE FILES                                   */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PROJECT INCLUDE FILES                                    */
+/*============================================================================*/
+#include "tmbslHdmiTx.h"
+#include "tmbslHdmiTx_local.h"
+
+/*============================================================================*/
+/*                   MACRO DEFINITIONS                                        */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   TYPE DEFINITIONS                                         */
+/*============================================================================*/
+
+#define SSD_UNUSED_VALUE 0xF0
+
+#ifdef FORMAT_PC
+#define DEPTH_COLOR_PC 1  /* PC_FORMAT only 8 bits available */
+#endif /* FORMAT_PC */
+
+/*============================================================================*/
+/*                   PUBLIC VARIABLE DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STATIC CONSTANT DECLARATIONS                             */
+/*============================================================================*/
+
+/** Preset default values for an object instance */
+static CONST_DAT hdmi_txobject_t k_hdmi_tx_instance_default
+= {
+	ST_UNINITIALIZED,                   /* state */
+	0,                                  /* nIgnoredEvents */
+	unit0,                            /* txUnit */
+	0,                                  /* uHwAddress */
+	(pbsl_sys_func_t)0,           /* sysFuncWrite */
+	(pbsl_sys_func_t)0,           /* sysFuncRead */
+	(pbsl_sys_func_edid_t)0,       /* sysFuncEdidRead */
+	(pbsl_sys_func_timer_t)0,      /* sysFuncTimer */
+	{                                   /* funcIntCallbacks[] */
+		(pbsl_callback_t)0
+	},
+	{                                   /* uSupportedVersions[] */
+		E_DEV_VERSION_N4, /* <=== Applies to N5 also */
+		E_DEV_VERSION_LIST_END
+	},
+	E_DEV_VERSION_LIST_END,             /* uDeviceVersion */
+	E_DEV_VERSION_LIST_END,             /* uDeviceFeatures */
+	power_on,                         /* ePowerState */
+	false,                              /* EdidAlternateAddr */
+	HDMITX_SINK_DVI,                    /* sinkType */
+	HDMITX_SINK_DVI,                    /* EdidSinkType */
+	false,                              /* EdidSinkAi */
+	0,                                  /* EdidCeaFlags */
+	HDMITX_EDID_NOT_READ,               /* EdidStatus */
+	0,                                  /* NbDTDStored */
+	{                                   /* EdidDTD: */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /* 1 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*2 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*3 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*4 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*5 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*6 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*7 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*8 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, /*9 */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} /*10*/
+	},
+	{                               /* EdidMonitorDescriptor */
+		false,                      /* bDescRecord */
+		/* uMonitorName[EDID_MONITOR_DESCRIPTOR_SIZE]       */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	},
+	{
+		false,                      /* bDescRecord */
+		/* uMinVerticalRate                                 */
+		0,
+		/* uMaxVerticalRate                                 */
+		0,
+		/* uMinHorizontalRate                               */
+		0,
+		/* uMaxHorizontalRate                               */
+		0,
+		/* uMaxSupportedPixelClk                            */
+		0
+	},
+	{
+		false,                      /* bDescRecord */
+		/* uOtherDescriptor[EDID_MONITOR_DESCRIPTOR_SIZE]   */
+		{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
+	},
+	{                                   /* EdidVFmts[] */
+		HDMITX_VFMT_NULL
+	},
+	0,                                  /* EdidSvdCnt */
+	{                                   /* EdidAFmts[]. */
+		{0, 0, 0}                           /* {ModeChans, Freqs, Byte3} */
+	},
+	0,                                  /* EdidSadCnt */
+	{
+		0                               /* EdidBlock[ ] */
+	},
+	0,                                  /* EdidBlockCnt */
+	0,                                  /* EdidSourceAddress */
+	{                                   /* EDIDBasicDisplayParam */
+		0,                              /* uVideoInputDef */
+		0,                              /* uMaxHorizontalSize */
+		0,                              /* uMaxVerticalSize */
+		0,                              /* uGamma */
+		0,                              /* uFeatureSupport */
+	},
+	HDMITX_VFMT_NULL,                   /* vinFmt */
+	HDMITX_VFMT_NULL,                   /* voutFmt */
+	HDMITX_PIXRATE_DOUBLE,              /* pixRate */
+	HDMITX_VINMODE_RGB444,              /* vinMode */
+	HDMITX_VOUTMODE_RGB444,             /* voutMode */
+	HDMITX_VFREQ_INVALID,               /* voutFreq */
+	HDMITX_SCAMODE_OFF,                 /* scaMode */
+	HDMITX_UPSAMPLE_AUTO,               /* upsampleMode */
+	HDMITX_PIXREP_MIN,                  /* pixelRepeatCount */
+	HDMITX_HOTPLUG_INVALID,             /* hotPlugStatus */
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+	HDMITX_RX_SENSE_INVALID,            /* rxSenseStatus */
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_PAGE_INVALID,                     /* curRegPage */
+	{
+		/* These match power-up defaults.  shadowReg[]: */
+		0x00,                           /* E_SP00_MAIN_CNTRL0 */
+		0x00,                           /* E_SP00_INT_FLAGS_0 */
+		0x00,                           /* E_SP00_INT_FLAGS_1 */
+#ifdef TMFL_TDA9981_SUPPORT
+		0x00,                           /* E_SP00_INT_FLAGS_2 */
+#endif /* TMFL_TDA9981_SUPPORT */
+		0x01,                           /* E_SP00_VIP_CNTRL_0 */
+		0x24,                           /* E_SP00_VIP_CNTRL_1 */
+		0x56,                           /* E_SP00_VIP_CNTRL_2 */
+		0x17,                           /* E_SP00_VIP_CNTRL_3 */
+		0x01,                           /* E_SP00_VIP_CNTRL_4 */
+		0x00,                           /* E_SP00_VIP_CNTRL_5 */
+		0x05,                           /* E_SP00_MAT_CONTRL  */
+		0x00,                           /* E_SP00_TBG_CNTRL_0 */
+		0x00,                           /* E_SP00_TBG_CNTRL_1 */
+		0x00,                           /* E_SP00_HVF_CNTRL_0 */
+		0x00,                           /* E_SP00_HVF_CNTRL_1 */
+		0x00,                           /* E_SP00_TIMER_H     */
+		0x00,                           /* E_SP00_DEBUG_PROBE */
+		0x00                            /* E_SP00_AIP_CLKSEL  */
+#ifndef TMFL_TDA9981_SUPPORT
+		, 0x00                          /* E_SP01_SC_VIDFORMAT*/
+		, 0x00                          /* E_SP01_SC_CNTRL    */
+		, 0x00                          /* E_SP01_TBG_CNTRL_0 */
+#endif /* TMFL_TDA9981_SUPPORT */
+	},
+	false,								/* Init prevBluescreen to false */
+	false,								/* Init prevPattern to false */
+	false                              /* bInitialized */
+};
+
+/**
+ * Lookup table to convert from EIA/CEA TV video formats used in the EDID and
+ * in API parameters to pixel clock frequencies, according to SCS Table
+ * "HDMI Pixel Clock Frequencies per EIA/CEA-861B Video Output Format".
+ * The other index is the veritical frame frequency.
+ * */
+
+static CONST_DAT u8 k_vfmt_to_pix_clk_tv[HDMITX_VFMT_TV_NUM][HDMITX_VFREQ_NUM] = {
+	/* HDMITX_VFREQ_24Hz HDMITX_VFREQ_25Hz HDMITX_VFREQ_30Hz HDMITX_VFREQ_50Hz HDMITX_VFREQ_59Hz HDMITX_VFREQ_60Hz */
+	/* HDMITX_VFMT_NULL               */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_01_640x480p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_25175,   E_PIXCLK_25200},
+	/* HDMITX_VFMT_02_720x480p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_03_720x480p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_04_1280x720p_60Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_74175,   E_PIXCLK_74250},
+	/* HDMITX_VFMT_05_1920x1080i_60Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_74175,   E_PIXCLK_74250},
+	/* HDMITX_VFMT_06_720x480i_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_07_720x480i_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_08_720x240p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_09_720x240p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_27027},
+	/* HDMITX_VFMT_10_720x480i_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_11_720x480i_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_12_720x240p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_13_720x240p_60Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_14_1440x480p_60Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_15_1440x480p_60Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_54054},
+	/* HDMITX_VFMT_16_1920x1080p_60Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_148350,  E_PIXCLK_148500},
+	/* HDMITX_VFMT_17_720x576p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_18_720x576p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_19_1280x720p_50Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_74250,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_20_1920x1080i_50Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_74250,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_21_720x576i_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_22_720x576i_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_23_720x288p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_24_720x288p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_27000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_25_720x576i_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_26_720x576i_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_27_720x288p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_28_720x288p_50Hz   */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_29_1440x576p_50Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_30_1440x576p_50Hz  */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_54000,   E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_31_1920x1080p_50Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_148500,  E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_32_1920x1080p_24Hz */
+	{E_PIXCLK_74250,   E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_33_1920x1080p_25Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_74250,   E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID},
+	/* HDMITX_VFMT_34_1920x1080p_30Hz */
+	{E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_74250,   E_PIXCLK_INVALID, E_PIXCLK_INVALID, E_PIXCLK_INVALID}
+};
+
+/**
+ * Lookup table to convert PC formats used in API parameters to pixel clock
+ * frequencies.
+ * The other index is the veritical frame frequency.
+ * */
+#ifdef FORMAT_PC
+static CONST_DAT u8 k_vfmt_to_pix_clk_pc[HDMITX_VFMT_PC_NUM+1] = {
+	/* HDMITX_VFREQ_60Hz HDMITX_VFREQ_70Hz HDMITX_VFREQ_72Hz HDMITX_VFREQ_75Hz HDMITX_VFREQ_85Hz HDMITX_VFREQ_87Hz*/
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_NULL                */
+	E_PIXCLK_25175  ,   /* HDMITX_VFMT_PC_640x480p_60Hz   */
+	E_PIXCLK_40000  ,   /* HDMITX_VFMT_PC_800x600p_60Hz   */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1152x960p_60Hz  */
+	E_PIXCLK_65000  ,   /* HDMITX_VFMT_PC_1024x768p_60Hz */
+	E_PIXCLK_79500  ,   /* HDMITX_VFMT_PC_1280x768p_60Hz */
+	E_PIXCLK_108000 ,   /* HDMITX_VFMT_PC_1280x1024p_60Hz */
+	E_PIXCLK_85500  ,   /* HDMITX_VFMT_PC_1360x768p_60Hz  */
+	E_PIXCLK_121750 ,   /* HDMITX_VFMT_PC_1400x1050p_60Hz */
+	E_PIXCLK_162000 ,   /* HDMITX_VFMT_PC_1600x1200p_60Hz */
+	E_PIXCLK_75000  ,   /* HDMITX_VFMT_PC_1024x768p_70Hz  */
+	E_PIXCLK_31500  ,   /* HDMITX_VFMT_PC_640x480p_72Hz   */
+	E_PIXCLK_50000  ,   /* HDMITX_VFMT_PC_800x600p_72Hz   */
+	E_PIXCLK_31500  ,   /* HDMITX_VFMT_PC_640x480p_75Hz   */
+	E_PIXCLK_78750  ,   /* HDMITX_VFMT_PC_1024x768p_75Hz  */
+	E_PIXCLK_49500  ,   /* HDMITX_VFMT_PC_800x600p_75Hz   */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1024x864p_75Hz  */
+	E_PIXCLK_135000 ,   /* HDMITX_VFMT_PC_1280x1024p_75Hz */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_640x350p_85Hz   */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_640x400p_85Hz   */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_720x400p_85Hz   */
+	E_PIXCLK_36000  ,   /* HDMITX_VFMT_PC_640x480p_85Hz   */
+	E_PIXCLK_56250  ,   /* HDMITX_VFMT_PC_800x600p_85Hz   */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1024x768p_85Hz  */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1152x864p_85Hz  */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1280x960p_85Hz  */
+	E_PIXCLK_INVALID,   /* HDMITX_VFMT_PC_1280x1024p_85Hz */
+	E_PIXCLK_INVALID    /* HDMITX_VFMT_PC_1024x768i_87Hz  */
+};
+#endif /* FORMAT_PC */
+
+/**
+ * Lookup table to convert from EIA/CEA TV video formats used in the EDID and in
+ * API parameters to the format used in the E_REG_P00_VIDFORMAT_W register
+ * */
+
+#ifndef FORMAT_PC
+static CONST_DAT u8 k_vfmt_to_regvfmt_tv[HDMITX_VFMT_TV_NUM] =
+#else /* FORMAT_PC */
+static CONST_DAT u8 k_vfmt_to_regvfmt_tv[HDMITX_VFMT_TV_NUM + HDMITX_VFMT_PC_NUM] =
+#endif /* FORMAT_PC */
+{
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_NULL               */
+	e_regvfmt_640x480p_60hz,        /* HDMITX_VFMT_01_640x480p_60Hz   */
+	e_regvfmt_720x480p_60hz,        /* HDMITX_VFMT_02_720x480p_60Hz   */
+	e_regvfmt_720x480p_60hz,        /* HDMITX_VFMT_03_720x480p_60Hz   */
+	e_regvfmt_1280x720p_60hz,       /* HDMITX_VFMT_04_1280x720p_60Hz  */
+	e_regvfmt_1920x1080i_60hz,      /* HDMITX_VFMT_05_1920x1080i_60Hz */
+	e_regvfmt_720x480i_60hz,        /* HDMITX_VFMT_06_720x480i_60Hz   */
+	e_regvfmt_720x480i_60hz,        /* HDMITX_VFMT_07_720x480i_60Hz   */
+	e_regvfmt_720x240p_60hz,        /* HDMITX_VFMT_08_720x240p_60Hz   */
+	e_regvfmt_720x240p_60hz,        /* HDMITX_VFMT_09_720x240p_60Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_10_720x480i_60Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_11_720x480i_60Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_12_720x240p_60Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_13_720x240p_60Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_14_1440x480p_60Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_15_1440x480p_60Hz  */
+	e_regvfmt_1920x1080p_60hz,      /* HDMITX_VFMT_16_1920x1080p_60Hz */
+	e_regvfmt_720x576p_50hz,        /* HDMITX_VFMT_17_720x576p_50Hz   */
+	e_regvfmt_720x576p_50hz,        /* HDMITX_VFMT_18_720x576p_50Hz   */
+	e_regvfmt_1280x720p_50hz,       /* HDMITX_VFMT_19_1280x720p_50Hz  */
+	e_regvfmt_1920x1080i_50hz,      /* HDMITX_VFMT_20_1920x1080i_50Hz */
+	e_regvfmt_720x576i_50hz,        /* HDMITX_VFMT_21_720x576i_50Hz   */
+	e_regvfmt_720x576i_50hz,        /* HDMITX_VFMT_22_720x576i_50Hz   */
+	e_regvfmt_720x288p_50hz,        /* HDMITX_VFMT_23_720x288p_50Hz   */
+	e_regvfmt_720x288p_50hz,        /* HDMITX_VFMT_24_720x288p_50Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_25_720x576i_50Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_26_720x576i_50Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_27_720x288p_50Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_28_720x288p_50Hz   */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_29_1440x576p_50Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_30_1440x576p_50Hz  */
+	e_regvfmt_1920x1080p_50hz,      /* HDMITX_VFMT_31_1920x1080p_50Hz */
+	e_regvfmt_1920x1080p_24hz,      /* HDMITX_VFMT_32_1920x1080p_24Hz */
+	e_regvfmt_1920x1080p_25hz,      /* HDMITX_VFMT_33_1920x1080p_25Hz */
+	e_regvfmt_1920x1080p_30hz       /* HDMITX_VFMT_34_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, e_regvfmt_640x480p_60hz,       /* HDMITX_VFMT_PC_640x480p_60Hz  */
+	e_regvfmt_800x600p_60hz,        /* HDMITX_VFMT_PC_800x600p_60Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1152x960p_60Hz  */
+	e_regvfmt_1024x768p_60hz,       /* HDMITX_VFMT_PC_1024x768p_60Hz  */
+	e_regvfmt_1280x768p_60hz,       /* HDMITX_VFMT_PC_1280x768p_60Hz */
+	e_regvfmt_1280x1024p_60hz,      /* HDMITX_VFMT_PC_1280x1024p_60Hz  */
+	e_regvfmt_1360x768p_60hz,       /* HDMITX_VFMT_PC_1360x768p_60Hz */
+	e_regvfmt_1400x1050p_60hz,      /* HDMITX_VFMT_PC_1400x1050p_60Hz */
+	e_regvfmt_1600x1200p_60hz,      /* HDMITX_VFMT_PC_1600x1200p_60Hz  */
+	e_regvfmt_1024x768p_70hz,       /* HDMITX_VFMT_PC_1024x768p_70Hz  */
+	e_regvfmt_640x480p_72hz,        /* HDMITX_VFMT_PC_640x480p_72Hz  */
+	e_regvfmt_800x600p_72hz,        /* HDMITX_VFMT_PC_800x600p_72Hz  */
+	e_regvfmt_640x480p_75hz,        /* HDMITX_VFMT_PC_640x480p_75Hz  */
+	e_regvfmt_1024x768p_75hz,       /* HDMITX_VFMT_PC_1024x768p_75Hz  */
+	e_regvfmt_800x600p_75hz,        /* HDMITX_VFMT_PC_800x600p_75Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1024x864p_75Hz  */
+	e_regvfmt_1280x1024p_75hz,      /* HDMITX_VFMT_PC_1280x1024p_75Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_640x350p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_640x400p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_720x400p_85Hz  */
+	e_regvfmt_640x480p_85hz,        /* HDMITX_VFMT_PC_640x480p_85Hz  */
+	e_regvfmt_800x600p_85hz,        /* HDMITX_VFMT_PC_800x600p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1024x768p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1152x864p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1280x960p_85Hz  */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1280x1024p_85Hz */
+	E_REGVFMT_INVALID,              /* HDMITX_VFMT_PC_1024x768i_87Hz  */
+#endif /* FORMAT PC */
+
+};
+
+/**
+ * Lookup table to convert from EIA/CEA TV video formats used in API
+ * parameters to the vid_format_i and vid_format_o values used in the
+ * E_REG_P01_SC_VIDFORMAT_W register
+ * */
+#define SCIO(scin,scout)            (((scin)<<4)|(scout))
+#define SCIO2SCIN(scio)             (u8)(((scio)>>4)&0xF)
+#define SCIO2SCOUT(scio)            (u8)((scio)&0xF)
+
+static CONST_DAT u8 k_vfmt_to_regvfmt_scio_tv[HDMITX_VFMT_TV_NUM] = {
+	/* HDMITX_VFMT_NULL               */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_01_640x480p_60Hz   */
+	SCIO(e_regvfmt_scin_480p_60hz, e_regvfmt_scout_480p_60hz),
+	/* HDMITX_VFMT_02_720x480p_60Hz   */
+	SCIO(e_regvfmt_scin_480p_60hz, e_regvfmt_scout_480p_60hz),
+	/* HDMITX_VFMT_03_720x480p_60Hz   */
+	SCIO(e_regvfmt_scin_480p_60hz, e_regvfmt_scout_480p_60hz),
+	/* HDMITX_VFMT_04_1280x720p_60Hz  */
+	SCIO(E_REGVFMT_SCIN_INVALID,   e_regvfmt_scout_720p_50hz_60hz),
+	/* HDMITX_VFMT_05_1920x1080i_60Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   e_regvfmt_scout_1080i_50hz_60hz),
+	/* HDMITX_VFMT_06_720x480i_60Hz   */
+	SCIO(e_regvfmt_scin_480i_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_07_720x480i_60Hz   */
+	SCIO(e_regvfmt_scin_480i_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_08_720x240p_60Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_09_720x240p_60Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_10_720x480i_60Hz   */
+	SCIO(e_regvfmt_scin_480i_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_11_720x480i_60Hz   */
+	SCIO(e_regvfmt_scin_480i_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_12_720x240p_60Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_13_720x240p_60Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_14_1440x480p_60Hz  */
+	SCIO(e_regvfmt_scin_480p_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_15_1440x480p_60Hz  */
+	SCIO(e_regvfmt_scin_480p_60hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_16_1920x1080p_60Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_17_720x576p_50Hz   */
+	SCIO(e_regvfmt_scin_576p_50hz, e_regvfmt_scout_576ip_50hz),
+	/* HDMITX_VFMT_18_720x576p_50Hz   */
+	SCIO(e_regvfmt_scin_576p_50hz, e_regvfmt_scout_576ip_50hz),
+	/* HDMITX_VFMT_19_1280x720p_50Hz  */
+	SCIO(E_REGVFMT_SCIN_INVALID,   e_regvfmt_scout_720p_50hz_60hz),
+	/* HDMITX_VFMT_20_1920x1080i_50Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   e_regvfmt_scout_1080i_50hz_60hz),
+	/* HDMITX_VFMT_21_720x576i_50Hz   */
+	SCIO(e_regvfmt_scin_576i_50hz, e_regvfmt_scout_576ip_50hz),
+	/* HDMITX_VFMT_22_720x576i_50Hz   */
+	SCIO(e_regvfmt_scin_576i_50hz, e_regvfmt_scout_576ip_50hz),
+	/* HDMITX_VFMT_23_720x288p_50Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_24_720x288p_50Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_25_720x576i_50Hz   */
+	SCIO(e_regvfmt_scin_576i_50hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_26_720x576i_50Hz   */
+	SCIO(e_regvfmt_scin_576i_50hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_27_720x288p_50Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_28_720x288p_50Hz   */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_29_1440x576p_50Hz  */
+	SCIO(e_regvfmt_scin_576p_50hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_30_1440x576p_50Hz  */
+	SCIO(e_regvfmt_scin_576p_50hz, E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_31_1920x1080p_50Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_32_1920x1080p_24Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_33_1920x1080p_25Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID),
+	/* HDMITX_VFMT_34_1920x1080p_30Hz */
+	SCIO(E_REGVFMT_SCIN_INVALID,   E_REGVFMT_SCOUT_INVALID)
+};
+
+/**
+ * Macro to pack output format flags as bits in a u16 for the following table
+ * */
+#define PKOPF(p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17) \
+	((p1)|((p2)<<1)|((p3)<<2)|((p4)<<3)|((p5)<<4)|((p6)<<5)|((p7)<<6)|((p8)<<7)| \
+	 ((p9)<<8)|((p10)<<9)|((p11)<<10)|((p12)<<11)|((p13)<<12)|((p14)<<13)|((p15)<<14)|((p16)<<15)|((p17)<<16))
+
+/* Macro to test for input and output format = '1' in following table */
+#define CAN_FMTS_SCALE(fin,fout) (kCanSclInToOut[(fin)]&(1<<(fout)))
+
+/**
+ * Lookup table to determine if an input format can be scaled to an
+ * output format, including scaler off conditions (in=out)
+ * Indexed by [input format][output format]
+ * */
+static CONST_DAT u16 k_can_scl_in_to_out[E_REGVFMT_INVALID+1] = {
+	/* -----OUTPUT FORMATS------ */
+	/* E_REGVFMT_640x480p_60Hz   */
+	/*    E_REGVFMT_720x480p_60Hz   */
+	/*       E_REGVFMT_1280x720p_60Hz  */
+	/*          E_REGVFMT_1920x1080i_60Hz */
+	/*             E_REGVFMT_720x480i_60Hz   */
+	/*                E_REGVFMT_720x240p_60Hz   */
+	/*                   E_REGVFMT_1920x1080p_60Hz */
+	/*                      E_REGVFMT_720x576p_50Hz   */
+	/*                         E_REGVFMT_1280x720p_50Hz  */
+	/*                            E_REGVFMT_1920x1080i_50Hz */
+	/*                               E_REGVFMT_720x576i_50Hz   */
+	/*                                  E_REGVFMT_720x288p_50Hz   */
+	/*                                     E_REGVFMT_1920x1080p_50Hz */
+	/*										  E_REGVFMT_1920x1080p_24Hz */
+	/*											 E_REGVFMT_1920x1080p_25Hz */
+	/*												E_REGVFMT_1920x1080p_30Hz */
+	/*												   E_REGVFMT_INVALID		   */
+	/* ------INPUT FORMATS------ */
+	/* E_REGVFMT_640x480p_60Hz   */
+	PKOPF(1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x480p_60Hz   */
+	PKOPF(0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1280x720p_60Hz  */
+	PKOPF(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1920x1080i_60Hz */
+	PKOPF(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x480i_60Hz   */
+	PKOPF(0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x240p_60Hz   */
+	PKOPF(0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1920x1080p_60Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x576p_50Hz   */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1280x720p_50Hz  */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1920x1080i_50Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x576i_50Hz   */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_720x288p_50Hz   */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0),
+	/* E_REGVFMT_1920x1080p_50Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0),
+	/* E_REGVFMT_1920x1080p_24Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0),
+	/* E_REGVFMT_1920x1080p_25Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0),
+	/* E_REGVFMT_1920x1080p_30Hz */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0),
+	/* E_REGVFMT_INVALID         */
+	PKOPF(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
+};
+
+/**
+ * Lookup tables to convert scaler input and output modes
+ * to PLL scaling values
+ * */
+static CONST_DAT u16 k_scl_mode_to_scg_n[E_REGVFMT_SCIN_NUM][E_REGVFMT_SCOUT_NUM] = {
+	/* E_REGVFMT_SCOUT_480p_60Hz */
+	/*        E_REGVFMT_SCOUT_576ip_50Hz */
+	/*                E_REGVFMT_SCOUT_720p_50Hz_60Hz */
+	/*                        E_REGVFMT_SCOUT_1080i_50Hz_60Hz */
+	{ 20,     0,    500,    500},   /* E_REGVFMT_SCIN_480i_60Hz */
+	{  0,    20,     88,     88},   /* E_REGVFMT_SCIN_576i_50Hz */
+	{  0,     0,    250,    250},   /* E_REGVFMT_SCIN_480p_60Hz */
+	{  0,     0,     44,     44},   /* E_REGVFMT_SCIN_576p_50Hz */
+};
+static CONST_DAT u16 k_scl_mode_to_scg_r[E_REGVFMT_SCIN_NUM][E_REGVFMT_SCOUT_NUM] = {
+	/* E_REGVFMT_SCOUT_480p_60Hz */
+	/*        E_REGVFMT_SCOUT_576ip_50Hz */
+	/*                E_REGVFMT_SCOUT_720p_50Hz_60Hz */
+	/*                        E_REGVFMT_SCOUT_1080i_50Hz_60Hz */
+	{ 10,     0,     91,     91},   /* E_REGVFMT_SCIN_480i_60Hz */
+	{  0,    10,     16,     16},   /* E_REGVFMT_SCIN_576i_50Hz */
+	{  0,     0,     91,     91},   /* E_REGVFMT_SCIN_480p_60Hz */
+	{  0,     0,     16,     16},   /* E_REGVFMT_SCIN_576p_50Hz */
+};
+
+/**
+ * Lookup tables to hide the scaler issue on side effect
+ * by adding blanking pixel on right and left side of the screen
+ * */
+static CONST_DAT u8 k_scl_add_blk_pix[E_REGVFMT_SCIN_NUM][E_REGVFMT_SCOUT_NUM] = {
+	/* E_REGVFMT_SCOUT_480p_60Hz */
+	/*        E_REGVFMT_SCOUT_576ip_50Hz */
+	/*                E_REGVFMT_SCOUT_720p_50Hz_60Hz */
+	/*                        E_REGVFMT_SCOUT_1080i_50Hz_60Hz */
+	{  0,     0,      4,      8},   /* E_REGVFMT_SCIN_480i_60Hz */
+	{  0,     0,      4,      8},   /* E_REGVFMT_SCIN_576i_50Hz */
+	{  0,     0,      4,      8},   /* E_REGVFMT_SCIN_480p_60Hz */
+	{  0,     0,      4,      8},   /* E_REGVFMT_SCIN_576p_50Hz */
+};
+static CONST_DAT u8 k_scl_clear_blk_pix[] = {
+	0,    /* HDMITX_VOUTMODE_RGB444 */
+	1,    /* HDMITX_VOUTMODE_YUV422 */
+	1,    /* HDMITX_VOUTMODE_YUV444 */
+	0,    /* HDMITX_VOUTMODE_NO_CHANGE */
+	0     /* HDMITX_VOUTMODE_INVALID */
+};
+
+/**
+ * Lookup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to corresponding VS_PIX_STRT_2
+ * register values, to correct the output window for interlaced
+ * output formats, with or without the scaler.
+ *
+ * The correction is VS_PIX_STRT_2=VS_PIX_STRT_2+VS_PIX_STRT_1.
+ * The same value is also applied to VS_PIX_END_2.
+ * */
+static CONST_DAT u16 k_regvfmt_to_vs2[E_REGVFMT_NUM] = {
+	0,            /* E_REGVFMT_640x480p_60Hz   */
+	0,            /* E_REGVFMT_720x480p_60Hz   */
+	0,            /* E_REGVFMT_1280x720p_60Hz  */
+	1100 + 88,    /* E_REGVFMT_1920x1080i_60Hz */
+	429  + 19,    /* E_REGVFMT_720x480i_60Hz   */
+	0,            /* E_REGVFMT_720x240p_60Hz   */
+	0,            /* E_REGVFMT_1920x1080p_60Hz */
+	0,            /* E_REGVFMT_720x576p_50Hz   */
+	0,            /* E_REGVFMT_1280x720p_50Hz  */
+	1320 + 528,   /* E_REGVFMT_1920x1080i_50Hz */
+	432  + 12,    /* E_REGVFMT_720x576i_50Hz   */
+	0,            /* E_REGVFMT_720x288p_50Hz   */
+	0,            /* E_REGVFMT_1920x1080p_50Hz */
+	0,            /* E_REGVFMT_1920x1080p_24Hz */
+	0,            /* E_REGVFMT_1920x1080p_25Hz */
+	0             /* E_REGVFMT_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, 0, /* E_REGVFMT_640x480p_72Hz   */
+	0, /* E_REGVFMT_640x480p_75Hz   */
+	0, /* E_REGVFMT_640x480p_85Hz   */
+	0, /* E_REGVFMT_800x600p_60Hz   */
+	0, /* E_REGVFMT_800x600p_72Hz   */
+	0, /* E_REGVFMT_800x600p_75Hz   */
+	0, /* E_REGVFMT_800x600p_85Hz   */
+	0, /* E_REGVFMT_1024x768p_60Hz  */
+	0, /* E_REGVFMT_1024x768p_70Hz  */
+	0, /* E_REGVFMT_1024x768p_75Hz  */
+	0, /* E_REGVFMT_1280x768p_60Hz  */
+	0, /* E_REGVFMT_1280x1024p_60Hz */
+	0, /* E_REGVFMT_1280x1024p_75Hz */
+	0, /* E_REGVFMT_1360x768p_60Hz  */
+	0, /* E_REGVFMT_1400x1050p_60Hz */
+	0, /* E_REGVFMT_1600x1200p_60Hz */
+#endif /* FORMAT_PC */
+};
+
+/**
+ * Lookup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to corresponding
+ * pixel repetition values in the PLL_SERIAL_2 register.
+ * 0=no repetition (pixel sent once)
+ * 1=one repetition (pixel sent twice) etc
+ * */
+static CONST_DAT u8 k_regvfmt_to_pix_rep[E_REGVFMT_NUM] = {
+	0, /* E_REGVFMT_640x480p_60Hz   */
+	0, /* E_REGVFMT_720x480p_60Hz   */
+	0, /* E_REGVFMT_1280x720p_60Hz  */
+	0, /* E_REGVFMT_1920x1080i_60Hz */
+	1, /* E_REGVFMT_720x480i_60Hz   */
+	1, /* E_REGVFMT_720x240p_60Hz   */
+	0, /* E_REGVFMT_1920x1080p_60Hz */
+	0, /* E_REGVFMT_720x576p_50Hz   */
+	0, /* E_REGVFMT_1280x720p_50Hz  */
+	0, /* E_REGVFMT_1920x1080i_50Hz */
+	1, /* E_REGVFMT_720x576i_50Hz   */
+	1, /* E_REGVFMT_720x288p_50Hz   */
+	0, /* E_REGVFMT_1920x1080p_50Hz */
+	0, /* E_REGVFMT_1920x1080p_24Hz */
+	0, /* E_REGVFMT_1920x1080p_25Hz */
+	0  /* E_REGVFMT_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, 0, /* E_REGVFMT_640x480p_72Hz   */
+	0, /* E_REGVFMT_640x480p_75Hz   */
+	0, /* E_REGVFMT_640x480p_85Hz   */
+	0, /* E_REGVFMT_800x600p_60Hz   */
+	0, /* E_REGVFMT_800x600p_72Hz   */
+	0, /* E_REGVFMT_800x600p_75Hz   */
+	0, /* E_REGVFMT_800x600p_85Hz   */
+	0, /* E_REGVFMT_1024x768p_60Hz  */
+	0, /* E_REGVFMT_1024x768p_70Hz  */
+	0, /* E_REGVFMT_1024x768p_75Hz  */
+	0, /* E_REGVFMT_1280x768p_60Hz  */
+	0, /* E_REGVFMT_1280x1024p_60Hz */
+	0, /* E_REGVFMT_1280x1024p_75Hz */
+	0, /* E_REGVFMT_1360x768p_60Hz  */
+	0, /* E_REGVFMT_1400x1050p_60Hz */
+	0, /* E_REGVFMT_1600x1200p_60Hz */
+#endif /* FORMAT_PC */
+
+};
+
+/**
+ * Lookup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to corresponding
+ * trios of 2-bit values in the srl_nosc, scg_nosc and de_nosc
+ * PLL control registers
+ * */
+#define SSD(srl,scg,de) (((srl)<<4)|((scg)<<2)|(de))
+#define SSD2SRL(ssd)    (u8)(((ssd)>>4)&3)
+#define SSD2SCG(ssd)    (u8)(((ssd)>>2)&3)
+#define SSD2DE(ssd)     (u8)((ssd)&3)
+
+static CONST_DAT struct {
+	u8 sca_off_ccir_off_dbl_edge_off[E_REGVFMT_NUM_TV];
+
+	u8 sca_off_ccir_on_dbl_edge_off[E_REGVFMT_NUM_TV];
+
+	u8 sca_off_ccir_on_dbl_edge_on[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_off_dbl_edge_off_interlace[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_on_dbl_edge_off_interlace[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_on_dbl_edge_on_interlace[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_off_dbl_edge_off_progressif[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_on_dbl_edge_off_progressif[E_REGVFMT_NUM_TV];
+
+	u8 sca_on_ccir_on_dbl_edge_on_progressif[E_REGVFMT_NUM_TV];
+
+#ifdef FORMAT_PC
+	u8 settings_format_pc[E_REGVFMT_NUM_PC];
+#endif /* FORMAT_PC */
+
+} k_regvfmt_to_pll_ssd = {
+
+	{   /*ScaOffCCIROffDblEdgeOff*/
+		/* SRL,SCG,DE */
+		SSD(2, 2, 2), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 2, 2), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 1, 1), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 1, 1), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(3, 3, 3), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 2, 2), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 1, 1), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 1, 1), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(3, 3, 3), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 1, 1), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 1, 1), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 1, 1) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /*ScaOffCCIROnDblEdgeOff*/
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 1, 1), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(2, 2, 2), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 1, 1), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(2, 2, 2), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(0xF, 0, 0) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /*ScaOffCcirONDblEdgeOn*/
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 1, 1), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(2, 2, 2), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 1, 1), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(2, 2, 2), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(0xF, 0, 0) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /* ScaOnCcirOffDblEdgeOffInterlace */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 2, 3), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 1, 3), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 1, 3), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 2, 3), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 1, 3), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 1, 3), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 1, 3), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 1, 3), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 1, 3) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /* ScaOnCcirONDblEdgeOffInterlace */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 1, 2), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 0, 2), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 1, 2), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 0, 2), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 0, 2) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{  /* ScaOnCcirONDblEdgeOnInterlace */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(2, 1, 2), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 0, 2), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(2, 1, 2), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 0, 2), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 0, 2), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 0, 2) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{ /* ScaOnCcirOffDblEdgeOffProgressif */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 1, 2), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 1, 2), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 1, 2), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 1, 2), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 1, 2), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 1, 2), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 1, 2) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /* ScaOnCcirOnDblEdgeOffProgressif */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 0, 1), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 0, 1), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 0, 1) /* E_REGVFMT_1920x1080p_30Hz */
+	},
+
+	{   /* ScaOnCcirONDblEdgeOnProgressif */
+		/* SRL,SCG,DE */
+		SSD(0xF, 0, 0), /* E_REGVFMT_640x480p_60Hz   */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480p_60Hz   */
+		SSD(1, 0, 1), /* E_REGVFMT_1280x720p_60Hz  */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080i_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x480i_60Hz   */
+		/* E_REGVFMT_720x240p_60Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_60Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576p_50Hz   */
+		SSD(1, 0, 1), /* E_REGVFMT_1280x720p_50Hz  */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080i_50Hz */
+		SSD(0xF, 0, 0), /* E_REGVFMT_720x576i_50Hz   */
+		/* E_REGVFMT_720x288p_50Hz    / * \todo Need nosc PLL value */
+		SSD(0xF, 0, 0),
+		SSD(0xF, 0, 0), /* E_REGVFMT_1920x1080p_50Hz */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080p_24Hz */
+		SSD(1, 0, 1), /* E_REGVFMT_1920x1080p_25Hz */
+		SSD(1, 0, 1) /* E_REGVFMT_1920x1080p_30Hz */
+	}
+
+#ifdef FORMAT_PC
+	, {
+		/* SRL,SCG,DE */
+		SSD(2, 0, 0), /* E_REGVFMT_640x480p_72Hz   */
+		SSD(2, 0, 0), /* E_REGVFMT_640x480p_75Hz   */
+		SSD(2, 0, 0), /* E_REGVFMT_640x480p_85Hz   */
+		SSD(1, 0, 0), /* E_REGVFMT_800x600p_60Hz   */
+		SSD(1, 0, 0), /* E_REGVFMT_800x600p_72Hz   */
+		SSD(1, 0, 0), /* E_REGVFMT_800x600p_75Hz   */
+		SSD(1, 0, 0), /* E_REGVFMT_800x600p_85Hz   */
+		SSD(1, 0, 0), /* E_REGVFMT_1024x768p_60Hz  */
+		SSD(1, 0, 0), /* E_REGVFMT_1024x768p_70Hz  */
+		SSD(1, 0, 0), /* E_REGVFMT_1024x768p_75Hz  */
+		SSD(0, 0, 0), /* E_REGVFMT_1280x768p_60Hz  */
+		SSD(0, 0, 0), /* E_REGVFMT_1280x1024p_60Hz */
+		SSD(0, 0, 0), /* E_REGVFMT_1280x1024p_75Hz */
+		SSD(0, 0, 0), /* E_REGVFMT_1360x768p_60Hz  */
+		SSD(0, 0, 0), /* E_REGVFMT_1400x1050p_60Hz */
+		SSD(0, 0, 0)  /* E_REGVFMT_1600x1200p_60Hz */
+	}
+#endif /* FORMAT_PC */
+
+};
+
+/**
+ * Lookup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to corresponding
+ * V_toggle values for Vs external sync.
+ * 0=no toggle
+ * 1=toggle
+ * */
+static CONST_DAT u8 k_regvfmt_to_vtoggle[E_REGVFMT_NUM] = {
+	1, /* E_REGVFMT_640x480p_60Hz   */
+	1, /* E_REGVFMT_720x480p_60Hz   */
+	0, /* E_REGVFMT_1280x720p_60Hz  */
+	0, /* E_REGVFMT_1920x1080i_60Hz */
+	1, /* E_REGVFMT_720x480i_60Hz   */
+	1, /* E_REGVFMT_720x240p_60Hz   */
+	0, /* E_REGVFMT_1920x1080p_60Hz */
+	1, /* E_REGVFMT_720x576p_50Hz   */
+	0, /* E_REGVFMT_1280x720p_50Hz  */
+	0, /* E_REGVFMT_1920x1080i_50Hz */
+	1, /* E_REGVFMT_720x576i_50Hz   */
+	1, /* E_REGVFMT_720x288p_50Hz   */
+	0, /* E_REGVFMT_1920x1080p_50Hz */
+	0, /* E_REGVFMT_1920x1080p_24Hz */
+	0, /* E_REGVFMT_1920x1080p_25Hz */
+	0  /* E_REGVFMT_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, 1, /* E_REGVFMT_640x480p_72Hz   */
+	1, /* E_REGVFMT_640x480p_75Hz   */
+	1, /* E_REGVFMT_640x480p_85Hz   */
+	0, /* E_REGVFMT_800x600p_60Hz   */
+	0, /* E_REGVFMT_800x600p_72Hz   */
+	0, /* E_REGVFMT_800x600p_75Hz   */
+	0, /* E_REGVFMT_800x600p_85Hz   */
+	1, /* E_REGVFMT_1024x768p_60Hz  */
+	1, /* E_REGVFMT_1024x768p_70Hz  */
+	0, /* E_REGVFMT_1024x768p_75Hz  */
+	0, /* E_REGVFMT_1280x768p_60Hz  */
+	0, /* E_REGVFMT_1280x1024p_60Hz */
+	0, /* E_REGVFMT_1280x1024p_75Hz */
+	0, /* E_REGVFMT_1360x768p_60Hz  */
+	0, /* E_REGVFMT_1400x1050p_60Hz */
+	0, /* E_REGVFMT_1600x1200p_60Hz */
+#endif /* FORMAT_PC */
+};
+
+/**
+ * Lookup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to corresponding
+ * H_toggle values for Vs external sync.
+ * 0=no toggle
+ * 1=toggle
+ * */
+static CONST_DAT u8 k_regvfmt_to_htoggle[E_REGVFMT_NUM] = {
+	1, /* E_REGVFMT_640x480p_60Hz   */
+	1, /* E_REGVFMT_720x480p_60Hz   */
+	0, /* E_REGVFMT_1280x720p_60Hz  */
+	0, /* E_REGVFMT_1920x1080i_60Hz */
+	1, /* E_REGVFMT_720x480i_60Hz   */
+	1, /* E_REGVFMT_720x240p_60Hz   */
+	0, /* E_REGVFMT_1920x1080p_60Hz */
+	1, /* E_REGVFMT_720x576p_50Hz   */
+	0, /* E_REGVFMT_1280x720p_50Hz  */
+	0, /* E_REGVFMT_1920x1080i_50Hz */
+	1, /* E_REGVFMT_720x576i_50Hz   */
+	1, /* E_REGVFMT_720x288p_50Hz   */
+	0, /* E_REGVFMT_1920x1080p_50Hz */
+	0, /* E_REGVFMT_1920x1080p_24Hz */
+	0, /* E_REGVFMT_1920x1080p_25Hz */
+	0  /* E_REGVFMT_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, 1, /* E_REGVFMT_640x480p_72Hz   */
+	1, /* E_REGVFMT_640x480p_75Hz   */
+	1, /* E_REGVFMT_640x480p_85Hz   */
+	0, /* E_REGVFMT_800x600p_60Hz   */
+	0, /* E_REGVFMT_800x600p_72Hz   */
+	0, /* E_REGVFMT_800x600p_75Hz   */
+	0, /* E_REGVFMT_800x600p_85Hz   */
+	1, /* E_REGVFMT_1024x768p_60Hz  */
+	1, /* E_REGVFMT_1024x768p_70Hz  */
+	0, /* E_REGVFMT_1024x768p_75Hz  */
+	1, /* E_REGVFMT_1280x768p_60Hz  */
+	0, /* E_REGVFMT_1280x1024p_60Hz */
+	0, /* E_REGVFMT_1280x1024p_75Hz */
+	0, /* E_REGVFMT_1360x768p_60Hz  */
+	1, /* E_REGVFMT_1400x1050p_60Hz */
+	0, /* E_REGVFMT_1600x1200p_60Hz */
+#endif /* FORMAT_PC */
+};
+
+/**
+ * Lokup table to convert from video format codes used in the
+ * E_REG_P00_VIDFORMAT_W register to RefPix and RefLine values
+ * according to sync source
+ * */
+static CONST_DAT struct {
+	u16  ref_pix_vs_sync;    /* Output values for Vs/Hs input sync */
+	u16  ref_line_vs_sync;
+	/* Output values for all other input sync sources */
+	u16  ref_pix_other_sync;
+	u16  ref_line_other_sync;
+} k_vid_fmt_to_refpix_refline[E_REGVFMT_NUM] = {
+	/*  PixVs   LineVs  PixOther    LineOther   vinFmt */
+	{17,    2,      161,        36},     /* E_REGVFMT_640x480p_60Hz   */
+	{17,    8,      139,        43},     /* E_REGVFMT_720x480p_60Hz   */
+	{111,   2,      371,        26},     /* E_REGVFMT_1280x720p_60Hz  */
+	{89,    2,      281,        21},     /* E_REGVFMT_1920x1080i_60Hz */
+	{20,    5,      139,        22},     /* E_REGVFMT_720x480i_60Hz   */
+	{20,    5,      139,        22},     /* E_REGVFMT_720x240p_60Hz   */
+	{89,    2,      281,        42},     /* E_REGVFMT_1920x1080p_60Hz */
+	{13,    2,      145,        45},     /* E_REGVFMT_720x576p_50Hz   */
+	{441,   2,      701,        26},     /* E_REGVFMT_1280x720p_50Hz  */
+	{529,   2,      721,        21},     /* E_REGVFMT_1920x1080i_50Hz */
+	{13,    2,      145,        23},     /* E_REGVFMT_720x576i_50Hz   */
+	{13,    2,      145,        23},     /* E_REGVFMT_720x288p_50Hz   */
+	{529,   2,      721,        42},     /* E_REGVFMT_1920x1080p_50Hz */
+	{639,   2,		831,        42},     /* E_REGVFMT_1920x1080p_24Hz */
+	{529,   2,		721,        42},     /* E_REGVFMT_1920x1080p_25Hz */
+	{89,    2,		281,        42}      /* E_REGVFMT_1920x1080p_30Hz */
+#ifdef FORMAT_PC
+	, {25,    2,      195,        32}, /* E_REGVFMT_640x480p_72Hz   */
+	{17,    2,      203,        20}, /* E_REGVFMT_640x480p_75Hz   */
+	{57,    2,      195,        29}, /* E_REGVFMT_640x480p_85Hz   */
+	{41,    2,      259,        28}, /* E_REGVFMT_800x600p_60Hz   */
+	{57,    2,      243,        30}, /* E_REGVFMT_800x600p_72Hz   */
+	{17,    2,      259,        25}, /* E_REGVFMT_800x600p_75Hz   */
+	{33,    2,      251,        31}, /* E_REGVFMT_800x600p_85Hz   */
+	{25,    2,      323,        36}, /* E_REGVFMT_1024x768p_60Hz  */
+	{25,    2,      307,        36}, /* E_REGVFMT_1024x768p_70Hz  */
+	{17,    2,      291,        32}, /* E_REGVFMT_1024x768p_75Hz  */
+	{65,    2,      387,        28}, /* E_REGVFMT_1280x768p_60Hz */
+	{49,    2,      501,        42}, /* E_REGVFMT_1280x1024p_60Hz */
+	{17,    2,      411,        42}, /* E_REGVFMT_1280x1024p_75Hz */
+	{65,    2,      435,        25}, /* E_REGVFMT_1360x768p_60Hz */
+	{89,    2,      467,        37}, /* E_REGVFMT_1400x1050p_60Hz */
+	{65,	2,		563,		50}  /* E_REGVFMT_1600x1200p_60Hz */
+#endif/* FORMAT_PC */
+};
+
+static CONST_DAT hdmi_tx_vid_reg_t k_vid_fmt_format_param[E_REGVFMT_NUM_TV_NO_REG] = {
+	/*  NPIX    NLINE  VsLineStart	VsPixStart	VsLineEnd	VsPixEnd	HsStart		HsEnd	vWinStart	vWinEnd	DeStart	DeEnd */
+	/* E_REGVFMT_1920x1080p_24Hz */
+	{2750,	1125,	  1,	      638,	       6,	        638,        638,    682,    41,         1121,   830,   2750},
+	/* E_REGVFMT_1920x1080p_25Hz */
+	{2640,	1125,	  1,	      528,	       6,	        528,	    528,	572,    41,         1121,   720,   2640},
+	/* E_REGVFMT_1920x1080p_30Hz */
+	{2200,	1125,	  1,	      88,	       6,	        88,	        88,	    132,    41,         1121,   280,   2200},
+
+};
+
+#ifdef FORMAT_PC
+static CONST_DAT hdmi_tx_vid_reg_t k_vid_fmt_to_pcformat_param[E_REGVFMT_NUM_PC] = {
+	/*  NPIX    NLINE  VsLineStart	VsPixStart	VsLineEnd	VsPixEnd	HsStart		HsEnd	vWinStart	vWinEnd	DeStart	DeEnd */
+	/* E_REGVFMT_640x480p_72Hz   */
+	{832,	520,      1,          24,	       4,	        24,	        24,	    64,	    31,	        511,    192,    832},
+	/* E_REGVFMT_640x480p_75Hz   */
+	{840,	500,      1,	      16,	       4,	        16,         16,	    80,	    19,	        499,    200,    840},
+	/* E_REGVFMT_640x480p_85Hz   */
+	{832,	509,      1,	      56,	       4,	        56,	        56,	    112,    28,         508,    192,    832},
+	/* E_REGVFMT_800x600p_60Hz   */
+	{1056,	628,	  1,	      40,	       5,	        40,	        40,    	168,    27,         627,    256,   1056},
+	/* E_REGVFMT_800x600p_72Hz   */
+	{1040,	666,	  1,	      56,	       7,	        56,	        56,	    176,    29,         619,    240,   1040},
+	/* E_REGVFMT_800x600p_75Hz   */
+	{1056,	625,	  1,	      16,	       4,           16,	        16,	    96,     24,         624,    256,   1056},
+	/* E_REGVFMT_800x600p_85Hz   */
+	{1048,	631,	  1,	      32,	       4,	        32,	        32,	    96,     30,         630,    248,   1048},
+	/* E_REGVFMT_1024x768p_60Hz  */
+	{1344,	806,	  1,	      24,	       7,	        24,	        24,	    160,    35,         803,    320,   1344},
+	/* E_REGVFMT_1024x768p_70Hz  */
+	{1328,	806,	  1,	      24,	       7,	        24,	        24,	    160,    35,         803,    304,   1328},
+	/* E_REGVFMT_1024x768p_75Hz  */
+	{1312,	800,	  1,	      16,	       4,	        16,	        16,	    112,    31,         799,    288,   1312},
+	/* E_REGVFMT_1280x768p_60Hz  */
+	{1664,	798,	  1,	      64,	       8,	        64,	        64,	    192,    27,         795,    384,   1664},
+	/* E_REGVFMT_1280x1024p_60Hz */
+	{1688,	1066,	  1,	      48,	       4,	        48,	        48,	    160,    41,         1065,   408,   1688},
+	/* E_REGVFMT_1280x1024p_75Hz */
+	{1688,	1066,	  1,	      16,	       4,	        16,	        16,	    160,    41,         1065,   408,   1688},
+	/* E_REGVFMT_1360x768p_60Hz  */
+	{1792,	795,	  1,	      64,	       7,	        64,	        64,	    176,    24,         792,    432,   1792},
+	/* E_REGVFMT_1400x1050p_60Hz */
+	{1864,	1089,	  1,	      88,	       5,	        88,	        88,	    232,    36,         1086,   464,   1864},
+	/* E_REGVFMT_1600x1200p_60Hz */
+	{2160,	1250,	  1,	      64,	       4,	        64,	        64,	    256,    49,         1249,   560,   2160}
+};
+#endif/* FORMAT_PC */
+
+/**
+ *  lookup table for each pixel clock frequency's CTS value in k_hz
+ *  according to SCS table "audio clock recovery CTS values"
+ * */
+static CONST_DAT u32 k_pix_clk_to_acr_cts[E_PIXCLK_NUM][HDMITX_AFS_NUM] = {
+	/* HDMITX_AFS_32k  _AFS_48K       _AFS_96K        _AFS_192K */
+	/*         _AFS_44_1k      _AFS_88_2K      _AFS_176_4K       */
+	/* E_PIXCLK_25175 */
+	{ 28125,  31250,  28125,  31250,  28125,  31250,  28125},
+	/* E_PIXCLK_25200 */
+	{ 25200,  28000,  25200,  28000,  25200,  28000,  25200},
+	/* E_PIXCLK_27000 */
+	{ 27000,  30000,  27000,  30000,  27000,  30000,  27000},
+	/* E_PIXCLK_27027 */
+	{ 27027,  30030,  27027,  30030,  27027,  30030,  27027},
+	/* E_PIXCLK_54000 */
+	{ 54000,  60000,  54000,  60000,  54000,  60000,  54000},
+	/* E_PIXCLK_54054 */
+	{ 54054,  60060,  54054,  60060,  54054,  60060,  54054},
+	/* E_PIXCLK_74175 */
+	{210937, 234375, 140625, 234375, 140625, 234375, 140625},
+	/* E_PIXCLK_74250 */
+	{ 74250,  82500,  74250,  82500,  74250,  82500,  74250},
+	/* E_PIXCLK_148350*/
+	{421875, 234375, 140625, 234375, 140625, 234375, 140625},
+	/* E_PIXCLK_148500*/
+	{148500, 165000, 148500, 165000, 148500, 165000, 148500}
+#ifdef FORMAT_PC
+	/* E_PIXCLK_31500 */
+	, { 31500,  35000,  31500,  35000,  31500,  35000,  31500},
+	/* E_PIXCLK_36000 */
+	{ 36000,  40000,  36000,  40000,  36000,  40000,  36000},
+	/* E_PIXCLK_40000 */
+	{ 40000,  44444,  40000,  44444,  40000,  44444,  40000},
+	/* E_PIXCLK_49500 */
+	{ 49500,  55000,  49500,  55000,  49500,  55000,  49500},
+	/* E_PIXCLK_50000 */
+	{ 50000,  55556,  50000,  55556,  50000,  55556,  50000},
+	/* E_PIXCLK_56250 */
+	{ 56250,  62500,  56250,  62500,  56250,  62500,  56250},
+	/* E_PIXCLK_65000 */
+	{ 65000,  72222,  65000,  72222,  65000,  72222,  65000},
+	/* E_PIXCLK_75000 */
+	{ 75000,  83333,  75000,  83333,  75000,  83333,  75000},
+	/* E_PIXCLK_78750 */
+	{ 78750,  87500,  78750,  87500,  78750,  87500,  78750},
+	/* E_PIXCLK_135000 */
+	{135000, 150000, 135000, 150000, 135000, 150000, 135000},
+	/* E_PIXCLK_162000*/
+	{162000, 180000, 162000, 180000, 162000, 180000, 162000}
+#endif /* FORMAT_PC */
+};
+
+/**
+ *  Lookup table for each pixel clock frequency's Audio Clock Regeneration N,
+ *  according to SCS Table "Audio Clock Recovery N Values"
+ * */
+
+static CONST_DAT u32 k_pix_clk_to_acr_n[E_PIXCLK_NUM][HDMITX_AFS_NUM] = {
+	/* HDMITX_AFS_32k  _AFS_48K       _AFS_96K        _AFS_192K */
+	/*         _AFS_44_1k      _AFS_88_2K      _AFS_176_4K       */
+	/* E_PIXCLK_25175 */
+	{ 4576,   7007,   6864,  14014,  13728,  28028,  27456},
+	/* E_PIXCLK_25200 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_27000 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_27027 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_54000 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_54054 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_74175 */
+	{11648,  17836,  11648,  35672,  23296,  71344,  46592},
+	/* E_PIXCLK_74250 */
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576},
+	/* E_PIXCLK_148350*/
+	{11648,   8918,   5824,  17836,  11648,  35672,  23296},
+	/* E_PIXCLK_148500*/
+	{ 4096,   6272,   6144,  12544,  12288,  25088,  24576}
+#ifdef FORMAT_PC
+	/* E_PIXCLK_31500 */
+	, { 4096,  6272,  6144,  12544,  12288,  25088,  24576},
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_36000 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_40000 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_49500 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_50000 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_56250 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_65000 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_75000 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_78750 */
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}, /* E_PIXCLK_135000*/
+	{ 4096,  6272,  6144,  12544,  12288,  25088,  24576}  /* E_PIXCLK_162000*/
+#endif /* FORMAT_PC */
+};
+
+/**
+ *  Lookup table for each pixel clock frequency's Audio Divider, according to
+ *  SCS Table "Audio Clock Recovery Divider Values"
+ * */
+static CONST_DAT u8 k_pix_clk_to_adiv[E_PIXCLK_NUM][HDMITX_AFS_NUM] = {
+	/* HDMITX_AFS_32k  _AFS_48K       _AFS_96K        _AFS_192K */
+	/*         _AFS_44_1k      _AFS_88_2K      _AFS_176_4K       */
+	/* E_PIXCLK_25175 */
+	{2,      2,      2,      1,      1,      0,      0},
+	/* E_PIXCLK_25200 */
+	{2,      2,      2,      1,      1,      0,      0},
+	/* E_PIXCLK_27000 */
+	{2,      2,      2,      1,      1,      0,      0},
+	/* E_PIXCLK_27027 */
+	{2,      2,      2,      1,      1,      0,      0},
+	/* E_PIXCLK_54000 */
+	{3,      3,      3,      2,      2,      1,      1},
+	/* E_PIXCLK_54054 */
+	{3,      3,      3,      2,      2,      1,      1},
+	/* E_PIXCLK_74175 */
+	{4,      3,      3,      2,      2,      1,      1},
+	/* E_PIXCLK_74250 */
+	{4,      3,      3,      2,      2,      1,      1},
+	/* E_PIXCLK_148350*/
+	{5,      4,      4,      3,      3,      2,      2},
+	/* E_PIXCLK_148500*/
+	{5,      4,      4,      3,      3,      2,      2}
+#ifdef FORMAT_PC
+	, {2,      2,      2,      1,      1,      0,      0}, /* E_PIXCLK_31500 */
+	{3,      2,      2,      1,      1,      0,      0}, /* E_PIXCLK_36000 */
+	{3,      2,      2,      1,      1,      0,      0}, /* E_PIXCLK_40000 */
+	{3,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_49500 */
+	{3,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_50000 */
+	{3,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_56250 */
+	{4,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_65000 */
+	{4,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_75000 */
+	{4,      3,      3,      2,      2,      1,      1}, /* E_PIXCLK_78750 */
+	{5,      4,      4,      3,      3,      2,      2}, /* E_PIXCLK_135000*/
+	{5,      4,      4,      3,      3,      2,      2}  /* E_PIXCLK_162000*/
+#endif /* FORMAT_PC */
+
+};
+
+/**
+ *  Lookup table for converting a sampling frequency into the values
+ *  required in channel status byte 3 according to IEC60958-3
+ * */
+static CONST_DAT u8 k_afs_to_csbyte3[HDMITX_AFS_NUM+1] = {
+	3,      /* HDMITX_AFS_32k */
+	0,      /* HDMITX_AFS_44_1k */
+	2,      /* HDMITX_AFS_48k */
+	8,      /* HDMITX_AFS_88_2k */
+	10,     /* HDMITX_AFS_96k */
+	12,     /* HDMITX_AFS_176_4k */
+	14,     /* HDMITX_AFS_192k */
+	1,      /* HDMITX_AFS_NOT_INDICATED */
+};
+
+/**
+ *  Lookup table for each pixel clock frequency index's nearest MHz value
+ * */
+static CONST_DAT u8 k_pix_clk_to_mhz[E_PIXCLK_NUM] = {
+	25,     /* E_PIXCLK_25175 */
+	25,     /* E_PIXCLK_25200 */
+	27,     /* E_PIXCLK_27000 */
+	27,     /* E_PIXCLK_27027 */
+	54,     /* E_PIXCLK_54000 */
+	54,     /* E_PIXCLK_54054 */
+	74,     /* E_PIXCLK_74175 */
+	74,     /* E_PIXCLK_74250 */
+	148,    /* E_PIXCLK_148350*/
+	148     /* E_PIXCLK_148500*/
+#ifdef FORMAT_PC
+	, 31, /* E_PIXCLK_31500 */
+	36, /* E_PIXCLK_36000 */
+	40, /* E_PIXCLK_40000 */
+	49, /* E_PIXCLK_49500 */
+	50, /* E_PIXCLK_50000 */
+	56, /* E_PIXCLK_56250 */
+	65, /* E_PIXCLK_65000 */
+	75, /* E_PIXCLK_75000 */
+	79, /* E_PIXCLK_78750 */
+	79, /* E_PIXCLK_79500 */
+	85, /* E_PIXCLK_85500 */
+	108, /* E_PIXCLK_108000 */
+	122, /* E_PIXCLK_121750 */
+	135, /* E_PIXCLK_135000 */
+	162  /* E_PIXCLK_162000 */
+#endif /* FORMAT_PC */
+};
+
+/**
+ *  Lookup table for each CTS X factor's k and m register values
+ * */
+static CONST_DAT u8 k_cts_xto_mk[HDMITX_CTSX_NUM][2] = {
+	/*   Register values    Actual values */
+	/*   m  k               m, k */
+	{3, 0},          /* 8, 1 */
+	{3, 1},          /* 8, 2 */
+	{3, 2},          /* 8, 3 */
+	{3, 3},          /* 8, 4 */
+	{0, 0}           /* 1, 1 */
+};
+
+/**
+ * Table of shadow registers, as packed Shad/Page/Addr codes.
+ * This allows shadow index values to be searched for using register page
+ * and address values.
+ * */
+static CONST_DAT u16 k_shadow_reg[E_SNUM] = {
+	/* Shadow Index                  Packed Shad/Page/Addr */
+	E_REG_P00_MAIN_CNTRL0_W ,    /* E_SP00_MAIN_CNTRL0  */
+	E_REG_P00_INT_FLAGS_0_RW,    /* E_SP00_INT_FLAGS_0  */
+	E_REG_P00_INT_FLAGS_1_RW,    /* E_SP00_INT_FLAGS_1  */
+#ifdef TMFL_TDA9981_SUPPORT
+	E_REG_P00_INT_FLAGS_2_RW,    /* E_SP00_INT_FLAGS_2  */
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_REG_P00_VIP_CNTRL_0_W ,    /* E_SP00_VIP_CNTRL_0  */
+	E_REG_P00_VIP_CNTRL_1_W ,    /* E_SP00_VIP_CNTRL_1  */
+	E_REG_P00_VIP_CNTRL_2_W ,    /* E_SP00_VIP_CNTRL_2  */
+	E_REG_P00_VIP_CNTRL_3_W ,    /* E_SP00_VIP_CNTRL_3  */
+	E_REG_P00_VIP_CNTRL_4_W ,    /* E_SP00_VIP_CNTRL_4  */
+	E_REG_P00_VIP_CNTRL_5_W ,    /* E_SP00_VIP_CNTRL_5  */
+	E_REG_P00_MAT_CONTRL_W  ,    /* E_SP00_MAT_CONTRL   */
+	E_REG_P00_TBG_CNTRL_0_W ,    /* E_SP00_TBG_CNTRL_0  */
+	E_REG_P00_TBG_CNTRL_1_W ,    /* E_SP00_TBG_CNTRL_1  */
+	E_REG_P00_HVF_CNTRL_0_W ,    /* E_SP00_HVF_CNTRL_0  */
+	E_REG_P00_HVF_CNTRL_1_W ,    /* E_SP00_HVF_CNTRL_1  */
+	E_REG_P00_TIMER_H_W     ,    /* E_SP00_TIMER_H      */
+	E_REG_P00_DEBUG_PROBE_W ,    /* E_SP00_DEBUG_PROBE  */
+	E_REG_P00_AIP_CLKSEL_W       /* E_SP00_AIP_CLKSEL   */
+#ifndef TMFL_TDA9981_SUPPORT
+	, E_REG_P01_SC_VIDFORMAT_W   /* E_SP01_SC_VIDFORMAT */
+	, E_REG_P01_SC_CNTRL_W       /* E_SP01_SC_CNTRL     */
+	, E_REG_P01_TBG_CNTRL_0_W    /* E_SP01_TBG_CNTRL_0  */
+#endif /* TMFL_TDA9981_SUPPORT */
+};
+
+/**
+ * Lookup table of input port control registers and their swap and mirror masks
+ * */
+static CONST_DAT struct _bsl_reg_vip {
+	u16 reg;
+	u8  mask_swap;
+	u8  mask_mirror;
+} k_reg_vip[HDMITX_VIN_PORT_MAP_TABLE_LEN] = {
+	{
+		E_REG_P00_VIP_CNTRL_0_W,
+		e_maskreg_p00_vip_cntrl_0_swap_a,
+		e_maskreg_p00_vip_cntrl_0_mirr_a
+	}, /* Port group 0 */
+	{
+		E_REG_P00_VIP_CNTRL_0_W,
+		e_maskreg_p00_vip_cntrl_0_swap_b,
+		e_maskreg_p00_vip_cntrl_0_mirr_b
+	}, /* Port group 1 */
+	{
+		E_REG_P00_VIP_CNTRL_2_W,
+		e_maskreg_p00_vip_cntrl_1_swap_c,
+		e_maskreg_p00_vip_cntrl_1_mirr_c
+	}, /* Port group 2 */
+	{
+		E_REG_P00_VIP_CNTRL_2_W,
+		e_maskreg_p00_vip_cntrl_1_swap_d,
+		e_maskreg_p00_vip_cntrl_1_mirr_d
+	}, /* Port group 3 */
+	{
+		E_REG_P00_VIP_CNTRL_1_W,
+		e_maskreg_p00_vip_cntrl_2_swap_e,
+		e_maskreg_p00_vip_cntrl_2_mirr_e
+	}, /* Port group 4 */
+	{
+		E_REG_P00_VIP_CNTRL_1_W,
+		e_maskreg_p00_vip_cntrl_2_swap_f,
+		e_maskreg_p00_vip_cntrl_2_mirr_f
+	}  /* Port group 5 */
+};
+
+/**
+ * Table of registers to switch scaler off
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_scaler_off[] = {
+	/* Scaler is bypassed */
+	{E_REG_P00_MAIN_CNTRL0_W,   e_maskreg_p00_main_cntrl0_scaler,   0},
+	/* Bypass PLL scaling */
+	{E_REG_P02_PLL_SCG2_RW,     e_maskreg_p02_pll_scg2_bypass_scg,  1},
+	/* Disable scaler clock */
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_ena_sc_clk,   0},
+	/* PLL loop open (standby) */
+	{E_REG_P02_PLL_SCG1_RW,     e_maskreg_p02_pll_scg1_scg_fdn,     1},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to switch scaler on
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_scaler_on[] = {
+	/* Scaler is on */
+	{E_REG_P00_MAIN_CNTRL0_W,   e_maskreg_p00_main_cntrl0_scaler,   1},
+	/* Don't bypass PLL scaling */
+	{E_REG_P02_PLL_SCG2_RW,     e_maskreg_p02_pll_scg2_bypass_scg,  0},
+	/* Enable scaler clock */
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_ena_sc_clk,   1},
+	/* PLL loop active */
+	{E_REG_P02_PLL_SCG1_RW,     e_maskreg_p02_pll_scg1_scg_fdn,     0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to switch to low power (standby)
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_power_off[] = {
+	{E_REG_P02_TEST2_RW,        e_maskreg_p02_test2_pwd1v8,         1},
+	{E_REG_P02_PLL_SCG1_RW,     e_maskreg_p02_pll_scg1_scg_fdn,     1},
+	{E_REG_P02_PLL_SERIAL_1_RW, e_maskreg_p02_pll_serial_1_srl_fdn, 1},
+	{E_REG_P02_PLL_DE_RW,       e_maskreg_p02_pll_de_pllde_fdn,     1},
+	{E_REG_P02_BUFFER_OUT_RW,   e_maskreg_p02_buffer_out_srl_force, 2},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_ena_sc_clk,   0},
+#ifdef TMFL_TDA9981_SUPPORT
+	{E_REG_P00_CCLK_ON_RW,		e_maskreg_p00_cclk_on_cclk_on,		0},
+#endif /* TMFL_TDA9981_SUPPORT */
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to switch to normal power (resume)
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_power_on[] = {
+	{E_REG_P02_TEST2_RW,        e_maskreg_p02_test2_pwd1v8,         0},
+	{E_REG_P02_PLL_SERIAL_1_RW, e_maskreg_p02_pll_serial_1_srl_fdn, 0},
+	{E_REG_P02_PLL_DE_RW,       e_maskreg_p02_pll_de_pllde_fdn,     0},
+	{E_REG_P02_PLL_SCG1_RW,     e_maskreg_p02_pll_scg1_scg_fdn,     0},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_ena_sc_clk,   1},
+	{E_REG_P02_BUFFER_OUT_RW,   e_maskreg_p02_buffer_out_srl_force, 0},
+	{E_REG_P00_TBG_CNTRL_0_W,   e_maskreg_p00_tbg_cntrl_0_sync_once, 0},
+#ifdef TMFL_TDA9981_SUPPORT
+	{E_REG_P00_CCLK_ON_RW,		e_maskreg_p00_cclk_on_cclk_on,		1},
+#endif /* TMFL_TDA9981_SUPPORT */
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to switch HDMI HDCP mode off for DVI
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vout_hdcp_off[] = {
+	{E_REG_P00_TBG_CNTRL_1_W,   e_maskreg_p00_tbg_cntrl_1_dwin_dis, 1},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_hdmi,       0},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_eess,       0},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_ctl_sel,    0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to switch HDMI HDCP mode on for HDMI
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vout_hdcp_on[] = {
+	{E_REG_P00_TBG_CNTRL_1_W,   e_maskreg_p00_tbg_cntrl_1_dwin_dis, 0},
+	{E_REG_P11_ENC_CNTRL_RW,    e_maskreg_p11_enc_cntrl_ctl_code,   1},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_hdmi,       1},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_eess,       1},
+	{E_REG_P12_HDCP_TX33_RW,    e_maskreg_p12_hdcp_tx_33_ctl_sel,    1},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to reset and release the CTS generator
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_reset_cts_generator[] = {
+	{E_REG_P11_AIP_CNTRL_0_RW,  e_maskreg_p11_aip_cntrl_0_rst_cts,  1},
+	{E_REG_P11_AIP_CNTRL_0_RW,  e_maskreg_p11_aip_cntrl_0_rst_cts,  0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to set 5s watchdog timer
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_set5sec_watchdog[] = {
+	/* Watchdog timer reference = CCLK divide by 32 / 100 = 10 kHz */
+	/* PNF57 {E_REG_P00_NDIV_PF_W,       E_MASKREG_ALL,  100}, */
+	/* CCLK divide by 32 = 1MHz */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_wd_clksel,    1},
+	/* Set 5s watchdog (registers set to 100,000) */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_tim_h,        0x02},
+	{E_REG_P00_TIMER_M_W,       E_MASKREG_ALL,                      0xb0},
+	{E_REG_P00_TIMER_L_W,       E_MASKREG_ALL,                      0x00},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to set 120ms watchdog timer based on HDMI clock
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_set120ms_watchdog[] = {
+	/* Set HDMI clock as watchdog */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_wd_clksel,    0},
+	/* Set 120ms watchdog (registers set to 120,000us) */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_tim_h,        0x01},
+	{E_REG_P00_TIMER_M_W,       E_MASKREG_ALL,                      0xD4},
+	{E_REG_P00_TIMER_L_W,       E_MASKREG_ALL,                      0xC0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to set 1s watchdog timer based on HDMI clock use for phase3
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_set1s_watchdog[] = {
+	/* PNF57 Set HDMI clock as watchdog */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_wd_clksel,    0},
+	/* Set 600ms watchdog for link check */
+	{E_REG_P00_TIMER_H_W,       e_maskreg_p00_timer_h_tim_h,        0x00},
+	{E_REG_P00_TIMER_M_W,       E_MASKREG_ALL,                      0x75},
+	{E_REG_P00_TIMER_L_W,       E_MASKREG_ALL,                      0x30},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to bypass colour processing (up/down sampler & matrix)
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_bypass_colour_proc[] = {
+	/* Bypass upsampler for RGB colourbars */
+	{E_REG_P00_HVF_CNTRL_0_W,   e_maskreg_p00_hvf_cntrl_0_intpol,   0},
+	/* Bypass matrix for RGB colourbars */
+	{E_REG_P00_MAT_CONTRL_W,    e_maskreg_p00_mat_contrl_mat_bp,    1},
+	/* Bypass downsampler for RGB colourbars */
+	{E_REG_P00_HVF_CNTRL_1_W,   e_maskreg_p00_hvf_cntrl_1_for,      0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to configure video input mode CCIR656
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vin_mode_ccir656[] = {
+	{E_REG_P00_VIP_CNTRL_4_W,   e_maskreg_p00_vip_cntrl_4_ccir656,      1},
+	{E_REG_P00_HVF_CNTRL_1_W,   e_maskreg_p00_hvf_cntrl_1_semi_planar,  1},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_sel_clk1,         1},
+	{E_REG_P02_PLL_SERIAL_3_RW, e_maskreg_p02_pll_serial_3_srl_ccir,    1},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to configure video input mode RGB444 or YUV444
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vin_mode444[] = {
+	{E_REG_P00_VIP_CNTRL_4_W,   e_maskreg_p00_vip_cntrl_4_ccir656,      0},
+	{E_REG_P00_HVF_CNTRL_1_W,   e_maskreg_p00_hvf_cntrl_1_semi_planar,  0},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_sel_clk1,         0},
+	{E_REG_P02_PLL_SERIAL_3_RW, e_maskreg_p02_pll_serial_3_srl_ccir,    0},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_sel_vrf_clk,      0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of registers to configure video input mode YUV422
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vin_mode_yuv422[] = {
+	{E_REG_P00_VIP_CNTRL_4_W,   e_maskreg_p00_vip_cntrl_4_ccir656,      0},
+	{E_REG_P00_HVF_CNTRL_1_W,   e_maskreg_p00_hvf_cntrl_1_semi_planar,  1},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_sel_clk1,         0},
+	{E_REG_P02_PLL_SERIAL_3_RW, e_maskreg_p02_pll_serial_3_srl_ccir,    0},
+	{E_REG_P02_SEL_CLK_RW,      e_maskreg_p02_sel_clk_sel_vrf_clk,      0},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure for all video input format (vinFmt)
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_common_pll_cfg[] = {
+	{E_REG_P02_PLL_SERIAL_1_RW, E_MASKREG_ALL,  0x00},
+	{E_REG_P02_PLL_SERIAL_2_RW, E_MASKREG_ALL,  0x01},
+	{E_REG_P02_PLL_SERIAL_3_RW, E_MASKREG_ALL,  0x01},
+	{E_REG_P02_SERIALIZER_RW,   E_MASKREG_ALL,  0x00},
+	{E_REG_P02_BUFFER_OUT_RW,   E_MASKREG_ALL,  0x00},
+	{E_REG_P02_CCIR_DIV_RW,     E_MASKREG_ALL,  0x00},
+	{E_REG_P02_PLL_SCG1_RW,     E_MASKREG_ALL,  0x00},
+	{E_REG_P02_AUDIO_DIV_RW,    E_MASKREG_ALL,  0x03},
+	{E_REG_P02_TEST2_RW,        E_MASKREG_ALL,  0x00},
+	{E_REG_P02_SEL_CLK_RW,      E_MASKREG_ALL,  0x09},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure for 480i and 576i vinFmt
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vfmt480i576i_pll_cfg[] = {
+	{E_REG_P02_PLL_SCGN1_RW,    E_MASKREG_ALL,  0x14},
+	{E_REG_P02_PLL_SCGN2_RW,    E_MASKREG_ALL,  0x00},
+	{E_REG_P02_PLL_SCGR1_RW,    E_MASKREG_ALL,  0x0A},
+	{E_REG_P02_PLL_SCGR2_RW,    E_MASKREG_ALL,  0x00},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure for other vinFmt than 480i and 576i
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_vfmt_other_pll_cfg[] = {
+	{E_REG_P02_PLL_SCGN1_RW,    E_MASKREG_ALL,  0xFA},
+	{E_REG_P02_PLL_SCGN2_RW,    E_MASKREG_ALL,  0x00},
+	{E_REG_P02_PLL_SCGR1_RW,    E_MASKREG_ALL,  0x5B},
+	{E_REG_P02_PLL_SCGR2_RW,    E_MASKREG_ALL,  0x00},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure for single mode pixel rate,
+ * vinFmt 480i or 576i only
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_single_prate_vfmt480i576i_pll_cfg[] = {
+	{E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x11},
+	{E_REG_P02_PLL_DE_RW,       E_MASKREG_ALL,  0xA1},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure for single repeated mode pixel rate,
+ * vinFmt 480i or 576i only
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_srepeated_prate_vfmt480i576i_pll_cfg[] = {
+	{E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x01},
+	{E_REG_P02_PLL_DE_RW,       E_MASKREG_ALL,  0xA1},
+	{E_REG_P02_CCIR_DIV_RW,     E_MASKREG_ALL,  0x01},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure single mode pixel rate,
+ * vinFmt other than 480i or 576i
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_single_prate_vfmt_other_pll_cfg[] = {
+	{E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x10},
+	{E_REG_P02_PLL_DE_RW,       E_MASKREG_ALL,  0x91},
+	{0, 0, 0}
+};
+
+/**
+ * Table of PLL settings registers to configure double mode pixel rate,
+ * vinFmt other than 480i or 576i
+ * */
+static CONST_DAT hdmi_tx_reg_mask_val_t k_double_prate_vfmt_other_pll_cfg[] = {
+	{E_REG_P02_PLL_SCG2_RW,     E_MASKREG_ALL,  0x00},
+	{E_REG_P02_PLL_DE_RW,       E_MASKREG_ALL,  0x10},
+	{0, 0, 0}
+};
+
+/**
+ *  Blue filter Lookup table for colour space conversion.
+ *  Each array consists of 31 register values from MAT_CONTROL through
+ *  to MAT_OO3_LSB
+ * */
+static CONST_DAT u8 matrix_coeff_blue_screen[][MATRIX_PRESET_SIZE] = {
+	{
+		0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0
+	},  /* blue screen for RGB output color space */
+
+	{
+		0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x1, 0x0, 0x3, 0x0
+	},  /* blue screen for YCbCr422 output color space */
+
+	{
+		0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x1, 0x0, 0x3, 0x0
+	},  /* blue screen for YCbCr444 output color space */
+};
+
+/*============================================================================*/
+/*                   STATIC VARIABLE DECLARATIONS                             */
+/*============================================================================*/
+
+/* Flag per device used to ignore 1st Encrypt interrupt after HdcpInit */
+static RAM_DAT  bool    g_ignore_encrypt[HDMITX_UNITS_MAX];
+
+/* Register values per device to restore colour processing after test pattern */
+static RAM_DAT  u8   g_mat_contrl[HDMITX_UNITS_MAX];
+static RAM_DAT  u8   g_hvf_cntrl0[HDMITX_UNITS_MAX];
+static RAM_DAT  u8   g_hvf_cntrl1[HDMITX_UNITS_MAX];
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DECLARATIONS                             */
+/*============================================================================*/
+static error_code_t    set_de_vs(hdmi_txobject_t *p_dis,
+                                 bsl_vid_fmt_t vout_fmt);
+static error_code_t    set_pixel_repeat(hdmi_txobject_t *p_dis,
+                                        bsl_vid_fmt_t vout_fmt,
+                                        u8 u_pixel_repeat);
+static error_code_t    set_sampling(hdmi_txobject_t *p_dis);
+static error_code_t    set_scaler_format(hdmi_txobject_t *p_dis,
+        bsl_vid_fmt_t vin_fmt,
+        bsl_vid_fmt_t vout_fmt,
+        u8 pixel_repeat);
+
+/*============================================================================*/
+/*                   PUBLIC FUNCTION DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/* bslAudioInResetCts                                                 */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_audio_in_reset_cts
+(
+    unit_select_t	            tx_unit
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Reset and release the CTS generator */
+	err = set_hw_register_field_table(p_dis, &k_reset_cts_generator[0]);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslAudioInSetConfig                                                */
+/*============================================================================*/
+error_code_t
+bsl_audio_in_set_config
+(
+    unit_select_t           tx_unit,
+    bsla_fmt_t        a_fmt,
+    u8                    chan_i2s,
+    u8                    chan_dsd,
+    bsl_clk_pol_dsd_t   clk_pol_dsd,
+    bsl_swap_dsd_t     swap_dsd,
+    u8                    layout,
+    u16                   u_latency_rd
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(a_fmt        >= HDMITX_AFMT_INVALID)
+	RETIF_BADPARAM(chan_i2s     >= HDMITX_CHAN_INVALID)
+	RETIF_BADPARAM(chan_dsd     >= HDMITX_CHAN_INVALID)
+	RETIF_BADPARAM(clk_pol_dsd   >= HDMITX_CLKPOLDSD_INVALID)
+	RETIF_BADPARAM(swap_dsd     >= HDMITX_SWAPDSD_INVALID)
+	RETIF_BADPARAM(layout      >= HDMITX_LAYOUT_INVALID)
+	RETIF_BADPARAM(u_latency_rd >= HDMITX_LATENCY_INVALID)
+
+	/* Fold OBA onto DSD */
+	if(a_fmt == HDMITX_AFMT_OBA) {
+		a_fmt = HDMITX_AFMT_DSD;
+	}
+
+	/* Set the audio input processor format to aFmt. */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_AIP_CLKSEL_W,
+	                            e_maskreg_p00_aip_clksel_sel_aip,
+	                            (u8)a_fmt);
+	RETIF_REG_FAIL(err)
+
+	/* Select the audio format */
+	if(a_fmt == HDMITX_AFMT_I2S) {
+		if(chan_i2s != HDMITX_CHAN_NO_CHANGE) {
+			err = set_hw_register(p_dis, E_REG_P11_CA_I2S_RW, chan_i2s);
+			RETIF_REG_FAIL(err)
+		}
+	} else if(a_fmt == HDMITX_AFMT_DSD) {
+		if(chan_dsd != HDMITX_CHAN_NO_CHANGE) {
+			err = set_hw_register(p_dis, E_REG_P11_CA_DSD_RW, chan_dsd);
+			RETIF_REG_FAIL(err)
+		}
+		if(clk_pol_dsd != HDMITX_CLKPOLDSD_NO_CHANGE) {
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P00_AIP_CLKSEL_W,
+			                            e_maskreg_p00_aip_clksel_sel_pol_clk,
+			                            (u8)clk_pol_dsd);
+			RETIF_REG_FAIL(err)
+		}
+		if(swap_dsd != HDMITX_SWAPDSD_NO_CHANGE) {
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P11_AIP_CNTRL_0_RW,
+			                            e_maskreg_p11_aip_cntrl_0_swap,
+			                            (u8)swap_dsd);
+			RETIF_REG_FAIL(err)
+		}
+	}
+
+	/* Set layout and latency */
+	if(layout != HDMITX_LAYOUT_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_AIP_CNTRL_0_RW,
+		                            e_maskreg_p11_aip_cntrl_0_layout,
+		                            layout);
+		RETIF_REG_FAIL(err)
+	}
+	if(u_latency_rd != HDMITX_LATENCY_NO_CHANGE) {
+		err = set_hw_register(p_dis, E_REG_P11_LATENCY_RD_RW, (u8)u_latency_rd);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* bslAudioInSetCts                                                   */
+/*============================================================================*/
+error_code_t
+bsl_audio_in_set_cts
+(
+    unit_select_t       tx_unit,
+    bslcts_ref_t  cts_ref,
+    bslafs_t     afs,
+    bsl_vid_fmt_t  vout_fmt,
+    bsl_vfreq_t   vout_freq,
+    u32               u_cts,
+    u16               u_cts_x,
+    bslcts_k_t    cts_k,
+    bslcts_m_t    cts_m
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t   err;        /* Error code */
+	u8           reg_val;     /* Register value */
+	u8           pix_clk;     /* Pixel clock index */
+	u32          acr_n;       /* Audio clock recovery N */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(cts_ref   >= HDMITX_CTSREF_INVALID)
+	RETIF_BADPARAM(afs      >= HDMITX_AFS_INVALID)
+
+#ifdef FORMAT_PC
+	RETIF_BADPARAM(vout_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM((vout_fmt > HDMITX_VFMT_TV_MAX) && (vout_fmt < HDMITX_VFMT_PC_MIN))
+	RETIF_BADPARAM(vout_fmt       > HDMITX_VFMT_PC_MAX)
+#else /* FORMAT_PC */
+	/*FORMAT TV only*/
+	RETIF_BADPARAM(vout_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vout_fmt       > HDMITX_VFMT_TV_MAX)
+#endif /* FORMAT_PC */
+
+	RETIF_BADPARAM(vout_freq >= HDMITX_VFREQ_INVALID)
+	RETIF_BADPARAM(u_cts_x    >= HDMITX_CTSX_INVALID)
+	RETIF_BADPARAM(cts_k     >= HDMITX_CTSK_INVALID)
+	RETIF_BADPARAM(cts_m     >= HDMITX_CTSMTS_INVALID)
+
+	if((vout_fmt  >=  HDMITX_VFMT_TV_MIN) && (vout_fmt  <=  HDMITX_VFMT_TV_MAX)) {
+		if(vout_freq == hdmitx_vfreq_50hz) {
+			RETIF(((vout_fmt < hdmitx_vfmt_17_720x576p_50hz) || (vout_fmt > hdmitx_vfmt_31_1920x1080p_50hz)),
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_24hz) {
+			RETIF(vout_fmt != hdmitx_vfmt_32_1920x1080p_24hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_25hz) {
+			RETIF(vout_fmt != hdmitx_vfmt_33_1920x1080p_25hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_30hz) {
+			RETIF(vout_fmt != hdmitx_vfmt_34_1920x1080p_30hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else {
+			RETIF(vout_fmt >= hdmitx_vfmt_17_720x576p_50hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		}
+
+	}
+
+#ifdef FORMAT_PC
+	if((vout_fmt  >=  HDMITX_VFMT_PC_MIN) && (vout_fmt  <=  HDMITX_VFMT_PC_MAX)) {
+		if(vout_freq == hdmitx_vfreq_60hz) {
+			RETIF(vout_fmt > hdmitx_vfmt_pc_1600x1200p_60hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_70hz) {
+			RETIF(vout_fmt != hdmitx_vfmt_pc_1024x768p_70hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_72hz) {
+			RETIF(((vout_fmt < hdmitx_vfmt_pc_640x480p_72hz) ||
+			       (vout_fmt > hdmitx_vfmt_pc_800x600p_72hz)),
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_75hz) {
+			RETIF(((vout_fmt < hdmitx_vfmt_pc_640x480p_75hz) ||
+			       (vout_fmt > hdmitx_vfmt_pc_1280x1024p_75hz)),
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else if(vout_freq == hdmitx_vfreq_85hz) {
+			RETIF(((vout_fmt < hdmitx_vfmt_pc_640x350p_85hz) ||
+			       (vout_fmt > hdmitx_vfmt_pc_1280x1024p_85hz)),
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		} else {
+			RETIF(vout_fmt != hdmitx_vfmt_pc_1024x768i_87hz,
+			      ERR_HDMI_INCONSISTENT_PARAMS)
+		}
+	}
+#endif /* FORMAT_PC */
+
+	/* Check for auto or manual CTS */
+	if(u_cts == HDMITX_CTS_AUTO) {
+		/* Auto */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_AIP_CNTRL_0_RW,
+		                            e_maskreg_p11_aip_cntrl_0_acr_man,
+		                            0);
+		RETIF_REG_FAIL(err)
+	} else {
+		/* Manual */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_AIP_CNTRL_0_RW,
+		                            e_maskreg_p11_aip_cntrl_0_acr_man,
+		                            1);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Derive M and K from X? */
+	if((cts_m == HDMITX_CTSMTS_USE_CTSX) || (cts_k == HDMITX_CTSK_USE_CTSX)) {
+		RETIF_BADPARAM(u_cts_x == HDMITX_CTSX_UNUSED)
+		cts_m = (bslcts_m_t)k_cts_xto_mk[u_cts_x][0];
+		cts_k = (bslcts_k_t)k_cts_xto_mk[u_cts_x][1];
+	}
+
+	/* Set the Post-divider measured timestamp factor */
+	reg_val = (u8)cts_m;
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_CTS_N_RW,
+	                            e_maskreg_p11_cts_n_m_sel,
+	                            reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Set the Pre-divider scale */
+	reg_val = (u8)cts_k;
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_CTS_N_RW,
+	                            e_maskreg_p11_cts_n_k_sel,
+	                            reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Use voutFmt and voutFreq to index into a lookup table to get
+	 * the current pixel clock value. */
+
+#ifdef FORMAT_PC
+	if((vout_fmt  >=  HDMITX_VFMT_PC_MIN) && (vout_fmt  <=  HDMITX_VFMT_PC_MAX)) {
+		pix_clk = k_vfmt_to_pix_clk_pc[(vout_fmt - HDMITX_VFMT_PC_MIN + 1)];
+	} else {
+#endif /* FORMAT_PC */
+		pix_clk = k_vfmt_to_pix_clk_tv[vout_fmt][vout_freq];
+#ifdef FORMAT_PC
+	}
+#endif /* FORMAT_PC */
+
+	if(pix_clk != E_PIXCLK_INVALID) {
+		/* Set the Audio Clock Recovery N multiplier based on the audio sample
+		 * frequency afs and current pixel clock. */
+		acr_n = k_pix_clk_to_acr_n[pix_clk][afs];
+
+		/* Set ACR N multiplier [19 to 16] */
+		reg_val = (u8)(acr_n >> 16);
+		err = set_hw_register(p_dis, E_REG_P11_ACR_N_2_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set ACR N multiplier [15 to 8] */
+		reg_val = (u8)(acr_n >> 8);
+		err = set_hw_register(p_dis, E_REG_P11_ACR_N_1_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set ACR N multiplier [7 to 0] */
+		reg_val = (u8)acr_n;
+		err = set_hw_register(p_dis, E_REG_P11_ACR_N_0_RW, reg_val);
+		RETIF_REG_FAIL(err)
+
+		/* Set the CDC Audio Divider register based on the audio sample frequency
+		 * afs and current pixel clock. */
+		reg_val = k_pix_clk_to_adiv[pix_clk][afs];
+		err = set_hw_register(p_dis, E_REG_P02_AUDIO_DIV_RW, reg_val);
+		RETIF_REG_FAIL(err)
+
+		/* If auto CTS, get CTS value based on the audio sample
+		 * frequency afs and current pixel clock. */
+		if(u_cts == HDMITX_CTS_AUTO) {
+			u_cts = k_pix_clk_to_acr_cts[pix_clk][afs];
+		}
+	}
+
+	/* Set manual or pixel clock CTS */
+	if(u_cts != HDMITX_CTS_AUTO) {
+		/* Set manual ACR CTS [19 to 16 */
+		reg_val = (u8)(u_cts >> 16);
+		err = set_hw_register(p_dis, E_REG_P11_ACR_CTS_2_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set manual ACR CTS [15 to 8] */
+		reg_val = (u8)(u_cts >> 8);
+		err = set_hw_register(p_dis, E_REG_P11_ACR_CTS_1_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set manual ACR CTS [7 to 0] */
+		reg_val = (u8)u_cts;
+		err = set_hw_register(p_dis, E_REG_P11_ACR_CTS_0_RW, reg_val);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Set the CTS clock reference register according to ctsRef */
+	reg_val = (u8)cts_ref;
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_AIP_CLKSEL_W,
+	                            e_maskreg_p00_aip_clksel_sel_fs,
+	                            reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Reset and release the CTS generator */
+	err = set_hw_register_field_table(p_dis, &k_reset_cts_generator[0]);
+	return err;
+}
+
+/*============================================================================*/
+/* bslAudioOutSetChanStatus                                           */
+/*============================================================================*/
+error_code_t
+bsl_audio_out_set_chan_status
+(
+    unit_select_t               tx_unit,
+    bsl_csformat_info_t    format_info,
+    bsl_cscopyright_t     copyright,
+    u8                        category_code,
+    bslafs_t             sample_freq,
+    bsl_csclk_acc_t        clock_accuracy,
+    bsl_csmax_word_length_t max_word_length,
+    bsl_csword_length_t    word_length,
+    bsl_csorig_afs_t       orig_sample_freq
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+	u8             buf[4];   /* Buffer to hold channel status data */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(format_info     >= HDMITX_CSFI_INVALID)
+	RETIF_BADPARAM(copyright      >= HDMITX_CSCOPYRIGHT_INVALID)
+	RETIF_BADPARAM(sample_freq     >  HDMITX_AFS_NOT_INDICATED)
+	RETIF_BADPARAM(clock_accuracy  >= HDMITX_CSCLK_INVALID)
+	RETIF_BADPARAM(max_word_length  >= HDMITX_CSMAX_INVALID)
+	RETIF_BADPARAM(word_length     >= HDMITX_CSWORD_INVALID)
+	RETIF_BADPARAM(word_length     == HDMITX_CSWORD_RESVD)
+	RETIF_BADPARAM(orig_sample_freq >= HDMITX_CSAFS_INVALID)
+
+	/* Prepare Byte 0 */
+	if(format_info == HDMITX_CSFI_NOTPCM_DEFAULT) {
+		buf[0] = ((u8)copyright << 2) | 2;   /* Set NOT_PCM bit2 */
+	} else {
+		buf[0] = ((u8)format_info << 3) | ((u8)copyright << 2);
+	}
+
+	/* Prepare Byte 1 */
+	buf[1] = category_code;
+
+	/* Prepare Byte 3  - note Byte 2 not in sequence in TDA9983 register map */
+	buf[2] = ((u8)clock_accuracy << 4) | k_afs_to_csbyte3[sample_freq];
+
+	/* Prepare Byte 4 */
+	buf[3] = ((u8)orig_sample_freq << 4) | ((u8)word_length << 1) |
+	         (u8)max_word_length;
+
+	/* Write 4 Channel Status bytes */
+	err = set_hw_registers(p_dis, E_REG_P11_CH_STAT_B_0_RW, &buf[0], 4);
+	return err;
+}
+
+/*============================================================================*/
+/* bslAudioOutSetChanStatusMapping                                    */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_audio_out_set_chan_status_mapping
+(
+    unit_select_t  tx_unit,
+    u8           source_left,
+    u8           channel_left,
+    u8           source_right,
+    u8           channel_right
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+	u8             buf[2];   /* Buffer to hold channel status data */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(source_left   > HDMITX_CS_SOURCES_MAX)
+	RETIF_BADPARAM(channel_left  > HDMITX_CS_CHANNELS_MAX)
+	RETIF_BADPARAM(source_right  > HDMITX_CS_SOURCES_MAX)
+	RETIF_BADPARAM(channel_right > HDMITX_CS_CHANNELS_MAX)
+
+	/* Prepare Left byte */
+	buf[0] = ((u8)channel_left << 4) | (u8)source_left;
+
+	/* Prepare Right byte */
+	buf[1] = ((u8)channel_right << 4) | (u8)source_right;
+
+	/* Write 2 Channel Status bytes */
+	err = set_hw_registers(p_dis, e_reg_p11_ch_stat_b_2_ap0_l_rw, &buf[0], 2);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslAudioOutSetMute                                                 */
+/*============================================================================*/
+error_code_t
+bsl_audio_out_set_mute
+(
+    unit_select_t      tx_unit,
+    bsla_mute_t  a_mute
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if sink is not an HDMI device */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(a_mute >= HDMITX_AMUTE_INVALID)
+
+	/* Reset the audio FIFO to mute audio */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_AIP_CNTRL_0_RW,
+	                            e_maskreg_p11_aip_cntrl_0_rst_fifo,
+	                            (u8)a_mute);
+	return err;
+}
+
+/*============================================================================*/
+/* bslDeinit                                                          */
+/*============================================================================*/
+error_code_t
+bsl_deinit
+(
+    unit_select_t tx_unit
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Hold the device in reset to disable it */
+	(void)set_hw_register_field(p_dis, E_REG_P00_MAIN_CNTRL0_W,
+	                            e_maskreg_p00_main_cntrl0_sr, 1);
+
+	/* Clear the Initialized flag to destroy the device instance */
+	p_dis->b_initialized = false;
+
+	set_state(p_dis, EV_DEINIT);
+	return 0;
+}
+
+/*============================================================================*/
+/* bslHotPlugGetStatus                                                */
+/*============================================================================*/
+error_code_t
+bsl_hot_plug_get_status
+(
+    unit_select_t        tx_unit,
+    bsl_hot_plug_t *p_hot_plug_status
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(p_hot_plug_status == (bsl_hot_plug_t *)0)
+
+	/* Read the hot plug status flag register last read at interrupt */
+	*p_hot_plug_status = p_dis->hot_plug_status;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslRxSenseGetStatus                                                */
+/*============================================================================*/
+error_code_t
+bsl_rx_sense_get_status
+(
+    unit_select_t        tx_unit,
+    bsl_rx_sense_t *p_rx_sense_status
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(p_rx_sense_status == (bsl_rx_sense_t *)0)
+
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+	/* Read the Rx sense status flag register last read at interrupt */
+	*p_rx_sense_status = p_dis->rx_sense_status;
+	return 0;
+#else /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+	(void)*p_rx_sense_status; /* else not referenced */
+	return ERR_HDMI_NOT_SUPPORTED;
+#endif /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+}
+
+/*============================================================================*/
+/* bslHwGetRegisters                                                  */
+/*============================================================================*/
+error_code_t
+bsl_hw_get_registers
+(
+    unit_select_t	tx_unit,
+    int             reg_page,
+    int             reg_addr,
+    u8          *p_reg_buf,
+    int             n_regs
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t *p_dis;
+	error_code_t   err;            /* Error code */
+	int             i;              /* Loop index */
+	u8           new_reg_page;     /* The register's new page number */
+	u8           reg_shad;        /* Index to the register's shadow copy */
+	u16          reg_shad_page_addr;/* Packed shadowindex/page/address */
+	bsl_sys_args_t sys_args;   /* Arguments passed to system function     */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM((reg_page < k_page_index_to_page[E_PAGE_00])
+	               || ((reg_page > k_page_index_to_page[E_PAGE_02])
+	                   && (reg_page < k_page_index_to_page[E_PAGE_11]))
+	               || (reg_page > k_page_index_to_page[E_PAGE_12]))
+	RETIF_BADPARAM((reg_addr < E_REG_MIN_ADR) || (reg_addr >= E_REG_CURPAGE_ADR_W))
+	RETIF_BADPARAM(p_reg_buf == (p_uint8)0)
+	RETIF_BADPARAM((n_regs < 1) || ((n_regs + reg_addr) > E_REG_CURPAGE_ADR_W))
+
+	/* Set page register if required */
+	new_reg_page = (u8)reg_page;
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* Read each register in the range. nRegs must start at 1 or more */
+	for(; n_regs > 0; p_reg_buf++, reg_addr++, n_regs--) {
+		/* Find shadow register index.
+		 * This loop is not very efficient, but it is assumed that this API
+		 * will not be used often. The alternative is to use a huge sparse
+		 * array indexed by page and address and containing the shadow index.
+		 *		 */
+		reg_shad = E_SNONE;
+		for(i = 0; i < E_SNUM; i++) {
+			/* Check lookup table for match with page and address */
+			reg_shad_page_addr = k_shadow_reg[i];
+			if((SPA2PAGE(reg_shad_page_addr) == new_reg_page)
+			   && (SPA2ADDR(reg_shad_page_addr) == reg_addr)) {
+				/* Found page and address - look up the shadow index */
+				reg_shad = SPA2SHAD(reg_shad_page_addr);
+				break;
+			}
+		}
+		/* Read the shadow register if available, as device registers that
+		 * are shadowed cannot be read directly */
+		if(reg_shad != E_SNONE) {
+			*p_reg_buf = p_dis->shadow_reg[reg_shad];
+		} else {
+			/* Read the device register - all non-OK results are errors.
+			 * Note that some non-shadowed registers are also write-only and
+			 * cannot be read. */
+			sys_args.slave_addr       = p_dis->u_hw_address;
+			sys_args.first_register   = (u8)reg_addr;
+			sys_args.len_data         = 1;
+			sys_args.p_data           = p_reg_buf;
+			err = p_dis->sys_func_read(&sys_args);
+			RETIF(err != 0, ERR_HDMI_I2C_READ)
+		}
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslHwGetVersion                                                    */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_hw_get_version
+(
+    unit_select_t	tx_unit,
+    p_uint8          p_hw_version
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t   err;            /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(p_hw_version == (p_uint8)0)
+
+#ifdef TMFL_TDA9981_SUPPORT
+
+	*p_hw_version = (u8) BSLHDMITX_TDA9981;
+
+#else
+
+	*p_hw_version = (u8) BSLHDMITX_TDA9983;
+
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslHwGetCapabilities                                                    */
+/*============================================================================*/
+error_code_t
+bsl_hw_get_capabilities
+(
+    unit_select_t          tx_unit,
+    bsl_hw_feature_t  *p_device_capabilities
+)
+
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t   err;            /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(p_device_capabilities == (bsl_hw_feature_t *)0)
+
+	*p_device_capabilities = bsl_hw_none;
+
+	if((p_dis->u_device_features & e_maskreg_p00_version_not_h) == 0) {
+		*p_device_capabilities = (bsl_hw_feature_t)(*p_device_capabilities + bsl_hw_hdcp);
+	}
+
+	if((p_dis->u_device_features & e_maskreg_p00_version_not_s) == 0) {
+		*p_device_capabilities = (bsl_hw_feature_t)(*p_device_capabilities + bsl_hw_scaler);
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslHwHandleInterrupt                                               */
+/* RETIF_REG_FAIL NOT USED HERE AS ALL ERRORS SHOULD BE TRAPPED IN ALL BUILDS */
+/*============================================================================*/
+error_code_t
+bsl_hw_handle_interrupt
+(
+    unit_select_t		tx_unit
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t *p_dis;
+	error_code_t     err;              /* Error code */
+	u8             reg_val;           /* Register value */
+#ifdef TMFL_TDA9981_SUPPORT
+	u16            f_interrupt_status; /* Interrupt flags */
+	u16            f_interrupt_mask;   /* Mask to test each interrupt bit */
+#ifdef TMFL_RX_SENSE_ON
+	bsl_rx_sense_t  new_rxs_fil;       /* Latest copy of rx_sense */
+#endif /* TMFL_RX_SENSE_ON */
+#else /* TMFL_TDA9981_SUPPORT */
+	u8             f_interrupt_status; /* Interrupt flags */
+	u8             f_interrupt_mask;   /* Mask to test each interrupt bit */
+#endif /* TMFL_TDA9981_SUPPORT */
+	int               i;                /* Loop counter */
+	bsl_hot_plug_t new_hpd_in;      /* Latest copy of hpd input */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	f_interrupt_status = 0;
+
+	/* Read the main interrupt flags register to determine the source(s)
+	 * of the interrupt. (The device resets these register flags after they
+	 * have been read.)
+	 *	 */
+#ifdef TMFL_TDA9981_SUPPORT
+	err = get_hw_register(p_dis, E_REG_P00_INT_FLAGS_0_RW, &reg_val);
+	RETIF(err != 0, err)
+	f_interrupt_status = reg_val;
+
+#else /* TMFL_TDA9981_SUPPORT */
+	err = get_hw_register(p_dis, E_REG_P00_INT_FLAGS_0_RW, &f_interrupt_status);
+	RETIF(err != 0, err)
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Read Hot Plug input status to unit object
+	 *	   DJW do this after reading INT flags so we get the actual
+	 *	   level that caused the interrupt */
+	err = get_hw_register(p_dis, E_REG_P00_INT_FLAGS_1_RW, &reg_val);
+	RETIF(err != 0, err)
+	new_hpd_in = (reg_val & e_maskreg_p00_int_flags_1_hpd_in) ?
+	             HDMITX_HOTPLUG_ACTIVE : HDMITX_HOTPLUG_INACTIVE;
+
+#ifdef TMFL_TDA9981_SUPPORT
+	/* Read the software interrupt flag */
+	if((reg_val & e_maskreg_p00_int_flags_1_sw_int) != 0) {
+		f_interrupt_status = f_interrupt_status | (1 << HDMITX_CALLBACK_INT_SW_INT);
+	}
+
+#ifdef TMFL_RX_SENSE_ON
+	/* Read INT_FLAGS_2 interrupt flag register.
+	 *(the device resets these register flags after they
+	 * have been read.) */
+	err = get_hw_register(p_dis, E_REG_P00_INT_FLAGS_2_RW, &reg_val);
+	RETIF(err != 0, err)
+
+	/* Has the rx_sense interrupt occurs */
+	if((reg_val & e_maskreg_p00_int_flags_2_rx_sense) != 0) {
+		f_interrupt_status = f_interrupt_status | (1 << HDMITX_CALLBACK_INT_RX_SENSE);
+	}
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Has the hpd input changed? (Ignore the HPD interrupt status flag in
+	 * fInterruptStatus as this may have latched a connect/disconnect glitch) */
+	if(new_hpd_in != p_dis->hot_plug_status) {
+		/* Yes: save new HPD level */
+		p_dis->hot_plug_status = new_hpd_in;
+
+		/* Reset EDID status */
+		p_dis->edid_status = HDMITX_EDID_NOT_READ;
+
+#ifdef TMFL_TDA9981_SUPPORT
+		/* Set HPD flag to 1 although it certainly already done just a security */
+		f_interrupt_status |= e_maskreg_p00_int_flags_0_hpd;
+		/* Reset all simultaneous HDCP interrupts on hot plug,
+		 * preserving only the high-priority hpd interrupt rx_sense and sw interrupt for debug*/
+		f_interrupt_status &= e_maskreg_p00_int_flags_0_hpd |
+#ifdef TMFL_RX_SENSE_ON
+		                      (1 << HDMITX_CALLBACK_INT_RX_SENSE) |
+#endif /* TMFL_RX_SENSE_ON */
+		                      (1 << HDMITX_CALLBACK_INT_SW_INT);
+#else
+		/* Reset all simultaneous HDCP interrupts on hot plug/unplug,
+		 * preserving only the high-priority hpd interrupt */
+		f_interrupt_status = e_maskreg_p00_int_flags_0_hpd;
+#endif /* TMFL_TDA9981_SUPPORT */
+
+		if(p_dis->hot_plug_status == HDMITX_HOTPLUG_ACTIVE) {
+			set_state(p_dis, EV_PLUGGEDIN);
+		} else {
+			set_state(p_dis, EV_UNPLUGGED);
+		}
+	} else {
+		/* Clear HPD status if level has not changed */
+		f_interrupt_status &= ~e_maskreg_p00_int_flags_0_hpd;
+	}
+
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+
+	/* Read INT_FLAGS_3 interrupt flag register. */
+	err = get_hw_register(p_dis, E_REG_P00_INT_FLAGS_3_R, &reg_val);
+	RETIF(err != 0, err)
+
+	/*	Read RXS_FIL status to know the actual
+	 *		level that caused the interrupt */
+	new_rxs_fil = (reg_val & e_maskreg_p00_int_flags_3_rxs_fil) ?
+	              HDMITX_RX_SENSE_ACTIVE : HDMITX_RX_SENSE_INACTIVE;
+
+	/* Has the Rxs Fil changed? (Ignore the RxSense interrupt status flag in
+	 * fInterruptStatus as this may have latched a on/off glitch) */
+	if(new_rxs_fil != p_dis->rx_sense_status) {
+		/* Yes: save new rxSense level */
+		p_dis->rx_sense_status = new_rxs_fil;
+
+		/* Set RX_Sense flag to 1 although it certainly already done just a security */
+		f_interrupt_status |= (1 << HDMITX_CALLBACK_INT_RX_SENSE);
+
+		f_interrupt_status &= e_maskreg_p00_int_flags_0_hpd |
+		                      (1 << HDMITX_CALLBACK_INT_RX_SENSE) |
+		                      (1 << HDMITX_CALLBACK_INT_SW_INT);
+
+		if(p_dis->rx_sense_status == HDMITX_RX_SENSE_ACTIVE) {
+			set_state(p_dis, EV_SINKON);
+		} else {
+			set_state(p_dis, EV_SINKOFF);
+		}
+	} else {
+		/* Clear RX_sense IT if level has not changed */
+		f_interrupt_status &= ~(1 << HDMITX_CALLBACK_INT_RX_SENSE);
+	}
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Ignore other simultaneous HDCP interrupts if T0 interrupt,
+	 * preserving any hpd interrupt */
+	if(f_interrupt_status & e_maskreg_p00_int_flags_0_t0) {
+		f_interrupt_status &=
+		    (
+		        e_maskreg_p00_int_flags_0_hpd |
+		        e_maskreg_p00_int_flags_0_t0
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+		        | (1 << HDMITX_CALLBACK_INT_RX_SENSE)
+#endif /* TMFL_RX_SENSE_ON */
+		        | (1 << HDMITX_CALLBACK_INT_SW_INT)
+#endif /* TMFL_TDA9981_SUPPORT */
+		    );
+	}
+
+	/* For each interrupt flag that is set, check the corresponding registered
+	 * callback function pointer in the Device Instance Structure
+	 * funcIntCallbacks array.
+	 *	 */
+	f_interrupt_mask = 1;
+	for(i = 0; i < HDMITX_CALLBACK_INT_NUM; i++) {
+		if(f_interrupt_status & f_interrupt_mask) {
+			/* IF a registered callback pointer is non-null THEN call it. */
+			if(p_dis->func_int_callbacks[i] != (pbsl_callback_t)0) {
+				p_dis->func_int_callbacks[i](tx_unit);
+			}
+		}
+		f_interrupt_mask <<= 1;
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslFlagSwInt                                                       */
+/* Use only for debug to flag the software debug interrupt                    */
+/*============================================================================*/
+error_code_t
+bsl_flag_sw_int
+(
+    unit_select_t	            tx_unit
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	err = set_hw_register(p_dis, E_REG_P00_SW_INT_W,
+	                      e_maskreg_p00_sw_int_sw_int);
+
+	return err;
+#else /* TMFL_TDA9981_SUPPORT */
+	return ERR_HDMI_NOT_SUPPORTED;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslHwSetRegisters                                                  */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_hw_set_registers
+(
+    unit_select_t	tx_unit,
+    int             reg_page,
+    int             reg_addr,
+    u8          *p_reg_buf,
+    int             n_regs
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t *p_dis;
+	error_code_t   err;            /* Error code */
+	int             i;              /* Loop index */
+	u8           new_reg_page;     /* The register's new page number */
+	u8           reg_shad;        /* Index to the register's shadow copy */
+	u16          reg_shad_page_addr;/* Packed shadowindex/page/address */
+	bsl_sys_args_t sys_args;   /* Arguments passed to system function */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM((reg_page < k_page_index_to_page[E_PAGE_00])
+	               || ((reg_page > k_page_index_to_page[E_PAGE_02])
+	                   && (reg_page < k_page_index_to_page[E_PAGE_11]))
+	               || (reg_page > k_page_index_to_page[E_PAGE_12]))
+	RETIF_BADPARAM((reg_addr < E_REG_MIN_ADR) || (reg_addr >= E_REG_CURPAGE_ADR_W))
+	RETIF_BADPARAM(p_reg_buf == (p_uint8)0)
+	RETIF_BADPARAM((n_regs < 0) || ((n_regs + reg_addr) > E_REG_CURPAGE_ADR_W))
+
+	/* Set page register if required */
+	new_reg_page = (u8)reg_page;
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* Write each register in the range. nRegs = 0 is ok, to allow only
+	 * the page register to be written if required (above)
+	 *	 */
+	for(; n_regs > 0; p_reg_buf++, reg_addr++, n_regs--) {
+		/* Find shadow register index.
+		 * This loop is not very efficient, but it is assumed that this API
+		 * will not be used often. The alternative is to use a huge sparse
+		 * array indexed by page and address and containing the shadow index.
+		 *		 */
+		for(i = 0; i < E_SNUM; i++) {
+			/* Check lookup table for match with page and address */
+			reg_shad_page_addr = k_shadow_reg[i];
+			if((SPA2PAGE(reg_shad_page_addr) == new_reg_page)
+			   && (SPA2ADDR(reg_shad_page_addr) == reg_addr)) {
+				/* Found index - write the shadow register */
+				reg_shad = SPA2SHAD(reg_shad_page_addr);
+				p_dis->shadow_reg[reg_shad] = *p_reg_buf;
+				break;
+			}
+		}
+		/* Write the device register - all non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = (u8)reg_addr;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = p_reg_buf;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+	}
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslHwStartup                                                       */
+/*============================================================================*/
+void
+bsl_hw_startup
+(
+    void
+)
+{
+	/* Reset device instance data for when compiler doesn't do it */
+	lmemset(&g_hdmi_tx_instance, 0, sizeof(g_hdmi_tx_instance));
+}
+
+/*============================================================================*/
+/* bslInit                                                            */
+/* RETIF_REG_FAIL NOT USED HERE AS ALL ERRORS SHOULD BE TRAPPED IN ALL BUILDS */
+/*============================================================================*/
+error_code_t
+bsl_init
+(
+    unit_select_t	           tx_unit,
+    u8                      u_hw_address,
+    pbsl_sys_func_t      sys_func_write,
+    pbsl_sys_func_t      sys_func_read,
+    pbsl_sys_func_edid_t  sys_func_edid_read,
+    pbsl_sys_func_timer_t sys_func_timer,
+    bsl_callback_list_t *func_int_callbacks,
+    bool                       b_edid_alt_addr,
+    bsl_vid_fmt_t        vin_fmt,
+    bsl_pix_rate_t       pix_rate
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t     err;      /* Error code */
+	int               i;        /* Loop index */
+	bool              b_found;   /* T=found, F=not found */
+	u8             reg_val;   /* Value read from register */
+
+	/* Check unit parameter and point to its object */
+	RETIF(tx_unit < unit0, ERR_HDMI_BAD_UNIT_NUMBER)
+	RETIF(tx_unit >= HDMITX_UNITS_MAX, ERR_HDMI_BAD_UNIT_NUMBER)
+	p_dis = &g_hdmi_tx_instance[tx_unit];
+
+	/* IF the bInitialized flag is set THEN return (only Init does this) */
+	RETIF(p_dis->b_initialized, ERR_HDMI_INIT_FAILED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(u_hw_address < HDMITX_SLAVE_ADDRESS_MIN)
+	RETIF_BADPARAM(u_hw_address > HDMITX_SLAVE_ADDRESS_MAX)
+	RETIF_BADPARAM(sys_func_write == (pbsl_sys_func_t)0)
+	RETIF_BADPARAM(sys_func_read == (pbsl_sys_func_t)0)
+	RETIF_BADPARAM(sys_func_edid_read == (pbsl_sys_func_edid_t)0)
+	RETIF_BADPARAM(sys_func_timer == (pbsl_sys_func_timer_t)0)
+	RETIF_BADPARAM((b_edid_alt_addr != true) && (b_edid_alt_addr != false))
+#ifdef FORMAT_PC
+	RETIF_BADPARAM(vin_fmt  < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM((vin_fmt > HDMITX_VFMT_TV_MAX) && (vin_fmt < HDMITX_VFMT_PC_MIN))
+	RETIF_BADPARAM(vin_fmt  > HDMITX_VFMT_PC_MAX)
+#else /* FORMAT_PC */
+	/* FORMAT TV only */
+	RETIF_BADPARAM(vin_fmt  < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vin_fmt  > HDMITX_VFMT_TV_MAX)
+#endif /* FORMAT_PC */
+	RETIF_BADPARAM(pix_rate >= HDMITX_PIXRATE_INVALID)
+
+	/* Set all Device Instance Structure members to default values */
+	lmemcpy(p_dis, &k_hdmi_tx_instance_default, sizeof(*p_dis));
+
+	/* Copy txUnit, uHwAddress, sysFuncWrite and sysFuncRead values to
+	 * the defaulted Device Instance Structure BEFORE FIRST DEVICE ACCESS.
+	 *	 */
+	p_dis->tx_unit          = tx_unit;
+#ifdef UNIT_TEST
+	/* Unit test build can't support 127 device sets of dummy registers, so use
+	 * smaller range instead, indexed by unit number not I2C address */
+	p_dis->u_hw_address      = (u8)tx_unit;
+#else
+	/* Store actual I2C address */
+	p_dis->u_hw_address      = u_hw_address;
+#endif
+	p_dis->sys_func_write    = sys_func_write;
+	p_dis->sys_func_read     = sys_func_read;
+	p_dis->sys_func_edid_read = sys_func_edid_read;
+	p_dis->sys_func_timer    = sys_func_timer;
+
+	/* Reset Hdcp interrupt flag */
+	g_ignore_encrypt[tx_unit] = false;
+
+	/* Ensure that DDC is not connected to I2C at start */
+	err = set_hw_register(p_dis, E_REG_P00_GHOST_ADDR_W, 0x01);
+	RETIF(err != 0, err)
+
+	/* Read the device version register to uDeviceVersion in the
+	 * Device Instance Structure
+	 *	 */
+	err = get_hw_register(p_dis, E_REG_P00_VERSION_R, &p_dis->u_device_version);
+	RETIF(err != 0, err)
+	/* Copy N4 features bits to DIS */
+	p_dis->u_device_features = p_dis->u_device_version &
+	                           (e_maskreg_p00_version_not_h | e_maskreg_p00_version_not_s);
+	/* Mask off N4 features bits in version */
+	p_dis->u_device_version &= (u8)~p_dis->u_device_features;
+
+#ifdef TMFL_TDA9981_SUPPORT
+	/* If version reads zero, test not_s to '1' for TDA9981 */
+	if(p_dis->u_device_version == E_DEV_VERSION_N4) {
+		if((p_dis->u_device_features & e_maskreg_p00_version_not_s) !=
+		   e_maskreg_p00_version_not_s) {
+			p_dis->u_device_version = E_DEV_VERSION_LIST_END;
+		}
+	}
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Quit if version reads zero */
+	RETIF(p_dis->u_device_version == E_DEV_VERSION_LIST_END,
+	      ERR_HDMI_COMPATIBILITY)
+
+	/* Search for the device version in the Supported Version
+	 * List in the Device Instance Structure.
+	 *	 */
+	for(i = 0, b_found = false; i < E_DEV_VERSION_LIST_NUM; i++) {
+		if(p_dis->u_device_version == p_dis->u_supported_versions[i]) {
+			b_found = true;
+		}
+	}
+
+	/* IF the device version is not found in the Supported Version List THEN
+	 * this driver component is not compatible with the device.
+	 *	 */
+	RETIF(!b_found, ERR_HDMI_COMPATIBILITY);
+
+	/* If version is N4 then detect N5 device (both have same version) */
+	if(p_dis->u_device_version == E_DEV_VERSION_N4) {
+		/* Read N5-specific registers to detect N5 */
+		err = get_hw_register(p_dis, E_REG_P00_DWIN_RE_DE_W, &reg_val);
+		RETIF(err != 0, err)
+		if(reg_val == 0x11) {
+			/* Default value for N5 */
+			err = get_hw_register(p_dis, E_REG_P00_DWIN_FE_DE_W, &reg_val);
+			RETIF(err != 0, err)
+			if(reg_val == 0x7A) {
+				/* Both N5 registers have correct default value for N5,
+				 * so set the N5 'feature' flag */
+				p_dis->u_device_features |= E_MASKREG_P00_FEATURE_N5;
+			}
+		}
+	}
+
+	/* IF the funcIntCallbacks array pointer is defined
+	 * THEN for each funcIntCallbacks pointer that is not null:
+	 * - Copy the pointer to the Device Instance Structure
+	 *   funcIntCallbacks array.
+	 *	 */
+	for(i = 0; i < HDMITX_CALLBACK_INT_NUM; i++) {
+		if((func_int_callbacks != (bsl_callback_list_t *)0)
+		   && (func_int_callbacks->func_callback[i] != (pbsl_callback_t)0)) {
+			p_dis->func_int_callbacks[i] = func_int_callbacks->func_callback[i];
+		} else {
+			p_dis->func_int_callbacks[i] = (pbsl_callback_t)0;
+		}
+	}
+
+	/* Set the EDID alternate address flag if needed*/
+	p_dis->b_edid_alternate_addr = b_edid_alt_addr;
+
+	/* Set the bInitialized flag to enable other APIs */
+	p_dis->b_initialized = true;
+
+	/* Set the PLL before resetting the device */
+	/* PLL registers common configuration */
+	err = set_hw_register_field_table(p_dis, &k_common_pll_cfg[0]);
+	RETIF_REG_FAIL(err)
+
+	switch(vin_fmt) {
+		/* 480i or 576i video input format */
+	case hdmitx_vfmt_06_720x480i_60hz:
+	case hdmitx_vfmt_07_720x480i_60hz:
+	case hdmitx_vfmt_21_720x576i_50hz:
+	case hdmitx_vfmt_22_720x576i_50hz:
+		err = set_hw_register_field_table(p_dis, &k_vfmt480i576i_pll_cfg[0]);
+		RETIF_REG_FAIL(err)
+
+		switch(pix_rate) {
+		case HDMITX_PIXRATE_SINGLE:
+			/* Single edge mode, vinFmt 480i or 576i */
+			err = set_hw_register_field_table(p_dis, &k_single_prate_vfmt480i576i_pll_cfg[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		case HDMITX_PIXRATE_SINGLE_REPEATED:
+			/* Single repeated edge mode, vinFmt 480i or 576i */
+			err = set_hw_register_field_table(p_dis, &k_srepeated_prate_vfmt480i576i_pll_cfg[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		default:
+			/* Double edge mode doesn't exist for vinFmt 480i or 576i */
+			return(ERR_HDMI_INCONSISTENT_PARAMS);
+			break;
+		}
+
+		break;
+
+		/* Others video input format */
+	default:
+		err = set_hw_register_field_table(p_dis, &k_vfmt_other_pll_cfg[0]);
+		RETIF_REG_FAIL(err)
+
+		switch(pix_rate) {
+		case HDMITX_PIXRATE_SINGLE:
+			/* Single edge mode, vinFmt other than 480i or 576i */
+			err = set_hw_register_field_table(p_dis, &k_single_prate_vfmt_other_pll_cfg[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		case HDMITX_PIXRATE_DOUBLE:
+			/* Double edge mode, vinFmt other than 480i or 576i */
+			err = set_hw_register_field_table(p_dis, &k_double_prate_vfmt_other_pll_cfg[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		default:
+			/* Single repeated edge mode doesn't exist for other vinFmt */
+			return(ERR_HDMI_INCONSISTENT_PARAMS);
+			break;
+		}
+
+		break;
+	}
+
+	/* Reset the device */
+	err = bsl_reset(tx_unit);
+	RETIF(err != 0, err)
+
+	/* The DIS hotplug status is HDMITX_HOTPLUG_INVALID, so call the main
+	 * interrupt handler to read the current Hot Plug status and run any
+	 * registered HPD callback before interrupts are enabled below */
+	err = bsl_hw_handle_interrupt(tx_unit);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	/* enable sw _interrupt for debug */
+	err = set_hw_register(p_dis, E_REG_P00_INT_FLAGS_1_RW,
+	                      e_maskreg_p00_int_flags_1_sw_int);
+
+#ifdef TMFL_RX_SENSE_ON
+	/* enable sw _interrupt for debug */
+	err = set_hw_register(p_dis, E_REG_P00_INT_FLAGS_2_RW,
+	                      e_maskreg_p00_int_flags_2_rx_sense);
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Enable only the Hot Plug detect interrupt */
+	err = set_hw_register(p_dis, E_REG_P00_INT_FLAGS_0_RW,
+	                      e_maskreg_p00_int_flags_0_hpd);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPowerGetState                                                   */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_power_get_state
+(
+    unit_select_t		tx_unit,
+    p_power_state_t		pe_power_state
+)
+{
+	hdmi_txobject_t *p_dis;   /* Pointer to Device Instance Structure */
+	error_code_t     err;    /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(pe_power_state == (p_power_state_t)0)
+
+	/* Read the device power status and set the pePowerState
+	 * return parameter
+	 *	 */
+	*pe_power_state = p_dis->e_power_state;
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslPowerSetState                                                   */
+/*============================================================================*/
+error_code_t
+bsl_power_set_state
+(
+    unit_select_t		tx_unit,
+    power_state_t      e_power_state
+)
+{
+	hdmi_txobject_t *p_dis;   /* Pointer to Device Instance Structure */
+	error_code_t     err;    /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(e_power_state > power_off)
+
+	/* Treat Off and Suspend the same as Standby */
+	if((e_power_state == power_off) || (e_power_state == power_suspend)) {
+		e_power_state = power_standby;
+	}
+
+	/* Set the device power control register to the requested ePowerState
+	 * state
+	 *	 */
+	if(e_power_state == power_on) {
+		/** Set power On state control registers */
+		err = set_hw_register_field_table(p_dis, &k_power_on[0]);
+		RETIF_REG_FAIL(err)
+
+		if(p_dis->e_power_state == power_standby) {
+			if(p_dis->hot_plug_status == HDMITX_HOTPLUG_ACTIVE) {
+				set_state(p_dis, EV_RESUME_PLUGGEDIN);
+			} else {
+				set_state(p_dis, EV_RESUME_UNPLUGGED);
+			}
+		}
+	} else {
+		/** Set power standby state control registers */
+		err = set_hw_register_field_table(p_dis, &k_power_off[0]);
+		RETIF_REG_FAIL(err)
+
+		set_state(p_dis, EV_STANDBY);
+	}
+
+	/* Save the ePowerState value in the Device Instance Structure */
+	p_dis->e_power_state = e_power_state;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslReset                                                           */
+/*============================================================================*/
+error_code_t
+bsl_reset
+(
+    unit_select_t		tx_unit
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Write to the transmitter to do a soft reset. Don't abort after any
+	 * error here, to ensure full reset.
+	 *	 */
+	(void)set_hw_register_field(p_dis, E_REG_P00_MAIN_CNTRL0_W,
+	                            e_maskreg_p00_main_cntrl0_sr, 1);
+	p_dis->sys_func_timer(50); /* ms */
+	(void)set_hw_register_field(p_dis, E_REG_P00_MAIN_CNTRL0_W,
+	                            e_maskreg_p00_main_cntrl0_sr, 0);
+
+	/* Clear any colourbars */
+	(void)set_hw_register_field(p_dis, E_REG_P00_HVF_CNTRL_0_W,
+	                            e_maskreg_p00_hvf_cntrl_0_sm, 0);
+
+	/* Transmitter is now inactive so treat as if sink has been unplugged */
+	set_state(p_dis, EV_UNPLUGGED);
+	return 0;
+}
+
+/*============================================================================*/
+/* bslScalerGet                                                       */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_scaler_get
+(
+    unit_select_t		      tx_unit,
+    bsl_scaler_diag_t  *p_scaler_diag
+)
+{
+	hdmi_txobject_t *p_dis;     /* Pointer to Device Instance Structure */
+	error_code_t   err;        /* Error code */
+	u8           reg_val;     /* Register value */
+
+	/* Check unit parameter and point to its object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)p_scaler_diag; /* else not referenced */
+	(void)reg_val; /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check remaining parameters */
+	RETIF_BADPARAM(p_scaler_diag == (bsl_scaler_diag_t *)0)
+
+	/* Read from dummy register to update MAX_BUFFILL_P registers */
+	err = get_hw_register(p_dis, E_REG_P01_SC_SAMPLE_BUFFILL_R, &reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Read the 16-bit MAX_BUFFILL_P register pair and copy to pScalerDiag */
+	err = get_hw_register(p_dis, E_REG_P01_SC_MAX_BUFFILL_P_0_R, &reg_val);
+	RETIF_REG_FAIL(err)
+	p_scaler_diag->max_buffill_p = reg_val;
+	err = get_hw_register(p_dis, E_REG_P01_SC_MAX_BUFFILL_P_1_R, &reg_val);
+	RETIF_REG_FAIL(err)
+	p_scaler_diag->max_buffill_p |= ((u16)reg_val << 8);
+
+	/* Read the 16-bit MAX_BUFFILL_D register pair and copy to pScalerDiag */
+	err = get_hw_register(p_dis, E_REG_P01_SC_MAX_BUFFILL_D_0_R, &reg_val);
+	RETIF_REG_FAIL(err)
+	p_scaler_diag->max_buffill_d = reg_val;
+	err = get_hw_register(p_dis, E_REG_P01_SC_MAX_BUFFILL_D_1_R, &reg_val);
+	RETIF_REG_FAIL(err)
+	p_scaler_diag->max_buffill_d |= ((u16)reg_val << 8);
+
+	/* Read from dummy register to update MAX_FIFOFILL registers */
+	err = get_hw_register(p_dis, E_REG_P01_SC_SAMPLE_FIFOFILL_R, &reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Read the 8-bit FIFOFILL registers directly to pScalerDiag */
+	err = get_hw_registers(p_dis, E_REG_P01_SC_MAX_FIFOFILL_PI_R,
+	                       &p_scaler_diag->max_fifofill_pi, 7);
+	return err;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslScalerGetMode                                                   */
+/*============================================================================*/
+error_code_t
+bsl_scaler_get_mode
+(
+    unit_select_t		      tx_unit,
+    bsl_sca_mode_t      *p_scaler_mode
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t   err;          /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)p_scaler_mode; /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(p_scaler_mode == NULL)
+
+	/* Set output parameter */
+	*p_scaler_mode = p_dis->sca_mode;
+	return 0;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslScalerInDisable                                                 */
+/*============================================================================*/
+error_code_t
+bsl_scaler_in_disable
+(
+    unit_select_t  tx_unit,
+    bool            b_disable
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)b_disable; /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(b_disable > true)
+
+	/* Set or clear frame_dis in the scaler Timebase Control 0 register
+	 * according to bDisable
+	 *	 */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P01_TBG_CNTRL_0_W,
+	                            e_maskreg_p01_tbg_cntrl_0_frame_dis,
+	                            (u8)b_disable);
+	return err;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslScalerSetCoeffs                                                 */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_scaler_set_coeffs
+(
+    unit_select_t        tx_unit,
+    bsl_sca_lut_t   lut_sel,
+    u8                *p_vs_lut
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)lut_sel; /* else not referenced */
+	(void)p_vs_lut; /* else not referenced */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(lut_sel >= HDMITX_SCALUT_INVALID)
+
+	if(lut_sel == HDMITX_SCALUT_USE_VSLUT) {
+		/* Table pointer must be valid here */
+		RETIF(p_vs_lut == NULL, ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Set LUT coefficient table */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P01_SC_VS_LUT_0_W,
+		                       p_vs_lut,
+		                       HDMITX_VSLUT_COEFF_NUM);
+		RETIF_REG_FAIL(err)
+	} else {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_SC_VIDFORMAT_W,
+		                            e_maskreg_p01_sc_vidformat_lut_sel,
+		                            (u8)lut_sel);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslScalerSetFieldOrder                                             */
+/*============================================================================*/
+error_code_t
+bsl_scaler_set_field_order
+(
+    unit_select_t      tx_unit,
+    bsl_int_ext_t top_ext,
+    bsl_int_ext_t de_ext,
+    bsl_top_sel_t top_sel,
+    bsl_top_tgl_t top_tgl
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)top_ext; /* else is declared but not used */
+	(void)de_ext;  /* else is declared but not used */
+	(void)top_sel; /* else is declared but not used */
+	(void)top_tgl; /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(top_ext > HDMITX_INTEXT_NO_CHANGE)
+	RETIF_BADPARAM(de_ext  > HDMITX_INTEXT_NO_CHANGE)
+	RETIF_BADPARAM(top_sel > HDMITX_TOPSEL_NO_CHANGE)
+	RETIF_BADPARAM(top_tgl > HDMITX_TOPTGL_NO_CHANGE)
+
+	/* Set each optional parameter */
+	if(top_ext != HDMITX_INTEXT_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_top_ext,
+		                            (u8)top_ext);
+		RETIF_REG_FAIL(err)
+	}
+	if(de_ext != HDMITX_INTEXT_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_de_ext,
+		                            (u8)de_ext);
+		RETIF_REG_FAIL(err)
+	}
+	if(top_sel != HDMITX_TOPSEL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_top_sel,
+		                            (u8)top_sel);
+		RETIF_REG_FAIL(err)
+	}
+	if(top_tgl != HDMITX_TOPTGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_top_tgl,
+		                            (u8)top_tgl);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslScalerSetFine                                                   */
+/*============================================================================*/
+error_code_t
+bsl_scaler_set_fine
+(
+    unit_select_t  tx_unit,
+    u16          u_ref_pix,
+    u16          u_ref_line
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)u_ref_pix;  /* else is declared but not used */
+	(void)u_ref_line; /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(u_ref_pix  >= HDMITX_SCALER_FINE_PIXEL_INVALID)
+	RETIF_BADPARAM(u_ref_line >= HDMITX_SCALER_FINE_LINE_INVALID)
+
+	if(u_ref_pix < HDMITX_SCALER_FINE_PIXEL_NO_CHANGE) {
+		err = set_hw_register_msb_lsb(p_dis, E_REG_P01_REFPIX_MSB_W, u_ref_pix);
+		RETIF_REG_FAIL(err)
+	}
+	if(u_ref_line < HDMITX_SCALER_FINE_LINE_NO_CHANGE) {
+		err = set_hw_register_msb_lsb(p_dis, E_REG_P01_REFLINE_MSB_W, u_ref_line);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslScalerSetSync                                                   */
+/*============================================================================*/
+error_code_t
+bsl_scaler_set_sync
+(
+    unit_select_t      tx_unit,
+    bsl_vs_meth_t method,
+    bsl_vs_once_t once
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	(void)method; /* else is declared but not used */
+	(void)once;   /* else is declared but not used */
+	return ERR_HDMI_NOT_SUPPORTED;
+#else
+	/* Check if this device has a Scaler */
+	RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+	      ERR_HDMI_NOT_SUPPORTED)
+
+	/* Check parameters */
+	RETIF_BADPARAM(method >= HDMITX_VSMETH_INVALID)
+	RETIF_BADPARAM(once   >= HDMITX_VSONCE_INVALID)
+
+	/* Set each optional parameter */
+	if(method != HDMITX_VSMETH_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_sync_mthd,
+		                            (u8)method);
+		RETIF_REG_FAIL(err)
+	}
+	if(once != HDMITX_VSONCE_NO_CHANGE) {
+		/* Must be last register set */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_TBG_CNTRL_0_W,
+		                            e_maskreg_p01_tbg_cntrl_0_sync_once,
+		                            (u8)once);
+		RETIF_REG_FAIL(err)
+		if(once == HDMITX_VSONCE_ONCE) {
+			/* Toggle output Sync Once flag for settings to take effect */
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P01_TBG_CNTRL_0_W,
+			                            e_maskreg_p01_tbg_cntrl_0_sync_once,
+			                            (u8)HDMITX_VSONCE_EACH_FRAME);
+			RETIF_REG_FAIL(err)
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P01_TBG_CNTRL_0_W,
+			                            e_maskreg_p01_tbg_cntrl_0_sync_once,
+			                            (u8)HDMITX_VSONCE_ONCE);
+			RETIF_REG_FAIL(err)
+		}
+	}
+	return 0;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslSwGetVersion                                                    */
+/*============================================================================*/
+error_code_t
+bsl_sw_get_version
+(
+    p_swversion_t      p_swversion
+)
+{
+	/* Check parameters */
+	RETIF_BADPARAM(p_swversion == (p_swversion_t)0)
+
+	/* Get the version details of the component. */
+	p_swversion->compatibility_nr = HDMITX_BSL_COMP_NUM;
+	p_swversion->major_version_nr  = HDMITX_BSL_MAJOR_VER;
+	p_swversion->minor_version_nr  = HDMITX_BSL_MINOR_VER;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslSysTimerWait                                                    */
+/*============================================================================*/
+error_code_t
+bsl_sys_timer_wait
+(
+    unit_select_t      tx_unit,
+    u16              wait_ms
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return if this device timer is not set up */
+	RETIF(!p_dis->sys_func_timer, ERR_HDMI_NOT_INITIALIZED)
+
+	/* Wait for the requested time */
+	p_dis->sys_func_timer(wait_ms);
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslTmdsSetOutputs                                                  */
+/*============================================================================*/
+error_code_t
+bsl_tmds_set_outputs
+(
+    unit_select_t          tx_unit,
+    bsl_tmds_out_t    tmds_out
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(tmds_out >= HDMITX_TMDSOUT_INVALID)
+
+	/* Set the TMDS output mode */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_BUFFER_OUT_RW,
+	                            e_maskreg_p02_buffer_out_srl_force,
+	                            (u8)tmds_out);
+	return err;
+}
+
+/*============================================================================*/
+/* bslTmdsSetSerializer                                               */
+/*============================================================================*/
+error_code_t
+bsl_tmds_set_serializer
+(
+    unit_select_t  tx_unit,
+    u8           u_phase2,
+    u8           u_phase3
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(u_phase2 >= HDMITX_TMDSPHASE_INVALID)
+	RETIF_BADPARAM(u_phase3 >= HDMITX_TMDSPHASE_INVALID)
+
+	/* Set the serializer phase 2 & 3 counts */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_SERIALIZER_RW,
+	                            e_maskreg_p02_serializer_srl_phase2,
+	                            u_phase2);
+	RETIF_REG_FAIL(err)
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_SERIALIZER_RW,
+	                            e_maskreg_p02_serializer_srl_phase3,
+	                            u_phase3);
+	return err;
+}
+
+/*============================================================================*/
+/* bslTestSetPattern                                                  */
+/*============================================================================*/
+error_code_t
+bsl_test_set_pattern
+(
+    unit_select_t           tx_unit,
+    bsl_test_pattern_t pattern
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t *p_dis;
+	error_code_t     err;						/* Error code */
+	u8             service_mode;				/* Register value */
+	u8             bars8;					/* Register value */
+	u8			  buf[MATRIX_PRESET_SIZE];	/* Temp buffer */
+	u8			  i;						/* Loop index */
+	u8			  hbl_off;					/* FB: define hbl offset*/
+	u8			  sc_in_fmt = 0;				/* Scaler input format */
+	u8			  sc_out_fmt = 0;				/* Scaler output format */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check pattern parameters */
+	switch(pattern) {
+	case HDMITX_PATTERN_CBAR4:
+		service_mode = 1;
+		bars8 = 0;
+		break;
+	case HDMITX_PATTERN_BLUE:
+	case HDMITX_PATTERN_CBAR8:
+		service_mode = 1;
+		bars8 = 1;
+		break;
+	case HDMITX_PATTERN_OFF:
+		service_mode = 0;
+		bars8 = 0;
+		break;
+	default:
+		return ERR_HDMI_BAD_PARAMETER;
+	}
+
+	if(service_mode) {
+		/* if pattern is on, register is already saved */
+		if(!p_dis->prev_pattern) {
+			/*  The kBypassColourProc registers are saved in bslTDA9984VideoSetInOut API */
+			/* Bypass up/down sampler and matrix for RGB colourbars */
+			set_hw_register_field_table(p_dis, &k_bypass_colour_proc[0]);
+
+			/* disable scaler blanking if necessary */
+			if(p_dis->sca_mode == HDMITX_SCAMODE_ON) {
+				/* remove blanking */
+				err = set_hw_register(p_dis, E_REG_P00_HBL_OFFSET_START_W, 0);
+				RETIF_REG_FAIL(err)
+			}
+		}
+		if(pattern == HDMITX_PATTERN_BLUE) {  /* blue screen pattern */
+
+			/* To create blue screen, we use the internal color bar 8 on which we apply a matrix to change it to blue */
+			/* Set the first block byte separately, as it is shadowed and can't
+			 * be set by setHwRegisters */
+
+			/* Set the first block byte separately, as it is shadowed and can't
+			 * be set by setHwRegisters */
+			err = set_hw_register(p_dis,
+			                      E_REG_P00_MAT_CONTRL_W,
+			                      matrix_coeff_blue_screen[p_dis->vout_mode][0]);
+			RETIF_REG_FAIL(err)
+
+			for(i = 0; i < MATRIX_PRESET_SIZE; i++) {
+				buf[i] = matrix_coeff_blue_screen[p_dis->vout_mode][i];
+			}
+
+			/* Set the rest of the block */
+			err = set_hw_registers(p_dis,
+			                       E_REG_P00_MAT_OI1_MSB_W,
+			                       &buf[1],
+			                       MATRIX_PRESET_SIZE - 1);
+			RETIF_REG_FAIL(err)
+
+			if(p_dis->vout_mode == HDMITX_VOUTMODE_YUV422) {
+				/* pattern is 444 -> convert to 422 */
+				err = set_hw_register_field(p_dis,
+				                            E_REG_P00_HVF_CNTRL_1_W,
+				                            e_maskreg_p00_hvf_cntrl_1_for,
+				                            1);
+			}
+
+			p_dis->prev_bluescreen = true;
+		} else { /* colour bars patterns */
+			/* Set number of colour bars */
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P00_HVF_CNTRL_0_W,
+			                            e_maskreg_p00_hvf_cntrl_0_rwb,
+			                            bars8);
+			RETIF_REG_FAIL(err)
+
+			/* Bypass up/down sampler and matrix for RGB colourbars */
+			set_hw_register_field_table(p_dis, &k_bypass_colour_proc[0]);
+		}
+		p_dis->prev_pattern = true;
+	} else { /* serviceMode == 0 */
+		if(p_dis->prev_bluescreen) {
+			/* Restore the previous Matrix when pattern goes off */
+			err = bsl_matrix_set_conversion(tx_unit, p_dis->vin_fmt, p_dis->vin_mode, p_dis->vout_fmt, p_dis->vout_mode, p_dis->dvi_vqr);
+			RETIF_REG_FAIL(err)
+
+			/* Restore the correct output sampler mode */
+			err = set_sampling(p_dis);
+			RETIF(err != 0, err)
+
+			p_dis->prev_bluescreen = false;
+		}
+
+		/* Restore kBypassColourProc registers when pattern goes off */
+		set_hw_register(p_dis, E_REG_P00_MAT_CONTRL_W,  g_mat_contrl[tx_unit]);
+		set_hw_register(p_dis, E_REG_P00_HVF_CNTRL_0_W, g_hvf_cntrl0[tx_unit]);
+		set_hw_register(p_dis, E_REG_P00_HVF_CNTRL_1_W, g_hvf_cntrl1[tx_unit]);
+		p_dis->prev_pattern = false;
+
+		/* restore scaler blanking if necessary */
+		if(p_dis->sca_mode == HDMITX_SCAMODE_ON) {
+			/* Look up scaler register formats from table */
+			sc_in_fmt = SCIO2SCIN(k_vfmt_to_regvfmt_scio_tv[p_dis->vin_fmt]);
+			sc_out_fmt = SCIO2SCOUT(k_vfmt_to_regvfmt_scio_tv[p_dis->vout_fmt]);
+
+			/* Look-up blanking re-insertion */
+			hbl_off = k_scl_add_blk_pix[sc_in_fmt][sc_out_fmt];
+			err = set_hw_register(p_dis, E_REG_P00_HBL_OFFSET_START_W, hbl_off);
+			RETIF_REG_FAIL(err)
+			/* clean green lines for none RGB output */
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P00_HVF_CNTRL_1_W,
+			                            e_maskreg_p00_hvf_cntrl_1_yuvblk,
+			                            k_scl_clear_blk_pix[p_dis->vout_mode]);
+			RETIF_REG_FAIL(err)
+		}
+	}
+
+	/* Set Service Mode on or off */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_HVF_CNTRL_0_W,
+	                            e_maskreg_p00_hvf_cntrl_0_sm,
+	                            service_mode);
+
+	return err;
+}
+
+/*============================================================================*/
+/* bslTestSetMode                                                     */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_test_set_mode
+(
+    unit_select_t          tx_unit,
+    bsl_test_mode_t   test_mode,
+    bsl_test_state_t  test_state
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+	/* Register used to activate a test */
+	u16            test_reg = E_REG_P00_VIP_CNTRL_4_W;
+	/* Register bitfield mask used */
+	u8             test_mask = e_maskreg_p00_vip_cntrl_4_tst_pat;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(test_mode  >= HDMITX_TESTMODE_INVALID)
+	RETIF_BADPARAM(test_state >= HDMITX_TESTSTATE_INVALID)
+
+	/* Set the mode selected by testMode to the state indicated by testState */
+	switch(test_mode) {
+	case HDMITX_TESTMODE_PAT:
+		test_reg  = E_REG_P00_VIP_CNTRL_4_W;
+		test_mask = e_maskreg_p00_vip_cntrl_4_tst_pat;
+		break;
+	case HDMITX_TESTMODE_656:
+		test_reg  = E_REG_P00_VIP_CNTRL_4_W;
+		test_mask = e_maskreg_p00_vip_cntrl_4_tst_656;
+		break;
+	case HDMITX_TESTMODE_SERPHOE:
+		test_reg  = E_REG_P02_TEST1_RW;
+		test_mask = e_maskreg_p02_test1_tstserphoe;
+		break;
+	case HDMITX_TESTMODE_NOSC:
+		test_reg  = E_REG_P02_TEST1_RW;
+		test_mask = e_maskreg_p02_test1_tst_nosc;
+		break;
+	case HDMITX_TESTMODE_HVP:
+		test_reg  = E_REG_P02_TEST1_RW;
+		test_mask = e_maskreg_p02_test1_tst_hvp;
+		break;
+	case HDMITX_TESTMODE_PWD:
+		test_reg  = E_REG_P02_TEST2_RW;
+		test_mask = e_maskreg_p02_test2_pwd1v8;
+		break;
+	case HDMITX_TESTMODE_DIVOE:
+		test_reg  = E_REG_P02_TEST2_RW;
+		test_mask = e_maskreg_p02_test2_divtestoe;
+		break;
+	case HDMITX_TESTMODE_INVALID:
+		break;
+	}
+	err = set_hw_register_field(p_dis, test_reg, test_mask, (u8)test_state);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslVideoInSetBlanking                                              */
+/*============================================================================*/
+error_code_t
+bsl_video_in_set_blanking
+(
+    unit_select_t         tx_unit,
+    bsl_blnk_src_t   blankit_source,
+    bsl_blnk_code_t  blanking_codes
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(blankit_source >= HDMITX_BLNKSRC_INVALID)
+	RETIF_BADPARAM(blanking_codes >= HDMITX_BLNKCODE_INVALID)
+
+	/* For each parameter that is not No Change, set its register */
+	if(blankit_source != HDMITX_BLNKSRC_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_4_W,
+		                            e_maskreg_p00_vip_cntrl_4_blankit,
+		                            (u8)blankit_source);
+		RETIF_REG_FAIL(err)
+	}
+	if(blanking_codes != HDMITX_BLNKCODE_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_4_W,
+		                            e_maskreg_p00_vip_cntrl_4_blc,
+		                            (u8)blanking_codes);
+		RETIF_REG_FAIL(err)
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoInSetConfig                                                */
+/*============================================================================*/
+error_code_t
+bsl_video_in_set_config
+(
+    unit_select_t            tx_unit,
+    bsl_vin_mode_t      vin_mode,
+    bsl_pix_edge_t      sample_edge,
+    bsl_pix_rate_t      pix_rate,
+    bsl_upsample_mode_t upsample_mode
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(vin_mode      >= HDMITX_VINMODE_INVALID)
+	RETIF_BADPARAM(sample_edge   >= HDMITX_PIXEDGE_INVALID)
+	RETIF_BADPARAM(pix_rate      >= HDMITX_PIXRATE_INVALID)
+	RETIF_BADPARAM(upsample_mode >= HDMITX_UPSAMPLE_INVALID)
+
+	if(vin_mode != HDMITX_VINMODE_NO_CHANGE) {
+		switch(vin_mode) {
+		case HDMITX_VINMODE_CCIR656:
+			err = set_hw_register_field_table(p_dis, &k_vin_mode_ccir656[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		case HDMITX_VINMODE_YUV422:
+			err = set_hw_register_field_table(p_dis, &k_vin_mode_yuv422[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		case HDMITX_VINMODE_RGB444:
+		case HDMITX_VINMODE_YUV444:
+		default:
+			err = set_hw_register_field_table(p_dis, &k_vin_mode444[0]);
+			RETIF_REG_FAIL(err)
+			break;
+		}
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P02_CCIR_DIV_RW,
+		                            e_maskreg_p02_ccir_div_refdiv2,
+		                            0);
+		RETIF_REG_FAIL(err)
+		p_dis->vin_mode = vin_mode;
+	}
+	if(sample_edge != HDMITX_PIXEDGE_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_edge,
+		                            (u8)sample_edge);
+		RETIF_REG_FAIL(err)
+	}
+	if(pix_rate != HDMITX_PIXRATE_NO_CHANGE) {
+		p_dis->pix_rate = pix_rate;
+
+		if(pix_rate == HDMITX_PIXRATE_SINGLE_REPEATED) {
+
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_CCIR_DIV_RW,
+			                            e_maskreg_p02_ccir_div_refdiv2,
+			                            1);
+			RETIF_REG_FAIL(err)
+
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_SCG2_RW,
+			                            e_maskreg_p02_pll_scg2_selpllclkin,
+			                            0);
+			RETIF_REG_FAIL(err)
+
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_DE_RW,
+			                            e_maskreg_p02_pll_de_pllde_fdn,
+			                            1);
+			RETIF_REG_FAIL(err)
+
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_DE_RW,
+			                            e_maskreg_p02_pll_de_bypass_pllde,
+			                            1);
+			RETIF_REG_FAIL(err)
+		} else {
+
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_SCG2_RW,
+			                            e_maskreg_p02_pll_scg2_selpllclkin,
+			                            (u8)pix_rate);
+			RETIF_REG_FAIL(err)
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_DE_RW,
+			                            e_maskreg_p02_pll_de_bypass_pllde,
+			                            (u8)pix_rate);
+			RETIF_REG_FAIL(err)
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P02_PLL_DE_RW,
+			                            e_maskreg_p02_pll_de_pllde_fdn,
+			                            (u8)pix_rate);
+			RETIF_REG_FAIL(err)
+		}
+	}
+	if(upsample_mode != HDMITX_UPSAMPLE_NO_CHANGE) {
+		p_dis->upsample_mode = upsample_mode;
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoInSetFine                                                  */
+/*============================================================================*/
+error_code_t
+bsl_video_in_set_fine
+(
+    unit_select_t            tx_unit,
+    bsl_pix_subpkt_t    subpacket_count,
+    bsl_pix_togl_t      toggle_clk1
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(subpacket_count >= HDMITX_PIXSUBPKT_INVALID)
+	RETIF_BADPARAM(toggle_clk1     >= HDMITX_PIXTOGL_INVALID)
+
+	/* IF subpacketCount is Fix at 0/1/2/3 THEN set subpacket count register
+	 * to 0/1/2/3 and set subpacket sync register to 3
+	 *	 */
+	if(subpacket_count <= HDMITX_PIXSUBPKT_FIX_3) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_5_W,
+		                            e_maskreg_p00_vip_cntrl_5_sp_cnt,
+		                            (u8)subpacket_count);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_sp_sync,
+		                            HDMITX_PIXSUBPKT_SYNC_FIXED);
+		RETIF_REG_FAIL(err)
+	}
+	/* ELSE IF subpacketCount is Sync by Hemb/ Sync by Rising Edge DE/
+	 * Sync by Rising Edge HS THEN set the unused subpacket count to zero and
+	 * set subpacket sync register to 0/1/2
+	 *	 */
+	else if(subpacket_count != HDMITX_PIXSUBPKT_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_5_W,
+		                            e_maskreg_p00_vip_cntrl_5_sp_cnt,
+		                            HDMITX_PIXSUBPKT_FIX_0);
+		RETIF_REG_FAIL(err)
+
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_sp_sync,
+		                            (u8)(subpacket_count - HDMITX_PIXSUBPKT_SYNC_FIRST));
+		RETIF_REG_FAIL(err)
+	}
+
+	/* IF toggleClk1 is not No Change THEN set ckcase bitfield */
+	if(toggle_clk1 != HDMITX_PIXTOGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_5_W,
+		                            e_maskreg_p00_vip_cntrl_5_ckcase,
+		                            (u8)toggle_clk1);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoInSetMapping                                               */
+/*============================================================================*/
+error_code_t
+bsl_video_in_set_mapping
+(
+    unit_select_t  tx_unit,
+    u8           *p_swap_table,
+    u8           *p_mirror_table
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+	int               i;          /* Loop counter */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(p_swap_table == NULL)
+	RETIF_BADPARAM(p_mirror_table == NULL)
+	for(i = 0; i < HDMITX_VIN_PORT_MAP_TABLE_LEN; i++) {
+		RETIF_BADPARAM(p_swap_table[i] >= HDMITX_VIN_PORT_SWAP_INVALID)
+		RETIF_BADPARAM(p_mirror_table[i] >= HDMITX_VIN_PORT_MIRROR_INVALID)
+	}
+
+	/* IF pswapTable[n] is not No Change THEN set the port swap registers from
+	 * pswapTable[n]
+	 *	 */
+	for(i = 0; i < HDMITX_VIN_PORT_MAP_TABLE_LEN; i++) {
+		if(p_swap_table[0] < HDMITX_VIN_PORT_SWAP_NO_CHANGE) {
+			err = set_hw_register_field(p_dis,
+			                            k_reg_vip[i].reg,
+			                            k_reg_vip[i].mask_swap,
+			                            p_swap_table[i]);
+			RETIF_REG_FAIL(err)
+		}
+	}
+
+	/* IF pMirrorTable[n] is not No Change THEN set the port mirror registers
+	 * from pMirrorTable[n]
+	 *	 */
+	for(i = 0; i < HDMITX_VIN_PORT_MAP_TABLE_LEN; i++) {
+		if(p_mirror_table[0] < HDMITX_VIN_PORT_MIRROR_NO_CHANGE) {
+			err = set_hw_register_field(p_dis,
+			                            k_reg_vip[i].reg,
+			                            k_reg_vip[i].mask_mirror,
+			                            p_mirror_table[i]);
+			RETIF_REG_FAIL(err)
+		}
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslSetVideoPortConfig                                              */
+/*============================================================================*/
+error_code_t
+bsl_set_video_port_config
+(
+    unit_select_t  tx_unit,
+    u8			*p_ena_video_port_table,
+    u8			*p_gnd_video_port_table
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(p_ena_video_port_table == NULL)
+	RETIF_BADPARAM(p_gnd_video_port_table == NULL)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_ENA_VP_0_RW,
+	                      p_ena_video_port_table[0]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_ENA_VP_1_RW,
+	                      p_ena_video_port_table[1]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_ENA_VP_2_RW,
+	                      p_ena_video_port_table[2]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_GND_VP_0_RW,
+	                      p_gnd_video_port_table[0]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_GND_VP_1_RW,
+	                      p_gnd_video_port_table[1]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_GND_VP_2_RW,
+	                      p_gnd_video_port_table[2]);
+	RETIF_REG_FAIL(err)
+
+	return 0;
+#else /* TMFL_TDA9981_SUPPORT */
+	(void)p_ena_video_port_table;
+	(void)p_gnd_video_port_table;
+	return ERR_HDMI_NOT_SUPPORTED;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslSetAudioPortConfig                                              */
+/*============================================================================*/
+error_code_t
+bsl_set_audio_port_config
+(
+    unit_select_t  tx_unit,
+    u8			*p_ena_audio_port_table,
+    u8			*p_gnd_audio_port_table
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(p_ena_audio_port_table == NULL)
+	RETIF_BADPARAM(p_gnd_audio_port_table == NULL)
+
+#ifdef TMFL_TDA9981_SUPPORT
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_ENA_AP_RW,
+	                      p_ena_audio_port_table[0]);
+	RETIF_REG_FAIL(err)
+
+	err = set_hw_register(p_dis,
+	                      E_REG_P00_GND_AP_RW,
+	                      p_gnd_audio_port_table[0]);
+	RETIF_REG_FAIL(err)
+
+	return 0;
+#else /* TMFL_TDA9981_SUPPORT */
+	(void)p_ena_audio_port_table;
+	(void)p_gnd_audio_port_table;
+	return ERR_HDMI_NOT_SUPPORTED;
+#endif /* TMFL_TDA9981_SUPPORT */
+}
+
+/*============================================================================*/
+/* bslVideoInSetSyncAuto                                              */
+/*============================================================================*/
+error_code_t
+bsl_video_in_set_sync_auto
+(
+    unit_select_t            tx_unit,
+    bsl_sync_source_t   sync_source,
+    bsl_vid_fmt_t       vin_fmt,
+    bsl_vin_mode_t      vin_mode
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+	u8             reg_vin_fmt;  /* Video i/p fmt value used for comparison */
+	u8             embedded;   /* Register value */
+	u8             sync_method; /* Sync method */
+	u8             toggle_v;    /* V toggle */
+	u8             toggle_h;    /* H toggle */
+	u8             toggle_x;    /* X toggle */
+	u16            u_ref_pix;    /* Output refpix */
+	u16            u_ref_line;   /* Output refline */
+	bsl_vid_fmt_t  vin_fmt_index; /* Index in tab kVfmtToRegvfmt_TV*/
+	u8             reg_vin_fmt_no_reg;
+	u8             reg_val;
+#ifdef FORMAT_PC
+	u8             reg_vin_fmt_pc;
+#endif /* FORMAT_PC */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters - syncSource must be specified */
+	RETIF_BADPARAM(sync_source   >= HDMITX_SYNCSRC_NO_CHANGE)
+
+#ifdef FORMAT_PC
+	RETIF_BADPARAM(vin_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM((vin_fmt > HDMITX_VFMT_TV_MAX) && (vin_fmt < HDMITX_VFMT_PC_MIN))
+	RETIF_BADPARAM(vin_fmt       > HDMITX_VFMT_PC_MAX)
+#else /* FORMAT_PC */
+	/*FORMAT TV only*/
+	RETIF_BADPARAM(vin_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vin_fmt       > HDMITX_VFMT_TV_MAX)
+#endif /* FORMAT_PC */
+
+	vin_fmt_index = vin_fmt;
+#ifdef FORMAT_PC
+	if(vin_fmt_index > HDMITX_VFMT_PC_MIN) {
+		vin_fmt_index = (bsl_vid_fmt_t)(vin_fmt_index - HDMITX_VFMT_PC_MIN + HDMITX_VFMT_TV_MAX + 1);
+	}
+#endif /* FORMAT_PC */
+
+	/* Look up the VIDFORMAT register format from the register format table */
+	reg_vin_fmt = k_vfmt_to_regvfmt_tv[vin_fmt_index];
+	/* Quit if the input format does not map to the register format */
+	RETIF_BADPARAM(reg_vin_fmt == E_REGVFMT_INVALID)
+
+	/* Select values according to sync source */
+	embedded = 0;
+	switch(sync_source) {
+	case HDMITX_SYNCSRC_EXT_VS:
+		sync_method = 0;
+		toggle_v    = k_regvfmt_to_vtoggle[reg_vin_fmt];
+		toggle_h    = k_regvfmt_to_htoggle[reg_vin_fmt];
+		toggle_x    = 0;
+		u_ref_pix    = k_vid_fmt_to_refpix_refline[reg_vin_fmt].ref_pix_vs_sync;
+		u_ref_line   = k_vid_fmt_to_refpix_refline[reg_vin_fmt].ref_line_vs_sync;
+		break;
+	case HDMITX_SYNCSRC_EMBEDDED:
+		embedded++;
+		/* fall thru */
+	case HDMITX_SYNCSRC_EXT_VREF:
+	default:
+		sync_method = 1;
+		toggle_v    = 1;
+		toggle_h    = 1;
+		toggle_x    = 1;
+		u_ref_pix    = k_vid_fmt_to_refpix_refline[reg_vin_fmt].ref_pix_other_sync;
+		u_ref_line   = k_vid_fmt_to_refpix_refline[reg_vin_fmt].ref_line_other_sync;
+		break;
+	}
+	/* Table has +1 added to refpix values which are not needed in
+	 *	   RGB444, YUV444 and YUV422 modes, but +2 is required in those cases */
+	if(vin_mode != HDMITX_VINMODE_CCIR656) {
+		u_ref_pix = u_ref_pix + 2;
+	}
+
+	/* Set embedded sync */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_VIP_CNTRL_3_W,
+	                            e_maskreg_p00_vip_cntrl_3_emb,
+	                            embedded);
+	RETIF_REG_FAIL(err)
+
+	/* Set sync method */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_TBG_CNTRL_0_W,
+	                            e_maskreg_p00_tbg_cntrl_0_sync_mthd,
+	                            sync_method);
+	RETIF_REG_FAIL(err)
+
+	/* Set VH toggle */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_VIP_CNTRL_3_W,
+	                            e_maskreg_p00_vip_cntrl_3_v_tgl,
+	                            toggle_v);
+	RETIF_REG_FAIL(err)
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_VIP_CNTRL_3_W,
+	                            e_maskreg_p00_vip_cntrl_3_h_tgl,
+	                            toggle_h);
+	RETIF_REG_FAIL(err)
+
+	/* Set X toggle */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_VIP_CNTRL_3_W,
+	                            e_maskreg_p00_vip_cntrl_3_x_tgl,
+	                            toggle_x);
+	RETIF_REG_FAIL(err)
+
+	if((vin_fmt >= HDMITX_VFMT_TV_NO_REG_MIN)
+	   && (vin_fmt < HDMITX_VFMT_PC_MIN)) {
+		RETIF_BADPARAM(reg_vin_fmt > E_REGVFMT_NUM_TV)
+
+		/* Check parameters */
+		reg_vin_fmt_no_reg = (u8)(reg_vin_fmt - E_REGVFMT_FIRST_TV_NO_REG);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].n_pix;
+		err = set_hw_register(p_dis, E_REG_P00_NPIX_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].n_pix >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_NPIX_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].n_line;
+		err = set_hw_register(p_dis, E_REG_P00_NLINE_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].n_line >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_NLINE_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_line_start;
+		err = set_hw_register(p_dis, E_REG_P00_VS_LINE_STRT_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_pix_start;
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_STRT_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_pix_start >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_STRT_1_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_line_end;
+		err = set_hw_register(p_dis, E_REG_P00_VS_LINE_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_pix_end;
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].vs_pix_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_END_1_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].hs_start;
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_START_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].hs_start >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_START_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].hs_end;
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_STOP_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].hs_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_STOP_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].v_win_start;
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_START_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].v_win_end;
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].v_win_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_END_1_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].de_start;
+		err = set_hw_register(p_dis, E_REG_P00_DE_START_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].de_start >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_DE_START_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_format_param[reg_vin_fmt_no_reg].de_end;
+		err = set_hw_register(p_dis, E_REG_P00_DE_STOP_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_format_param[reg_vin_fmt_no_reg].de_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_DE_STOP_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+	}
+
+#ifdef FORMAT_PC
+
+	if(vin_fmt > HDMITX_VFMT_PC_MIN) {
+
+		/* Check parameters */
+		RETIF_BADPARAM(reg_vin_fmt < E_REGVFMT_NUM_TV)
+
+		reg_vin_fmt_pc = (u8)(reg_vin_fmt - E_REGVFMT_FIRST_PC_FORMAT);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].n_pix;
+		err = set_hw_register(p_dis, E_REG_P00_NPIX_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].n_pix >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_NPIX_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].n_line;
+		err = set_hw_register(p_dis, E_REG_P00_NLINE_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].n_line >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_NLINE_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].vs_line_start;
+		err = set_hw_register(p_dis, E_REG_P00_VS_LINE_STRT_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].vs_pix_start;
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_STRT_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].vs_line_end;
+		err = set_hw_register(p_dis, E_REG_P00_VS_LINE_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].vs_pix_end;
+		err = set_hw_register(p_dis, E_REG_P00_VS_PIX_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].hs_start;
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_START_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].hs_end;
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_STOP_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].hs_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_HS_PIX_STOP_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].v_win_start;
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_START_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].v_win_end;
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_END_1_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].v_win_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_VWIN_END_1_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].de_start;
+		err = set_hw_register(p_dis, E_REG_P00_DE_START_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].de_start >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_DE_START_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].de_end;
+		err = set_hw_register(p_dis, E_REG_P00_DE_STOP_LSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = (u8)(k_vid_fmt_to_pcformat_param[reg_vin_fmt_pc].de_end >> 8);
+		err = set_hw_register(p_dis, E_REG_P00_DE_STOP_MSB_W, reg_val);
+		RETIF_REG_FAIL(err);
+
+		reg_val = DEPTH_COLOR_PC;
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_1_W,
+		                            e_maskreg_p00_hvf_cntrl_1_pad,
+		                            reg_val);
+
+		RETIF_REG_FAIL(err);
+	}
+#endif /* FORMAT_PC */
+
+	/* Set refpix, refline */
+	/* tweak for gplugD */
+	u_ref_pix = 0x99;
+	u_ref_line = 0x07;
+	err = set_hw_register_msb_lsb(p_dis, E_REG_P00_REFPIX_MSB_W, u_ref_pix);
+	RETIF_REG_FAIL(err)
+	err = set_hw_register_msb_lsb(p_dis, E_REG_P00_REFLINE_MSB_W, u_ref_line);
+	return err;
+}
+
+/*============================================================================*/
+/* bslVideoInSetSyncManual                                            */
+/*============================================================================*/
+
+error_code_t
+bsl_video_in_set_sync_manual
+(
+    unit_select_t            tx_unit,
+    bsl_sync_source_t   sync_source,
+    bsl_vs_meth_t       sync_method,
+    bsl_pix_togl_t      toggle_v,
+    bsl_pix_togl_t      toggle_h,
+    bsl_pix_togl_t      toggle_x,
+    u16                    u_ref_pix,
+    u16                    u_ref_line
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+	u8             embedded;   /* Register value */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(sync_source   >= HDMITX_SYNCSRC_INVALID)
+	RETIF_BADPARAM(sync_method   >= HDMITX_VSMETH_INVALID)
+	RETIF_BADPARAM(toggle_v      >= HDMITX_PIXTOGL_INVALID)
+	RETIF_BADPARAM(toggle_h      >= HDMITX_PIXTOGL_INVALID)
+	RETIF_BADPARAM(toggle_x      >= HDMITX_PIXTOGL_INVALID)
+	RETIF_BADPARAM(u_ref_pix  >= HDMITX_VOUT_FINE_PIXEL_INVALID)
+	RETIF_BADPARAM(u_ref_line >= HDMITX_VOUT_FINE_LINE_INVALID)
+
+	if(sync_source != HDMITX_SYNCSRC_NO_CHANGE) {
+		if(sync_source == HDMITX_SYNCSRC_EMBEDDED) {
+			embedded = 1;
+		} else {
+			embedded = 0;
+		}
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_emb,
+		                            embedded);
+		RETIF_REG_FAIL(err)
+	}
+	if(sync_method != HDMITX_VSMETH_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_0_W,
+		                            e_maskreg_p00_tbg_cntrl_0_sync_mthd,
+		                            (u8)sync_method);
+		RETIF_REG_FAIL(err)
+	}
+	if(toggle_v != HDMITX_PIXTOGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_v_tgl,
+		                            (u8)toggle_v);
+		RETIF_REG_FAIL(err)
+	}
+	if(toggle_h != HDMITX_PIXTOGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_h_tgl,
+		                            (u8)toggle_h);
+		RETIF_REG_FAIL(err)
+	}
+	if(toggle_x != HDMITX_PIXTOGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_VIP_CNTRL_3_W,
+		                            e_maskreg_p00_vip_cntrl_3_x_tgl,
+		                            (u8)toggle_x);
+		RETIF_REG_FAIL(err)
+	}
+	if(u_ref_pix < HDMITX_VOUT_FINE_PIXEL_NO_CHANGE) {
+		err = set_hw_register_msb_lsb(p_dis, E_REG_P00_REFPIX_MSB_W, u_ref_pix);
+		RETIF_REG_FAIL(err)
+	}
+	if(u_ref_line < HDMITX_VOUT_FINE_LINE_NO_CHANGE) {
+		err = set_hw_register_msb_lsb(p_dis, E_REG_P00_REFLINE_MSB_W, u_ref_line);
+		RETIF_REG_FAIL(err)
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoOutDisable                                                 */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_video_out_disable
+(
+    unit_select_t  tx_unit,
+    bool            b_disable
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(b_disable > true)
+
+	/* Set or clear frame_dis in the scaler Timebase Control 0 register
+	 * according to bDisable
+	 *	 */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_TBG_CNTRL_0_W,
+	                            e_maskreg_p00_tbg_cntrl_0_frame_dis,
+	                            (u8)b_disable);
+	if(b_disable) {
+		set_state(p_dis, EV_OUTDISABLE);
+	}
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslVideoOutSetConfig                                               */
+/*============================================================================*/
+error_code_t
+bsl_video_out_set_config
+(
+    unit_select_t            tx_unit,
+    bsl_sink_type_t     sink_type,
+    bsl_vout_mode_t     vout_mode,
+    bsl_vout_prefil_t   pre_filter,
+    bsl_vout_yuv_blnk_t  yuv_blank,
+    bsl_vout_qrange_t   quantization
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+	u8             reg_val;     /* Register value */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(sink_type     >= HDMITX_SINK_INVALID)
+	RETIF_BADPARAM(vout_mode     >= HDMITX_VOUTMODE_INVALID)
+	RETIF_BADPARAM(pre_filter    >= HDMITX_VOUT_PREFIL_INVALID)
+	RETIF_BADPARAM(yuv_blank     >= HDMITX_VOUT_YUV_BLNK_INVALID)
+	RETIF_BADPARAM(quantization >= HDMITX_VOUT_QRANGE_INVALID)
+
+	(void)DUMMY_ACCESS(quantization);
+
+	if(sink_type == HDMITX_SINK_EDID) {
+		if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+			/* EDID has not been read so assume simplest sink */
+			p_dis->sink_type = HDMITX_SINK_DVI;
+		} else {
+			/* EDID has been read so set sink to the type that was read */
+			p_dis->sink_type = p_dis->edid_sink_type;
+		}
+	} else {
+		/* Set demanded sink type */
+		p_dis->sink_type = sink_type;
+	}
+
+	/* Is DVI sink required? */
+	if(p_dis->sink_type == HDMITX_SINK_DVI) {
+		/* Mute the audio FIFO */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_AIP_CNTRL_0_RW,
+		                            e_maskreg_p11_aip_cntrl_0_rst_fifo,
+		                            1);
+		RETIF_REG_FAIL(err)
+
+		/* Force RGB mode for DVI sink */
+		vout_mode = HDMITX_VOUTMODE_RGB444;
+
+		/* Set HDMI HDCP mode off for DVI */
+		err = set_hw_register_field_table(p_dis, &k_vout_hdcp_off[0]);
+		RETIF_REG_FAIL(err)
+
+		reg_val = 0;
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_ENC_CNTRL_RW,
+		                            e_maskreg_p11_enc_cntrl_ctl_code,
+		                            reg_val);
+		RETIF_REG_FAIL(err)
+	} else {
+		/* Unmute the audio FIFO */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_AIP_CNTRL_0_RW,
+		                            e_maskreg_p11_aip_cntrl_0_rst_fifo,
+		                            0);
+		RETIF_REG_FAIL(err)
+
+		/* Set HDMI HDCP mode on for HDMI */
+		/* Also sets E_MASKREG_P11_ENC_CNTRL_ctl_code */
+		err = set_hw_register_field_table(p_dis, &k_vout_hdcp_on[0]);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* For each parameter that is not No Change, set its register */
+	if(vout_mode != HDMITX_VOUTMODE_NO_CHANGE) {
+		/* Save the output mode for later use by the matrix & downsampler */
+		p_dis->vout_mode = vout_mode;
+	}
+	if(pre_filter < HDMITX_VOUT_PREFIL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_0_W,
+		                            e_maskreg_p00_hvf_cntrl_0_prefil,
+		                            (u8)pre_filter);
+		RETIF_REG_FAIL(err)
+	}
+	if(yuv_blank < HDMITX_VOUT_YUV_BLNK_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_1_W,
+		                            e_maskreg_p00_hvf_cntrl_1_yuvblk,
+		                            (u8)yuv_blank);
+		RETIF_REG_FAIL(err)
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoOutSetSync                                                 */
+/*============================================================================*/
+error_code_t
+bsl_video_out_set_sync
+(
+    unit_select_t          tx_unit,
+    bsl_vs_src_t      src_h,
+    bsl_vs_src_t      src_v,
+    bsl_vs_src_t      src_x,
+    bsl_vs_tgl_t      toggle,
+    bsl_vs_once_t     once
+)
+{
+	hdmi_txobject_t *p_dis;       /* Pointer to Device Instance Structure */
+	error_code_t     err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+	RETIF_BADPARAM(src_h   >= HDMITX_VSSRC_INVALID)
+	RETIF_BADPARAM(src_v   >= HDMITX_VSSRC_INVALID)
+	RETIF_BADPARAM(src_x   >= HDMITX_VSSRC_INVALID)
+	RETIF_BADPARAM(toggle >= HDMITX_VSTGL_INVALID)
+	RETIF_BADPARAM(once   >= HDMITX_VSONCE_INVALID)
+
+	/* For each parameter that is not No Change, set its register */
+	if(src_h != HDMITX_VSSRC_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_1_W,
+		                            e_maskreg_p00_tbg_cntrl_1_vhx_ext_hs,
+		                            (u8)src_h);
+		RETIF_REG_FAIL(err)
+	}
+	if(src_v != HDMITX_VSSRC_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_1_W,
+		                            e_maskreg_p00_tbg_cntrl_1_vhx_ext_vs,
+		                            (u8)src_v);
+		RETIF_REG_FAIL(err)
+	}
+	if(src_x != HDMITX_VSSRC_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_1_W,
+		                            e_maskreg_p00_tbg_cntrl_1_vhx_ext_de,
+		                            (u8)src_x);
+		RETIF_REG_FAIL(err)
+	}
+	if(toggle != HDMITX_VSTGL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_1_W,
+		                            e_maskreg_p00_tbg_cntrl_1_vh_tgl,
+		                            (u8)toggle);
+		RETIF_REG_FAIL(err)
+	}
+	if(once != HDMITX_VSONCE_NO_CHANGE) {
+		/* Must be last register set */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_0_W,
+		                            e_maskreg_p00_tbg_cntrl_0_sync_once,
+		                            (u8)once);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Toggle TMDS serialiser force flags - stability fix */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_BUFFER_OUT_RW,
+	                            e_maskreg_p02_buffer_out_srl_force,
+	                            (u8)HDMITX_TMDSOUT_FORCED0);
+	RETIF_REG_FAIL(err)
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_BUFFER_OUT_RW,
+	                            e_maskreg_p02_buffer_out_srl_force,
+	                            (u8)HDMITX_TMDSOUT_NORMAL);
+	RETIF_REG_FAIL(err)
+
+	if(once == HDMITX_VSONCE_ONCE) {
+		/* Toggle output Sync Once flag for settings to take effect */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_0_W,
+		                            e_maskreg_p00_tbg_cntrl_0_sync_once,
+		                            (u8)HDMITX_VSONCE_EACH_FRAME);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_TBG_CNTRL_0_W,
+		                            e_maskreg_p00_tbg_cntrl_0_sync_once,
+		                            (u8)HDMITX_VSONCE_ONCE);
+		RETIF_REG_FAIL(err)
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* bslVideoSetInOut                                                   */
+/*============================================================================*/
+error_code_t
+bsl_video_set_in_out
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vin_fmt,
+    bsl_sca_mode_t    sca_mode_request,
+    bsl_vid_fmt_t     vout_fmt,
+    u8                   u_pixel_repeat,
+    bsl_mat_mode_t    mat_mode,
+    bsl_vout_dbits_t  datapath_bits,
+    bsl_vqr_t        dvi_vqr
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t        *p_dis;
+	error_code_t           err;         /* Error code */
+	bsl_vid_fmt_t     sca_in_fmt;    /* Scaler input format */
+	bsl_vid_fmt_t     sca_out_fmt;   /* Scaler output format */
+	bsl_sca_mode_t    sca_mode;     /* Scaler mode */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check parameters */
+#ifdef FORMAT_PC
+	RETIF_BADPARAM(vin_fmt        < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vout_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM((vin_fmt  > HDMITX_VFMT_TV_MAX) && (vin_fmt < HDMITX_VFMT_PC_MIN))
+	RETIF_BADPARAM((vout_fmt > HDMITX_VFMT_TV_MAX) && (vout_fmt < HDMITX_VFMT_PC_MIN))
+	RETIF_BADPARAM(vin_fmt        > HDMITX_VFMT_PC_MAX)
+	RETIF_BADPARAM(vout_fmt       > HDMITX_VFMT_PC_MAX)
+#else /* FORMAT_PC */
+	/*FORMAT TV only*/
+	RETIF_BADPARAM(vin_fmt        < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vout_fmt       < HDMITX_VFMT_TV_MIN)
+	RETIF_BADPARAM(vin_fmt        > HDMITX_VFMT_TV_MAX)
+	RETIF_BADPARAM(vout_fmt       > HDMITX_VFMT_TV_MAX)
+#endif /* FORMAT_PC */
+
+	RETIF_BADPARAM(sca_mode_request >= HDMITX_SCAMODE_INVALID)
+	RETIF_BADPARAM(u_pixel_repeat   >= HDMITX_PIXREP_INVALID)
+	RETIF_BADPARAM(mat_mode        >= HDMITX_MATMODE_INVALID)
+	RETIF_BADPARAM(datapath_bits   >= HDMITX_VOUT_DBITS_INVALID)
+
+	sca_mode = sca_mode_request;
+
+#ifdef TMFL_TDA9981_SUPPORT
+	sca_mode = HDMITX_SCAMODE_OFF;
+#else /* TMFL_TDA9981_SUPPORT */
+	if(vout_fmt >= HDMITX_VFMT_TV_NO_REG_MIN) {
+		/* Disable Scaler mode for PC_FORMAT and for 24/25/30Hz formats */
+		sca_mode = HDMITX_SCAMODE_OFF;
+	}
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/* Get current input format if it must not change */
+	if(vin_fmt == HDMITX_VFMT_NO_CHANGE) {
+		RETIF(p_dis->vin_fmt == HDMITX_VFMT_NULL,
+		      ERR_HDMI_INCONSISTENT_PARAMS)
+		vin_fmt = p_dis->vin_fmt;
+	} else {
+		p_dis->vin_fmt = vin_fmt;
+	}
+
+	/* Get current output format if it must not change */
+	if(vout_fmt == HDMITX_VFMT_NO_CHANGE) {
+		RETIF(p_dis->vout_fmt == HDMITX_VFMT_NULL,
+		      ERR_HDMI_INCONSISTENT_PARAMS)
+		vout_fmt = p_dis->vout_fmt;
+	} else {
+		p_dis->vout_fmt = vout_fmt;
+	}
+	/* Force RGB mode for VGA output format */
+	if(vout_fmt == HDMITX_VFMT_TV_MIN) {
+		p_dis->vout_mode = HDMITX_VOUTMODE_RGB444;
+	}
+
+	if(p_dis->vout_mode == HDMITX_VOUTMODE_RGB444) {
+		if((p_dis->vout_fmt >= hdmitx_vfmt_02_720x480p_60hz) && (p_dis->vout_fmt <= HDMITX_VFMT_TV_MAX)) {
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P00_HVF_CNTRL_1_W,
+			                            e_maskreg_p00_hvf_cntrl_1_vqr,
+			                            (u8) HDMITX_VOUT_QRANGE_RGB_YUV);
+			RETIF_REG_FAIL(err)
+		} else { /*Format PC or VGA*/
+			err = set_hw_register_field(p_dis,
+			                            E_REG_P00_HVF_CNTRL_1_W,
+			                            e_maskreg_p00_hvf_cntrl_1_vqr,
+			                            (u8) HDMITX_VOUT_QRANGE_FS);
+			RETIF_REG_FAIL(err)
+		}
+	} else {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_1_W,
+		                            e_maskreg_p00_hvf_cntrl_1_vqr,
+		                            (u8) HDMITX_VOUT_QRANGE_YUV);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* If scaler mode is auto then set mode based on input and output format */
+	if(sca_mode != HDMITX_SCAMODE_NO_CHANGE) {
+		if(sca_mode == HDMITX_SCAMODE_AUTO) {
+			/* If both formats map to the same device output format then
+			 * the scaler can be switched off */
+			if(k_vfmt_to_regvfmt_tv[vout_fmt] == k_vfmt_to_regvfmt_tv[vin_fmt]) {
+				sca_mode = HDMITX_SCAMODE_OFF;
+			} else {
+				sca_mode = HDMITX_SCAMODE_ON;
+			}
+		}
+		sca_in_fmt  = vin_fmt;
+		if(sca_mode == HDMITX_SCAMODE_ON) {
+			sca_out_fmt = vout_fmt;
+		} else {
+			sca_out_fmt = vin_fmt;
+		}
+		err = set_scaler_format(p_dis, sca_in_fmt, sca_out_fmt, u_pixel_repeat);
+		RETIF(err != 0, err)
+	} else {
+		/* Set pixel repetition - sets pixelRepeatCount, used by setScalerFormat */
+		err = set_pixel_repeat(p_dis, vout_fmt, u_pixel_repeat);
+		RETIF(err != 0, err)
+	}
+
+	/* Set VS and optional DE */
+	err = set_de_vs(p_dis, vout_fmt);
+	RETIF(err != 0, err)
+
+	/* If matrix mode is auto then set mode based on input and output format */
+	if(mat_mode != HDMITX_MATMODE_NO_CHANGE) {
+		if(mat_mode == HDMITX_MATMODE_AUTO) {
+			err = bsl_matrix_set_conversion(tx_unit, vin_fmt,
+			                                p_dis->vin_mode, vout_fmt, p_dis->vout_mode, p_dis->dvi_vqr);
+		} else {
+			err = bsl_matrix_set_mode(tx_unit, HDMITX_MCNTRL_OFF,
+			                          HDMITX_MSCALE_NO_CHANGE);
+		}
+		RETIF(err != 0, err)
+	}
+
+	/* Set upsampler and downsampler */
+	err = set_sampling(p_dis);
+	RETIF(err != 0, err)
+
+	/* Set colour component bit depth */
+	if(datapath_bits != HDMITX_VOUT_DBITS_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_1_W,
+		                            e_maskreg_p00_hvf_cntrl_1_pad,
+		                            (u8)datapath_bits);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Save kBypassColourProc registers before pattern goes on */
+	get_hw_register(p_dis, E_REG_P00_MAT_CONTRL_W,  &g_mat_contrl[tx_unit]);
+	get_hw_register(p_dis, E_REG_P00_HVF_CNTRL_0_W, &g_hvf_cntrl0[tx_unit]);
+	get_hw_register(p_dis, E_REG_P00_HVF_CNTRL_1_W, &g_hvf_cntrl1[tx_unit]);
+
+	set_state(p_dis, EV_SETINOUT);
+	return 0;
+}
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DEFINTIONS                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/* setDeVs                                                                    */
+/*============================================================================*/
+static error_code_t
+set_de_vs
+(
+    hdmi_txobject_t    *p_dis,
+    bsl_vid_fmt_t  vout_fmt
+)
+{
+	error_code_t   err;        /* Error code */
+	u16          vs_pix_strt2; /* VS pixel number for start pulse in field 2 */
+	u8           reg_vfmt;    /* Video format value used for register */
+	bsl_vid_fmt_t  vout_fmt_index; /* Index in tab kVfmtToRegvfmt_TV*/
+
+	/* Parameters already checked by caller */
+
+	/* IF voutFmt = No Change THEN return 0 */
+	RETIF(vout_fmt == HDMITX_VFMT_NO_CHANGE, 0)
+
+	vout_fmt_index = vout_fmt;
+#ifdef FORMAT_PC
+	if(vout_fmt_index > HDMITX_VFMT_PC_MIN) {
+		vout_fmt_index = (bsl_vid_fmt_t)(vout_fmt_index - HDMITX_VFMT_PC_MIN + HDMITX_VFMT_TV_MAX + 1);
+	}
+#endif /* FORMAT_PC */
+
+	/* Quit if the output format does not map to the register format */
+	reg_vfmt = k_vfmt_to_regvfmt_tv[vout_fmt_index];
+	RETIF_BADPARAM(reg_vfmt == E_REGVFMT_INVALID)
+
+	/* DE_START & DE_STOP no longer set because N2 device no longer supported */
+
+	/* Adjust VS_PIX_STRT_2 and VS_PIX_END_2 for interlaced output formats */
+	vs_pix_strt2 = k_regvfmt_to_vs2[reg_vfmt];
+	err = set_hw_register_msb_lsb(p_dis, E_REG_P00_VS_PIX_STRT_2_MSB_W, vs_pix_strt2);
+	RETIF_REG_FAIL(err)
+	err = set_hw_register_msb_lsb(p_dis, E_REG_P00_VS_PIX_END_2_MSB_W, vs_pix_strt2);
+
+	return err;
+}
+
+/*============================================================================*/
+/* setPixelRepeat                                                             */
+/*============================================================================*/
+static error_code_t
+set_pixel_repeat
+(
+    hdmi_txobject_t    *p_dis,
+    bsl_vid_fmt_t vout_fmt,
+    u8               u_pixel_repeat
+)
+{
+	error_code_t err = 0;  /* Error code */
+	u8         reg_vfmt;      /* Video format value used for register */
+	u8         ssd;          /* Packed srl, scg and de */
+	bsl_vid_fmt_t  vout_fmt_index; /* Index in tab kVfmtToRegvfmt_TV*/
+	/* Pointer on a tab of kRegvfmtToPllSsd*/
+	u8         *tab_setting_pll_ssd = NULL;
+	/* true if TV_FORMAT with internal chip confiration  found (default) */
+	bool          b_is_tv_format;
+
+	b_is_tv_format = true;
+
+	/* IF voutFmt = No Change THEN return 0 */
+	RETIF(vout_fmt == HDMITX_VFMT_NO_CHANGE, 0)
+
+	vout_fmt_index = vout_fmt;
+#ifdef FORMAT_PC
+	if(vout_fmt_index > HDMITX_VFMT_PC_MIN) {
+		vout_fmt_index = (bsl_vid_fmt_t)(vout_fmt_index - HDMITX_VFMT_PC_MIN + HDMITX_VFMT_TV_MAX + 1);
+		b_is_tv_format = false; /* PC_FORMAT found */
+	}
+#endif /* FORMAT_PC */
+
+	/* Quit if the output format does not map to the register format */
+	reg_vfmt = k_vfmt_to_regvfmt_tv[vout_fmt_index];
+	RETIF_BADPARAM(reg_vfmt == E_REGVFMT_INVALID)
+
+#ifdef FORMAT_PC
+	if(b_is_tv_format) {
+#endif /* FORMAT_PC */
+		switch(p_dis->sca_mode) {
+		case HDMITX_SCAMODE_OFF:
+
+			switch(p_dis->vin_mode) {
+			case HDMITX_VINMODE_RGB444:
+			case HDMITX_VINMODE_YUV444:
+			case HDMITX_VINMODE_YUV422:
+
+				switch(p_dis->pix_rate) {
+				case HDMITX_PIXRATE_SINGLE:
+				case HDMITX_PIXRATE_SINGLE_REPEATED:
+					tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_off_ccir_off_dbl_edge_off;
+					break;
+
+				case HDMITX_PIXRATE_DOUBLE:
+					return ERR_HDMI_INCONSISTENT_PARAMS;
+					break;
+
+				default:
+					return ERR_HDMI_BAD_PARAMETER;
+				}
+
+				break;
+
+			case HDMITX_VINMODE_CCIR656:
+
+				switch(p_dis->pix_rate) {
+				case HDMITX_PIXRATE_SINGLE:
+				case HDMITX_PIXRATE_SINGLE_REPEATED:
+					tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_off_ccir_on_dbl_edge_off;
+					break;
+
+				case HDMITX_PIXRATE_DOUBLE:
+					tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_off_ccir_on_dbl_edge_on;
+					break;
+
+				default:
+					return ERR_HDMI_BAD_PARAMETER;
+				}
+
+				break;
+
+			default:
+				return ERR_HDMI_BAD_PARAMETER;
+			}
+
+			break;
+		case HDMITX_SCAMODE_ON:
+
+			switch(p_dis->vin_mode) {
+			case HDMITX_VINMODE_RGB444:
+			case HDMITX_VINMODE_YUV444:
+			case HDMITX_VINMODE_YUV422:
+
+				switch(p_dis->pix_rate) {
+				case HDMITX_PIXRATE_SINGLE:
+				case HDMITX_PIXRATE_SINGLE_REPEATED:
+					switch(p_dis->vin_fmt) {
+					case hdmitx_vfmt_06_720x480i_60hz:
+					case hdmitx_vfmt_07_720x480i_60hz:
+					case hdmitx_vfmt_10_720x480i_60hz:
+					case hdmitx_vfmt_11_720x480i_60hz:
+					case hdmitx_vfmt_21_720x576i_50hz:
+					case hdmitx_vfmt_22_720x576i_50hz:
+					case hdmitx_vfmt_25_720x576i_50hz:
+					case hdmitx_vfmt_26_720x576i_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_off_dbl_edge_off_interlace;
+						break;
+
+					case hdmitx_vfmt_02_720x480p_60hz:
+					case hdmitx_vfmt_03_720x480p_60hz:
+					case hdmitx_vfmt_17_720x576p_50hz:
+					case hdmitx_vfmt_18_720x576p_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_off_dbl_edge_off_progressif;
+						break;
+					default:
+						return ERR_HDMI_BAD_PARAMETER;
+					}
+
+					break;
+				case HDMITX_PIXRATE_DOUBLE:
+					break;
+				default:
+					return ERR_HDMI_BAD_PARAMETER;
+				}
+
+				break;
+
+			case HDMITX_VINMODE_CCIR656:
+
+				switch(p_dis->pix_rate) {
+				case HDMITX_PIXRATE_SINGLE:
+				case HDMITX_PIXRATE_SINGLE_REPEATED:
+					switch(p_dis->vin_fmt) {
+					case hdmitx_vfmt_06_720x480i_60hz:
+					case hdmitx_vfmt_07_720x480i_60hz:
+					case hdmitx_vfmt_10_720x480i_60hz:
+					case hdmitx_vfmt_11_720x480i_60hz:
+					case hdmitx_vfmt_21_720x576i_50hz:
+					case hdmitx_vfmt_22_720x576i_50hz:
+					case hdmitx_vfmt_25_720x576i_50hz:
+					case hdmitx_vfmt_26_720x576i_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_on_dbl_edge_off_interlace;
+						break;
+
+					case hdmitx_vfmt_02_720x480p_60hz:
+					case hdmitx_vfmt_03_720x480p_60hz:
+					case hdmitx_vfmt_17_720x576p_50hz:
+					case hdmitx_vfmt_18_720x576p_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_on_dbl_edge_off_progressif;
+						break;
+
+					default:
+						return ERR_HDMI_BAD_PARAMETER;
+					}
+
+					break;
+
+				case HDMITX_PIXRATE_DOUBLE:
+
+					switch(p_dis->vin_fmt) {
+					case hdmitx_vfmt_06_720x480i_60hz:
+					case hdmitx_vfmt_07_720x480i_60hz:
+					case hdmitx_vfmt_10_720x480i_60hz:
+					case hdmitx_vfmt_11_720x480i_60hz:
+					case hdmitx_vfmt_21_720x576i_50hz:
+					case hdmitx_vfmt_22_720x576i_50hz:
+					case hdmitx_vfmt_25_720x576i_50hz:
+					case hdmitx_vfmt_26_720x576i_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_on_dbl_edge_on_interlace;
+						break;
+
+					case hdmitx_vfmt_02_720x480p_60hz:
+					case hdmitx_vfmt_03_720x480p_60hz:
+					case hdmitx_vfmt_17_720x576p_50hz:
+					case hdmitx_vfmt_18_720x576p_50hz:
+						tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.sca_on_ccir_on_dbl_edge_on_progressif;
+						break;
+
+					default:
+						return ERR_HDMI_BAD_PARAMETER;
+					}
+
+					break;
+
+				default:
+					return ERR_HDMI_BAD_PARAMETER;
+				}
+
+				break;
+
+			default:
+				return ERR_HDMI_BAD_PARAMETER;
+			}
+
+			break;
+
+		default:
+			return ERR_HDMI_BAD_PARAMETER;
+		}
+
+		/* Check parameters */
+		RETIF_BADPARAM(reg_vfmt >= E_REGVFMT_NUM_TV)
+
+		/* Table pointer must be valid here */
+		if(tab_setting_pll_ssd) {
+			/* Set PLLs based on output format */
+			ssd = tab_setting_pll_ssd[reg_vfmt];
+		} else {
+			return ERR_HDMI_ASSERTION;
+		}
+
+#ifdef FORMAT_PC
+	} else {
+		tab_setting_pll_ssd = (u8 *)k_regvfmt_to_pll_ssd.settings_format_pc;
+
+		/* Check parameters */
+		RETIF_BADPARAM(reg_vfmt < E_REGVFMT_NUM_TV)
+
+		ssd = tab_setting_pll_ssd[reg_vfmt - E_REGVFMT_NUM_TV];
+	}
+
+#endif /* FORMAT_PC */
+
+	if(ssd < SSD_UNUSED_VALUE) {
+
+		err = set_hw_register_field(p_dis, E_REG_P02_PLL_SERIAL_2_RW,
+		                            e_maskreg_p02_pll_serial_2_srl_nosc,
+		                            SSD2SRL(ssd));
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis, E_REG_P02_PLL_SCG2_RW,
+		                            e_maskreg_p02_pll_scg2_scg_nosc,
+		                            SSD2SCG(ssd));
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis, E_REG_P02_PLL_DE_RW,
+		                            e_maskreg_p02_pll_de_pllde_nosc,
+		                            SSD2DE(ssd));
+	}
+
+	/* Set pixel repetition */
+	if(u_pixel_repeat != HDMITX_PIXREP_NO_CHANGE) {
+		if(u_pixel_repeat == HDMITX_PIXREP_DEFAULT) {
+			/* Look up default pixel repeat value for this output format */
+			u_pixel_repeat = k_regvfmt_to_pix_rep[reg_vfmt];
+		}
+
+		/* Update current pixel repetition count */
+		p_dis->pixel_repeat_count = u_pixel_repeat;
+
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P02_PLL_SERIAL_2_RW,
+		                            e_maskreg_p02_pll_serial_2_srl_pr,
+		                            u_pixel_repeat);
+		RETIF_REG_FAIL(err)
+		/* Set pixel repetition count for Repetitor module */
+		err = set_hw_register(p_dis, E_REG_P00_RPT_CNTRL_W, u_pixel_repeat);
+	}
+	return err;
+}
+
+/*============================================================================*/
+/* setSampling                                                                */
+/*============================================================================*/
+static error_code_t
+set_sampling
+(
+    hdmi_txobject_t   *p_dis
+)
+{
+	error_code_t err;          /* Error code */
+	u8         up_sample;     /* 1 if upsampler must be enabled */
+	u8         down_sample;   /* 1 if downsampler must be enabled */
+	u8         matrix_bypass; /*>0 if matrix has been bypassed */
+
+	if((p_dis->vin_mode == HDMITX_VINMODE_YUV422)
+	   || (p_dis->vin_mode == HDMITX_VINMODE_CCIR656)) {
+		if(p_dis->vout_mode == HDMITX_VOUTMODE_YUV422) {
+			/* Input 422/656, output 422 */
+			err = get_hw_register(p_dis, E_REG_P00_MAT_CONTRL_W, &matrix_bypass);
+			RETIF_REG_FAIL(err)
+			matrix_bypass &= e_maskreg_p00_mat_contrl_mat_bp;
+			/* Has matrix been bypassed? */
+			if(matrix_bypass > 0) {
+				up_sample = 0;
+				down_sample = 0;
+			} else {
+				up_sample = 1;
+				down_sample = 1;
+			}
+		} else {
+			/* Input 422/656, output not 422 */
+			up_sample = 1;
+			down_sample = 0;
+		}
+	} else {
+		if(p_dis->vout_mode == HDMITX_VOUTMODE_YUV422) {
+			/* Input not 422/656, output 422 */
+			up_sample = 0;
+			down_sample = 1;
+		} else {
+			/* Input not 422/656, output not 422 */
+			up_sample = 0;
+			down_sample = 0;
+		}
+	}
+
+	/* Check upsample mode saved by bslVideoInSetConfig */
+	if(p_dis->upsample_mode != HDMITX_UPSAMPLE_AUTO) {
+		/* Saved upsample mode overrides local one */
+		up_sample = p_dis->upsample_mode;
+	}
+
+	/* Set upsampler */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_HVF_CNTRL_0_W,
+	                            e_maskreg_p00_hvf_cntrl_0_intpol,
+	                            up_sample);
+	RETIF_REG_FAIL(err)
+
+	/* Set downsampler */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P00_HVF_CNTRL_1_W,
+	                            e_maskreg_p00_hvf_cntrl_1_for,
+	                            down_sample);
+	return err;
+}
+
+/*============================================================================*/
+/* setScalerFormat                                                            */
+/*============================================================================*/
+static error_code_t
+set_scaler_format
+(
+    hdmi_txobject_t   *p_dis,
+    bsl_vid_fmt_t vin_fmt,
+    bsl_vid_fmt_t vout_fmt,
+    u8 pixel_repeat
+)
+{
+	error_code_t err;          /* Error code */
+	u8         reg_vout_fmt;   /* Video o/p format value used for register */
+	u8         reg_vin_fmt;    /* Video i/p format value used for comparison */
+	u8         reg_val;       /* Register value */
+#ifndef TMFL_TDA9981_SUPPORT
+	u8         sc_in_fmt = 0;  /* Scaler input format */
+	u8         sc_out_fmt = 0; /* Scaler output format */
+	u16        pll_scg_n;      /* PLL scaling values */
+	u16        pll_scg_r;
+	u8		  hbl_off;		/* FB: define hbl offset*/
+
+#endif /* TMFL_TDA9981_SUPPORT */
+
+#ifdef FORMAT_PC
+	RETIF_BADPARAM(vin_fmt        > HDMITX_VFMT_PC_MAX)
+	RETIF_BADPARAM(vout_fmt        > HDMITX_VFMT_PC_MAX)
+#else
+	RETIF_BADPARAM(vin_fmt        > HDMITX_VFMT_TV_MAX)
+	RETIF_BADPARAM(vout_fmt        > HDMITX_VFMT_TV_MAX)
+#endif
+
+	/* Look up the VIDFORMAT register formats from the register format table */
+	reg_vin_fmt = k_vfmt_to_regvfmt_tv[vin_fmt];
+	reg_vout_fmt = k_vfmt_to_regvfmt_tv[vout_fmt];
+	/* Quit if the output format does not map to the register format */
+	RETIF_BADPARAM(reg_vout_fmt == E_REGVFMT_INVALID)
+
+	if((vin_fmt > HDMITX_VFMT_TV_MAX)
+	   || (vout_fmt > HDMITX_VFMT_TV_MAX)
+	   || (reg_vin_fmt == reg_vout_fmt)) {
+		/* Disable scaler for PC formats or if same input and output formats */
+		err = set_hw_register_field_table(p_dis, &k_scaler_off[0]);
+		RETIF_REG_FAIL(err)
+
+#ifndef TMFL_TDA9981_SUPPORT
+		if(p_dis->sca_mode == HDMITX_SCAMODE_ON) {
+			/* remove blanking */
+			err = set_hw_register(p_dis, E_REG_P00_HBL_OFFSET_START_W, 0);
+			RETIF_REG_FAIL(err)
+		}
+#endif	/* TMFL_TDA9981_SUPPORT */
+
+		p_dis->sca_mode = HDMITX_SCAMODE_OFF;
+	} else {
+#ifdef TMFL_TDA9981_SUPPORT
+		return ERR_HDMI_NOT_SUPPORTED;
+#else
+		/* Need to scale: quit if no scaler */
+		RETIF(p_dis->u_device_features & e_maskreg_p00_version_not_s,
+		      ERR_HDMI_NOT_SUPPORTED)
+
+		/* Look up scaler register formats from table */
+		sc_in_fmt = SCIO2SCIN(k_vfmt_to_regvfmt_scio_tv[vin_fmt]);
+		sc_out_fmt = SCIO2SCOUT(k_vfmt_to_regvfmt_scio_tv[vout_fmt]);
+
+		/* Do these formats individually support scaling? */
+		RETIF(sc_in_fmt  == E_REGVFMT_SCIN_INVALID,
+		      ERR_HDMI_INCONSISTENT_PARAMS)
+		RETIF(sc_out_fmt == E_REGVFMT_SCOUT_INVALID,
+		      ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Can the i/p register format be scaled to the o/p register format? */
+		RETIF(CAN_FMTS_SCALE(reg_vin_fmt, reg_vout_fmt) == 0,
+		      ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Scaling is possible: Enable scaler */
+		err = set_hw_register_field_table(p_dis, &k_scaler_on[0]);
+		RETIF_REG_FAIL(err)
+
+		/* Set scaler input format */
+		err = set_hw_register(p_dis, E_REG_P01_VIDFORMAT_W, sc_in_fmt);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_SC_VIDFORMAT_W,
+		                            e_maskreg_p01_sc_vidformat_vid_format_i,
+		                            sc_in_fmt);
+		RETIF_REG_FAIL(err)
+
+		/* Set scaler output format */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_SC_VIDFORMAT_W,
+		                            e_maskreg_p01_sc_vidformat_vid_format_o,
+		                            sc_out_fmt);
+		RETIF_REG_FAIL(err)
+
+		p_dis->sca_mode = HDMITX_SCAMODE_ON;
+
+		/* Look up PLL scaling */
+		pll_scg_n = k_scl_mode_to_scg_n[sc_in_fmt][sc_out_fmt];
+
+		/* Set bits [10 to 8] */
+		reg_val = (u8)(pll_scg_n >> 8) & 7;
+		err = set_hw_register(p_dis, E_REG_P02_PLL_SCGN2_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set bits [7 to 0] */
+		reg_val = (u8)pll_scg_n;
+		err = set_hw_register(p_dis, E_REG_P02_PLL_SCGN1_RW, reg_val);
+		RETIF_REG_FAIL(err)
+
+		/* Look up PLL scaling */
+		pll_scg_r = k_scl_mode_to_scg_r[sc_in_fmt][sc_out_fmt];
+
+		/* Set bit [8] */
+		reg_val = (u8)(pll_scg_r >> 8) & 1;
+		err = set_hw_register(p_dis, E_REG_P02_PLL_SCGR2_RW, reg_val);
+		RETIF_REG_FAIL(err)
+		/* Set bits [7 to 0] */
+		reg_val = (u8)pll_scg_r;
+		err = set_hw_register(p_dis, E_REG_P02_PLL_SCGR1_RW, reg_val);
+		RETIF_REG_FAIL(err)
+
+		/* Look-up blanking insertion */
+		hbl_off = k_scl_add_blk_pix[sc_in_fmt][sc_out_fmt];
+		err = set_hw_register(p_dis, E_REG_P00_HBL_OFFSET_START_W, hbl_off);
+		RETIF_REG_FAIL(err)
+		/* clean green lines for none RGB output */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_HVF_CNTRL_1_W,
+		                            e_maskreg_p00_hvf_cntrl_1_yuvblk,
+		                            k_scl_clear_blk_pix[p_dis->vout_mode]);
+		RETIF_REG_FAIL(err)
+#endif /* TMFL_TDA9981_SUPPORT */
+	}
+
+	/* PR 207  call function setPixelRepeat before wite in E_REG_P00_VIDFORMAT_W*/
+	/* Set pixel repetition - sets pixelRepeatCount, used by setScalerFormat */
+	err = set_pixel_repeat(p_dis, p_dis->vout_fmt, pixel_repeat);
+	RETIF(err != 0, err)
+
+	/* Set scaler clock */
+	reg_val = 0;
+	if((p_dis->pixel_repeat_count > HDMITX_PIXREP_MIN) &&
+	   (p_dis->pixel_repeat_count <= HDMITX_PIXREP_MAX)) {
+		reg_val = 2;
+	} else if(p_dis->vin_mode == HDMITX_VINMODE_CCIR656) {
+		reg_val = (u8)((p_dis->sca_mode == HDMITX_SCAMODE_ON) ? 0 : 1);
+	}
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P02_SEL_CLK_RW,
+	                            e_maskreg_p02_sel_clk_sel_vrf_clk,
+	                            reg_val);
+	RETIF_REG_FAIL(err)
+
+	/* Set format register for the selected output format voutFmt */
+	/* MUST BE AFTER SCALER CLOCK or sometimes the 9983 won't take the value */
+	err = set_hw_register(p_dis, E_REG_P00_VIDFORMAT_W, reg_vout_fmt);
+	RETIF_REG_FAIL(err)
+
+	/** \todo Evaluation of customer fix for 576i -> 720 p issue *************/
+
+#ifndef TMFL_TDA9981_SUPPORT
+	if(p_dis->sca_mode == HDMITX_SCAMODE_ON) {
+		/* Set scaler input format again */
+		/* MUST BE AFTER SCALER CLOCK or sometimes the 9983 won't take value */
+		err = set_hw_register(p_dis, E_REG_P01_VIDFORMAT_W, sc_in_fmt);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_SC_VIDFORMAT_W,
+		                            e_maskreg_p01_sc_vidformat_vid_format_i,
+		                            sc_in_fmt);
+		RETIF_REG_FAIL(err)
+
+		/* Set scaler output format again */
+		/* MUST BE AFTER SCALER CLOCK or sometimes the 9983 won't take value */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P01_SC_VIDFORMAT_W,
+		                            e_maskreg_p01_sc_vidformat_vid_format_o,
+		                            sc_out_fmt);
+		RETIF_REG_FAIL(err)
+	}
+#endif /* TMFL_TDA9981_SUPPORT */
+	return err;
+}
+
+/*============================================================================*/
+/*                     END OF FILE                                            */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_2.c b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_2.c
new file mode 100755
index 0000000..f07b9ae
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_2.c
@@ -0,0 +1,2404 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl_2.c
+ *
+ * \version       $Revision: 29 $
+ *
+ * \date          $Date: 29/10/07 14:11 $
+ *
+ * \brief         BSL driver component for the TDA9983 HDMI Transmitter
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *   $History: bsl_2.c $
+ *
+ * *******************  Version 29  *****************
+ * User: B.Vereecke     Date: 29/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR852 : remove external library dependancy
+ *
+ * * *****************  Version 28  *****************
+ * User: B.Vereecke     Date: 17/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR872 : add new formats, 1080p24/25/30
+ *
+ * * *****************  Version 27  *****************
+ * User: J. Lamotte      Date: 01/06/07   Time: 12:00
+ * Updated in $/Source/bsl/src
+ * PR359 (PR176) : Modify SetHwRegisters call in
+ *				bslMatrixSetConversion API
+ *
+ * * *****************  Version 26  *****************
+ * User: J. Lamotte      Date: 14/05/07   Time: 10:30
+ * Updated in $/Source/bsl/src
+ * PR322 (PR176) : Remove 3 DLL compilation warnings
+ *                 (calculateCheckusm, getEdidBlock,
+ *                 bslpktSetVsInfoframe)
+ *
+ * * *****************  Version 25  *****************
+ * User: Burnouf         Date: 18/04/07   Time: 13:25
+ * Updated in $/Source/bsl/src
+ * PR50 : Send event EV_SINKON for TDA9981
+ *
+ * *****************  Version 24  *****************
+ * User: Burnouf      Date: 29/11/06   Time: 17:06
+ * Updated in $/Source/bsl/Src
+ * PNF79 and PR11 allow driver to go in state connected if EDID checksum
+ * is bad
+ *
+ * *****************  Version 23  *****************
+ * User: Mayhew       Date: 23/11/06   Time: 15:06
+ * Updated in $/Source/bsl/Src
+ * PNF78 Ensure that DDC is disconnected from I2C after bad EDID read
+ *
+ * *****************  Version 21  *****************
+ * User: Mayhew       Date: 10/11/06   Time: 10:11
+ * Updated in $/Source/bsl/Src
+ * PNF68 RETIF_REG_FAIL macro replaces RETIF checks after register set/get
+ * calls, and compiled out to save code space
+ *
+ * *****************  Version 19  *****************
+ * User: Mayhew       Date: 2/11/06    Time: 16:54
+ * Updated in $/Source/bsl/Src
+ * Remove N3 support
+ *
+ * *****************  Version 17  *****************
+ * User: Mayhew       Date: 21/09/06   Time: 15:49
+ * Updated in $/Source/bsl/Src
+ * Cut code size in demo by using RETIF_BADPARAM
+ *
+ * *****************  Version 15  *****************
+ * User: Djw          Date: 22/08/06   Time: 9:56
+ * Updated in $/Source/bsl/Src
+ * Updated file configuration info.
+ *
+ * *****************  Version 14  *****************
+ * User: Mayhew       Date: 10/07/06   Time: 13:09
+ * Updated in $/Source/bsl/Src
+ * Fix file header comment
+ *
+ * *****************  Version 12  *****************
+ * User: Mayhew       Date: 30/06/06   Time: 13:26
+ * Updated in $/Source/bsl/Src
+ * EdidSinkType replaced by SinkType. Set full colourspace for VGA format
+ * 1 as well as for PC formats.
+ *
+ * *****************  Version 10  *****************
+ * User: Djw          Date: 16/06/06   Time: 12:04
+ * Updated in $/Source/bsl/Src
+ * Added use of alternate i2c address for EDID.  More conditional
+ * compilation for demoboard build.
+ *
+ * *****************  Version 8  *****************
+ * User: Mayhew       Date: 5/06/06    Time: 16:39
+ * Updated in $/Source/bsl/Src
+ * Save code space by replacing API unit checks with checkUnitSetDis.
+ *
+ * *****************  Version 7  *****************
+ * User: Djw          Date: 24/05/06   Time: 15:30
+ * Updated in $/Source/bsl/Src
+ * Minor change to force EDID reads of block 0 or 1 to occur without
+ * segment pointer - thus keeping compatibility with older EDIDs.
+ *
+ * *****************  Version 5  *****************
+ * User: Djw          Date: 24/05/06   Time: 11:19
+ * Updated in $/Source/bsl/Src
+ * Added conditional compilation for demoboard build.  Added N4 EDID
+ * capability with Seg Ptr writing.  Added all InfoFrames with N4 version
+ * checking; InfoFrames use page 10h on N4.
+ *
+ * *****************  Version 4  *****************
+ * User: Mayhew       Date: 10/05/06   Time: 17:08
+ * Updated in $/Source/bsl/Src
+ * Rename local E_ enums to public HDMITX_ enums
+ *
+ * *****************  Version 3  *****************
+ * User: Djw          Date: 20/04/06   Time: 18:03
+ * Updated in $/Source/bsl/Src
+ * Fixed logic problem with EDID block parsing on block 1 upwards
+ * (checksum test).  Added workaround for EDID ghost register problem on
+ * n3 device.
+ *
+ * *****************  Version 2  *****************
+ * User: Mayhew       Date: 11/04/06   Time: 14:09
+ * Updated in $/Source/bsl/Src
+ * Fixed Bad Parameter error in MatrixSetConversion and fixed wrong block
+ * version in video infoframe.
+ *
+ * *****************  Version 1  *****************
+ * User: Mayhew       Date: 4/04/06    Time: 16:28
+ * Created in $/Source/bsl/Src
+ * Driver phase 2
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                   FILE CONFIGURATION                                       */
+/*============================================================================*/
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_BADPARAM */
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_REG_FAIL */
+
+/* Defining this symbol on the compiler command line excludes unused code */
+/* #define DEMO_BUILD */
+
+/*============================================================================*/
+/*                   STANDARD INCLUDE FILES                                   */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PROJECT INCLUDE FILES                                    */
+/*============================================================================*/
+#include "tmbslHdmiTx.h"
+#include "tmbslHdmiTx_local.h"
+
+/*============================================================================*/
+/*                   MACRO DEFINITIONS                                        */
+/*============================================================================*/
+#define EDID_NUMBER_MAX_DTD_BLK_1           6
+/** EDID block 0 parse start point */
+#define EDID_BLK0_BASE_DTD                  0x36
+
+#define EDID_BLK1_OFFSET_BASE_DTD           2
+
+/** EDID block 0 extension block count */
+#define EDID_BLK0_EXT_CNT                   0x7E
+
+/** EDID extension block parse start point */
+#define EDID_BLK_EXT_BASE                   0x04
+
+/** CEA extension block type */
+#define EDID_CEA_EXTENSION                  0x02
+
+/** CEA Block Map */
+#define EDID_BLOCK_MAP                      0xF0
+
+/** NB Max of descriptor DTD or monitor in block 0 */
+#define EDID_NB_MAX_DESCRIP_BLK_IN_BLK_0    4
+
+#define EDID_MONITOR_NAME_DESC_DATA_TYPE    252
+
+#define EDID_MONITOR_RANGE_DESC_DATA_TYPE   253
+
+/*============================================================================*/
+/*                   TYPE DEFINITIONS                                         */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC VARIABLE DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STATIC VARIABLE DECLARATIONS                             */
+/*============================================================================*/
+
+/**
+ *  Lookup table for colour space conversion matrix register sets.
+ *  Each array consists of 31 register values from MAT_CONTROL through
+ *  to MAT_OO3_LSB
+ * */
+static CONST_DAT u8 k_matrix_preset[MATRIX_PRESET_QTY][MATRIX_PRESET_SIZE] = {
+	{
+		0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x6F, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x3, 0x6F, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3,
+		0x6F, 0x0, 0x40, 0x0, 0x40, 0x0, 0x40
+	},  /* RGB Full to RGB Limited */
+
+	{
+		0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x4, 0x1, 0x7, 0x0,
+		0x64, 0x6, 0x88, 0x1, 0xC2, 0x7, 0xB7, 0x6, 0xD6, 0x7, 0x68, 0x1,
+		0xC2, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	},  /* RGB Full to BT601 */
+
+	{
+		0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x75, 0x0, 0xBB, 0x0,
+		0x3F, 0x6, 0x68, 0x1, 0xC2, 0x7, 0xD7, 0x6, 0xA6, 0x7, 0x99, 0x1,
+		0xC2, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	},  /* RGB Full to BT709 */
+
+	{
+		0x1, 0x7, 0xC0, 0x7, 0xC0, 0x7, 0xC0, 0x2, 0x54, 0x0, 0x0, 0x0,
+		0x0, 0x0, 0x0, 0x2, 0x54, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2,
+		0x54, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+	},  /* RGB Limited to RGB Full */
+
+	{
+		0x2, 0x7, 0xC0, 0x7, 0xC0, 0x7, 0xC0, 0x2, 0x59, 0x1, 0x32, 0x0,
+		0x75, 0x6, 0x4A, 0x2, 0x0C, 0x7, 0xAB, 0x6, 0xA5, 0x7, 0x4F, 0x2,
+		0x0C, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	},  /* RGB Limited to BT601 */
+
+	{
+		0x2, 0x7, 0xC0, 0x7, 0xC0, 0x7, 0xC0, 0x2, 0xDC, 0x0, 0xDA, 0x0,
+		0x4A, 0x6, 0x24, 0x2, 0x0C, 0x7, 0xD0, 0x6, 0x6C, 0x7, 0x88, 0x2,
+		0x0C, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	},  /* RGB Limited to BT709 */
+
+	{
+		0x0, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x1, 0x2A, 0x7, 0x30, 0x7,
+		0x9C, 0x1, 0x2A, 0x1, 0x99, 0x0, 0x0, 0x1, 0x2A, 0x0, 0x0, 0x2,
+		0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+	},  /* BT601 to RGB Full */
+
+	{
+		0x1, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x2, 0x0, 0x6, 0x9A, 0x7,
+		0x54, 0x2, 0x0, 0x2, 0xBE, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3,
+		0x77, 0x0, 0x40, 0x0, 0x40, 0x0, 0x40
+	},  /* BT601 to RGB Limited */
+
+	{
+		0x1, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x2, 0x0, 0x7, 0x96, 0x7,
+		0xC5, 0x0, 0x0, 0x2, 0x0D, 0x0, 0x26, 0x0, 0x0, 0x0, 0x3B, 0x2,
+		0x0A, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	},  /* BT601 to BT709 */
+
+	{
+		0x0, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x1, 0x2A, 0x7, 0x77, 0x7,
+		0xC9, 0x1, 0x2A, 0x1, 0xCB, 0x0, 0x0, 0x1, 0x2A, 0x0, 0x0, 0x2,
+		0x1D, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0
+	},  /* BT709 to RGB Full */
+
+	{
+		0x1, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x2, 0x0, 0x7, 0x16, 0x7,
+		0xA2, 0x2, 0x0, 0x3, 0x14, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x3,
+		0xA1, 0x0, 0x40, 0x0, 0x40, 0x0, 0x40
+	},  /* BT709 to RGB Limited */
+
+	{
+		0x1, 0x7, 0xC0, 0x6, 0x0, 0x6, 0x0, 0x2, 0x0, 0x0, 0x62, 0x0,
+		0x33, 0x0, 0x0, 0x1, 0xF7, 0x7, 0xDB, 0x0, 0x0, 0x7, 0xC7, 0x1,
+		0xFB, 0x0, 0x40, 0x2, 0x0, 0x2, 0x0
+	}  /* BT709 to BT601 */
+};
+
+/**
+ *  This table gives us the index into the kMatrixPreset array, based
+ *  on the input and output colourspaces.
+ *  The co-ordinates into this array are bslColourspace_t enums.
+ *  The value of -1 is returned for matching input/output colourspaces.
+ * */
+static CONST_DAT int k_matrix_index[HDMITX_CS_NUM][HDMITX_CS_NUM] = {
+	{ -1, E_MATRIX_RGBF_2_RGBL, E_MATRIX_RGBF_2_BT601, E_MATRIX_RGBF_2_BT709},
+	{E_MATRIX_RGBL_2_RGBF, -1, E_MATRIX_RGBL_2_BT601, E_MATRIX_RGBL_2_BT709},
+	{E_MATRIX_BT601_2_RGBF, E_MATRIX_BT601_2_RGBL, -1, E_MATRIX_BT601_2_BT709},
+	{E_MATRIX_BT709_2_RGBF, E_MATRIX_BT709_2_RGBL, E_MATRIX_BT709_2_BT601, -1}
+};
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DECLARATIONS                             */
+/*============================================================================*/
+static u8            calculate_checksum(u8 *p_data, int num_bytes);
+static error_code_t    get_edid_block(hdmi_txobject_t *p_dis,
+                                      int block_number);
+static error_code_t    parse_edid_block(hdmi_txobject_t *p_dis,
+                                        int block_number);
+
+static bool             store_dtd_block(hdmi_txobject_t    *p_dis,
+                                        u8               block_ptr);
+
+static bool             store_monitor_descriptor(hdmi_txobject_t    *p_dis,
+        u8                block_ptr);
+
+/*============================================================================*/
+/*                   PUBLIC FUNCTION DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/* bslEdidGetAudioCapabilities                                        */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_edid_get_audio_capabilities
+(
+    unit_select_t          tx_unit,
+    bsl_edid_sad_t    *p_edid_afmts,
+    uint                    a_fmt_length,
+    uint                    *p_afmts_avail,
+    u8                   *p_audio_flags
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	uint                i;          /* Loop index */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_edid_afmts == NULL)
+	RETIF_BADPARAM(a_fmt_length < 1)
+	RETIF_BADPARAM(p_afmts_avail == NULL)
+	RETIF_BADPARAM(p_audio_flags == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	/* Copy the Device Instance Structure EdidAFmts descriptors to
+	 * pEdidAFmts until we run out or no more space in structure.
+	 *	 */
+	if(p_dis->edid_sad_cnt > 0) {
+		for(i = 0; (i < (uint)p_dis->edid_sad_cnt) && (i < a_fmt_length); i++) {
+			p_edid_afmts[i].mode_chans = p_dis->edid_afmts[i].mode_chans;
+			p_edid_afmts[i].freqs     = p_dis->edid_afmts[i].freqs;
+			p_edid_afmts[i].byte3     = p_dis->edid_afmts[i].byte3;
+		}
+	} else {
+		/* No pEdidAFmts to copy so set a zero format to be safe */
+		p_edid_afmts[0].mode_chans = 0;
+		p_edid_afmts[0].freqs     = 0;
+		p_edid_afmts[0].byte3     = 0;
+	}
+
+	/* Fill Audio Flags parameter */
+	*p_audio_flags = ((p_dis->edid_cea_flags & 0x40) << 1);  /* Basic audio */
+	if(p_dis->edid_sink_ai == true) {
+		/* Mask in AI support */
+		*p_audio_flags += 0x40;
+	}
+
+	/* Fill number of SADs available parameter */
+	*p_afmts_avail = p_dis->edid_sad_cnt;
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslEdidGetBlockCount                                               */
+/*============================================================================*/
+error_code_t
+bsl_edid_get_block_count
+(
+    unit_select_t      tx_unit,
+    u8               *pu_edid_block_count
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(pu_edid_block_count == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	*pu_edid_block_count = p_dis->edid_block_cnt;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslEdidGetBlockData                                                */
+/*============================================================================*/
+error_code_t
+bsl_edid_get_block_data
+(
+    unit_select_t  tx_unit,
+    u8           *p_raw_edid,
+    int             num_blocks,  /* Only relevant if pRawEdid valid */
+    int             len_raw_edid, /* Only relevant if pRawEdid valid */
+    u8           *p_edid_status
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	int                 i;          /* Loop index */
+	u8               ext_block_cnt;   /* Count of extension blocks */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s)
+	 * We do allow a null pRawEdid pointer, in which case buffer length is
+	 * irrelevant. If pRawEdid pointer is valid, there is no point in
+	 * continuing if insufficient space for at least one block.
+	 *	 */
+	RETIF_BADPARAM((p_raw_edid != NULL) && (len_raw_edid < EDID_BLOCK_SIZE))
+	/* Sensible value of numBlocks? */
+	RETIF((p_raw_edid != NULL) && ((num_blocks < 1) || (num_blocks > 255)),
+	      ERR_HDMI_INCONSISTENT_PARAMS)
+	/* Enough space for the data requested? */
+	RETIF((p_raw_edid != NULL) && (len_raw_edid < (num_blocks * EDID_BLOCK_SIZE)),
+	      ERR_HDMI_INCONSISTENT_PARAMS)
+	RETIF_BADPARAM(p_edid_status == NULL)
+
+	/* Reset the EdidStatus in the Device Instance Structure */
+	p_dis->edid_status = HDMITX_EDID_NOT_READ;
+
+	/* Reset stored parameters from EDID in the Device Instance Structure */
+	p_dis->edid_sink_type = HDMITX_SINK_DVI;
+	p_dis->edid_sink_ai = false;
+	p_dis->edid_cea_flags = 0;
+	p_dis->edid_svd_cnt = 0;
+	p_dis->edid_sad_cnt = 0;
+	p_dis->edid_source_address = 0;                /* 0.0.0.0 */
+	p_dis->nb_dtdstored = 0;
+	p_dis->edid_first_monitor_descriptor.b_desc_record = false;
+	p_dis->edid_second_monitor_descriptor.b_desc_record = false;
+	p_dis->edid_other_monitor_descriptor.b_desc_record = false;
+
+	/* Read the HPD pin via the hpd_in flag in the first interrupt status
+	 * register and return a ERR_HDMI_NULL_CONNECTION error if it is
+	 * not set.
+	 * We must use the flag in the Device Instance Structure to avoid
+	 * clearing pending interrupt flags.
+	 *	 */
+	RETIF(p_dis->hot_plug_status != HDMITX_HOTPLUG_ACTIVE,
+	      ERR_HDMI_NULL_CONNECTION)
+
+	/* Get the first EDID block into Device Instance workspace */
+	err = get_edid_block(p_dis, 0);
+	/* PR11 : On i2c error or bad checksum in block 0 */
+	/* allow driver to go in state CONNECTED */
+
+	if(err != 0) {
+		set_state(p_dis, EV_GETBLOCKDATA);
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+		if(p_dis->rx_sense_status == HDMITX_RX_SENSE_ACTIVE) {
+			set_state(p_dis, EV_SINKON);
+		}
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+		return err;
+	}
+
+	/* Indicate that status OK so far */
+	p_dis->edid_status = HDMITX_EDID_READ;
+
+	/* If pointer present, copy block from workspace.  We know from the
+	 * paramenter checking on entry that at least one block is required
+	 * and we have the space for it.
+	 *	 */
+	if(p_raw_edid != NULL) {
+		lmemcpy(p_raw_edid, p_dis->edid_block, EDID_BLOCK_SIZE);
+	}
+
+	/* Could check block 0 header (0x00,6 x 0xFF,0x00) here but not
+	 * certain to be future proof [CEA861C A.2.3]
+	 *	 */
+
+	/* Read block count from penultimate byte of block and store in DIS */
+	ext_block_cnt = p_dis->edid_block[EDID_BLK0_EXT_CNT];
+	/* (For N3, used to have to limit extBlockCnt to one block) */
+	/* Total = Block 0 + extensions */
+	p_dis->edid_block_cnt = ext_block_cnt + 1;
+
+	/* Parse block 0 */
+	parse_edid_block(p_dis, 0);
+
+	/* If extension blocks are present, process them */
+	if(ext_block_cnt > 0) {
+		for(i = 0; i < ext_block_cnt; i++) {
+			/* read block */
+			err = get_edid_block(p_dis, i + 1);
+			/* On this occasion, we also accept INVALID_STATE which means
+			 * there was a checksum error
+			 *			 */
+			if((err != 0) && (err != ERR_HDMI_INVALID_STATE)) {
+				/* PR11 : allow driver to go in state CONNECTED */
+				set_state(p_dis, EV_GETBLOCKDATA);
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+				if(p_dis->rx_sense_status == HDMITX_RX_SENSE_ACTIVE) {
+					set_state(p_dis, EV_SINKON);
+				}
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+				return err;
+			}
+
+			/* If pointer was supplied, copy block from DIS to buffer */
+			if(p_raw_edid != NULL) {
+				/* Check if we've copied as many as requested yet? */
+				if((i + 2) <= num_blocks) {
+					lmemcpy(p_raw_edid + ((i + 1) * EDID_BLOCK_SIZE),
+					        p_dis->edid_block,
+					        EDID_BLOCK_SIZE);
+					if(err == ERR_HDMI_INVALID_STATE) {
+						/* Note checksum error in EdidStatus */
+						p_dis->edid_status = HDMITX_EDID_ERROR;
+					}
+				} else { /* Fewer blocks requested than EDID contains, warn */
+					if(p_dis->edid_status == HDMITX_EDID_ERROR) {
+						p_dis->edid_status = HDMITX_EDID_ERROR_INCOMPLETE;
+					}
+				}
+			}
+			/* If the checksum was OK, we can parse the block */
+			if(err == 0) {
+				parse_edid_block(p_dis, i + 1);
+			}
+		}
+	}
+
+	/* Copy return value from EdidStatus */
+	*p_edid_status = p_dis->edid_status;
+
+	/* Filter out buffer status from the EdidStatus value in the
+	 * Device Instance Structure
+	 *	 */
+	if((p_dis->edid_status == HDMITX_EDID_ERROR) ||
+	   (p_dis->edid_status == HDMITX_EDID_ERROR_INCOMPLETE)) {
+		p_dis->edid_status = HDMITX_EDID_ERROR;
+	}
+
+	set_state(p_dis, EV_GETBLOCKDATA);
+
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+	if(p_dis->rx_sense_status == HDMITX_RX_SENSE_ACTIVE) {
+		set_state(p_dis, EV_SINKON);
+	}
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslEdidGetSinkType                                                 */
+/*============================================================================*/
+error_code_t
+bsl_edid_get_sink_type
+(
+    unit_select_t              tx_unit,
+    bsl_sink_type_t      *p_sink_type
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_sink_type == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	*p_sink_type = p_dis->edid_sink_type;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslEdidGetSourceAddress                                            */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_edid_get_source_address
+(
+    unit_select_t  tx_unit,
+    u16          *p_source_address
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_source_address == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	*p_source_address = p_dis->edid_source_address;
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslEdidGetVideoCapabilities                                        */
+/*============================================================================*/
+error_code_t
+bsl_edid_get_video_capabilities
+(
+    unit_select_t          tx_unit,
+    u8                   *p_edid_vfmts,
+    uint                    v_fmt_length,
+    uint                    *p_vfmts_avail,
+    u8                   *p_vid_flags
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	uint                i;          /* Loop index */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_edid_vfmts == NULL)
+	RETIF_BADPARAM(v_fmt_length < 1)
+	RETIF_BADPARAM(p_vfmts_avail == NULL)
+	RETIF_BADPARAM(p_vid_flags == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	/* Copy the Device Instance Structure EdidVFmts descriptors to
+	 * pEdidVFmts until we run out or no more space in structure.
+	 *	 */
+	if(p_dis->edid_svd_cnt > 0) {
+		for(i = 0; (i < (uint)p_dis->edid_svd_cnt) && (i < v_fmt_length); i++) {
+			p_edid_vfmts[i] = p_dis->edid_vfmts[i];
+		}
+	} else {
+		/* No pEdidVFmts to copy so set a zero format to be safe */
+		p_edid_vfmts[0] = HDMITX_VFMT_NULL;
+	}
+
+	/* Fill Video Flags parameter */
+	*p_vid_flags = ((p_dis->edid_cea_flags & 0x80) |         /* Underscan */
+	                /* YUV444, YUV422 */
+	                ((p_dis->edid_cea_flags & 0x30) << 1));
+
+	/* Fill number of SVDs available parameter */
+	*p_vfmts_avail = p_dis->edid_svd_cnt;
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslEdidGetVideoPreferred                                           */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_edid_get_video_preferred
+(
+    unit_select_t		   tx_unit,
+    bsl_edid_dtd_t *p_edid_dtd
+)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+	u8               edid_result;
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_edid_dtd == NULL)
+
+	/* IF the EdidStatus value is not valid in the Device Instance Structure
+	 * THEN call bslEdidGetBlockData.
+	 *	 */
+	if(p_dis->edid_status == HDMITX_EDID_NOT_READ) {
+		err = bsl_edid_get_block_data(tx_unit, NULL, 0, 0, &edid_result);
+		/* IF the result is not 0 THEN return it. */
+		RETIF(err != 0, err)
+	}
+
+	/* Populate the Detailed Timing Descriptor structure pEdidDTD from
+	 * EdidDtd in the Device Instance Structure.
+	 *	 */
+	lmemcpy(p_edid_dtd, &p_dis->edid_dtd, sizeof(*p_edid_dtd));
+
+	return 0;
+}
+#endif /* DEMO_BUILD */
+
+#ifndef DEMO_BUILD
+error_code_t
+bsl_edid_get_detailed_timing_descriptors
+(
+    unit_select_t          tx_unit,
+    bsl_edid_dtd_t    *p_edid_dtd,
+    u8                   nb_size,
+    u8                   *p_dtda_vail
+)
+{
+
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t    *p_dis;
+	error_code_t       err;        /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_edid_dtd == NULL)
+	RETIF_BADPARAM(p_dtda_vail == NULL)
+	RETIF_BADPARAM(nb_size == 0)
+
+	if((p_dis->edid_status == HDMITX_EDID_READ)  ||
+	   (p_dis->edid_status == HDMITX_EDID_ERROR) ||
+	   (p_dis->edid_status == HDMITX_EDID_ERROR_INCOMPLETE)) {
+		/* allow if edid are read or if there are a chk error on an other block than block 0 */
+		if(nb_size > p_dis->nb_dtdstored) {
+			*p_dtda_vail = p_dis->nb_dtdstored;
+		} else {
+			*p_dtda_vail = nb_size;
+		}
+
+		lmemcpy(p_edid_dtd, p_dis->edid_dtd, sizeof(bsl_edid_dtd_t) *(*p_dtda_vail));
+	} else {
+		/* Not allowed if EdidStatus value is not valid */
+		err = ERR_HDMI_INVALID_STATE;
+	}
+
+	return 0;
+
+}
+#endif  /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslMatrixSetCoeffs                                                 */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_matrix_set_coeffs
+(
+    unit_select_t		   tx_unit,
+    bsl_mat_coeff_t *p_mat_coeff
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	int                 i;      /* Loop index */
+	u8               buf[HDMITX_MAT_COEFF_NUM * 2];     /* Temp buffer */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_mat_coeff == (bsl_mat_coeff_t *)0)
+	for(i = 0; i < HDMITX_MAT_COEFF_NUM; i++) {
+		RETIF_BADPARAM((p_mat_coeff->coeff[i] < HDMITX_MAT_OFFSET_MIN) ||
+		               (p_mat_coeff->coeff[i] > HDMITX_MAT_OFFSET_MAX))
+	}
+
+	/* Convert signed 11 bit values from Coeff array to pairs of MSB-LSB
+	 * register values, and write to register pairs
+	 *	 */
+	for(i = 0; i < HDMITX_MAT_COEFF_NUM; i++) {
+		/* Mask & copy MSB */
+		buf[i*2] = (u8)(((u16)p_mat_coeff->coeff[i] & 0x0700) >> 8);
+		/* Copy LSB */
+		buf[(i*2)+1] = (u8)((u16)p_mat_coeff->coeff[i] & 0x00FF);
+	}
+	err = set_hw_registers(p_dis,
+	                       E_REG_P00_MAT_P11_MSB_W,
+	                       &buf[0],
+	                       HDMITX_MAT_COEFF_NUM * 2);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslMatrixSetConversion                                             */
+/*============================================================================*/
+error_code_t
+bsl_matrix_set_conversion
+(
+    unit_select_t          tx_unit,
+    bsl_vid_fmt_t     vin_fmt,
+    bsl_vin_mode_t    vin_mode,
+    bsl_vid_fmt_t     vout_fmt,
+    bsl_vout_mode_t   vout_mode,
+    bsl_vqr_t        dvi_vqr
+)
+{
+	/* Ptr to Device Instance Structure */
+	hdmi_txobject_t            *p_dis;
+	error_code_t               err;        /* Error code */
+	bsl_colourspace_t    cspace_in;  /* Input colourspaces */
+	bsl_colourspace_t    cspace_out; /* Output colourspaces */
+	/* Index into matrix preset array */
+	int                         matrix_index;
+	u8						buf[MATRIX_PRESET_SIZE]; /* Temp buffer */
+	u8						i; /* Loop index */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(((vin_fmt < HDMITX_VFMT_TV_MIN) || (vin_fmt > HDMITX_VFMT_PC_MAX))
+	               || ((vin_fmt > HDMITX_VFMT_TV_MAX) && (vin_fmt < HDMITX_VFMT_PC_MIN)))
+	/* NB: NO_CHANGE is not valid for this function, so limit to actual values*/
+	RETIF_BADPARAM(vin_mode >= HDMITX_VINMODE_NO_CHANGE)
+	RETIF_BADPARAM(((vout_fmt < HDMITX_VFMT_TV_MIN) || (vout_fmt > HDMITX_VFMT_PC_MAX))
+	               || ((vout_fmt > HDMITX_VFMT_TV_MAX) && (vout_fmt < HDMITX_VFMT_PC_MIN)))
+	/* NB: NO_CHANGE is not valid for this function, so limit to actual values*/
+	RETIF_BADPARAM(vout_mode >= HDMITX_VOUTMODE_NO_CHANGE)
+
+	/* Since vinMode and voutMode are different types, we don't use a local
+	 *	   function to do this and use inline code twice */
+
+	/* Calculate input colour space */
+	if((vin_fmt == HDMITX_VFMT_TV_MIN) || (vin_fmt >= HDMITX_VFMT_PC_MIN)) {
+		/* Catch the VGA or PC formats */
+		cspace_in = HDMITX_CS_RGB_FULL;
+	} else {
+		switch(vin_fmt) {
+			/* Catch the HD modes */
+		case hdmitx_vfmt_04_1280x720p_60hz:
+		case hdmitx_vfmt_05_1920x1080i_60hz:
+		case hdmitx_vfmt_16_1920x1080p_60hz:
+		case hdmitx_vfmt_19_1280x720p_50hz:
+		case hdmitx_vfmt_20_1920x1080i_50hz:
+		case hdmitx_vfmt_31_1920x1080p_50hz:
+		case hdmitx_vfmt_32_1920x1080p_24hz:
+		case hdmitx_vfmt_33_1920x1080p_25hz:
+		case hdmitx_vfmt_34_1920x1080p_30hz:
+			if(vin_mode == HDMITX_VINMODE_RGB444) {  /* RGB */
+				cspace_in = HDMITX_CS_RGB_LIMITED;
+				/* CCIR656, YUV444, YU422 */
+			} else {
+				cspace_in = HDMITX_CS_YUV_ITU_BT709;
+			}
+			break;
+		default:    /* Now all the SD modes */
+			if(vin_mode == HDMITX_VINMODE_RGB444) {  /* we're RGB */
+				cspace_in = HDMITX_CS_RGB_LIMITED;
+				/* CCIR656, YUV444, YU422 */
+			} else {
+				cspace_in = HDMITX_CS_YUV_ITU_BT601;
+			}
+			break;
+		}
+	}
+
+	/* Calculate output colour space */
+	if((vout_fmt == HDMITX_VFMT_TV_MIN) || (vout_fmt >= HDMITX_VFMT_PC_MIN)) {
+		/* Catch the VGA or PC formats */
+		cspace_out = HDMITX_CS_RGB_FULL;
+	} else {
+		switch(vout_fmt) {
+			/* Catch the HD modes */
+		case hdmitx_vfmt_04_1280x720p_60hz:
+		case hdmitx_vfmt_05_1920x1080i_60hz:
+		case hdmitx_vfmt_16_1920x1080p_60hz:
+		case hdmitx_vfmt_19_1280x720p_50hz:
+		case hdmitx_vfmt_20_1920x1080i_50hz:
+		case hdmitx_vfmt_31_1920x1080p_50hz:
+		case hdmitx_vfmt_32_1920x1080p_24hz:
+		case hdmitx_vfmt_33_1920x1080p_25hz:
+		case hdmitx_vfmt_34_1920x1080p_30hz:
+			if(vout_mode == HDMITX_VOUTMODE_RGB444) { /* RGB */
+				cspace_out = HDMITX_CS_RGB_LIMITED;
+			} else {                                /* YUV444 or YUV422 */
+				cspace_out = HDMITX_CS_YUV_ITU_BT709;
+			}
+			break;
+		default:    /* Now all the SD modes */
+			if(vout_mode == HDMITX_VOUTMODE_RGB444) { /* RGB */
+				cspace_out = HDMITX_CS_RGB_LIMITED;
+			} else {                                /* YUV444 or YUV422 */
+				cspace_out = HDMITX_CS_YUV_ITU_BT601;
+			}
+			break;
+		}
+	}
+
+	if(p_dis->sink_type == HDMITX_SINK_DVI) {
+
+		switch(dvi_vqr) {
+		case HDMITX_VQR_DEFAULT :
+			/* do nothing */
+			break;
+
+		case HDMITX_RGB_FULL :
+			cspace_out = HDMITX_CS_RGB_FULL;
+			break;
+
+		case HDMITX_RGB_LIMITED :
+			cspace_out = HDMITX_CS_RGB_LIMITED;
+			break;
+		}
+
+	}
+
+	if(cspace_in == cspace_out) {
+		/* Switch off colour matrix by setting bypass flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_MAT_CONTRL_W,
+		                            e_maskreg_p00_mat_contrl_mat_bp,
+		                            1);
+	} else {
+		/* Load appropriate values into matrix  - we have preset blocks of
+		 * 31 register vales in a table, just need to work out which set to use
+		 *		 */
+		matrix_index = k_matrix_index[cspace_in][cspace_out];
+
+		/* Set the first block byte separately, as it is shadowed and can't
+		 * be set by setHwRegisters */
+		err = set_hw_register(p_dis,
+		                      E_REG_P00_MAT_CONTRL_W,
+		                      k_matrix_preset[matrix_index][0]);
+		RETIF_REG_FAIL(err)
+
+		for(i = 0; i < MATRIX_PRESET_SIZE; i++) {
+			buf[i] = k_matrix_preset[matrix_index][i];
+		}
+
+		/* Set the rest of the block */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P00_MAT_OI1_MSB_W,
+		                       &buf[1],
+		                       MATRIX_PRESET_SIZE - 1);
+	}
+	return err;
+}
+
+/*============================================================================*/
+/* bslMatrixSetInputOffset                                            */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_matrix_set_input_offset
+(
+    unit_select_t		    tx_unit,
+    bsl_mat_offset_t  *p_mat_offset
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	int                 i;      /* Loop index */
+	u8               buf[HDMITX_MAT_OFFSET_NUM * 2];    /* Temp buffer */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_mat_offset == (bsl_mat_offset_t *)0)
+	for(i = 0; i < HDMITX_MAT_OFFSET_NUM; i++) {
+		RETIF_BADPARAM((p_mat_offset->offset[i] < HDMITX_MAT_OFFSET_MIN) ||
+		               (p_mat_offset->offset[i] > HDMITX_MAT_OFFSET_MAX))
+	}
+
+	/* Convert signed 11 bit values from Offset array to pairs of MSB-LSB
+	 * register values, and write to register pairs
+	 *	 */
+	for(i = 0; i < HDMITX_MAT_OFFSET_NUM; i++) {
+		/* Mask & copy MSB */
+		buf[i*2] = (u8)(((u16)p_mat_offset->offset[i] & 0x0700) >> 8);
+		/* Copy LSB */
+		buf[(i*2)+1] = (u8)((u16)p_mat_offset->offset[i] & 0x00FF);
+	}
+	err = set_hw_registers(p_dis,
+	                       E_REG_P00_MAT_OI1_MSB_W,
+	                       &buf[0],
+	                       HDMITX_MAT_OFFSET_NUM * 2);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslMatrixSetMode                                                   */
+/*============================================================================*/
+error_code_t
+bsl_matrix_set_mode
+(
+    unit_select_t		 tx_unit,
+    bslm_cntrl_t m_control,
+    bslm_scale_t m_scale
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM((m_control > HDMITX_MCNTRL_MAX) ||
+	               (m_scale > HDMITX_MSCALE_MAX))
+
+	/* For each value that is not NoChange, update the appropriate register */
+	if(m_control != HDMITX_MCNTRL_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_MAT_CONTRL_W,
+		                            e_maskreg_p00_mat_contrl_mat_bp,
+		                            (u8)m_control);
+		RETIF_REG_FAIL(err)
+	}
+
+	if(m_scale != HDMITX_MSCALE_NO_CHANGE) {
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P00_MAT_CONTRL_W,
+		                            e_maskreg_p00_mat_contrl_mat_sc,
+		                            (u8)m_scale);
+		RETIF_REG_FAIL(err)
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* bslMatrixSetOutputOffset                                           */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_matrix_set_output_offset
+(
+    unit_select_t		    tx_unit,
+    bsl_mat_offset_t  *p_mat_offset
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	int                 i;      /* Loop index */
+	u8               buf[HDMITX_MAT_OFFSET_NUM * 2];   /* Temp buffer */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM(p_mat_offset == (bsl_mat_offset_t *)0)
+	for(i = 0; i < HDMITX_MAT_OFFSET_NUM; i++) {
+		RETIF_BADPARAM((p_mat_offset->offset[i] < HDMITX_MAT_OFFSET_MIN) ||
+		               (p_mat_offset->offset[i] > HDMITX_MAT_OFFSET_MAX))
+	}
+
+	/* Convert signed 11 bit values from Offset array to pairs of MSB-LSB
+	 * register values, and write to register pairs
+	 *	 */
+	for(i = 0; i < HDMITX_MAT_OFFSET_NUM; i++) {
+		/* Mask & copy MSB */
+		buf[i*2] = (u8)(((u16)p_mat_offset->offset[i] & 0x0700) >> 8);
+		/* Copy LSB */
+		buf[(i*2)+1] = (u8)((u16)p_mat_offset->offset[i] & 0x00FF);
+	}
+	err = set_hw_registers(p_dis,
+	                       E_REG_P00_MAT_OO1_MSB_W,
+	                       &buf[0],
+	                       HDMITX_MAT_OFFSET_NUM * 2);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslPktSetAclkRecovery                                              */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_pkt_set_aclk_recovery
+(
+    unit_select_t  tx_unit,
+    bool            b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	/* Write the ACR packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_acr,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetAcp                                                       */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_acp
+(
+    unit_select_t		tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    u8               u_acp_type,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[3]; /* Temp buffer to hold header bytes */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM(byte_cnt > HDMITX_PKT_DATA_BYTE_CNT)
+		RETIF(byte_cnt == 0, ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Data to change, start by clearing ACP packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_FLAGS_RW,
+		                            e_maskreg_p11_dip_flags_acp,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare ACP header */
+		buf[0] = 0x04;      /* ACP packet */
+		buf[1] = u_acp_type;
+		buf[2] = 0;         /* Reserved [HDMI 1.2] */
+
+		/* Write 3 header bytes to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ACP_HB0_RW,
+		                       &buf[0],
+		                       3);
+		RETIF_REG_FAIL(err)
+
+		/* Write "byteCnt" bytes of data to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ACP_PB0_RW,
+		                       &p_pkt->data_byte[0],
+		                       (u16)byte_cnt);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the ACP packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_acp,
+	                            (u8)b_enable);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslPktSetAudioInfoframe                                            */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_audio_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_aif_t *p_pkt,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[9]; /* Temp buffer to hold header/packet bytes */
+	u16              buf_reg; /* Base register used for writing InfoFrame*/
+	u16              flag_reg;/* Flag register to be used */
+	u8               flag_mask;/* Mask used for writing flag register */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM(p_pkt->coding_type   > 0x0F)
+		RETIF_BADPARAM(p_pkt->channel_count > 0x07)
+		RETIF_BADPARAM(p_pkt->sample_freq   > 0x07)
+		RETIF_BADPARAM(p_pkt->sample_size   > 0x03)
+		/* No need to check ChannelAlloc - all values are allowed */
+		RETIF_BADPARAM((p_pkt->down_mix_inhibit != true) &&
+		               (p_pkt->down_mix_inhibit != false))
+		RETIF_BADPARAM(p_pkt->level_shift   > 0x0F)
+	}
+
+	/* Only supported for device N4 or later */
+
+	/* We're using n4 or later, use IF4 buffer for Audio InfoFrame */
+	buf_reg = E_REG_P10_IF4_HB0_RW;
+	flag_reg = E_REG_P11_DIP_IF_FLAGS_RW;
+	flag_mask = e_maskreg_p11_dip_if_flags_if4;
+
+	if(p_pkt != NULL) {
+		/* Data to change, start by clearing AIF packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            flag_reg,
+		                            flag_mask,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare AIF header */
+		buf[0] = 0x84;     /* Audio InfoFrame */
+		buf[1] = 0x01;     /* Version 1 [HDMI 1.2] */
+		buf[2] = 0x0A;     /* Length [HDMI 1.2] */
+
+		/* Prepare AIF packet (byte numbers offset by 3) */
+		buf[0+3] = 0;     /* Preset checksum to zero so calculation works! */
+		buf[1+3] = ((p_pkt->coding_type & 0x0F) << 4) |
+		           (p_pkt->channel_count & 0x07);        /* CT3-0, CC2-0 */
+		buf[2+3] = ((p_pkt->sample_freq & 0x07) << 2) |
+		           (p_pkt->sample_size & 0x03);          /* SF2-0, SS1-0 */
+		buf[3+3] = 0;                                      /* [HDMI 1.2] */
+		buf[4+3] = p_pkt->channel_alloc;                  /* CA7-0 */
+		buf[5+3] = ((p_pkt->level_shift & 0x0F) << 3);    /* LS3-0 */
+		if(p_pkt->down_mix_inhibit == true) {
+			buf[5+3] += 0x80;                              /* DMI bit */
+		}
+
+		/* Calculate checksum - this is worked out on "Length" bytes of the
+		 * packet, the checksum (which we've preset to zero), and the three
+		 * header bytes.  We exclude bytes PB6 to PB10 (which we
+		 * are not writing) since they are zero.
+		 *		 */
+		buf[0+3] = calculate_checksum(&buf[0], 0x0A + 1 + 3 - 5);
+
+		/* Write header and packet bytes in one operation */
+		err = set_hw_registers(p_dis,
+		                       buf_reg,
+		                       &buf[0],
+		                       9);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write AIF packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            flag_reg,
+	                            flag_mask,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetGeneralCntrl                                              */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_pkt_set_general_cntrl
+(
+    unit_select_t      tx_unit,
+    bsla_mute_t  *pa_mute,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(pa_mute != NULL) {
+		RETIF_BADPARAM((*pa_mute != HDMITX_AMUTE_OFF) && (*pa_mute != HDMITX_AMUTE_ON))
+
+		if(*pa_mute == HDMITX_AMUTE_ON) {
+			err = set_hw_register(p_dis, E_REG_P11_GC_AVMUTE_RW, 0x02);
+			RETIF_REG_FAIL(err)
+		} else {
+			err = set_hw_register(p_dis, E_REG_P11_GC_AVMUTE_RW, 0x01);
+			RETIF_REG_FAIL(err)
+		}
+	}
+
+	/* Set or clear GC packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_gc,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetIsrc1                                                     */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_isrc1
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    bool                b_isrc_cont,
+    bool                b_isrc_valid,
+    u8               u_isrc_status,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[3]; /* Temp buffer to hold header bytes */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM((b_isrc_cont != true) && (b_isrc_cont != false))
+		RETIF_BADPARAM((b_isrc_valid != true) && (b_isrc_valid != false))
+		RETIF_BADPARAM(u_isrc_status > 7)    /* 3 bits */
+		RETIF_BADPARAM(byte_cnt > HDMITX_PKT_DATA_BYTE_CNT)
+		RETIF(byte_cnt == 0, ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Data to change, start by clearing ISRC1 packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_FLAGS_RW,
+		                            e_maskreg_p11_dip_flags_isrc1,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare ISRC1 header */
+		buf[0] = 0x05;      /* ISRC1 packet */
+		buf[1] = (u_isrc_status & 0x07);
+		if(b_isrc_valid == true) {
+			buf[1] += 0x40;
+		}
+		if(b_isrc_cont == true) {
+			buf[1] += 0x80;
+		}
+		buf[2] = 0;         /* Reserved [HDMI 1.2] */
+
+		/* Write 3 header bytes to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ISRC1_HB0_RW,
+		                       &buf[0],
+		                       3);
+		RETIF_REG_FAIL(err)
+
+		/* Write "byteCnt" bytes of data to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ISRC1_PB0_RW,
+		                       &p_pkt->data_byte[0],
+		                       (u16)byte_cnt);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the ISRC1 packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_isrc1,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetIsrc2                                                     */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_isrc2
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[3]; /* Temp buffer to hold header bytes */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM(byte_cnt > HDMITX_PKT_DATA_BYTE_CNT)
+		RETIF(byte_cnt == 0, ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Data to change, start by clearing ISRC2 packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_FLAGS_RW,
+		                            e_maskreg_p11_dip_flags_isrc2,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare ISRC2 header */
+		buf[0] = 0x06;      /* ISRC2 packet */
+		buf[1] = 0;         /* Reserved [HDMI 1.2] */
+		buf[2] = 0;         /* Reserved [HDMI 1.2] */
+
+		/* Write 3 header bytes to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ISRC2_HB0_RW,
+		                       &buf[0],
+		                       3);
+		RETIF_REG_FAIL(err)
+
+		/* Write "byteCnt" bytes of data to registers */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P11_ISRC2_PB0_RW,
+		                       &p_pkt->data_byte[0],
+		                       (u16)byte_cnt);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the ISRC2 packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_isrc2,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetMpegInfoframe                                             */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_mpeg_infoframe
+(
+    unit_select_t          tx_unit,
+    bsl_pkt_mpeg_t    *p_pkt,
+    bool                    b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[9]; /* Temp buffer to hold packet */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM((p_pkt->b_field_repeat != true) && (p_pkt->b_field_repeat != false))
+		RETIF_BADPARAM(p_pkt->frame_type >= HDMITX_MPEG_FRAME_INVALID)
+
+		/* Data to change, start by clearing MPEG packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_IF_FLAGS_RW,
+		                            e_maskreg_p11_dip_if_flags_if5,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare MPEG header */
+		buf[0] = 0x85;      /* MPEG Source InfoFrame */
+		buf[1] = 0x01;      /* Version 1 [HDMI 1.2] */
+		buf[2] = 0x0A;      /* Length [HDMI 1.2] */
+
+		/* Prepare MPEG packet (byte numbers offset by 3) */
+		buf[0+3] = 0;     /* Preset checksum to zero so calculation works! */
+		buf[1+3] = (u8)(p_pkt->bit_rate & 0x000000FF);
+		buf[2+3] = (u8)((p_pkt->bit_rate & 0x0000FF00) >> 8);
+		buf[3+3] = (u8)((p_pkt->bit_rate & 0x00FF0000) >> 16);
+		buf[4+3] = (u8)((p_pkt->bit_rate & 0xFF000000) >> 24);
+		buf[5+3] = p_pkt->frame_type;                         /* MF1-0 */
+		if(p_pkt->b_field_repeat == true) {
+			buf[5+3] += 0x10;                               /* FR0 bit */
+		}
+
+		/* Calculate checksum - this is worked out on "Length" bytes of the
+		 * packet, the checksum (which we've preset to zero), and the three
+		 * header bytes.  We exclude bytes PB6 to PB10 (which we
+		 * are not writing) since they are zero.
+		 *		 */
+		buf[0+3] = calculate_checksum(&buf[0], 0x0A + 1 + 3 - 5);
+
+		/* Write header and packet bytes in one operation */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P10_IF5_HB0_RW,
+		                       &buf[0],
+		                       9);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the MPEG packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_IF_FLAGS_RW,
+	                            e_maskreg_p11_dip_if_flags_if5,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetNullInsert                                                */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_null_insert
+(
+    unit_select_t  tx_unit,
+    bool            b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	/* Set or clear FORCE_NULL packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_force_null,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetNullSingle                                                */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_null_single
+(
+    unit_select_t  tx_unit
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Set NULL packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_FLAGS_RW,
+	                            e_maskreg_p11_dip_flags_null,
+	                            0x01);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetSpdInfoframe                                              */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_spd_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_spd_t *p_pkt,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[29];/* Temp buffer to hold packet */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM(p_pkt->source_dev_info >= HDMITX_SPD_INFO_INVALID)
+
+		/* Data to change, start by clearing SPD packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_IF_FLAGS_RW,
+		                            e_maskreg_p11_dip_if_flags_if3,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare SPD header */
+		buf[0] = 0x83;      /* Source. Product Descriptor InfoFrame */
+		buf[1] = 0x01;      /* Version 1 [CEA 861B] */
+		buf[2] = 0x19;      /* Length [HDMI 1.2] */
+
+		/* Prepare SPD packet (byte numbers offset by 3) */
+		buf[0+3] = 0;     /* Preset checksum to zero so calculation works! */
+		lmemcpy(&buf[1+3], &p_pkt->vendor_name[0], HDMI_TX_SPD_VENDOR_SIZE);
+		lmemcpy(&buf[1+3+HDMI_TX_SPD_VENDOR_SIZE], &p_pkt->prod_descr[0],
+		        HDMI_TX_SPD_DESCR_SIZE);
+
+		buf[HDMI_TX_SPD_LENGTH+3] = p_pkt->source_dev_info;
+
+		/* Calculate checksum - this is worked out on "Length" bytes of the
+		 * packet, the checksum (which we've preset to zero), and the three
+		 * header bytes.
+		 *		 */
+		buf[0+3] = calculate_checksum(&buf[0], HDMI_TX_SPD_LENGTH + 1 + 3);
+
+		/* Write header and packet bytes in one operation */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P10_IF3_HB0_RW,
+		                       &buf[0],
+		                       29);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the SPD packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_IF_FLAGS_RW,
+	                            e_maskreg_p11_dip_if_flags_if3,
+	                            (u8)b_enable);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslPktSetVideoInfoframe                                            */
+/*============================================================================*/
+error_code_t
+bsl_pkt_set_video_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_vif_t *p_pkt,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[17];/* Temp buffer to hold header/packet bytes */
+	u16              buf_reg; /* Base register used for writing InfoFrame*/
+	u16              flag_reg;/* Flag register to be used */
+	u8               flag_mask;/* Mask used for writing flag register */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		RETIF_BADPARAM(p_pkt->colour             > 0x03)
+		RETIF_BADPARAM((p_pkt->active_info != true) && (p_pkt->active_info != false))
+		RETIF_BADPARAM(p_pkt->bar_info            > 0x03)
+		RETIF_BADPARAM(p_pkt->scan_info           > 0x03)
+		RETIF_BADPARAM(p_pkt->colorimetry        > 0x03)
+		RETIF_BADPARAM(p_pkt->picture_aspect_ratio > 0x03)
+		RETIF_BADPARAM(p_pkt->active_format_ratio  > 0x0F)
+		RETIF_BADPARAM(p_pkt->scaling            > 0x03)
+		RETIF_BADPARAM(p_pkt->vid_format          > 0x7F)
+		RETIF_BADPARAM(p_pkt->pixel_repeat        > 0x0F)
+	}
+
+	/* Only supported for device N4 or later */
+
+	/* We're using n4 or later, use IF2 buffer for Video InfoFrame */
+	buf_reg = E_REG_P10_IF2_HB0_RW;
+	flag_reg = E_REG_P11_DIP_IF_FLAGS_RW;
+	flag_mask = e_maskreg_p11_dip_if_flags_if2;
+
+	if(p_pkt != NULL) {
+		/* Data to change, start by clearing VIF packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            flag_reg,
+		                            flag_mask,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare VIF header */
+		buf[0] = 0x82;     /* Video InfoFrame */
+		buf[1] = 0x02;     /* Version 2 [HDMI 1.2] */
+		buf[2] = 0x0D;     /* Length [HDMI 1.2] */
+
+		/* Prepare VIF packet (byte numbers offset by 3) */
+		buf[0+3] = 0;     /* Preset checksum to zero so calculation works! */
+		buf[1+3] = ((p_pkt->colour & 0x03) << 5) |       /* Y1-0, B1-0,S1-0 */
+		           ((p_pkt->bar_info & 0x03) << 2) |
+		           (p_pkt->scan_info & 0x03);
+		if(p_pkt->active_info == true) {
+			buf[1+3] += 0x10;                              /* AI bit */
+		}
+		buf[2+3] = ((p_pkt->colorimetry & 0x03) << 6) |  /* C1-0, M1-0, R3-0 */
+		           ((p_pkt->picture_aspect_ratio & 0x03) << 4) |
+		           (p_pkt->active_format_ratio & 0x0F);
+		/* SC1-0  /  [HDMI 1.2] */
+		buf[3+3] = (p_pkt->scaling & 0x03);
+		buf[4+3] = (p_pkt->vid_format & 0x7F);            /* VIC6-0 */
+		buf[5+3] = (p_pkt->pixel_repeat & 0x0F);          /* PR3-0 */
+		buf[6+3] = (u8)(p_pkt->end_top_bar_line & 0x00FF);
+		buf[7+3] = (u8)((p_pkt->end_top_bar_line & 0xFF00) >> 8);
+		buf[8+3] = (u8)(p_pkt->start_bottom_bar_line & 0x00FF);
+		buf[9+3] = (u8)((p_pkt->start_bottom_bar_line & 0xFF00) >> 8);
+		buf[10+3] = (u8)(p_pkt->end_left_bar_pixel & 0x00FF);
+		buf[11+3] = (u8)((p_pkt->end_left_bar_pixel & 0xFF00) >> 8);
+		buf[12+3] = (u8)(p_pkt->start_right_bar_pixel & 0x00FF);
+		buf[13+3] = (u8)((p_pkt->start_right_bar_pixel & 0xFF00) >> 8);
+
+		/* Calculate checksum - this is worked out on "Length" bytes of the
+		 * packet, the checksum (which we've preset to zero), and the three
+		 * header bytes.
+		 *		 */
+		buf[0+3] = calculate_checksum(&buf[0], 0x0D + 1 + 3);
+
+		/* Write header and packet bytes in one operation */
+		err = set_hw_registers(p_dis,
+		                       buf_reg,
+		                       &buf[0],
+		                       17);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write VIF packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            flag_reg,
+	                            flag_mask,
+	                            (u8)b_enable);
+	return err;
+}
+
+/*============================================================================*/
+/* bslPktSetVsInfoframe                                               */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t
+bsl_pkt_set_vs_infoframe
+(
+    unit_select_t      tx_unit,
+    bsl_pkt_t    *p_pkt,
+    uint                byte_cnt,
+    u8               u_version,
+    bool                b_enable
+)
+{
+	hdmi_txobject_t    *p_dis;  /* Pointer to Device Instance Structure */
+	error_code_t       err;    /* Error code */
+	u8               buf[31];/* Temp buffer to hold packet */
+
+	/* Check unit parameter and point to TX unit object */
+	err = check_unit_set_dis(tx_unit, &p_dis);
+	RETIF(err != 0, err)
+
+	/* Return ERR_HDMI_OPERATION_NOT_PERMITTED error if the
+	 * sinkType is not HDMI
+	 *	 */
+	RETIF(p_dis->sink_type != HDMITX_SINK_HDMI,
+	      ERR_HDMI_OPERATION_NOT_PERMITTED)
+
+	/* Only supported for device N4 or later */
+
+	/* Check remaining parameter(s) - NULL pointer allowed */
+	RETIF_BADPARAM((b_enable != true) && (b_enable != false))
+
+	if(p_pkt != NULL) {
+		/* Pointer to structure provided so check parameters */
+		/* InfoFrame needs a checksum, so 1 usable byte less than full pkt */
+		RETIF_BADPARAM(byte_cnt > (HDMITX_PKT_DATA_BYTE_CNT - 1))
+		RETIF(byte_cnt == 0, ERR_HDMI_INCONSISTENT_PARAMS)
+
+		/* Data to change, start by clearing VS_IF packet insertion flag */
+		err = set_hw_register_field(p_dis,
+		                            E_REG_P11_DIP_IF_FLAGS_RW,
+		                            e_maskreg_p11_dip_if_flags_if1,
+		                            0x00);
+		RETIF_REG_FAIL(err)
+
+		/* Prepare VS_IF header */
+		/* Clear buffer as user may vary length used */
+		lmemset(&buf[0], 0, 31);
+		buf[0] = 0x81;          /* Vendor Specific InfoFrame */
+		buf[1] = u_version;      /* Vendor defined version */
+		buf[2] = (u8)byte_cnt;       /* Length [HDMI 1.2] */
+
+		/* Prepare VS_IF packet (byte numbers offset by 3) */
+		buf[0+3] = 0;     /* Preset checksum to zero so calculation works! */
+		lmemcpy(&buf[1+3], &p_pkt->data_byte[0], byte_cnt);
+
+		/* Calculate checksum - this is worked out on "Length" bytes of the
+		 * packet, the checksum (which we've preset to zero), and the three
+		 * header bytes.
+		 *		 */
+		buf[0+3] = calculate_checksum(&buf[0], byte_cnt + 1 + 3);
+
+		/* Write header and packet bytes in one operation  - write entire
+		 * buffer even though we may not be using it all so that zeros
+		 * are placed in the unused registers. */
+		err = set_hw_registers(p_dis,
+		                       E_REG_P10_IF1_HB0_RW,
+		                       &buf[0],
+		                       31);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Write the VS_IF packet insertion flag */
+	err = set_hw_register_field(p_dis,
+	                            E_REG_P11_DIP_IF_FLAGS_RW,
+	                            e_maskreg_p11_dip_if_flags_if1,
+	                            (u8)b_enable);
+	return err;
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DEFINTIONS                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/* calculateChecksum - returns the byte needed to yield a checksum of zero    */
+/*============================================================================*/
+static u8
+calculate_checksum
+(
+    u8       *p_data,     /* Pointer to checksum data */
+    int         num_bytes    /* Number of bytes over which to calculate */
+)
+{
+	u8       checksum = 0;   /* Working checksum calculation */
+	u8       result = 0;     /* Value to be returned */
+	int         i;
+
+	if((p_data != NULL) && (num_bytes > 0)) {
+		for(i = 0; i < num_bytes; i++) {
+			checksum = checksum + (*(p_data + i));
+		}
+		result = (255 - checksum) + 1;
+	}
+	return result;          /* returns 0 in the case of null ptr or 0 bytes */
+}
+
+/*============================================================================*/
+/* getEdidBlock - reads an entire edid block                                  */
+/*============================================================================*/
+static error_code_t
+get_edid_block
+(
+    hdmi_txobject_t    *p_dis,      /* Device instance strucure to use */
+    int                 block_number /* Block number to read */
+)
+{
+	error_code_t   err;        /* Error code */
+	int             i;          /* Loop index */
+	u8           chksum;     /* Checksum value */
+	u8           segptr;     /* Segment ptr value */
+	u8           offset;     /* Word offset value */
+	bsl_sys_args_edid_t sys_args; /* Arguments passed to system function */
+
+	/* Check block number is valid [CEA861C A.2.1] */
+	RETIF_BADPARAM(block_number >= 255)
+
+	/* Enable the EDID ghost device to allow I2C write-through */
+	/* Write the segment pointer address into the ghost regsiter */
+	/* (For N3, we did't use the segptr and did't support alternate addr) */
+	/* Load both Ghost registers  - we load whole register so no shadowing
+	 *	   to give control of lsbs */
+
+	if(p_dis->b_edid_alternate_addr == true) {
+		/* Use alternate address and set  a0_zero bit (lsb) in GHOST_XADDR */
+		err = set_hw_register(p_dis, E_REG_P00_GHOST_XADDR_W,
+		                      DDC_SGMT_PTR_ADDRESS + 1);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register(p_dis, E_REG_P00_GHOST_ADDR_W,
+		                      DDC_EDID_ADDRESS_ALT);
+		RETIF_REG_FAIL(err)
+	} else {
+		/* Use normal address and don't set a0_zero bit */
+		err = set_hw_register(p_dis, E_REG_P00_GHOST_XADDR_W,
+		                      DDC_SGMT_PTR_ADDRESS);
+		RETIF_REG_FAIL(err)
+		err = set_hw_register(p_dis, E_REG_P00_GHOST_ADDR_W,
+		                      DDC_EDID_ADDRESS);
+		RETIF_REG_FAIL(err)
+	}
+
+	/* Calculate which segment of the EDID we need (2 blocks per segment) */
+	segptr = (u8)block_number / 2;
+	/* For even blocks we need an offset of 0, odd blocks we need 128 */
+	offset = (((u8)block_number & 1) == 1) ? 128 : 0;
+
+	/* If we're reading blocks 0 or 1, we don't use segptr, as sink may not
+	 *	   support it.  We also never use for n3 or earlier, as it is not
+	 *	   supported.
+	 *	 */
+	if(block_number < 2) {
+		/* NULL SegPtrAddress used to indicate seg ptr should be skipped */
+		sys_args.seg_ptr_addr  = 0;
+	} else {
+		sys_args.seg_ptr_addr  = DDC_SGMT_PTR_ADDRESS;
+	}
+
+	if(p_dis->b_edid_alternate_addr == true) {
+		/* Use alternate address */
+		sys_args.data_reg_addr = DDC_EDID_ADDRESS_ALT;
+	} else {
+		/* Use default address */
+		sys_args.data_reg_addr = DDC_EDID_ADDRESS;
+	}
+
+	/* Read EDID block: THIS CAN FAIL IF DDC CONNECTION IS BROKEN */
+	sys_args.seg_ptr      = segptr;
+	sys_args.word_offset  = offset;
+	sys_args.len_data     = EDID_BLOCK_SIZE;
+	sys_args.p_data       = p_dis->edid_block;
+	err = p_dis->sys_func_edid_read(&sys_args);
+
+	/* Do not quit yet on I2C error: must always set GHOST_ADDR here */
+	set_hw_register(p_dis, E_REG_P00_GHOST_ADDR_W, 0x01);
+
+	/* Ignore last error, but return the more important EDID Read error */
+	RETIF(err != 0, ERR_HDMI_I2C_READ)
+
+	/* Add up all the values of the EDID block bytes, including the
+	 * checksum byte
+	 *	 */
+	chksum = 0;
+	for(i = 0; i < EDID_BLOCK_SIZE; i++) {
+		chksum = chksum + p_dis->edid_block[i];
+	}
+
+	/* IF the EDID block does not yield a checksum of zero
+	 * THEN return a ERR_HDMI_INVALID_STATE error.
+	 *	 */
+	return (chksum == 0) ? 0 : ERR_HDMI_INVALID_STATE;
+}
+
+/*============================================================================*/
+/* parseEdidBlock                                                             */
+/*============================================================================*/
+static error_code_t
+parse_edid_block
+(
+    /* Device instance strucure holding block */
+    hdmi_txobject_t    *p_dis,
+    int                 block_number /* Block number */
+)
+{
+	u8           i;                  /* Loop index */
+	u8           block_ptr, end_ptr;   /* Parsing pointers */
+	u8           block_type, block_length;
+	bool            dtd_found;
+	u8           nb_blk_read;
+
+	/* Check block number is valid [CEA861C A.2.1] */
+	RETIF_BADPARAM(block_number >= 255)
+
+	nb_blk_read = 0;
+	dtd_found = true;
+	block_ptr = 0;
+
+	if(block_number == 0) {
+		p_dis->edidbasic_display_param.u_video_input_def = p_dis->edid_block[0x14];
+		p_dis->edidbasic_display_param.u_max_horizontal_size = p_dis->edid_block[0x15];
+		p_dis->edidbasic_display_param.u_max_vertical_size = p_dis->edid_block[0x16];
+		p_dis->edidbasic_display_param.u_gamma = p_dis->edid_block[0x17];
+		p_dis->edidbasic_display_param.u_feature_support = p_dis->edid_block[0x18];
+
+		/* Block 0 - contains DTDs but no video data block (SVDs) */
+		/* search 2 possible DTD blocks in block 0 */
+		for(i = 0; (i < 2) && (dtd_found); i++) {
+			block_ptr = (u8)(EDID_BLK0_BASE_DTD + (i * EDID_DTD_BLK_SIZE));
+			if((block_ptr + EDID_DTD_BLK_SIZE - 1) < EDID_BLOCK_SIZE) {
+				dtd_found = store_dtd_block(p_dis, block_ptr);
+				if(dtd_found) {
+					nb_blk_read++;
+				}
+			}
+		}
+
+		dtd_found = true;
+
+		/* Parse monitor descriptor */
+		for(i = nb_blk_read; (i < EDID_NB_MAX_DESCRIP_BLK_IN_BLK_0) && (dtd_found); i++) {
+			block_ptr = (u8)(EDID_BLK0_BASE_DTD + (i * EDID_DTD_BLK_SIZE));
+			if((block_ptr + EDID_DTD_BLK_SIZE - 1) < EDID_BLOCK_SIZE) {
+#ifndef DEMO_BUILD
+				dtd_found = store_monitor_descriptor(p_dis, block_ptr);
+#endif /* DEMO_BUILD */
+			}
+		}
+	} else if(block_number >= 1) {
+		switch(p_dis->edid_block[0]) {
+			/* CEA EXTENSION */
+		case EDID_CEA_EXTENSION:
+			/* Read CEA flag bits here - lockout when read once??? */
+			p_dis->edid_cea_flags = p_dis->edid_block[3];
+
+			/* data block start always fixed */
+			block_ptr = EDID_BLK_EXT_BASE;
+			/* byte after end of data blocks */
+			end_ptr = p_dis->edid_block[2];
+			if(end_ptr >= (EDID_BLK_EXT_BASE + 2))
+				/* Only try reading if data blocks take up 2 bytes or more, since
+				 * a video data block must be at least 2 bytes
+				 *				 */
+			{
+				while(block_ptr < end_ptr) {
+					block_type   = (u8)((p_dis->edid_block[block_ptr] & 0xE0) >> 5);
+					block_length = (p_dis->edid_block[block_ptr] & 0x1F);
+
+					switch((int)block_type) {
+					case E_CEA_VIDEO_BLOCK:  /* We have a video data block */
+						for(i = 1; i <= block_length; i++) {
+							/* If space, store non-zero SVDs */
+							if((p_dis->edid_block[block_ptr + i] != 0) &&
+							   (p_dis->edid_svd_cnt < HDMI_TX_SVD_MAX_CNT)) {
+								p_dis->edid_vfmts[p_dis->edid_svd_cnt] =
+								    p_dis->edid_block[block_ptr + i];
+								p_dis->edid_svd_cnt++;
+							}
+						}
+						break;
+					case E_CEA_AUDIO_BLOCK:  /* We have an audio data block */
+						for(i = 1; (i + 2) <= block_length; i += 3) {
+							/* Must loop in steps of 3 (SAD size) */
+							/* If space, store non-zero SADs */
+							if(((p_dis->edid_block[block_ptr + i] & 0x78) != 0) &&
+							   (p_dis->edid_sad_cnt < HDMI_TX_SAD_MAX_CNT)) {
+								p_dis->edid_afmts[p_dis->edid_sad_cnt].mode_chans =
+								    p_dis->edid_block[block_ptr + i];
+								p_dis->edid_afmts[p_dis->edid_sad_cnt].freqs =
+								    p_dis->edid_block[block_ptr + i + 1];
+								p_dis->edid_afmts[p_dis->edid_sad_cnt].byte3 =
+								    p_dis->edid_block[block_ptr + i + 2];
+								p_dis->edid_sad_cnt++;
+							}
+						}
+						break;
+					case E_CEA_VSDB:         /* We have a VSDB */
+						/* 5 bytes expected, but this is EDID land so double check*/
+						if(block_length >= 5) {
+							if((p_dis->edid_block[block_ptr + 1] == 0x03) &&
+							   (p_dis->edid_block[block_ptr + 2] == 0x0C) &&
+							   (p_dis->edid_block[block_ptr + 3] == 0x00)) {
+								p_dis->edid_sink_type = HDMITX_SINK_HDMI;
+								p_dis->edid_source_address =
+								    ((u16)p_dis->edid_block[block_ptr + 4] << 8) +
+								    p_dis->edid_block[block_ptr + 5];
+							} else {
+								p_dis->edid_sink_type = HDMITX_SINK_DVI;
+							}
+						}
+						/* Space for byte with AI flag */
+						if(block_length >= 6) {
+							/* Mask AI bit */
+							if((p_dis->edid_block[block_ptr + 6] & 0x80) == 0x80) {
+								p_dis->edid_sink_ai = true;
+							}
+						}
+						break;
+					default:
+						break;
+					}
+					block_ptr += (block_length + 1);  /* Point to next block */
+				}
+			}
+			dtd_found = true;
+
+			/* search possible DTD blocks in block 1 */
+			for(i = 0; (i < EDID_NUMBER_MAX_DTD_BLK_1) && (dtd_found); i++) {
+				block_ptr = ((u8)p_dis->edid_block[EDID_BLK1_OFFSET_BASE_DTD]) + ((u8)(i * EDID_DTD_BLK_SIZE));
+				if((block_ptr + EDID_DTD_BLK_SIZE - 1) < EDID_BLOCK_SIZE) {
+					dtd_found = store_dtd_block(p_dis, block_ptr);
+
+				}
+			}
+
+			break;
+
+		case EDID_BLOCK_MAP:
+			/* BLOCK MAP */
+			/* Nothing special to do */
+			break;
+
+		}
+
+	}
+
+	return 0;
+}
+
+/*============================================================================*/
+/* storeDtdBlock                                                              */
+/*============================================================================*/
+
+static bool
+store_dtd_block
+(
+    /* Device instance strucure holding block */
+    hdmi_txobject_t    *p_dis,
+    u8               block_ptr
+)
+{
+
+	bool    dtd_found = false;
+
+#ifndef DEMO_BUILD
+
+	/* First, select blocks that are DTDs [CEA861C A.2.10] */
+	if(((p_dis->edid_block[block_ptr+0] != 0) ||
+	    (p_dis->edid_block[block_ptr+1] != 0) ||
+	    (p_dis->edid_block[block_ptr+2] != 0) ||
+	    (p_dis->edid_block[block_ptr+4] != 0))
+	   &&
+	   (p_dis->nb_dtdstored < NUMBER_DTD_STORED)) {
+		/* Store the first DTD we find, others will be skipped */
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_pixel_clock =
+		    ((u16)p_dis->edid_block[block_ptr+1] << 8) |
+		    (u16)p_dis->edid_block[block_ptr+0];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_hactive_pixels =
+		    (((u16)p_dis->edid_block[block_ptr+4] & 0x00F0) << 4) |
+		    (u16)p_dis->edid_block[block_ptr+2];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_hblank_pixels =
+		    (((u16)p_dis->edid_block[block_ptr+4] & 0x000F) << 8) |
+		    (u16)p_dis->edid_block[block_ptr+3];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vactive_lines =
+		    (((u16)p_dis->edid_block[block_ptr+7] & 0x00F0) << 4) |
+		    (u16)p_dis->edid_block[block_ptr+5];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vblank_lines =
+		    (((u16)p_dis->edid_block[block_ptr+7] & 0x000F) << 8) |
+		    (u16)p_dis->edid_block[block_ptr+6];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_hsync_offset =
+		    (((u16)p_dis->edid_block[block_ptr+11] & 0x00C0) << 2) |
+		    (u16)p_dis->edid_block[block_ptr+8];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_hsync_width =
+		    (((u16)p_dis->edid_block[block_ptr+11] & 0x0030) << 4) |
+		    (u16)p_dis->edid_block[block_ptr+9];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vsync_offset =
+		    (((u16)p_dis->edid_block[block_ptr+11] & 0x000C) << 2) |
+		    (((u16)p_dis->edid_block[block_ptr+10] & 0x00F0) >> 4);
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vsync_width =
+		    (((u16)p_dis->edid_block[block_ptr+11] & 0x0003) << 4) |
+		    ((u16)p_dis->edid_block[block_ptr+10] & 0x000F);
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_himage_size =
+		    (((u16)p_dis->edid_block[block_ptr+14] & 0x00F0) << 4) |
+		    (u16)p_dis->edid_block[block_ptr+12];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vimage_size =
+		    (((u16)p_dis->edid_block[block_ptr+14] & 0x000F) << 8) |
+		    (u16)p_dis->edid_block[block_ptr+13];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_hborder_pixels =
+		    (u16)p_dis->edid_block[block_ptr+15];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].u_vborder_pixels =
+		    (u16)p_dis->edid_block[block_ptr+16];
+
+		p_dis->edid_dtd[p_dis->nb_dtdstored].flags = p_dis->edid_block[block_ptr+17];
+
+		p_dis->nb_dtdstored++;
+
+		dtd_found = true;    /* Stop any more DTDs being parsed */
+	}
+#endif /* DEMO_BUILD */
+
+	return (dtd_found);
+}
+
+/*============================================================================*/
+/* storeMonitorDescriptor                                                     */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+static bool
+store_monitor_descriptor
+(
+    /* Device instance strucure holding block */
+    hdmi_txobject_t    *p_dis,
+    u8               block_ptr
+)
+{
+
+	bool    dtd_found = false;
+
+	/* First, select blocks that are DTDs [CEA861C A.2.10] */
+	if((p_dis->edid_block[block_ptr+0] == 0) &&
+	   (p_dis->edid_block[block_ptr+1] == 0) &&
+	   (p_dis->edid_block[block_ptr+2] == 0)
+	  ) {
+		if(p_dis->edid_block[block_ptr+3] == EDID_MONITOR_NAME_DESC_DATA_TYPE) {
+			if(p_dis->edid_first_monitor_descriptor.b_desc_record == false) {
+				p_dis->edid_first_monitor_descriptor.b_desc_record = true;
+				lmemcpy(&(p_dis->edid_first_monitor_descriptor.u_monitor_name) ,
+				        &(p_dis->edid_block[block_ptr+5]), EDID_MONITOR_DESCRIPTOR_SIZE);
+				dtd_found = true;
+			} else if((p_dis->edid_other_monitor_descriptor.b_desc_record == false)) {
+				p_dis->edid_other_monitor_descriptor.b_desc_record = true;
+				lmemcpy(&(p_dis->edid_other_monitor_descriptor.u_other_descriptor) ,
+				        &(p_dis->edid_block[block_ptr+5]), EDID_MONITOR_DESCRIPTOR_SIZE);
+				dtd_found = true;
+			}
+		} else if(p_dis->edid_block[block_ptr+3] == EDID_MONITOR_RANGE_DESC_DATA_TYPE) {
+			if(p_dis->edid_second_monitor_descriptor.b_desc_record == false) {
+				p_dis->edid_second_monitor_descriptor.b_desc_record = true;
+				p_dis->edid_second_monitor_descriptor.u_min_vertical_rate = p_dis->edid_block[block_ptr+5];
+				p_dis->edid_second_monitor_descriptor.u_max_vertical_rate = p_dis->edid_block[block_ptr+6];
+				p_dis->edid_second_monitor_descriptor.u_min_horizontal_rate = p_dis->edid_block[block_ptr+7];
+				p_dis->edid_second_monitor_descriptor.u_max_horizontal_rate = p_dis->edid_block[block_ptr+8];
+				p_dis->edid_second_monitor_descriptor.u_max_supported_pixel_clk = p_dis->edid_block[block_ptr+9];
+				dtd_found = true;
+			}
+		}
+	}
+
+	return (dtd_found);
+
+}
+#endif /* DEMO_BUILD */
+
+/*============================================================================*/
+/* bslDebugWriteFakeRegPage                                                 */
+/*============================================================================*/
+#ifndef DEMO_BUILD
+error_code_t bsl_debug_write_fake_reg_page(unit_select_t tx_unit)
+{
+	/* Pointer to Device Instance Structure */
+	hdmi_txobject_t *p_dis;
+	error_code_t     err;            /* Error code */
+
+	err = check_unit_set_dis(tx_unit, &p_dis);
+
+	p_dis->cur_reg_page = 0x20;
+
+	return err;
+}
+#endif  /* DEMO_BUILD */
+
+/*============================================================================*/
+/*                     END OF FILE                                            */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.c b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.c
new file mode 100755
index 0000000..dd47777
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.c
@@ -0,0 +1,898 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl_local.c
+ *
+ * \version       $Revision: 15 $
+ *
+ * \date          $Date: 29/10/07 14:11 $
+ *
+ * \brief         BSL driver component for the TDA998x HDMI Transmitter
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *   $History: bsl_local.c $
+ *
+ * *****************  Version 15  *****************
+ * User: B.Vereecke     Date: 29/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR852 : remove external library dependancy
+ *
+ * *****************  Version 14  *****************
+ * User: B.Vereecke    Date: 08/08/07   Time: 15:40
+ * Updated in $/Source/bsl/Src
+ * PR 563 : Unused shadow value for register
+ *          E_REG_P00_INT_FLAGS_2_RW
+ *
+ * *****************  Version 13  *****************
+ * User: Burnouf       Date: 18/04/07   Time: 15:50
+ * Updated in $/Source/bsl/Src
+ * PR 50 : Manage state ST_AWAIT_RX_SENSE for TDA9981
+ *
+ * *****************  Version 12  *****************
+ * User: Mayhew       Date: 21/09/06   Time: 15:50
+ * Updated in $/Source/bsl/Src
+ * Cut code size in demo by using RETIF_BADPARAM
+ *
+ * *****************  Version 10  *****************
+ * User: Mayhew       Date: 15/09/06   Time: 16:08
+ * Updated in $/Source/bsl/Src
+ * Reduce code size in setState by using local copies of DIS
+ *
+ * *****************  Version 8  *****************
+ * User: Mayhew       Date: 30/06/06   Time: 13:23
+ * Updated in $/Source/bsl/Src
+ * EV_HDCP_BKSV_SECURE renamed to EV_HDCP_BKSV_REPEAT
+ *
+ * *****************  Version 6  *****************
+ * User: Mayhew       Date: 6/06/06    Time: 13:40
+ * Updated in $/Source/bsl/Src
+ * Add checkUnitSetDis to reduce code size in most APIs
+ *
+ * *****************  Version 4  *****************
+ * User: Djw          Date: 24/05/06   Time: 11:20
+ * Updated in $/Source/bsl/Src
+ * Added E_PAGE_10 for new Infoframe registers in N4.
+ *
+ * *****************  Version 3  *****************
+ * User: Mayhew       Date: 10/05/06   Time: 17:09
+ * Updated in $/Source/bsl/Src
+ * Add HDCP state handling
+ *
+ * *****************  Version 2  *****************
+ * User: Djw          Date: 20/04/06   Time: 17:32
+ * Updated in $/Source/bsl/Src
+ * Modification to prevent reading of shadow copies of interrupt flag
+ * registers.
+ *
+ * *****************  Version 1  *****************
+ * User: Mayhew       Date: 4/04/06    Time: 16:30
+ * Created in $/Source/bsl/Src
+ * Driver local code & data phase 2
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                   FILE CONFIGURATION                                       */
+/*============================================================================*/
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_BADPARAM */
+
+/*============================================================================*/
+/*                   STANDARD INCLUDE FILES                                   */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PROJECT INCLUDE FILES                                    */
+/*============================================================================*/
+#include "tmbslHdmiTx.h"
+#include "tmbslHdmiTx_local.h"
+
+/*============================================================================*/
+/*                   MACRO DEFINITIONS                                        */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   TYPE DEFINITIONS                                         */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC VARIABLE DEFINITIONS                              */
+/*============================================================================*/
+
+/** The array of object instances for all concurrently supported HDMI
+ *  Transmitter units
+ * */
+RAM_DAT hdmi_txobject_t g_hdmi_tx_instance[HDMITX_UNITS_MAX];
+
+/**
+ * Lookup table to map register page index to actual page number
+ * */
+CONST_DAT u8 k_page_index_to_page[E_PAGE_NUM] = {
+	0x00,   /* E_PAGE_00 */
+	0x01,   /* E_PAGE_01 */
+	0x02,   /* E_PAGE_02 */
+	0x10,   /* E_PAGE_10 */
+	0x11,   /* E_PAGE_11 */
+	0x12    /* E_PAGE_12 */
+};
+
+/*============================================================================*/
+/*                   STATIC VARIABLE DECLARATIONS                             */
+/*============================================================================*/
+
+/**
+ * Lookup table to map an 8-bit mask to a number of left shifts
+ * needed to shift a value starting at bit 0 onto the mask.
+ * Indexed by mask 0-255. For example, mask 0x00 and 0x01 need
+ * no shift, mask 0x02 needs one shift, mask 0x03 needs no shift,
+ * mask 0x04 needs 2 shifts, etc.
+ * Rows were formatted by "HDMI Driver - Register List.xls" and pasted here
+ * */
+static CONST_DAT u8 k_mask_to_shift[256] = {
+	/* Mask index: */
+	/*x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF        */
+	0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 1x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 2x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 3x */
+	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 4x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 5x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 6x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 7x */
+	7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 8x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 9x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Ax */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Bx */
+	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Cx */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Dx */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Ex */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0  /* Fx */
+};
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DECLARATIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC FUNCTION DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/* checkUnitSetDis                                                            */
+/*============================================================================*/
+error_code_t
+check_unit_set_dis
+(
+    unit_select_t	 tx_unit,
+    hdmi_txobject_t **pp_dis
+)
+{
+	/* Return error if unit numbr is out of range */
+	RETIF(tx_unit < unit0, ERR_HDMI_BAD_UNIT_NUMBER)
+	RETIF(tx_unit >= HDMITX_UNITS_MAX, ERR_HDMI_BAD_UNIT_NUMBER)
+
+	/* Point to unit's Device Instance Structure */
+	*pp_dis = &g_hdmi_tx_instance[tx_unit];
+
+	/* Return if this device instance is not initialised */
+	RETIF(!(*pp_dis)->b_initialized, ERR_HDMI_NOT_INITIALIZED)
+
+	return 0;
+}
+
+/*============================================================================*/
+/* getHwRegisters                                                             */
+/*============================================================================*/
+error_code_t
+get_hw_registers
+(
+    hdmi_txobject_t *p_dis,
+    u16 reg_shad_page_addr,
+    u8 *p_data,
+    u16 len_data
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_shad;    /* The index to the register's shadow copy */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack 1st register's shadow index, page index and address */
+	reg_shad = SPA2SHAD(reg_shad_page_addr);
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Check length does not overflow page */
+	RETIF_BADPARAM((reg_addr + len_data) > E_REG_CURPAGE_ADR_W)
+
+	/* Check 1st reg does not have a shadow - whole range assumed likewise */
+	RETIF_BADPARAM(reg_shad != E_SNONE)
+
+	/* Set page register if required */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* Get I2C register range - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->u_hw_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = (u8)len_data;
+	sys_args.p_data           = p_data;
+	err = p_dis->sys_func_read(&sys_args);
+	return (err == 0) ? 0 : ERR_HDMI_I2C_READ;
+}
+
+/*============================================================================*/
+/* getHwRegister                                                              */
+/*============================================================================*/
+error_code_t
+get_hw_register
+(
+    hdmi_txobject_t *p_dis,
+    u16  reg_shad_page_addr,
+    u8   *p_reg_value
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_shad;    /* The index to the register's shadow copy */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack register shadow index, page index and address */
+	reg_shad = SPA2SHAD(reg_shad_page_addr);
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Set page register if required */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	if((reg_shad != E_SNONE)
+	   && (reg_shad_page_addr != E_REG_P00_INT_FLAGS_0_RW)
+	   && (reg_shad_page_addr != E_REG_P00_INT_FLAGS_1_RW)
+#ifdef TMFL_TDA9981_SUPPORT
+	   && (reg_shad_page_addr != E_REG_P00_INT_FLAGS_2_RW)
+#endif /* TMFL_TDA9981_SUPPORT */
+	  ) {
+		/* Get shadow copy - shadowed registers can't be read */
+		/* Don't read shadow copy of interrupt status flags! */
+		*p_reg_value = p_dis->shadow_reg[reg_shad];
+		return 0;
+	} else {
+		/* Get I2C register - all non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = reg_addr;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = p_reg_value;
+		err = p_dis->sys_func_read(&sys_args);
+		return (err == 0) ? 0 : ERR_HDMI_I2C_READ;
+	}
+}
+
+/*============================================================================*/
+/* setHwRegisters                                                             */
+/*============================================================================*/
+error_code_t
+set_hw_registers
+(
+    hdmi_txobject_t *p_dis,
+    u16 reg_shad_page_addr,
+    u8 *p_data,
+    u16 len_data
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_shad;    /* The index to the register's shadow copy */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack 1st register's shadow index, page index and address */
+	reg_shad = SPA2SHAD(reg_shad_page_addr);
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Check length does not overflow page */
+	RETIF_BADPARAM((reg_addr + len_data) > E_REG_CURPAGE_ADR_W)
+
+	/* Check 1st reg does not have a shadow - whole range assumed likewise */
+	RETIF_BADPARAM(reg_shad != E_SNONE)
+
+	/* Set page register if required - whole range is on same page */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* Write to I2C register range - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->u_hw_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = (u8)len_data;
+	sys_args.p_data           = p_data;
+	err = p_dis->sys_func_write(&sys_args);
+	return (err == 0) ? 0 : ERR_HDMI_I2C_WRITE;
+}
+
+/*============================================================================*/
+/* setHwRegisterMsbLsb                                                        */
+/*============================================================================*/
+error_code_t
+set_hw_register_msb_lsb
+(
+    hdmi_txobject_t *p_dis,
+    u16  reg_shad_page_addr,
+    u16  reg_word
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	u8           msb_lsb[2];  /* The bytes from regWord                  */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack register shadow index, page index and address */
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Unpack regWord bytes, MSB first */
+	msb_lsb[0] = (u8)(reg_word >> 8);
+	msb_lsb[1] = (u8)(reg_word & 0xFF);
+
+	/* Set page register if required */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* No word registers are shadowed */
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->u_hw_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 2;
+	sys_args.p_data           = &msb_lsb[0];
+	err = p_dis->sys_func_write(&sys_args);
+	return (err == 0) ? 0 : ERR_HDMI_I2C_WRITE;
+}
+
+/*============================================================================*/
+/* setHwRegister                                                              */
+/*============================================================================*/
+error_code_t
+set_hw_register
+(
+    hdmi_txobject_t *p_dis,
+    u16  reg_shad_page_addr,
+    u8   reg_value
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_shad;    /* The index to the register's shadow copy */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack register shadow index, page index and address */
+	reg_shad = SPA2SHAD(reg_shad_page_addr);
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Set page register if required */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	/* Set shadow copy */
+	if(reg_shad != E_SNONE) {
+		p_dis->shadow_reg[reg_shad] = reg_value;
+	}
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->u_hw_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = &reg_value;
+	err = p_dis->sys_func_write(&sys_args);
+	return (err == 0) ? 0 : ERR_HDMI_I2C_WRITE;
+}
+
+/*============================================================================*/
+/*  setHwRegisterField                                                        */
+/*============================================================================*/
+error_code_t
+set_hw_register_field
+(
+    hdmi_txobject_t *p_dis,
+    u16  reg_shad_page_addr,
+    u8   field_mask,
+    u8   field_value
+)
+{
+	error_code_t   err;        /* Error code */
+	u8           reg_shad;    /* The index to the register's shadow copy */
+	u8           reg_page;    /* The index to the register's page        */
+	u8           reg_addr;    /* The register's address on the page      */
+	u8           new_reg_page; /* The register's new page number          */
+	u8           reg_value;   /* The register's current value            */
+	bsl_sys_args_t sys_args; /* Arguments passed to system function   */
+
+	/* Unpack register shadow index, page index and address */
+	reg_shad = SPA2SHAD(reg_shad_page_addr);
+	reg_page = SPA2PAGE(reg_shad_page_addr);
+	reg_addr = SPA2ADDR(reg_shad_page_addr);
+	new_reg_page = k_page_index_to_page[reg_page];
+
+	/* Set page register if required */
+	if(p_dis->cur_reg_page != new_reg_page) {
+		/* All non-OK results are errors */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = E_REG_CURPAGE_ADR_W;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &new_reg_page;
+		err = p_dis->sys_func_write(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_WRITE)
+		p_dis->cur_reg_page = new_reg_page;
+	}
+
+	if(reg_shad != E_SNONE) {
+		/* Get shadow copy */
+		reg_value = p_dis->shadow_reg[reg_shad];
+	} else {
+		/* Read I2C register value.
+		 * All bitfield registers are either shadowed or can be read.
+		 *		 */
+		sys_args.slave_addr       = p_dis->u_hw_address;
+		sys_args.first_register   = reg_addr;
+		sys_args.len_data         = 1;
+		sys_args.p_data           = &reg_value;
+		err = p_dis->sys_func_read(&sys_args);
+		RETIF(err != 0, ERR_HDMI_I2C_READ)
+	}
+
+	/* Reset register bits that are set in the mask */
+	reg_value = reg_value & (u8)(~field_mask);
+
+	/* Shift the field value left to align its bits with the mask */
+	field_value <<= k_mask_to_shift[field_mask];
+
+	/* Reset shifted field bits that are not set in the mask */
+	field_value &= field_mask;
+
+	/* Set the shifted bitfield */
+	reg_value |= field_value;
+
+	/* Set shadow copy */
+	if(reg_shad != E_SNONE) {
+		p_dis->shadow_reg[reg_shad] = reg_value;
+	}
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->u_hw_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = &reg_value;
+	err = p_dis->sys_func_write(&sys_args);
+	return (err == 0) ? 0 : ERR_HDMI_I2C_WRITE;
+}
+
+/*============================================================================*/
+/* setHwRegisterFieldTable                                                    */
+/*============================================================================*/
+error_code_t
+set_hw_register_field_table
+(
+    hdmi_txobject_t *p_dis,
+    const hdmi_tx_reg_mask_val_t *p_table
+)
+{
+	error_code_t err; /* Error code */
+	int           i;   /* Table index */
+
+	/* Set register, mask and value from table until terminator is reached */
+	for(i = 0; p_table[i].reg > 0; i++) {
+		err = set_hw_register_field(p_dis, p_table[i].reg, p_table[i].mask, p_table[i].val);
+		RETIF(err != 0, err)
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* setState                                                                   */
+/*============================================================================*/
+error_code_t
+set_state
+(
+    hdmi_txobject_t   *p_dis,
+    bsl_event_t  event
+)
+{
+	bsl_state_t state = p_dis->state;
+	u8 n_ignored_events = p_dis->n_ignored_events;
+
+	switch(state) {
+	case ST_UNINITIALIZED:
+		switch(event) {
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_PLUGGEDIN:
+			state = ST_AWAIT_EDID;
+			break;
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_DISCONNECTED:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_PLUGGEDIN:
+			state = ST_AWAIT_EDID;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_AWAIT_EDID:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_GETBLOCKDATA:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#else /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		case EV_GETBLOCKDATA:
+			state = ST_SINK_CONNECTED;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+	case ST_AWAIT_RX_SENSE:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_SINKON:
+			state = ST_SINK_CONNECTED;
+			break;
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+	case ST_SINK_CONNECTED:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_SETINOUT:
+			state = ST_VIDEO_NO_HDCP;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_VIDEO_NO_HDCP:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_OUTDISABLE:
+			state = ST_SINK_CONNECTED;
+			break;
+		case EV_HDCP_RUN:
+			state = ST_HDCP_WAIT_RX;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_HDCP_WAIT_RX:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_HDCP_BKSV_NREPEAT:
+			state = ST_HDCP_AUTHENTICATED;
+			break;
+		case EV_HDCP_BKSV_REPEAT:
+			state = ST_HDCP_WAIT_BSTATUS;
+			break;
+		case EV_HDCP_BKSV_NSECURE:
+			state = ST_HDCP_WAIT_RX;
+			break;
+		case EV_HDCP_T0:
+			state = ST_HDCP_WAIT_RX;
+			break;
+		case EV_HDCP_STOP:
+			state = ST_VIDEO_NO_HDCP;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_HDCP_WAIT_BSTATUS:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_HDCP_BSTATUS_GOOD:
+			state = ST_HDCP_WAIT_SHA_1;
+			break;
+		case EV_HDCP_T0:
+			state = ST_HDCP_WAIT_RX;
+			break;
+		case EV_HDCP_STOP:
+			state = ST_VIDEO_NO_HDCP;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_HDCP_WAIT_SHA_1:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_HDCP_KSV_SECURE:
+			state = ST_HDCP_AUTHENTICATED;
+			break;
+		case EV_HDCP_T0:
+			state = ST_HDCP_WAIT_RX;
+			break;
+		case EV_HDCP_STOP:
+			state = ST_VIDEO_NO_HDCP;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_HDCP_AUTHENTICATED:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_STANDBY:
+			state = ST_STANDBY;
+			break;
+		case EV_HDCP_T0:
+			state = ST_HDCP_WAIT_RX;
+			break;
+		case EV_HDCP_STOP:
+			state = ST_VIDEO_NO_HDCP;
+			break;
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+		case EV_SINKOFF:
+			state = ST_AWAIT_RX_SENSE;
+			break;
+#endif /* TMFL_TDA9981_SUPPORT & TMFL_RX_SENSE_ON */
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_STANDBY:
+		switch(event) {
+		case EV_DEINIT:
+			state = ST_UNINITIALIZED;
+			break;
+		case EV_RESUME_UNPLUGGED:
+			state = ST_DISCONNECTED;
+			break;
+		case EV_RESUME_PLUGGEDIN:
+			state = ST_AWAIT_EDID;
+			break;
+		default:
+			n_ignored_events++;
+			break;
+		}
+		break;
+	case ST_INVALID:
+		n_ignored_events++;
+		break;
+	}
+	p_dis->state = state;
+	p_dis->n_ignored_events = n_ignored_events;
+	return 0;
+}
+
+/*============================================================================*/
+/* lmemcpy                                                                     */
+/*============================================================================*/
+error_code_t
+lmemcpy
+(
+    void *p_table1,
+    const void *p_table2,
+    uint size
+)
+{
+	char *ptr_source = (char *) p_table1;
+	char *end_source = (char *)p_table1 + size;
+	char *ptr_dest = (char *)p_table2;
+
+	RETIF_BADPARAM(p_table1 == NULL)
+	RETIF_BADPARAM(p_table2 == NULL)
+
+	while(end_source > ptr_source) {
+		*(ptr_source++) = *(ptr_dest++);
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/* lmemset                                                                     */
+/*============================================================================*/
+error_code_t
+lmemset
+(
+    void *p_table1,
+    const u8 value,
+    uint size
+)
+{
+	char *ptr_source = (char *) p_table1;
+	char *end_source = (char *)p_table1 + size;
+
+	RETIF_BADPARAM(p_table1 == NULL)
+
+	while(end_source > ptr_source) {
+		*(ptr_source++) = value;
+	}
+	return 0;
+}
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DEFINTIONS                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                     END OF FILE                                            */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.h b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.h
new file mode 100755
index 0000000..0ea2553
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmbslTDA9983/src/tmbslHdmiTx_local.h
@@ -0,0 +1,1967 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          bsl_local.h
+ *
+ * \version       $Revision: 66 $
+ *
+ * \date          $Date: 29/10/07 14:11 $
+ *
+ * \brief         BSL driver component local definitions for the TDA998x
+ *                HDMI Transmitter.
+ *
+ * \section refs  Reference Documents
+ * HDMI Driver - Outline Architecture.doc,
+ * HDMI Driver - bsl - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *   $History: bsl_local.h $
+ *
+ * *****************  Version 66  ****************
+ * User: B.Vereecke     Date: 29/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR852 : remove external library dependancy
+ *
+ * *****************  Version 65  ****************
+ * User: B.Vereecke     Date: 17/10/07   Time: 14:11
+ * Updated in $/Source/bsl/src
+ * PR872 : add new formats, 1080p24/25/30
+ *
+ * *****************  Version 64  *****************
+ * User: B.Vereecke    Date: 11/09/07   Time: 15:15
+ * Updated in $/Source/bsl/Src
+ * PR679: Update version to 3.9
+ *
+ * *****************  Version 63  *****************
+ * User: B.Vereecke    Date: 07/09/07   Time: 16:23
+ * Updated in $/Source/bsl/Src
+ * PR670 : Add PC Format : 1280x1024@75Hz
+ *
+ * *****************  Version 62  *****************
+ * User: B.Vereecke    Date: 27/07/07   Time: 11:23
+ * Updated in $/Source/bsl/Src
+ * PR536 : Update version to 2.69
+ *
+ * *****************  Version 61  *****************
+ * User: B.Vereecke    Date: 17/07/07   Time: 10:30
+ * Updated in $/Source/bsl/Src
+ * PR 217 : Add a new flag in tmHdmiTxobject_t
+ *
+ * *****************  Version 60  *****************
+ * User: J. Lamotte    Date: 26/06/07   Time: 11:37
+ * Updated in $/Source/bsl/Src
+ * PR 459 : Update version to 3.7
+ *
+ * *****************  Version 59  *****************
+ * User: J. Lamotte    Date: 13/06/07   Time: 17:00
+ * Updated in $/Source/bsl/Src
+ * PR 401 : Update version to 3.6
+ *
+ * *****************  Version 58  *****************
+ * User: J. Lamotte    Date: 13/06/07   Time: 12:00
+ * Updated in $/Source/bsl/Src
+ * PR 397 : Merge with PR 391 (ST_CONNECTED rename
+ *          to ST_SINK_CONNECTED)
+ *
+ * *****************  Version 57  *****************
+ * User: Burnouf       Date: 08/06/07   Time: 15:50
+ * Updated in $/Source/bsl/Src
+ * PR 347 : Add new PC formats
+ *
+ * *****************  Version 56  *****************
+ * User: J. Lamotte    Date: 24/05/07   Time: 14:45
+ * Updated in $/Source/bsl/Src
+ * PR 50 : Update version to 3.5
+ *
+ * *****************  Version 55  *****************
+ * User: J. Lamotte    Date: 03/05/07   Time: 13:55
+ * Updated in $/Source/bsl/Src
+ * PR 50 : Update E_DEV_VERSION_N4 and E_DEV_VERSION_LIST_END
+ *         in _eDevVersion enum for TDA9981 chip detection
+ *
+ * *****************  Version 54  *****************
+ * User: Burnouf       Date: 18/04/07   Time: 15:50
+ * Updated in $/Source/bsl/Src
+ * PR 50 : Add new state ST_AWAIT_RX_SENSE and
+ *         add new events EV_SINKON and EV_SINKOFF for TDA9981
+ *
+ * *****************  Version 53  *****************
+ * User: J. Lamotte      Date: 17/04/07   Time: 13:00
+ * Updated in $/Source/bsl/src
+ * PR50 - disable scaler for TDA9981
+ *      - undefined page 1 register for TDA9981
+ * Driver 3.2
+ *
+ * *****************  Version 52  *****************
+ * User: J. Lamotte      Date: 16/04/07   Time: 11:30
+ * Updated in $/Source/bsl/src
+ * PR50 - move define of HDMITX_UNITS_MAX in
+ *        tmblsHdmiTx.h
+ * Driver 3.2
+ *
+ * *****************  Version 51  *****************
+ * User: J. Lamotte     Date: 25/04/07   Time: 14:50
+ * Updated in $/Source/bsl/src
+ * PR273 - add PLL configuration before soft reset
+ *         in function bslInit
+ * Driver 3.4
+ *
+ * *****************  Version 50  *****************
+ * User: J. Lamotte      Date: 13/04/07   Time: 17:30
+ * Updated in $/Source/bsl/src
+ * PR50 - add registers for TDA9981
+ * Driver 3.2
+ *
+ * *****************  Version 49  *****************
+ * User: C. Logiou      Date: 08/03/07   Time: 16:52
+ * Updated in $/Source/bsl/src
+ * PR214 - add new input format repeated 480i/576i
+ * Driver 3.2
+ *
+ * *****************  Version 48  *****************
+ * User: Burnouf      Date: 01/03/07   Time: 16:15
+ * Updated in $/Source/bsl/Src
+ * PR207
+ * Driver 3.1
+ *
+ * *****************  Version 48  *****************
+ * User: Burnouf      Date: 06/02/07   Time: 16:15
+ * Updated in $/Source/bsl/Src
+ * PR49 : add PC Formats
+ * Driver 3.0
+ *
+ * *****************  Version 47  *****************
+ * User: Burnouf      Date: 29/01/07   Time: 16:15
+ * Updated in $/Source/bsl/Src
+ * Driver 2.9
+ *
+ * *****************  Version 46  *****************
+ * User: Burnouf      Date: 08/01/07   Time: 16:15
+ * Updated in $/Source/bsl/Src
+ * Driver 2.8
+ *
+ * *****************  Version 45  *****************
+ * User: Burnouf      Date: 14/12/06   Time: 10:03
+ * Updated in $/Source/bsl/Src
+ * Driver 2.7
+ *
+ * *****************  Version 44  *****************
+ * User: Burnouf      Date: 11/12/06   Time: 11:08
+ * Updated in $/Source/bsl/Src
+ * Driver 2.6
+ *
+ * *****************  Version 43  *****************
+ * User: Burnouf      Date: 07/12/06   Time: 14:20
+ * Updated in $/Source/bsl/Src
+ * Driver 2.5
+ *
+ * *****************  Version 42  *****************
+ * User: Burnouf      Date: 29/11/06   Time: 17:07
+ * Updated in $/Source/bsl/Src
+ * Driver 2.4
+ *
+ * *****************  Version 41  *****************
+ * User: Mayhew       Date: 23/11/06   Time: 15:07
+ * Updated in $/Source/bsl/Src
+ * Driver 2.3
+ *
+ * *****************  Version 39  *****************
+ * User: Djw          Date: 22/11/06   Time: 11:37
+ * Updated in $/Source/bsl/Src
+ * PNF74 Changes to serial clock divider values in setPixelRepeat
+ *
+ * *****************  Version 37  *****************
+ * User: Mayhew       Date: 10/11/06   Time: 10:14
+ * Updated in $/Source/bsl/Src
+ * PNF68 RETIF_REG_FAIL macro added, controlled by compiler command line
+ * symbol NO_RETIF_REG_FAIL
+ * PNF68 DIS members funcScheduled, uFuncScheduledMs replaced by HdcpFunc*
+ * and HdcpCheck* members
+ *
+ * *****************  Version 36  *****************
+ * User: Mayhew       Date: 6/11/06    Time: 17:49
+ * Updated in $/Source/bsl/Src
+ * PNF68 Add funcScheduled and uFuncScheduledMs to DIS
+ *
+ * *****************  Version 34  *****************
+ * User: Mayhew       Date: 2/11/06    Time: 17:05
+ * Updated in $/Source/bsl/Src
+ * Version 2.1
+ *
+ * *****************  Version 32  *****************
+ * User: Mayhew       Date: 31/10/06   Time: 16:23
+ * Updated in $/Source/bsl/Src
+ * Version 2.0
+ *
+ * *****************  Version 30  *****************
+ * User: Mayhew       Date: 27/10/06   Time: 12:33
+ * Updated in $/Source/bsl/Src
+ * Version 1.9
+ *
+ * *****************  Version 28  *****************
+ * User: Mayhew       Date: 23/10/06   Time: 16:41
+ * Updated in $/Source/bsl/Src
+ * Driver version 1.8
+ *
+ * *****************  Version 26  *****************
+ * User: Mayhew       Date: 13/10/06   Time: 11:19
+ * Updated in $/Source/bsl/Src
+ * Version 1.7. PNF40 Rename P11_CH_STAT registers correctly
+ *
+ * *****************  Version 24  *****************
+ * User: Mayhew       Date: 21/09/06   Time: 15:50
+ * Updated in $/Source/bsl/Src
+ * Version 1.6. Cut code size in demo by using RETIF_BADPARAM.
+ *
+ * *****************  Version 22  *****************
+ * User: Mayhew       Date: 15/09/06   Time: 16:10
+ * Updated in $/Source/bsl/Src
+ * PNF22 Add HdcpRi & HdcpFsmState to DIS
+ * Version 1.5. Fix QAC warning.
+ *
+ * *****************  Version 20  *****************
+ * User: Mayhew       Date: 7/09/06    Time: 9:43
+ * Updated in $/Source/bsl/Src
+ * Minor version now 4
+ *
+ * *****************  Version 18  *****************
+ * User: Djw          Date: 24/08/06   Time: 12:12
+ * Updated in $/Source/bsl/Src
+ * PNF8 Use TX33 register in NO_HDCP build.
+ * PNF14 Add DIS.pixelRepeatCount.
+ *
+ * *****************  Version 17  *****************
+ * User: Djw          Date: 22/08/06   Time: 9:58
+ * Updated in $/Source/bsl/Src
+ * NO_HDCP modifications
+ *
+ * *****************  Version 16  *****************
+ * User: Mayhew       Date: 10/07/06   Time: 13:18
+ * Updated in $/Source/bsl/Src
+ * Minor version now 2. Add #define BCAPS_REPEATER.
+ * Add N5 registers and feature flag. Fix Doxygen warnings.
+ *
+ * *****************  Version 14  *****************
+ * User: Mayhew       Date: 30/06/06   Time: 12:55
+ * Updated in $/Source/bsl/Src
+ * Minor version now 1. BKSV_SECURE event renamed to BKSV_REPEAT.
+ * HDCP_BCAPS register is now shadowed and has new _repeater bit.
+ * Add N4 CH_STAT registers. EdidSinkType replaced by SinkType.
+ * Add DIS.HdcpAksv.
+ *
+ * *****************  Version 12  *****************
+ * User: Djw          Date: 16/06/06   Time: 12:04
+ * Updated in $/Source/bsl/Src
+ * Added flag to DIS to support use of alternate i2c address for EDID.
+ *
+ * *****************  Version 10  *****************
+ * User: Mayhew       Date: 6/06/06    Time: 13:41
+ * Updated in $/Source/bsl/Src
+ * Add checkUnitSetDis. Remove erroneous NOT_SUPPORTED definition.
+ *
+ * *****************  Version 9  *****************
+ * User: Mayhew       Date: 5/06/06    Time: 15:06
+ * Updated in $/Source/bsl/Src
+ * Move error code definitions to bsl.h, replace with #if checks
+ * Add DIS.HdcpT0FailState.
+ *
+ * *****************  Version 7  *****************
+ * User: Djw          Date: 24/05/06   Time: 11:23
+ * Updated in $/Source/bsl/Src
+ * Added new registers for N4 (page 10h Infoframes).  Added 2nd Ghost
+ * register.  Reset names for ISRC1 and ACP packet registers for N4
+ * compatibility.
+ *
+ * *****************  Version 5  *****************
+ * User: Mayhew       Date: 22/05/06   Time: 15:58
+ * Updated in $/Source/bsl/Src
+ * Add DIS.uDeviceFeatures. Add N4 to version list. Add version register
+ * masks for N4.
+ *
+ * *****************  Version 4  *****************
+ * User: Mayhew       Date: 10/05/06   Time: 17:10
+ * Updated in $/Source/bsl/Src
+ * Add HDCP state handling and DIS members, move EDID status enum to .h
+ *
+ * *****************  Version 3  *****************
+ * User: Djw          Date: 20/04/06   Time: 17:31
+ * Updated in $/Source/bsl/Src
+ * Minor comment correction for EDID DTD in DIS.
+ *
+ * *****************  Version 2  *****************
+ * User: Mayhew       Date: 11/04/06   Time: 14:19
+ * Updated in $/Source/bsl/Src
+ * Add upsampleMode to Device Instance Structure
+ *
+ * *****************  Version 1  *****************
+ * User: Mayhew       Date: 4/04/06    Time: 16:30
+ * Created in $/Source/bsl/Src
+ * Driver local API phase 2
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef BSLHDMITX_LOCAL_H
+#define BSLHDMITX_LOCAL_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+/* for remove warning */
+#define DUMMY_ACCESS(x) x
+
+/* Defining this symbol here enables the BCAPS Repeater mod for N4 onwards */
+#ifndef BCAPS_REPEATER
+#define BCAPS_REPEATER
+#endif
+
+/** \name Versions
+ *  A group of macros to set the software component number and version
+ * */
+/*@{*/
+/** Compatibility number */
+#define HDMITX_BSL_COMP_NUM             1
+
+/** Major software version 1 to 255 */
+#define HDMITX_BSL_MAJOR_VER            4
+
+/** Minor software version 0 to 9 */
+#define HDMITX_BSL_MINOR_VER            18
+/*@}*/
+
+/** \name ErrorChecks
+ *  A group of checks ensuring that public error codes match DVP standard errors
+ * */
+/*@{*/
+/** SW interface compatibility error */
+#if ERR_HDMI_COMPATIBILITY != \
+(ERR_HDMI_BASE + ERR_COMPATIBILITY)
+#error
+#endif
+
+/** SW major version error */
+#if ERR_HDMI_MAJOR_VERSION != \
+(ERR_HDMI_BASE + ERR_MAJOR_VERSION)
+#error
+#endif
+
+/** SW component version error */
+#if ERR_HDMI_COMP_VERSION != \
+(ERR_HDMI_BASE + ERR_COMP_VERSION)
+#error
+#endif
+
+/** Invalid device unit number */
+#if ERR_HDMI_BAD_UNIT_NUMBER != \
+(ERR_HDMI_BASE + ERR_BAD_UNIT_NUMBER)
+#error
+#endif
+
+/** Invalid input parameter other than unit number */
+#if ERR_HDMI_BAD_PARAMETER != \
+(ERR_HDMI_BASE + ERR_BAD_PARAMETER)
+#error
+#endif
+
+/** Inconsistent input parameters */
+#if ERR_HDMI_INCONSISTENT_PARAMS != \
+(ERR_HDMI_BASE + ERR_INCONSISTENT_PARAMS)
+#error
+#endif
+
+/** Component is not initialized */
+#if ERR_HDMI_NOT_INITIALIZED != \
+(ERR_HDMI_BASE + ERR_NOT_INITIALIZED)
+#error
+#endif
+
+/** Command not supported for current device */
+#if ERR_HDMI_NOT_SUPPORTED != \
+(ERR_HDMI_BASE + ERR_NOT_SUPPORTED)
+#error
+#endif
+
+/** Initialization failed */
+#if ERR_HDMI_INIT_FAILED != \
+(ERR_HDMI_BASE + ERR_INIT_FAILED)
+#error
+#endif
+
+/** Component is busy and cannot do a new operation */
+#if ERR_HDMI_BUSY != \
+(ERR_HDMI_BASE + ERR_BUSY)
+#error
+#endif
+
+/** I2C read error */
+#if ERR_HDMI_I2C_READ != \
+(ERR_HDMI_BASE + ERR_READ)
+#error
+#endif
+
+/** I2C write error */
+#if ERR_HDMI_I2C_WRITE != \
+(ERR_HDMI_BASE + ERR_WRITE)
+#error
+#endif
+
+/** Assertion failure */
+#if ERR_HDMI_ASSERTION != \
+(ERR_HDMI_BASE + ERR_ASSERTION)
+#error
+#endif
+
+/** Bad EDID block checksum */
+#if ERR_HDMI_INVALID_CHECKSUM != \
+(ERR_HDMI_BASE + ERR_INVALID_STATE)
+#error
+#endif
+
+/** No connection to HPD pin */
+#if ERR_HDMI_NULL_CONNECTION != \
+(ERR_HDMI_BASE + ERR_NULL_CONNECTION)
+#error
+#endif
+
+/** Not allowed in DVI mode */
+#if ERR_HDMI_OPERATION_NOT_PERMITTED != \
+(ERR_HDMI_BASE + ERR_OPERATION_NOT_PERMITTED)
+#error
+#endif
+/*@}*/
+
+/**
+ * A macro to check a condition and if true return a result
+ * */
+#define RETIF(cond, rslt)       if ((cond)){return (rslt);}
+
+/**
+ * A macro to check a condition and if true return
+ * ERR_HDMI_BAD_PARAMETER.
+ * To save code space, it can be compiled out by defining NO_RETIF_BADPARAM on
+ * the compiler command line.
+ * */
+#ifdef NO_RETIF_BADPARAM
+#define RETIF_BADPARAM(cond)
+#else
+#define RETIF_BADPARAM(cond)  if ((cond)){return ERR_HDMI_BAD_PARAMETER;}
+#endif
+
+/**
+ * A macro to check the result of a register API and if not 0 to return it.
+ * To save code space, it can be compiled out by defining NO_RETIF_REG_FAIL on
+ * the compiler command line.
+ * */
+#ifdef NO_RETIF_REG_FAIL
+#define RETIF_REG_FAIL(result)
+#else
+#define RETIF_REG_FAIL(result)  if ((result) != TM_OK){return (result);}
+#endif
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/**
+ * Driver events and states used for diagnosis
+ * */
+typedef enum _bsl_event {
+	EV_DEINIT               = 0,
+	EV_UNPLUGGED            = 1,
+	EV_PLUGGEDIN            = 2,
+	EV_STANDBY              = 3,
+	EV_RESUME_UNPLUGGED     = 4,
+	EV_RESUME_PLUGGEDIN     = 5,
+	EV_GETBLOCKDATA         = 6,
+	EV_SETINOUT             = 7,
+	EV_OUTDISABLE           = 8,
+	EV_HDCP_RUN             = 9,
+	EV_HDCP_BKSV_NREPEAT    = 10,
+	EV_HDCP_BKSV_NSECURE    = 11,
+	EV_HDCP_BKSV_REPEAT     = 12,
+	EV_HDCP_BSTATUS_GOOD    = 13,
+	EV_HDCP_KSV_SECURE      = 14,
+	EV_HDCP_T0              = 15,
+	EV_HDCP_STOP            = 16,
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+	EV_SINKON               = 17,
+	EV_SINKOFF              = 18,
+	EV_INVALID              = 19
+#else /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+	EV_INVALID              = 17
+#endif /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+} bsl_event_t;
+
+typedef enum _bsl_state {
+	ST_UNINITIALIZED        = 0,
+	ST_DISCONNECTED         = 1,
+	ST_AWAIT_EDID           = 2,
+	ST_SINK_CONNECTED       = 3,
+	ST_VIDEO_NO_HDCP        = 4,
+	ST_STANDBY              = 5,
+	ST_HDCP_WAIT_RX         = 6,
+	ST_HDCP_WAIT_BSTATUS    = 7,
+	ST_HDCP_WAIT_SHA_1      = 8,
+	ST_HDCP_AUTHENTICATED   = 9,
+#if defined (TMFL_TDA9981_SUPPORT) && defined(TMFL_RX_SENSE_ON)
+	ST_AWAIT_RX_SENSE       = 10,
+	ST_INVALID              = 11,
+	ST_NUM                  = 11
+#else /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+	ST_INVALID              = 10,
+	ST_NUM                  = 10
+#endif /* TMFL_TDA9981_SUPPORT && TMFL_RX_SENSE_ON */
+} bsl_state_t;
+
+/**
+ * An enum to index into the Device Instance Data shadowReg array
+ * */
+enum _e_shad {
+#ifdef TMFL_TDA9981_SUPPORT
+	E_SP00_MAIN_CNTRL0  = 0,
+	E_SP00_INT_FLAGS_0  = 1,
+	E_SP00_INT_FLAGS_1  = 2,
+	E_SP00_INT_FLAGS_2  = 3,
+	E_SP00_VIP_CNTRL_0  = 4,
+	E_SP00_VIP_CNTRL_1  = 5,
+	E_SP00_VIP_CNTRL_2  = 6,
+	E_SP00_VIP_CNTRL_3  = 7,
+	E_SP00_VIP_CNTRL_4  = 8,
+	E_SP00_VIP_CNTRL_5  = 9,
+	E_SP00_MAT_CONTRL   = 10,
+	E_SP00_TBG_CNTRL_0  = 11,
+	E_SP00_TBG_CNTRL_1  = 12,
+	E_SP00_HVF_CNTRL_0  = 13,
+	E_SP00_HVF_CNTRL_1  = 14,
+	E_SP00_TIMER_H      = 15,
+	E_SP00_DEBUG_PROBE  = 16,
+	E_SP00_AIP_CLKSEL   = 17,
+	E_SNUM              = 18,   /* Number of shadow registers */
+	E_SNONE             = 18    /* Index value indicating no shadow register */
+#else
+	E_SP00_MAIN_CNTRL0  = 0,
+	E_SP00_INT_FLAGS_0  = 1,
+	E_SP00_INT_FLAGS_1  = 2,
+	E_SP00_VIP_CNTRL_0  = 3,
+	E_SP00_VIP_CNTRL_1  = 4,
+	E_SP00_VIP_CNTRL_2  = 5,
+	E_SP00_VIP_CNTRL_3  = 6,
+	E_SP00_VIP_CNTRL_4  = 7,
+	E_SP00_VIP_CNTRL_5  = 8,
+	E_SP00_MAT_CONTRL   = 9,
+	E_SP00_TBG_CNTRL_0  = 10,
+	E_SP00_TBG_CNTRL_1  = 11,
+	E_SP00_HVF_CNTRL_0  = 12,
+	E_SP00_HVF_CNTRL_1  = 13,
+	E_SP00_TIMER_H      = 14,
+	E_SP00_DEBUG_PROBE  = 15,
+	E_SP00_AIP_CLKSEL   = 16,
+	E_SP01_SC_VIDFORMAT = 17,
+	E_SP01_SC_CNTRL     = 18,
+	E_SP01_TBG_CNTRL_0  = 19,
+	E_SNUM              = 20,   /* Number of shadow registers */
+	E_SNONE             = 20    /* Index value indicating no shadow register */
+#endif /* TMFL_TDA9981_SUPPORT */
+};
+
+/**
+ * Page list
+ * These are indexes to the allowed register page numbers
+ * */
+enum _e_page {
+	E_PAGE_00      = 0,
+	E_PAGE_01      = 1,
+	E_PAGE_02      = 2,
+	E_PAGE_10      = 3,         /* New for N4 */
+	E_PAGE_11      = 4,
+	E_PAGE_12      = 5,
+	E_PAGE_NUM     = 6,         /* Number of pages */
+	E_PAGE_INVALID = 6          /* Index value indicating invalid page */
+};
+
+/**
+ * Macros to initialize and access the following register list enum _eReg
+ * */
+/* Pack shadow index s, page index p and register address a into u16 */
+#define SPA(s,p,a)       (u16)(((s)<<11)|((p)<<8)|(a))
+/* Unpacks shadow index s from u16 */
+#define SPA2SHAD(spa)    (u8)((spa)>>11)
+/* Unpacks page index p from u16 */
+#define SPA2PAGE(spa)    (u8)(((spa)>>8)&0x0007)
+/* Unpacks register address a from u16 */
+#define SPA2ADDR(spa)    (u8)((spa)&0x00FF)
+
+/**
+ * Register list
+ *
+ * Each register symbol has these fields: E_REG_page_register_access
+ *
+ * The symbols have a 16-bit value as follows, including an index to
+ * the Device Instance Data shadowReg[] array:
+ *
+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ * |15 |14 |13 |12 |11 |10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ * |  Shadow Index     |Page Index |       Register Address        |
+ * +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ *
+ * */
+enum _e_reg {
+	/*************************************************************************/
+	/** Rows formatted in "HDMI Driver - Register List.xls" and pasted here **/
+	/*************************************************************************/
+	E_REG_MIN_ADR                   = 0x00, /* First register on all pages   */
+	E_REG_CURPAGE_ADR_W             = 0xFF, /* Address register on all pages */
+
+	E_REG_P00_VERSION_R             = SPA(E_SNONE            , E_PAGE_00, 0x00),
+	E_REG_P00_MAIN_CNTRL0_W         = SPA(E_SP00_MAIN_CNTRL0 , E_PAGE_00, 0x01),
+#ifdef TMFL_TDA9981_SUPPORT
+	E_REG_P00_SR_REG_W              = SPA(E_SNONE            , E_PAGE_00, 0x0A),
+	E_REG_P00_DDC_DISABLE_RW        = SPA(E_SNONE            , E_PAGE_00, 0x0B),
+	E_REG_P00_CCLK_ON_RW            = SPA(E_SNONE            , E_PAGE_00, 0x0C),
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_REG_P00_INT_FLAGS_0_RW        = SPA(E_SP00_INT_FLAGS_0 , E_PAGE_00, 0x0F),
+	E_REG_P00_INT_FLAGS_1_RW        = SPA(E_SP00_INT_FLAGS_1 , E_PAGE_00, 0x10),
+#ifdef TMFL_TDA9981_SUPPORT
+	E_REG_P00_INT_FLAGS_2_RW        = SPA(E_SP00_INT_FLAGS_2 , E_PAGE_00, 0x11),
+	E_REG_P00_INT_FLAGS_3_R         = SPA(E_SNONE            , E_PAGE_00, 0x12),
+	E_REG_P00_SW_INT_W              = SPA(E_SNONE            , E_PAGE_00, 0x15),
+	E_REG_P00_ENA_VP_0_RW           = SPA(E_SNONE            , E_PAGE_00, 0x18),
+	E_REG_P00_ENA_VP_1_RW           = SPA(E_SNONE            , E_PAGE_00, 0x19),
+	E_REG_P00_ENA_VP_2_RW           = SPA(E_SNONE            , E_PAGE_00, 0x1A),
+	E_REG_P00_GND_VP_0_RW           = SPA(E_SNONE            , E_PAGE_00, 0x1B),
+	E_REG_P00_GND_VP_1_RW           = SPA(E_SNONE            , E_PAGE_00, 0x1C),
+	E_REG_P00_GND_VP_2_RW           = SPA(E_SNONE            , E_PAGE_00, 0x1D),
+	E_REG_P00_ENA_AP_RW             = SPA(E_SNONE            , E_PAGE_00, 0x1E),
+	E_REG_P00_GND_AP_RW             = SPA(E_SNONE            , E_PAGE_00, 0x1F),
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_REG_P00_VIP_CNTRL_0_W         = SPA(E_SP00_VIP_CNTRL_0 , E_PAGE_00, 0x20),
+	E_REG_P00_VIP_CNTRL_1_W         = SPA(E_SP00_VIP_CNTRL_1 , E_PAGE_00, 0x21),
+	E_REG_P00_VIP_CNTRL_2_W         = SPA(E_SP00_VIP_CNTRL_2 , E_PAGE_00, 0x22),
+	E_REG_P00_VIP_CNTRL_3_W         = SPA(E_SP00_VIP_CNTRL_3 , E_PAGE_00, 0x23),
+	E_REG_P00_VIP_CNTRL_4_W         = SPA(E_SP00_VIP_CNTRL_4 , E_PAGE_00, 0x24),
+	E_REG_P00_VIP_CNTRL_5_W         = SPA(E_SP00_VIP_CNTRL_5 , E_PAGE_00, 0x25),
+	E_REG_P00_MAT_CONTRL_W          = SPA(E_SP00_MAT_CONTRL  , E_PAGE_00, 0x80),
+	E_REG_P00_MAT_OI1_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x81),
+	E_REG_P00_MAT_OI1_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x82),
+	E_REG_P00_MAT_OI2_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x83),
+	E_REG_P00_MAT_OI2_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x84),
+	E_REG_P00_MAT_OI3_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x85),
+	E_REG_P00_MAT_OI3_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x86),
+	E_REG_P00_MAT_P11_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x87),
+	E_REG_P00_MAT_P11_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x88),
+	E_REG_P00_MAT_P12_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x89),
+	E_REG_P00_MAT_P12_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8A),
+	E_REG_P00_MAT_P13_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8B),
+	E_REG_P00_MAT_P13_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8C),
+	E_REG_P00_MAT_P21_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8D),
+	E_REG_P00_MAT_P21_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8E),
+	E_REG_P00_MAT_P22_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x8F),
+	E_REG_P00_MAT_P22_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x90),
+	E_REG_P00_MAT_P23_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x91),
+	E_REG_P00_MAT_P23_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x92),
+	E_REG_P00_MAT_P31_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x93),
+	E_REG_P00_MAT_P31_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x94),
+	E_REG_P00_MAT_P32_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x95),
+	E_REG_P00_MAT_P32_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x96),
+	E_REG_P00_MAT_P33_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x97),
+	E_REG_P00_MAT_P33_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x98),
+	E_REG_P00_MAT_OO1_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x99),
+	E_REG_P00_MAT_OO1_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x9A),
+	E_REG_P00_MAT_OO2_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x9B),
+	E_REG_P00_MAT_OO2_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x9C),
+	E_REG_P00_MAT_OO3_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x9D),
+	E_REG_P00_MAT_OO3_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0x9E),
+	E_REG_P00_VIDFORMAT_W           = SPA(E_SNONE            , E_PAGE_00, 0xA0),
+	E_REG_P00_REFPIX_MSB_W          = SPA(E_SNONE            , E_PAGE_00, 0xA1),
+	E_REG_P00_REFPIX_LSB_W          = SPA(E_SNONE            , E_PAGE_00, 0xA2),
+	E_REG_P00_REFLINE_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0xA3),
+	E_REG_P00_REFLINE_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0xA4),
+	E_REG_P00_NPIX_MSB_W            = SPA(E_SNONE            , E_PAGE_00, 0xA5),
+	E_REG_P00_NPIX_LSB_W            = SPA(E_SNONE            , E_PAGE_00, 0xA6),
+	E_REG_P00_NLINE_MSB_W           = SPA(E_SNONE            , E_PAGE_00, 0xA7),
+	E_REG_P00_NLINE_LSB_W           = SPA(E_SNONE            , E_PAGE_00, 0xA8),
+	E_REG_P00_VS_LINE_STRT_1_MSB_W  = SPA(E_SNONE            , E_PAGE_00, 0xA9),
+	E_REG_P00_VS_LINE_STRT_1_LSB_W  = SPA(E_SNONE            , E_PAGE_00, 0xAA),
+	E_REG_P00_VS_PIX_STRT_1_MSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xAB),
+	E_REG_P00_VS_PIX_STRT_1_LSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xAC),
+	E_REG_P00_VS_LINE_END_1_MSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xAD),
+	E_REG_P00_VS_LINE_END_1_LSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xAE),
+	E_REG_P00_VS_PIX_END_1_MSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xAF),
+	E_REG_P00_VS_PIX_END_1_LSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xB0),
+	E_REG_P00_VS_LINE_STRT_2_MSB_W  = SPA(E_SNONE            , E_PAGE_00, 0xB1),
+	E_REG_P00_VS_LINE_STRT_2_LSB_W  = SPA(E_SNONE            , E_PAGE_00, 0xB2),
+	E_REG_P00_VS_PIX_STRT_2_MSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xB3),
+	E_REG_P00_VS_PIX_STRT_2_LSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xB4),
+	E_REG_P00_VS_LINE_END_2_MSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xB5),
+	E_REG_P00_VS_LINE_END_2_LSB_W   = SPA(E_SNONE            , E_PAGE_00, 0xB6),
+	E_REG_P00_VS_PIX_END_2_MSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xB7),
+	E_REG_P00_VS_PIX_END_2_LSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xB8),
+	E_REG_P00_HS_PIX_START_MSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xB9),
+	E_REG_P00_HS_PIX_START_LSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xBA),
+	E_REG_P00_HS_PIX_STOP_MSB_W     = SPA(E_SNONE            , E_PAGE_00, 0xBB),
+	E_REG_P00_HS_PIX_STOP_LSB_W     = SPA(E_SNONE            , E_PAGE_00, 0xBC),
+	E_REG_P00_VWIN_START_1_MSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xBD),
+	E_REG_P00_VWIN_START_1_LSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xBE),
+	E_REG_P00_VWIN_END_1_MSB_W      = SPA(E_SNONE            , E_PAGE_00, 0xBF),
+	E_REG_P00_VWIN_END_1_LSB_W      = SPA(E_SNONE            , E_PAGE_00, 0xC0),
+	E_REG_P00_VWIN_START_2_MSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xC1),
+	E_REG_P00_VWIN_START_2_LSB_W    = SPA(E_SNONE            , E_PAGE_00, 0xC2),
+	E_REG_P00_VWIN_END_2_MSB_W      = SPA(E_SNONE            , E_PAGE_00, 0xC3),
+	E_REG_P00_VWIN_END_2_LSB_W      = SPA(E_SNONE            , E_PAGE_00, 0xC4),
+	E_REG_P00_DE_START_MSB_W        = SPA(E_SNONE            , E_PAGE_00, 0xC5),
+	E_REG_P00_DE_START_LSB_W        = SPA(E_SNONE            , E_PAGE_00, 0xC6),
+	E_REG_P00_DE_STOP_MSB_W         = SPA(E_SNONE            , E_PAGE_00, 0xC7),
+	E_REG_P00_DE_STOP_LSB_W         = SPA(E_SNONE            , E_PAGE_00, 0xC8),
+	E_REG_P00_COLBAR_WIDTH_W        = SPA(E_SNONE            , E_PAGE_00, 0xC9),
+	E_REG_P00_TBG_CNTRL_0_W         = SPA(E_SP00_TBG_CNTRL_0 , E_PAGE_00, 0xCA),
+	E_REG_P00_TBG_CNTRL_1_W         = SPA(E_SP00_TBG_CNTRL_1 , E_PAGE_00, 0xCB),
+	E_REG_P00_VBL_OFFSET_START_W    = SPA(E_SNONE            , E_PAGE_00, 0xCC),
+	E_REG_P00_VBL_OFFSET_END_W      = SPA(E_SNONE            , E_PAGE_00, 0xCD),
+	E_REG_P00_HBL_OFFSET_START_W    = SPA(E_SNONE            , E_PAGE_00, 0xCE),
+	E_REG_P00_HBL_OFFSET_END_W      = SPA(E_SNONE            , E_PAGE_00, 0xCF),
+	E_REG_P00_DWIN_RE_DE_W          = SPA(E_SNONE            , E_PAGE_00, 0xD0),
+	E_REG_P00_DWIN_FE_DE_W          = SPA(E_SNONE            , E_PAGE_00, 0xD1),
+	E_REG_P00_HVF_CNTRL_0_W         = SPA(E_SP00_HVF_CNTRL_0 , E_PAGE_00, 0xE4),
+	E_REG_P00_HVF_CNTRL_1_W         = SPA(E_SP00_HVF_CNTRL_1 , E_PAGE_00, 0xE5),
+	E_REG_P00_TIMER_H_W             = SPA(E_SP00_TIMER_H     , E_PAGE_00, 0xE8),
+	E_REG_P00_TIMER_M_W             = SPA(E_SNONE            , E_PAGE_00, 0xE9),
+	E_REG_P00_TIMER_L_W             = SPA(E_SNONE            , E_PAGE_00, 0xEA),
+#ifdef TMFL_TDA9981_SUPPORT
+	E_REG_P00_TIMER_2SEC_W          = SPA(E_SNONE            , E_PAGE_00, 0xEB),
+	E_REG_P00_TIMER_5SEC_W          = SPA(E_SNONE            , E_PAGE_00, 0xEC),
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_REG_P00_NDIV_IM_W             = SPA(E_SNONE            , E_PAGE_00, 0xEE),
+	E_REG_P00_NDIV_PF_W             = SPA(E_SNONE            , E_PAGE_00, 0xEF),
+	E_REG_P00_RPT_CNTRL_W           = SPA(E_SNONE            , E_PAGE_00, 0xF0),
+	E_REG_P00_LEAD_OFF_W            = SPA(E_SNONE            , E_PAGE_00, 0xF1),
+	E_REG_P00_TRAIL_OFF_W           = SPA(E_SNONE            , E_PAGE_00, 0xF2),
+	E_REG_P00_DEBUG_PROBE_W         = SPA(E_SP00_DEBUG_PROBE , E_PAGE_00, 0xF8),
+	E_REG_P00_GHOST_XADDR_W         = SPA(E_SNONE            , E_PAGE_00, 0xF9),
+	E_REG_P00_AIP_CLKSEL_W          = SPA(E_SP00_AIP_CLKSEL  , E_PAGE_00, 0xFD),
+	E_REG_P00_GHOST_ADDR_W          = SPA(E_SNONE            , E_PAGE_00, 0xFE),
+#ifndef TMFL_TDA9981_SUPPORT
+	E_REG_P01_SC_VIDFORMAT_W        = SPA(E_SP01_SC_VIDFORMAT, E_PAGE_01, 0x00),
+	E_REG_P01_SC_CNTRL_W            = SPA(E_SP01_SC_CNTRL    , E_PAGE_01, 0x01),
+	E_REG_P01_SC_DELTA_PHASE_V_W    = SPA(E_SNONE            , E_PAGE_01, 0x02),
+	E_REG_P01_SC_DELTA_PHASE_H_W    = SPA(E_SNONE            , E_PAGE_01, 0x03),
+	E_REG_P01_SC_START_PHASE_H_W    = SPA(E_SNONE            , E_PAGE_01, 0x04),
+	E_REG_P01_SC_NPIX_IN_LSB_W      = SPA(E_SNONE            , E_PAGE_01, 0x05),
+	E_REG_P01_SC_NPIX_IN_MSB_W      = SPA(E_SNONE            , E_PAGE_01, 0x06),
+	E_REG_P01_SC_NPIX_OUT_LSB_W     = SPA(E_SNONE            , E_PAGE_01, 0x07),
+	E_REG_P01_SC_NPIX_OUT_MSB_W     = SPA(E_SNONE            , E_PAGE_01, 0x08),
+	E_REG_P01_SC_NLINE_IN_LSB_W     = SPA(E_SNONE            , E_PAGE_01, 0x09),
+	E_REG_P01_SC_NLINE_IN_MSB_W     = SPA(E_SNONE            , E_PAGE_01, 0x0A),
+	E_REG_P01_SC_NLINE_OUT_LSB_W    = SPA(E_SNONE            , E_PAGE_01, 0x0B),
+	E_REG_P01_SC_NLINE_OUT_MSB_W    = SPA(E_SNONE            , E_PAGE_01, 0x0C),
+	E_REG_P01_SC_NLINE_SKIP_W       = SPA(E_SNONE            , E_PAGE_01, 0x0D),
+	E_REG_P01_SC_SAMPLE_BUFFILL_R   = SPA(E_SNONE            , E_PAGE_01, 0x0E),
+	E_REG_P01_SC_MAX_BUFFILL_P_0_R  = SPA(E_SNONE            , E_PAGE_01, 0x0F),
+	E_REG_P01_SC_MAX_BUFFILL_P_1_R  = SPA(E_SNONE            , E_PAGE_01, 0x10),
+	E_REG_P01_SC_MAX_BUFFILL_D_0_R  = SPA(E_SNONE            , E_PAGE_01, 0x11),
+	E_REG_P01_SC_MAX_BUFFILL_D_1_R  = SPA(E_SNONE            , E_PAGE_01, 0x12),
+	E_REG_P01_SC_SAMPLE_FIFOFILL_R  = SPA(E_SNONE            , E_PAGE_01, 0x13),
+	E_REG_P01_SC_MAX_FIFOFILL_PI_R  = SPA(E_SNONE            , E_PAGE_01, 0x14),
+	E_REG_P01_SC_MIN_FIFOFILL_PO1_R = SPA(E_SNONE            , E_PAGE_01, 0x15),
+	E_REG_P01_SC_MIN_FIFOFILL_PO2_R = SPA(E_SNONE            , E_PAGE_01, 0x16),
+	E_REG_P01_SC_MIN_FIFOFILL_PO3_R = SPA(E_SNONE            , E_PAGE_01, 0x17),
+	E_REG_P01_SC_MIN_FIFOFILL_PO4_R = SPA(E_SNONE            , E_PAGE_01, 0x18),
+	E_REG_P01_SC_MAX_FIFOFILL_DI_R  = SPA(E_SNONE            , E_PAGE_01, 0x19),
+	E_REG_P01_SC_MAX_FIFOFILL_DO_R  = SPA(E_SNONE            , E_PAGE_01, 0x1A),
+	E_REG_P01_SC_VS_LUT_0_W         = SPA(E_SNONE            , E_PAGE_01, 0x1B),
+	E_REG_P01_SC_VS_LUT_1_W         = SPA(E_SNONE            , E_PAGE_01, 0x1C),
+	E_REG_P01_SC_VS_LUT_2_W         = SPA(E_SNONE            , E_PAGE_01, 0x1D),
+	E_REG_P01_SC_VS_LUT_3_W         = SPA(E_SNONE            , E_PAGE_01, 0x1E),
+	E_REG_P01_SC_VS_LUT_4_W         = SPA(E_SNONE            , E_PAGE_01, 0x1F),
+	E_REG_P01_SC_VS_LUT_5_W         = SPA(E_SNONE            , E_PAGE_01, 0x20),
+	E_REG_P01_SC_VS_LUT_6_W         = SPA(E_SNONE            , E_PAGE_01, 0x21),
+	E_REG_P01_SC_VS_LUT_7_W         = SPA(E_SNONE            , E_PAGE_01, 0x22),
+	E_REG_P01_SC_VS_LUT_8_W         = SPA(E_SNONE            , E_PAGE_01, 0x23),
+	E_REG_P01_SC_VS_LUT_9_W         = SPA(E_SNONE            , E_PAGE_01, 0x24),
+	E_REG_P01_SC_VS_LUT_10_W        = SPA(E_SNONE            , E_PAGE_01, 0x25),
+	E_REG_P01_SC_VS_LUT_11_W        = SPA(E_SNONE            , E_PAGE_01, 0x26),
+	E_REG_P01_SC_VS_LUT_12_W        = SPA(E_SNONE            , E_PAGE_01, 0x27),
+	E_REG_P01_SC_VS_LUT_13_W        = SPA(E_SNONE            , E_PAGE_01, 0x28),
+	E_REG_P01_SC_VS_LUT_14_W        = SPA(E_SNONE            , E_PAGE_01, 0x29),
+	E_REG_P01_SC_VS_LUT_15_W        = SPA(E_SNONE            , E_PAGE_01, 0x2A),
+	E_REG_P01_SC_VS_LUT_16_W        = SPA(E_SNONE            , E_PAGE_01, 0x2B),
+	E_REG_P01_SC_VS_LUT_17_W        = SPA(E_SNONE            , E_PAGE_01, 0x2C),
+	E_REG_P01_SC_VS_LUT_18_W        = SPA(E_SNONE            , E_PAGE_01, 0x2D),
+	E_REG_P01_SC_VS_LUT_19_W        = SPA(E_SNONE            , E_PAGE_01, 0x2E),
+	E_REG_P01_SC_VS_LUT_20_W        = SPA(E_SNONE            , E_PAGE_01, 0x2F),
+	E_REG_P01_SC_VS_LUT_21_W        = SPA(E_SNONE            , E_PAGE_01, 0x30),
+	E_REG_P01_SC_VS_LUT_22_W        = SPA(E_SNONE            , E_PAGE_01, 0x31),
+	E_REG_P01_SC_VS_LUT_23_W        = SPA(E_SNONE            , E_PAGE_01, 0x32),
+	E_REG_P01_SC_VS_LUT_24_W        = SPA(E_SNONE            , E_PAGE_01, 0x33),
+	E_REG_P01_SC_VS_LUT_25_W        = SPA(E_SNONE            , E_PAGE_01, 0x34),
+	E_REG_P01_SC_VS_LUT_26_W        = SPA(E_SNONE            , E_PAGE_01, 0x35),
+	E_REG_P01_SC_VS_LUT_27_W        = SPA(E_SNONE            , E_PAGE_01, 0x36),
+	E_REG_P01_SC_VS_LUT_28_W        = SPA(E_SNONE            , E_PAGE_01, 0x37),
+	E_REG_P01_SC_VS_LUT_29_W        = SPA(E_SNONE            , E_PAGE_01, 0x38),
+	E_REG_P01_SC_VS_LUT_30_W        = SPA(E_SNONE            , E_PAGE_01, 0x39),
+	E_REG_P01_SC_VS_LUT_31_W        = SPA(E_SNONE            , E_PAGE_01, 0x3A),
+	E_REG_P01_SC_VS_LUT_32_W        = SPA(E_SNONE            , E_PAGE_01, 0x3B),
+	E_REG_P01_SC_VS_LUT_33_W        = SPA(E_SNONE            , E_PAGE_01, 0x3C),
+	E_REG_P01_SC_VS_LUT_34_W        = SPA(E_SNONE            , E_PAGE_01, 0x3D),
+	E_REG_P01_SC_VS_LUT_35_W        = SPA(E_SNONE            , E_PAGE_01, 0x3E),
+	E_REG_P01_SC_VS_LUT_36_W        = SPA(E_SNONE            , E_PAGE_01, 0x3F),
+	E_REG_P01_SC_VS_LUT_37_W        = SPA(E_SNONE            , E_PAGE_01, 0x40),
+	E_REG_P01_SC_VS_LUT_38_W        = SPA(E_SNONE            , E_PAGE_01, 0x41),
+	E_REG_P01_SC_VS_LUT_39_W        = SPA(E_SNONE            , E_PAGE_01, 0x42),
+	E_REG_P01_SC_VS_LUT_40_W        = SPA(E_SNONE            , E_PAGE_01, 0x43),
+	E_REG_P01_SC_VS_LUT_41_W        = SPA(E_SNONE            , E_PAGE_01, 0x44),
+	E_REG_P01_SC_VS_LUT_42_W        = SPA(E_SNONE            , E_PAGE_01, 0x45),
+	E_REG_P01_SC_VS_LUT_43_W        = SPA(E_SNONE            , E_PAGE_01, 0x46),
+	E_REG_P01_SC_VS_LUT_44_W        = SPA(E_SNONE            , E_PAGE_01, 0x47),
+	E_REG_P01_VIDFORMAT_W           = SPA(E_SNONE            , E_PAGE_01, 0xA0),
+	E_REG_P01_REFPIX_MSB_W          = SPA(E_SNONE            , E_PAGE_01, 0xA1),
+	E_REG_P01_REFPIX_LSB_W          = SPA(E_SNONE            , E_PAGE_01, 0xA2),
+	E_REG_P01_REFLINE_MSB_W         = SPA(E_SNONE            , E_PAGE_01, 0xA3),
+	E_REG_P01_REFLINE_LSB_W         = SPA(E_SNONE            , E_PAGE_01, 0xA4),
+	E_REG_P01_NPIX_MSB_W            = SPA(E_SNONE            , E_PAGE_01, 0xA5),
+	E_REG_P01_NPIX_LSB_W            = SPA(E_SNONE            , E_PAGE_01, 0xA6),
+	E_REG_P01_NLINE_MSB_W           = SPA(E_SNONE            , E_PAGE_01, 0xA7),
+	E_REG_P01_NLINE_LSB_W           = SPA(E_SNONE            , E_PAGE_01, 0xA8),
+	E_REG_P01_VWIN_START_1_MSB_W    = SPA(E_SNONE            , E_PAGE_01, 0xBD),
+	E_REG_P01_VWIN_START_1_LSB_W    = SPA(E_SNONE            , E_PAGE_01, 0xBE),
+	E_REG_P01_VWIN_END_1_MSB_W      = SPA(E_SNONE            , E_PAGE_01, 0xBF),
+	E_REG_P01_VWIN_END_1_LSB_W      = SPA(E_SNONE            , E_PAGE_01, 0xC0),
+	E_REG_P01_VWIN_START_2_MSB_W    = SPA(E_SNONE            , E_PAGE_01, 0xC1),
+	E_REG_P01_VWIN_START_2_LSB_W    = SPA(E_SNONE            , E_PAGE_01, 0xC2),
+	E_REG_P01_VWIN_END_2_MSB_W      = SPA(E_SNONE            , E_PAGE_01, 0xC3),
+	E_REG_P01_VWIN_END_2_LSB_W      = SPA(E_SNONE            , E_PAGE_01, 0xC4),
+	E_REG_P01_DE_START_MSB_W        = SPA(E_SNONE            , E_PAGE_01, 0xC5),
+	E_REG_P01_DE_START_LSB_W        = SPA(E_SNONE            , E_PAGE_01, 0xC6),
+	E_REG_P01_DE_STOP_MSB_W         = SPA(E_SNONE            , E_PAGE_01, 0xC7),
+	E_REG_P01_DE_STOP_LSB_W         = SPA(E_SNONE            , E_PAGE_01, 0xC8),
+	E_REG_P01_TBG_CNTRL_0_W         = SPA(E_SP01_TBG_CNTRL_0 , E_PAGE_01, 0xCA),
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_REG_P02_PLL_SERIAL_1_RW       = SPA(E_SNONE            , E_PAGE_02, 0x00),
+	E_REG_P02_PLL_SERIAL_2_RW       = SPA(E_SNONE            , E_PAGE_02, 0x01),
+	E_REG_P02_PLL_SERIAL_3_RW       = SPA(E_SNONE            , E_PAGE_02, 0x02),
+	E_REG_P02_SERIALIZER_RW         = SPA(E_SNONE            , E_PAGE_02, 0x03),
+	E_REG_P02_BUFFER_OUT_RW         = SPA(E_SNONE            , E_PAGE_02, 0x04),
+	E_REG_P02_PLL_SCG1_RW           = SPA(E_SNONE            , E_PAGE_02, 0x05),
+	E_REG_P02_PLL_SCG2_RW           = SPA(E_SNONE            , E_PAGE_02, 0x06),
+	E_REG_P02_PLL_SCGN1_RW          = SPA(E_SNONE            , E_PAGE_02, 0x07),
+	E_REG_P02_PLL_SCGN2_RW          = SPA(E_SNONE            , E_PAGE_02, 0x08),
+	E_REG_P02_PLL_SCGR1_RW          = SPA(E_SNONE            , E_PAGE_02, 0x09),
+	E_REG_P02_PLL_SCGR2_RW          = SPA(E_SNONE            , E_PAGE_02, 0x0A),
+	E_REG_P02_PLL_DE_RW             = SPA(E_SNONE            , E_PAGE_02, 0x0B),
+	E_REG_P02_CCIR_DIV_RW           = SPA(E_SNONE            , E_PAGE_02, 0x0C),
+	E_REG_P02_VAI_PLL_R             = SPA(E_SNONE            , E_PAGE_02, 0x0D),
+	E_REG_P02_AUDIO_DIV_RW          = SPA(E_SNONE            , E_PAGE_02, 0x0E),
+	E_REG_P02_TEST1_RW              = SPA(E_SNONE            , E_PAGE_02, 0x0F),
+	E_REG_P02_TEST2_RW              = SPA(E_SNONE            , E_PAGE_02, 0x10),
+	E_REG_P02_SEL_CLK_RW            = SPA(E_SNONE            , E_PAGE_02, 0x11),
+	E_REG_P10_IF1_HB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x20),
+	E_REG_P10_IF1_HB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x21),
+	E_REG_P10_IF1_HB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x22),
+	E_REG_P10_IF1_PB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x23),
+	E_REG_P10_IF1_PB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x24),
+	E_REG_P10_IF1_PB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x25),
+	E_REG_P10_IF1_PB3_RW            = SPA(E_SNONE            , E_PAGE_10, 0x26),
+	E_REG_P10_IF1_PB4_RW            = SPA(E_SNONE            , E_PAGE_10, 0x27),
+	E_REG_P10_IF1_PB5_RW            = SPA(E_SNONE            , E_PAGE_10, 0x28),
+	E_REG_P10_IF1_PB6_RW            = SPA(E_SNONE            , E_PAGE_10, 0x29),
+	E_REG_P10_IF1_PB7_RW            = SPA(E_SNONE            , E_PAGE_10, 0x2A),
+	E_REG_P10_IF1_PB8_RW            = SPA(E_SNONE            , E_PAGE_10, 0x2B),
+	E_REG_P10_IF1_PB9_RW            = SPA(E_SNONE            , E_PAGE_10, 0x2C),
+	E_REG_P10_IF1_PB10_RW           = SPA(E_SNONE            , E_PAGE_10, 0x2D),
+	E_REG_P10_IF1_PB11_RW           = SPA(E_SNONE            , E_PAGE_10, 0x2E),
+	E_REG_P10_IF1_PB12_RW           = SPA(E_SNONE            , E_PAGE_10, 0x2F),
+	E_REG_P10_IF1_PB13_RW           = SPA(E_SNONE            , E_PAGE_10, 0x30),
+	E_REG_P10_IF1_PB14_RW           = SPA(E_SNONE            , E_PAGE_10, 0x31),
+	E_REG_P10_IF1_PB15_RW           = SPA(E_SNONE            , E_PAGE_10, 0x32),
+	E_REG_P10_IF1_PB16_RW           = SPA(E_SNONE            , E_PAGE_10, 0x33),
+	E_REG_P10_IF1_PB17_RW           = SPA(E_SNONE            , E_PAGE_10, 0x34),
+	E_REG_P10_IF1_PB18_RW           = SPA(E_SNONE            , E_PAGE_10, 0x35),
+	E_REG_P10_IF1_PB19_RW           = SPA(E_SNONE            , E_PAGE_10, 0x36),
+	E_REG_P10_IF1_PB20_RW           = SPA(E_SNONE            , E_PAGE_10, 0x37),
+	E_REG_P10_IF1_PB21_RW           = SPA(E_SNONE            , E_PAGE_10, 0x38),
+	E_REG_P10_IF1_PB22_RW           = SPA(E_SNONE            , E_PAGE_10, 0x39),
+	E_REG_P10_IF1_PB23_RW           = SPA(E_SNONE            , E_PAGE_10, 0x3A),
+	E_REG_P10_IF1_PB24_RW           = SPA(E_SNONE            , E_PAGE_10, 0x3B),
+	E_REG_P10_IF1_PB25_RW           = SPA(E_SNONE            , E_PAGE_10, 0x3C),
+	E_REG_P10_IF1_PB26_RW           = SPA(E_SNONE            , E_PAGE_10, 0x3D),
+	E_REG_P10_IF1_PB27_RW           = SPA(E_SNONE            , E_PAGE_10, 0x3E),
+	E_REG_P10_IF2_HB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x40),
+	E_REG_P10_IF2_HB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x41),
+	E_REG_P10_IF2_HB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x42),
+	E_REG_P10_IF2_PB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x43),
+	E_REG_P10_IF2_PB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x44),
+	E_REG_P10_IF2_PB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x45),
+	E_REG_P10_IF2_PB3_RW            = SPA(E_SNONE            , E_PAGE_10, 0x46),
+	E_REG_P10_IF2_PB4_RW            = SPA(E_SNONE            , E_PAGE_10, 0x47),
+	E_REG_P10_IF2_PB5_RW            = SPA(E_SNONE            , E_PAGE_10, 0x48),
+	E_REG_P10_IF2_PB6_RW            = SPA(E_SNONE            , E_PAGE_10, 0x49),
+	E_REG_P10_IF2_PB7_RW            = SPA(E_SNONE            , E_PAGE_10, 0x4A),
+	E_REG_P10_IF2_PB8_RW            = SPA(E_SNONE            , E_PAGE_10, 0x4B),
+	E_REG_P10_IF2_PB9_RW            = SPA(E_SNONE            , E_PAGE_10, 0x4C),
+	E_REG_P10_IF2_PB10_RW           = SPA(E_SNONE            , E_PAGE_10, 0x4D),
+	E_REG_P10_IF2_PB11_RW           = SPA(E_SNONE            , E_PAGE_10, 0x4E),
+	E_REG_P10_IF2_PB12_RW           = SPA(E_SNONE            , E_PAGE_10, 0x4F),
+	E_REG_P10_IF2_PB13_RW           = SPA(E_SNONE            , E_PAGE_10, 0x50),
+	E_REG_P10_IF2_PB14_RW           = SPA(E_SNONE            , E_PAGE_10, 0x51),
+	E_REG_P10_IF2_PB15_RW           = SPA(E_SNONE            , E_PAGE_10, 0x52),
+	E_REG_P10_IF2_PB16_RW           = SPA(E_SNONE            , E_PAGE_10, 0x53),
+	E_REG_P10_IF2_PB17_RW           = SPA(E_SNONE            , E_PAGE_10, 0x54),
+	E_REG_P10_IF2_PB18_RW           = SPA(E_SNONE            , E_PAGE_10, 0x55),
+	E_REG_P10_IF2_PB19_RW           = SPA(E_SNONE            , E_PAGE_10, 0x56),
+	E_REG_P10_IF2_PB20_RW           = SPA(E_SNONE            , E_PAGE_10, 0x57),
+	E_REG_P10_IF2_PB21_RW           = SPA(E_SNONE            , E_PAGE_10, 0x58),
+	E_REG_P10_IF2_PB22_RW           = SPA(E_SNONE            , E_PAGE_10, 0x59),
+	E_REG_P10_IF2_PB23_RW           = SPA(E_SNONE            , E_PAGE_10, 0x5A),
+	E_REG_P10_IF2_PB24_RW           = SPA(E_SNONE            , E_PAGE_10, 0x5B),
+	E_REG_P10_IF2_PB25_RW           = SPA(E_SNONE            , E_PAGE_10, 0x5C),
+	E_REG_P10_IF2_PB26_RW           = SPA(E_SNONE            , E_PAGE_10, 0x5D),
+	E_REG_P10_IF2_PB27_RW           = SPA(E_SNONE            , E_PAGE_10, 0x5E),
+	E_REG_P10_IF3_HB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x60),
+	E_REG_P10_IF3_HB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x61),
+	E_REG_P10_IF3_HB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x62),
+	E_REG_P10_IF3_PB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x63),
+	E_REG_P10_IF3_PB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x64),
+	E_REG_P10_IF3_PB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x65),
+	E_REG_P10_IF3_PB3_RW            = SPA(E_SNONE            , E_PAGE_10, 0x66),
+	E_REG_P10_IF3_PB4_RW            = SPA(E_SNONE            , E_PAGE_10, 0x67),
+	E_REG_P10_IF3_PB5_RW            = SPA(E_SNONE            , E_PAGE_10, 0x68),
+	E_REG_P10_IF3_PB6_RW            = SPA(E_SNONE            , E_PAGE_10, 0x69),
+	E_REG_P10_IF3_PB7_RW            = SPA(E_SNONE            , E_PAGE_10, 0x6A),
+	E_REG_P10_IF3_PB8_RW            = SPA(E_SNONE            , E_PAGE_10, 0x6B),
+	E_REG_P10_IF3_PB9_RW            = SPA(E_SNONE            , E_PAGE_10, 0x6C),
+	E_REG_P10_IF3_PB10_RW           = SPA(E_SNONE            , E_PAGE_10, 0x6D),
+	E_REG_P10_IF3_PB11_RW           = SPA(E_SNONE            , E_PAGE_10, 0x6E),
+	E_REG_P10_IF3_PB12_RW           = SPA(E_SNONE            , E_PAGE_10, 0x6F),
+	E_REG_P10_IF3_PB13_RW           = SPA(E_SNONE            , E_PAGE_10, 0x70),
+	E_REG_P10_IF3_PB14_RW           = SPA(E_SNONE            , E_PAGE_10, 0x71),
+	E_REG_P10_IF3_PB15_RW           = SPA(E_SNONE            , E_PAGE_10, 0x72),
+	E_REG_P10_IF3_PB16_RW           = SPA(E_SNONE            , E_PAGE_10, 0x73),
+	E_REG_P10_IF3_PB17_RW           = SPA(E_SNONE            , E_PAGE_10, 0x74),
+	E_REG_P10_IF3_PB18_RW           = SPA(E_SNONE            , E_PAGE_10, 0x75),
+	E_REG_P10_IF3_PB19_RW           = SPA(E_SNONE            , E_PAGE_10, 0x76),
+	E_REG_P10_IF3_PB20_RW           = SPA(E_SNONE            , E_PAGE_10, 0x77),
+	E_REG_P10_IF3_PB21_RW           = SPA(E_SNONE            , E_PAGE_10, 0x78),
+	E_REG_P10_IF3_PB22_RW           = SPA(E_SNONE            , E_PAGE_10, 0x79),
+	E_REG_P10_IF3_PB23_RW           = SPA(E_SNONE            , E_PAGE_10, 0x7A),
+	E_REG_P10_IF3_PB24_RW           = SPA(E_SNONE            , E_PAGE_10, 0x7B),
+	E_REG_P10_IF3_PB25_RW           = SPA(E_SNONE            , E_PAGE_10, 0x7C),
+	E_REG_P10_IF3_PB26_RW           = SPA(E_SNONE            , E_PAGE_10, 0x7D),
+	E_REG_P10_IF3_PB27_RW           = SPA(E_SNONE            , E_PAGE_10, 0x7E),
+	E_REG_P10_IF4_HB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x80),
+	E_REG_P10_IF4_HB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x81),
+	E_REG_P10_IF4_HB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x82),
+	E_REG_P10_IF4_PB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0x83),
+	E_REG_P10_IF4_PB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0x84),
+	E_REG_P10_IF4_PB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0x85),
+	E_REG_P10_IF4_PB3_RW            = SPA(E_SNONE            , E_PAGE_10, 0x86),
+	E_REG_P10_IF4_PB4_RW            = SPA(E_SNONE            , E_PAGE_10, 0x87),
+	E_REG_P10_IF4_PB5_RW            = SPA(E_SNONE            , E_PAGE_10, 0x88),
+	E_REG_P10_IF4_PB6_RW            = SPA(E_SNONE            , E_PAGE_10, 0x89),
+	E_REG_P10_IF4_PB7_RW            = SPA(E_SNONE            , E_PAGE_10, 0x8A),
+	E_REG_P10_IF4_PB8_RW            = SPA(E_SNONE            , E_PAGE_10, 0x8B),
+	E_REG_P10_IF4_PB9_RW            = SPA(E_SNONE            , E_PAGE_10, 0x8C),
+	E_REG_P10_IF4_PB10_RW           = SPA(E_SNONE            , E_PAGE_10, 0x8D),
+	E_REG_P10_IF4_PB11_RW           = SPA(E_SNONE            , E_PAGE_10, 0x8E),
+	E_REG_P10_IF4_PB12_RW           = SPA(E_SNONE            , E_PAGE_10, 0x8F),
+	E_REG_P10_IF4_PB13_RW           = SPA(E_SNONE            , E_PAGE_10, 0x90),
+	E_REG_P10_IF4_PB14_RW           = SPA(E_SNONE            , E_PAGE_10, 0x91),
+	E_REG_P10_IF4_PB15_RW           = SPA(E_SNONE            , E_PAGE_10, 0x92),
+	E_REG_P10_IF4_PB16_RW           = SPA(E_SNONE            , E_PAGE_10, 0x93),
+	E_REG_P10_IF4_PB17_RW           = SPA(E_SNONE            , E_PAGE_10, 0x94),
+	E_REG_P10_IF4_PB18_RW           = SPA(E_SNONE            , E_PAGE_10, 0x95),
+	E_REG_P10_IF4_PB19_RW           = SPA(E_SNONE            , E_PAGE_10, 0x96),
+	E_REG_P10_IF4_PB20_RW           = SPA(E_SNONE            , E_PAGE_10, 0x97),
+	E_REG_P10_IF4_PB21_RW           = SPA(E_SNONE            , E_PAGE_10, 0x98),
+	E_REG_P10_IF4_PB22_RW           = SPA(E_SNONE            , E_PAGE_10, 0x99),
+	E_REG_P10_IF4_PB23_RW           = SPA(E_SNONE            , E_PAGE_10, 0x9A),
+	E_REG_P10_IF4_PB24_RW           = SPA(E_SNONE            , E_PAGE_10, 0x9B),
+	E_REG_P10_IF4_PB25_RW           = SPA(E_SNONE            , E_PAGE_10, 0x9C),
+	E_REG_P10_IF4_PB26_RW           = SPA(E_SNONE            , E_PAGE_10, 0x9D),
+	E_REG_P10_IF4_PB27_RW           = SPA(E_SNONE            , E_PAGE_10, 0x9E),
+	E_REG_P10_IF5_HB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA0),
+	E_REG_P10_IF5_HB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA1),
+	E_REG_P10_IF5_HB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA2),
+	E_REG_P10_IF5_PB0_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA3),
+	E_REG_P10_IF5_PB1_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA4),
+	E_REG_P10_IF5_PB2_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA5),
+	E_REG_P10_IF5_PB3_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA6),
+	E_REG_P10_IF5_PB4_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA7),
+	E_REG_P10_IF5_PB5_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA8),
+	E_REG_P10_IF5_PB6_RW            = SPA(E_SNONE            , E_PAGE_10, 0xA9),
+	E_REG_P10_IF5_PB7_RW            = SPA(E_SNONE            , E_PAGE_10, 0xAA),
+	E_REG_P10_IF5_PB8_RW            = SPA(E_SNONE            , E_PAGE_10, 0xAB),
+	E_REG_P10_IF5_PB9_RW            = SPA(E_SNONE            , E_PAGE_10, 0xAC),
+	E_REG_P10_IF5_PB10_RW           = SPA(E_SNONE            , E_PAGE_10, 0xAD),
+	E_REG_P10_IF5_PB11_RW           = SPA(E_SNONE            , E_PAGE_10, 0xAE),
+	E_REG_P10_IF5_PB12_RW           = SPA(E_SNONE            , E_PAGE_10, 0xAF),
+	E_REG_P10_IF5_PB13_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB0),
+	E_REG_P10_IF5_PB14_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB1),
+	E_REG_P10_IF5_PB15_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB2),
+	E_REG_P10_IF5_PB16_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB3),
+	E_REG_P10_IF5_PB17_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB4),
+	E_REG_P10_IF5_PB18_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB5),
+	E_REG_P10_IF5_PB19_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB6),
+	E_REG_P10_IF5_PB20_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB7),
+	E_REG_P10_IF5_PB21_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB8),
+	E_REG_P10_IF5_PB22_RW           = SPA(E_SNONE            , E_PAGE_10, 0xB9),
+	E_REG_P10_IF5_PB23_RW           = SPA(E_SNONE            , E_PAGE_10, 0xBA),
+	E_REG_P10_IF5_PB24_RW           = SPA(E_SNONE            , E_PAGE_10, 0xBB),
+	E_REG_P10_IF5_PB25_RW           = SPA(E_SNONE            , E_PAGE_10, 0xBC),
+	E_REG_P10_IF5_PB26_RW           = SPA(E_SNONE            , E_PAGE_10, 0xBD),
+	E_REG_P10_IF5_PB27_RW           = SPA(E_SNONE            , E_PAGE_10, 0xBE),
+	E_REG_P11_AIP_CNTRL_0_RW        = SPA(E_SNONE            , E_PAGE_11, 0x00),
+	E_REG_P11_CA_I2S_RW             = SPA(E_SNONE            , E_PAGE_11, 0x01),
+	E_REG_P11_CA_DSD_RW             = SPA(E_SNONE            , E_PAGE_11, 0x02),
+	E_REG_P11_OBA_PH_RW             = SPA(E_SNONE            , E_PAGE_11, 0x03),
+	E_REG_P11_LATENCY_RD_RW         = SPA(E_SNONE            , E_PAGE_11, 0x04),
+	E_REG_P11_ACR_CTS_0_RW          = SPA(E_SNONE            , E_PAGE_11, 0x05),
+	E_REG_P11_ACR_CTS_1_RW          = SPA(E_SNONE            , E_PAGE_11, 0x06),
+	E_REG_P11_ACR_CTS_2_RW          = SPA(E_SNONE            , E_PAGE_11, 0x07),
+	E_REG_P11_ACR_N_0_RW            = SPA(E_SNONE            , E_PAGE_11, 0x08),
+	E_REG_P11_ACR_N_1_RW            = SPA(E_SNONE            , E_PAGE_11, 0x09),
+	E_REG_P11_ACR_N_2_RW            = SPA(E_SNONE            , E_PAGE_11, 0x0A),
+	E_REG_P11_GC_AVMUTE_RW          = SPA(E_SNONE            , E_PAGE_11, 0x0B),
+	E_REG_P11_CTS_N_RW              = SPA(E_SNONE            , E_PAGE_11, 0x0C),
+	E_REG_P11_ENC_CNTRL_RW          = SPA(E_SNONE            , E_PAGE_11, 0x0D),
+	E_REG_P11_DIP_FLAGS_RW          = SPA(E_SNONE            , E_PAGE_11, 0x0E),
+	E_REG_P11_DIP_IF_FLAGS_RW       = SPA(E_SNONE            , E_PAGE_11, 0x0F),
+	E_REG_P11_CH_STAT_B_0_RW        = SPA(E_SNONE            , E_PAGE_11, 0x14),
+	E_REG_P11_CH_STAT_B_1_RW        = SPA(E_SNONE            , E_PAGE_11, 0x15),
+	E_REG_P11_CH_STAT_B_3_RW        = SPA(E_SNONE            , E_PAGE_11, 0x16),
+	E_REG_P11_CH_STAT_B_4_RW        = SPA(E_SNONE            , E_PAGE_11, 0x17),
+	e_reg_p11_ch_stat_b_2_ap0_l_rw  = SPA(E_SNONE            , E_PAGE_11, 0x18),
+	e_reg_p11_ch_stat_b_2_ap0_r_rw  = SPA(E_SNONE            , E_PAGE_11, 0x19),
+	e_reg_p11_ch_stat_b_2_ap1_l_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1A),
+	e_reg_p11_ch_stat_b_2_ap1_r_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1B),
+	e_reg_p11_ch_stat_b_2_ap2_l_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1C),
+	e_reg_p11_ch_stat_b_2_ap2_r_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1D),
+	e_reg_p11_ch_stat_b_2_ap3_l_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1E),
+	e_reg_p11_ch_stat_b_2_ap3_r_rw  = SPA(E_SNONE            , E_PAGE_11, 0x1F),
+	/* 20-3E: n3 uses this area for VideoInfoFrame */
+	E_REG_P11_ISRC1_HB0_RW          = SPA(E_SNONE            , E_PAGE_11, 0x20),
+	E_REG_P11_ISRC1_HB1_RW          = SPA(E_SNONE            , E_PAGE_11, 0x21),
+	E_REG_P11_ISRC1_HB2_RW          = SPA(E_SNONE            , E_PAGE_11, 0x22),
+	E_REG_P11_ISRC1_PB0_RW          = SPA(E_SNONE            , E_PAGE_11, 0x23),
+	E_REG_P11_ISRC1_PB1_RW          = SPA(E_SNONE            , E_PAGE_11, 0x24),
+	E_REG_P11_ISRC1_PB2_RW          = SPA(E_SNONE            , E_PAGE_11, 0x25),
+	E_REG_P11_ISRC1_PB3_RW          = SPA(E_SNONE            , E_PAGE_11, 0x26),
+	E_REG_P11_ISRC1_PB4_RW          = SPA(E_SNONE            , E_PAGE_11, 0x27),
+	E_REG_P11_ISRC1_PB5_RW          = SPA(E_SNONE            , E_PAGE_11, 0x28),
+	E_REG_P11_ISRC1_PB6_RW          = SPA(E_SNONE            , E_PAGE_11, 0x29),
+	E_REG_P11_ISRC1_PB7_RW          = SPA(E_SNONE            , E_PAGE_11, 0x2A),
+	E_REG_P11_ISRC1_PB8_RW          = SPA(E_SNONE            , E_PAGE_11, 0x2B),
+	E_REG_P11_ISRC1_PB9_RW          = SPA(E_SNONE            , E_PAGE_11, 0x2C),
+	E_REG_P11_ISRC1_PB10_RW         = SPA(E_SNONE            , E_PAGE_11, 0x2D),
+	E_REG_P11_ISRC1_PB11_RW         = SPA(E_SNONE            , E_PAGE_11, 0x2E),
+	E_REG_P11_ISRC1_PB12_RW         = SPA(E_SNONE            , E_PAGE_11, 0x2F),
+	E_REG_P11_ISRC1_PB13_RW         = SPA(E_SNONE            , E_PAGE_11, 0x30),
+	E_REG_P11_ISRC1_PB14_RW         = SPA(E_SNONE            , E_PAGE_11, 0x31),
+	E_REG_P11_ISRC1_PB15_RW         = SPA(E_SNONE            , E_PAGE_11, 0x32),
+	E_REG_P11_ISRC1_PB16_RW         = SPA(E_SNONE            , E_PAGE_11, 0x33),
+	E_REG_P11_ISRC1_PB17_RW         = SPA(E_SNONE            , E_PAGE_11, 0x34),
+	E_REG_P11_ISRC1_PB18_RW         = SPA(E_SNONE            , E_PAGE_11, 0x35),
+	E_REG_P11_ISRC1_PB19_RW         = SPA(E_SNONE            , E_PAGE_11, 0x36),
+	E_REG_P11_ISRC1_PB20_RW         = SPA(E_SNONE            , E_PAGE_11, 0x37),
+	E_REG_P11_ISRC1_PB21_RW         = SPA(E_SNONE            , E_PAGE_11, 0x38),
+	E_REG_P11_ISRC1_PB22_RW         = SPA(E_SNONE            , E_PAGE_11, 0x39),
+	E_REG_P11_ISRC1_PB23_RW         = SPA(E_SNONE            , E_PAGE_11, 0x3A),
+	E_REG_P11_ISRC1_PB24_RW         = SPA(E_SNONE            , E_PAGE_11, 0x3B),
+	E_REG_P11_ISRC1_PB25_RW         = SPA(E_SNONE            , E_PAGE_11, 0x3C),
+	E_REG_P11_ISRC1_PB26_RW         = SPA(E_SNONE            , E_PAGE_11, 0x3D),
+	E_REG_P11_ISRC1_PB27_RW         = SPA(E_SNONE            , E_PAGE_11, 0x3E),
+	E_REG_P11_ISRC2_HB0_RW          = SPA(E_SNONE            , E_PAGE_11, 0x40),
+	E_REG_P11_ISRC2_HB1_RW          = SPA(E_SNONE            , E_PAGE_11, 0x41),
+	E_REG_P11_ISRC2_HB2_RW          = SPA(E_SNONE            , E_PAGE_11, 0x42),
+	E_REG_P11_ISRC2_PB0_RW          = SPA(E_SNONE            , E_PAGE_11, 0x43),
+	E_REG_P11_ISRC2_PB1_RW          = SPA(E_SNONE            , E_PAGE_11, 0x44),
+	E_REG_P11_ISRC2_PB2_RW          = SPA(E_SNONE            , E_PAGE_11, 0x45),
+	E_REG_P11_ISRC2_PB3_RW          = SPA(E_SNONE            , E_PAGE_11, 0x46),
+	E_REG_P11_ISRC2_PB4_RW          = SPA(E_SNONE            , E_PAGE_11, 0x47),
+	E_REG_P11_ISRC2_PB5_RW          = SPA(E_SNONE            , E_PAGE_11, 0x48),
+	E_REG_P11_ISRC2_PB6_RW          = SPA(E_SNONE            , E_PAGE_11, 0x49),
+	E_REG_P11_ISRC2_PB7_RW          = SPA(E_SNONE            , E_PAGE_11, 0x4A),
+	E_REG_P11_ISRC2_PB8_RW          = SPA(E_SNONE            , E_PAGE_11, 0x4B),
+	E_REG_P11_ISRC2_PB9_RW          = SPA(E_SNONE            , E_PAGE_11, 0x4C),
+	E_REG_P11_ISRC2_PB10_RW         = SPA(E_SNONE            , E_PAGE_11, 0x4D),
+	E_REG_P11_ISRC2_PB11_RW         = SPA(E_SNONE            , E_PAGE_11, 0x4E),
+	E_REG_P11_ISRC2_PB12_RW         = SPA(E_SNONE            , E_PAGE_11, 0x4F),
+	E_REG_P11_ISRC2_PB13_RW         = SPA(E_SNONE            , E_PAGE_11, 0x50),
+	E_REG_P11_ISRC2_PB14_RW         = SPA(E_SNONE            , E_PAGE_11, 0x51),
+	E_REG_P11_ISRC2_PB15_RW         = SPA(E_SNONE            , E_PAGE_11, 0x52),
+	E_REG_P11_ISRC2_PB16_RW         = SPA(E_SNONE            , E_PAGE_11, 0x53),
+	E_REG_P11_ISRC2_PB17_RW         = SPA(E_SNONE            , E_PAGE_11, 0x54),
+	E_REG_P11_ISRC2_PB18_RW         = SPA(E_SNONE            , E_PAGE_11, 0x55),
+	E_REG_P11_ISRC2_PB19_RW         = SPA(E_SNONE            , E_PAGE_11, 0x56),
+	E_REG_P11_ISRC2_PB20_RW         = SPA(E_SNONE            , E_PAGE_11, 0x57),
+	E_REG_P11_ISRC2_PB21_RW         = SPA(E_SNONE            , E_PAGE_11, 0x58),
+	E_REG_P11_ISRC2_PB22_RW         = SPA(E_SNONE            , E_PAGE_11, 0x59),
+	E_REG_P11_ISRC2_PB23_RW         = SPA(E_SNONE            , E_PAGE_11, 0x5A),
+	E_REG_P11_ISRC2_PB24_RW         = SPA(E_SNONE            , E_PAGE_11, 0x5B),
+	E_REG_P11_ISRC2_PB25_RW         = SPA(E_SNONE            , E_PAGE_11, 0x5C),
+	E_REG_P11_ISRC2_PB26_RW         = SPA(E_SNONE            , E_PAGE_11, 0x5D),
+	E_REG_P11_ISRC2_PB27_RW         = SPA(E_SNONE            , E_PAGE_11, 0x5E),
+	/* 60-7E: n3 uses this area for AudioInfoFrame */
+	E_REG_P11_ACP_HB0_RW            = SPA(E_SNONE            , E_PAGE_11, 0x60),
+	E_REG_P11_ACP_HB1_RW            = SPA(E_SNONE            , E_PAGE_11, 0x61),
+	E_REG_P11_ACP_HB2_RW            = SPA(E_SNONE            , E_PAGE_11, 0x62),
+	E_REG_P11_ACP_PB0_RW            = SPA(E_SNONE            , E_PAGE_11, 0x63),
+	E_REG_P11_ACP_PB1_RW            = SPA(E_SNONE            , E_PAGE_11, 0x64),
+	E_REG_P11_ACP_PB2_RW            = SPA(E_SNONE            , E_PAGE_11, 0x65),
+	E_REG_P11_ACP_PB3_RW            = SPA(E_SNONE            , E_PAGE_11, 0x66),
+	E_REG_P11_ACP_PB4_RW            = SPA(E_SNONE            , E_PAGE_11, 0x67),
+	E_REG_P11_ACP_PB5_RW            = SPA(E_SNONE            , E_PAGE_11, 0x68),
+	E_REG_P11_ACP_PB6_RW            = SPA(E_SNONE            , E_PAGE_11, 0x69),
+	E_REG_P11_ACP_PB7_RW            = SPA(E_SNONE            , E_PAGE_11, 0x6A),
+	E_REG_P11_ACP_PB8_RW            = SPA(E_SNONE            , E_PAGE_11, 0x6B),
+	E_REG_P11_ACP_PB9_RW            = SPA(E_SNONE            , E_PAGE_11, 0x6C),
+	E_REG_P11_ACP_PB10_RW           = SPA(E_SNONE            , E_PAGE_11, 0x6D),
+	E_REG_P11_ACP_PB11_RW           = SPA(E_SNONE            , E_PAGE_11, 0x6E),
+	E_REG_P11_ACP_PB12_RW           = SPA(E_SNONE            , E_PAGE_11, 0x6F),
+	E_REG_P11_ACP_PB13_RW           = SPA(E_SNONE            , E_PAGE_11, 0x70),
+	E_REG_P11_ACP_PB14_RW           = SPA(E_SNONE            , E_PAGE_11, 0x71),
+	E_REG_P11_ACP_PB15_RW           = SPA(E_SNONE            , E_PAGE_11, 0x72),
+	E_REG_P11_ACP_PB16_RW           = SPA(E_SNONE            , E_PAGE_11, 0x73),
+	E_REG_P11_ACP_PB17_RW           = SPA(E_SNONE            , E_PAGE_11, 0x74),
+	E_REG_P11_ACP_PB18_RW           = SPA(E_SNONE            , E_PAGE_11, 0x75),
+	E_REG_P11_ACP_PB19_RW           = SPA(E_SNONE            , E_PAGE_11, 0x76),
+	E_REG_P11_ACP_PB20_RW           = SPA(E_SNONE            , E_PAGE_11, 0x77),
+	E_REG_P11_ACP_PB21_RW           = SPA(E_SNONE            , E_PAGE_11, 0x78),
+	E_REG_P11_ACP_PB22_RW           = SPA(E_SNONE            , E_PAGE_11, 0x79),
+	E_REG_P11_ACP_PB23_RW           = SPA(E_SNONE            , E_PAGE_11, 0x7A),
+	E_REG_P11_ACP_PB24_RW           = SPA(E_SNONE            , E_PAGE_11, 0x7B),
+	E_REG_P11_ACP_PB25_RW           = SPA(E_SNONE            , E_PAGE_11, 0x7C),
+	E_REG_P11_ACP_PB26_RW           = SPA(E_SNONE            , E_PAGE_11, 0x7D),
+	/* 80-9E: deleted according to tda9983n3_i2c_GSmodifications_2.xls 27/3/2006 */
+	E_REG_P11_ACP_PB27_RW           = SPA(E_SNONE            , E_PAGE_11, 0x7E),
+	E_REG_P12_OTP_ADDRESS_W         = SPA(E_SNONE            , E_PAGE_12, 0x30),
+	E_REG_P12_OTP_DATA_MSB_RW       = SPA(E_SNONE            , E_PAGE_12, 0x31),
+	E_REG_P12_OTP_DATA_ISB_RW       = SPA(E_SNONE            , E_PAGE_12, 0x32),
+	E_REG_P12_OTP_DATA_LSB_RW       = SPA(E_SNONE            , E_PAGE_12, 0x33),
+	E_REG_P12_OTP_CNTRL_W           = SPA(E_SNONE            , E_PAGE_12, 0x34),
+	E_REG_P12_OTP_STATUS_R          = SPA(E_SNONE            , E_PAGE_12, 0x35),
+	E_REG_P12_VPP_TIMER_W           = SPA(E_SNONE            , E_PAGE_12, 0x36),
+	E_REG_P12_WRITE_TIMER_W         = SPA(E_SNONE            , E_PAGE_12, 0x37),
+	E_REG_P12_DISCHARGE_TIMER_W     = SPA(E_SNONE            , E_PAGE_12, 0x38),
+	E_REG_P12_READ_TIMER_W          = SPA(E_SNONE            , E_PAGE_12, 0x39),
+	E_REG_P12_HDCP_TX33_RW          = SPA(E_SNONE            , E_PAGE_12, 0xB8)
+};
+#undef SPR
+
+/**
+ * Register bitfield masks, with a macro to allow binary initializers.
+ * Enum names are derived directly from TDA998x register and bitfield names.
+ * */
+#define BINARY(d7,d6,d5,d4,d3,d2,d1,d0) \
+	(((d7)<<7)|((d6)<<6)|((d5)<<5)|((d4)<<4)|((d3)<<3)|((d2)<<2)|((d1)<<1)|(d0))
+
+enum _e_mask_reg {
+	E_MASKREG_NONE                          = BINARY(0, 0, 0, 0, 0, 0, 0, 0),
+	E_MASKREG_ALL                           = BINARY(1, 1, 1, 1, 1, 1, 1, 1),
+
+	/* N4 features flags read from version register:
+	 * not_h = no HDCP support
+	 * not_s = no scaler support
+	 *
+	 * N5 = a flag that is not a register bit, but is derived by the
+	 * driver from the new N5 registers DWIN_RE_DE and DWIN_FE_DE,
+	 * because the N5 device still uses the N4 version register value.
+	 * This bit position would clash with version register, so is not
+	 * present in the driver's copy (uDeviceVersion) of the version
+	 * register, but only in the driver's features byte (uDeviceFeatures).
+	 *	 */
+	e_maskreg_p00_version_not_h             = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_version_not_s             = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	E_MASKREG_P00_FEATURE_N5                = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_main_cntrl0_scaler        = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_main_cntrl0_cehs          = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_main_cntrl0_cecs          = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_main_cntrl0_dehs          = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_main_cntrl0_decs          = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_main_cntrl0_sr            = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+#ifdef TMFL_TDA9981_SUPPORT
+	e_maskreg_p00_sr_reg_sr_i2c_ms			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_sr_reg_sr_audio			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_ddc_disable_ddc_dis		= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_cclk_on_cclk_on			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_int_flags_0_r0			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+#endif /* TMFL_TDA9981_SUPPORT */
+	e_maskreg_p00_int_flags_0_pj            = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_int_flags_0_sha_1         = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_int_flags_0_bstatus       = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_int_flags_0_bcaps         = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_int_flags_0_t0            = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_int_flags_0_hpd           = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_int_flags_0_encrypt       = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_int_flags_1_hpd_in 		= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+#ifdef TMFL_TDA9981_SUPPORT
+	e_maskreg_p00_int_flags_1_sw_int		= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+#endif /* TMFL_TDA9981_SUPPORT */
+	e_maskreg_p00_int_flags_1_sc_deil		= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_int_flags_1_sc_vid		= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_int_flags_1_sc_out		= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_int_flags_1_sc_in			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_int_flags_1_otp			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_int_flags_1_vs_rpt		= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+#ifdef TMFL_TDA9981_SUPPORT
+	e_maskreg_p00_int_flags_2_rx_sense		= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_int_flags_3_rxs_fil		= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_sw_int_sw_int				= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_ena_vp_0_ena_vp7			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp6			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp5			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp4			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp3			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp2			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp1			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_ena_vp_0_ena_vp0			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_ena_vp_1_ena_vp15			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp14			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp13			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp12			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp11			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp10			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp9			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_ena_vp_1_ena_vp8			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_ena_vp_2_ena_vp23			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp22			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp21			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp20			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp19			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp18			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp17			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_ena_vp_2_ena_vp16			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_gnd_vp_0_ena_vp7			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp6			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp5			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp4			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp3			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp2			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp1			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_gnd_vp_0_ena_vp0			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_gnd_vp_1_ena_vp15			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp14			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp13			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp12			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp11			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp10			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp9			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_gnd_vp_1_ena_vp8			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_gnd_vp_2_ena_vp23			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp22			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp21			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp20			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp19			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp18			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp17			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_gnd_vp_2_ena_vp16			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_ena_ap_ena_ap7			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap6			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap5			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap4			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap3			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap2			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_ena_ap_ena_ap1			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_ena_ap_ena_ap0			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_gnd_ap_gnd_ap7			= BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap6			= BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap5			= BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap4			= BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap3			= BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap2			= BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap1			= BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_gnd_ap_gnd_ap0			= BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	e_maskreg_p00_vip_cntrl_0_mirr_a        = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_0_swap_a        = BINARY(0, 1, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_0_mirr_b        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_0_swap_b        = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p00_vip_cntrl_1_mirr_c        = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_1_swap_c        = BINARY(0, 1, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_1_mirr_d        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_1_swap_d        = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p00_vip_cntrl_2_mirr_e        = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_2_swap_e        = BINARY(0, 1, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_2_mirr_f        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_2_swap_f        = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p00_vip_cntrl_3_edge          = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_3_sp_sync       = BINARY(0, 0, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_3_emb           = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_3_v_tgl         = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_vip_cntrl_3_h_tgl         = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_vip_cntrl_3_x_tgl         = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_vip_cntrl_4_tst_pat       = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_4_tst_656       = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_4_ccir656       = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_vip_cntrl_4_blankit       = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p00_vip_cntrl_4_blc           = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p00_vip_cntrl_5_sp_cnt        = BINARY(0, 0, 0, 0, 0, 1, 1, 0),
+	e_maskreg_p00_vip_cntrl_5_ckcase        = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_mat_contrl_mat_bp         = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_mat_contrl_mat_sc         = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p00_vidformat_vidformat       = BINARY(0, 0, 0, 1, 1, 1, 1, 1),
+
+	e_maskreg_p00_tbg_cntrl_0_sync_once     = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_0_sync_mthd     = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_0_frame_dis     = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+
+	e_maskreg_p00_tbg_cntrl_1_dwin_dis      = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vhx_ext       = BINARY(0, 0, 1, 1, 1, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vhx_ext_vs    = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vhx_ext_hs    = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vhx_ext_de    = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vh_tgl        = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+	e_maskreg_p00_tbg_cntrl_1_vh_tgl_2      = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_tbg_cntrl_1_vh_tgl_1      = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_tbg_cntrl_1_vh_tgl_0      = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_hvf_cntrl_0_sm            = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_hvf_cntrl_0_rwb           = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_hvf_cntrl_0_prefil        = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p00_hvf_cntrl_0_intpol        = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p00_hvf_cntrl_1_semi_planar   = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_hvf_cntrl_1_pad           = BINARY(0, 0, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p00_hvf_cntrl_1_vqr           = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p00_hvf_cntrl_1_yuvblk        = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_hvf_cntrl_1_for           = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_timer_h_im_clksel         = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_timer_h_wd_clksel         = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p00_timer_h_tim_h             = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p00_debug_probe_bypass        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p00_debug_probe_vid_de        = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_debug_probe_di_de         = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p00_debug_probe_woo_en        = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p00_aip_clksel_sel_aip_shift  = 3,
+	e_maskreg_p00_aip_clksel_sel_aip        = BINARY(0, 0, 0, 1, 1, 0, 0, 0),
+	e_maskreg_p00_aip_clksel_sel_pol_clk    = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p00_aip_clksel_sel_fs         = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+#ifndef TMFL_TDA9981_SUPPORT
+	e_maskreg_p01_sc_vidformat_lut_sel      = BINARY(1, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p01_sc_vidformat_vid_format_o = BINARY(0, 0, 1, 1, 1, 0, 0, 0),
+	e_maskreg_p01_sc_vidformat_vid_format_i = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p01_sc_cntrl_il_out_on        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p01_sc_cntrl_phases_v         = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p01_sc_cntrl_vs_on            = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p01_sc_cntrl_deil_on          = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p01_vidformat_vidformat       = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p01_tbg_cntrl_0_sync_once     = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p01_tbg_cntrl_0_sync_mthd     = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p01_tbg_cntrl_0_frame_dis     = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p01_tbg_cntrl_0_top_ext       = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p01_tbg_cntrl_0_de_ext        = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p01_tbg_cntrl_0_top_sel       = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p01_tbg_cntrl_0_top_tgl       = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+#endif /* TMFL_TDA9981_SUPPORT */
+	e_maskreg_p02_pll_serial_1_srl_man_ip   = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p02_pll_serial_1_srl_reg_ip   = BINARY(0, 0, 1, 1, 1, 0, 0, 0),
+	e_maskreg_p02_pll_serial_1_srl_iz       = BINARY(0, 0, 0, 0, 0, 1, 1, 0),
+	e_maskreg_p02_pll_serial_1_srl_fdn      = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_pll_serial_2_srl_pr       = BINARY(1, 1, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p02_pll_serial_2_srl_nosc     = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p02_pll_serial_3_srl_pxin_sel = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p02_pll_serial_3_srl_de       = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p02_pll_serial_3_srl_ccir     = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_serializer_srl_phase3     = BINARY(1, 1, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p02_serializer_srl_phase2     = BINARY(0, 0, 0, 0, 1, 1, 1, 1),
+
+	e_maskreg_p02_buffer_out_srl_force      = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p02_buffer_out_srl_clk        = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p02_pll_scg1_scg_fdn          = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_pll_scg2_bypass_scg       = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p02_pll_scg2_selpllclkin      = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p02_pll_scg2_scg_nosc         = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p02_pll_de_bypass_pllde       = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p02_pll_de_pllde_nosc         = BINARY(0, 0, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p02_pll_de_pllde_iz           = BINARY(0, 0, 0, 0, 0, 1, 1, 0),
+	e_maskreg_p02_pll_de_pllde_fdn          = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_ccir_div_refdiv2          = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_vai_pll_pllde_hvp         = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p02_vai_pll_pllscg_hvp        = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p02_vai_pll_pllsrl_hvp        = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p02_vai_pll_pllde_lock        = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p02_vai_pll_pllscg_lock       = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p02_vai_pll_pllsrl_lock       = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_audio_div_audio_div       = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p02_test1_tstserphoe          = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p02_test1_tst_nosc            = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p02_test1_tst_hvp             = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_test2_pwd1v8              = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p02_test2_divtestoe           = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p02_sel_clk_ena_sc_clk        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p02_sel_clk_sel_vrf_clk       = BINARY(0, 0, 0, 0, 0, 1, 1, 0),
+	e_maskreg_p02_sel_clk_sel_clk1          = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p11_aip_cntrl_0_rst_cts       = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p11_aip_cntrl_0_acr_man       = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p11_aip_cntrl_0_layout        = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p11_aip_cntrl_0_swap          = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p11_aip_cntrl_0_rst_fifo      = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p11_gc_avmute_set_mute        = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p11_gc_avmute_clr_mute        = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+	e_maskreg_p11_gc_avmute_setclr_mute     = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p11_cts_n_m_sel               = BINARY(0, 0, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p11_cts_n_k_sel               = BINARY(0, 0, 0, 0, 0, 1, 1, 1),
+
+	e_maskreg_p11_enc_cntrl_ctl_code        = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p11_enc_cntrl_rst_sel         = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p11_enc_cntrl_rst_enc         = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+	e_maskreg_p11_dip_flags_force_null      = BINARY(1, 0, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p11_dip_flags_null            = BINARY(0, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p11_dip_flags_acp             = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p11_dip_flags_isrc2           = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p11_dip_flags_isrc1           = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p11_dip_flags_gc              = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p11_dip_flags_acr             = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p11_dip_if_flags_if5          = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p11_dip_if_flags_if4          = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p11_dip_if_flags_if3          = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p11_dip_if_flags_if2          = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p11_dip_if_flags_if1          = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+
+	e_maskreg_p12_otp_cntrl_start_rd        = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p12_otp_cntrl_start_dl        = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p12_otp_cntrl_bch_act         = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p12_otp_cntrl_start_pc        = BINARY(0, 0, 0, 0, 0, 0, 0, 1),
+
+	e_maskreg_p12_otp_status_rd_d_status    = BINARY(1, 1, 0, 0, 0, 0, 0, 0),
+	e_maskreg_p12_otp_status_rd_c_status    = BINARY(0, 0, 1, 1, 0, 0, 0, 0),
+	e_maskreg_p12_otp_status_rd_b_status    = BINARY(0, 0, 0, 0, 1, 1, 0, 0),
+	e_maskreg_p12_otp_status_rd_a_status    = BINARY(0, 0, 0, 0, 0, 0, 1, 1),
+
+	e_maskreg_p12_hdcp_tx_33_ac_not          = BINARY(0, 0, 1, 0, 0, 0, 0, 0),
+	e_maskreg_p12_hdcp_tx_33_ctl_sel         = BINARY(0, 0, 0, 1, 0, 0, 0, 0),
+	e_maskreg_p12_hdcp_tx_33_sys_req         = BINARY(0, 0, 0, 0, 1, 0, 0, 0),
+	e_maskreg_p12_hdcp_tx_33_eess            = BINARY(0, 0, 0, 0, 0, 1, 0, 0),
+	e_maskreg_p12_hdcp_tx_33_hdmi            = BINARY(0, 0, 0, 0, 0, 0, 1, 0),
+	e_maskreg_p12_hdcp_tx_33_avmute          = BINARY(0, 0, 0, 0, 0, 0, 0, 1)
+};
+#undef BINARY
+
+/**
+ * An enum for the video formats used in the E_REG_P00_VIDFORMAT_W register
+ * */
+enum _e_reg_vfmt {
+	e_regvfmt_640x480p_60hz     = 0,
+	e_regvfmt_720x480p_60hz     ,
+	e_regvfmt_1280x720p_60hz    ,
+	e_regvfmt_1920x1080i_60hz   ,
+	e_regvfmt_720x480i_60hz     ,
+	e_regvfmt_720x240p_60hz     ,
+	e_regvfmt_1920x1080p_60hz   ,
+	e_regvfmt_720x576p_50hz     ,
+	e_regvfmt_1280x720p_50hz    ,
+	e_regvfmt_1920x1080i_50hz   ,
+	e_regvfmt_720x576i_50hz     ,
+	e_regvfmt_720x288p_50hz     ,
+	e_regvfmt_1920x1080p_50hz   ,
+	e_regvfmt_1920x1080p_24hz   ,
+	e_regvfmt_1920x1080p_25hz   ,
+	e_regvfmt_1920x1080p_30hz   ,
+#ifdef FORMAT_PC
+	e_regvfmt_640x480p_72hz     ,
+	e_regvfmt_640x480p_75hz     ,
+	e_regvfmt_640x480p_85hz     ,
+	e_regvfmt_800x600p_60hz     ,
+	e_regvfmt_800x600p_72hz     ,
+	e_regvfmt_800x600p_75hz     ,
+	e_regvfmt_800x600p_85hz     ,
+	e_regvfmt_1024x768p_60hz    ,
+	e_regvfmt_1024x768p_70hz    ,
+	e_regvfmt_1024x768p_75hz    ,
+	e_regvfmt_1280x768p_60hz    ,
+	e_regvfmt_1280x1024p_60hz   ,
+	e_regvfmt_1280x1024p_75hz   ,
+	e_regvfmt_1360x768p_60hz    ,
+	e_regvfmt_1400x1050p_60hz   ,
+	e_regvfmt_1600x1200p_60hz   ,
+#endif /*FORMAT_PC*/
+
+	E_REGVFMT_INVALID           ,
+	E_REGVFMT_NUM_TV            = e_regvfmt_1920x1080p_30hz + 1,
+	E_REGVFMT_NUM_TV_NO_REG		= E_REGVFMT_NUM_TV - e_regvfmt_1920x1080p_24hz,
+	E_REGVFMT_FIRST_TV_NO_REG	= e_regvfmt_1920x1080p_24hz,
+	E_REGVFMT_NUM               = E_REGVFMT_INVALID
+
+#ifdef FORMAT_PC
+	, E_REGVFMT_FIRST_PC_FORMAT = e_regvfmt_640x480p_72hz,
+	E_REGVFMT_NUM_PC          = e_regvfmt_1600x1200p_60hz - E_REGVFMT_NUM_TV + 1
+
+#endif
+
+};
+
+/**
+ * An enum for the video input formats used in the E_REG_P01_SC_VIDFORMAT_W
+ * register
+ * */
+enum _e_reg_vfmt_sc_in {
+	e_regvfmt_scin_480i_60hz    = 0,
+	e_regvfmt_scin_576i_50hz    = 1,
+	e_regvfmt_scin_480p_60hz    = 2,
+	e_regvfmt_scin_576p_50hz    = 3,
+	E_REGVFMT_SCIN_MAX          = 3,
+	E_REGVFMT_SCIN_NUM          = 4,
+	E_REGVFMT_SCIN_INVALID      = 4
+};
+
+/**
+ * An enum for the video output formats used in the E_REG_P01_SC_VIDFORMAT_W
+ * register
+ * */
+enum _e_reg_vfmt_sc_out {
+	e_regvfmt_scout_480p_60hz       = 0,
+	e_regvfmt_scout_576ip_50hz      = 1,
+	e_regvfmt_scout_720p_50hz_60hz  = 2,
+	e_regvfmt_scout_1080i_50hz_60hz = 3,
+	E_REGVFMT_SCOUT_MAX             = 3,
+	E_REGVFMT_SCOUT_NUM             = 4,
+	E_REGVFMT_SCOUT_INVALID         = 4
+};
+
+/**
+ * An enum to list all supported pixel clock frequencies in kHz
+ * */
+enum _e_pix_clk {
+	E_PIXCLK_25175      = 0,
+	E_PIXCLK_25200      = 1,
+	E_PIXCLK_27000      = 2,
+	E_PIXCLK_27027      = 3,
+	E_PIXCLK_54000      = 4,
+	E_PIXCLK_54054      = 5,
+	E_PIXCLK_74175      = 6,
+	E_PIXCLK_74250      = 7,
+	E_PIXCLK_148350     = 8,
+	E_PIXCLK_148500     = 9,
+#ifndef FORMAT_PC
+	E_PIXCLK_MAX        = 9,
+	E_PIXCLK_INVALID    = 10,
+	E_PIXCLK_NUM        = 10
+#else /* FORMAT_PC */
+	E_PIXCLK_31500      = 10,
+	E_PIXCLK_36000      = 11,
+	E_PIXCLK_40000      = 12,
+	E_PIXCLK_49500      = 13,
+	E_PIXCLK_50000      = 14,
+	E_PIXCLK_56250      = 15,
+	E_PIXCLK_65000      = 16,
+	E_PIXCLK_75000      = 17,
+	E_PIXCLK_78750      = 18,
+	E_PIXCLK_79500      = 19,
+	E_PIXCLK_85500      = 20,
+	E_PIXCLK_108000     = 21,
+	E_PIXCLK_121750     = 22,
+	E_PIXCLK_135000		= 23,
+	E_PIXCLK_162000     = 24,
+	E_PIXCLK_MAX        = 24,
+	E_PIXCLK_INVALID    = 25,
+	E_PIXCLK_NUM        = 25
+#endif /* FORMAT_PC */
+};
+
+/**
+ * An enum to list all device version codes supported by this driver.
+ * The values form a list, with non-zero version codes first in any order.
+ * The E_DEV_VERSION_END_LIST must be the last value in the list.
+ * */
+enum _e_dev_version {
+	E_DEV_VERSION_N2            = 0x40,
+	E_DEV_VERSION_N3            = 0x41,
+#ifdef TMFL_TDA9981_SUPPORT
+	E_DEV_VERSION_N4            = 0x00,
+	E_DEV_VERSION_LIST_END      = 0xCF,
+#else /* TMFL_TDA9981_SUPPORT */
+	E_DEV_VERSION_N4            = 0x42,
+	E_DEV_VERSION_LIST_END      = 0x00,
+#endif /* TMFL_TDA9981_SUPPORT */
+	E_DEV_VERSION_LIST_NUM      = 4         /**< Number of items in list */
+};
+
+/**
+ * An enum to list all CEA Data Block Tag Codes we may find in EDID.
+ * */
+enum _e_cea_block_tags {
+	E_CEA_RESERVED_0     = 0x00,
+	E_CEA_AUDIO_BLOCK    = 0x01,
+	E_CEA_VIDEO_BLOCK    = 0x02,
+	E_CEA_VSDB           = 0x03,
+	E_CEA_SPEAKER_ALLOC  = 0x04,
+	E_CEA_VESA_DTC       = 0x05,
+	E_CEA_RESERVED_6     = 0x06,
+	E_CEA_EXTENDED       = 0x07
+};
+
+/** A typedef for colourspace values */
+typedef enum {
+	HDMITX_CS_RGB_FULL              = 0,    /**< RGB Full (PC) */
+	HDMITX_CS_RGB_LIMITED           = 1,    /**< RGB Limited (TV) */
+	HDMITX_CS_YUV_ITU_BT601         = 2,    /**< YUV ITUBT601 (SDTV) */
+	HDMITX_CS_YUV_ITU_BT709         = 3,    /**< YUV ITUBT709 (HDTV) */
+	HDMITX_CS_NUM                   = 4     /**< Number Cspaces we support */
+} bsl_colourspace_t;
+
+/** Matrix register block size */
+#define MATRIX_PRESET_SIZE		    31
+
+/** Matrix register block size */
+#define MATRIX_PRESET_QTY		    12
+
+/** The enum that vectors us into the MatrixPreset table */
+enum _e_matrix_preset_index {
+	E_MATRIX_RGBF_2_RGBL    = 0,
+	E_MATRIX_RGBF_2_BT601   = 1,
+	E_MATRIX_RGBF_2_BT709   = 2,
+	E_MATRIX_RGBL_2_RGBF    = 3,
+	E_MATRIX_RGBL_2_BT601   = 4,
+	E_MATRIX_RGBL_2_BT709   = 5,
+	E_MATRIX_BT601_2_RGBF   = 6,
+	E_MATRIX_BT601_2_RGBL   = 7,
+	E_MATRIX_BT601_2_BT709  = 8,
+	E_MATRIX_BT709_2_RGBF   = 9,
+	E_MATRIX_BT709_2_RGBL   = 10,
+	E_MATRIX_BT709_2_BT601  = 11
+};
+
+/** EDID block size */
+#define EDID_BLOCK_SIZE		    128
+
+/** number of detailed timing descriptor stored in BSL */
+#define NUMBER_DTD_STORED       10
+
+/** EDID DTD block descriptor size */
+#define EDID_DTD_BLK_SIZE       0x12
+
+/** EDID i2c address */
+#define DDC_EDID_ADDRESS        0xA0
+
+/** EDID alternate i2c address */
+#define DDC_EDID_ADDRESS_ALT    0xA2
+
+/** EDID Segment Pointer address */
+#define DDC_SGMT_PTR_ADDRESS    0x60
+
+/** EDID block 0 parse start point */
+#define EDID_BLK0_BASE          0x36
+
+/** EDID block 0 descriptor size */
+#define EDID_BLK0_SIZE          0x12
+
+/** EDID block 0 extension block count */
+#define EDID_BLK0_EXT_CNT       0x7E
+
+/** EDID extension block parse start point */
+#define EDID_BLK_EXT_BASE       0x04
+
+/** CEA extension block type */
+#define EDID_CEA_EXTENSION      0x02
+
+/**
+ * \brief A structure type to form arrays that hold a series of registers and
+ * values
+ * */
+typedef struct _tm_hdmi_tx_reg_val_t {
+	u16 reg;
+	u8  val;
+} hdmi_tx_reg_val_t;
+
+/**
+ * \brief A structure type to form arrays that hold a series of registers,
+ * bitfield masks and bitfield values
+ * */
+typedef struct _tm_hdmi_tx_reg_mask_val_t {
+	u16 reg;
+	u8  mask;
+	u8  val;
+} hdmi_tx_reg_mask_val_t;
+
+/**
+ * \brief A function pointer type to call a function and return a result
+ * */
+typedef error_code_t (FUNC_PTR *p_hdmi_tx_func_t)(unit_select_t tx_unit);
+
+/**
+ * \brief The structure of a TM998x object, one per device unit
+ ****************************************************************************
+ ** copy changes to k_test_dis_names tab in "HDMI driver - register list.xls" **
+ ****************************************************************************
+ * */
+typedef struct _tm_hdmi_txobject_t {
+	/** Component State */
+	bsl_state_t state;
+
+	/** Count of events ignored by setState() */
+	u8 n_ignored_events;
+
+	/** Device unit number */
+	unit_select_t tx_unit;
+
+	/** Device I2C slave address */
+	u8 u_hw_address;
+
+	/** System function to write to the I2C driver */
+	pbsl_sys_func_t sys_func_write;
+
+	/** System function to read from the I2C driver */
+	pbsl_sys_func_t sys_func_read;
+
+	/** System function to read EDID blocks via the I2C driver */
+	pbsl_sys_func_edid_t sys_func_edid_read;
+
+	/** System function to run a timer */
+	pbsl_sys_func_timer_t sys_func_timer;
+
+	/** Array of registered interrupt handler callback functions */
+	pbsl_callback_t func_int_callbacks[HDMITX_CALLBACK_INT_NUM];
+
+	/** Device version(s) supported by this component */
+	u8 u_supported_versions[E_DEV_VERSION_LIST_NUM];
+
+	/** Device version read from register, with features flags masked out */
+	u8 u_device_version;
+
+	/** Device features flags read from version register */
+	u8 u_device_features;
+
+	/** The device's power state */
+	power_state_t e_power_state;
+
+	/*=== E D I D ===*/
+
+	/** EDID Use alternative i2c address flag */
+	bool b_edid_alternate_addr;
+
+	/** The sink type set by the user (may or may not match EdidSinkType) */
+	bsl_sink_type_t sink_type;
+
+	/** EDID Sink Type for receiver */
+	bsl_sink_type_t edid_sink_type;
+
+	/** EDID AI_Support from HDMI VSDB */
+	bool edid_sink_ai;
+
+	/** EDID CEA flags from extension block */
+	u8 edid_cea_flags;
+
+	/** EDID Read Status */
+	u8 edid_status;
+
+	/** NB DTD stored in EdidDTD */
+	u8 nb_dtdstored;
+
+	/** EDID  Detailed Timing Descriptor */
+	bsl_edid_dtd_t edid_dtd[NUMBER_DTD_STORED];
+
+	/** EDID First Moniteur descriptor */
+	bsl_edid_first_md_t edid_first_monitor_descriptor;
+
+	/** EDID Second Moniteur descriptor */
+	bsl_edid_second_md_t edid_second_monitor_descriptor;
+
+	/** EDID Other Moniteur descriptor */
+	bsl_edid_other_md_t edid_other_monitor_descriptor;
+
+	/** EDID supported Short Video Descriptors */
+	u8 edid_vfmts[HDMI_TX_SVD_MAX_CNT];
+
+	/** Counter for supported short video descriptors */
+	u8 edid_svd_cnt;
+
+	/** EDID supported Short Audio Descriptors */
+	bsl_edid_sad_t edid_afmts[HDMI_TX_SAD_MAX_CNT];
+
+	/** Counter for supported short audio descriptors */
+	u8 edid_sad_cnt;
+
+	/** EDID block workspace */
+	u8 edid_block[EDID_BLOCK_SIZE];
+
+	/** EDID Block Count */
+	u8 edid_block_cnt;
+
+	/** CEC Source Address read from EDID as "A.B.C.D" nibbles */
+	u16 edid_source_address;
+
+	/** EDID Basic Display Parameters */
+	bsl_edid_bdparam_t edidbasic_display_param;
+
+	/*=== V I D E O ===*/
+
+	/** Current EIA/CEA video input format */
+	bsl_vid_fmt_t vin_fmt;
+
+	/** Current EIA/CEA video output format */
+	bsl_vid_fmt_t vout_fmt;
+
+	/** Current pix Rate*/
+	bsl_pix_rate_t pix_rate;
+
+	/** Video input mode */
+	bsl_vin_mode_t vin_mode;
+
+	/** Video output mode */
+	bsl_vout_mode_t vout_mode;
+
+	/** Vertical output frequency */
+	bsl_vfreq_t vout_freq;
+
+	/** Current scaler mode */
+	bsl_sca_mode_t sca_mode;
+
+	/** Current upsampler mode */
+	bsl_upsample_mode_t upsample_mode;
+
+	/** Current pixel repetition count */
+	u8 pixel_repeat_count;
+
+	/** Status of hot plug detect pin last read at interrupt */
+	bsl_hot_plug_t hot_plug_status;
+
+#ifdef TMFL_TDA9981_SUPPORT
+#ifdef TMFL_RX_SENSE_ON
+	/** Status of rx sense detect pin last read at interrupt */
+	bsl_rx_sense_t rx_sense_status;
+#endif /* TMFL_RX_SENSE_ON */
+#endif /* TMFL_TDA9981_SUPPORT */
+
+	/** Current register page */
+	u8 cur_reg_page;
+
+	/** Shadow copies of write-only registers with bitfields */
+	u8 shadow_reg[E_SNUM];
+
+	/** true: Blue screen is the previous test pattern ; false: is not */
+	bool prev_bluescreen;
+
+	/** true: last screen is test pattern ; false: is not */
+	bool prev_pattern;
+
+	/** true: Unit has been initialized; false: not initialized */
+	bool b_initialized;
+
+	bsl_vqr_t        dvi_vqr;
+
+} hdmi_txobject_t;
+
+/**
+ * \The structure of registers for video format ,
+ *  used by PC_formats and chip_unknown formats
+ * */
+
+typedef struct _tm_hdmi_tx_vid_reg_t {
+	u16  n_pix;
+	u16  n_line;
+	u8   vs_line_start;
+	u16  vs_pix_start;
+	u8   vs_line_end;
+	u16  vs_pix_end;
+	u16  hs_start;
+	u16  hs_end;
+	u8   v_win_start;
+	u16  v_win_end;
+	u16  de_start;
+	u16  de_end;
+} hdmi_tx_vid_reg_t;
+
+/*============================================================================*/
+/*                       EXTERN DATA DEFINITION                               */
+/*============================================================================*/
+
+extern RAM_DAT  hdmi_txobject_t g_hdmi_tx_instance[HDMITX_UNITS_MAX];
+extern CONST_DAT u8 k_page_index_to_page[E_PAGE_NUM];
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+error_code_t    check_unit_set_dis(unit_select_t tx_unit,
+                                   hdmi_txobject_t **pp_dis);
+error_code_t    get_hw_registers(hdmi_txobject_t *p_dis,
+                                 u16 reg_shad_page_addr,
+                                 u8 *p_data, u16 len_data);
+error_code_t    get_hw_register(hdmi_txobject_t *p_dis,
+                                u16 reg_shad_page_addr,
+                                u8 *p_reg_value);
+error_code_t    set_hw_registers(hdmi_txobject_t *p_dis,
+                                 u16 reg_shad_page_addr,
+                                 u8 *p_data, u16 len_data);
+error_code_t    set_hw_register_msb_lsb(hdmi_txobject_t *p_dis,
+                                        u16 reg_shad_page_addr,
+                                        u16 reg_word);
+error_code_t    set_hw_register(hdmi_txobject_t *p_dis,
+                                u16 reg_shad_page_addr,
+                                u8 reg_value);
+error_code_t    set_hw_register_field(hdmi_txobject_t *p_dis,
+                                      u16 reg_shad_page_addr,
+                                      u8 field_mask, u8 field_value);
+error_code_t    set_hw_register_field_table(hdmi_txobject_t *p_dis,
+        const hdmi_tx_reg_mask_val_t *p_table);
+
+error_code_t    set_state(hdmi_txobject_t *p_dis, bsl_event_t event);
+
+error_code_t    lmemcpy(void *p_table1,
+                        const void *p_table2,
+                        uint size);
+error_code_t    lmemset(void *p_table1,
+                        const u8 value,
+                        uint size);
+
+#endif /* BSLHDMITX_LOCAL_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.c b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.c
new file mode 100755
index 0000000..e7666c2
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.c
@@ -0,0 +1,1062 @@
+/*
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          dlHdmiCEC_IW.c
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 06/02/07 8:32 $
+ *
+ * \brief         devlib driver component API for the CEC Messages
+ *
+ * \section refs  Reference Documents
+ *
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: dlHdmiCEC_IW.c $
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#ifdef TMFL_OS_WINDOWS
+#define _WIN32_WINNT 0x0500
+#include "windows.h"
+#else
+#include "RTL.h"
+#endif
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+#include "tmdlHdmiCEC_Types.h"
+#include "tmdlHdmiCEC_cfg.h"
+#include "tmdlHdmiCEC_IW.h"
+
+/*============================================================================*/
+/*                       DEFINES                                              */
+/*============================================================================*/
+
+/* maximum number of tasks that can be handled by the wrapper */
+#define MAX_TASKS  4
+/* maximum number of message queues that can be handled by the wrapper */
+#define MAX_QUEUES 4
+/* maximum number of message queues that can be handled by the wrapper */
+#define MAX_SEMA   4
+
+/*============================================================================*/
+/*                                MACRO                                       */
+/*============================================================================*/
+
+/* macro for quick error handling */
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+
+/*============================================================================*/
+/*                       TYPE DEFINITIONS                                     */
+/*============================================================================*/
+
+#ifdef TMFL_OS_WINDOWS
+/* structure describing each task handled by the wrapper */
+typedef struct {
+	bool                   created;
+	bool                   started;
+	u8                  priority;
+	u16                 stack_size;
+	DWORD                  thread_id;
+	HANDLE                 thread_handle;
+	LPTHREAD_START_ROUTINE associated_thread;
+	tx_iwfunc_ptr_t            associated_task;
+} iw_tcb_t;
+
+/* structure describing each message queue handled by the wrapper */
+typedef struct {
+	bool    created;
+	HANDLE  access_semaphore;
+	HANDLE  count_semaphore;
+	u16  queue_fullness;
+	u16  queue_size;
+	u16  write_pointer;
+	u16  read_pointer;
+	u8  *queue;
+} iw_queue_t;
+
+/*============================================================================*/
+/*                       FUNCTION PROTOTYPES                                  */
+/*============================================================================*/
+
+DWORD WINAPI thread_proc0(LPVOID lp_parameter);
+DWORD WINAPI thread_proc1(LPVOID lp_parameter);
+DWORD WINAPI thread_proc2(LPVOID lp_parameter);
+DWORD WINAPI thread_proc3(LPVOID lp_parameter);
+
+/*============================================================================*/
+/*                       VARIABLES                                            */
+/*============================================================================*/
+
+/* table storing all tasks descriptions */
+iw_tcb_t task_table[MAX_TASKS] = {
+	{false, false, 0, 0, 0, NULL, thread_proc0},
+	{false, false, 0, 0, 0, NULL, thread_proc1},
+	{false, false, 0, 0, 0, NULL, thread_proc2},
+	{false, false, 0, 0, 0, NULL, thread_proc3}
+};
+
+/* table storing all message queues descriptions */
+iw_queue_t queue_table[MAX_QUEUES] = {
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL}
+};
+
+/*============================================================================*/
+/*                       FUNCTION                                                */
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a task and allocates all the necessary resources. Note that creating a task do not start it automatically, an explicit call to IWTaskStart must be made.
+ *
+ *    \param pFunc        Pointer to the function that will be executed in the task context.
+ *    \param Priority     Priority of the task. The minimum priority is 0, the maximum is 255.
+ *    \param StackSize    Size of the stack to allocate for this task.
+ *    \param pHandle      Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_create
+(
+    tx_iwfunc_ptr_t     p_func,
+    u8           priority,
+    u16          stack_size,
+    tx_iwtask_handle_t  *p_handle
+)
+{
+	u32 i;
+
+	/* check that input pointer is not NULL */
+	RETIF(p_func == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* search for available task slot */
+	for(i = 0; i < MAX_TASKS; i++) {
+		if(task_table[i].created == false)
+			break;
+
+	}
+	RETIF(i >= MAX_TASKS, ERR_DLHDMICEC_NO_RESOURCES)
+
+	/* store task parameters into the dedicated structure */
+	task_table[i].priority = priority;
+	task_table[i].stack_size = stack_size;
+	task_table[i].associated_task = p_func;
+	task_table[i].created = true;
+
+	*p_handle = (tx_iwtask_handle_t)i;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief    This function destroys an existing task and frees resources used by it.
+ *
+ *    \param Handle        Handle of the task to be destroyed, as returned by IWTaskCreate.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_destroy
+(
+    tx_iwtask_handle_t handle
+)
+{
+	/* check if handle number is in range */
+	RETIF((handle < 0) || (handle >= MAX_TASKS), ERR_DLHDMICEC_BAD_HANDLE)
+
+	/* check if handle corresponding to task is created */
+	RETIF(task_table[handle].created == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	if(task_table[handle].started == true) {
+		terminate_thread(task_table[handle].thread_handle, 0);
+		task_table[handle].started = false;
+	}
+	task_table[handle].created = false;
+	close_handle(task_table[handle].thread_handle);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function start an existing task.
+ *
+ *    \param Handle        Handle of the task to be started.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_ALREADY_STARTED: the function is already started
+ *            - ERR_DLHDMICEC_NOT_STARTED: the function is not started
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_start(tx_iwtask_handle_t handle)
+{
+	HANDLE thread_handle;
+
+	/* check if handle number is in range */
+	RETIF((handle < 0) || (handle >= MAX_TASKS), ERR_DLHDMICEC_BAD_HANDLE)
+
+	/* check if task is already started */
+	RETIF(task_table[handle].started == true, ERR_DLHDMICEC_ALREADY_STARTED)
+
+	/* start thread associated to the task */
+	thread_handle = create_thread(NULL,
+	                              (SIZE_T)task_table[handle].stack_size,
+	                              task_table[handle].associated_thread,
+	                              NULL,
+	                              0,
+	                              &(task_table[handle].thread_id));
+
+	/* check return code for errors */
+	RETIF(!thread_handle, ERR_DLHDMICEC_NOT_STARTED)
+
+	/* update task status */
+	task_table[handle].thread_handle = thread_handle;
+	task_table[handle].started = true;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function blocks the current task for the specified amount time. This is a passive wait.
+ *
+ *    \param Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait(u16 duration)
+{
+	HANDLE        timer_handle;
+	LARGE_INTEGER time;
+
+	timer_handle = create_waitable_timer(NULL, true, NULL);
+	RETIF(timer_handle == NULL, ERR_DLHDMICEC_NO_RESOURCES)
+
+	time.quad_part = -10000 * (long)duration;
+	set_waitable_timer(timer_handle, &time, 0, NULL, NULL, false);
+	wait_for_single_object(timer_handle, INFINITE);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a message queue.
+ *
+ *    \param QueueSize    Maximum number of messages in the message queue.
+ *    \param pHandle        Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_create(u8 queue_size, tx_iwqueue_handle_t *p_handle)
+{
+	u32 i;
+
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* search for available queue slot */
+	for(i = 0; i < MAX_QUEUES; i++) {
+		if(queue_table[i].created == false)
+			break;
+
+	}
+
+	RETIF(i >= MAX_QUEUES, ERR_DLHDMICEC_NO_RESOURCES)
+
+	/* allocate memory for the queue */
+	queue_table[i].queue = (u8 *)global_alloc(GMEM_FIXED, queue_size);
+	RETIF(queue_table[i].queue == NULL, ERR_DLHDMICEC_NO_RESOURCES)
+
+	/* allocate semaphores for the queue */
+	queue_table[i].count_semaphore = create_semaphore(NULL, 0, queue_size, NULL);
+	RETIF(queue_table[i].count_semaphore == NULL, ERR_DLHDMICEC_NO_RESOURCES)
+
+	queue_table[i].access_semaphore = create_semaphore(NULL, 1, 1, NULL);
+	RETIF(queue_table[i].access_semaphore == NULL, ERR_DLHDMICEC_NO_RESOURCES)
+
+	/* update status of the queue table */
+	queue_table[i].created = true;
+	queue_table[i].queue_size = queue_size;
+	*p_handle = (tx_iwqueue_handle_t)i;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing message queue.
+ *
+ *    \param    Handle        Handle of the queue to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_destroy(tx_iwqueue_handle_t handle)
+{
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMICEC_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	global_free((LPVOID)queue_table[handle].queue);
+	close_handle(queue_table[handle].count_semaphore);
+	close_handle(queue_table[handle].access_semaphore);
+	queue_table[handle].created = false;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function sends a message into the specified message queue.
+ *
+ *    \param Handle    Handle of the queue that will receive the message.
+ *    \param Message   Message to be sent.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_send(tx_iwqueue_handle_t handle, u8 message)
+{
+	error_code_t error_code = 0;
+
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMICEC_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created != true, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* ask for exclusive access to this queue */
+	wait_for_single_object(queue_table[handle].access_semaphore, INFINITE);
+
+	if(queue_table[handle].queue_fullness < (queue_table[handle].queue_size - 1)) {
+		queue_table[handle].queue[queue_table[handle].write_pointer] = message;
+		queue_table[handle].queue_fullness++;
+		queue_table[handle].write_pointer++;
+		if(queue_table[handle].write_pointer == queue_table[handle].queue_size) {
+			queue_table[handle].write_pointer = 0;
+		}
+		release_semaphore(queue_table[handle].count_semaphore, 1, NULL);
+	} else {
+		error_code = ERR_DLHDMICEC_FULL;
+	}
+
+	/* release access to this queue */
+	release_semaphore(queue_table[handle].access_semaphore, 1, NULL);
+
+	return(0);
+}
+/*============================================================================*/
+
+/**
+ *    \brief This function reads a message from the specified message queue.
+ *
+ *    \param    Handle        Handle of the queue from which to read the message.
+ *    \param    pMessage      Pointer to the message buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_receive(tx_iwqueue_handle_t handle, u8 *p_message)
+{
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMICEC_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created != true, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_message == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* ask for a new message by acquiring the counting semaphore */
+	wait_for_single_object(queue_table[handle].count_semaphore, INFINITE);
+
+	/* if we reach this point, this means that we got a message */
+	/* ask for exclusive access to this queue */
+	wait_for_single_object(queue_table[handle].access_semaphore, INFINITE);
+
+	*p_message = queue_table[handle].queue[queue_table[handle].read_pointer];
+	queue_table[handle].queue_fullness--;
+	queue_table[handle].read_pointer++;
+	if(queue_table[handle].read_pointer == queue_table[handle].queue_size) {
+		queue_table[handle].read_pointer = 0;
+	}
+
+	/* release access to this queue */
+	release_semaphore(queue_table[handle].access_semaphore, 1, NULL);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a semaphore.
+ *
+ *    \param     pHandle    Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create(tx_iwsem_handle_t *p_handle)
+{
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	*p_handle = (tx_iwsem_handle_t)create_semaphore(NULL, 1, 1, NULL);
+
+	RETIF((*p_handle) == NULL, ERR_DLHDMICEC_NO_RESOURCES)
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy(tx_iwsem_handle_t handle)
+{
+	RETIF(close_handle(handle) == false, ERR_DLHDMICEC_BAD_HANDLE)
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function acquires the specified semaphore.
+ *
+ *    \param Handle        Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p(tx_iwsem_handle_t handle)
+{
+	RETIF(wait_for_single_object(handle, INFINITE) != WAIT_OBJECT_0, ERR_DLHDMICEC_BAD_HANDLE)
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function releases the specified semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v(tx_iwsem_handle_t handle)
+{
+	RETIF(release_semaphore(handle, 1, NULL) == 0, ERR_DLHDMICEC_BAD_HANDLE)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function disables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwdisable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+	device;
+}
+
+/******************************************************************************
+ *    \brief  This function enables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwenable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+	device;
+}
+
+DWORD WINAPI thread_proc0(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[0].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[0].started = false;
+
+	return(0);
+}
+
+DWORD WINAPI thread_proc1(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[1].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[1].started = false;
+
+	return(0);
+}
+
+DWORD WINAPI thread_proc2(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[2].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[2].started = false;
+
+	return(0);
+}
+
+DWORD WINAPI thread_proc3(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[3].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[3].started = false;
+
+	return(0);
+}
+#else
+
+/*============================================================================*/
+/*                       TYPE DEFINITIONS                                     */
+/*============================================================================*/
+
+/* structure describing each task handled by the wrapper */
+typedef struct {
+	bool                   created;
+	bool                   started;
+	u8                  priority;
+	u16                 stack_size;
+	uint                   thread_handle;
+	tx_iwfunc_ptr_t            associated_task;
+} iw_tcb_t;
+
+/* structure describing each message queue handled by the wrapper */
+#define Queue_default_Size 128
+
+os_mbx_declare(mbox0, queue_default_size);
+os_mbx_declare(mbox1, queue_default_size);
+os_mbx_declare(mbox2, queue_default_size);
+os_mbx_declare(mbox3, queue_default_size);
+
+_declare_box(mpool0, sizeof(u8), queue_default_size);
+_declare_box(mpool1, sizeof(u8), queue_default_size);
+_declare_box(mpool2, sizeof(u8), queue_default_size);
+_declare_box(mpool3, sizeof(u8), queue_default_size);
+
+typedef struct {
+	bool            created;
+	u16          queue_size;
+	void           *mbox;
+	void           *mpool;
+} iw_queue_t;
+
+/* structure describing each task handled by the wrapper */
+typedef struct {
+	bool                    created;
+	OS_SEM                  handle;
+} iw_sem_t;
+/*============================================================================*/
+/*                       FUNCTION PROTOTYPES                                  */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       VARIABLES                                            */
+/*============================================================================*/
+
+/* table storing all tasks descriptions */
+iw_tcb_t task_table[MAX_TASKS] = {
+	{false, false, 0, 0, 0, NULL},
+	{false, false, 0, 0, 0, NULL},
+	{false, false, 0, 0, 0, NULL},
+	{false, false, 0, 0, 0, NULL}
+};
+
+/* table storing all message queues descriptions */
+iw_queue_t queue_table[MAX_QUEUES] = {
+	{false, 0, mbox0, mpool0},
+	{false, 0, mbox1, mpool1},
+	{false, 0, mbox2, mpool2},
+	{false, 0, mbox3, mpool3}
+};
+
+/* table storing all message queues descriptions */
+iw_sem_t sem_table[MAX_SEMA] = {
+	{false, 0},
+	{false, 0},
+	{false, 0},
+	{false, 0},
+};
+/*============================================================================*/
+/*                       FUNCTION                                                */
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a task and allocates all the necessary resources. Note that creating a task do not start it automatically, an explicit call to IWTaskStart must be made.
+ * Parameters:
+ *
+ *    \param pSWVersion    Pointer to the version structure
+ *    \param pFunc        Pointer to the function that will be executed in the task context.
+ *    \param Priority        Priority of the task. The minimum priority is 0, the maximum is 255.
+ *    \param StackSize    Size of the stack to allocate for this task.
+ *    \param pHandle        Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0        If call is successful.
+ *            - NOK    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_create(tx_iwfunc_ptr_t     p_func,
+                              u8           priority,
+                              u16          stack_size,
+                              tx_iwtask_handle_t *p_handle)
+{
+	u32 i;
+
+	/* search for available task slot */
+	for(i = 0; i < MAX_TASKS; i++) {
+		if(task_table[i].created == false)
+			break;
+
+	}
+	if(i >= MAX_TASKS) return(ERR_NO_RESOURCES);
+
+	/* store task parameters into the dedicated structure */
+	task_table[i].priority = priority;
+	task_table[i].stack_size = stack_size;
+	task_table[i].associated_task = p_func;
+	task_table[i].created = true;
+
+	*p_handle = (tx_iwtask_handle_t)i;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief    This function destroys an existing task and frees resources used by it.
+ *
+ *    \param Handle        Handle of the task to be destroyed, as returned by TxIWTaskCreate.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_destroy(tx_iwtask_handle_t handle)
+{
+	if(task_table[handle].started == true) {
+		if(os_tsk_delete(task_table[handle].thread_handle) == OS_R_OK) {
+			task_table[handle].started = false;
+		} else {
+			return ~0;
+		}
+	}
+	task_table[handle].created = false;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function start an existing task.
+ *
+ *    \param Handle        Handle of the task to be started.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_start(tx_iwtask_handle_t handle)
+{
+	uint thread_handle;
+
+	/* check if task is already started */
+	if(task_table[handle].started == true)
+		return(ERR_ALREADY_STARTED);
+
+	/* start thread associated to the task */
+	thread_handle = os_tsk_create(task_table[handle].associated_task,
+	                              task_table[handle].priority);
+
+	/* check return code for errors */
+	if(!thread_handle) {
+		return(ERR_NOT_STARTED);
+	}
+
+	/* update task status */
+	task_table[handle].thread_handle = thread_handle;
+	task_table[handle].started = true;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function blocks the current task for the specified amount time. This is a passive wait.
+ *
+ *    \param Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait(u16 duration)
+{
+	/*TODO perform conversion with Tick system in order to consider ms */
+	os_dly_wait(duration / 10);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a message queue.
+ *
+ *    \param QueueSize    Maximum number of messages in the message queue.
+ *    \param pHandle        Pointer to the handle buffer.
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_create(u8 queue_size, tx_iwqueue_handle_t *p_handle)
+{
+	u8 i;
+
+	if(queue_size > queue_default_size) return ERR_BAD_PARAMETER;
+
+	/* search for available queue slot */
+	for(i = 0; i < MAX_QUEUES; i++) {
+		if(queue_table[i].created == false)
+			break;
+
+	}
+	if(i >= MAX_QUEUES) return(ERR_NO_RESOURCES);
+
+	*p_handle = i;
+
+	/* Initialisation of queue object */
+	/*TODO check if we can reuse deleted queue */
+	_init_box(queue_table[i].mpool, sizeof(queue_table[i].mpool), sizeof(u8));
+	os_mbx_init(queue_table[i].mbox, sizeof(queue_table[i].mbox));
+
+	/* update status of the queue table */
+	queue_table[i].created = true;
+	queue_table[i].queue_size = queue_size;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing message queue.
+ *
+ *    \param    Handle        Handle of the queue to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_destroy(tx_iwqueue_handle_t handle)
+{
+	void *msg;
+
+	RETIF(handle > MAX_QUEUES, ERR_BAD_HANDLE);
+	RETIF(queue_table[handle].created == false, ERR_BAD_HANDLE);
+
+	while(os_mbx_check(queue_table[handle].mbox) != queue_table[handle].queue_size) {
+		RETIF(os_mbx_wait(queue_table[handle].mbox, &msg, 10) == OS_R_TMO, ERR_TIMEOUT);
+	}
+
+	queue_table[handle].created = false;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function sends a message into the specified message queue.
+ *
+ *    \param Handle    Handle of the queue that will receive the message.
+ *                    Message    Message to be sent.
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_send(tx_iwqueue_handle_t handle, u8 message)
+{
+	u8 *msg;
+
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_BAD_HANDLE);
+	RETIF(queue_table[handle].created != true, ERR_BAD_HANDLE);
+
+	msg = _alloc_box(queue_table[handle].mpool);
+	msg = (u8 *) message;
+
+	if(os_mbx_check(queue_table[handle].mbox) != 0) {
+		RETIF(os_mbx_send(queue_table[handle].mbox, msg, 0xffff) == OS_R_TMO, ERR_TIMEOUT);
+	} else {
+		return ERR_FULL;
+	}
+
+	return(0);
+}
+/*============================================================================*/
+
+/**
+ *    \brief This function reads a message from the specified message queue.
+ *
+ *    \param    Handle        Handle of the queue from which to read the message.
+ *            pMessage    Pointer to the message buffer.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_receive(tx_iwqueue_handle_t handle, u8 *p_message)
+{
+	u8 *msg;
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_BAD_HANDLE);
+	RETIF(queue_table[handle].created != true, ERR_BAD_HANDLE);
+
+	/* if we reach this point, this means that we got a message */
+	/* ask for exclusive access to this queue */
+	RETIF(os_mbx_wait(queue_table[handle].mbox , (void **) &msg, 0xffff) == OS_R_TMO, ERR_TIMEOUT);
+	*p_message = (uint) msg;
+	_free_box(queue_table[handle].mpool, msg);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a semaphore.
+ *
+ *    \param     pHandle    Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create(tx_iwsem_handle_t *p_handle)
+{
+	u8 i;
+
+	/* search for available queue slot */
+	for(i = 0; i < MAX_SEMA; i++) {
+		if(sem_table[i].created == false)
+			break;
+
+	}
+	if(i >= MAX_SEMA) return(ERR_NO_RESOURCES);
+
+	os_sem_init(sem_table[i].handle, 1);
+
+	*p_handle = (tx_iwsem_handle_t) i;
+
+	sem_table[i].created = true;
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0     If call is successful.
+ *            - ~0 If call failed.
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy(tx_iwsem_handle_t handle)
+{
+	/*TODO check if we can reuse */
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function acquires the specified semaphore.
+ *
+ *    \param Handle        Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p(tx_iwsem_handle_t handle)
+{
+	if(sem_table[handle].created == false) return ERR_BAD_HANDLE;
+
+	RETIF(os_sem_wait(sem_table[handle].handle, 0xffff) == OS_R_TMO, ERR_TIMEOUT);
+
+	return(0);
+}
+
+/*============================================================================*/
+
+/**
+ *    \brief This function releases the specified semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0    If call is successful.
+ *            - ~0    If call failed.
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v(tx_iwsem_handle_t handle)
+{
+	if(sem_table[handle].created == false) return ERR_BAD_HANDLE;
+
+	RETIF(os_sem_send(sem_table[handle].handle) == OS_R_NOK, ERR_BAD_HANDLE);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function disables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwdisable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+}
+
+/******************************************************************************
+ *    \brief  This function enables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwenable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+}
+
+#endif
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
new file mode 100755
index 0000000..27942c4
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_IW.h
@@ -0,0 +1,297 @@
+/**
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          dlHdmiCEC_IW.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date:  $
+ *
+ * \brief         devlib driver component API for the CEC messages
+ *
+ * \section refs  Reference Documents
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: dlHdmiCEC_IW.h $
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef DLHDMICEC_IW_H
+#define DLHDMICEC_IW_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#ifdef __LINUX_ARM_ARCH__
+#include <linux/kernel.h>
+#else
+#ifdef TMFL_OS_WINDOWS
+#define _WIN32_WINNT 0x0500
+#include "windows.h"
+#else
+#include "RTL.h"
+#endif
+#endif
+
+#include "tmNxTypes.h"
+#include "tmdlHdmiCEC_Types.h"
+
+/*============================================================================*/
+/*                       TYPE DEFINITIONS                                     */
+/*============================================================================*/
+typedef void (*tx_iwfunc_ptr_t)(void);
+typedef u8 tx_iwtask_handle_t;
+typedef u8 tx_iwqueue_handle_t;
+#ifdef TMFL_OS_WINDOWS
+typedef HANDLE tx_iwsem_handle_t;
+#else
+typedef u8 tx_iwsem_handle_t;
+#endif
+
+/**
+ * \brief Enum listing all available devices for enable/disable interrupts
+ * */
+typedef enum {
+	DL_HDMI_IW_RX_1,
+	DL_HDMI_IW_RX_2,
+	DL_HDMI_IW_TX_1,
+	DL_HDMI_IW_TX_2,
+	DL_HDMI_IW_CEC_1,
+	DL_HDMI_IW_CEC_2
+} dl_hdmi_iwdevice_interrupt_t;
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a task and allocates all the necessary
+ *           resources. Note that creating a task do not start it automatically,
+ *           an explicit call to IWTaskStart must be made.
+ *
+ *    \param pFunc      Pointer to the function that will be executed in the task context.
+ *    \param Priority   Priority of the task. The minimum priority is 0, the maximum is 255.
+ *    \param StackSize  Size of the stack to allocate for this task.
+ *    \param pHandle    Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMIRX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_create(tx_iwfunc_ptr_t p_func, u8 priority, u16 stack_size, tx_iwtask_handle_t *p_handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief    This function destroys an existing task and frees resources used by it.
+ *
+ *    \param Handle        Handle of the task to be destroyed, as returned by IWTaskCreate.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_destroy(tx_iwtask_handle_t handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function start an existing task.
+ *
+ *    \param Handle        Handle of the task to be started.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_ALREADY_STARTED: the function is already started
+ *            - ERR_DLHDMIRX_NOT_STARTED: the function is not started
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_start(tx_iwtask_handle_t handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function blocks the current task for the specified amount time. This is a passive wait.
+ *
+ *    \param Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait(u16 duration);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a message queue.
+ *
+ *    \param QueueSize    Maximum number of messages in the message queue.
+ *    \param pHandle        Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMIRX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_create(u8 queue_size, tx_iwqueue_handle_t *p_handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing message queue.
+ *
+ *    \param    Handle        Handle of the queue to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMIRX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_destroy(tx_iwqueue_handle_t handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function sends a message into the specified message queue.
+ *
+ *    \param Handle    Handle of the queue that will receive the message.
+ *    \param Message   Message to be sent.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMIRX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMIRX_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_send(tx_iwqueue_handle_t handle, u8 message);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function reads a message from the specified message queue.
+ *
+ *    \param    Handle        Handle of the queue from which to read the message.
+ *    \param    pMessage      Pointer to the message buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMIRX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMIRX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_receive(tx_iwqueue_handle_t handle, u8 *p_message);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function creates a semaphore.
+ *
+ *    \param     pHandle    Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMIRX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create(tx_iwsem_handle_t *p_handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function destroys an existing semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy(tx_iwsem_handle_t handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function acquires the specified semaphore.
+ *
+ *    \param Handle        Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p(tx_iwsem_handle_t handle);
+
+/*============================================================================*/
+
+/**
+ *    \brief This function releases the specified semaphore.
+ *
+ *    \param    Handle        Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMIRX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v(tx_iwsem_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function disables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwdisable_interrupts(dl_hdmi_iwdevice_interrupt_t device);
+
+/******************************************************************************
+ *    \brief  This function enables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwenable_interrupts(dl_hdmi_iwdevice_interrupt_t device);
+
+#endif /* DLHDMICEC_IW_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
new file mode 100755
index 0000000..4916379
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_Linux.c
@@ -0,0 +1,423 @@
+/*============================================================================*/
+/*                             INCLUDE FILES                                  */
+/*============================================================================*/
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+
+#include "tmdlHdmiCEC_IW.h"
+#include "tmNxTypes.h"
+#include "tmdlHdmiCEC.h"
+#include "tmdlHdmiCEC_cfg.h"
+
+struct i2c_client *get_this_i2c_client(void);
+unsigned char  my_i2c_data[255];
+
+/*============================================================================*/
+/*                          MACROS                                            */
+/*============================================================================*/
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+#define I2C_M_WR 0
+
+/*============================================================================*/
+/*                          FUNCTIONS DECLARATIONS                            */
+/*============================================================================*/
+
+error_code_t           i2c_read_function(dl_hdmi_cec_sys_args_t *p_sys_args);
+error_code_t           i2c_write_function(dl_hdmi_cec_sys_args_t *p_sys_args);
+
+/*============================================================================*/
+/*                       CONSTANTS DECLARATIONS                               */
+/*============================================================================*/
+
+#define COMMAND_TASK_PRIORITY_0  250
+#define COMMAND_TASK_STACKSIZE_0 128
+#define COMMAND_TASK_QUEUESIZE_0 8
+
+/* I2C adress of the unit */
+#ifdef TMFL_TDA9996
+#define UNIT_I2C_ADDRESS_0 0x60 /* I2C Address of TDA9950 */
+#else
+#define UNIT_I2C_ADDRESS_0 0x34 /* I2C Address of TDA9950 */
+#endif
+
+/*============================================================================*/
+/*                       VARIABLES DECLARATIONS                               */
+/*============================================================================*/
+
+dl_hdmi_cec_capabilities_t ceccapabilities_list = {DL_HDMICEC_DEVICE_UNKNOWN, cec_version_1_3a};
+
+dl_hdmi_cec_driver_config_table_t cecdriver_config_table[MAX_UNITS] = {
+	{
+		COMMAND_TASK_PRIORITY_0,
+		COMMAND_TASK_STACKSIZE_0,
+		COMMAND_TASK_QUEUESIZE_0,
+		UNIT_I2C_ADDRESS_0,
+		i2c_read_function,
+		i2c_write_function,
+		&ceccapabilities_list
+	}
+};
+
+int blockwrite_reg(struct i2c_client *client,
+                   u8 reg, u16 alength, u8 *val, u16 *out_len)
+{
+	int err = 0, i, initiator, receiver;
+	struct i2c_msg msg[1];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = alength + 1;
+	msg->buf = my_i2c_data;
+
+	msg->buf[0] = reg;
+	for(i = 0; i < alength; i++) {
+		msg->buf[i+1] = val[i];
+		/*       printk(KERN_INFO "buf[%d]=%d val[%d]=%d\n",i+1,msg->buf[i+1],i,val[i]); */
+	}
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	udelay(50);
+
+	if(reg == 7) {
+		/* CEC message */
+		extern char *cec_opcode(int op);
+		initiator = (msg->buf[3] >> 4) & 0x0f;
+		receiver = msg->buf[3] & 0x0f;
+		/*       printk(KERN_INFO "reg:%d alength:%d \n",reg, alength); */
+		if(alength == 3) {
+			printk(KERN_INFO "hdmicec:polling:[%x--->%x] \n", initiator, receiver);
+		} else {
+			printk(KERN_INFO "hdmicec:tx:[%x--->%x] %s %02x%02x%02x%02x\n", \
+			       initiator, receiver, cec_opcode(msg->buf[4]), msg->buf[4], msg->buf[5], msg->buf[6], msg->buf[7]);
+		}
+	}
+	/*    dev_dbg(&client->dev, "<%s> i2c Block write at 0x%x, " */
+	/*            "*val=%d flags=%d byte[%d] err=%d\n", */
+	/*            __func__, data[0], data[1], msg->flags, i, err); */
+	return (err < 0 ? err : 0);
+
+#if 0
+	int err = 0, i;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+
+	/* high byte goes out first */
+	data[0] = reg >> 8;
+
+	for(i = 0; i < alength - 1; i++) {
+		data[1] = val[i];
+		err = i2c_transfer(client->adapter, msg, 1);
+		udelay(50);
+		dev_dbg(&client->dev, "<%s> i2c block write at 0x%x, "
+		        "*val=%d flags=%d byte[%d] err=%d\n",
+		        __func__, data[0], data[1], msg->flags, i, err);
+		if(err < 0)
+			break;
+	}
+	/* set the number of bytes written*/
+	*out_len = i;
+
+	if(err < 0) {
+		dev_err(&client->dev, "<%s> ERROR:  i2c block write at 0x%x, "
+		        "*val=%d flags=%d bytes written=%d "
+		        "err=%d\n",
+		        __func__, data[0], data[1], msg->flags, i, err);
+		return err;
+	}
+	return 0;
+#endif
+}
+
+int blockread_reg(struct i2c_client *client, u16 data_length,
+                  u8 reg, u16 alength, u8 *val, u16 *out_len)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 1;
+	msg->buf = data;
+	data[0] = reg; /* High byte goes out first */
+	err = i2c_transfer(client->adapter, msg, 1);
+	if(err < 0) goto BLOCK_READ_OUPS;
+
+	msg->flags = I2C_M_RD;
+	msg->len = alength;
+	msg->buf = val;
+	err = i2c_transfer(client->adapter, msg, 1);
+	if(err < 0) goto BLOCK_READ_OUPS;
+
+	/*    printk(KERN_INFO "DBG blockread_reg addr:%x len:%d buf:%02x%02x%02x%02x\n",msg->addr,msg->len,\ */
+	/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3]); */
+
+	return 0;
+
+BLOCK_READ_OUPS:
+	/*    printk(KERN_INFO "DBG blockread_reg addr:%x len:%d ERROR\n",msg->addr,msg->len); */
+	dev_err(&client->dev, "<%s> ERROR:  i2c read at 0x%x, "
+	        "*val=%d flags=%d bytes err=%d\n",
+	        __func__, reg, *val, msg->flags, err);
+	return err;
+
+#if 0
+	int err = 0, i;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 1;
+	msg->buf = data;
+
+	/* High byte goes out first */
+	data[0] = reg;
+
+	for(i = 0; i < alength; i++) {
+		err = i2c_transfer(client->adapter, msg, 1);
+		dev_dbg(&client->dev, "<%s> i2c block read1 at 0x%x, "
+		        "*val=%d flags=%d err=%d\n",
+		        __func__, data[0], data[1], msg->flags, err);
+		if(err >= 0) {
+			mdelay(3);
+			msg->flags = I2C_M_RD;
+			msg->len = data_length;
+			err = i2c_transfer(client->adapter, msg, 1);
+		} else
+			break;
+		if(err >= 0) {
+			val[i] = 0;
+			/* High byte comes first */
+			if(data_length == 1)
+				val[i] = data[0];
+			else if(data_length == 2)
+				val[i] = data[1] + (data[0] << 8);
+			dev_dbg(&client->dev, "<%s> i2c block read2 at 0x%x, "
+			        "*val=%d flags=%d byte=%d "
+			        "err=%d\n",
+			        __func__, reg, val[i], msg->flags, i, err);
+		} else
+			break;
+	}
+	*out_len = i;
+	dev_info(&client->dev, "<%s> i2c block read at 0x%x, bytes read = %d\n",
+	         __func__, reg, *out_len);
+
+	if(err < 0) {
+		dev_err(&client->dev, "<%s> ERROR:  i2c read at 0x%x, "
+		        "*val=%d flags=%d bytes read=%d err=%d\n",
+		        __func__, reg, *val, msg->flags, i, err);
+		return err;
+	}
+	return 0;
+#endif
+}
+
+int write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+	int retries = 0;
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+retry:
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+
+	data[0] = reg;
+	data[1] = val;
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	dev_dbg(&client->dev, "<%s> i2c write at=%x "
+	        "val=%x flags=%d err=%d\n",
+	        __func__, data[0], data[1], msg->flags, err);
+	udelay(50);
+
+	/*    printk(KERN_INFO "DBG write_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
+	if(err >= 0)
+		return 0;
+
+	dev_err(&client->dev, "<%s> ERROR: i2c write at=%x "
+	        "val=%x flags=%d err=%d\n",
+	        __func__, data[0], data[1], msg->flags, err);
+	if(retries <= 5) {
+		dev_info(&client->dev, "retrying I2C... %d\n", retries);
+		retries++;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(20));
+		goto retry;
+	}
+
+	return err;
+}
+
+int read_reg(struct i2c_client *client, u16 data_length, u8 reg, u8 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 1;
+	msg->buf = data;
+
+	data[0] = reg;
+	err = i2c_transfer(client->adapter, msg, 1);
+	dev_dbg(&client->dev, "<%s> i2c read1 reg=%x val=%d "
+	        "flags=%d err=%d\n",
+	        __func__, reg, data[1], msg->flags, err);
+
+	if(err >= 0) {
+		mdelay(3);
+		msg->flags = I2C_M_RD;
+		msg->len = data_length;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	if(err >= 0) {
+		*val = 0;
+		if(data_length == 1)
+			*val = data[0];
+		else if(data_length == 2)
+			*val = data[1] + (data[0] << 8);
+		dev_dbg(&client->dev, "<%s> i2c read2 at 0x%x, *val=%d "
+		        "flags=%d err=%d\n",
+		        __func__, reg, *val, msg->flags, err);
+		return 0;
+	}
+
+	dev_err(&client->dev, "<%s> ERROR: i2c read at 0x%x, "
+	        "*val=%d flags=%d err=%d\n",
+	        __func__, reg, *val, msg->flags, err);
+	return err;
+}
+
+error_code_t i2c_read_function(dl_hdmi_cec_sys_args_t *p_sys_args)
+{
+	error_code_t err = 0;
+	u16 out_lenght = 0;
+	struct i2c_client *client = get_this_i2c_client();
+	u32 client_main_addr = client->addr;
+
+	/* DevLib needs address control, so let it be */
+	client->addr = p_sys_args->slave_addr;
+
+	if(p_sys_args->len_data == 1) {
+		/* single byte */
+		err = read_reg(get_this_i2c_client(), 1, p_sys_args->first_register, p_sys_args->p_data);
+	} else {
+		/* block */
+		err = blockread_reg(get_this_i2c_client(), 1, \
+		                    p_sys_args->first_register, \
+		                    p_sys_args->len_data, \
+		                    p_sys_args->p_data, &out_lenght);
+	}
+
+	/* restore default client address */
+	client->addr = client_main_addr;
+
+	return err;
+}
+
+error_code_t i2c_write_function(dl_hdmi_cec_sys_args_t *p_sys_args)
+{
+
+	error_code_t err = 0;
+	u16 out_lenght = 0;
+	struct i2c_client *client = get_this_i2c_client();
+	u32 client_main_addr = client->addr;
+
+	/* DevLib needs address control, so let it be */
+	client->addr = p_sys_args->slave_addr;
+
+	if(p_sys_args->len_data == 1) {
+		/* single byte */
+		err = write_reg(get_this_i2c_client(), p_sys_args->first_register, *p_sys_args->p_data);
+	} else {
+		/* block */
+		err = blockwrite_reg(get_this_i2c_client(),  \
+		                     p_sys_args->first_register, \
+		                     p_sys_args->len_data,       \
+		                     p_sys_args->p_data, &out_lenght);
+	}
+
+	/* restore default client address */
+	client->addr = client_main_addr;
+
+	return err;
+
+}
+
+error_code_t tx_iwwait
+(
+    u16 duration
+)
+{
+
+	mdelay((unsigned long)duration);
+
+	return(0);
+}
+
+error_code_t dl_hdmi_cec_cfg_get_config
+(
+    unit_select_t                 unit,
+    dl_hdmi_cec_driver_config_table_t *p_config
+)
+{
+	/* check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMICEC_BAD_UNIT_NUMBER)
+
+	/* check if pointer is NULL */
+	RETIF(p_config == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	*p_config = cecdriver_config_table[unit];
+
+	return(0);
+};
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.c b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.c
new file mode 100755
index 0000000..7aee692
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.c
@@ -0,0 +1,298 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          dlHdmiCEC_cfg.c
+ *
+ * \version       Revision: 1
+ *
+ * \date          Date:
+ *
+ * \brief         devlib driver component API for the CEC message
+ *
+ * \section refs  Reference Documents
+ *
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   History:       dlHdmiCEC_cfg.c
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                             INCLUDE FILES                                  */
+/*============================================================================*/
+#include "tmdlHdmiCEC_IW.h"
+#include "tmNxTypes.h"
+#include "tmdlHdmiCEC.h"
+#include "tmdlHdmiCEC_cfg.h"
+
+#ifdef   TMFL_OS_WINDOWS    /* OS Windows */
+#include "infra_i2c.h"
+#else                       /* OS ARM7 */
+#include "I2C.h"
+#include <LPC21xx.H>
+#endif                      /* endif TMFL_OS_WINDOWS */
+
+/******************************************************************************
+ ******************************************************************************
+ *                 THIS PART CAN BE MODIFIED BY CUSTOMER                      *
+ ******************************************************************************
+ *****************************************************************************/
+/*============================================================================*/
+/*                          INTERNAL PROTOTYPE                                */
+/*============================================================================*/
+
+#ifdef TMFL_OS_WINDOWS      /* OS Windows */
+error_code_t windows_i2c_read_function(bsl_sys_args_t *p_sys_args);
+error_code_t windows_i2c_write_function(bsl_sys_args_t *p_sys_args);
+#else                       /* OS ARM7 */
+error_code_t rtx_i2c_read_function(dl_hdmi_cec_sys_args_t *p_sys_args);
+error_code_t rtx_i2c_write_function(dl_hdmi_cec_sys_args_t *p_sys_args);
+#endif                      /* endif TMFL_OS_WINDOWS */
+
+/*============================================================================*/
+/*                                MACRO                                       */
+/*============================================================================*/
+
+/* macro for quick error handling */
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       CONSTANTS DECLARATIONS                               */
+/*============================================================================*/
+
+/* Configuration for unit 0 *************************** */
+#ifdef TMFL_OS_WINDOWS         /* OS Windows */
+#define COMMAND_TASK_PRIORITY_0  THREAD_PRIORITY_HIGHEST
+#else                          /* OS ARM7 */
+#define COMMAND_TASK_PRIORITY_0  250
+#endif                        /* endif TMFL_OS_WINDOWS */
+/* stack size of the command tasks */
+#define COMMAND_TASK_STACKSIZE_0 128
+/* size of the message queues for command tasks */
+#define COMMAND_TASK_QUEUESIZE_0 8
+/* I2C adress of the unit */
+#ifdef TMFL_TDA9996
+#define UNIT_I2C_ADDRESS_0 0x60 /* I2C Address of TDA9950 */
+#else
+#define UNIT_I2C_ADDRESS_0 0x34 /* I2C Address of TDA9950 */
+#endif
+
+/* Configuration for unit 1 *************************** */
+/* priority of the command tasks */
+#ifdef TMFL_OS_WINDOWS         /* OS Windows */
+#define COMMAND_TASK_PRIORITY_1  THREAD_PRIORITY_HIGHEST
+#else                          /* OS ARM7 */
+#define COMMAND_TASK_PRIORITY_1  250
+#endif                        /* endif TMFL_OS_WINDOWS */
+/* stack size of the command tasks */
+#define COMMAND_TASK_STACKSIZE_1 128
+/* size of the message queues for command tasks */
+#define COMMAND_TASK_QUEUESIZE_1 8
+/* I2C adress of the unit */
+#ifdef TMFL_TDA9996
+#define UNIT_I2C_ADDRESS_1 0x60 /* I2C Address of TDA9950 */
+#else
+#define UNIT_I2C_ADDRESS_1 0x34 /* I2C Address of TDA9950 */
+#endif
+
+/*============================================================================*/
+/*                        DEFINES DECLARATIONS                                */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       VARIABLES DECLARATIONS                               */
+/*============================================================================*/
+
+/**
+ * \brief List of the capabilities to be enabled by the device library
+ * */
+dl_hdmi_cec_capabilities_t ceccapabilities_list = {DL_HDMICEC_DEVICE_UNKNOWN, cec_version_1_3a};
+
+/**
+ * \brief Configuration Tables. This table can be modified by the customer
+ *            to choose its prefered configuration
+ * */
+
+#ifdef TMFL_OS_WINDOWS
+dl_hdmi_cec_driver_config_table_t cecdriver_config_table[MAX_UNITS] = {
+	{
+		COMMAND_TASK_PRIORITY_0,
+		COMMAND_TASK_STACKSIZE_0,
+		COMMAND_TASK_QUEUESIZE_0,
+		UNIT_I2C_ADDRESS_0,
+		windows_i2c_read_function,
+		windows_i2c_write_function,
+		&ceccapabilities_list
+	}
+};
+#else
+dl_hdmi_cec_driver_config_table_t cecdriver_config_table[MAX_UNITS] = {
+	{
+		COMMAND_TASK_PRIORITY_0,
+		COMMAND_TASK_STACKSIZE_0,
+		COMMAND_TASK_QUEUESIZE_0,
+		UNIT_I2C_ADDRESS_0,
+		rtx_i2c_read_function,
+		rtx_i2c_write_function,
+		&ceccapabilities_list
+	}
+};
+#endif
+
+#ifdef TMFL_OS_WINDOWS
+/*============================================================================*/
+/*                              FUNCTIONS                                     */
+/*============================================================================*/
+
+/**
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C read structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+windows_i2c_read_function
+(
+    dl_hdmi_cec_sys_args_t        *p_sys_args
+)
+{
+	error_code_t  err;
+
+#ifdef TMFL_TDA9996
+	err = i2c_read(reg_tda_9996, (bsl_hdmi_sys_args_t *) p_sys_args);
+#else
+	err = i2c_read(reg_tda_9950, (bsl_hdmi_sys_args_t *) p_sys_args);
+#endif
+
+	return err;
+}
+/**
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C write structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+windows_i2c_write_function
+(
+    dl_hdmi_cec_sys_args_t *p_sys_args
+)
+{
+	error_code_t   err;
+
+#ifdef TMFL_TDA9996
+	err = i2c_write(reg_tda_9996, (bsl_hdmi_sys_args_t *) p_sys_args);
+#else
+	err = i2c_write(reg_tda_9950, (bsl_hdmi_sys_args_t *) p_sys_args);
+#endif
+
+	return err;
+}
+#else
+
+/*============================================================================*/
+
+/**
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C read structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+rtx_i2c_read_function
+(
+    dl_hdmi_cec_sys_args_t        *p_sys_args
+)
+{
+	error_code_t               err;
+
+	err = i2c_read(reg_tda_9950, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+/**
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C write structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+rtx_i2c_write_function
+(
+    dl_hdmi_cec_sys_args_t *p_sys_args
+)
+{
+	error_code_t               err;
+
+	err = i2c_write(reg_tda_9950, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+
+#endif
+
+/******************************************************************************
+ ******************************************************************************
+ *                THIS PART MUST NOT BE MODIFIED BY CUSTOMER                  *
+ ******************************************************************************
+ *****************************************************************************/
+
+/**
+ *    \brief This function allows to the main driver to retrieve its
+ *           configuration parameters.
+ *
+ *    \param pConfig Pointer to the config structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t dl_hdmi_cec_cfg_get_config
+(
+    unit_select_t                 unit,
+    dl_hdmi_cec_driver_config_table_t *p_config
+)
+{
+	/* check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMICEC_BAD_UNIT_NUMBER)
+
+	/* check if pointer is NULL */
+	RETIF(p_config == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	*p_config = cecdriver_config_table[unit];
+
+	return(0);
+};
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.h
new file mode 100755
index 0000000..56cdbb6
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCEC_cfg.h
@@ -0,0 +1,94 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          dlHdmiCEC_cfg.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date:  $
+ *
+ * \brief         devlib driver component API for the CEC messages
+ *
+ * \section refs  Reference Documents
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History:  dlHdmiCEC_cfg.h
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+/******************************************************************************
+ ******************************************************************************
+ *                THIS FILE MUST NOT BE MODIFIED BY CUSTOMER                  *
+ ******************************************************************************
+ *****************************************************************************/
+
+#ifndef DLHDMICEC_CFG_H
+#define DLHDMICEC_CFG_H
+
+#include "tmNxTypes.h"
+#include "tmdlHdmiCEC_Types.h"
+#include "tmdlHdmiCEC_Functions.h"
+
+/* Number of HW units supported by SW driver */
+#define MAX_UNITS 1
+
+#ifndef TMFL_CEC_AVAILABLE
+typedef struct _bsl_sys_args_t {
+	u8 slave_addr;
+	u8 first_register;
+	u8 len_data;
+	u8 *p_data;
+} bsl_sys_args_t;
+#endif
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+typedef struct {
+	u8                         command_task_priority;
+	u8                         command_task_stack_size;
+	u8                         command_task_queue_size;
+	u8                         i2c_address;
+	ptmdl_hdmi_cec_sys_func_t         i2c_read_function;
+	ptmdl_hdmi_cec_sys_func_t         i2c_write_function;
+	dl_hdmi_cec_capabilities_t     *p_capabilities_list;
+} dl_hdmi_cec_driver_config_table_t;
+
+/*============================================================================*/
+/*                       FUNCTIONS DECLARATIONS                               */
+/*============================================================================*/
+
+/**
+ *    \brief This function allows to the main driver to retrieve its
+ *           configuration parameters.
+ *
+ *    \param pConfig Pointer to the config structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t dl_hdmi_cec_cfg_get_config
+(
+    unit_select_t                 unit,
+    dl_hdmi_cec_driver_config_table_t *p_config
+);
+
+#endif /* DLHDMICEC_CFG_H */
+
+/*============================================================================*/
+/*                               END OF FILE                                  */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCecCfg.def b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCecCfg.def
new file mode 100755
index 0000000..2c0cd60
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/cfg/tmdlHdmiCecCfg.def
@@ -0,0 +1,16 @@
+LIBRARY tmdlHdmiCecCfg
+EXPORTS tmdlHdmiCecCfgGetConfig @1
+tmdlHdmiTxIWTaskCreate
+tmdlHdmiTxIWTaskDestroy
+tmdlHdmiTxIWTaskStart
+tmdlHdmiTxIWWait
+tmdlHdmiTxIWQueueCreate
+tmdlHdmiTxIWQueueDestroy
+tmdlHdmiTxIWQueueSend
+tmdlHdmiTxIWQueueReceive
+tmdlHdmiTxIWSemaphoreCreate
+tmdlHdmiTxIWSemaphoreDestroy
+tmdlHdmiTxIWSemaphoreP
+tmdlHdmiTxIWSemaphoreV
+tmdlHdmiTxIWDisableInterrupts
+tmdlHdmiTxIWEnableInterrupts
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC.h
new file mode 100755
index 0000000..0a54a48
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC.h
@@ -0,0 +1,46 @@
+/*============================================================================= */
+/* Copyright (C) 2007 NXP N.V., All Rights Reserved. */
+/* This source code and any compilation or derivative thereof is the proprietary */
+/* information of NXP N.V. and is confidential in nature. Under no circumstances */
+/* is this software to be  exposed to or placed under an Open Source License of */
+/* any type without the expressed written permission of NXP N.V. */
+/*============================================================================= */
+/*!
+ *    \file    dlHdmiCEC.h
+ *
+ *	\version 1.0
+ *
+ *	\date    04/07/2007
+ *
+ * 	\brief   This provides interfaces description of CEC messages.
+ *
+ *    \section refs  Reference Documents
+ *             TDA998X Driver - tx - SCS.doc
+ *    \note    None.
+ *
+ *    HISTORY :
+ *    \verbatim
+ *     Date          Modified by CRPRNr  TASKNr  Maintenance description
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *     04/07/2007   |  F.G      |       |       | Creation.
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *    \endverbatim
+ * */
+/*========================================================================== */
+
+#ifndef DLHDMICEC_H
+#define DLHDMICEC_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+#include "tmNxCompId.h"
+#include "tmdlHdmiCEC_Types.h"
+#include "tmdlHdmiCEC_Functions.h"
+
+#endif /* DLHDMICEC_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Functions.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Functions.h
new file mode 100755
index 0000000..7e9ecb9
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Functions.h
@@ -0,0 +1,3147 @@
+/*============================================================================= */
+/* Copyright (C) 2007 NXP N.V., All Rights Reserved. */
+/* This source code and any compilation or derivative thereof is the proprietary */
+/* information of NXP N.V. and is confidential in nature. Under no circumstances */
+/* is this software to be  exposed to or placed under an Open Source License of */
+/* any type without the expressed written permission of NXP N.V. */
+/*============================================================================= */
+/*!
+ *    \file    dlHdmiCEC_Functions.h
+ *
+ *	\version 1.0
+ *
+ *	\date    04/07/2007
+ *
+ * 	\brief   This provides interfaces description of CEC messages.
+ *
+ *    \section refs  Reference Documents
+ *             TDA998X Driver - dlHdmiCec - SCS.doc
+ *    \note    None.
+ *
+ *    HISTORY :
+ *    \verbatim
+ *     Date          Modified by CRPRNr  TASKNr  Maintenance description
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *     04/07/2007   |  F.G      |       |       | Creation.
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *    \endverbatim
+ * */
+/*========================================================================== */
+
+#ifndef DLHDMICEC_FUNCTIONS_H
+#define DLHDMICEC_FUNCTIONS_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#include "tmNxTypes.h"
+
+/*============================================================================*/
+/*                       PUBLIC FUNCTION DECLARATION                          */
+/*============================================================================*/
+
+/*========================================================================== */
+/*!
+ *    \brief This message is reserved for testing purposes
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *	\param u8 ReceiverLogicalAddress\n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_abort_message
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a new source to indicate that it has started
+ *           to transmit a stream OR used in reponse to a <Request Active Source>
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_active_source
+(
+    instance_t   instance,
+    u16         physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate the supported CEC version in response
+ *           to a <Get CEC Version>
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *	\param u8 ReceiverLogicalAddress\n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECVersion_t CECVersion \n
+ *           Supported CEC Version.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_version
+(
+    instance_t         instance,
+    u8                receiver_logical_address,
+    dl_hdmi_cecversion_t cecversion
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to clear an Analogue timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_analogue_timer
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    u8                               day_of_month,
+    u8                               month_of_year,
+    u16                              start_time,
+    dl_hdmi_cecduration_t              *p_duration,
+    u8                               recording_sequence,
+    dl_hdmi_cecanalogue_broadcast_type_t  analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t        broadcast_system
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_digital_timer
+(
+    instance_t                               instance,
+    u8                                      receiver_logical_address,
+    u8                                      day_of_month,
+    u8                                      month_of_year,
+    u16                                     start_time,
+    dl_hdmi_cecduration_t                     *p_duration,
+    u8                                      recording_sequence,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_external_timer_with_external_plug
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    u8                       day_of_month,
+    u8                       month_of_year,
+    u16                      start_time,
+    dl_hdmi_cecduration_t      *p_duration,
+    u8                       recording_sequence,
+    dl_hdmi_cecexternal_plug_t  external_plug
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_external_timer_with_physical_address
+(
+    instance_t                           instance,
+    u8                                  receiver_logical_address,
+    u8                                  day_of_month,
+    u8                                  month_of_year,
+    u16                                 start_time,
+    dl_hdmi_cecduration_t                 *p_duration,
+    u8                                  recording_sequence,
+    dl_hdmi_cecexternal_physical_address_t  external_physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to conrol a device's media functions
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDecControlMode_t DeckControlMode \n
+ *           Used in message <Deck Control>\n
+ *
+ *    \note  The "Skip Forward / Wind" and "Skip Reverse / Rewind" values are
+ *           used for example in a DVD as next xhapter and previous chapter and
+ *           in a VCR as wind and rewind. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_deck_control
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    dl_hdmi_cecdec_control_mode_t deck_control_mode
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to provide a deck's status to the initiator
+ *           of the <Give Deck Status> message
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDecInfo_t DeckInfo \n
+ *           Information on the device's current status \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_deck_status
+(
+    instance_t         instance,
+    u8                receiver_logical_address,
+    dl_hdmi_cecdec_info_t deck_info
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message report the vendor ID of this device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u32 VendorID \n
+ *           Indentifier for a specific Vendor \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_device_vendor_id
+(
+    instance_t instance,
+    u32       vendor_id
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used as a reponse to indicate that the device does
+ *           not support the requested message type, or that it cannot execute it
+ *           at the present time.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECFeatureOpcode_t FeatureOpcode \n
+ *           Opcode of the aborted message. \n
+ *
+ *    \param dlHdmiCECAbortReason_t   AbortReason \n
+ *           The reason why message cannot respond. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_feature_abort
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecfeature_opcode_t feature_opcode,
+    dl_hdmi_cecabort_reason_t   abort_reason
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a device to enquire which version of CEC
+ *           the target supports
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_cec_version
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is sent by a device capable of character generation
+ *           (for OSD and Menus) to a TV in order to discover the currently selected
+ *           Menu Language. Also used by a TV during installation to dicover the
+ *           currently set menu language of other devices.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_menu_language
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is requests an amplifier to send its volume and mute status
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_audio_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to request the status of a device regardless
+ *           of whether or not it is the current active source.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECStatusRequest_t StatusRequest \n
+ *           Allows the initiator to request the status once or on all future state
+ *           change. Or to cancel a previous <Give Deck Status > ["On"] request. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_deck_status
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecstatus_request_t status_request
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to determine the current power status of a
+ *           target device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_device_power_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is request the vendor ID from a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_device_vendor_id
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to request preferred OSD name of a device
+ *           for use in menus associated with that device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_osd_name
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is a request to a device to return its physical Address
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_physical_address
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message request the status of the system audio mode
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_system_audio_mode_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to request the status of a tuner device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECStatusRequest_t StatusRequest \n
+ *           Allows the initiator to request the status once or on all future state
+ *           change. Or to cancel a previous <Give Tuner Device Status > ["On"] request. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_tuner_device_status
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecstatus_request_t status_request
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message sent by a source device to the TV whenever it enters
+ *           the active state
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receivers. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_image_view_on
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by the currently active source to inform the
+ *           TV that it has no video to be presented to the user, or is going
+ *           into standby as the result of a lcoal user command on the device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress, \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Physical Address of the device. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_inactive_source
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecexternal_physical_address_t  physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message request from the TV for a device to show/remove a
+ *           menu or to query if a device is currently showing a menu
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECMenuRequestType_t  MenuRequestType \n
+ *           Indicates if the menu request is to activate or deactivate the
+ *           devices menu or simply query the devices menu status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_menu_request
+(
+    instance_t                  instance,
+    u8                         receiver_logical_address,
+    dl_hdmi_cecmenu_request_type_t  menu_request_type
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate to the TV that the device is
+ *           showing/has removed a menu and requets the remote control keys to
+ *           be passed though
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECMenuState_t  MenuState \n
+ *           Indicates if the device is in the 'Device Menu Active' state or
+ *           'Device Menu Inactive' state. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_menu_status
+(
+    instance_t            instance,
+    u8                   receiver_logical_address,
+    dl_hdmi_cecmenu_state_t  menu_state
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to control the playback behaviour of a source
+ *           device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPlayMode_t  PlayMode \n
+ *           In which mode to play media. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_play
+(
+    instance_t           instance,
+    u8                  receiver_logical_address,
+    dl_hdmi_cecplay_mode_t  play_mode
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by any device for device discovery - similar to
+ *           ping in other protocols
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_polling_message
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message request a device to stop a recording
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_off
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message attempt to record analogue source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_analogue_service
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    dl_hdmi_cecanalogue_broadcast_type_t  analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t        broadcast_system
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message attempt to record digital source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_digital_service
+(
+    instance_t                              instance,
+    u8                                     receiver_logical_address,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message attempt to record an external physical address source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_external_physical_address
+(
+    instance_t                         instance,
+    u8                                receiver_logical_address,
+    dl_hdmi_cecexternal_physical_address_t external_physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message attempt to record an external plug source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_external_plug
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecexternal_plug_t      external_plug
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message attempt to record an external plug source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_own_source
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a recording device to inform the initiator
+ *           of the message <Record On> about its status.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECRecordStatusInfo_t  RecordStatusInfo \n
+ *           The recording status of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_status
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecrecord_status_info_t  record_status_info
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message request by the recording device to record the presently
+ *           displayed source.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_tv_screen
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message report an amplifier's volume and mute.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECAudioStatus_t AudioStatus \n
+ *           Volume and mute status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_audio_status
+(
+    instance_t              instance,
+    u8                     receiver_logical_address,
+    ptmdl_hdmi_cecaudio_status_t p_audio_status
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportShortAudioDescriptor( )
+ *    \brief This message Report Audio Capability.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u32 ShortAudioDecriptor \n
+ *           Audio Descriptor. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_short_audio_descriptor
+(
+    instance_t   instance,
+    u8          receiver_logical_address,
+    u32         short_audio_decriptor
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestShortAudioDescriptor( )
+ *    \brief This message Request Audio Capability.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8 AudioFormatID \n
+ *
+ *    \param u8 AudioFormatCode \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_short_audio_descriptor
+(
+    instance_t   instance,
+    u8          receiver_logical_address,
+    u8          audio_format_id,
+    u8          audio_format_code
+
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecIniateARC( )
+ *    \brief This message Used by an ARC RX device to activate the
+ *           ARC functionality in an ARC TX device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_iniate_arc
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportArcInitiated( )
+ *    \brief This message Used by an ARC TX device to indicate that
+ *           its ARC functionality has been activated
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_arc_initiated
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportArcTerminated( )
+ *    \brief This message Used by an ARC TX device to indicate that its ARC functionality
+ *           has been deactivated.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_arc_terminated
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestArcInitiation( )
+ *    \brief This message Used by an ARC TX device to request an ARC RX device to
+ *           activate the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_arc_initiation
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestArcTerminiation( )
+ *    \brief Used by an ARC TX device to request an ARC RX device to deactivate
+ *           the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_arc_terminiation
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTerminateARC( )
+ *    \brief Used by an ARC TX device to request an ARC RX device to deactivate
+ *           the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_terminate_arc
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to inform all other devices of the mapping
+ *           between physical and logical address of the initiator.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Device physical address within the cluster. \n
+ *
+ *    \param dlHdmiCECDeviceType_t DeviceType \n
+ *           Type of the device (TV, Playback, tuner,...). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_physical_address
+(
+    instance_t             instance,
+    u16                   physical_address,
+    dl_hdmi_cecdevice_type_t  device_type
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to inform a requesting device of the current
+ *           power status.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPowerStatus_t PowerStatus \n
+ *           Current power status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_power_status
+(
+    instance_t             instance,
+    u8                    receiver_logical_address,
+    dl_hdmi_cecpower_status_t power_status
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a new device to discover the status of
+ *           the system.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_active_source
+(
+    instance_t  instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is sent by a CEC switch when it is manually switched to
+ *           inform all other devices on the network that the active route below
+ *           the switch has changed.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 OriginalAddress \n
+ *           Previous address that the switch was switched to. \n
+ *
+ *    \param u16 NewAddress \n
+ *           The new address it has been moved to. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_routing_change
+(
+    instance_t  instance,
+    u16        original_address,
+    u16        new_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is sent by a CEC switch to indicate the active route
+ *           below the switch.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           The current active route to the sink in the CEC switch. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_routing_information
+(
+    instance_t  instance,
+    u16        physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message select directly an analogue TV Service.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_select_analogue_service
+(
+    instance_t                       instance,
+    u8                              receiver_logical_address,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                             analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message select directly a digital TV, Radio or Data Broadcast
+ *           Service.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_select_digital_service
+(
+    instance_t                                instance,
+    u8                                       receiver_logical_address,
+    ptmdl_hdmi_cecdigital_service_identification_t  p_service_identification
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set asingle timer block on an analogue
+ *           recording device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_analogue_timer
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    u8                               day_of_month,
+    u8                               month_of_year,
+    u16                              start_time,
+    dl_hdmi_cecduration_t              *p_duration,
+    u8                               recording_sequence,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to control audio rate from Source device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECAudioRate_t AudioRate \n
+ *           The audio rate requested. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_audio_rate
+(
+    instance_t           instance,
+    u8                  receiver_logical_address,
+    dl_hdmi_cecaudio_rate_t audio_rate
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set a digital timer block on a digital
+ *           recording device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_digital_timer
+(
+    instance_t                               instance,
+    u8                                     receiver_logical_address,
+    u8                                      day_of_month,
+    u8                                      month_of_year,
+    u16                                     start_time,
+    dl_hdmi_cecduration_t                     *p_duration,
+    u8                                      recording_sequence,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set a single timer block to record from an
+ *           external device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_external_timer_with_external_plug
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    u8                       day_of_month,
+    u8                       month_of_year,
+    u16                      start_time,
+    dl_hdmi_cecduration_t      *p_duration,
+    u8                       recording_sequence,
+    dl_hdmi_cecexternal_plug_t  external_plug
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set a single timer block to record from an
+ *           external device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_external_timer_with_physical_address
+(
+    instance_t                           instance,
+    u8                                  receiver_logical_address,
+    u8                                  day_of_month,
+    u8                                  month_of_year,
+    u16                                 start_time,
+    dl_hdmi_cecduration_t                 *p_duration,
+    u8                                  recording_sequence,
+    dl_hdmi_cecexternal_physical_address_t  external_physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a TV or another device to indicate the menu
+ *           Language.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param const char *pLanguage \n
+ *           Pointer on the user's menu language choice. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_menu_language
+(
+    instance_t instance,
+    const char   *p_language
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set the preferred OSD name of a device
+ *           for use in manus associated with that device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param const char *pOsdName \n
+ *           Pointer on the preferred name of the device. \n
+ *
+ *    \param u8    OsdNameLength \n
+ *           Length of Osd Name String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_osd_name
+(
+    instance_t instance,
+    u8        receiver_logical_address,
+    const char   *p_osd_name,
+    u8        osd_name_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to send a test message to output on a TV.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDisplayControl_t DisplayControl \n
+ *           Display timing. \n
+ *
+ *    \param const char *pOsdString \n
+ *           Pointer on the Text to display. \n
+ *
+ *    \param u8    OsdStringLength \n
+ *           Length of Osd String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_osd_string
+(
+    instance_t                 instance,
+    u8                        receiver_logical_address,
+    dl_hdmi_cecdisplay_control_t  display_control,
+    const char                   *p_osd_string,
+    u8                        osd_string_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a TV to request a streaming path from
+ *           the specified physical address.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_stream_path
+(
+    instance_t  instance,
+    u16        physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message turn the system audio Mode ON or OFF.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECSystemAudioStatus_t SystemAudioStatus \n
+ *           Specifies if the system audio mode is ON or OFF.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_system_audio_mode
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecsystem_audio_status_t system_audio_status
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to set the name of a program associated
+ *           with a timer block.Sent directly after sending a
+ *           <Set analogue Timer> or <Set Digital Timer> message. The name
+ *           is then associated with that timer block.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param const char *pProgramTitleString \n
+ *           Pointer on the program title. \n
+ *
+ *    \param u8    ProgramTitleLength \n
+ *           Length of Program Title String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_timer_program_title
+(
+    instance_t instance,
+    u8        receiver_logical_address,
+    const char   *p_program_title_string,
+    u8        program_title_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message switches one or all devices into standby mode.Can be
+ *           be used as a broadcast message o be addressed to a specific device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_standby
+(
+    instance_t instance,
+    u8        receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief A device implementing System Audio Control and which has volume
+ *           control RC button(eg TV or STB) request to use System Audio Mode
+ *           to the amplifier.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_system_audio_mode_request
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u16        physical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Reports the current status of the System Audio Mode.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECSystemAudioStatus_t SystemAudioStatus \n
+ *           Current system audio mode.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_system_audio_mode_status
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecsystem_audio_status_t system_audio_status
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message as <Image View On>, but should also remove any text,
+ *           menus and PIP windows from the TV's display
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_text_view_on
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to give the status of a <Cleared Analogue Timer>,
+ *           <Clear Digital Timer> or <Clear External Timer> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECTimerClearedStatusData_t TimerClearedStatusData \n
+ *           Indicates if the timer was cleared successfully. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_timer_cleared_status
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    dl_hdmi_cectimer_cleared_status_data_t timer_cleared_status_data
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to send timer status to the initiator of a
+ *           <Set Timer> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECTimerStatusData_t *pTimerStatusData \n
+ *           Pointer on the Timer status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_timer_status
+(
+    instance_t                 instance,
+    u8                        receiver_logical_address,
+    dl_hdmi_cectimer_status_data_t *p_timer_status_data
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a tuner device to provide its status to the
+ *           initiator of the <Give Tuner Device Status> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECRecordingFlag_t RecordingFlag \n
+ *           Indicates if the tuner is being used as a source of a recording. \n
+ *
+ *    \param dlHdmiCECTunerDisplayInfo_t TunerDisplayInfo \n
+ *           Indicates if the the device is currently deplaying its tuner or not. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_device_status_analogue
+(
+    instance_t                       instance,
+    u8                              receiver_logical_address,
+    dl_hdmi_cecrecording_flag_t         recording_flag,
+    dl_hdmi_cectuner_display_info_t      tuner_display_info,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                             analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used by a tuner device to provide its status to the
+ *           initiator of the <Give Tuner Device Status> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECRecordingFlag_t RecordingFlag \n
+ *           Indicates if the tuner is being used as a source of a recording. \n
+ *
+ *    \param dlHdmiCECTunerDisplayInfo_t TunerDisplayInfo \n
+ *           Indicates if the the device is currently deplaying its tuner or not. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_device_status_digital
+(
+    instance_t                               instance,
+    u8                                      receiver_logical_address,
+    dl_hdmi_cecrecording_flag_t                 recording_flag,
+    dl_hdmi_cectuner_display_info_t              tuner_display_info,
+    ptmdl_hdmi_cecdigital_service_identification_t p_service_identification
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to tune to next lowest service in a tuner's
+ *           service list.Can be used for PIP.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_step_decrement
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to tune to next highest service in a tuner's
+ *           service list.Can be used for PIP.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_step_increment
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECUserRemoteControlCommand_t UICommand \n
+ *           Relevant UI command issued by user. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecuser_remote_control_command_t uicommand
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPlayMode_t PlayMode \n
+ *           In which mode to play media. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_play
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecplay_mode_t                 play_mode
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectAudioInput \n
+ *           Number of the Audio Input (Audio input number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_audio_input
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_audio_input
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectAVInput \n
+ *           Number of the A/V Input (A/V input number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_avinput
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_avinput
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectMedia \n
+ *           Number of Media (Media number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_media
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_media
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECChannelIdentifier_t  *pChannelIdentifier \n
+ *           Pointer to the structure of Major and Minor Channel number
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_tune
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecchannel_identifier_t        *p_channel_identifier
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is used to indicate that the user released a remote button
+ *           The last one indicated by the <User Control Pressed> Message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_released
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is allows vendor specific commands to be sent between
+ *           two devices.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  *pVendorSpecificData \n
+ *           Pointer to the Vendor Specific datas
+ *
+ *    \param u8    VendorSpecificDataLength \n
+ *           Length of VendorSpecificData. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_command
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u8         *p_vendor_specific_data,
+    u8         vendor_specific_data_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message is allows vendor specific commands to be sent between
+ *           two devices or broadcast.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u32 VendorID \n
+ *           Indentifier for a specific Vendor \n
+ *
+ *    \param u8  *pVendorSpecificData \n
+ *           Pointer to the Vendor Specific datas
+ *
+ *    \param u8    VendorSpecificDataLength \n
+ *           Length of VendorSpecificData. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_command_with_id
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u32        vendor_id,
+    u8         *p_vendor_specific_data,
+    u8         vendor_specific_data_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message indicates that a remote control button has been depressed.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  *pVendorSpecificRcCode \n
+ *           Pointer to the Vendor Specific remote control code.
+ *           its recommended t keep this to a minimum size.
+ *           The maximum length shall not exceed 14 data blocks to avoid saturating bus
+ *
+ *    \param u8    VendorSpecificRcCodeLength \n
+ *           Length of VendorSpecificRcCode. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_remote_button_down
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u8         *p_vendor_specific_rc_code,
+    u8         vendor_specific_rc_code_length
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This message indicates that a remote control button (the last button
+ *           pressed indicated by the <Vendor remote button down > message) has
+ *           been released.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_remote_button_up
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get the software version of the driver.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param pSWVersion Pointer to the version structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_swversion
+(
+    swversion_t  *p_swversion
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get the number of available CEC devices in the system.
+ *           A unit directly represents a physical device.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param pUnitCount Pointer to the number of available units.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_number_of_units
+(
+    u32  *p_unit_count
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get the capabilities of unit 0. Capabilities are stored into a
+ *           dedicated structure.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_capabilities
+(
+    dl_hdmi_cec_capabilities_t *p_capabilities
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get the capabilities of a specific unit. Capabilities are stored
+ *           into a dedicated structure
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param unit          Unit to be probed.
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_capabilities_m
+(
+    unit_select_t            unit,
+    dl_hdmi_cec_capabilities_t *p_capabilities
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Open unit 0 of CEC driver and provides the instance number to
+ *           the caller. Note that one unit of CEC represents one physical
+ *           CEC device and that only one instance per unit can be opened.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param pInstance Pointer to the variable that will receive the instance
+ *                     identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMICEC_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_open
+(
+    instance_t   *p_instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Open a specific unit of CEC driver and provides the instance
+ *           number to the caller. Note that one unit of CEC represents one
+ *           physical CEC device and that only one instance per unit can be
+ *           opened.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param pInstance Pointer to the structure that will receive the instance
+ *                     identifier.
+ *    \param unit      Unit number to be opened.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMICEC_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_open_m
+(
+    instance_t   *p_instance,
+    unit_select_t  unit
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Close an instance of CEC driver.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_close
+(
+    instance_t   instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Set the power state of an instance of the CEC device. ON
+ *           state corresponds to a fully supplied, up and running device. Other
+ *           modes correspond to the powerdown state of the device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param powerState Power state to set.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_power_state
+(
+    instance_t   instance,
+    power_state_t power_state
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get the power state of an instance of the CEC device. ON
+ *           state corresponds to a fully supplied, up and running device. Other
+ *           modes correspond to the powerdown state of the device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance    Instance identifier.
+ *    \param pPowerState Pointer to the power state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_power_state
+(
+    instance_t    instance,
+    power_state_t *p_power_state
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Set the configuration of instance attributes. This function is
+ *           required by DVP architecture rules but actually does nothing in this
+ *           driver
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance    Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_instance_config
+(
+    instance_t    instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration like Logical Address or device
+ *           state.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_instance_setup
+(
+    instance_t                instance,
+    ptmdl_hdmi_cec_instance_setup_t p_setup_info
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Get instance setup parameters.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure that will receive setup
+ *                      parameters
+ *                      This function is synchronous.
+ *                      This function is not ISR friendly.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_instance_setup
+(
+    instance_t                instance,
+    ptmdl_hdmi_cec_instance_setup_t p_setup_info
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Make device library handle an incoming interrupt. This function is
+ *           used by application to tell the device library that the hardware
+ *           sent an interrupt. It can also be used to poll the interrupt status
+ *           of the device if the interrupt line is not physically connected to
+ *           the CPU.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_FULL: the queue is full
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_handle_interrupt
+(
+    instance_t    instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief Register event callbacks. Only one callback is registered through
+ *           this API. This callback will received the type of event that
+ *           occured throug a dedicated parameter and will be called as many
+ *           times as there is pending events.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pCallback  Pointer to the callback function that will handle events
+ *                      from the devlib.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_INVALID_STATE: the state is invalid for
+ *              the function
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_register_callbacks
+(
+    instance_t                instance,
+    ptmdl_hdmi_cec_callback_func_t  pk_callback
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetLogicalAddress( )
+ *    \brief Set Device Logical Address
+ *
+ *    \param instance Instance identifier.
+ *    \param LogicalAddress Logical Address value.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_logical_address
+(
+    instance_t   instance,
+    dl_hdmi_ceclogical_address_t   logical_address
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetRetry( )
+ *    \brief Change the number of retransmission
+ *
+ *    \param instance Instance identifier.
+ *    \param NbRetry Number of retry.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_retry
+(
+    instance_t   instance,
+    u8   nb_retry
+);
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t getCecLastMessage( )
+ *    \brief Return the Addresses and the Opcode of the last CEC
+ *	       transmitted message
+ *
+ *    \param pSaveMessage   Pointer to the CEC Save Message
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t get_cec_last_message
+(
+    dl_hdmi_cec_save_message_t  *p_save_message
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This function allows enabling a specific event of devlib.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to enable
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_enable_event
+(
+    instance_t      instance,
+    dl_hdmi_cec_event_t event
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This function allows disabling a specific event of devlib.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to disable
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_disable_event
+(
+    instance_t      instance,
+    dl_hdmi_cec_event_t event
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This function enables calibration depending on CEC clock source
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param cecClockSource    CEC clock source
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_enable_calibration
+(
+    instance_t instance,
+    dl_hdmi_cec_clock_source_t cec_clock_source
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This function disable calibration depending on CEC clock source
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_disable_calibration(
+    instance_t instance
+);
+
+/*========================================================================== */
+/*!
+ *    \brief This function allow to send a generic CEC message
+ *           This function has to be used when CEC messages are construct in
+ *	   the middleware
+ *
+ *    \param instance  Instance identifier.
+ *
+ *    \param *pData    Pointer to the CEC data buffer
+ *
+ *    \param lenData   Lenght of I2C data buffer
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_send_message(
+
+    instance_t instance,
+    u8        *p_data,
+    u16       len_data
+);
+
+unsigned char dl_hdmi_cec_get_register(instance_t   instance, u32 offset);
+error_code_t dl_hdmi_cec_set_register(instance_t  instance, u32 offset, u32 value);
+
+#endif /* DLHDMICEC_FUNCTIONS_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Types.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Types.h
new file mode 100755
index 0000000..d9b99b7
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/inc/tmdlHdmiCEC_Types.h
@@ -0,0 +1,1114 @@
+/*============================================================================= */
+/* Copyright (C) 2007 NXP N.V., All Rights Reserved. */
+/* This source code and any compilation or derivative thereof is the proprietary */
+/* information of NXP N.V. and is confidential in nature. Under no circumstances */
+/* is this software to be  exposed to or placed under an Open Source License of */
+/* any type without the expressed written permission of NXP N.V. */
+/*============================================================================= */
+/*!
+ *    \file    dlHdmiCEC_Types.h
+ *
+ *	\version 1.0
+ *
+ *	\date    04/07/2007
+ *
+ * 	\brief   This provides interfaces description of CEC messages.
+ *
+ *    \section refs  Reference Documents
+ *             TDA998X Driver - tx - SCS.doc
+ *    \note    None.
+ *
+ *    HISTORY :
+ *    \verbatim
+ *     Date          Modified by CRPRNr  TASKNr  Maintenance description
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *     04/07/2007   |  F.G      |       |       | Creation.
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *    \endverbatim
+ * */
+/*========================================================================== */
+
+#ifndef DLHDMICEC_TYPES_H
+#define DLHDMICEC_TYPES_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#include "tmNxTypes.h"
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                                DEFINES                                     */
+/*============================================================================*/
+
+/**< Error Codes */
+#define ERR_DLHDMICEC_BASE                      0x100
+#define ERR_DLHDMICEC_COMPATIBILITY             (ERR_DLHDMICEC_BASE + ERR_COMPATIBILITY)             /**< SW Interface compatibility   */
+#define ERR_DLHDMICEC_MAJOR_VERSION             (ERR_DLHDMICEC_BASE + ERR_MAJOR_VERSION)             /**< SW Major Version error       */
+#define ERR_DLHDMICEC_COMP_VERSION              (ERR_DLHDMICEC_BASE + ERR_COMP_VERSION)              /**< SW component version error   */
+#define ERR_DLHDMICEC_BAD_UNIT_NUMBER           (ERR_DLHDMICEC_BASE + ERR_BAD_UNIT_NUMBER)           /**< Invalid device unit number   */
+#define ERR_DLHDMICEC_BAD_INSTANCE              (ERR_DLHDMICEC_BASE + ERR_BAD_INSTANCE)              /**< Bad input instance value     */
+#define ERR_DLHDMICEC_BAD_HANDLE                (ERR_DLHDMICEC_BASE + ERR_BAD_HANDLE)                /**< Bad input handle             */
+#define ERR_DLHDMICEC_BAD_PARAMETER             (ERR_DLHDMICEC_BASE + ERR_BAD_PARAMETER)             /**< Invalid input parameter      */
+#define ERR_DLHDMICEC_NO_RESOURCES              (ERR_DLHDMICEC_BASE + ERR_NO_RESOURCES)              /**< Resource is not available    */
+#define ERR_DLHDMICEC_RESOURCE_OWNED            (ERR_DLHDMICEC_BASE + ERR_RESOURCE_OWNED)            /**< Resource is already in use   */
+#define ERR_DLHDMICEC_RESOURCE_NOT_OWNED        (ERR_DLHDMICEC_BASE + ERR_RESOURCE_NOT_OWNED)        /**< Caller does not own resource */
+#define ERR_DLHDMICEC_INCONSISTENT_PARAMS       (ERR_DLHDMICEC_BASE + ERR_INCONSISTENT_PARAMS)       /**< Inconsistent input params    */
+#define ERR_DLHDMICEC_NOT_INITIALIZED           (ERR_DLHDMICEC_BASE + ERR_NOT_INITIALIZED)           /**< Component is not initialized */
+#define ERR_DLHDMICEC_NOT_SUPPORTED             (ERR_DLHDMICEC_BASE + ERR_NOT_SUPPORTED)             /**< Function is not supported    */
+#define ERR_DLHDMICEC_INIT_FAILED               (ERR_DLHDMICEC_BASE + ERR_INIT_FAILED)               /**< Initialization failed        */
+#define ERR_DLHDMICEC_BUSY                      (ERR_DLHDMICEC_BASE + ERR_BUSY)                      /**< Component is busy            */
+#define ERR_DLHDMICEC_I2C_READ                  (ERR_DLHDMICEC_BASE + ERR_READ)                      /**< Read error                   */
+#define ERR_DLHDMICEC_I2C_WRITE                 (ERR_DLHDMICEC_BASE + ERR_WRITE)                     /**< Write error                  */
+#define ERR_DLHDMICEC_FULL                      (ERR_DLHDMICEC_BASE + ERR_FULL)                      /**< Queue is full                */
+#define ERR_DLHDMICEC_NOT_STARTED               (ERR_DLHDMICEC_BASE + ERR_NOT_STARTED)               /**< Function is not started      */
+#define ERR_DLHDMICEC_ALREADY_STARTED           (ERR_DLHDMICEC_BASE + ERR_ALREADY_STARTED)           /**< Function is already started  */
+#define ERR_DLHDMICEC_ASSERTION                 (ERR_DLHDMICEC_BASE + ERR_ASSERTION)                 /**< Assertion failure            */
+#define ERR_DLHDMICEC_INVALID_STATE             (ERR_DLHDMICEC_BASE + ERR_INVALID_STATE)             /**< Invalid state for function   */
+#define ERR_DLHDMICEC_OPERATION_NOT_PERMITTED   (ERR_DLHDMICEC_BASE + ERR_OPERATION_NOT_PERMITTED)   /**< corresponds to posix EPERM   */
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/*!
+ *	\enum  dlHdmiCECAbortReason_t
+ *    \brief This enum indicates the reason for a <Feature Abort> response
+ * */
+typedef enum {
+	CEC_ABORT_UNKNOWN_OPCODE      = 0, /*!< Unrecognized opcode */
+	CEC_ABORT_INCORRECT_MODE      = 1, /*!< Not in correct mode to respond */
+	CEC_ABORT_NO_SOURCE           = 2, /*!< cannot provide source */
+	CEC_ABORT_INVALID_OPERAND     = 3, /*!< Invalid operand  */
+	CEC_ABORT_REFUSED             = 4, /*!< Refused */
+	CEC_ABORT_UNABLE_TO_DETERMINE = 5  /*!< Unable to Determine */
+} dl_hdmi_cecabort_reason_t;
+
+/*!
+ *	\enum  dlHdmiCECAnalogueBroadcastType_t
+ *    \brief This enum indicates the analogue broadcast type
+ * */
+typedef enum {
+	CEC_BROADCAST_TYPE_CABLE       = 0x00, /*!< Cable */
+	CEC_BROADCAST_TYPE_SATELLITE   = 0x01, /*!< Satellite*/
+	CEC_BROADCAST_TYPE_TERRESTRIAL = 0x02 /*!< Terrestrial */
+} dl_hdmi_cecanalogue_broadcast_type_t;
+
+/*!
+ *	\enum  _tmdlHdmiCECAnalogueFrequency
+ *    \brief This enum specify the min and max frequency used by an analogue tuner
+ * */
+enum _tmdl_hdmi_cecanalogue_frequency {
+	CEC_ANALOG_FREQ_MIN = 0x0000, /*!< Min frequency used by analogue tuner */
+	CEC_ANALOG_FREQ_MAX = 0xFFFF  /*!< Max frequency used by analogue tuner */
+};
+
+/*!
+ *	\enum  _tmdlHdmiCECAsciiDigit
+ *    \brief This enum represent the min and max of a printable digit character
+ * */
+enum _tmdl_hdmi_cecascii_digit {
+	CEC_ASCII_DIGIT_MIN = 0x30, /*!< Min of a printable digit character */
+	CEC_ASCII_DIGIT_MAX = 0x39  /*!< Max of a printable digit character */
+};
+
+/*!
+ *	\enum  _tmdlHdmiCECAscii
+ *    \brief This enum represent the min and max of a printable character
+ * */
+enum _tmbs_hdmi_cecascii {
+	CEC_ASCII_CHARACTER_MIN  = 0x20, /*!< Min of a printable character */
+	CEC_ASCII_CHARACTER_MAX  = 0x7E  /*!< Max of a printable character */
+};
+
+/*!
+ *    \enum  _tmdlHdmiCECAudioFormatCode
+ *    \brief This enum represent the min and max of a Audio Format Code is defined
+ *           in CEA-861-D for CEA Short Audio Descriptor
+ * */
+enum _tmdl_hdmi_cecaudio_format_code {
+	CEC_AUDIO_FORMAT_CODE_MIN = 0x01, /*!< Min of a Audio Format Code */
+	CEC_AUDIO_FORMAT_CODE_MAX = 0x0F  /*!< Max of a Audio Format Code */
+};
+
+/*!
+ *	\enum  dlHdmiCECAudioRate_t
+ *    \brief This enum indicates the audio range control
+ * */
+typedef enum {
+	CEC_AUDIO_RATE_OFF                        = 0, /*!< Rate Control off */
+	/*!< Standard rate : 100% rate */
+	CEC_AUDIO_RATE_WIDE_RANGE_STANDARD_RATE   = 1,
+	/*!< Fast rate : Max 101% rate */
+	CEC_AUDIO_RATE_WIDE_RANGE_FAST_RATE       = 2,
+	/*!< Sloaw rate : 99% rate */
+	CEC_AUDIO_RATE_WIDE_RANGE_SLOW_RATE       = 3,
+	/*!< Standard rate : 100% rate */
+	CEC_AUDIO_RATE_NARROW_RANGE_STANDARD_RATE = 4,
+	/*!< Fast rate : Max 101% rate */
+	CEC_AUDIO_RATE_NARROW_RANGE_FAST_RATE     = 5,
+	/*!< Sloaw rate : 99% rate */
+	CEC_AUDIO_RATE_NARROW_RANGE_SLOW_RATE     = 6
+} dl_hdmi_cecaudio_rate_t;
+
+/*!
+ *	\enum  dlHdmiCECAudioMute_t
+ *    \brief This enum indicates the audio current audio mute status
+ * */
+typedef enum {
+	CEC_AUDIO_MUTE_OFF  = 0, /*!< Audio Mute off */
+	CEC_AUDIO_MUTE_ON   = 1 /*!< Audio Mute on */
+} dl_hdmi_cecaudio_mute_t;
+
+/*!
+ *	\struct dlHdmiCECAudioStatus_t
+ *    \brief  This union indicates the current audio status of a device
+ * */
+typedef struct _tmdl_hdmi_cecaudio_status_t {
+	dl_hdmi_cecaudio_mute_t audio_mute_status   ; /*!< Audio Mute Status */
+	u8                  audio_volume_status ; /*!< Audio Volume Status  */
+} dl_hdmi_cecaudio_status_t, *ptmdl_hdmi_cecaudio_status_t;
+
+/*!
+ *	\enum  dlHdmiCECBoolean_t
+ *    \brief This enum indicates a Flag
+ * */
+typedef enum {
+	CEC_FALSE  = 0, /*!< false */
+	CEC_TRUE   = 1, /*!< true */
+} dl_hdmi_cecboolean_t;
+
+/*!
+ *	\enum  dlHdmiCECBroadcastSystem_t
+ *    \brief This enum indicates information about the color system, the sound carrier and IF-frequency
+ * */
+typedef enum {
+	/*!< Sound  / Sound Modulation / Video Modulation / Vertical Frequency / Color sub-carier         */
+	/*!< 5.5MHZ / FM                 NEG                50HZ                 4.43 MHZ                 */
+	CEC_BROADCAST_SYSTEM_PAL_BG       = 0,
+	/*!< 6.5MHZ / AM                 POS                50HZ                 Fob 4.25MHz,For 4.406Mhz */
+	CEC_BROADCAST_SYSTEM_PAL_SECAM_L  = 1,
+	/*!< 4.5MHZ / FM                 NEG                60HZ                 3.5756 MHZ               */
+	CEC_BROADCAST_SYSTEM_PAL_M        = 2,
+	/*!< 4.5MHZ / FM                 NEG                60HZ                 3.5795 MHZ               */
+	CEC_BROADCAST_SYSTEM_NTSC_M       = 3,
+	/*!< 6.0MHZ / FM                 NEG                50HZ                 4.43 MHZ                 */
+	CEC_BROADCAST_SYSTEM_PAL_I        = 4,
+	/*!< 6.5MHZ / FM                 NEG                50HZ                 Fob 4.25MHz,For 4.406Mhz */
+	CEC_BROADCAST_SYSTEM_SECAM_DK     = 5,
+	/*!< 5.5MHZ / FM                 NEG                50HZ                 Fob 4.25MHz,For 4.406Mhz */
+	CEC_BROADCAST_SYSTEM_SECAM_BG     = 6,
+	/*!< 6.5MHZ / AM                 POS                50HZ                 Fob 4.25MHz,For 4.406Mhz */
+	CEC_BROADCAST_SYSTEM_SECAM_L      = 7,
+	/*!< 5.5MHZ / FM                 NEG                50HZ                 4.43MHZ                  */
+	CEC_BROADCAST_SYSTEM_PAL_DK       = 8,
+	CEC_BROADCAST_SYSTEM_FUTURE_USE   = 9, /*!< Future Use   */
+	CEC_BROADCAST_SYSTEM_OTHER_SYSTEM = 31 /*!< Other System */
+} dl_hdmi_cecbroadcast_system_t;
+
+/*!
+ *	\enum  dlHdmiCECVersion_t
+ *    \brief This enum indicates the supported CEC version
+ * */
+typedef enum {
+	cec_version_reserved = 0x00, /*!< CEC Reserved */
+	cec_version_reserved1 = 0x01, /*!< CEC Reserved */
+	cec_version_reserved2 = 0x02, /*!< CEC Reserved */
+	cec_version_reserved3 = 0x03, /*!< CEC Reserved */
+	cec_version_1_3a     = 0x04, /*!< CEC Version 1.3a */
+	CEC_VERSION_1_4      = 0x05  /*!< CEC Version 1.4  */
+} dl_hdmi_cecversion_t;
+
+/*!
+ *	\enum  dlHdmiCECChanNumFormat_t
+ *    \brief This enum indicates the Channel Format
+ * */
+typedef enum {
+	CEC_FIRST_CHAN_NUMBER  = 0x01, /*!< 1-part channel number */
+	CEC_SECOND_CHAN_NUMBER = 0x02  /*!< 2-part channel number */
+} dl_hdmi_cecchan_num_format_t;
+
+/*!
+ *	\struct dlHdmiCECChannelIdentifier_t
+ *    \brief  This struct indicates a 1-part Logical or Virtual Channel Number or
+ *            a 2-part Major and Minor channel combination
+ * */
+typedef struct {
+	dl_hdmi_cecchan_num_format_t chan_num_format   ; /*!< Channel Format */
+	/*!< Major Channel Number (if channel is 2-part) */
+	u16                      major_chan_number ;
+	/*!< 1-part Channel Number ,or a Minor Channel Number (if channel is 2-part) */
+	u16                      minor_chan_number ;
+} dl_hdmi_cecchannel_identifier_t ;
+
+/*!
+ *	\enum  dlHdmiCECDayOfMonth_t
+ *    \brief This enum indicates the day of the month
+ * */
+typedef enum {
+	CEC_FIRST_DAY_OF_MONTH  = 1, /*!< First day of the month */
+	CEC_LAST_DAY_OF_MONTH   = 31 /*!< Last day of the month */
+} dl_hdmi_cecday_of_month_t;
+
+/*!
+ *	\enum  dlHdmiCECDecControlMode_t
+ *    \brief This enum indicates command used for opcode <Deck Control>
+ * */
+typedef enum {
+	CEC_DECK_CONTROL_WIND   = 1, /*!< Skip Forward / Wind   */
+	CEC_DECK_CONTROL_REWIND = 2, /*!< Skip Reverse / Rewind */
+	CEC_DECK_CONTROL_STOP   = 3, /*!< Stop                  */
+	CEC_DECK_CONTROL_EJECT  = 4  /*!< Eject                 */
+} dl_hdmi_cecdec_control_mode_t;
+
+/*!
+ *	\enum  dlHdmiCECDecInfo_t
+ *    \brief This enum indicates the current status of a tape or disk deck
+ * */
+typedef enum {
+	CEC_DECK_INFO_PLAY              = 0x11, /*!< Play                  */
+	CEC_DECK_INFO_RECORD            = 0x12, /*!< Record                */
+	CEC_DECK_INFO_PLAY_REVERSE      = 0x13, /*!< Play Reverse          */
+	CEC_DECK_INFO_STILL             = 0x14, /*!< Still                 */
+	CEC_DECK_INFO_SLOW              = 0x15, /*!< Slow                  */
+	CEC_DECK_INFO_SLOW_REVERSE      = 0x16, /*!< Slow Reverse          */
+	CEC_DECK_INFO_FAST_FORWARD      = 0x17, /*!< Fast Forward          */
+	CEC_DECK_INFO_FAST_REVERSE      = 0x18, /*!< Fast Reverse          */
+	CEC_DECK_INFO_NO_MEDIA          = 0x19, /*!< No Media              */
+	CEC_DECK_INFO_STOP              = 0x1A, /*!< Stop                  */
+	CEC_DECK_INFO_WIND              = 0x1B, /*!< Skip Forward / Wind   */
+	CEC_DECK_INFO_REWIND            = 0x1C, /*!< Skip Reverse / Rewind */
+	CEC_DECK_INFO_ID_SEARCH_FORWARD = 0x1D, /*!< Index Search Forward  */
+	CEC_DECK_INFO_ID_SEARCH_REVERSE = 0x1E, /*!< Index Search Forward  */
+	CEC_DECK_INFO_OTHER_STATUS      = 0x1F  /*!< Other Status          */
+} dl_hdmi_cecdec_info_t;
+
+/*!
+ *	\enum  dlHdmiCECDeviceType_t
+ *    \brief This enum indicates the device type
+ * */
+typedef enum {
+	CEC_DEVICE_TYPE_TV               = 0, /*!< TV               */
+	CEC_DEVICE_TYPE_REC_DEVICE       = 1, /*!< Recording Device */
+	CEC_DEVICE_TYPE_RESERVED         = 2, /*!< Reserved         */
+	CEC_DEVICE_TYPE_TUNER            = 3, /*!< Tuner            */
+	CEC_DEVICE_TYPE_PLAYBACK_DEVICE  = 4, /*!< PlayBack Device  */
+	CEC_DEVICE_TYPE_AUDIO_DEVICE     = 5, /*!< Audio System     */
+	CEC_DEVICE_TYPE_PURE_CEC_SWITCTH = 6,  /*!< Pure CEC Switch  */
+	CEC_DEVICE_TYPE_VIDEO_PROCESSOR  = 7  /*!< Video Processor  */
+} dl_hdmi_cecdevice_type_t;
+
+/*!
+ *	\enum  dlHdmiCECServiceIdentMethod_t
+ *    \brief This enum indicates a Service Indentification Method
+ * */
+typedef enum {
+	CEC_SERVICE_DIGITAL  = 0, /*!< Service identified by digital IDs  */
+	CEC_SERVICE_CHANNEL  = 1  /*!< Service identified by channel      */
+} dl_hdmi_cecservice_ident_method_t;
+
+/*!
+ *	\enum  dlHdmiCECDigitalBroadcastSystem_t
+ *    \brief This enum indicates the Digital Broadcast System of required service
+ * */
+typedef enum {
+	CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC = 0x01, /*!< ARIB generic */
+	CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC = 0x02, /*!< ATSC generic */
+	CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC  = 0x03, /*!< DVB generic  */
+	CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_BS      = 0x08, /*!< ARIB-BS      */
+	CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_CS      = 0x09, /*!< ARIB-CS      */
+	CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_T       = 0x0A, /*!< ARIB-T       */
+	CEC_DIGITAL_BROADCAST_SYSTEM_CABLE        = 0x10, /*!< Cable        */
+	CEC_DIGITAL_BROADCAST_SYSTEM_SATELLITE    = 0x11, /*!< Satellite    */
+	CEC_DIGITAL_BROADCAST_SYSTEM_TERRESTRIAL  = 0x12, /*!< Terrestrial  */
+	CEC_DIGITAL_BROADCAST_SYSTEM_DVB_C        = 0x18, /*!< DVB-C        */
+	CEC_DIGITAL_BROADCAST_SYSTEM_DVB_S        = 0x19, /*!< DVB-S        */
+	CEC_DIGITAL_BROADCAST_SYSTEM_DVB_S2       = 0x1A, /*!< DVB-S2       */
+	CEC_DIGITAL_BROADCAST_SYSTEM_DVB_T        = 0x1B  /*!< DVB-T        */
+} dl_hdmi_cecdigital_broadcast_system_t;
+
+/*!
+ *	\struct dlHdmiCECAribData_t
+ *    \brief  This struct indicates the ARIB Data
+ * */
+typedef struct {
+	/*!< Tansport_stream_id of the transport stream carrying the required service                  */
+	u16 transport_stream_id ;
+	/*!< Service_ID of the required service                                                        */
+	u16 service_id         ;
+	/*!< Original_network_ID of the network carrying the transport stream for the required service */
+	u16 original_network_id ;
+} dl_hdmi_cecarib_data_t ;
+
+/*!
+ *	\struct dlHdmiCECAtscData_t
+ *    \brief  This struct indicates the ATSC Data
+ * */
+typedef struct {
+	/*!< Tansport_stream_id of the transport stream carrying the required service */
+	u16 transport_stream_id ;
+	/*!< Program Number of the required service                                   */
+	u16 program_number     ;
+	/*!< Reserved                                                                 */
+	u16 reserved          ;
+} dl_hdmi_cecatsc_data_t ;
+
+/*!
+ *	\struct dlHdmiCECDvbData_t
+ *    \brief  This struct indicates the DVB Data
+ * */
+typedef struct {
+	/*!< Tansport_stream_id of the transport stream carrying the required service                  */
+	u16 transport_stream_id ;
+	/*!< Service_ID of the required service                                                        */
+	u16 service_id         ;
+	/*!< Original_network_ID of the network carrying the transport stream for the required service */
+	u16 original_network_id ;
+} dl_hdmi_cecdvb_data_t ;
+
+/*!
+ *	\struct dlHdmiCECChannelData_t
+ *    \brief  This struct indicates the Channel Data
+ * */
+typedef struct {
+	/*!< Logical or virtual channel number of a service */
+	dl_hdmi_cecchannel_identifier_t channel_identifier ;
+	/*!< Reserved                                       */
+	u16 reserved                                  ;
+} dl_hdmi_cecchannel_data_t ;
+
+/*!
+ *	\struct dlHdmiCECDigitalServiceIdentification_t
+ *    \brief  This struct indicates the Digital Broadcast System
+ *            and the parameters to identify a specific service
+ * */
+typedef struct _tmdl_hdmi_cecdigital_service_identification_t {
+	/*!< See dlHdmiCECServiceIdentMethod_t                                                                   */
+	dl_hdmi_cecservice_ident_method_t     service_identification_method ;
+	/*!< See dlHdmiCECDigitalBroadcastSystem_t                                                               */
+	dl_hdmi_cecdigital_broadcast_system_t digital_broadcast_system      ;
+	/*!< dlHdmiCECAribData_t or dlHdmiCECAtscData_t or dlHdmiCECDvbData_t or dlHdmiCECChannelData_t */
+	void                                *p_service_identification     ;
+} dl_hdmi_cecdigital_service_identification_t, *ptmdl_hdmi_cecdigital_service_identification_t;
+
+/*!
+ *	\enum  dlHdmiCECDisplayControl_t
+ *    \brief This enum indicates the display mode for an on screen display message
+ * */
+typedef enum {
+	/*!< Display for default time */
+	CEC_DISPLAY_CONTROL_DEFAULT_TIME           = 0  ,
+	/*!< Display until cleared     */
+	CEC_DISPLAY_CONTROL_UNTIL_CLEARED          = 64 ,
+	/*!< Clear previous message    */
+	CEC_DISPLAY_CONTROL_CLEAR_PREVIOUS_MESSAGE = 128,
+	/*!< Clear previous message    */
+	CEC_DISPLAY_CONTROL_RESERVED               = 192
+} dl_hdmi_cecdisplay_control_t;
+
+/*!
+ *	\struct dlHdmiCECDuration_t
+ *    \brief  This struct indicates a duration in BCD format
+ * */
+typedef struct {
+	u8 hours  ; /*!< Duration hours in bcd format between 0 and 99 */
+	u8 minute ; /*!< Duration minute in bcd format between 0 and 59 */
+} dl_hdmi_cecduration_t ;
+
+/*!
+ *    \brief  This typedef indicates physical adress of device that is to be used as the source of a recording
+ * */
+typedef u16 dl_hdmi_cecexternal_physical_address_t ;
+
+/*!
+ *    \brief  This typedef indicates external plug number (1 to 255 )on the recording device
+ * */
+typedef u8 dl_hdmi_cecexternal_plug_t;
+
+/*!
+ *	\enum  dlHdmiCECExternalSourceSpecifier_t
+ *    \brief This enum indicates External source specifier
+ * */
+typedef enum {
+	CEC_EXTERNAL_PLUG             = 4  , /*!< Display for default time */
+	CEC_EXTERNAL_PHYSICAL_ADDRESS = 5    /*!< Display until cleared     */
+} dl_hdmi_cecexternal_source_specifier_t;
+
+/*!
+ *    \brief  This typedef indicates External Source is specified bey exeternal plug number on the recording device
+ *            or by the External physical Adress of the required source
+ * */
+typedef u8 external_source_specifier;
+
+/*!
+ *	\enum  dlHdmiCECFeatureOpcode_t
+ *    \brief This enum defines command to be performed
+ * */
+typedef enum {
+	CEC_OPCODE_FEATURE_ABORT                 = 0x00, /*!< */
+	CEC_OPCODE_IMAGE_VIEW_ON                 = 0x04, /*!< */
+	CEC_OPCODE_TUNER_STEP_INCREMENT          = 0x05, /*!< */
+	CEC_OPCODE_TUNER_STEP_DECREMENT          = 0x06, /*!< */
+	CEC_OPCODE_TUNER_DEVICE_STATUS           = 0x07, /*!< */
+	CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS      = 0x08, /*!< */
+	CEC_OPCODE_RECORD_ON                     = 0x09, /*!< */
+	CEC_OPCODE_RECORD_STATUS                 = 0x0A, /*!< */
+	CEC_OPCODE_RECORD_OFF                    = 0x0B, /*!< */
+	CEC_OPCODE_TEXT_VIEW_ON                  = 0x0D, /*!< */
+	CEC_OPCODE_RECORD_TV_SCREEN              = 0x0F, /*!< */
+	CEC_OPCODE_GIVE_DECK_STATUS              = 0x1A, /*!< */
+	CEC_OPCODE_DECK_STATUS                   = 0x1B, /*!< */
+	CEC_OPCODE_SET_MENU_LANGUAGE             = 0x32, /*!< */
+	CEC_OPCODE_CLEAR_ANALOGUE_TIMER          = 0x33, /*!< */
+	CEC_OPCODE_SET_ANALOGUE_TIMER            = 0x34, /*!< */
+	CEC_OPCODE_TIMER_STATUS                  = 0x35, /*!< */
+	CEC_OPCODE_STANDBY                       = 0x36, /*!< */
+	CEC_OPCODE_PLAY                          = 0x41, /*!< */
+	CEC_OPCODE_DESCK_CONTROL                 = 0x42, /*!< */
+	CEC_OPCODE_TIMER_CLEARED_STATUS          = 0x43, /*!< */
+	CEC_OPCODE_USER_CONTROL_PRESSED          = 0x44, /*!< */
+	CEC_OPCODE_USER_CONTROL_RELEASED         = 0x45, /*!< */
+	CEC_OPCODE_GIVE_OSD_NAME                 = 0x46, /*!< */
+	CEC_OPCODE_SET_OSD_NAME                  = 0x47, /*!< */
+	CEC_OPCODE_SET_OSD_STRING                = 0x64, /*!< */
+	CEC_OPCODE_SET_TIMER_PROGRAM_TITLE       = 0x67, /*!< */
+	CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST     = 0x70, /*!< */
+	CEC_OPCODE_GIVE_AUDIO_STATUS             = 0x71, /*!< */
+	CEC_OPCODE_SET_SYSTEM_AUDIO_MODE         = 0x72, /*!< */
+	CEC_OPCODE_REPORT_AUDIO_STATUS           = 0x7A, /*!< */
+	CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS = 0x7D, /*!< */
+	CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS      = 0x7E, /*!< */
+	CEC_OPCODE_ROUTING_CHANGE                = 0x80, /*!< */
+	CEC_OPCODE_ROUTING_INFORMATION           = 0x81, /*!< */
+	CEC_OPCODE_ACTIVE_SOURCE                 = 0x82, /*!< */
+	CEC_OPCODE_GIVE_PHYSICAL_ADDRESS         = 0x83, /*!< */
+	CEC_OPCODE_REPORT_PHYSICAL_ADDRESS       = 0x84, /*!< */
+	CEC_OPCODE_REQUEST_ACTIVE_SOURCE         = 0x85, /*!< */
+	CEC_OPCODE_SET_STREAM_PATH               = 0x86, /*!< */
+	CEC_OPCODE_DEVICE_VENDOR_ID		    = 0x87, /*!< */
+	CEC_OPCODE_VENDOR_COMMAND                = 0x89, /*!< */
+	CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN     = 0x8A, /*!< */
+	CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP       = 0x8B, /*!< */
+	CEC_OPCODE_GIVE_DEVICE_VENDOR_ID         = 0x8C, /*!< */
+	CEC_OPCODE_MENU_REQUEST                  = 0x8D, /*!< */
+	CEC_OPCODE_MENU_STATUS                   = 0x8E, /*!< */
+	CEC_OPCODE_GIVE_DEVICE_POWER_STATUS      = 0x8F, /*!< */
+	CEC_OPCODE_REPORT_POWER_STATUS           = 0x90, /*!< */
+	CEC_OPCODE_GET_MENU_LANGUAGE             = 0x91, /*!< */
+	CEC_OPCODE_SET_ANALOGUE_SERVICE          = 0x92, /*!< */
+	CEC_OPCODE_SET_DIGITAL_SERVICE           = 0x93, /*!< */
+	CEC_OPCODE_SET_DIGITAL_TIMER             = 0x97, /*!< */
+	CEC_OPCODE_CLEAR_DIGITAL_TIMER           = 0x99, /*!< */
+	CEC_OPCODE_SET_AUDIO_RATE                = 0x9A, /*!< */
+	CEC_OPCODE_INACTIVE_SOURCE               = 0x9D, /*!< */
+	CEC_OPCODE_CEC_VERSION                   = 0x9E, /*!< */
+	CEC_OPCODE_GET_CEC_VERSION               = 0x9F, /*!< */
+	CEC_OPCODE_VENDOR_COMMAND_WITH_ID        = 0xA0, /*!< */
+	CEC_OPCODE_CLEAR_EXTERNAL_TIMER          = 0xA1, /*!< */
+	CEC_OPCODE_SET_EXTERNAL_TIMER            = 0xA2, /*!< */
+	CEC_OPCODE_REPORT_SHORT_AUDIO_DESCRIPTOR = 0xA3, /*!< */
+	CEC_OPCODE_REQUEST_SHORT_AUDIO_DESCRIPTOR = 0xA4, /*!< */
+	CEC_OPCODE_INITATE_ARC                   = 0xC0, /*!< */
+	CEC_OPCODE_REPORT_ARC_INITIATED          = 0xC1, /*!< */
+	CEC_OPCODE_REPORT_ARC_TERMINATED         = 0xC2, /*!< */
+	CEC_OPCODE_REPORT_ARC_INITIATION         = 0xC3, /*!< */
+	CEC_OPCODE_REPORT_ARC_TERMINATION        = 0xC4, /*!< */
+	CEC_OPCODE_TERMINATE_ARC                 = 0xC5, /*!< */
+	/*!< This message is reserved for testing*/
+	CEC_OPCODE_ABORT_MESSAGE                 = 0xFF
+} dl_hdmi_cecfeature_opcode_t;
+
+/*!
+ *	\enum  dlHdmiCECMenuRequestType_t
+ *    \brief This enum specifies wether to activate or desactivate a devices menu or
+ *           simply query its current menu status
+ * */
+typedef enum {
+	CEC_MENU_TYPE_ACTIVATE        = 0 , /*!< Activate   */
+	CEC_MENU_TYPE_DEACTIVATE      = 1 , /*!< Deactivate */
+	CEC_MENU_TYPE_QUERY           = 2   /*!< Query      */
+} dl_hdmi_cecmenu_request_type_t;
+
+/*!
+ *	\enum  dlHdmiCECMenuState_t
+ *    \brief This enum pecifies state of the device menu
+ * */
+typedef enum {
+	CEC_MENU_STATE_ACTIVATE        = 0 , /*!< Activate   */
+	CEC_MENU_STATE_DEACTIVATE      = 1   /*!< Deactivate */
+} dl_hdmi_cecmenu_state_t;
+
+/*!
+ *	\enum  dlHdmiCECPlayMode_t
+ *    \brief This enum indicates in which mode to play media
+ * */
+typedef enum {
+	CEC_MODE_PLAY_FORWARD              = 0x24 ,
+	CEC_MODE_PLAY_REVERSE              = 0x20 ,
+	CEC_MODE_FAST_FORWARD_MIN_SPEED    = 0x05 ,
+	CEC_MODE_FAST_FORWARD_MEDIUM_SPEED = 0x06 ,
+	CEC_MODE_FAST_FORWARD_MAX_SPEED    = 0x07 ,
+	CEC_MODE_FAST_REVERSE_MIN_SPEED    = 0x09 ,
+	CEC_MODE_FAST_REVERSE_MEDIUM_SPEED = 0x0A ,
+	CEC_MODE_FAST_REVERSE_MAX_SPEED    = 0x0B ,
+	CEC_MODE_SLOW_FORWARD_MIN_SPEED    = 0x15 ,
+	CEC_MODE_SLOW_FORWARD_MEDIUM_SPEED = 0x16 ,
+	CEC_MODE_SLOW_FORWARD_MAX_SPEED    = 0x17 ,
+	CEC_MODE_SLOW_REVERSE_MIN_SPEED    = 0x19 ,
+	CEC_MODE_SLOW_REVERSE_MEDIUM_SPEED = 0x1A ,
+	CEC_MODE_SLOW_REVERSE_MAX_SPEED    = 0x1B
+} dl_hdmi_cecplay_mode_t;
+
+/*!
+ *	\enum  dlHdmiCECPowerStatus_t
+ *    \brief This enum indicates the current power status of a device
+ * */
+typedef enum {
+	/*!< On                          */
+	CEC_POWER_STATUS_ON                       = 0x00 ,
+	/*!< Standby                     */
+	CEC_POWER_STATUS_STANDBY                  = 0x01 ,
+	/*!< In Transition Standby to On */
+	CEC_POWER_STATUS_TRANSITION_STANDBY_TO_ON = 0x02 ,
+	/*!< In Transition On to StandBy */
+	CEC_POWER_STATUS_TRANSITION_ON_TO_STANDBY = 0x03
+} dl_hdmi_cecpower_status_t;
+
+/*!
+ *	\enum  dlHdmiCECRecordSourceType_t
+ *    \brief This enum allows the record source to be specified for a recording
+ * */
+typedef enum {
+	/*!< Own Source                */
+	CEC_RECORD_SOURCE_OWN_SOURCE                = 1 ,
+	/*!< Digital Service           */
+	CEC_RECORD_SOURCE_DIGITAL_SERVICE           = 2 ,
+	/*!< Analogue Service          */
+	CEC_RECORD_SOURCE_ANALOGUE_SERVICE          = 3 ,
+	/*!< External Plug             */
+	CEC_RECORD_SOURCE_EXTERNAL_PLUG             = 4 ,
+	/*!< External Physical Address */
+	CEC_RECORD_SOURCE_EXTERNAL_PHYSICAL_ADDRESS = 5
+} dl_hdmi_cecrecord_source_type_t;
+
+/*!
+ *	\enum  dlHdmiCECRecordStatusInfo_t
+ *    \brief This enum indicates the status of a recording
+ * */
+typedef enum {
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_CURRENTLY_SELECTED_SOURCE       = 1 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_DIGITAL_SERVICE                 = 2 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_ANALOGUE_SERVCICE               = 3 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_EXTERNAL_INPUT                  = 4 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_UNABLE_TO_RECORD_DIGITAL_SERVICE   = 5 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_UNABLE_TO_RECORD_ANALOGUE_SERVICE  = 6 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_UNABLE_TO_SELECT_REQUIRED_SERVICE  = 7 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_INVALID_EXTERNAL_PLUG_NUMBER       = 9 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_INVALID_EXTERNAL_PHYSICAL_ADDRESS  = 10 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_CA_SYSTEM_NOT_SUPPORTED            = 11 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NO_OR_INSUFFICIENT_CA_ENTITLEMENTS = 12 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NOT_ALLOWED_TO_COPY_SOURCE         = 13 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NO_FURTHER_COPY_ALLOWED            = 14 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NO_MEDIA                           = 16 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_PLAYING                            = 17 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_ALREADY_RECORDING                  = 18 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_MEDIA_PROTECTED                    = 19 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NO_SOURCE_SIGNAL                   = 20 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_MEDIA_PROBLEM                      = 21 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_NOT_ENOUGH_SPACE_AVAILABLE         = 22 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_REC_PARENTAL_LOCK_ON                   = 23 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_TERMINATED_NORMALLY             = 26 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_RECORDING_HAS_ALREADY_TERMINATED          = 27 ,
+	/*!< */
+	CEC_RECORD_STATUS_INFO_NO_RECORDING_OTHER_REASON                 = 31
+} dl_hdmi_cecrecord_status_info_t;
+
+/*!
+ *	\enum  dlHdmiCECRecordingSequence_t
+ *    \brief This enum indicates the status of a recording
+ * */
+typedef enum {
+	CEC_RECORDING_SEQUENCE_ONCE_ONLY = 0 , /*!< */
+	CEC_RECORDING_SEQUENCE_SYNDAY    = 1 , /*!< */
+	CEC_RECORDING_SEQUENCE_MONDAY    = 2 , /*!< */
+	CEC_RECORDING_SEQUENCE_TUESDAY   = 4 , /*!< */
+	CEC_RECORDING_SEQUENCE_WEDNESDAY = 8 , /*!< */
+	CEC_RECORDING_SEQUENCE_THURSDAY  = 16, /*!< */
+	CEC_RECORDING_SEQUENCE_FRIDAY    = 32, /*!< */
+	CEC_RECORDING_SEQUENCE_SATURDAY  = 64  /*!< */
+} dl_hdmi_cecrecording_sequence_t;
+
+/*!
+ *	\enum  dlHdmiCECStatusRequest_t
+ *    \brief This enum contains the status request mode which can be report once or
+ *           on all future state changes or reporting off.
+ * */
+typedef enum {
+	CEC_STATUS_REQUEST_ON   = 1 , /*!< Status Request ON   */
+	CEC_STATUS_REQUEST_OFF  = 2 , /*!< Status Request OFF  */
+	CEC_STATUS_REQUEST_ONCE = 3   /*!< Status Request ONCE */
+} dl_hdmi_cecstatus_request_t;
+
+/*!
+ *	\enum  dlHdmiCECSystemAudioStatus_t
+ *    \brief This enum indicates if the system audio Mode is On or Off
+ * */
+typedef enum {
+	CEC_SYSTEM_AUDIO_STATUS_OFF  = 0 ,   /*!< Status Request OFF  */
+	CEC_SYSTEM_AUDIO_STATUS_ON   = 1  /*!< Status Request ON   */
+} dl_hdmi_cecsystem_audio_status_t;
+
+/*!
+ *	\enum  dlHdmiCECTimerClearedStatusData_t
+ *    \brief This enum indicates status in <Timer Cleared Status> message
+ * */
+typedef enum {
+	CEC_TIMER_STATUS_TIMER_NOT_CLEARED_RECORDING          = 0,  /*!< */
+	CEC_TIMER_STATUS_TIMER_NOT_CLEARED_NO_MATCHING        = 1,  /*!< */
+	CEC_TIMER_STATUS_TIMER_NOT_CLEARED_NO_INFO_AVAILABLE  = 2,  /*!< */
+	CEC_TIMER_STATUS_TIMER_NOT_TIMER_CLEARED              = 128 /*!< */
+} dl_hdmi_cectimer_cleared_status_data_t;
+
+/*!
+ *	\enum  dlHdmiCECTimerOverlapWarning_t
+ *    \brief This enum indicates if there is another timer block already set which
+ *           overlaps with this new recording request
+ * */
+typedef enum {
+	CEC_TIMER_OVERLAP_WARNING_NO_OVERLAP            = 0, /*!< No Overlap   */
+	/*!< Timer blocks overlap  */
+	CEC_TIMER_OVERLAP_WARNING_TIMER_BLOCKS_OVERLAP  = 1
+} dl_hdmi_cectimer_overlap_warning_t;
+
+/*!
+ *	\enum  dlHdmiCECMediaInfo_t
+ *    \brief This enum indicates if removable media is present and its write protect state
+ * */
+typedef enum {
+	/*!< Media present and not protected */
+	CEC_MEDIA_INFO_MEDIA_PRESENT_AND_NOT_PROTECTED   = 0,
+	/*!< Media present but protected     */
+	CEC_MEDIA_INFO_MEDIA_PRESENT_BUT_PROTECTED       = 1,
+	/*!< Media not present               */
+	CEC_MEDIA_INFO_MEDIA_NOT_PRESENT                 = 2,
+	/*!< Future use                      */
+	CEC_MEDIA_INFO_FUTURE_USE                        = 3
+} dl_hdmi_cecmedia_info_t;
+
+/*!
+ *	\enum  dlHdmiCECProgrammedIndicator_t
+ *    \brief This enum indicates a selector for [Timer Programmed Info]
+ * */
+typedef enum {
+	CEC_PROGRAM_INDICATOR_NOT_PROGRAMMED = 0, /*!< */
+	CEC_PROGRAM_INDICATOR_PROGRAMMED     = 1  /*!< */
+} dl_hdmi_cecprogrammed_indicator_t;
+
+/*!
+ *	\enum  dlHdmiCECProgrammedInfo_t
+ *    \brief This enum indicates any non-fatal issues with the programming request
+ * */
+typedef enum {
+	CEC_PROGRAM_INFO_ENOUGHT_SPACE_AVAILABLE_FOR_RECORDING     = 8, /*!< */
+	CEC_PROGRAM_INFO_NOT_ENOUGHT_SPACE_AVAILABLE_FOR_RECORDING = 9, /*!< */
+	CEC_PROGRAM_INFO_NO_MEDIA_INFO_AVAILABLE                   = 10,/*!< */
+	CEC_PROGRAM_INFO_MAY_NOT_BE_ENOUGH_SPACE_AVAILABLE         = 11 /*!< */
+} dl_hdmi_cecprogrammed_info_t;
+
+/*!
+ *	\enum  dlHdmiCECNotProgrammedErrorInfo_t
+ *    \brief This enum indicates reason for programming failure
+ * */
+typedef enum {
+	CEC_PROGRAM_ERROR_INFO_FUTURE_USE                        = 0,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_NO_FREE_TIMER_AVAILABLE           = 1,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_DATE_OUT_OF_RANGE                 = 2,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_RECORDING_SEQUENCE_ERROR          = 3,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_INVALID_EXTERNAL_PLUG_NUMBER      = 4,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_INVALID_EXTERNAL_PHYSICAL_ADDRESS = 5,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_CA_SYSTEM_NOT_SUPPORTED           = 6,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_NO_OR_INSUFFICIENT_CA_ENTITLMENTS = 7,  /*!< */
+	/*!< Tuner or recorder does not support HD */
+	CEC_PROGRAM_ERROR_INFO_DOES_NOT_SUPPORT_RESOLUTION       = 8,
+	CEC_PROGRAM_ERROR_INFO_PARENTAL_LOCK_ON                  = 9,  /*!< */
+	CEC_PROGRAM_ERROR_INFO_CLOCK_FAILURE                     = 10, /*!< */
+	/*!< A timer block with identical details has already been programmed*/
+	CEC_PROGRAM_ERROR_INFO_DUPLICATE_ALREADY_PROGRAMMED      = 14
+} dl_hdmi_cecnot_programmed_error_info_t;
+
+/*!
+ *	\struct dlHdmiCECTimerProgrammedInfo_t
+ *    \brief  This struct
+ * */
+typedef struct {
+	/*!< dlHdmiCECProgrammedIndicator_t */
+	dl_hdmi_cecprogrammed_indicator_t select_program_info ;
+	/*!< dlHdmiCECProgrammedInfo_t or dlHdmiCECNotProgrammedErrorInfo_t*/
+	u8                             program_info;
+	/*!< Optional paramter : If [Programmed Info] is "Not enough space available" */
+	u16                            duration_available ;
+	/*!<  If [Not Programmed Info] is "Duplicate : already programmed" */
+} dl_hdmi_cectimer_programmed_info_t ;
+
+/*!
+ *	\struct dlHdmiCECTimerStatusData_t
+ *    \brief  This struct is used by recording device to respond to the initiator
+ *            of a <Set Timer> message
+ * */
+typedef struct {
+	/*!< Indicates if there is another timer block already set which overlaps with this bew recording request*/
+	dl_hdmi_cectimer_overlap_warning_t timer_overlap_warning ;
+	/*!< Indicate if removable media is present and its write protect state */
+	dl_hdmi_cecmedia_info_t           media_info           ;
+	/*!< Give information about how and if the programming request has been done */
+	dl_hdmi_cectimer_programmed_info_t timer_programmed_info ;
+} dl_hdmi_cectimer_status_data_t ;
+
+/*!
+ *	\enum  dlHdmiCECRecordingFlag_t
+ *    \brief This enum indicates if the tuner is being used as a source of a recording
+ * */
+typedef enum {
+	/*!< Not Being used for recording  */
+	CEC_RECORDING_FLAG_NOT_BEING_USED_FOR_RECORDING = 0,
+	/*!< Being used for recording      */
+	CEC_RECORDING_FLAG_BEING_USED_FOR_RECORDING     = 1
+} dl_hdmi_cecrecording_flag_t;
+
+/*!
+ *	\enum  dlHdmiCECTunerDisplayInfo_t
+ *    \brief This enum indicates if the device is currently displaying its tuner or not.
+ *           (it may for example be displaying an external source or media)
+ * */
+typedef enum {
+	/*!< Displaying Digital Tuner */
+	CEC_TUNER_DISPLAY_MEDIA_DISPLAYING_DIGITAL_TUNER  = 0,
+	/*!< Not Displaying Tuner */
+	CEC_TUNER_DISPLAY_MEDIA_NOT_DISPLAYING_TUNER      = 1,
+	/*!< Not Displaying Tuner */
+	CEC_TUNER_DISPLAY_MEDIA_DISPLAYING_ANALOGUE_TUNER = 2
+} dl_hdmi_cectuner_display_info_t;
+
+/*!
+ *    \enum  dlHdmiCECUiBroadcastType_t
+ *    \brief This enum indicates type of broadcast
+ * */
+typedef enum {
+	CEC_UI_BROADCAST_TYPE_ALL_AVAILABLE           = 0x00 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_ANALOGUE_TOGGLE = 0x01 , /*!< */
+	CEC_UI_BROADCAST_TYPE_ANALOGUE                = 0x10 , /*!< */
+	CEC_UI_BROADCAST_TYPE_ANALOGUE_TERRESTRIAL    = 0x20 , /*!< */
+	CEC_UI_BROADCAST_TYPE_ANALOGUE_CABLE          = 0x30 , /*!< */
+	CEC_UI_BROADCAST_TYPE_ANALOGUE_SATELLITE      = 0x40 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL                 = 0x50 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_TERRESTRIAL     = 0x60 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_CABLE           = 0x70 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_SATELLITE       = 0x80 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_COM_SATELLITE   = 0x90 , /*!< */
+	CEC_UI_BROADCAST_TYPE_DIGITAL_COM_SATELLITE_2 = 0x91 , /*!< */
+	CEC_UI_BROADCAST_TYPE_IP                      = 0xA0   /*!< */
+} dl_hdmi_cecui_broadcast_type_t;
+
+/*!
+ *    \enum  dlHdmiCECUiSoundPresentationControl_t
+ *    \brief This enum indicates the selected command
+ * */
+typedef enum {
+	/*!< "Sound Mixing Mode (Dual Mono)" */
+	CEC_UI_PRESENTATION_CONTROL_SOUND_MIX_DUAL_MONO        = 0x20 ,
+	/*!< "Sound Mixing Mode (Karaoke)" */
+	CEC_UI_PRESENTATION_CONTROL_SOUND_MIX_KARAOKE          = 0x30 ,
+	/*!< "Select Audio Downmix Mode" */
+	CEC_UI_PRESENTATION_CONTROL_SELECT_AUDIO_DOWNMIX       = 0x80 ,
+	/*!< "Select Audio Reverberation Processing Mode" */
+	CEC_UI_PRESENTATION_CONTROL_SELECT_AUDIO_REVERBERATION = 0x90 ,
+	/*!< "Select Audio Equalizer Mode" */
+	CEC_UI_PRESENTATION_CONTROL_SELECT_AUDIO_EQUALIZER     = 0xA0 ,
+	/*!< "bass step + " */
+	CEC_UI_PRESENTATION_CONTROL_BASS_STEP_PLUS             = 0xB1 ,
+	/*!< "bass neutral position" */
+	CEC_UI_PRESENTATION_CONTROL_BASS_NEUTRAL_POSITION      = 0xB2 ,
+	/*!< "bass step - " */
+	CEC_UI_PRESENTATION_CONTROL_BASS_STEP_MINUS            = 0xB3 ,
+	/*!< "Treble step + " */
+	CEC_UI_PRESENTATION_CONTROL_TREBLE_STEP_PLUS           = 0xC1 ,
+	/*!< "Treble neutral position" */
+	CEC_UI_PRESENTATION_CONTROL_TREBLE_NEUTRAL_POSITION    = 0xC2 ,
+	/*!< "Treble step - " */
+	CEC_UI_PRESENTATION_CONTROL_TREBLE_STEP_MINUS          = 0xC3
+
+} dl_hdmi_cecui_sound_presentation_control_t;
+
+/*!
+ *	\enum  dlHdmiCECUserRemoteControlCommand_t
+ *    \brief This enum indicates the remote control button pressed
+ * */
+typedef enum {
+	CEC_REMOTE_BUTTON_SELECT                       = 0,
+	CEC_REMOTE_BUTTON_UP                           = 1,
+	CEC_REMOTE_BUTTON_DOWN                         = 2,
+	CEC_REMOTE_BUTTON_LEFT                         = 3,
+	CEC_REMOTE_BUTTON_RIGHT                        = 4,
+	CEC_REMOTE_BUTTON_RIGHT_UP                     = 5,
+	CEC_REMOTE_BUTTON_RIGHT_DOWN                   = 6,
+	CEC_REMOTE_BUTTON_LEFT_UP                      = 7,
+	CEC_REMOTE_BUTTON_LEFT_DOWN                    = 8,
+	CEC_REMOTE_BUTTON_ROOT_MENU                    = 9,
+	CEC_REMOTE_BUTTON_SETUP_MENU                   = 10,
+	CEC_REMOTE_BUTTON_CONTENTS_MENU                = 11,
+	CEC_REMOTE_BUTTON_FAVORITE_MENU                = 12,
+	CEC_REMOTE_BUTTON_EXIT                         = 13,
+	CEC_REMOTE_BUTTON_MEDIA_TOP_MENU               = 16,
+	CEC_REMOTE_BUTTON_MEDIA_CONTEXT                = 17,
+	CEC_REMOTE_BUTTON_NUMBER_ENTRY_MODE            = 29,
+	CEC_REMOTE_BUTTON_NUMBER_11                    = 30,
+	CEC_REMOTE_BUTTON_NUMBER_12                    = 31,
+	CEC_REMOTE_BUTTON_NUMBER_0_OR_NUMBER_10        = 32,
+	CEC_REMOTE_BUTTON_NUMBER_1                     = 33,
+	CEC_REMOTE_BUTTON_NUMBER_2                     = 34,
+	CEC_REMOTE_BUTTON_NUMBER_3                     = 35,
+	CEC_REMOTE_BUTTON_NUMBER_4                     = 36,
+	CEC_REMOTE_BUTTON_NUMBER_5                     = 37,
+	CEC_REMOTE_BUTTON_NUMBER_6                     = 38,
+	CEC_REMOTE_BUTTON_NUMBER_7                     = 39,
+	CEC_REMOTE_BUTTON_NUMBER_8                     = 40,
+	CEC_REMOTE_BUTTON_NUMBER_9                     = 41,
+	CEC_REMOTE_BUTTON_DOT                          = 42,
+	CEC_REMOTE_BUTTON_ENTER                        = 43,
+	CEC_REMOTE_BUTTON_CLEAR                        = 44,
+	CEC_REMOTE_BUTTON_NEXT_FAVORITE                = 47,
+	CEC_REMOTE_BUTTON_CHANNEL_UP                   = 48,
+	CEC_REMOTE_BUTTON_CHANNEL_DOWN                 = 49,
+	CEC_REMOTE_BUTTON_PREVIOUS_CHANNEL             = 50,
+	CEC_REMOTE_BUTTON_SOUND_SELECT                 = 51,
+	CEC_REMOTE_BUTTON_INPUT_SELECT                 = 52,
+	CEC_REMOTE_BUTTON_DISPLAY_INFORMATION          = 53,
+	CEC_REMOTE_BUTTON_HELP                         = 54,
+	CEC_REMOTE_BUTTON_PAGE_UP                      = 55,
+	CEC_REMOTE_BUTTON_PAGE_DOWN                    = 56,
+	CEC_REMOTE_BUTTON_POWER                        = 64,
+	CEC_REMOTE_BUTTON_VOLUME_UP                    = 65,
+	CEC_REMOTE_BUTTON_VOLUME_DOWN                  = 66,
+	CEC_REMOTE_BUTTON_MUTE                         = 67,
+	CEC_REMOTE_BUTTON_PLAY                         = 68,
+	CEC_REMOTE_BUTTON_STOP                         = 69,
+	CEC_REMOTE_BUTTON_PAUSE                        = 70,
+	CEC_REMOTE_BUTTON_RECORD                       = 71,
+	CEC_REMOTE_BUTTON_REWIND                       = 72,
+	CEC_REMOTE_BUTTON_FAST_FORWARD                 = 73,
+	CEC_REMOTE_BUTTON_EJECT                        = 74,
+	CEC_REMOTE_BUTTON_FORWARD                      = 75,
+	CEC_REMOTE_BUTTON_BACKWARD                     = 76,
+	CEC_REMOTE_BUTTON_STOP_RECORD                  = 77,
+	CEC_REMOTE_BUTTON_PAUSE_RECORD                 = 78,
+	CEC_REMOTE_BUTTON_ANGLE                        = 80,
+	CEC_REMOTE_BUTTON_SUB_PICTURE                  = 81,
+	CEC_REMOTE_BUTTON_VIDEO_ON_DEMAND              = 82,
+	CEC_REMOTE_BUTTON_ELECTRONIC_PROGRAM_GUIDE     = 83,
+	CEC_REMOTE_BUTTON_TIMER_PROGRAMMING            = 84,
+	CEC_REMOTE_BUTTON_INITIAL_CONFIGURATION        = 85,
+	CEC_REMOTE_BUTTON_SELECT_BROADCAST_TYPE        = 86,
+	CEC_REMOTE_BUTTON_SELECT_SOUND_PRESENTATION    = 87,
+	CEC_REMOTE_BUTTON_PLAY_FUNCTION                = 96,
+	CEC_REMOTE_BUTTON_PAUSE_PLAY_FUNCTION          = 97,
+	CEC_REMOTE_BUTTON_RECORD_FUNCTION              = 98,
+	CEC_REMOTE_BUTTON_PAUSE_RECORD_FUNCTION        = 99,
+	CEC_REMOTE_BUTTON_STOP_FUNCTION                = 100,
+	CEC_REMOTE_BUTTON_MUTE_FUNCTION                = 101,
+	CEC_REMOTE_BUTTON_RESTORE_VOLUME_FUNCTION      = 102,
+	CEC_REMOTE_BUTTON_TUNE_FUNCTION                = 103,
+	CEC_REMOTE_BUTTON_SELECT_MEDIA_FUNCTION        = 104,
+	CEC_REMOTE_BUTTON_SELECT_AV_INPUT_FUNCTION     = 105,
+	CEC_REMOTE_BUTTON_SELECT_AUDIO_INPUT_FUNCTION  = 106,
+	CEC_REMOTE_BUTTON_POWER_TOGGLE_FUNCTION        = 107,
+	CEC_REMOTE_BUTTON_POWER_OFF_FUNCTION           = 108,
+	CEC_REMOTE_BUTTON_POWER_ON_FUNCTION            = 109,
+	CEC_REMOTE_BUTTON_F1_BLUE                      = 113,
+	CEC_REMOTE_BUTTON_F2_RED                       = 114,
+	CEC_REMOTE_BUTTON_F3_GREEN                     = 115,
+	CEC_REMOTE_BUTTON_F4_YELLOW                    = 116,
+	CEC_REMOTE_BUTTON_F5                           = 117,
+	CEC_REMOTE_BUTTON_DATA                         = 118
+} dl_hdmi_cecuser_remote_control_command_t;
+
+/*!
+ *	\enum  dlHdmiCECLogicalAddress_t
+ *    \brief This enum indicates the logical address of the a device
+ * */
+typedef enum {
+	/*!< TV                    */
+	CEC_LOGICAL_ADDRESS_TV                     = 0,
+	/*!< Recording Device 1    */
+	CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1     = 1,
+	/*!< Recording Device 1    */
+	CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2     = 2,
+	/*!< Tuner 1               */
+	CEC_LOGICAL_ADDRESS_TUNER_1                = 3,
+	/*!< Playback Device 1     */
+	CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1      = 4,
+	/*!< Audio System          */
+	CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM           = 5,
+	/*!< Tuner 2               */
+	CEC_LOGICAL_ADDRESS_TUNER_2                = 6,
+	/*!< Tuner 3               */
+	CEC_LOGICAL_ADDRESS_TUNER_3                = 7,
+	/*!< Playback Device 2     */
+	CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2      = 8,
+	/*!< Recording Device 3    */
+	CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3     = 9,
+	/*!< Tuner 4               */
+	CEC_LOGICAL_ADDRESS_TUNER_4                = 10,
+	/*!< Playback Device 3     */
+	CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3      = 11,
+	/*!< Reserved              */
+	CEC_LOGICAL_ADDRESS_RESERVED1              = 12,
+	/*!< Reserved              */
+	CEC_LOGICAL_ADDRESS_RESERVED2              = 13,
+	/*!< Specific Use          */
+	CEC_LOGICAL_ADDRESS_SPECIFIC_USE           = 14,
+	/*!< Unregistred/Broadcast */
+	CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST  = 15
+} dl_hdmi_ceclogical_address_t;
+
+/*!
+ *   \enum  dlHdmiCecEvent_t
+ *   \brief Enum listing all events that can be signalled to application
+ * */
+typedef enum {
+	/**< A message is available on CEC line */
+	DL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE = 0,
+	DL_HDMICEC_CALLBACK_STATUS = 1,             /**< Status of CEC line */
+} dl_hdmi_cec_event_t;
+
+/*!
+ *   \enum  dlHdmiCecEventStatus_t
+ *   \brief Enum listing all available event status
+ * */
+typedef enum {
+	DL_HDMICEC_EVENT_ENABLED,      /*!< Event is enabled  */
+	DL_HDMICEC_EVENT_DISABLED      /*!< Event is disabled */
+} dl_hdmi_cec_event_status_t;
+
+/**
+ * \brief System function pointer type, to call user I2C read/write functions
+ * \param slaveAddr     The I2C slave address
+ * \param firstRegister The first device register address to read or write
+ * \param lenData       Length of data to read or write (i.e. no. of registers)
+ * \param pData         Pointer to data to write, or to buffer to receive data
+ * \return              The call result:
+ *                      - 0: the call was successful
+ *                      - ERR_HDMI_I2C_WRITE: failed when writing
+ *                      - ERR_HDMI_I2C_READ:  failed when reading
+ * */
+typedef struct {
+	u8 slave_addr;
+	u8 first_register;
+	u8 len_data;
+	u8 *p_data;
+} dl_hdmi_cec_sys_args_t;
+typedef u32 (*ptmdl_hdmi_cec_sys_func_t)(dl_hdmi_cec_sys_args_t *p_sys_args);
+
+/*!
+ *   \brief Timer function pointer type, to call an application timer
+ *   \param Parameter ms: Delay in milliseconds required
+ * */
+typedef void(*ptmbsl_hdmi_cec_sys_func_timer_t)(u16 ms);
+
+/*!
+ *   \brief Callback function pointer type, used to allow driver to callback
+ *          application when activity status is changing at input.
+ *   \param Event Identifier of the source event.
+ * */
+typedef void (*ptmdl_hdmi_cec_callback_func_t)(dl_hdmi_cec_event_t event,
+        u8           *pdata,
+        u8           size);
+
+/*!
+ *   \brief Enum listing all supported device versions
+ * */
+typedef enum {
+	DL_HDMICEC_DEVICE_UNKNOWN, /*!< HW device is unknown   */
+	DL_HDMICEC_DEVICE_TDA9950, /*!< HW device is a TDA9950 */
+	DL_HDMICEC_DEVICE_TDA9989, /*!< HW device is a TDA9989 */
+} dl_hdmi_cec_device_version_t;
+
+/*!
+ *   \brief Enum listing possible CEC clock source
+ * */
+typedef enum {
+	DL_HDMICEC_CLOCK_XTAL,
+	DL_HDMICEC_CLOCK_FRO,
+	DL_HDMICEC_CLOCK_PCLK
+} dl_hdmi_cec_clock_source_t;
+
+/**
+ * \brief Structure describing unit capabilities
+ * */
+typedef struct {
+	/*!< HW device version                        */
+	dl_hdmi_cec_device_version_t device_version;
+	/*!< Supported HDMI CEC standard version      */
+	dl_hdmi_cecversion_t       hdmi_cec_version;
+} dl_hdmi_cec_capabilities_t;
+
+/*!
+ *	\struct dlHdmiCECInstanceSetup_t
+ *    \brief  This struct is used to setup CEC driver by application
+ *            Application setup the device and state of the device.
+ * */
+
+typedef struct _tmdl_hdmi_cec_instance_setup_t {
+	dl_hdmi_ceclogical_address_t device_logical_address;
+	dl_hdmi_cec_clock_source_t    cec_clock_source;
+	/*  dlHdmiCECDeviceState_t    DeviceState; */
+} dl_hdmi_cec_instance_setup_t, *ptmdl_hdmi_cec_instance_setup_t;
+
+/**
+ * \brief The structure of a CEC Data Register Protocol
+ * */
+typedef struct {
+	u8 address_byte;
+	/* Indicate if it's a poolling message "1" or a normal CEC message "0" */
+	bool  message_type_polling;
+	u8 opcode;
+} dl_hdmi_cec_save_message_t;
+
+typedef struct {
+	u8 frame_byte_count;
+	u8 address_byte;
+	u8 data_bytes[15];
+} dl_hdmi_cec_frame_format_t;
+
+#endif /* DLHDMICEC_TYPES_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
new file mode 100755
index 0000000..708552b
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC.c
@@ -0,0 +1,7969 @@
+/*============================================================================= */
+/* Copyright (C) 2007 NXP N.V., All Rights Reserved. */
+/* This source code and any compilation or derivative thereof is the proprietary */
+/* information of NXP N.V. and is confidential in nature. Under no circumstances */
+/* is this software to be  exposed to or placed under an Open Source License of */
+/* any type without the expressed written permission of NXP N.V. */
+/*============================================================================= */
+/*!
+ *    \file    dlHdmiCEC.c
+ *
+ *    \version 1.0
+ *
+ *    \date    24/07/2007
+ *
+ *    \brief   devlib driver component API for the CEC features.
+ *
+ *    \section refs  Reference Documents
+ *             TDA998X Driver - tx - SCS.doc
+ *    \note    None.
+ *
+ *    HISTORY :
+ *    \verbatim
+ *     Date          Modified by CRPRNr  TASKNr  Maintenance description
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *     24/07/2007   |  F.G      |       |       | Creation.
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *    \endverbatim
+ * */
+/*========================================================================== */
+
+/*============================================================================*/
+/*                   FILE CONFIGURATION                                       */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STANDARD INCLUDE FILES                                   */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PROJECT INCLUDE FILES                                    */
+/*============================================================================*/
+#ifdef __LINUX_ARM_ARCH__
+#include <linux/kernel.h>
+#else
+#include <string.h>
+#include <stdio.h>
+#endif
+#include "tmdlHdmiCEC_IW.h"
+#include "tmdlHdmiCEC_cfg.h"
+#include "tmdlHdmiCEC.h"
+#include "tmdlHdmiCEC_local.h"
+
+/*============================================================================*/
+/*                   MACRO DEFINITIONS                                        */
+/*============================================================================*/
+#ifdef __LINUX_ARM_ARCH__
+#define DV_DBG_PRINT printk
+#else
+#define DV_DBG_PRINT printf
+#endif
+
+/*============================================================================*/
+/*                   TYPE DEFINITIONS                                         */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC VARIABLE DEFINITIONS                              */
+/*============================================================================*/
+dl_hdmi_cec_unit_config_t unit_table[MAX_UNITS] = {
+	{0, CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST, false, DL_HDMICEC_DEVICE_TDA9950, CEC_STATE_NOT_INITIALIZED, 0}
+};
+
+dl_hdmi_cec_driver_config_table_t gtmdl_hdmi_cec_driver_config_table[MAX_UNITS];
+
+dl_hdmi_cec_save_message_t gtmdl_hdmi_cec_driver_save_message;
+
+/*============================================================================*/
+/*                   STATIC CONSTANT DECLARATIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STATIC VARIABLE DECLARATIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DECLARATIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                              FUNCTIONS                                     */
+/*============================================================================*/
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetSWVersion( )
+ *    \brief Get the software version of the driver.
+ *
+ *    \param pSWVersion Pointer to the version structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_swversion
+(
+    swversion_t  *p_swversion
+)
+{
+	/* check that input pointer is not NULL */
+	RETIF(p_swversion == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* copy SW version */
+	p_swversion->compatibility_nr = VERSION_COMPATIBILITY;
+	p_swversion->major_version_nr  = VERSION_MAJOR;
+	p_swversion->minor_version_nr  = VERSION_MINOR;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetNumberOfUnits( )
+ *    \brief Get the number of available CEC devices in the system.
+ *           A unit directly represents a physical device.
+ *
+ *    \param pUnitCount Pointer to the number of available units.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_number_of_units
+(
+    u32  *p_unit_count
+)
+{
+	/* check that input pointer is not NULL */
+	RETIF(p_unit_count == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* copy the maximum number of units */
+	*p_unit_count = MAX_UNITS;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetInstanceSetup( )
+ *    \brief Get instance setup parameters.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure that will receive setup
+ *                      parameters
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_instance_setup
+(
+    instance_t                instance,
+    ptmdl_hdmi_cec_instance_setup_t p_setup_info
+)
+{
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_setup_info == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_setup_info->device_logical_address  = unit_table[instance].device_logical_address;
+
+	return(0);
+}
+
+/*=========================	================================================= */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecHandleInterrupt( )
+ *    \brief Make device library handle an incoming interrupt. This function is
+ *           used by application to tell the device library that the hardware
+ *           sent an interrupt. It can also be used to poll the interrupt status
+ *           of the device if the interrupt line is not physically connected to
+ *           the CPU.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_FULL: the queue is full
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_handle_interrupt
+(
+    instance_t    instance
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_read_buffer[19] ;   /* I2C Read data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	/* Pointer to Cec Object */
+	dl_hdmi_cec_unit_config_t        *p_cec_object;
+	dl_hdmi_cec_frame_format_t  read_frame;
+	dl_hdmi_cec_save_message_t  last_send_message;
+	int i;
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+	p_cec_object = &unit_table[instance];
+
+#ifdef TMFL_TDA9989
+	/*Check if pending CEC interruption */
+	err = get_cec_hw_registers(p_dis, E_REG_CEC_INT, i2c_read_buffer, 1);
+	RETIF(err != 0, err)
+
+	if((i2c_read_buffer[0] & CEC_INT_MASK) == 0x00) {
+		/*No CEC interruption pending. */
+		return 0;
+	}
+#endif
+
+	err = get_cec_hw_registers(p_dis, E_REG_CDR0, i2c_read_buffer, 19);
+	RETIF(err != 0, err)
+
+	/*Fill Frame structure with read data*/
+
+	/* Case of Receiving CECData.cnf*/
+	/*Inform Success or reason of failure of CEC message sending*/
+	if(i2c_read_buffer[1] == 0x01) {
+		/* Get Infos of last message send */
+		get_cec_last_message(&last_send_message);
+
+		if(last_send_message.message_type_polling) {
+			read_frame.frame_byte_count = i2c_read_buffer[0];
+			read_frame.address_byte = last_send_message.address_byte;
+			read_frame.data_bytes[0] = i2c_read_buffer[2];
+		} else {
+			read_frame.frame_byte_count = i2c_read_buffer[0] + 1;
+			read_frame.address_byte = last_send_message.address_byte;
+			read_frame.data_bytes[0] = i2c_read_buffer[2];
+			read_frame.data_bytes[1] = last_send_message.opcode;
+		}
+
+		p_cec_object->message_callback(DL_HDMICEC_CALLBACK_STATUS
+		                               , (void *) &read_frame, read_frame.frame_byte_count);
+	}
+
+	/* Case of Receiving CECData.ind*/
+	/*Give receive data from CEC bus*/
+	if(i2c_read_buffer[1] == 0x81) {
+		read_frame.frame_byte_count = i2c_read_buffer[0];
+		read_frame.address_byte = i2c_read_buffer[2];
+		for(i = 0; i < 15; i++) {
+			read_frame.data_bytes[i] = i2c_read_buffer[i+3];
+		}
+
+		p_cec_object->message_callback(DL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE
+		                               , (void *) &read_frame, read_frame.frame_byte_count);
+	}
+
+	return(0);
+
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecOpen( )
+ *    \brief Open unit 0 of CEC and provides the instance number to
+ *           the caller. Note that one unit of CEC represents one physical
+ *           CEC device and that only one instance per unit can be opened.
+ *
+ *    \param pInstance Pointer to the variable that will receive the instance
+ *                     identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMICEC_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMICEC_INVALID_STATE: the state is invalid for
+ *              the function
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_open
+(
+    instance_t   *p_instance
+)
+{
+	/* directly call OpenM function for unit 0 and return the result */
+	return(dl_hdmi_cec_open_m(p_instance, (unit_select_t)0));
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecOpenM( )
+ *    \brief Open a specific unit of CEC driver and provides the instance
+ *           number to the caller. Note that one unit of CEC represents one
+ *           physical CEC device and that only one instance per unit can be
+ *           opened. This function switches driver's state machine to
+ *           "initialized" state.
+ *
+ *    \param pInstance Pointer to the structure that will receive the instance
+ *                     identifier.
+ *    \param unit      Unit number to be opened.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMICEC_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMICEC_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_open_m
+(
+    instance_t   *p_instance,
+    unit_select_t  unit
+)
+{
+
+	/* check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMICEC_BAD_UNIT_NUMBER)
+
+	/* check if Instance pointer is NULL */
+	RETIF(p_instance == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* check if unit is already instanciated */
+	RETIF(unit_table[unit].opened == true, ERR_DLHDMICEC_RESOURCE_OWNED)
+
+	/* Ckeck the state */
+	RETIF(unit_table[unit].state != CEC_STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE)
+
+	/* instanciate unit and return corresponding instance number */
+	/* Since HW unit are only instanciable once, instance = unit */
+	unit_table[unit].opened           = true;
+	unit_table[unit].message_callback = NULL;
+	/* Give a logical Address to Device */
+	unit_table[unit].device_logical_address = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+
+	/* Recover the configuration of the device library */
+	RETIF(dl_hdmi_cec_cfg_get_config(unit, &gtmdl_hdmi_cec_driver_config_table[unit]) != 0, ERR_DLHDMICEC_INIT_FAILED)
+
+	*p_instance = (instance_t)unit;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecClose( )
+ *    \brief Close an instance of CEC driver.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_close
+(
+    instance_t   instance
+)
+{
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* close instance */
+	unit_table[instance].opened = false;
+	unit_table[instance].state = CEC_STATE_NOT_INITIALIZED;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecInstanceConfig( )
+ *    \brief Set the configuration of instance attributes. This function is
+ *           required by DVP architecture rules but actually does nothing in this
+ *           driver
+ *
+ *    \param instance    Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_instance_config
+(
+    instance_t    instance
+)
+{
+	if(instance);
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecInstanceSetup( )
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration for CEC Stack Processor.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_instance_setup
+(
+    instance_t               instance,
+    dl_hdmi_cec_instance_setup_t *p_setup_info
+)
+{
+	error_code_t                  err;
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+#ifdef TMFL_TDA9989
+	unsigned char               i2c_read_buffer[1];
+#endif
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_setup_info == NULL, ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* Ckeck the state */
+	RETIF(unit_table[instance].state != CEC_STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Wait for 250 ms */
+	RETIF((err = tx_iwwait(500)) != 0, err)
+
+#ifdef TMFL_TDA9989
+	/* Enable CEC Stack Processor */
+	err = get_cec_hw_registers(p_dis, E_REG_CDR0, i2c_read_buffer, 1);
+	RETIF(err != 0, err)
+
+	err = get_cec_hw_registers(p_dis, E_REG_ENAMODS, i2c_read_buffer, 1);
+	RETIF(err != 0, err)
+
+	i2c_read_buffer[0] |= DEFAULT_ENAMODS;
+
+	err = set_cec_hw_register(p_dis, E_REG_ENAMODS, i2c_read_buffer[0]);
+	if(err != 0) {
+		/*TODO WA still needed? */
+		err = set_cec_hw_register(p_dis, E_REG_ENAMODS, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+	}
+
+	RETIF((err = tx_iwwait(TDA9950_RESET_DELAY_MS)) != 0, err)
+
+	/* Select CEC clock source and divider value */
+
+	if(p_setup_info->cec_clock_source == DL_HDMICEC_CLOCK_XTAL) {
+		err = get_cec_hw_registers(p_dis, E_REG_CEC_CLK, i2c_read_buffer, 1);
+		RETIF(err != 0, err)
+
+		i2c_read_buffer[0] &= CEC_CLK_SEL;
+		err = set_cec_hw_register(p_dis, E_REG_CEC_CLK, i2c_read_buffer[0]);
+	}
+
+	RETIF((err = tx_iwwait(TDA9950_RESET_DELAY_MS)) != 0, err)
+
+	/*TODO WA to avoid spurious interrupts */
+	err = get_cec_hw_registers(p_dis, E_REG_CDR0, i2c_read_buffer, 1);
+	RETIF(err != 0, err)
+#endif
+
+	/* Reset CEC Stack Processor */
+	err = set_cec_hw_register(p_dis, E_REG_CCR, 0x80);
+	RETIF(err != 0, err)
+
+	/* Wait for 250 ms */
+	RETIF((err = tx_iwwait(TDA9950_RESET_DELAY_MS)) != 0, err)
+
+	/* Configure Stack Processor (Retry = 5)*/
+	err = set_cec_hw_register(p_dis, E_REG_CCONR, 0x05);
+	RETIF(err != 0, err)
+
+	unit_table[instance].device_logical_address = p_setup_info->device_logical_address;
+
+	/* CEC Control register */
+	err = set_cec_hw_register_msb_lsb(p_dis, E_REG_ACKH, 0x1 << (unit_table[instance].device_logical_address));
+	RETIF(err != 0, err)
+
+	/* CEC Stack Processor enable*/
+	err = set_cec_hw_register(p_dis, E_REG_CCR, 0x40);
+	RETIF(err != 0, err)
+
+	/* switch instance to its new state */
+	unit_table[instance].state = CEC_STATE_CONFIGURED;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRegisterCallback( )
+ *    \brief Register event callbacks. Three types of callbacks can be
+ *           registered : input activity related callback, data related
+ *           callback (infoframes, packets, etc.) and general information
+ *           callback. A null pointer means that no callback are registered.
+ *
+ *    \param instance                 Instance identifier.
+ *    \param MessageCallback         Pointer to the callback function that will
+ *                                    handle message related events.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_register_callbacks
+(
+    instance_t               instance,
+    ptmdl_hdmi_cec_callback_func_t message_callback
+)
+{
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	/* store callback pointers */
+	unit_table[instance].message_callback  = message_callback;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetLogicalAddress( )
+ *    \brief Set Device Logical Address
+ *
+ *    \param instance      Instance identifier.
+ *    \param LogicalAddress Logical address value.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_logical_address
+(
+    instance_t   instance,
+    dl_hdmi_ceclogical_address_t   logical_address
+)
+{
+	error_code_t                  err;
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* Ckeck the state */
+	RETIF(unit_table[instance].state != CEC_STATE_CONFIGURED, ERR_DLHDMICEC_INVALID_STATE)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	unit_table[instance].device_logical_address = logical_address;
+
+	err = set_cec_hw_register_msb_lsb(p_dis, E_REG_ACKH, 0x1 << (unit_table[instance].device_logical_address));
+	RETIF(err != 0, err)
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetRetry( )
+ *    \brief Change the number of retransmission
+ *
+ *    \param instance Instance identifier.
+ *    \param NbRetry Number of retry.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_retry
+(
+    instance_t   instance,
+    u8   nb_retry
+)
+{
+	error_code_t                  err;
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* Ckeck the state */
+	RETIF(unit_table[instance].state != CEC_STATE_CONFIGURED, ERR_DLHDMICEC_INVALID_STATE)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Configure Retry register */
+	err = set_cec_hw_register(p_dis, E_REG_CCONR, nb_retry);
+	RETIF(err != 0, err)
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t getCecLastMessage( )
+ *    \brief Return the Addresses and the Opcode of the last CEC
+ *	       transmitted message
+ *
+ *    \param pSaveMessage   Pointer to the CEC Save Message
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t get_cec_last_message
+(
+    dl_hdmi_cec_save_message_t  *p_save_message
+)
+{
+	/* copy Last CEC message datas */
+	p_save_message->address_byte  = gtmdl_hdmi_cec_driver_save_message.address_byte;
+	p_save_message->message_type_polling = gtmdl_hdmi_cec_driver_save_message.message_type_polling;
+	p_save_message->opcode  = gtmdl_hdmi_cec_driver_save_message.opcode;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecImageViewOn( )
+ *    \brief This message sent by a source device to the TV whenever it enters
+ *           the active state
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receivers. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_image_view_on
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C Write data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	/*RETIF(UnitTable[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED) */
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Image View On command */
+
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_IMAGE_VIEW_ON ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecInactiveSource( )
+ *    \brief This message is used by the currently active source to inform the
+ *           TV that it has no video to be presented to the user, or is going
+ *           into standby as the result of a lcoal user command on the device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress, \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Physical Address of the device. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_inactive_source
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecexternal_physical_address_t  physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+	/*======To do : make a prepare message function with parameter */
+	/* Inactive source command */
+	i2c_buffer[0] = 0x06;
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_INACTIVE_SOURCE ;  /* Inactive Source*/
+	/* MsByte of Physical Address */
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecActiveSource()
+ *    \brief This message is used by a new source to indicate that it has started
+ *           to transmit a stream OR used in reponse to a <Request Active Source>
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_active_source
+(
+    instance_t   instance,
+    u16         physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Active Source command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_ACTIVE_SOURCE ;        /* Active source */
+	/* MsByte of Physical Address */
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecVersion()
+ *    \brief This message is used to indicate the supported CEC version in response
+ *           to a <Get CEC Version>
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress\n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECVersion_t CECVersion \n
+ *           Supported CEC Version.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_version
+(
+    instance_t         instance,
+    u8                receiver_logical_address,
+    dl_hdmi_cecversion_t cecversion
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* CEC Version command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_CEC_VERSION ;  /* CECVersion*/
+	i2c_buffer[4] = cecversion;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecClearAnalogueTimer( )
+ *    \brief This message is used to clear an Analogue timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_analogue_timer
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    u8                               day_of_month,
+    u8                               month_of_year,
+    u16                              start_time,
+    dl_hdmi_cecduration_t              *p_duration,
+    u8                               recording_sequence,
+    dl_hdmi_cecanalogue_broadcast_type_t  analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t        broadcast_system
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[15] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Clear Analogue Timer command */
+	i2c_buffer[0] = 0x0f;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_CLEAR_ANALOGUE_TIMER ;
+	i2c_buffer[4] = day_of_month;                       /*Day of Month*/
+	i2c_buffer[5] = month_of_year;                      /*Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);  /*Start Time*/
+	i2c_buffer[7] = (u8)start_time;
+	i2c_buffer[8] = p_duration -> hours;               /*Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;              /*Duration minute*/
+	i2c_buffer[10] = recording_sequence;               /*Recording Sequence*/
+	/*Analogue Broadcast Type*/
+	i2c_buffer[11] = analogue_broadcast_type;
+	/*Analogue Frequency*/
+	i2c_buffer[12] = (unsigned char)(analogue_frequency >> 8);
+	i2c_buffer[13] = (unsigned char)analogue_frequency;
+	i2c_buffer[14] = broadcast_system;                 /*BroadcastSystem*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 15);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecClearDigitalTimer( )
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_digital_timer
+(
+    instance_t                               instance,
+    u8                                      receiver_logical_address,
+    u8                                      day_of_month,
+    u8                                      month_of_year,
+    u16                                     start_time,
+    dl_hdmi_cecduration_t                     *p_duration,
+    u8                                      recording_sequence,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[18] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cecarib_data_t *p_arib_pointer;
+	dl_hdmi_cecatsc_data_t *p_atsc_pointer;
+	dl_hdmi_cecdvb_data_t  *p_dvb_pointer;
+
+	unsigned char regval;                 /* Local variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Clear Digital Timer command */
+	i2c_buffer[0] = 0x12;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_CLEAR_DIGITAL_TIMER ;
+	i2c_buffer[4] = day_of_month;                       /*Day of Month*/
+	i2c_buffer[5] = month_of_year;                      /*Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);  /*Start Time*/
+	i2c_buffer[7] = (u8)start_time;
+	i2c_buffer[8] = p_duration -> hours;               /*Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;              /*Durantion Minute*/
+	i2c_buffer[10] = recording_sequence;               /*Recording Sequence*/
+
+	/* Digital service Identification*/
+	/*Merge Service Method and Digital Broadcast System in the same Byte*/
+	/*bit 7 is Service Method*/
+	regval = (unsigned char)(p_service_identification->service_identification_method & 0x01);
+	regval = regval << 7;
+	/*bits 6 to 0 are Digital Broadcast*/
+	regval |= (unsigned char)(p_service_identification->digital_broadcast_system & 0x7F);
+	i2c_buffer[11] = regval;
+
+	/*Case of a ARIB Generic*/
+	if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC) {
+		p_arib_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_arib_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_arib_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_arib_pointer->service_id >> 8);
+		i2c_buffer[15] = (unsigned char)p_arib_pointer->service_id;
+		i2c_buffer[16] = (unsigned char)(p_arib_pointer->original_network_id >> 8);
+		i2c_buffer[17] = (unsigned char)p_arib_pointer->original_network_id;
+
+	}
+	/*Case of a ATSC Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC) {
+		p_atsc_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_atsc_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_atsc_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_atsc_pointer->program_number >> 8);
+		i2c_buffer[15] = (unsigned char)p_atsc_pointer->program_number;
+		i2c_buffer[16] = (unsigned char)(p_atsc_pointer->reserved >> 8);
+		i2c_buffer[17] = (unsigned char)p_atsc_pointer->reserved;
+	}
+	/*Case of a DVB Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC) {
+		p_dvb_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_dvb_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_dvb_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_dvb_pointer->service_id >> 8);
+		i2c_buffer[15] = (unsigned char)p_dvb_pointer->service_id;
+		i2c_buffer[16] = (unsigned char)(p_dvb_pointer->original_network_id >> 8);
+		i2c_buffer[17] = (unsigned char)p_dvb_pointer->original_network_id;
+	}
+	/*other cases, Buffer are empty*/
+	else {
+		i2c_buffer[12] = 0xFF;
+		i2c_buffer[13] = 0xFF;
+		i2c_buffer[14] = 0xFF;
+		i2c_buffer[15] = 0xFF;
+		i2c_buffer[16] = 0xFF;
+		i2c_buffer[17] = 0xFF;
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 18);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecClearExternalTimerWithExternalPlug( )
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_external_timer_with_external_plug
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    u8                       day_of_month,
+    u8                       month_of_year,
+    u16                      start_time,
+    dl_hdmi_cecduration_t      *p_duration,
+    u8                       recording_sequence,
+    dl_hdmi_cecexternal_plug_t   external_plug
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[13] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/* RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Clear External Timer with External Plug Command*/
+	i2c_buffer[0] = 0x0D;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_CLEAR_EXTERNAL_TIMER ;
+	i2c_buffer[4] = day_of_month;                       /*Day of Month*/
+	i2c_buffer[5] = month_of_year;                      /*Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);  /*Start Time*/
+	i2c_buffer[7] = (unsigned char)start_time;
+	i2c_buffer[8] = p_duration -> hours;               /*Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;              /*Duration minute*/
+	i2c_buffer[10] = recording_sequence;               /*Recording Sequence*/
+	/*External Source Specifier = External Plug */
+	i2c_buffer[11] = CEC_EXTERNAL_PLUG;
+	i2c_buffer[12] = external_plug;                    /*External Plug*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 13);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecClearExternalTimerWithPhysicalAddress( )
+ *    \brief This message is used to clear a digital timer block of a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_clear_external_timer_with_physical_address
+(
+    instance_t                           instance,
+    u8                                  receiver_logical_address,
+    u8                                  day_of_month,
+    u8                                  month_of_year,
+    u16                                 start_time,
+    dl_hdmi_cecduration_t                 *p_duration,
+    u8                                  recording_sequence,
+    dl_hdmi_cecexternal_physical_address_t   external_physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[14] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Clear External Timer with Physical Address Command */
+	i2c_buffer[0] = 0x0E;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/*Clear External Timer*/
+	i2c_buffer[3] = CEC_OPCODE_CLEAR_EXTERNAL_TIMER ;
+	/*Day of Month*/
+	i2c_buffer[4] = day_of_month;
+	/*Month of Year*/
+	i2c_buffer[5] = month_of_year;
+	/*Start Time*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);
+	i2c_buffer[7] = (unsigned char)start_time;
+	/*Duration Hours*/
+	i2c_buffer[8] = p_duration -> hours;
+	/*Duration Minute*/
+	i2c_buffer[9] = p_duration -> minute;
+	/*Recording Sequence*/
+	i2c_buffer[10] = recording_sequence;
+	/*External Source Specifier = External Address*/
+	i2c_buffer[11] = CEC_EXTERNAL_PHYSICAL_ADDRESS;
+	/*External Address*/
+	i2c_buffer[12] = (unsigned char)(external_physical_address >> 8);
+	i2c_buffer[13] = (unsigned char)external_physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 14);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTextViewOn( )
+ *    \brief This message as <Image View On>, but should also remove any text,
+ *           menus and PIP windows from the TV's display
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_text_view_on
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to Instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if Instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Text View On command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_TEXT_VIEW_ON ;     /* Text View On */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTimerClearedStatus( )
+ *    \brief This message is used to give the status of a <Cleared Analogue Timer>,
+ *           <Clear Digital Timer> or <Clear External Timer> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECTimerClearedStatusData_t TimerClearedStatusData \n
+ *           Indicates if the timer was cleared successfully. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_timer_cleared_status
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    dl_hdmi_cectimer_cleared_status_data_t timer_cleared_status_data
+)
+{
+
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Timer Clear Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_TIMER_CLEARED_STATUS;  /* System Audio Status*/
+	/* Timer Cleared Status*/
+	i2c_buffer[4] = timer_cleared_status_data;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTimerStatus( )
+ *    \brief This message is used to send timer status to the initiator of a
+ *           <Set Timer> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECTimerStatusData_t *pTimerStatusData \n
+ *           Pointer on the Timer status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_timer_status
+(
+    instance_t                 instance,
+    u8                        receiver_logical_address,
+    dl_hdmi_cectimer_status_data_t *p_timer_status_data
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cectimer_programmed_info_t *p_timer_prog_info;
+	unsigned char regval;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Timer Status command */
+	i2c_buffer[0] = 0x07;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_TIMER_CLEARED_STATUS;  /* System Audio Status*/
+	/* First Byte Building */
+	/* bit 7 for Timer Overlap Warning */
+	regval = ((unsigned char)(p_timer_status_data->timer_overlap_warning) & 0x01) << 7 ;
+	/* bit 6 to 5 for Media Info */
+	regval |= ((unsigned char)(p_timer_status_data->media_info) & 0x03) << 5;
+
+	p_timer_prog_info = &(p_timer_status_data->timer_programmed_info);
+	/* bit 4 for Timer Programed Indicator */
+	regval |= ((unsigned char)(p_timer_prog_info->select_program_info) & 0x01) << 4;
+	/* bit 3 to 0 for Program Information */
+	regval |= (unsigned char)(p_timer_prog_info->program_info) & 0x0F;
+	i2c_buffer[4] = regval;
+
+	/* 2 Duration Available Bytes Building */
+	/* Duration Available is only filled in the the both following conditions*/
+	if((p_timer_prog_info->select_program_info == CEC_PROGRAM_INDICATOR_NOT_PROGRAMMED) && (p_timer_prog_info->program_info == CEC_PROGRAM_ERROR_INFO_DUPLICATE_ALREADY_PROGRAMMED)) {
+		i2c_buffer[5] = (unsigned char)(p_timer_prog_info->duration_available >> 8);
+		i2c_buffer[6] = (unsigned char)p_timer_prog_info->duration_available;
+	} else if((p_timer_prog_info->select_program_info == CEC_PROGRAM_INDICATOR_PROGRAMMED) && (p_timer_prog_info->program_info == CEC_PROGRAM_INFO_NOT_ENOUGHT_SPACE_AVAILABLE_FOR_RECORDING)) {
+		i2c_buffer[5] = (unsigned char)(p_timer_prog_info->duration_available >> 8);
+		i2c_buffer[6] = (unsigned char)p_timer_prog_info->duration_available;
+	}
+	/*Else, 2 bytes of Duration Available are filled with 0xFF*/
+	else {
+		i2c_buffer[5] = 0xFF;
+		i2c_buffer[6] = 0xFF;
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTunerDeviceStatusAnalogue( )
+ *    \brief This message is used by a tuner device to provide its status to the
+ *           initiator of the <Give Tuner Device Status> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECRecordingFlag_t RecordingFlag \n
+ *           Indicates if the tuner is being used as a source of a recording. \n
+ *
+ *    \param dlHdmiCECTunerDisplayInfo_t TunerDisplayInfo \n
+ *           Indicates if the the device is currently deplaying its tuner or not. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_device_status_analogue
+(
+    instance_t                       instance,
+    u8                              receiver_logical_address,
+    dl_hdmi_cecrecording_flag_t         recording_flag,
+    dl_hdmi_cectuner_display_info_t      tuner_display_info,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                             analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[9] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	unsigned char regval;                 /*Local Variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Select Aanalogue Service command */
+	i2c_buffer[0] = 0x09;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Tuner Device Status*/
+	i2c_buffer[3] = CEC_OPCODE_TUNER_DEVICE_STATUS ;
+	/* Build First Byte*/
+	/*bit 7 is Recording Flag */
+	regval = ((unsigned char)recording_flag & 0X01) << 7;
+	/*bit 6 to 0 are Tuner display Info*/
+	regval |= (unsigned char)tuner_display_info & 0X7F;
+	i2c_buffer[4] = regval;
+
+	/*Analogue Broadcast System type*/
+	i2c_buffer[5] = analogue_broadcast_type;
+	/*Analogue Frequency*/
+	i2c_buffer[6] = (unsigned char)(analogue_frequency >> 8);
+	i2c_buffer[7] = (unsigned char)analogue_frequency;
+	/*Broadcast System*/
+	i2c_buffer[8] = broadcast_system;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 9);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTunerDeviceStatusDigital( )
+ *    \brief This message is used by a tuner device to provide its status to the
+ *           initiator of the <Give Tuner Device Status> message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECRecordingFlag_t RecordingFlag \n
+ *           Indicates if the tuner is being used as a source of a recording. \n
+ *
+ *    \param dlHdmiCECTunerDisplayInfo_t TunerDisplayInfo \n
+ *           Indicates if the the device is currently deplaying its tuner or not. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_device_status_digital
+(
+    instance_t                               instance,
+    u8                                      receiver_logical_address,
+    dl_hdmi_cecrecording_flag_t                 recording_flag,
+    dl_hdmi_cectuner_display_info_t              tuner_display_info,
+    ptmdl_hdmi_cecdigital_service_identification_t p_service_identification
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[12] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cecarib_data_t *p_arib_pointer;
+	dl_hdmi_cecatsc_data_t *p_atsc_pointer;
+	dl_hdmi_cecdvb_data_t  *p_dvb_pointer;
+
+	unsigned char regval;                 /* Local variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record On Digital Service command */
+	i2c_buffer[0] = 0x0C;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Tuner Device Status*/
+	i2c_buffer[3] = CEC_OPCODE_TUNER_DEVICE_STATUS ;
+
+	/* Merge Recording Flag With Tuner Display Info*/
+	/* bit 7 is Recording Flag*/
+	regval = ((unsigned char)recording_flag & 0X01) << 7;
+	/* bit 6 to 0 are Tuner display Info*/
+	regval |= (unsigned char)tuner_display_info & 0X7F;
+	i2c_buffer[4] = regval;
+
+	/* Digital service Identification*/
+	/*Merge Service Method and Digital Broadcast System in the same Byte*/
+	/* bit 7 is Service Method*/
+	regval = (unsigned char)(p_service_identification->service_identification_method & 0x01) << 7;
+	/* bits 6 to 0 are Digital Broadcast*/
+	regval |= (unsigned char)(p_service_identification->digital_broadcast_system & 0x7F);
+	i2c_buffer[5] = regval;
+
+	/*Case of a ARIB Generic*/
+	if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC) {
+		p_arib_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_arib_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_arib_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_arib_pointer->service_id >> 8);
+		i2c_buffer[9] = (unsigned char)p_arib_pointer->service_id;
+		i2c_buffer[10] = (unsigned char)(p_arib_pointer->original_network_id >> 8);
+		i2c_buffer[11] = (unsigned char)p_arib_pointer->original_network_id;
+	}
+	/*Case of a ATSC Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC) {
+		p_atsc_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_atsc_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_atsc_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_atsc_pointer->program_number >> 8);
+		i2c_buffer[9] = (unsigned char)p_atsc_pointer->program_number;
+		i2c_buffer[10] = (unsigned char)(p_atsc_pointer->reserved >> 8);
+		i2c_buffer[11] = (unsigned char)p_atsc_pointer->reserved;
+	}
+	/*Case of a DVB Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC) {
+		p_dvb_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_dvb_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_dvb_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_dvb_pointer->service_id >> 8);
+		i2c_buffer[9] = (unsigned char)p_dvb_pointer->service_id;
+		i2c_buffer[10] = (unsigned char)(p_dvb_pointer->original_network_id >> 8);
+		i2c_buffer[11] = (unsigned char)p_dvb_pointer->original_network_id;
+	}
+	/*other cases, Buffer are empty*/
+	else {
+		i2c_buffer[6] = 0xFF;
+		i2c_buffer[7] = 0xFF;
+		i2c_buffer[8] = 0xFF;
+		i2c_buffer[9] = 0xFF;
+		i2c_buffer[10] = 0xFF;
+		i2c_buffer[11] = 0xFF;
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 12);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestActiveSource( )
+ *    \brief This message is used by a new device to discover the status of
+ *           the system.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_Instance: the Instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_active_source
+(
+    instance_t  instance
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* IRequest Active Source command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Request Active Source */
+	i2c_buffer[3] = CEC_OPCODE_REQUEST_ACTIVE_SOURCE ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRoutingChange( )
+ *    \brief This message is sent by a CEC switch when it is manually switched to
+ *           inform all other devices on the network that the active route below
+ *           the switch has changed.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 OriginalAddress \n
+ *           Previous address that the switch was switched to. \n
+ *
+ *    \param u16 NewAddress \n
+ *           The new address it has been moved to. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_routing_change
+(
+    instance_t  instance,
+    u16        original_address,
+    u16        new_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[8] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Routing Change command */
+	i2c_buffer[0] = 0x08;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_ROUTING_CHANGE ;            /* Routing Change */
+	/* MsByte of Original Address*/
+	i2c_buffer[4] = (unsigned char)(original_address >> 8);
+	/* LsByte of Original Address */
+	i2c_buffer[5] = (unsigned char)original_address;
+	/* MsByte of New Address */
+	i2c_buffer[6] = (unsigned char)(new_address >> 8);
+	/* LsByte of New Address */
+	i2c_buffer[7] = (unsigned char)new_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 8);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRoutingInformation( )
+ *    \brief This message is sent by a CEC switch to indicate the active route
+ *           below the switch.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           The current active route to the sink in the CEC switch. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_routing_information
+(
+    instance_t  instance,
+    u16        physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Routing Information command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Routing Information */
+	i2c_buffer[3] = CEC_OPCODE_ROUTING_INFORMATION ;
+	/* MsByte of Physical Address*/
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSelectAnalogueService( )
+ *    \brief This message select directly an analogue TV Service.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_select_analogue_service
+(
+    instance_t                       instance,
+    u8                              receiver_logical_address,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                             analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[8] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Select Aanalogue Service command */
+	i2c_buffer[0] = 0x08;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Select Analogue Service*/
+	i2c_buffer[3] = CEC_OPCODE_SET_ANALOGUE_SERVICE ;
+	i2c_buffer[4] = analogue_broadcast_type;
+	i2c_buffer[5] = (unsigned char)(analogue_frequency >> 8);
+	i2c_buffer[6] = (unsigned char)analogue_frequency;
+	i2c_buffer[7] = broadcast_system;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 8);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetStreamPath( )
+ *    \brief This message is used by a TV to request a streaming path from
+ *           the specified physical address.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_stream_path
+(
+    instance_t  instance,
+    u16        physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set Stream Path command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Set Stream Path */
+	i2c_buffer[3] = CEC_OPCODE_SET_STREAM_PATH ;
+	/* MsByte of Physical Address*/
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetSystemAudioMode( )
+ *    \brief This message turn the system audio Mode ON or OFF.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECSystemAudioStatus_t SystemAudioStatus \n
+ *           Specifies if the system audio mode is ON or OFF.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_system_audio_mode
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecsystem_audio_status_t system_audio_status
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set System Audio Mode Command */
+	i2c_buffer[0] = 0x05;    /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Set System Audio Mode*/
+	i2c_buffer[3] = CEC_OPCODE_SET_SYSTEM_AUDIO_MODE ;
+	/*System Audio Status*/
+	i2c_buffer[4] = system_audio_status;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetTimerProgramTitle( )
+ *    \brief This message is used to set the name of a program associated
+ *           with a timer block.Sent directly after sending a
+ *           <Set analogue Timer> or <Set Digital Timer> message. The name
+ *           is then associated with that timer block.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param const char *pProgramTitleString \n
+ *           Pointer on the program title. \n
+ *
+ *    \param u8    ProgramTitleLength \n
+ *           Length of Program Title String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_timer_program_title
+(
+    instance_t instance,
+    u8        receiver_logical_address,
+    const char   *p_program_title_string,
+    u8        program_title_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Set Timer Program Title */
+	/* Calculate Message length*/
+	mess_length = program_title_length + 4;
+
+	i2c_buffer[0] = (unsigned char)mess_length;
+
+	/* Request CEC data */
+	i2c_buffer[1] = 0x00;
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Set Timer Program Title*/
+	i2c_buffer[3] = CEC_OPCODE_SET_TIMER_PROGRAM_TITLE ;
+
+	for(loci = 0; loci <= program_title_length ; loci++) {
+		/* Fill Table with Program Title characters*/
+		i2c_buffer[(loci+4)] = p_program_title_string[loci];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, (mess_length));
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecStandby( )
+ *    \brief This message switches one or all devices into standby mode.Can be
+ *           be used as a broadcast message o be addressed to a specific device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_standby
+(
+    instance_t instance,
+    u8        receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Standby command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_STANDBY ;      /* Standby */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSystemAudioModeRequest( )
+ *    \brief A device implementing System Audio Control and which has volume
+ *           control RC button(eg TV or STB) request to use System Audio Mode
+ *           to the amplifier.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Physical address of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_system_audio_mode_request
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u16        physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* System Audio Mode Request command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* System Audio Mode Request*/
+	i2c_buffer[3] = CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST ;
+	/* MsByte of Physical Address */
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSystemAudioModeStatus( )
+ *    \brief Reports the current status of the System Audio Mode.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECSystemAudioStatus_t SystemAudioStatus \n
+ *           Current system audio mode.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_system_audio_mode_status
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecsystem_audio_status_t system_audio_status
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* System Audio Mode Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* System Audio Mode Status*/
+	i2c_buffer[3] = CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS ;
+	/* System Audio Status*/
+	i2c_buffer[4] = system_audio_status;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveTunerDeviceStatus( )
+ *    \brief This message is used to request the status of a tuner device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECStatusRequest_t StatusRequest \n
+ *           Allows the initiator to request the status once or on all future state
+ *           change. Or to cancel a previous <Give Tuner Device Status > ["On"] request. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_tuner_device_status
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecstatus_request_t status_request
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* System Audio Mode Request command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Give Tuner Device Status*/
+	i2c_buffer[3] = CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS ;
+	i2c_buffer[4] = (unsigned char)status_request; /* Status Request */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordTvScreen( )
+ *    \brief This message request by the recording device to record the presently
+ *           displayed source.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_tv_screen
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record TV Sreen command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_TV_SCREEN ;     /* Record TV screen */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportAudioStatus( )
+ *    \brief This message report an amplifier's volume and mute.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECAudioStatus_t AudioStatus \n
+ *           Volume and mute status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_audio_status
+(
+    instance_t              instance,
+    u8                     receiver_logical_address,
+    ptmdl_hdmi_cecaudio_status_t p_audio_status
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char regval;                 /*Local Variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Report Audio Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_REPORT_AUDIO_STATUS ;  /* Report Audio Statust*/
+	/* bit 7 Mute Status*/
+	regval = (((unsigned char)p_audio_status -> audio_mute_status) & 0x01) << 7;
+	/* bit 6 to 0 Volum Status*/
+	regval |= ((unsigned char)p_audio_status -> audio_volume_status) & 0x7F;
+	i2c_buffer[4] = regval;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportShortAudioDescriptor( )
+ *    \brief This message Report Audio Capability.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u32 ShortAudioDecriptor \n
+ *           Audio Descriptor. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_short_audio_descriptor
+(
+    instance_t   instance,
+    u8          receiver_logical_address,
+    u32         short_audio_decriptor
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x07;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Report Audio Capability*/
+	i2c_buffer[3] = CEC_OPCODE_REPORT_SHORT_AUDIO_DESCRIPTOR ;
+	/* MSByte of ShortAudioDecriptor*/
+	i2c_buffer[4] = (unsigned char)(short_audio_decriptor >> 16);
+	i2c_buffer[5] = (unsigned char)(short_audio_decriptor >> 8);
+	/* LSByte of ShortAudioDecriptor*/
+	i2c_buffer[6] = (unsigned char)short_audio_decriptor;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestShortAudioDescriptor( )
+ *    \brief This message Request Audio Capability.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8 AudioFormatID \n
+ *
+ *    \param u8 AudioFormatCode \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_short_audio_descriptor
+(
+    instance_t   instance,
+    u8          receiver_logical_address,
+    u8          audio_format_id,
+    u8          audio_format_code
+
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char regval;                 /*Local Variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Request Audio Capability*/
+	i2c_buffer[3] = CEC_OPCODE_REQUEST_SHORT_AUDIO_DESCRIPTOR ;
+	/* bit 3 to 7  AudioFormatCode*/
+	regval = (((unsigned char)audio_format_code) & 0x3F) << 2;
+	/* bit 1 to 0 AudioFormatID*/
+	regval |= ((unsigned char)audio_format_id) & 0x03;
+	i2c_buffer[4] = regval;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecIniateARC( )
+ *    \brief This message Used by an ARC RX device to activate the
+ *           ARC functionality in an ARC TX device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_iniate_arc
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_INITATE_ARC ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportArcInitiated( )
+ *    \brief This message Used by an ARC TX device to indicate that
+ *           its ARC functionality has been activated
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_arc_initiated
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_REPORT_ARC_INITIATED ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportArcTerminated( )
+ *    \brief This message Used by an ARC TX device to indicate that its ARC functionality
+ *           has been deactivated.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_arc_terminated
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_REPORT_ARC_TERMINATED ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestArcInitiation( )
+ *    \brief This message Used by an ARC TX device to request an ARC RX device to
+ *           activate the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_arc_initiation
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_REPORT_ARC_INITIATION ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRequestArcTerminiation( )
+ *    \brief Used by an ARC TX device to request an ARC RX device to deactivate
+ *           the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_request_arc_terminiation
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_REPORT_ARC_TERMINATION ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTerminateARC( )
+ *    \brief Used by an ARC TX device to request an ARC RX device to deactivate
+ *           the ARC functionality in the ARC TX device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_terminate_arc
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Report Short Audio Decriptor */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_TERMINATE_ARC ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGivePhysicalAddress( )
+ *    \brief This message is a request to a device to return its physical Address
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_physical_address
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give physical Address command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Give Physical Address */
+	i2c_buffer[3] = CEC_OPCODE_GIVE_PHYSICAL_ADDRESS ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveSystemAudioModeStatus( )
+ *    \brief This message request the status of the system audio mode
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_system_audio_mode_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give System Audio Mode Status command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Give System Audio Mode Status*/
+	i2c_buffer[3] = CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetMenuLanguage( )
+ *    \brief This message is sent by a device capable of character generation
+ *           (for OSD and Menus) to a TV in order to discover the currently selected
+ *           Menu Language. Also used by a TV during installation to dicover the
+ *           currently set menu language of other devices.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_menu_language
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Get Menu Language command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Get Menu Address */
+	i2c_buffer[3] = CEC_OPCODE_GET_MENU_LANGUAGE ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveAudioStatus( )
+ *    \brief This message is requests an amplifier to send its volume and mute status
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_audio_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give Audio Mode Status command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_GIVE_AUDIO_STATUS ;    /* Message Abort*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecPollingMessage( )
+ *    \brief This message is used by any device for device discovery - similar to
+ *           ping in other protocols
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_polling_message
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[3] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Polling Message command */
+	i2c_buffer[0] = 0x03;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 3);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 1;
+	gtmdl_hdmi_cec_driver_save_message.opcode = 0;
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordStatus( )
+ *    \brief This message is used by a recording device to inform the initiator
+ *           of the message <Record On> about its status.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECRecordStatusInfo_t  RecordStatusInfo \n
+ *           The recording status of the device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_status
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecrecord_status_info_t  record_status_info
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_STATUS ;    /* Record Status */
+	i2c_buffer[4] = record_status_info; /* Record Status */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOff( )
+ *    \brief This message request a device to stop a recording
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_off
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record Off command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_OFF ;   /* Record Off */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOnAnalogueService( )
+ *    \brief This message attempt to record analogue source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_analogue_service
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    dl_hdmi_cecanalogue_broadcast_type_t  analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t        broadcast_system
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[9] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Record On Analogue Device command */
+	i2c_buffer[0] = 0x09;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_ON ;                     /*Record On*/
+
+	/*RecordSourceType = CEC_RECORD_SOURCE_ANALOGUE_SERVICE*/
+	i2c_buffer[4] = CEC_RECORD_SOURCE_ANALOGUE_SERVICE;
+	/*Analogue Brodcast Type*/
+	i2c_buffer[5] = analogue_broadcast_type;
+	/*Analogue Frequency*/
+	i2c_buffer[6] = (unsigned char)(analogue_frequency >> 8);
+	i2c_buffer[7] = (unsigned char)analogue_frequency;
+	/*Brodcast System*/
+	i2c_buffer[8] = broadcast_system;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 9);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOnDigitalService( )
+ *    \brief This message attempt to record digital source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_digital_service
+(
+    instance_t                              instance,
+    u8                                     receiver_logical_address,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[12] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cecarib_data_t *p_arib_pointer;
+	dl_hdmi_cecatsc_data_t *p_atsc_pointer;
+	dl_hdmi_cecdvb_data_t  *p_dvb_pointer;
+
+	unsigned char regval;                 /* Local variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record On Digital Service command */
+	i2c_buffer[0] = 0x0C;     /* Param number = 10*/
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Record On Digital Service*/
+	i2c_buffer[3] = CEC_OPCODE_RECORD_ON ;
+
+	/* RecordSourceType = CEC_RECORD_SOURCE_DIGITAL_SERVICE */
+	i2c_buffer[4] = CEC_RECORD_SOURCE_DIGITAL_SERVICE;
+
+	/* Digital Service Identification*/
+	/*Merge Service Method and Digital Broadcast System in the same Byte*/
+	/*bit 7 is Service Method*/
+	regval = (unsigned char)(p_service_identification->service_identification_method & 0x01);
+	regval = regval << 7;
+	/*bits 6 to 0 are Digital Broadcast*/
+	regval |= (unsigned char)(p_service_identification->digital_broadcast_system & 0x7F);
+	i2c_buffer[5] = regval;
+
+	/*Case of a ARIB Generic*/
+	if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC) {
+		p_arib_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_arib_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_arib_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_arib_pointer->service_id >> 8);
+		i2c_buffer[9] = (unsigned char)p_arib_pointer->service_id;
+		i2c_buffer[10] = (unsigned char)(p_arib_pointer->original_network_id >> 8);
+		i2c_buffer[11] = (unsigned char)p_arib_pointer->original_network_id;
+	}
+	/*Case of a ATSC Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC) {
+		p_atsc_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_atsc_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_atsc_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_atsc_pointer->program_number >> 8);
+		i2c_buffer[9] = (unsigned char)p_atsc_pointer->program_number;
+		i2c_buffer[10] = (unsigned char)(p_atsc_pointer->reserved >> 8);
+		i2c_buffer[11] = (unsigned char)p_atsc_pointer->reserved;
+	}
+	/*Case of a DVB Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC) {
+		p_dvb_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[6] = (unsigned char)(p_dvb_pointer->transport_stream_id >> 8);
+		i2c_buffer[7] = (unsigned char)p_dvb_pointer->transport_stream_id;
+		i2c_buffer[8] = (unsigned char)(p_dvb_pointer->service_id >> 8);
+		i2c_buffer[9] = (unsigned char)p_dvb_pointer->service_id;
+		i2c_buffer[10] = (unsigned char)(p_dvb_pointer->original_network_id >> 8);
+		i2c_buffer[11] = (unsigned char)p_dvb_pointer->original_network_id;
+	}
+	/*other cases, Buffer are empty*/
+	else {
+		i2c_buffer[6] = 0xFF;
+		i2c_buffer[7] = 0xFF;
+		i2c_buffer[8] = 0xFF;
+		i2c_buffer[9] = 0xFF;
+		i2c_buffer[10] = 0xFF;
+		i2c_buffer[11] = 0xFF;
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 12);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOnExternalPhysicalAddress( )
+ *    \brief This message attempt to record an external physical address source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_external_physical_address
+(
+    instance_t                         instance,
+    u8                                receiver_logical_address,
+    dl_hdmi_cecexternal_physical_address_t external_physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record On External Physial Address command */
+	i2c_buffer[0] = 0x07;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/*Record On*/
+	i2c_buffer[3] = CEC_OPCODE_RECORD_ON ;
+	/*RecordSourceType = CEC_RECORD_SOURCE_EXTERNAL_PHYSICAL_ADDRESS*/
+	i2c_buffer[4] = CEC_RECORD_SOURCE_EXTERNAL_PHYSICAL_ADDRESS;
+	/*External Physical Address*/
+	i2c_buffer[5] = (unsigned char)(external_physical_address >> 8);
+	i2c_buffer[6] = (unsigned char)external_physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOnExternalPlug( )
+ *    \brief This message attempt to record an external plug source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_external_plug
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address,
+    dl_hdmi_cecexternal_plug_t      external_plug
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record On External Plug command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_ON ;                   /* Record On*/
+
+	/* RecordSourceType = CEC_RECORD_SOURCE_EXTERNAL_PLUG*/
+	i2c_buffer[4] = CEC_RECORD_SOURCE_EXTERNAL_PLUG;
+	i2c_buffer[5] = external_plug;                            /*External Plug*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecRecordOnOwnSource( )
+ *    \brief This message attempt to record an external plug source
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8    ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_record_on_own_source
+(
+    instance_t                   instance,
+    u8                          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Record On Own Source command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_RECORD_ON ;                /* Record On*/
+
+	/* RecordSourceType = CEC_RECORD_SOURCE_OWN_SOURCE*/
+	i2c_buffer[4] = CEC_RECORD_SOURCE_OWN_SOURCE;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportPhysicalAddress( )
+ *    \brief This message is used to inform all other devices of the mapping
+ *           between physical and logical address of the initiator.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u16 PhysicalAddress \n
+ *           Device physical address within the cluster. \n
+ *
+ *    \param dlHdmiCECDeviceType_t DeviceType \n
+ *           Type of the device (TV, Playback, tuner,...). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_physical_address
+(
+    instance_t             instance,
+    u16                   physical_address,
+    dl_hdmi_cecdevice_type_t  device_type
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Report Physical Address command */
+	i2c_buffer[0] = 0x07;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Report Physical Address */
+	i2c_buffer[3] = CEC_OPCODE_REPORT_PHYSICAL_ADDRESS ;
+	/* MsByte of Physical Address*/
+	i2c_buffer[4] = (unsigned char)(physical_address >> 8);
+	/* LsByte of Physical Address */
+	i2c_buffer[5] = (unsigned char)physical_address;
+
+	i2c_buffer[6] = device_type ;                              /* Device Type*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetMenuLanguage( )
+ *    \brief This message is used by a TV or another device to indicate the menu
+ *           Language.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param const char *pLanguage \n
+ *           Pointer on the user's menu language choice. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_menu_language
+(
+    instance_t instance,
+    const char   *p_language
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/* RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set Menu Language command */
+	i2c_buffer[0] = 0x07;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Set Menu Language*/
+	i2c_buffer[3] = CEC_OPCODE_SET_MENU_LANGUAGE ;
+	i2c_buffer[4] = p_language[0];     /* First Tocken*/
+	i2c_buffer[5] = p_language[1];
+	i2c_buffer[6] = p_language[2];     /* Last Tocken*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecDeckControl()
+ *    \brief This message is used to conrol a device's media functions
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDecControlMode_t DeckControlMode \n
+ *           Used in message <Deck Control>\n
+ *
+ *    \note  The "Skip Forward / Wind" and "Skip Reverse / Rewind" values are
+ *           used for example in a DVD as next xhapter and previous chapter and
+ *           in a VCR as wind and rewind. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_deck_control
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    dl_hdmi_cecdec_control_mode_t deck_control_mode
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if Instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to Instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if Instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Deck Control command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_DESCK_CONTROL;     /* Deck Control Mode*/
+	i2c_buffer[4] = deck_control_mode;      /* Deck Control Value*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecDeckStatus()
+ *    \brief This message is used to provide a deck's status to the initiator
+ *           of the <Give Deck Status> message
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDecInfo_t DeckInfo \n
+ *           Information on the device's current status \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_deck_status
+(
+    instance_t         instance,
+    u8                receiver_logical_address,
+    dl_hdmi_cecdec_info_t deck_info
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Deck Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_DECK_STATUS;       /* Deck Status*/
+	i2c_buffer[4] = deck_info;     /* Deck Status Mode Information*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveDeckStatus( )
+ *    \brief This message is used to request the status of a device regardless
+ *           of whether or not it is the current active source.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECStatusRequest_t StatusRequest \n
+ *           Allows the initiator to request the status once or on all future state
+ *           change. Or to cancel a previous <Give Deck Status > ["On"] request. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_deck_status
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecstatus_request_t status_request
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if Instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give Deck Status command */
+	i2c_buffer[0] = 0x05;    /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_GIVE_DECK_STATUS;      /* Give Deck Status*/
+	i2c_buffer[4] = status_request;        /* Deck Status Request Information*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecPlay( )
+ *    \brief This message is used to control the playback behaviour of a source
+ *           device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPlayMode_t  PlayMode \n
+ *           In which mode to play media. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_play
+(
+    instance_t           instance,
+    u8                  receiver_logical_address,
+    dl_hdmi_cecplay_mode_t  play_mode
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Play command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_PLAY;  /* Play*/
+	/* Play Mode Information Information*/
+	i2c_buffer[4] = (unsigned char)play_mode;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSelectDigitalService( )
+ *    \brief This message select directly a digital TV, Radio or Data Broadcast
+ *           Service.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_select_digital_service
+(
+    instance_t                                instance,
+    u8                                       receiver_logical_address,
+    ptmdl_hdmi_cecdigital_service_identification_t  p_service_identification
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[11] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cecarib_data_t *p_arib_pointer;
+	dl_hdmi_cecatsc_data_t *p_atsc_pointer;
+	dl_hdmi_cecdvb_data_t  *p_dvb_pointer;
+
+	unsigned char regval;                 /*Local Variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Select Digital Service command */
+	i2c_buffer[0] = 0x0B;     /* Param number = 10*/
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Select Digital Service*/
+	i2c_buffer[3] = CEC_OPCODE_SET_DIGITAL_SERVICE ;
+
+	/*Merge Service Method and Digital Broadcast System in the same Byte*/
+	/* Load the 1 bit of Service Method*/
+	regval = (unsigned char)(p_service_identification->service_identification_method & 0x01);
+	regval = regval << 7;
+	/*Merge with the 7 bits of Digital Broadcast*/
+	regval |= (unsigned char)(p_service_identification->digital_broadcast_system & 0x7F);
+	i2c_buffer[4] = regval;
+
+	/*Case of a ARIB Generic*/
+	if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC) {
+		p_arib_pointer = p_service_identification->p_service_identification;
+
+		/* Service Identification */
+		i2c_buffer[5] = (unsigned char)(p_arib_pointer->transport_stream_id >> 8);
+		i2c_buffer[6] = (unsigned char)p_arib_pointer->transport_stream_id;
+		i2c_buffer[7] = (unsigned char)(p_arib_pointer->service_id >> 8);
+		i2c_buffer[8] = (unsigned char)p_arib_pointer->service_id;
+		i2c_buffer[9] = (unsigned char)(p_arib_pointer->original_network_id >> 8);
+		i2c_buffer[10] = (unsigned char)p_arib_pointer->original_network_id;
+	}
+	/*Case of a ATSC Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC) {
+		p_atsc_pointer = p_service_identification->p_service_identification;
+
+		/* Service Identification */
+		i2c_buffer[5] = (unsigned char)(p_atsc_pointer->transport_stream_id >> 8);
+		i2c_buffer[6] = (unsigned char)p_atsc_pointer->transport_stream_id;
+		i2c_buffer[7] = (unsigned char)(p_atsc_pointer->program_number >> 8);
+		i2c_buffer[8] = (unsigned char)p_atsc_pointer->program_number;
+		i2c_buffer[9] = (unsigned char)(p_atsc_pointer->reserved >> 8);
+		i2c_buffer[10] = (unsigned char)p_atsc_pointer->reserved;
+	}
+	/*Case of a DVB Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC) {
+		p_dvb_pointer = p_service_identification->p_service_identification;
+
+		/* Service Identification */
+		i2c_buffer[5] = (unsigned char)(p_dvb_pointer->transport_stream_id >> 8);
+		i2c_buffer[6] = (unsigned char)p_dvb_pointer->transport_stream_id;
+		i2c_buffer[7] = (unsigned char)(p_dvb_pointer->service_id >> 8);
+		i2c_buffer[8] = (unsigned char)p_dvb_pointer->service_id;
+		i2c_buffer[9] = (unsigned char)(p_dvb_pointer->original_network_id >> 8);
+		i2c_buffer[10] = (unsigned char)p_dvb_pointer->original_network_id;
+	}
+	/*other cases, Buffer are empty*/
+	else {
+		i2c_buffer[5] = 0xFF;       /* Service Identification */
+		i2c_buffer[6] = 0xFF;
+		i2c_buffer[7] = 0xFF;
+		i2c_buffer[8] = 0xFF;
+		i2c_buffer[9] = 0xFF;
+		i2c_buffer[10] = 0xFF;
+	}
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 11);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetAnalogueTimer( )
+ *    \brief This message is used to set asingle timer block on an analogue
+ *           recording device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECAnalogueBroadcastType_t AnalogueBroadcastType \n
+ *           "Cable,Sattellite,Terrestrial".\n
+ *
+ *    \param u16 AnalogueFrequency \n
+ *           Specify frequency used by analogue tuner (0x0000<=N<=0xFFFF).\n
+ *
+ *    \param dlHdmiCECBroadcastSystem_t BroadcastSystem \n
+ *           Specify information about the colour system, the sound carrier and
+ *           the IF-frequency.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_analogue_timer
+(
+    instance_t                        instance,
+    u8                               receiver_logical_address,
+    u8                               day_of_month,
+    u8                               month_of_year,
+    u16                              start_time,
+    dl_hdmi_cecduration_t              *p_duration,
+    u8                               recording_sequence,
+    dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type,
+    u16                              analogue_frequency,
+    dl_hdmi_cecbroadcast_system_t       broadcast_system
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[15] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set Analogue Timer command */
+	i2c_buffer[0] = 0x0F;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_ANALOGUE_TIMER ;   /* Message Abort*/
+	i2c_buffer[4] = day_of_month;
+	i2c_buffer[5] = month_of_year;
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);
+	i2c_buffer[7] = (unsigned char)start_time;
+	i2c_buffer[8] = p_duration -> hours;
+	i2c_buffer[9] = p_duration -> minute;
+	i2c_buffer[10] = recording_sequence;
+	i2c_buffer[11] = analogue_broadcast_type;
+	i2c_buffer[12] = (unsigned char)(analogue_frequency >> 8);
+	i2c_buffer[13] = (unsigned char)analogue_frequency;
+	i2c_buffer[14] = broadcast_system;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 15);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetAudioRate( )
+ *    \brief This message is used to control audio rate from Source device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECAudioRate_t AudioRate \n
+ *           The audio rate requested. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_audio_rate
+(
+    instance_t           instance,
+    u8                  receiver_logical_address,
+    dl_hdmi_cecaudio_rate_t audio_rate
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set Audio Rate command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_AUDIO_RATE ;   /* Set Audio Rate */
+	i2c_buffer[4] = audio_rate;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetDigitalTimer( )
+ *    \brief This message is used to set a digital timer block on a digital
+ *           recording device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress \n
+ *           Address of message receiver. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECDigitalServiceIdentification_t *pServiceIdentification \n
+ *           Pointer to the structure Digital Service Identification
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_digital_timer
+(
+    instance_t                               instance,
+    u8                                     receiver_logical_address,
+    u8                                      day_of_month,
+    u8                                      month_of_year,
+    u16                                     start_time,
+    dl_hdmi_cecduration_t                     *p_duration,
+    u8                                      recording_sequence,
+    dl_hdmi_cecdigital_service_identification_t *p_service_identification
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[18] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	dl_hdmi_cecarib_data_t *p_arib_pointer;
+	dl_hdmi_cecatsc_data_t *p_atsc_pointer;
+	dl_hdmi_cecdvb_data_t  *p_dvb_pointer;
+
+	unsigned char regval;                 /* Local variable*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set Digital Timer command */
+	i2c_buffer[0] = 0x12;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Set Digital Timer*/
+	i2c_buffer[3] = CEC_OPCODE_SET_DIGITAL_TIMER ;
+	i2c_buffer[4] = day_of_month;                           /* Day of Month*/
+	i2c_buffer[5] = month_of_year;                          /* Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);      /* Start Time*/
+	i2c_buffer[7] = (unsigned char)start_time;
+	i2c_buffer[8] = p_duration -> hours;                   /* Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;                  /* Duration Minute*/
+	/*Recording Sequence*/
+	i2c_buffer[10] = recording_sequence;
+
+	/* Digital service Identification*/
+	/*Merge Service Method and Digital Broadcast System in the same Byte*/
+	/*bit 7 is Service Method*/
+	regval = (unsigned char)(p_service_identification->service_identification_method & 0x01);
+	regval = regval << 7;
+	/*bits 6 to 0 are Digital Broadcast*/
+	regval |= (unsigned char)(p_service_identification->digital_broadcast_system & 0x7F);
+	i2c_buffer[11] = regval;
+
+	/*Case of a ARIB Generic*/
+	if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ARIB_GENERIC) {
+		p_arib_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_arib_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_arib_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_arib_pointer->service_id >> 8);
+		i2c_buffer[15] = (unsigned char)p_arib_pointer->service_id;
+		i2c_buffer[16] = (unsigned char)(p_arib_pointer->original_network_id >> 8);
+		i2c_buffer[17] = (unsigned char)p_arib_pointer->original_network_id;
+	}
+	/*Case of a ATSC Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_ATSC_GENERIC) {
+		p_atsc_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_atsc_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_atsc_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_atsc_pointer->program_number >> 8);
+		i2c_buffer[15] = (unsigned char)p_atsc_pointer->program_number;
+		i2c_buffer[16] = (unsigned char)(p_atsc_pointer->reserved >> 8);
+		i2c_buffer[17] = (unsigned char)p_atsc_pointer->reserved;
+	}
+	/*Case of a DVB Generic*/
+	else if(p_service_identification->digital_broadcast_system == CEC_DIGITAL_BROADCAST_SYSTEM_DVB_GENERIC) {
+		p_dvb_pointer = p_service_identification->p_service_identification;
+
+		i2c_buffer[12] = (unsigned char)(p_dvb_pointer->transport_stream_id >> 8);
+		i2c_buffer[13] = (unsigned char)p_dvb_pointer->transport_stream_id;
+		i2c_buffer[14] = (unsigned char)(p_dvb_pointer->service_id >> 8);
+		i2c_buffer[15] = (unsigned char)p_dvb_pointer->service_id;
+		i2c_buffer[16] = (unsigned char)(p_dvb_pointer->original_network_id >> 8);
+		i2c_buffer[17] = (unsigned char)p_dvb_pointer->original_network_id;
+	}
+	/*other cases, Buffer are empty*/
+	else {
+		i2c_buffer[12] = 0xFF;
+		i2c_buffer[13] = 0xFF;
+		i2c_buffer[14] = 0xFF;
+		i2c_buffer[15] = 0xFF;
+		i2c_buffer[16] = 0xFF;
+		i2c_buffer[17] = 0xFF;
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 18);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetExternalTimerWithExternalPlug( )
+ *    \brief This message is used to set a single timer block to record from an
+ *           external device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPlug_t  ExternalPlug \n
+ *           indicates external plug number (1 to 255 )on the recording device.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_external_timer_with_external_plug
+(
+    instance_t                instance,
+    u8                       receiver_logical_address,
+    u8                       day_of_month,
+    u8                       month_of_year,
+    u16                      start_time,
+    dl_hdmi_cecduration_t      *p_duration,
+    u8                       recording_sequence,
+    dl_hdmi_cecexternal_plug_t  external_plug
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[13] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set External Timer With External Plug command */
+	i2c_buffer[0] = 0x0D;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_EXTERNAL_TIMER ;   /*SetDigital Timer*/
+
+	i2c_buffer[4] = day_of_month;                       /*Day of Month*/
+	i2c_buffer[5] = month_of_year;                      /*Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);  /*Start Time*/
+	i2c_buffer[7] = (unsigned char)start_time;
+	i2c_buffer[8] = p_duration -> hours;               /*Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;              /*Duration Minute*/
+	i2c_buffer[10] = recording_sequence;               /*Recording Sequence*/
+	/*External Source Specifier = External Plug */
+	i2c_buffer[11] = CEC_EXTERNAL_PLUG;
+	i2c_buffer[12] = external_plug;                    /*External Plug*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 13);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetExternalTimerWithPhysicalAddress( )
+ *    \brief This message is used to set a single timer block to record from an
+ *           external device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  DayOfMonth \n
+ *           Day of the month.\n
+ *
+ *    \param u8  MonthOfYear \n
+ *           Month of the year.\n
+ *
+ *    \param u16 StartTime \n
+ *           Start time for a timer based recording.\n
+ *
+ *    \param u16 Duration \n
+ *           Pointer to the structure dlHdmiCECDuration_t in BCD format.\n
+ *
+ *    \param u8 Recording Sequence \n
+ *           Indicates if recording is repeated and, if so, on which day
+ *           For repeated recording the recording sequence value is the
+ *           bitwise OR of the days when recordings are required
+ *           Shall be set to 0x00 when recording is not repeated.\n
+ *
+ *    \param dlHdmiCECExternalPhysicalAddress_t  PhysicalAddress \n
+ *           Defines the path between the TV an a device-thus giving it a physical
+ *           address within the cluster.\n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_external_timer_with_physical_address
+(
+    instance_t                           instance,
+    u8                                  receiver_logical_address,
+    u8                                  day_of_month,
+    u8                                  month_of_year,
+    u16                                 start_time,
+    dl_hdmi_cecduration_t                 *p_duration,
+    u8                                  recording_sequence,
+    dl_hdmi_cecexternal_physical_address_t  external_physical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[14] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set external Timer With External Physical Address command */
+	i2c_buffer[0] = 0x0E;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_EXTERNAL_TIMER ;   /* SetDigital Timer*/
+
+	i2c_buffer[4] = day_of_month;                       /* Day of Month*/
+	i2c_buffer[5] = month_of_year;                      /* Month of Year*/
+	i2c_buffer[6] = (unsigned char)(start_time >> 8);  /* Start Time*/
+	i2c_buffer[7] = (unsigned char)start_time;
+	i2c_buffer[8] = p_duration -> hours;               /* Duration Hours*/
+	i2c_buffer[9] = p_duration -> minute;              /* Duration Minute*/
+	i2c_buffer[10] = recording_sequence;               /* Recording Sequence*/
+	/*External Source Specifier = External Address*/
+	i2c_buffer[11] = CEC_EXTERNAL_PHYSICAL_ADDRESS;
+	/*External Address*/
+	i2c_buffer[12] = (unsigned char)(external_physical_address >> 8);
+	i2c_buffer[13] = (unsigned char) external_physical_address;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 14);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTunerStepDecrement( )
+ *    \brief This message is used to tune to next lowest service in a tuner's
+ *           service list.Can be used for PIP.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_step_decrement
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Tuner Step Decrement command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Tuner Step Decrement*/
+	i2c_buffer[3] = CEC_OPCODE_TUNER_STEP_DECREMENT ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecTunerStepIncrement( )
+ *    \brief This message is used to tune to next highest service in a tuner's
+ *           service list.Can be used for PIP.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_tuner_step_increment
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Tuner Step Increment command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Tuner Step Increment*/
+	i2c_buffer[3] = CEC_OPCODE_TUNER_STEP_INCREMENT ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecDeviceVendorID()
+ *    \brief This message report the vendor ID of this device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u32 VendorID \n
+ *           Indentifier for a specific Vendor \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_device_vendor_id
+(
+    instance_t instance,
+    u32       vendor_id
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[7] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Device Vendor ID command */
+	/* Param number in case of Vendor ID is 32 Bytes*/
+	i2c_buffer[0] = 0x07;
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Broadcast*/
+	i2c_buffer[2] |= 0x0F;
+
+	/* Device Vendor ID opcode = 0x87*/
+	i2c_buffer[3] = CEC_OPCODE_DEVICE_VENDOR_ID ;
+	i2c_buffer[4] = (unsigned char)(vendor_id >> 16);  /* MSByte of Vendor ID*/
+	i2c_buffer[5] = (unsigned char)(vendor_id >> 8);
+	i2c_buffer[6] = (unsigned char)vendor_id;          /* LSByte of Vendor ID*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 7);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveDeviceVendorID( )
+ *    \brief This message is request the vendor ID from a device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_device_vendor_id
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give Device Vendor ID command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Give Device Vendor*/
+	i2c_buffer[3] = CEC_OPCODE_GIVE_DEVICE_VENDOR_ID ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecVendorCommand( )
+ *    \brief This message is allows vendor specific commands to be sent between
+ *           two devices.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  *pVendorSpecificData \n
+ *           Pointer to the Vendor Specific datas
+ *
+ *    \param u8    VendorSpecificDataLength \n
+ *           Length of VendorSpecificData. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_command
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u8         *p_vendor_specific_data,
+    u8         vendor_specific_data_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Vendor Command command */
+	/* Calculate Message length*/
+	mess_length = vendor_specific_data_length + 4;
+
+	i2c_buffer[0] = mess_length;                    /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_VENDOR_COMMAND ;       /* Vendor Command*/
+
+	for(loci = 0; loci <= vendor_specific_data_length ; loci++) {
+		/* Fill Table with vendorSpecific Data characters*/
+		i2c_buffer[(loci+7)] = p_vendor_specific_data[loci];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, mess_length);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecVendorCommandWithID( )
+ *    \brief This message is allows vendor specific commands to be sent between
+ *           two devices or broadcast.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u32 VendorID \n
+ *           Indentifier for a specific Vendor \n
+ *
+ *    \param u8  *pVendorSpecificData \n
+ *           Pointer to the Vendor Specific datas
+ *
+ *    \param u8    VendorSpecificDataLength \n
+ *           Length of VendorSpecificData. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_command_with_id
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u32        vendor_id,
+    u8         *p_vendor_specific_data,
+    u8         vendor_specific_data_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Vendor Command With ID command */
+	/* Calculate Message length*/
+	mess_length = vendor_specific_data_length + 7;
+
+	i2c_buffer[0] = mess_length;                      /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Vendor Command*/
+	i2c_buffer[3] = CEC_OPCODE_VENDOR_COMMAND_WITH_ID ;
+	i2c_buffer[4] = (unsigned char)(vendor_id >> 16);  /* MSByte of Vendor ID*/
+	i2c_buffer[5] = (unsigned char)(vendor_id >> 8);
+	i2c_buffer[6] = (unsigned char)vendor_id;          /* LSByte of Vendor ID*/
+
+	for(loci = 0; loci <= vendor_specific_data_length ; loci++) {
+		/* Fill Table with vendorSpecific Data characters*/
+		i2c_buffer[(loci+7)] = p_vendor_specific_data[loci];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, mess_length);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecVendorRemoteButtonDown( )
+ *    \brief This message indicates that a remote control button has been depressed.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8  *pVendorSpecificRcCode \n
+ *           Pointer to the Vendor Specific remote control code.
+ *           its recommended t keep this to a minimum size.
+ *           The maximum length shall not exceed 14 data blocks to avoid saturating bus
+ *
+ *    \param u8    VendorSpecificRcCodeLength \n
+ *           Length of VendorSpecificRcCode. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_remote_button_down
+(
+    instance_t  instance,
+    u8         receiver_logical_address,
+    u8         *p_vendor_specific_rc_code,
+    u8         vendor_specific_rc_code_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Vendor Remote Button Down command */
+	/* Calculate Message length*/
+	mess_length = vendor_specific_rc_code_length + 4;
+
+	i2c_buffer[0] = mess_length;                       /* Message Length */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Vendor Remote Button Down Opcode*/
+	i2c_buffer[3] = CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN ;
+	/*Vendor Specific RC code Parameter*/
+	for(loci = 0; loci <= vendor_specific_rc_code_length ; loci++) {
+		/* Fill Table with Vendor Specific RC Code data*/
+		i2c_buffer[(loci+4)] = p_vendor_specific_rc_code[loci];
+	}
+	/*Send message Via I2C*/
+
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, mess_length);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecVendorRemoteButtonUp( )
+ *    \brief This message indicates that a remote control button (the last button
+ *           pressed indicated by the <Vendor remote button down > message) has
+ *           been released.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_vendor_remote_button_up
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Vendor Remote Button Up command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Vendor Remote Button Up*/
+	i2c_buffer[3] = CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetOsdString( )
+ *    \brief This message is used to send a test message to output on a TV.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECDisplayControl_t DisplayControl \n
+ *           Display timing. \n
+ *
+ *    \param const char *pOsdString \n
+ *           Pointer on the Text to display. \n
+ *
+ *    \param u8    OsdStringLength \n
+ *           Length of Osd String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_osd_string
+(
+    instance_t                 instance,
+    u8                        receiver_logical_address,
+    dl_hdmi_cecdisplay_control_t  display_control,
+    const char                   *p_osd_string,
+    u8                        osd_string_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set OSD String command */
+
+	/* Calculate Message length*/
+	mess_length = osd_string_length + 5;
+
+	i2c_buffer[0] = (unsigned char)mess_length;
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_OSD_STRING ;       /* Set Osd String*/
+	i2c_buffer[4] = display_control;                   /*Display Control*/
+	for(loci = 0; loci <= osd_string_length ; loci++) {
+		/* Fill Table with OSD Name characters*/
+		i2c_buffer[(loci+5)] = p_osd_string[loci];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, (mess_length));
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveOsdName( )
+ *    \brief This message is used to request preferred OSD name of a device
+ *           for use in menus associated with that device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_osd_name
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give OSD Name command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_GIVE_OSD_NAME ;    /* Give OSD Name*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetOsdName( )
+ *    \brief This message is used to set the preferred OSD name of a device
+ *           for use in manus associated with that device.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param const char *pOsdName \n
+ *           Pointer on the preferred name of the device. \n
+ *
+ *    \param u8    OsdNameLength \n
+ *           Length of Osd Name String. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_osd_name
+(
+    instance_t instance,
+    u8        receiver_logical_address,
+    const char   *p_osd_name,
+    u8        osd_name_length
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[19] ;       /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char loci;                   /* Local increment variable*/
+	unsigned char mess_length;             /* Local Message length*/
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Set OSD Name command */
+
+	/* Calculate Message length*/
+	mess_length = osd_name_length + 4;
+
+	i2c_buffer[0] = (unsigned char)mess_length;
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_SET_OSD_NAME ;     /* Set Osd Name*/
+	for(loci = 0; loci <= osd_name_length ; loci++) {
+		/* Fill Table with OSD Name characters*/
+		i2c_buffer[(loci+4)] = p_osd_name[loci];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, (mess_length));
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecMenuRequest( )
+ *    \brief This message request from the TV for a device to show/remove a
+ *           menu or to query if a device is currently showing a menu
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECMenuRequestType_t  MenuRequestType \n
+ *           Indicates if the menu request is to activate or deactivate the
+ *           devices menu or simply query the devices menu status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_menu_request
+(
+    instance_t                  instance,
+    u8                         receiver_logical_address,
+    dl_hdmi_cecmenu_request_type_t  menu_request_type
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Menu Request command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_MENU_REQUEST ;     /* Menu Request*/
+	i2c_buffer[4] = menu_request_type;              /*Menu Request Type */
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecMenuStatus( )
+ *    \brief This message is used to indicate to the TV that the device is
+ *           showing/has removed a menu and requets the remote control keys to
+ *           be passed though
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECMenuState_t  MenuState \n
+ *           Indicates if the device is in the 'Device Menu Active' state or
+ *           'Device Menu Inactive' state. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_menu_status
+(
+    instance_t            instance,
+    u8                   receiver_logical_address,
+    dl_hdmi_cecmenu_state_t  menu_state
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Menu Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_MENU_STATUS;       /* Menu Status*/
+	i2c_buffer[4] = menu_state;                    /* Menu State*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressed( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECUserRemoteControlCommand_t UICommand \n
+ *           Relevant UI command issued by user. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecuser_remote_control_command_t uicommand
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Pressed command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control pressed*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+	i2c_buffer[4] = uicommand;                            /* UI Command*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressedPlay( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPlayMode_t PlayMode \n
+ *           In which mode to play media. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_play
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecplay_mode_t                 play_mode
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Presses Play command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Pressed*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+
+	/* UI Command = CEC_REMOTE_BUTTON_PLAY_FUNCTION */
+	i2c_buffer[4] = CEC_REMOTE_BUTTON_PLAY_FUNCTION;
+	i2c_buffer[5] = play_mode;                             /* Play Mode*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressedSelectAudioInput( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectAudioInput \n
+ *           Number of the Audio Input (Audio input number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_audio_input
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_audio_input
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Pressed Select Audio Input command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Pressed*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+
+	/* UI Command = CEC_REMOTE_BUTTON_SELECT_AUDIO_INPUT_FUNCTION*/
+	i2c_buffer[4] = CEC_REMOTE_BUTTON_SELECT_AUDIO_INPUT_FUNCTION;
+	/* UI Function Select Audio mode*/
+	i2c_buffer[5] = select_audio_input;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressedSelectAVInput( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectAVInput \n
+ *           Number of the A/V Input (A/V input number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_avinput
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_avinput
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Pressed Select AV Input command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Pressed*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+
+	/* UI Command = CEC_REMOTE_BUTTON_SELECT_AV_INPUT_FUNCTION */
+	i2c_buffer[4] = CEC_REMOTE_BUTTON_SELECT_AV_INPUT_FUNCTION;
+	/* UI Function Select A/V Input*/
+	i2c_buffer[5] = select_avinput;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressedSelectMedia( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 SelectMedia \n
+ *           Number of Media (Media number between 1 and 255). \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_select_media
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    u8                                 select_media
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Pressed Select Media command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Pressed*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+
+	/* UI Command = CEC_REMOTE_BUTTON_SELECT_MEDIA_FUNCTION*/
+	i2c_buffer[4] = CEC_REMOTE_BUTTON_SELECT_MEDIA_FUNCTION;
+	/* UI Function Media*/
+	i2c_buffer[5] = select_media;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlPressedTune( )
+ *    \brief This message is used to indicate that the user pressed a remote button
+ *           or switched from one remote control button to another.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECChannelIdentifier_t  *pChannelIdentifier \n
+ *           Pointer to the structure of Major and Minor Channel number
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_pressed_tune
+(
+    instance_t                          instance,
+    u8                                 receiver_logical_address,
+    dl_hdmi_cecchannel_identifier_t        *p_channel_identifier
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[10] ;       /* I2C data buffer */
+	u16 regval16 ;                      /* Local variable used for conversion*/
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Pressed Tune command */
+	i2c_buffer[0] = 0x0A;   /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Pressed Opcode*/
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_PRESSED;
+
+	/* UI Command = CEC_REMOTE_BUTTON_TUNE_FUNCTION*/
+	i2c_buffer[4] = CEC_REMOTE_BUTTON_TUNE_FUNCTION;
+
+	/* Merge 6 bits of ChanNum with 10 bits of Major channel*/
+	/* Save the 6 lsbits */
+	regval16 = (u16)(p_channel_identifier->chan_num_format & 0x003F);
+	regval16 = regval16 << 10;
+	regval16 |= (u16)(p_channel_identifier->major_chan_number & 0x03FF);
+
+	/* Load the 4 information bytes of Channel ID*/
+	i2c_buffer[5] = (unsigned char)(regval16 >> 8);
+	i2c_buffer[6] = (unsigned char)regval16;
+	i2c_buffer[7] = (unsigned char)(p_channel_identifier->minor_chan_number >> 8);
+	i2c_buffer[8] = (unsigned char)p_channel_identifier->minor_chan_number;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 9);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecUserControlReleased( )
+ *    \brief This message is used to indicate that the user released a remote button
+ *           The last one indicated by the <User Control Pressed> Message.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_user_control_released
+(
+    instance_t  instance,
+    u8         receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* User Control Released command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* User Control Released */
+	i2c_buffer[3] = CEC_OPCODE_USER_CONTROL_RELEASED ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGiveDevicePowerStatus( )
+ *    \brief This message is used to determine the current power status of a
+ *           target device
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_give_device_power_status
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Give Device power Status Power Status command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Give Device Power Status */
+	i2c_buffer[3] = CEC_OPCODE_GIVE_DEVICE_POWER_STATUS ;
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecReportPowerStatus( )
+ *    \brief This message is used to inform a requesting device of the current
+ *           power status.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECPowerStatus_t PowerStatus \n
+ *           Current power status. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_report_power_status
+(
+    instance_t             instance,
+    u8                    receiver_logical_address,
+    dl_hdmi_cecpower_status_t power_status
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[5] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Report Power Status command */
+	i2c_buffer[0] = 0x05;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	/* Report Power Status*/
+	i2c_buffer[3] = CEC_OPCODE_REPORT_POWER_STATUS ;
+	i2c_buffer[4] = power_status;                          /* Power Status*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 5);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecFeatureAbort()
+ *    \brief This message is used as a reponse to indicate that the device does
+ *           not support the requested message type, or that it cannot execute it
+ *           at the present time.
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param dlHdmiCECFeatureOpcode_t FeatureOpcode \n
+ *           Opcode of the aborted message. \n
+ *
+ *    \param dlHdmiCECAbortReason_t   AbortReason \n
+ *           The reason why message cannot respond. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_feature_abort
+(
+    instance_t               instance,
+    u8                      receiver_logical_address,
+    dl_hdmi_cecfeature_opcode_t feature_opcode,
+    dl_hdmi_cecabort_reason_t   abort_reason
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[6] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Feature Abort command */
+	i2c_buffer[0] = 0x06;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_FEATURE_ABORT ;    /* Feature Abort*/
+	i2c_buffer[4] = feature_opcode;    /* Feature Opcode*/
+	i2c_buffer[5] = abort_reason;      /* Abort Reason*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 6);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetCecVersion( )
+ *    \brief This message is used by a device to enquire which version of CEC
+ *           the target supports
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_cec_version
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* Get CEC Version command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_GET_CEC_VERSION ;  /* Get CEC Version*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecAbortMessage( )
+ *    \brief This message is reserved for testing purposes
+ *
+ *    \param tmInstance_t Instance \n
+ *           Instance identifier. \n
+ *
+ *    \param u8 ReceiverLogicalAddress\n
+ *           Address of message receiver. \n
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_abort_message
+(
+    instance_t   instance,
+    u8          receiver_logical_address
+)
+{
+	error_code_t  err;
+	unsigned char  i2c_buffer[4] ;        /* I2C data buffer */
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if instance state is correct */
+	/*RETIF(UnitTable[Instance].state != STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/*======To do : make a prepare message function with parameter */
+	/* CEC Abort Message command */
+	i2c_buffer[0] = 0x04;     /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	/* Receiver logical Address*/
+	i2c_buffer[2] |= receiver_logical_address & 0x0F;
+
+	i2c_buffer[3] = CEC_OPCODE_ABORT_MESSAGE ;    /* Message Abort*/
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, 4);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = i2c_buffer[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = i2c_buffer[3];
+
+	return(0);
+}
+
+/*Non Functional function used to provide easy way to access register */
+
+/*========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecGetRegister( )
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration for CEC Stack Processor.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+unsigned char dl_hdmi_cec_get_register
+(
+    instance_t               instance,
+    u32                     offset
+)
+{
+	error_code_t                  err;
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+	unsigned char               i2c_read_buffer[1];
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), 0xFF)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, 0xFF)
+
+	/* Ckeck the state */
+	/*RETIF(UnitTable[instance].state != CEC_STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	err = get_cec_hw_registers(p_dis, (u8) offset, i2c_read_buffer, 1);
+	RETIF(err != 0, 0xff)
+
+	return(i2c_read_buffer[0]);
+}
+
+/*QB 10 Jan ========================================================================== */
+/*!
+ *    \fn tmErrorCode_t dlHdmiCecSetRegister( )
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration for CEC Stack Processor.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_register
+(
+    instance_t                instance,
+    u32                      offset,
+    u32                      value
+)
+{
+	error_code_t                  err;
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* Ckeck the state */
+	/*RETIF(UnitTable[instance].state != CEC_STATE_NOT_INITIALIZED, ERR_DLHDMICEC_INVALID_STATE) */
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	err = set_cec_hw_register(p_dis, (u8) offset, (u8)value);
+	RETIF(err != 0, err)
+
+	return(0);
+}
+
+/*========================================================================== */
+/*!
+ *    \brief Set the power state of an instance of the CEC device. ON
+ *           state corresponds to a fully supplied, up and running device. Other
+ *           modes correspond to the powerdown state of the device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param powerState Power state to set.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_set_power_state
+(
+    instance_t   instance,
+    power_state_t power_state
+)
+{
+	error_code_t err = 0;
+
+#ifdef TMFL_TDA9989
+	unsigned char i2c_read_buffer[1];
+
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	if(power_state == power_on) {
+
+		err = get_cec_hw_registers(p_dis, E_REG_ENAMODS, i2c_read_buffer, 1);
+		RETIF(err != 0, err)
+
+		i2c_read_buffer[0] |= DEFAULT_ENAMODS;
+
+		err = set_cec_hw_register(p_dis, E_REG_ENAMODS, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+	} else if(power_state == power_standby) {
+
+		err = get_cec_hw_registers(p_dis, E_REG_ENAMODS, i2c_read_buffer, 1);
+		RETIF(err != 0, err)
+
+		i2c_read_buffer[0] &=  ~(DEFAULT_ENAMODS);
+
+		err = set_cec_hw_register(p_dis, E_REG_ENAMODS, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+		unit_table[instance].state = CEC_STATE_NOT_INITIALIZED;
+
+	} else {
+		return ERR_DLHDMICEC_BAD_PARAMETER;
+	}
+
+#endif  /*  TMFL_TDA9989 */
+
+	return err;
+}
+
+/*========================================================================== */
+/*!
+ *    \brief Get the power state of an instance of the CEC device. ON
+ *           state corresponds to a fully supplied, up and running device. Other
+ *           modes correspond to the powerdown state of the device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance    Instance identifier.
+ *    \param pPowerState Pointer to the power state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_get_power_state
+(
+    instance_t    instance,
+    power_state_t *p_power_state
+)
+{
+	error_code_t err = 0;
+
+#ifdef TMFL_TDA9989
+
+	unsigned char i2c_read_buffer[1];
+
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	if(p_power_state == NULL) return ERR_DLHDMICEC_BAD_PARAMETER;
+
+	err = get_cec_hw_registers(p_dis, E_REG_ENAMODS, i2c_read_buffer, 1);
+	RETIF(err != 0, err)
+
+	if((i2c_read_buffer[0] & DEFAULT_ENAMODS) == DEFAULT_ENAMODS) {
+		*p_power_state = power_on;
+	} else {
+		*p_power_state = power_standby;
+	}
+
+#endif  /*  TMFL_TDA9989 */
+
+	return err;
+
+}
+
+/*========================================================================== */
+/*!
+ *    \brief This function allow to send a generic CEC message
+ *           This function has to be used when CEC messages are construct in
+ *	   the middleware
+ *
+ *    \param instance  Instance identifier.
+ *
+ *    \param *pData    Pointer to the CEC data buffer
+ *
+ *    \param lenData   Lenght of I2C data buffer
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMICEC_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMICEC_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *	    - ERR_DLHDMICEC_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ * */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_send_message(
+
+    instance_t instance,
+    u8        *p_data,
+    u16       len_data
+)
+{
+
+	error_code_t  err = 0;
+
+#ifdef TMFL_TDA9989
+
+	unsigned char  i2c_buffer[19] ;        /* I2C data buffer */
+	unsigned char  loci;                   /* Local increment variable*/
+	unsigned char  mess_length;             /* Local Message length*/
+
+	/* Pointer to Device Instance Structure */
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* check if unit corresponding to instance is opened */
+	RETIF(unit_table[instance].opened == false, ERR_DLHDMICEC_RESOURCE_NOT_OWNED)
+
+	/* check if CEC message is not too long */
+	RETIF((len_data > 16), ERR_DLHDMICEC_INCONSISTENT_PARAMS)
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* Calculate Internal Message length*/
+	/* real data is less ReceiverLogical address */
+	mess_length = (len_data - 1) + 3;
+
+	i2c_buffer[0] = mess_length;  /* Param number */
+
+	i2c_buffer[1] = 0x00;     /* Request CEC data */
+
+	/*Build Initiator and Reciever Logical Address Byte*/
+	/*Initiator logical Address*/
+	i2c_buffer[2] = (unsigned char)(unit_table[instance].device_logical_address) & 0x0F;
+	i2c_buffer[2] = i2c_buffer[2] << 4;
+	i2c_buffer[2] |= p_data[0] & 0x0F;
+
+	for(loci = 0; loci <= len_data ; loci++) {
+		/* Fill Table with Data from middleware, Data begin at position 1*/
+		i2c_buffer[(loci+3)] = p_data[(loci+1)];
+	}
+
+	/* CEC Data register */
+	err = set_cec_hw_registers(p_dis, E_REG_CDR0, i2c_buffer, mess_length);
+	RETIF(err != 0, err)
+
+	/* Save Datas of the CEC message send */
+	gtmdl_hdmi_cec_driver_save_message.address_byte = p_data[2];
+	gtmdl_hdmi_cec_driver_save_message.message_type_polling = 0;
+	gtmdl_hdmi_cec_driver_save_message.opcode = p_data[3];
+
+#endif  /*  TMFL_TDA9989 */
+
+	return err;
+
+}
+
+/*========================================================================== */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_enable_calibration(instance_t instance, dl_hdmi_cec_clock_source_t cec_clock_source)
+{
+	error_code_t err = 0;
+
+#ifdef TMFL_TDA9989
+
+	unsigned char                   i2c_read_buffer[1];
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* CLOCK SOURCE is FRO */
+	if(cec_clock_source == DL_HDMICEC_CLOCK_FRO) {
+
+		/* cf PR1795 set desired frequency to 12 Mhz*/
+
+		dl_hdmi_cec_set_register(instance, 0xF3, 0xC0);
+
+		RETIF(err != 0, err)
+
+		dl_hdmi_cec_set_register(instance, 0xF4, 0xD4);
+
+		RETIF(err != 0, err)
+
+		/* set calibration in automatic mode */
+		err = get_cec_hw_registers(p_dis, E_REG_CEC_DES_FREQ2, i2c_read_buffer, 1);
+		RETIF(err != 0, err)
+		i2c_read_buffer[0] &= CEC_AUTOMATIC_CALIBRATION_MSK;
+		err = set_cec_hw_register(p_dis, E_REG_CEC_DES_FREQ2, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+		/* select FRO clock mode, osc_freq shall be also set to one */
+		i2c_read_buffer[0] = CEC_SELECT_FRO_CLOCK_SOURCE;
+		err = set_cec_hw_register(p_dis, E_REG_CEC_CLK, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+		/* Enable cec_clk AND FRO */
+		err = get_cec_hw_registers(p_dis, E_REG_ENAMODS, i2c_read_buffer, 1);
+		RETIF(err != 0, err)
+		i2c_read_buffer[0] |= CEC_ENABLE_CEC_CLK_MSK;
+		i2c_read_buffer[0] &= CEC_ENABLE_FRO_MSK;
+		err = set_cec_hw_register(p_dis, E_REG_ENAMODS, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+		/* Enable calibration */
+		i2c_read_buffer[0] = CEC_ENABLE_CALIBRATION;
+		err = set_cec_hw_register(p_dis, E_REG_CEC_CAL_XOSC_CTRL1, i2c_read_buffer[0]);
+		RETIF(err != 0, err)
+
+	} /* CLOCK SOURCE is FRO */
+
+#endif  /*  TMFL_TDA9989 */
+
+	return err;
+}
+
+/*========================================================================== */
+/*========================================================================== */
+error_code_t dl_hdmi_cec_disable_calibration(instance_t instance)
+{
+	error_code_t err = 0;
+
+#ifdef TMFL_TDA9989
+
+	unsigned char                   i2c_read_buffer[1];
+	dl_hdmi_cec_driver_config_table_t *p_dis;
+
+	p_dis = &gtmdl_hdmi_cec_driver_config_table[instance];
+
+	/* check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMICEC_BAD_INSTANCE)
+
+	/* Disable calibration */
+	i2c_read_buffer[0] = CEC_DISABLE_CALIBRATION;
+	err = set_cec_hw_register(p_dis, E_REG_CEC_CAL_XOSC_CTRL1, i2c_read_buffer[0]);
+	RETIF(err != 0, err)
+
+#endif  /*  TMFL_TDA9989 */
+
+	return err;
+}
+
+/*============================================================================*/
+/*                     END OF FILE                                            */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.c b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.c
new file mode 100755
index 0000000..c71fe68
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.c
@@ -0,0 +1,286 @@
+/**
+ * Copyright (C) 2006 Koninklijke Philips Electronics N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of Koninklijke Philips Electronics N.V. and is confidential in
+ * nature. Under no circumstances is this software to be  exposed to or placed
+ * under an Open Source License of any type without the expressed written
+ * permission of Koninklijke Philips Electronics N.V.
+ *
+ * \file          dlHdmiCEC_local.c
+ *
+ * \version       $Revision:  $
+ *
+ * \date          $Date: $
+ *
+ * \brief         dev lib driver component for the CEC messages
+ *
+ * \section refs  Reference Documents
+ * \section info  Change Information
+ *
+ * \verbatim
+ *   $History: dlHdmiCEC_local.c $
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                   FILE CONFIGURATION                                       */
+/*============================================================================*/
+
+/* Defining this symbol on the compiler command line excludes some API checks */
+/* #define NO_RETIF_BADPARAM */
+
+/*============================================================================*/
+/*                   STANDARD INCLUDE FILES                                   */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PROJECT INCLUDE FILES                                    */
+/*============================================================================*/
+#ifdef __LINUX_ARM_ARCH__
+#include <linux/kernel.h>
+#else
+#include <string.h>
+#endif
+#include "tmdlHdmiCEC.h"
+#include "tmdlHdmiCEC_local.h"
+
+/*============================================================================*/
+/*                   MACRO DEFINITIONS                                        */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   TYPE DEFINITIONS                                         */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC VARIABLE DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   STATIC VARIABLE DECLARATIONS                             */
+/*============================================================================*/
+
+/**
+ * Lookup table to map an 8-bit mask to a number of left shifts
+ * needed to shift a value starting at bit 0 onto the mask.
+ * Indexed by mask 0-255. For example, mask 0x00 and 0x01 need
+ * no shift, mask 0x02 needs one shift, mask 0x03 needs no shift,
+ * mask 0x04 needs 2 shifts, etc.
+ * Rows were formatted by "HDMI Driver - Register List.xls" and pasted here
+ * */
+static CONST_DAT u8 k_mask_to_shift[256] = {
+	/* Mask index: */
+	/*x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF        */
+	0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 0x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 1x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 2x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 3x */
+	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 4x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 5x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 6x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 7x */
+	7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 8x */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* 9x */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Ax */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Bx */
+	6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Cx */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Dx */
+	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, /* Ex */
+	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0  /* Fx */
+};
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DECLARATIONS                             */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                   PUBLIC FUNCTION DEFINITIONS                              */
+/*============================================================================*/
+
+/*============================================================================*/
+/* getCecHwRegisters                                                             */
+/*============================================================================*/
+error_code_t
+get_cec_hw_registers
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8  reg_addr,
+    u8  *p_data,
+    u16 len_data
+)
+{
+	error_code_t        err;     /* Error code */
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Get I2C register range - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = (u8)len_data;
+	sys_args.p_data           = p_data;
+	err = p_dis->i2c_read_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_READ;
+}
+
+/*============================================================================*/
+/* getCecHwRegister                                                              */
+/*============================================================================*/
+error_code_t
+get_cec_hw_register
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8 reg_addr,
+    u8 *p_reg_value
+)
+{
+	error_code_t        err;     /* Error code */
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Get I2C register - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = p_reg_value;
+	err = p_dis->i2c_read_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_READ;
+
+}
+
+/*============================================================================*/
+/* setCecHwRegisters                                                             */
+/*============================================================================*/
+error_code_t
+set_cec_hw_registers
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8  reg_addr,
+    u8  *p_data,
+    u16 len_data
+)
+{
+	error_code_t        err;     /* Error code */
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Write to I2C register range - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = (u8)len_data;
+	sys_args.p_data           = p_data;
+	err = p_dis->i2c_write_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_WRITE;
+}
+
+/*============================================================================*/
+/* setCecHwRegisterMsbLsb                                                        */
+/*============================================================================*/
+error_code_t
+set_cec_hw_register_msb_lsb
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8  reg_addr,
+    u16 reg_word
+)
+{
+	error_code_t        err;        /* Error code */
+	/* The bytes from regWord                  */
+	u8                msb_lsb[2];
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Unpack regWord bytes, MSB first */
+	msb_lsb[0] = (u8)(reg_word >> 8);
+	msb_lsb[1] = (u8)(reg_word & 0xFF);
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 2;
+	sys_args.p_data           = &msb_lsb[0];
+	err = p_dis->i2c_write_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_WRITE;
+}
+
+/*============================================================================*/
+/* setCecHwRegister                                                              */
+/*============================================================================*/
+error_code_t
+set_cec_hw_register
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8 reg_addr,
+    u8 reg_value
+)
+{
+	error_code_t        err;     /* Error code */
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = &reg_value;
+	err = p_dis->i2c_write_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_WRITE;
+}
+
+/*============================================================================*/
+/*  setCecHwRegisterField                                                        */
+/*============================================================================*/
+error_code_t
+set_cec_hw_register_field
+(
+    dl_hdmi_cec_driver_config_table_t *p_dis,
+    u8 reg_addr,
+    u8 field_mask,
+    u8 field_value
+)
+{
+	error_code_t        err;        /* Error code */
+	/* The register's current value            */
+	u8                reg_value;
+	/* Arguments passed to system function   */
+	dl_hdmi_cec_sys_args_t sys_args;
+
+	/* Read I2C register value.
+	 * All bitfield registers are either shadowed or can be read.
+	 *	 */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = &reg_value;
+	err = p_dis->i2c_read_function(&sys_args);
+	RETIF(err != 0, ERR_DLHDMICEC_I2C_READ)
+
+	/* Reset register bits that are set in the mask */
+	reg_value = reg_value & (u8)(~field_mask);
+
+	/* Shift the field value left to align its bits with the mask */
+	field_value <<= k_mask_to_shift[field_mask];
+
+	/* Reset shifted field bits that are not set in the mask */
+	field_value &= field_mask;
+
+	/* Set the shifted bitfield */
+	reg_value |= field_value;
+
+	/* Write to I2C - all non-OK results are errors */
+	sys_args.slave_addr       = p_dis->i2c_address;
+	sys_args.first_register   = reg_addr;
+	sys_args.len_data         = 1;
+	sys_args.p_data           = &reg_value;
+	err = p_dis->i2c_write_function(&sys_args);
+	return (err == 0) ? 0 : ERR_DLHDMICEC_I2C_WRITE;
+}
+
+/*============================================================================*/
+/*                   STATIC FUNCTION DEFINTIONS                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                     END OF FILE                                            */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.h b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.h
new file mode 100755
index 0000000..eb16cb6
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlHdmiCEC/src/tmdlHdmiCEC_local.h
@@ -0,0 +1,208 @@
+/*============================================================================= */
+/* Copyright (C) 2007 NXP N.V., All Rights Reserved. */
+/* This source code and any compilation or derivative thereof is the proprietary */
+/* information of NXP N.V. and is confidential in nature. Under no circumstances */
+/* is this software to be  exposed to or placed under an Open Source License of */
+/* any type without the expressed written permission of NXP N.V. */
+/*============================================================================= */
+/*!
+ *    \file    dlHdmiCEC_local.h
+ *
+ *	\version 1.0
+ *
+ *	\date    24/07/2007
+ *
+ * 	\brief   devlib driver component API for the CEC messages.
+ *
+ *    \section refs  Reference Documents
+ *             TDA998X Driver - tx - SCS.doc
+ *    \note    None.
+ *
+ *    HISTORY :
+ *    \verbatim
+ *     Date          Modified by CRPRNr  TASKNr  Maintenance description
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *     24/07/2007   |  F.G      |       |       | Creation.
+ *     -------------|-----------|-------|-------|-----------------------------------
+ *    \endverbatim
+ * */
+/*========================================================================== */
+
+#ifndef DLHDMICEC_LOCAL_H
+#define DLHDMICEC_LOCAL_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+/*#include "dlHdmiCEC_IW.h" */
+#include "tmdlHdmiCEC_cfg.h"
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/* Version of the SW driver */
+#define VERSION_COMPATIBILITY 0
+#define VERSION_MAJOR         1
+#define VERSION_MINOR         4
+
+/**
+ * A macro to check a condition and if true return a result
+ * */
+#define RETIF(cond, rslt)       if ((cond)){return (rslt);}
+
+/**
+ * A macro to check a condition and if true return
+ * ERR_HDMI_BAD_PARAMETER.
+ * To save code space, it can be compiled out by defining NO_RETIF_BADPARAM on
+ * the compiler command line.
+ * */
+#ifdef NO_RETIF_BADPARAM
+#define RETIF_BADPARAM(cond)
+#else
+#define RETIF_BADPARAM(cond)  if ((cond)){return ERR_HDMI_BAD_PARAMETER;}
+#endif
+
+/**
+ * A macro to check the result of a register API and if not 0 to return it.
+ * To save code space, it can be compiled out by defining NO_RETIF_REG_FAIL on
+ * the compiler command line.
+ * */
+#ifdef NO_RETIF_REG_FAIL
+#define RETIF_REG_FAIL(result)
+#else
+#define RETIF_REG_FAIL(result)  if ((result) != TM_OK){return (result);}
+#endif
+
+#define TDA9950_RESET_DELAY_MS 250
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+#ifdef TMFL_TDA9989
+
+#define E_REG_ENAMODS	0xFF
+#define E_REG_CEC_CLK	0xF6
+#define E_REG_CEC_INT	0xEE
+#define E_REG_COMBI_INT	0xEC
+#define DEFAULT_ENAMODS 0x81
+#define CEC_CLK_SEL	0xE6
+#define CEC_INT_MASK	0x01
+
+#define E_REG_CEC_CAL_XOSC_CTRL1 0xF2
+#define E_REG_CEC_DES_FREQ2      0xF5
+
+#define CEC_AUTOMATIC_CALIBRATION_MSK    0x7F
+#define CEC_SELECT_FRO_CLOCK_SOURCE      0x11
+#define CEC_ENABLE_CEC_CLK_MSK           0x80
+#define CEC_ENABLE_FRO_MSK               0xBF
+#define CEC_ENABLE_CALIBRATION           0x01
+#define CEC_DISABLE_CALIBRATION          0x00
+
+#endif  /* TMFL_TDA9989 */
+
+/*!
+ *   \enum  CEC Stack Processor Regsiters
+ *   \brief The CSP is controlled via a series of registers
+ * */
+
+enum _e_reg {
+	E_REG_APR   = 0x00, /*!< Address Pointer Regsiter (Write)           */
+	E_REG_CSR   = 0x00, /*!< CSP Status Register (Read)                 */
+	E_REG_CER   = 0x01, /*!< CSP Error Register  (Read)                 */
+	E_REG_CVR   = 0x02, /*!< CSP Version Register(Read)                 */
+	E_REG_CCR   = 0x03, /*!< CSP Control Register (Read/Write)          */
+	E_REG_ACKH  = 0x04, /*!< CEC Address ACK High Register (Read/Write) */
+	E_REG_ACKL  = 0x05, /*!< CEC Address ACK Low Register (Read/Write)  */
+	E_REG_CCONR = 0x06, /*!< CEC Config Register (Read/Write)           */
+	E_REG_CDR0  = 0x07, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR1  = 0x08, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR2  = 0x09, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR3  = 0x0A, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR4  = 0x0B, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR5  = 0x0C, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR6  = 0x0D, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR7  = 0x0E, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR8  = 0x0F, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR9  = 0x10, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR10 = 0x11, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR11 = 0x12, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR12 = 0x13, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR13 = 0x14, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR14 = 0x15, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR15 = 0x16, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR16 = 0x17, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR17 = 0x18, /*!< CEC Data Register (Read/Write)             */
+	E_REG_CDR18 = 0x19 /*!< CEC Data Register (Read/Write)             */
+};
+
+/* possible states of the state driver */
+typedef enum {
+	CEC_STATE_NOT_INITIALIZED, /**< Driver is not initialized */
+	CEC_STATE_UNLOCKED ,       /**< Driver is not locked */
+	CEC_STATE_LOCKED,          /**< Driver is locked */
+	CEC_STATE_CONFIGURED       /**< Driver is configured */
+} dl_hdmi_cec_driver_state_t;
+
+/**
+ * \brief The structure of a CEC object, one per device unit
+ * */
+typedef struct {
+	instance_t                  instance;
+	dl_hdmi_ceclogical_address_t   device_logical_address;
+	/**< is unit instanciated ? */
+	bool                          opened;
+	/**< Version of the HW device */
+	dl_hdmi_cec_device_version_t    device_version;
+	/**< Current state of the driver */
+	dl_hdmi_cec_driver_state_t      state;
+	/**< Message callback */
+	ptmdl_hdmi_cec_callback_func_t    message_callback;
+} dl_hdmi_cec_unit_config_t;
+
+/**
+ * \brief States of CEC Status
+ * */
+#define CEC_MSG_SUCCESS	    			0x00	/*Message transmisson Succeed*/
+#define CEC_CSP_OFF_STATE   			0x80	/*CSP in Off State*/
+#define CEC_BAD_REQ_SERVICE 			0x81	/*Bad .req service*/
+#define CEC_MSG_FAIL_UNABLE_TO_ACCESS	0x82	/*Message transmisson failed: Unable to access CEC line*/
+#define CEC_MSG_FAIL_ARBITRATION_ERROR	0x83	/*Message transmisson failed: Arbitration error*/
+#define CEC_MSG_FAIL_BIT_TIMMING_ERROR	0x84	/*Message transmisson failed: Bit timming error*/
+#define CEC_MSG_FAIL_DEST_NOT_ACK		0x85	/*Message transmisson failed: Destination Address not aknowledged*/
+#define CEC_MSG_FAIL_DATA_NOT_ACK		0x86	/*Message transmisson failed: Databyte not acknowledged*/
+
+/*============================================================================*/
+/*                       EXTERN DATA DEFINITION                               */
+/*============================================================================*/
+
+extern dl_hdmi_cec_driver_config_table_t gtmdl_hdmi_cec_driver_config_table[MAX_UNITS];
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+error_code_t    get_cec_hw_registers(dl_hdmi_cec_driver_config_table_t *p_dis,
+                                     u8  reg_addr,
+                                     u8 *p_data, u16 len_data);
+error_code_t    get_cec_hw_register(dl_hdmi_cec_driver_config_table_t *p_dis,
+                                    u8  reg_addr,
+                                    u8 *p_reg_value);
+error_code_t    set_cec_hw_registers(dl_hdmi_cec_driver_config_table_t *p_dis,
+                                     u8  reg_addr,
+                                     u8 *p_data, u16 len_data);
+error_code_t    set_cec_hw_register_msb_lsb(dl_hdmi_cec_driver_config_table_t *p_dis,
+        u8  reg_addr,
+        u16 reg_word);
+error_code_t    set_cec_hw_register(dl_hdmi_cec_driver_config_table_t *p_dis,
+                                    u8  reg_addr,
+                                    u8 reg_value);
+error_code_t    set_cec_hw_register_field(dl_hdmi_cec_driver_config_table_t *p_dis,
+        u8  reg_addr,
+        u8 field_mask, u8 field_value);
+
+#endif /* DLHDMI_CEC_LOCAL_H */
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.c b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.c
new file mode 100755
index 0000000..fe98e93
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.c
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_IW.c
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 07/08/07 16:00 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * TDA998x Driver - FRS.doc,
+ * TDA998x Driver - tx - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: tx_IW.c $
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 07/08/07   Time: 16:00
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#define _WIN32_WINNT 0x0500
+
+#ifndef WINDOWS_QMORE
+#include "windows.h"
+#endif
+
+#include "tmNxTypes.h"
+#include "tmNxCompId.h"
+#include "tmdlHdmiTx_Types.h"
+#include "tmdlHdmiTx_cfg.h"
+#include "tmdlHdmiTx_IW.h"
+
+/*============================================================================*/
+/*                       DEFINES                                              */
+/*============================================================================*/
+
+/* maximum number of tasks that can be handled by the wrapper */
+#define MAX_TASKS  5
+/* maximum number of message queues that can be handled by the wrapper */
+#define MAX_QUEUES 5
+
+/*============================================================================*/
+/*                                MACRO                                       */
+/*============================================================================*/
+
+/* macro for quick error handling */
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+
+/*============================================================================*/
+/*                       TYPE DEFINITIONS                                     */
+/*============================================================================*/
+
+/* structure describing each task handled by the wrapper */
+typedef struct {
+	bool                    created;
+	bool                    started;
+	u8                   priority;
+	u16                  stack_size;
+	DWORD                   thread_id;
+	HANDLE                  thread_handle;
+	LPTHREAD_START_ROUTINE  associated_thread;
+	tx_iwfunc_ptr_t   associated_task;
+} iw_tcb_t;
+
+/* structure describing each message queue handled by the wrapper */
+typedef struct {
+	bool    created;
+	HANDLE  access_semaphore;
+	HANDLE  count_semaphore;
+	u16  queue_fullness;
+	u16  queue_size;
+	u16  write_pointer;
+	u16  read_pointer;
+	u8  *queue;
+} iw_queue_t;
+
+/*============================================================================*/
+/*                       FUNCTION PROTOTYPES                                  */
+/*============================================================================*/
+
+DWORD WINAPI thread_proc0(LPVOID lp_parameter);
+DWORD WINAPI thread_proc1(LPVOID lp_parameter);
+DWORD WINAPI thread_proc2(LPVOID lp_parameter);
+DWORD WINAPI thread_proc3(LPVOID lp_parameter);
+DWORD WINAPI thread_proc4(LPVOID lp_parameter);
+
+/*============================================================================*/
+/*                       VARIABLES                                            */
+/*============================================================================*/
+
+/* table storing all tasks descriptions */
+iw_tcb_t task_table[MAX_TASKS] = {
+	{false, false, 0, 0, 0, NULL, thread_proc0},
+	{false, false, 0, 0, 0, NULL, thread_proc1},
+	{false, false, 0, 0, 0, NULL, thread_proc2},
+	{false, false, 0, 0, 0, NULL, thread_proc3},
+	{false, false, 0, 0, 0, NULL, thread_proc4}
+};
+
+/* table storing all message queues descriptions */
+iw_queue_t queue_table[MAX_QUEUES] = {
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL},
+	{false, 0, 0, 0, 0, 0, 0, NULL}
+};
+
+/*============================================================================*/
+/*                                  FUNCTION                                  */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief  This function creates a task and allocates all the necessary resources.
+ *            Note that creating a task do not start it automatically,
+ *            an explicit call to txIWTaskStart must be made.
+ *
+ *    \param  pFunc        Pointer to the function that will be executed in the task context.
+ *    \param  Priority     Priority of the task. The minimum priority is 0, the maximum is 255.
+ *    \param  StackSize    Size of the stack to allocate for this task.
+ *    \param  pHandle      Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_create
+(
+    tx_iwfunc_ptr_t       p_func,
+    u8                       priority,
+    u16                      stack_size,
+    tx_iwtask_handle_t    *p_handle
+)
+{
+	u32 i;
+
+	/* check that input pointer is not NULL */
+	RETIF(p_func == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* search for available task slot */
+	for(i = 0; i < MAX_TASKS; i++) {
+		if(task_table[i].created == false)
+			break;
+
+	}
+	RETIF(i >= MAX_TASKS, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* store task parameters into the dedicated structure */
+	task_table[i].priority = priority;
+	task_table[i].stack_size = stack_size;
+	task_table[i].associated_task = p_func;
+	task_table[i].created = true;
+
+	*p_handle = (tx_iwtask_handle_t)i;
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function destroys an existing task and frees resources used by it.
+ *
+ *    \param  Handle  Handle of the task to be destroyed, as returned by
+ *                    txIWTaskCreate.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_destroy
+(
+    tx_iwtask_handle_t handle
+)
+{
+	/* check if handle number is in range */
+	RETIF((handle < 0) || (handle >= MAX_TASKS), ERR_DLHDMITX_BAD_HANDLE)
+
+	/* check if handle corresponding to task is created */
+	RETIF(task_table[handle].created == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	if(task_table[handle].started == true) {
+		terminate_thread(task_table[handle].thread_handle, 0);
+		task_table[handle].started = false;
+	}
+	task_table[handle].created = false;
+	close_handle(task_table[handle].thread_handle);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function start an existing task.
+ *
+ *    \param  Handle  Handle of the task to be started.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_ALREADY_STARTED: the function is already started
+ *            - ERR_DLHDMITX_NOT_STARTED: the function is not started
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_start
+(
+    tx_iwtask_handle_t handle
+)
+{
+	HANDLE thread_handle;
+
+	/* check if handle number is in range */
+	RETIF((handle < 0) || (handle >= MAX_TASKS), ERR_DLHDMITX_BAD_HANDLE)
+
+	/* check if task is already started */
+	RETIF(task_table[handle].started == true, ERR_DLHDMITX_ALREADY_STARTED)
+
+	/* start thread associated to the task */
+	thread_handle = create_thread(NULL,
+	                              (SIZE_T)task_table[handle].stack_size,
+	                              task_table[handle].associated_thread,
+	                              NULL,
+	                              0,
+	                              &(task_table[handle].thread_id));
+
+	/* check return code for errors */
+	RETIF(!thread_handle, ERR_DLHDMITX_NOT_STARTED)
+
+	/* set the priority task */
+	set_thread_priority(thread_handle, (int)task_table[handle].priority);
+
+	/* update task status */
+	task_table[handle].thread_handle = thread_handle;
+	task_table[handle].started = true;
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function blocks the current task for the specified amount time.
+ *            This is a passive wait.
+ *
+ *    \param  Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait
+(
+    u16 duration
+)
+{
+	HANDLE        timer_handle;
+	LARGE_INTEGER time;
+
+	timer_handle = create_waitable_timer(NULL, true, NULL);
+	RETIF(timer_handle == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	time.quad_part = -10000 * (long)duration;
+	set_waitable_timer(timer_handle, &time, 0, NULL, NULL, false);
+	wait_for_single_object(timer_handle, INFINITE);
+
+	close_handle(timer_handle);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function creates a message queue.
+ *
+ *    \param  QueueSize   Maximum number of messages in the message queue.
+ *    \param  pHandle     Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_create
+(
+    u8                       queue_size,
+    tx_iwqueue_handle_t   *p_handle
+)
+{
+	u32 i;
+
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* search for available queue slot */
+	for(i = 0; i < MAX_QUEUES; i++) {
+		if(queue_table[i].created == false)
+			break;
+
+	}
+
+	RETIF(i >= MAX_QUEUES, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* allocate memory for the queue */
+	queue_table[i].queue = (u8 *)global_alloc(GMEM_FIXED, queue_size);
+	RETIF(queue_table[i].queue == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* allocate semaphores for the queue */
+	queue_table[i].count_semaphore = create_semaphore(NULL, 0, queue_size, NULL);
+	RETIF(queue_table[i].count_semaphore == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	queue_table[i].access_semaphore = create_semaphore(NULL, 1, 1, NULL);
+	RETIF(queue_table[i].access_semaphore == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* update status of the queue table */
+	queue_table[i].created = true;
+	queue_table[i].queue_size = queue_size;
+	*p_handle = (tx_iwqueue_handle_t)i;
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function destroys an existing message queue.
+ *
+ *    \param  Handle  Handle of the queue to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_destroy
+(
+    tx_iwqueue_handle_t handle
+)
+{
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMITX_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	global_free((LPVOID)queue_table[handle].queue);
+	close_handle(queue_table[handle].count_semaphore);
+	close_handle(queue_table[handle].access_semaphore);
+	queue_table[handle].created = false;
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function sends a message into the specified message queue.
+ *
+ *    \param  Handle  Handle of the queue that will receive the message.
+ *    \param  Message Message to be sent.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_send
+(
+    tx_iwqueue_handle_t   handle,
+    u8                       message
+)
+{
+	error_code_t error_code = 0;
+
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMITX_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created != true, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	/* ask for exclusive access to this queue */
+	wait_for_single_object(queue_table[handle].access_semaphore, INFINITE);
+
+	if(queue_table[handle].queue_fullness < (queue_table[handle].queue_size - 1)) {
+		queue_table[handle].queue[queue_table[handle].write_pointer] = message;
+		queue_table[handle].queue_fullness++;
+		queue_table[handle].write_pointer++;
+		if(queue_table[handle].write_pointer == queue_table[handle].queue_size) {
+			queue_table[handle].write_pointer = 0;
+		}
+		release_semaphore(queue_table[handle].count_semaphore, 1, NULL);
+	} else {
+		error_code = ERR_DLHDMITX_FULL;
+	}
+
+	/* release access to this queue */
+	release_semaphore(queue_table[handle].access_semaphore, 1, NULL);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function reads a message from the specified message queue.
+ *
+ *    \param  Handle      Handle of the queue from which to read the message.
+ *    \param  pMessage    Pointer to the message buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_receive
+(
+    tx_iwqueue_handle_t handle, u8 *p_message
+)
+{
+	/* check that handle is correct */
+	RETIF(handle > MAX_QUEUES, ERR_DLHDMITX_BAD_HANDLE)
+
+	RETIF(queue_table[handle].created != true, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	/* check that input pointer is not NULL */
+	RETIF(p_message == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* ask for a new message by acquiring the counting semaphore */
+	wait_for_single_object(queue_table[handle].count_semaphore, INFINITE);
+
+	/* if we reach this point, this means that we got a message */
+	/* ask for exclusive access to this queue */
+	wait_for_single_object(queue_table[handle].access_semaphore, INFINITE);
+
+	*p_message = queue_table[handle].queue[queue_table[handle].read_pointer];
+	queue_table[handle].queue_fullness--;
+	queue_table[handle].read_pointer++;
+	if(queue_table[handle].read_pointer == queue_table[handle].queue_size) {
+		queue_table[handle].read_pointer = 0;
+	}
+
+	/* release access to this queue */
+	release_semaphore(queue_table[handle].access_semaphore, 1, NULL);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function creates a semaphore.
+ *
+ *    \param  pHandle Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create
+(
+    tx_iwsem_handle_t *p_handle
+)
+{
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	*p_handle = (tx_iwsem_handle_t)create_semaphore(NULL, 1, 1, NULL);
+
+	RETIF((*p_handle) == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function destroys an existing semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy
+(
+    tx_iwsem_handle_t handle
+)
+{
+	RETIF(close_handle(handle) == false, ERR_DLHDMITX_BAD_HANDLE)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function acquires the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p
+(
+    tx_iwsem_handle_t handle
+)
+{
+	RETIF(wait_for_single_object(handle, INFINITE) != WAIT_OBJECT_0, ERR_DLHDMITX_BAD_HANDLE)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function releases the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v
+(
+    tx_iwsem_handle_t handle
+)
+{
+	RETIF(release_semaphore(handle, 1, NULL) == 0, ERR_DLHDMITX_BAD_HANDLE)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function disables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwdisable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+	device;
+}
+
+/******************************************************************************
+ *    \brief  This function enables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwenable_interrupts(dl_hdmi_iwdevice_interrupt_t device)
+{
+	device;
+}
+
+/******************************************************************************/
+DWORD WINAPI thread_proc0(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[0].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[0].started = false;
+
+	return(0);
+}
+
+/******************************************************************************/
+DWORD WINAPI thread_proc1(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[1].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[1].started = false;
+
+	return(0);
+}
+
+/******************************************************************************/
+DWORD WINAPI thread_proc2(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[2].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[2].started = false;
+
+	return(0);
+}
+
+/******************************************************************************/
+DWORD WINAPI thread_proc3(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[3].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[3].started = false;
+
+	return(0);
+}
+
+DWORD WINAPI thread_proc4(LPVOID lp_parameter)
+{
+	/* dummy reference to avoid compilation warning C4100 */
+	lp_parameter;
+
+	/* call the registered task */
+	task_table[4].associated_task();
+	/* if we reach this point, the task is terminated, so update its status */
+	task_table[4].started = false;
+
+	return(0);
+}
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.h b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.h
new file mode 100755
index 0000000..30c1d52
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_IW.h
@@ -0,0 +1,281 @@
+/**
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_IW.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 07/08/07 16:00 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * TDA998x Driver - FRS.doc,
+ * TDA998x Driver - tx - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: tx_IW.h $
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 07/08/07   Time: 16:00
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef DLHDMITX_IW_H
+#define DLHDMITX_IW_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#ifdef TMFL_OS_WINDOWS
+#define _WIN32_WINNT 0x0500
+#include "windows.h"
+#endif
+
+#include "tmNxTypes.h"
+#include "tmdlHdmiTx_Types.h"
+
+/*============================================================================*/
+/*                       TYPE DEFINITIONS                                     */
+/*============================================================================*/
+typedef void (*tx_iwfunc_ptr_t)(void);
+typedef u8 tx_iwtask_handle_t;
+typedef u8 tx_iwqueue_handle_t;
+#ifdef __LINUX_ARM_ARCH__ /* AL */
+typedef unsigned long tx_iwsem_handle_t;
+#else
+#ifdef TMFL_OS_WINDOWS
+typedef HANDLE tx_iwsem_handle_t;
+#else
+typedef u8 tx_iwsem_handle_t;
+#endif
+#endif
+
+/**
+ * \brief Enum listing all available devices for enable/disable interrupts
+ * */
+typedef enum {
+	DL_HDMI_IW_RX_1,
+	DL_HDMI_IW_RX_2,
+	DL_HDMI_IW_TX_1,
+	DL_HDMI_IW_TX_2,
+	DL_HDMI_IW_CEC_1,
+	DL_HDMI_IW_CEC_2
+} dl_hdmi_iwdevice_interrupt_t;
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief  This function creates a task and allocates all the necessary
+ *            resources. Note that creating a task do not start it automatically,
+ *            an explicit call to txIWTaskStart must be made.
+ *
+ *    \param  pFunc       Pointer to the function that will be executed in the task context.
+ *    \param  Priority    Priority of the task. The minimum priority is 0, the maximum is 255.
+ *    \param  StackSize   Size of the stack to allocate for this task.
+ *    \param  pHandle     Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_create(tx_iwfunc_ptr_t p_func, u8 priority, u16 stack_size, tx_iwtask_handle_t *p_handle);
+
+/******************************************************************************
+ *    \brief  This function destroys an existing task and frees resources used by it.
+ *
+ *    \param  Handle  Handle of the task to be destroyed, as returned by txIWTaskCreate.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_destroy(tx_iwtask_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function start an existing task.
+ *
+ *    \param  Handle  Handle of the task to be started.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_ALREADY_STARTED: the function is already started
+ *            - ERR_DLHDMITX_NOT_STARTED: the function is not started
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwtask_start(tx_iwtask_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function blocks the current task for the specified amount time. This is a passive wait.
+ *
+ *    \param  Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait(u16 duration);
+
+/******************************************************************************
+ *    \brief  This function creates a message queue.
+ *
+ *    \param  QueueSize   Maximum number of messages in the message queue.
+ *    \param  pHandle     Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_create(u8 queue_size, tx_iwqueue_handle_t *p_handle);
+
+/******************************************************************************
+ *    \brief  This function destroys an existing message queue.
+ *
+ *    \param  Handle  Handle of the queue to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_destroy(tx_iwqueue_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function sends a message into the specified message queue.
+ *
+ *    \param  Handle  Handle of the queue that will receive the message.
+ *    \param  Message Message to be sent.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_send(tx_iwqueue_handle_t handle, u8 message);
+
+/******************************************************************************
+ *    \brief  This function reads a message from the specified message queue.
+ *
+ *    \param  Handle      Handle of the queue from which to read the message.
+ *    \param  pMessage    Pointer to the message buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwqueue_receive(tx_iwqueue_handle_t handle, u8 *p_message);
+
+/******************************************************************************
+ *    \brief  This function creates a semaphore.
+ *
+ *    \param  pHandle Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create(tx_iwsem_handle_t *p_handle);
+
+/******************************************************************************
+ *    \brief  This function destroys an existing semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy(tx_iwsem_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function acquires the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p(tx_iwsem_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function releases the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v(tx_iwsem_handle_t handle);
+
+/******************************************************************************
+ *    \brief  This function disables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwdisable_interrupts(dl_hdmi_iwdevice_interrupt_t device);
+
+/******************************************************************************
+ *    \brief  This function enables the interrupts for a specific device.
+ *
+ *    \param
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+void tx_iwenable_interrupts(dl_hdmi_iwdevice_interrupt_t device);
+
+#endif /* DLHDMITX_IW_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_Linux.c b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_Linux.c
new file mode 100755
index 0000000..271a61d
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_Linux.c
@@ -0,0 +1,924 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_cfg.c
+ *
+ * \version       Revision: 1
+ *
+ * \date          Date: 08/08/07 11:00
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   History:       tx_cfg.c
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 08/08/07  Time: 11:00
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                             INCLUDE FILES                                  */
+/*============================================================================*/
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+
+#include "tmdlHdmiTx_IW.h"
+#include "tmNxTypes.h"
+#include "tmdlHdmiTx.h"
+#include "tmdlHdmiTx_cfg.h"
+
+#include "tmbslHdmiTx.h"
+
+#define I2C_M_WR 0
+
+struct i2c_client *get_this_i2c_client(void);
+unsigned char  my_i2c_data[255];
+
+/*============================================================================*/
+/*                          INTERNAL PROTOTYPE                                */
+/*============================================================================*/
+
+error_code_t tx_i2c_read_function(bsl_sys_args_t *p_sys_args);
+error_code_t tx_i2c_write_function(bsl_sys_args_t *p_sys_args);
+error_code_t tda9983_edid_read(bsl_sys_args_edid_t *p_arg);
+
+/*============================================================================*/
+/*                                MACRO                                       */
+/*============================================================================*/
+
+/* macro for quick error handling */
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+
+/* I2C adress of the unit */
+#define UNIT_I2C_ADDRESS_0 0x70
+
+/* I2C adress of the unit */
+#define UNIT_I2C_ADDRESS_1 0x71
+
+/* Resolution supported */
+#ifndef FORMAT_PC
+#define RESOLUTION_NB   34
+#else
+#define RESOLUTION_NB   61
+#endif /* FORMAT_PC */
+
+/* HDCP key */
+#define KEY_SEED    0x1234
+
+/* Audio port configuration, bitn = 1 to enable port n, = 0 to disable port n */
+#define ENABLE_ALL_AUDIO_PORT       0xFF
+
+/* Audio clock port configuration */
+#define ENABLE_AUDIO_CLOCK_PORT     true
+#define DISABLE_AUDIO_CLOCK_PORT    false
+
+/* Audio port configuration, bitn = 1 to pulldown port n, = 0 to pulldown port n */
+#define DISABLE_ALL_AUDIO_PORT_PULLDOWN 0x00
+
+/* Audio clock port pulldown configuration */
+#define ENABLE_AUDIO_CLOCK_PORT_PULLDOWN    true
+#define DISABLE_AUDIO_CLOCK_PORT_PULLDOWN   false
+
+/*============================================================================*/
+/*                        DEFINES DECLARATIONS                                */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       VARIABLES DECLARATIONS                               */
+/*============================================================================*/
+
+/**
+ * \brief List of the resolution to be detected by the device library
+ * */
+
+const tx_cfg_resolution_t resolution_info_tx[RESOLUTION_NB] = {
+	/* TV Formats */
+	/* 60 HZ */
+	{dl_hdmitx_vfmt_01_640x480p_60hz,     640,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_02_720x480p_60hz,     720,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_03_720x480p_60hz,     720,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_04_1280x720p_60hz,    1280,  720,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_05_1920x1080i_60hz,   1920,  1080,   true,   dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_06_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_07_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_08_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_09_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_10_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_11_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_12_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_13_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_14_1440x480p_60hz,    1440,  480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_15_1440x480p_60hz,    1440,  480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_16_1920x1080p_60hz,   1920,  1080,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	/* 50 HZ */
+	{dl_hdmitx_vfmt_17_720x576p_50hz,     720,   576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_18_720x576p_50hz,     720,   576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_19_1280x720p_50hz,    1280,  720,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_20_1920x1080i_50hz,   1920,  1080,   true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_21_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_22_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_23_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_24_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_25_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_26_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_27_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_28_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_29_1440x576p_50hz,    1440,  576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_30_1440x576p_50hz,    1440,  576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_31_1920x1080p_50hz,   1920,  1080,   false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_32_1920x1080p_24hz,   1920,  1080,   false,  dl_hdmitx_vfreq_24hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_33_1920x1080p_25hz,   1920,  1080,   false,  dl_hdmitx_vfreq_25hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_34_1920x1080p_30hz,   1920,  1080,   false,  dl_hdmitx_vfreq_30hz, DL_HDMITX_P_ASPECT_RATIO_16_9}
+#ifdef FORMAT_PC
+	/* PC Formats */
+	/* 60 HZ */
+	, {dl_hdmitx_vfmt_pc_640x480p_60hz,     640,   480,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_60hz,     800,   600,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1152x960p_60hz,    1152,  960,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_6_5},
+	{dl_hdmitx_vfmt_pc_1024x768p_60hz,    1024,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x768p_60hz,    1280,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_5_3},
+	{dl_hdmitx_vfmt_pc_1280x1024p_60hz,   1280,  1024,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	{dl_hdmitx_vfmt_pc_1360x768p_60hz,    1360,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_pc_1400x1050p_60hz,   1400,  1050,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1600x1200p_60hz,   1600,  1200,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 70 HZ */
+	{dl_hdmitx_vfmt_pc_1024x768p_70hz,    1024,  768,    false,  dl_hdmitx_vfreq_70hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 72 HZ */
+	{dl_hdmitx_vfmt_pc_640x480p_72hz,     640,   480,    false,  dl_hdmitx_vfreq_72hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_72hz,     800,   600,    false,  dl_hdmitx_vfreq_72hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 75 HZ */
+	{dl_hdmitx_vfmt_pc_640x480p_75hz,     640,   480,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x768p_75hz,    1024,  768,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_75hz,     800,   600,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x864p_75hz,    1024,  864,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_UNDEFINED},
+	{dl_hdmitx_vfmt_pc_1280x1024p_75hz,   1280,  1024,   false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	/* 85 HZ */
+	{dl_hdmitx_vfmt_pc_640x350p_85hz,     640,   350,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_UNDEFINED},
+	{dl_hdmitx_vfmt_pc_640x400p_85hz,     640,   400,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_16_10},
+	{dl_hdmitx_vfmt_pc_720x400p_85hz,     720,   400,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_9_5},
+	{dl_hdmitx_vfmt_pc_640x480p_85hz,     640,   480,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_85hz,     800,   600,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x768p_85hz,    1024,  768,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1152x864p_85hz,    1152,  864,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x960p_85hz,    1280,  960,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x1024p_85hz,   1280,  1024,   false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	/* 87 HZ */
+	{dl_hdmitx_vfmt_pc_1024x768i_87hz,    1024,  768,    true,   dl_hdmitx_vfreq_87hz, DL_HDMITX_P_ASPECT_RATIO_4_3}
+#endif /* FORMAT_PC */
+};
+
+const tx_cfg_video_signal444 video_port_mapping_yuv444[MAX_UNITS][6] = {
+	{
+		DL_HDMITX_VID444_BU_0_TO_3,   /* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID444_BU_4_TO_7,   /* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID444_GY_0_TO_3,   /* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID444_GY_4_TO_7,   /* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID444_VR_0_TO_3,   /* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID444_VR_4_TO_7    /* Signals connected to VPC[4..7] */
+	}
+};
+
+const tx_cfg_video_signal444 video_port_mapping_rgb444[MAX_UNITS][6] = {
+	{
+		DL_HDMITX_VID444_BU_0_TO_3,   /* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID444_BU_4_TO_7,   /* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID444_GY_0_TO_3,   /* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID444_GY_4_TO_7,   /* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID444_VR_0_TO_3,   /* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID444_VR_4_TO_7    /* Signals connected to VPC[4..7] */
+	}
+};
+
+const tx_cfg_video_signal422 video_port_mapping_yuv422[MAX_UNITS][6] = {
+
+	{
+		/* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID422_Y_4_TO_7,
+		/* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID422_Y_8_TO_11,
+		/* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID422_UV_4_TO_7,
+		/* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID422_UV_8_TO_11,
+		/* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID422_NOT_CONNECTED,
+		/* Signals connected to VPC[4..7] */
+		DL_HDMITX_VID422_NOT_CONNECTED
+	}
+};
+
+const tx_cfg_video_signal_ccir656 video_port_mapping_ccir656[MAX_UNITS][6] = {
+	{
+		/* Signals connected to VPA[0..3] */
+		DL_HDMITX_VIDCCIR_4_TO_7,
+		/* Signals connected to VPA[4..7] */
+		DL_HDMITX_VIDCCIR_8_TO_11,
+		/* Signals connected to VPB[0..3] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPB[4..7] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPC[0..3] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPC[4..7] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED
+	}
+};
+
+/* Audio port configuration for SPDIF                                         */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortSPDIF and groundAudioPortSPDIF should be filled with a      */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortSPDIF and groundAudioClockPortSPDIF can be configured  */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+u8 enable_audio_port_spdif[MAX_UNITS]      = {0x40};
+u8 enable_audio_clock_port_spdif[MAX_UNITS] = {DISABLE_AUDIO_CLOCK_PORT};
+u8 ground_audio_port_spdif[MAX_UNITS]      = {0xBF};
+u8 ground_audio_clock_port_spdif[MAX_UNITS] = {ENABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for I2S                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortI2S and groundAudioPortI2S should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortI2S and groundAudioClockPortI2S can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+u8 enable_audio_port_i2s[MAX_UNITS]        = {0x03};
+u8 enable_audio_port_i2s8c[MAX_UNITS]      = {0x1F};
+u8 enable_audio_clock_port_i2s[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+u8 ground_audio_port_i2s[MAX_UNITS]        = {0xFC};
+u8 ground_audio_port_i2s8c[MAX_UNITS]      = {0xE0};
+u8 ground_audio_clock_port_i2s[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for OBA                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortOBA and groundAudioPortOBA should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortOBA and groundAudioClockPortOBA can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+u8 enable_audio_port_oba[MAX_UNITS]        = {0xFF};
+u8 enable_audio_clock_port_oba[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+u8 ground_audio_port_oba[MAX_UNITS]        = {0x00};
+u8 ground_audio_clock_port_oba[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for DST                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortDST and groundAudioPortDST should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortDST and groundAudioClockPortDST can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+u8 enable_audio_port_dst[MAX_UNITS]        = {0xFF};
+u8 enable_audio_clock_port_dst[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+u8 ground_audio_port_dst[MAX_UNITS]        = {0x00};
+u8 ground_audio_clock_port_dst[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for HBR                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortHBR and groundAudioPortHBR should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortHBR and groundAudioClockPortHBR can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+u8 enable_audio_port_hbr[MAX_UNITS]        = {0x1F};
+u8 enable_audio_clock_port_hbr[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+u8 ground_audio_port_hbr[MAX_UNITS]        = {0xE0};
+u8 ground_audio_clock_port_hbr[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Do not modify, those tables are filled dynamically by dlHdmiTxGenerateCfgVideoPortTables API */
+u8 mirror_table_ccir656[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 swap_table_ccir656[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 enable_video_port_ccir656[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+u8 ground_video_port_ccir656[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+u8 mirror_table_yuv422[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 swap_table_yuv422[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 enable_video_port_yuv422[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+u8 ground_video_port_yuv422[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+u8 mirror_table_yuv444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 swap_table_yuv444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 enable_video_port_yuv444[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+u8 ground_video_port_yuv444[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+u8 mirror_table_rgb444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 swap_table_rgb444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+u8 enable_video_port_rgb444[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+u8 ground_video_port_rgb444[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+
+/**
+ * \brief Configuration Tables. This table can be modified by the customer
+ *            to choose its prefered configuration.
+ * */
+tx_driver_config_table_t driver_config_table_tx[MAX_UNITS] = {
+	{
+		250 ,/* COMMAND_TASK_PRIORITY_0 */
+		128 ,/* COMMAND_TASK_STACKSIZE_0 */
+		128 ,/* COMMAND_TASK_QUEUESIZE_0 */
+		250 ,/* HDCP_CHECK_TASK_PRIORITY_0 */
+		128 ,/* HDCP_CHECK_TASK_STACKSIZE_0 */
+		UNIT_I2C_ADDRESS_0,
+		tx_i2c_read_function,
+		tx_i2c_write_function,
+		tda9983_edid_read,
+		NULL,                           /* filled dynamically, do not modify */
+		RESOLUTION_NB,
+		/* filled dynamically, do not modify */
+		&mirror_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_rgb444[0][0],
+		&enable_audio_port_spdif[0],
+		&ground_audio_port_spdif[0],
+		&enable_audio_clock_port_spdif[0],
+		&ground_audio_clock_port_spdif[0],
+		&enable_audio_port_i2s[0],
+		&ground_audio_port_i2s[0],
+		&enable_audio_port_i2s8c[0],
+		&ground_audio_port_i2s8c[0],
+		&enable_audio_clock_port_i2s[0],
+		&ground_audio_clock_port_i2s[0],
+		&enable_audio_port_oba[0],
+		&ground_audio_port_oba[0],
+		&enable_audio_clock_port_oba[0],
+		&ground_audio_clock_port_oba[0],
+		&enable_audio_port_dst[0],
+		&ground_audio_port_dst[0],
+		&enable_audio_clock_port_dst[0],
+		&ground_audio_clock_port_dst[0],
+		&enable_audio_port_hbr[0],
+		&ground_audio_port_hbr[0],
+		&enable_audio_clock_port_hbr[0],
+		&ground_audio_clock_port_hbr[0],
+		KEY_SEED,
+		DL_HDMITX_PATTERN_BLUE
+	}
+};
+
+/*
+ *
+ * Linux wrapping starts here...............................
+ *
+ * */
+
+/*
+ *  Write a bloc to a register in Tx device.
+ * */
+int blockwrite_reg(struct i2c_client *client,
+                   u8 reg, u16 alength, u8 *val)
+{
+	int err = 0, i;
+	struct i2c_msg msg[1];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = alength + 1;
+	msg->buf = my_i2c_data;
+
+	msg->buf[0] = reg;
+	for(i = 1; i <= alength; i++) msg->buf[i] = (*val++);
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	udelay(50);
+
+	/*    printk(KERN_INFO "DBG blockwrite_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
+
+	/*    dev_dbg(&client->dev, "<%s> i2c Block write at 0x%x, " */
+	/*            "*val=%d flags=%d byte[%d] err=%d\n", */
+	/*            __func__, data[0], data[1], msg->flags, i, err); */
+	return (err < 0 ? err : 0);
+}
+
+/*
+ *  Read a bloc to a register in Tx device.
+ * */
+int blockread_reg(struct i2c_client *client,
+                  u8 reg, u16 alength, u8 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 1;
+	msg->buf = data;
+	data[0] = reg; /* High byte goes out first */
+	err = i2c_transfer(client->adapter, msg, 1);
+	/*    printk(KERN_INFO "DBG blockread_reg #1 addr:%x len:%d buf:%02x%02x%02x%02x %s\n",msg->addr,msg->len,\ */
+	/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3],(err<0?"ERROR":"")); */
+	if(err < 0) goto BLOCK_READ_OUPS;
+
+	msg->flags = I2C_M_RD;
+	msg->len = alength;
+	msg->buf = val;
+	err = i2c_transfer(client->adapter, msg, 1);
+	/*    printk(KERN_INFO "DBG blockread_reg #2 addr:%x len:%d buf:%02x%02x%02x%02x %s\n",msg->addr,msg->len,\ */
+	/*           msg->buf[0],msg->buf[1],msg->buf[2],msg->buf[3],(err<0?"ERROR":"")); */
+
+	if(err < 0) goto BLOCK_READ_OUPS;
+
+	return 0;
+
+BLOCK_READ_OUPS:
+	dev_err(&client->dev, "<%s> ERROR:  i2c read at 0x%x, "
+	        "*val=%d flags=%d bytes err=%d\n",
+	        __func__, reg, *val, msg->flags, err);
+	return err;
+}
+
+/*
+ *  Write a byte to a register in Tx device.
+ * */
+int write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+	int retries = 0;
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+retry:
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 2;
+	msg->buf = data;
+
+	data[0] = reg;
+	data[1] = val;
+
+	err = i2c_transfer(client->adapter, msg, 1);
+	dev_dbg(&client->dev, "<%s> i2c write at=%x "
+	        "val=%x flags=%d err=%d\n",
+	        __func__, data[0], data[1], msg->flags, err);
+	udelay(50);
+
+	/*    printk(KERN_INFO "DBG write_reg addr:%x reg:%d data:%x %s\n",msg->addr,reg,val,(err<0?"ERROR":"")); */
+
+	if(err >= 0)
+		return 0;
+
+	dev_err(&client->dev, "<%s> ERROR: i2c write at=%x "
+	        "val=%x flags=%d err=%d\n",
+	        __func__, data[0], data[1], msg->flags, err);
+	if(retries <= 5) {
+		dev_info(&client->dev, "retrying I2C... %d\n", retries);
+		retries++;
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(20));
+		goto retry;
+	}
+	return err;
+}
+
+/*
+ *  Read a byte from a register in Tx device.
+ * */
+int read_reg(struct i2c_client *client, u16 data_length, u8 reg, u8 *val)
+{
+	int err = 0;
+	struct i2c_msg msg[1];
+	u8 data[2];
+
+	if(!client->adapter) {
+		dev_err(&client->dev, "<%s> ERROR: no HDMI device\n", __func__);
+		return -ENODEV;
+	}
+
+	msg->addr = client->addr;
+	msg->flags = I2C_M_WR;
+	msg->len = 1;
+	msg->buf = data;
+
+	data[0] = reg;
+	err = i2c_transfer(client->adapter, msg, 1);
+	dev_dbg(&client->dev, "<%s> i2c read1 reg=%x val=%d "
+	        "flags=%d err=%d\n",
+	        __func__, reg, data[1], msg->flags, err);
+
+	if(err >= 0) {
+		mdelay(3);
+		msg->flags = I2C_M_RD;
+		msg->len = data_length;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+
+	if(err >= 0) {
+		*val = 0;
+		if(data_length == 1)
+			*val = data[0];
+		else if(data_length == 2)
+			*val = data[1] + (data[0] << 8);
+		dev_dbg(&client->dev, "<%s> i2c read2 at 0x%x, *val=%d "
+		        "flags=%d err=%d\n",
+		        __func__, reg, *val, msg->flags, err);
+		return 0;
+	}
+
+	dev_err(&client->dev, "<%s> ERROR: i2c read at 0x%x, "
+	        "*val=%d flags=%d err=%d\n",
+	        __func__, reg, *val, msg->flags, err);
+	return err;
+}
+
+/* The following function must be rewritten by the customer to fit its own    */
+/* SW infrastructure. This function allows reading through I2C bus.           */
+/* bslSysArgs_t definition is located into bsl_type.h file.   */
+error_code_t tx_i2c_read_function(bsl_sys_args_t *p_sys_args)
+{
+
+	error_code_t err = 0;
+	struct i2c_client *client = get_this_i2c_client();
+	u32 client_main_addr = client->addr;
+
+	/* DevLib needs address control, so let it be */
+	client->addr = p_sys_args->slave_addr;
+
+	if(p_sys_args->len_data == 1) {
+		/* single byte */
+		err = read_reg(get_this_i2c_client(), 1, p_sys_args->first_register, p_sys_args->p_data);
+	} else {
+		/* block */
+		err = blockread_reg(get_this_i2c_client(), \
+		                    p_sys_args->first_register, \
+		                    p_sys_args->len_data, \
+		                    p_sys_args->p_data);
+	}
+
+	/* restore default client address */
+	client->addr = client_main_addr;
+
+	return err;
+}
+
+/* The following function must be rewritten by the customer to fit its own    */
+/* SW infrastructure. This function allows writing through I2C bus.           */
+/* bslSysArgs_t definition is located into bsl_type.h file.   */
+error_code_t tx_i2c_write_function(bsl_sys_args_t *p_sys_args)
+{
+
+	error_code_t err = 0;
+	struct i2c_client *client = get_this_i2c_client();
+	u32 client_main_addr = client->addr;
+
+	/* DevLib needs address control, so let it be */
+	client->addr = p_sys_args->slave_addr;
+
+	if(p_sys_args->len_data == 1) {
+		/* single byte */
+		err = write_reg(get_this_i2c_client(), p_sys_args->first_register, *p_sys_args->p_data);
+	} else {
+		/* block */
+		err = blockwrite_reg(get_this_i2c_client(),  \
+		                     p_sys_args->first_register, \
+		                     p_sys_args->len_data,       \
+		                     p_sys_args->p_data);
+	}
+
+	/* restore default client address */
+	client->addr = client_main_addr;
+
+	return err;
+}
+
+error_code_t tda9983_edid_read(bsl_sys_args_edid_t *p_arg)
+{
+	struct i2c_client *client = get_this_i2c_client();
+	struct i2c_msg msg[3];
+	int index = 0;
+
+	if(p_arg->seg_ptr_addr != 0) {
+		msg[index].addr = (p_arg->seg_ptr_addr >> 1);
+		msg[index].flags = 0;
+		msg[index].len = 1;
+		p_arg->seg_ptr |= 0x01;
+		msg[index].buf = &p_arg->seg_ptr;
+		index++;
+	}
+
+	msg[index].addr = (p_arg->data_reg_addr >> 1);
+	msg[index].flags = 0;
+	msg[index].len = 1;
+	msg[index].buf = &p_arg->word_offset;
+	index++;
+
+	msg[index].addr = (p_arg->data_reg_addr >> 1);
+	msg[index].flags = I2C_M_RD;
+	msg[index].len = p_arg->len_data;
+	msg[index].buf = p_arg->p_data;
+	index++;
+	i2c_transfer(client->adapter, msg, index);
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief  This function blocks the current task for the specified amount time.
+ *            This is a passive wait.
+ *
+ *    \param  Duration    Duration of the task blocking in milliseconds.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *
+ ******************************************************************************/
+error_code_t tx_iwwait
+(
+    u16 duration
+)
+{
+
+	mdelay((unsigned long)duration);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function creates a semaphore.
+ *
+ *    \param  pHandle Pointer to the handle buffer.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_create
+(
+    tx_iwsem_handle_t *p_handle
+)
+{
+	struct semaphore *mutex;
+
+	/* check that input pointer is not NULL */
+	RETIF(p_handle == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	mutex = (struct semaphore *)kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+	if(!mutex) {
+		printk(KERN_ERR "malloc failed in %s\n", __func__);
+		return ERR_DLHDMITX_NO_RESOURCES;
+	}
+
+	init_MUTEX(mutex);
+	*p_handle = (tx_iwsem_handle_t)mutex;
+
+	RETIF(p_handle == NULL, ERR_DLHDMITX_NO_RESOURCES)
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function destroys an existing semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be destroyed.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_destroy
+(
+    tx_iwsem_handle_t handle
+)
+{
+	RETIF(handle == false, ERR_DLHDMITX_BAD_HANDLE);
+
+	if(atomic_read((atomic_t *)&((struct semaphore *)handle)->count) < 1) {
+		printk(KERN_ERR "release catched semaphore");
+	}
+
+	kfree((void *)handle);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function acquires the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be acquired.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_p
+(
+    tx_iwsem_handle_t handle
+)
+{
+
+	down((struct semaphore *)handle);
+
+	return(0);
+}
+
+/******************************************************************************
+ *    \brief  This function releases the specified semaphore.
+ *
+ *    \param  Handle  Handle of the semaphore to be released.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_iwsemaphore_v
+(
+    tx_iwsem_handle_t handle
+)
+{
+	up((struct semaphore *)handle);
+
+	return(0);
+}
+
+/*============================================================================*/
+/*                              FUNCTIONS                                     */
+/*============================================================================*/
+
+/*****************************************************************************
+ ******************************************************************************
+ *                THIS PART MUST NOT BE MODIFIED BY CUSTOMER                  *
+ ******************************************************************************
+ *****************************************************************************/
+
+/******************************************************************************
+ *    \brief  Generate swap and mirror tables in function
+ *            of video port mapping tables.
+ *
+ *    \param unit     Unit identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_generate_cfg_video_port_tables
+(
+    unit_select_t                  unit,
+    tx_driver_config_table_t   *p_config
+)
+{
+	u8   i;
+
+	for(i = 0; i < 6; i++) {
+		/* CCIR656 */
+		if(video_port_mapping_ccir656[unit][i] != DL_HDMITX_VIDCCIR_NOT_CONNECTED) {
+			p_config->p_swap_table_ccir656[video_port_mapping_ccir656[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_ccir656[video_port_mapping_ccir656[unit][i] & 0x07F] = (u8)(video_port_mapping_ccir656[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_ccir656[i/2] |= 0x0F;
+				p_config->p_ground_video_port_ccir656[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_ccir656[i/2] |= 0xF0;
+				p_config->p_ground_video_port_ccir656[i/2] &= 0x0F;
+			}
+		}
+
+		/* YUV422 */
+		if(video_port_mapping_yuv422[unit][i] != DL_HDMITX_VID422_NOT_CONNECTED) {
+			p_config->p_swap_table_yuv422[video_port_mapping_yuv422[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_yuv422[video_port_mapping_yuv422[unit][i] & 0x07F] = (u8)(video_port_mapping_yuv422[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_yuv422[i/2] |= 0x0F;
+				p_config->p_ground_video_port_yuv422[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_yuv422[i/2] |= 0xF0;
+				p_config->p_ground_video_port_yuv422[i/2] &= 0x0F;
+			}
+		}
+
+		/* YUV444 */
+		if(video_port_mapping_yuv444[unit][i] != DL_HDMITX_VID444_NOT_CONNECTED) {
+			p_config->p_swap_table_yuv444[video_port_mapping_yuv444[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_yuv444[video_port_mapping_yuv444[unit][i] & 0x07F] = (u8)(video_port_mapping_yuv444[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_yuv444[i/2] |= 0x0F;
+				p_config->p_ground_video_port_yuv444[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_yuv444[i/2] |= 0xF0;
+				p_config->p_ground_video_port_yuv444[i/2] &= 0x0F;
+			}
+		}
+
+		/* RGB444 */
+		if(video_port_mapping_rgb444[unit][i] != DL_HDMITX_VID444_NOT_CONNECTED) {
+			p_config->p_swap_table_rgb444[video_port_mapping_rgb444[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_rgb444[video_port_mapping_rgb444[unit][i] & 0x07F] = (u8)(video_port_mapping_rgb444[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_rgb444[i/2] |= 0x0F;
+				p_config->p_ground_video_port_rgb444[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_rgb444[i/2] |= 0xF0;
+				p_config->p_ground_video_port_rgb444[i/2] &= 0x0F;
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *    \brief This function allows to the main driver to retrieve its
+ *           configuration parameters.
+ *
+ *    \param pConfig Pointer to the config structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_cfg_get_config
+(
+    unit_select_t                  unit,
+    tx_driver_config_table_t   *p_config
+)
+{
+	/* Check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMITX_BAD_UNIT_NUMBER)
+
+	/* Check if pointer is NULL */
+	RETIF(p_config == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	*p_config = driver_config_table_tx[unit];
+
+	/* Done here because of const declaration of tables in ARM7 case */
+	p_config->p_resolution_info = (ptx_cfg_resolution_t)resolution_info_tx;
+
+	/* Generate swap and mirror tables in function of video port mapping tables */
+	dl_hdmi_tx_generate_cfg_video_port_tables(unit, p_config);
+
+	return 0;
+}
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.c b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.c
new file mode 100755
index 0000000..74ea1bd
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.c
@@ -0,0 +1,797 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_cfg.c
+ *
+ * \version       Revision: 1
+ *
+ * \date          Date: 08/08/07 11:00
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   History:       tx_cfg.c
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 08/08/07  Time: 11:00
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                             INCLUDE FILES                                  */
+/*============================================================================*/
+#include "tmdlHdmiTx_IW.h"
+#include "tmNxTypes.h"
+#include "tmdlHdmiTx.h"
+#include "tmdlHdmiTx_cfg.h"
+
+#ifdef TMFL_OS_WINDOWS      /* OS Windows */
+#include "infra_i2c.h"
+#else                       /* OS ARM7 */
+#include "I2C.h"
+#include <LPC21xx.H>
+#endif                      /* endif TMFL_OS_WINDOWS */
+
+#include "tmbslHdmiTx.h"
+
+/******************************************************************************
+ ******************************************************************************
+ *                 THIS PART CAN BE MODIFIED BY CUSTOMER                      *
+ ******************************************************************************
+ *****************************************************************************/
+
+/*============================================================================*/
+/*                          INTERNAL PROTOTYPE                                */
+/*============================================================================*/
+#ifdef TMFL_OS_WINDOWS  /* OS Windows */
+error_code_t windows_i2c_read_function(bsl_sys_args_t *p_sys_args);
+error_code_t windows_i2c_write_function(bsl_sys_args_t *p_sys_args);
+#else                   /* OS ARM7 */
+error_code_t rtx_tx_i2c_read_function(bsl_sys_args_t *p_sys_args);
+error_code_t rtx_tx_i2c_write_function(bsl_sys_args_t *p_sys_args);
+#endif                  /* endif TMFL_OS_WINDOWS */
+
+error_code_t edid_read_function(bsl_sys_args_edid_t *p_sys_args);
+
+/*============================================================================*/
+/*                                MACRO                                       */
+/*============================================================================*/
+
+/* macro for quick error handling */
+#define RETIF(cond, rslt) if ((cond)){return (rslt);}
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       CONSTANTS DECLARATIONS                               */
+/*============================================================================*/
+
+/* Configuration for unit 0 *************************** */
+/* priority of the command tasks */
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+#define COMMAND_TASK_PRIORITY_0  THREAD_PRIORITY_HIGHEST
+#else                           /* OS ARM7 */
+#define COMMAND_TASK_PRIORITY_0  250
+#endif                          /* endif TMFL_OS_WINDOWS */
+/* stack size of the command tasks */
+#define COMMAND_TASK_STACKSIZE_0 128
+/* size of the message queues for command tasks */
+#define COMMAND_TASK_QUEUESIZE_0 128
+
+/* priority of the hdcp check tasks */
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+#define HDCP_CHECK_TASK_PRIORITY_0  THREAD_PRIORITY_HIGHEST
+#else                           /* OS ARM7 */
+#define HDCP_CHECK_TASK_PRIORITY_0  250
+#endif                          /* endif TMFL_OS_WINDOWS */
+
+/* stack size of the hdcp check tasks */
+#define HDCP_CHECK_TASK_STACKSIZE_0 128
+/* I2C adress of the unit */
+#define UNIT_I2C_ADDRESS_0 0x70
+
+/* Configuration for unit 1 *************************** */
+/* priority of the command tasks */
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+#define COMMAND_TASK_PRIORITY_1  THREAD_PRIORITY_HIGHEST
+#else                           /* OS ARM7 */
+#define COMMAND_TASK_PRIORITY_1  250
+#endif                          /* endif TMFL_OS_WINDOWS */
+/* stack size of the command tasks */
+#define COMMAND_TASK_STACKSIZE_1 128
+/* size of the message queues for command tasks */
+#define COMMAND_TASK_QUEUESIZE_1 128
+
+/* priority of the hdcp check tasks */
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+#define HDCP_CHECK_TASK_PRIORITY_1  THREAD_PRIORITY_HIGHEST
+#else                           /* OS ARM7 */
+#define HDCP_CHECK_TASK_PRIORITY_1  250
+#endif                          /* endif TMFL_OS_WINDOWS */
+
+/* stack size of the hdcp check tasks */
+#define HDCP_CHECK_TASK_STACKSIZE_1 128
+/* I2C adress of the unit */
+#define UNIT_I2C_ADDRESS_1 0x71
+
+/* Resolution supported */
+#ifndef FORMAT_PC
+#define RESOLUTION_NB   34
+#else
+#define RESOLUTION_NB   61
+#endif /* FORMAT_PC */
+
+/* HDCP key */
+#define KEY_SEED    0x1234
+
+/* Audio port configuration, bitn = 1 to enable port n, = 0 to disable port n */
+#define ENABLE_ALL_AUDIO_PORT       0xFF
+
+/* Audio clock port configuration */
+#define ENABLE_AUDIO_CLOCK_PORT     true
+#define DISABLE_AUDIO_CLOCK_PORT    false
+
+/* Audio port configuration, bitn = 1 to pulldown port n, = 0 to pulldown port n */
+#define DISABLE_ALL_AUDIO_PORT_PULLDOWN 0x00
+
+/* Audio clock port pulldown configuration */
+#define ENABLE_AUDIO_CLOCK_PORT_PULLDOWN    true
+#define DISABLE_AUDIO_CLOCK_PORT_PULLDOWN   false
+
+/*============================================================================*/
+/*                        DEFINES DECLARATIONS                                */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                       VARIABLES DECLARATIONS                               */
+/*============================================================================*/
+
+/**
+ * \brief List of the resolution to be detected by the device library
+ * */
+
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+tx_cfg_resolution_t resolution_info_tx[RESOLUTION_NB] = {
+#else                           /* OS ARM7 */
+const tx_cfg_resolution_t resolution_info_tx[RESOLUTION_NB] = {
+#endif                          /* endif TMFL_OS_WINDOWS */
+	/* TV Formats */
+	/* 60 HZ */
+	{dl_hdmitx_vfmt_01_640x480p_60hz,     640,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_02_720x480p_60hz,     720,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_03_720x480p_60hz,     720,   480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_04_1280x720p_60hz,    1280,  720,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_05_1920x1080i_60hz,   1920,  1080,   true,   dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_06_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_07_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_08_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_09_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_10_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_11_720x480i_60hz,     720,   480,    true,   dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_12_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_13_720x240p_60hz,     720,   240,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_14_1440x480p_60hz,    1440,  480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_15_1440x480p_60hz,    1440,  480,    false,  dl_hdmitx_vfreq_59hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_16_1920x1080p_60hz,   1920,  1080,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	/* 50 HZ */
+	{dl_hdmitx_vfmt_17_720x576p_50hz,     720,   576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_18_720x576p_50hz,     720,   576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_19_1280x720p_50hz,    1280,  720,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_20_1920x1080i_50hz,   1920,  1080,   true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_21_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_22_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_23_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_24_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_25_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_26_720x576i_50hz,     720,   576,    true,   dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_27_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_28_720x288p_50hz,     720,   288,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_29_1440x576p_50hz,    1440,  576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_30_1440x576p_50hz,    1440,  576,    false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_31_1920x1080p_50hz,   1920,  1080,   false,  dl_hdmitx_vfreq_50hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_32_1920x1080p_24hz,   1920,  1080,   false,  dl_hdmitx_vfreq_24hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_33_1920x1080p_25hz,   1920,  1080,   false,  dl_hdmitx_vfreq_25hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_34_1920x1080p_30hz,   1920,  1080,   false,  dl_hdmitx_vfreq_30hz, DL_HDMITX_P_ASPECT_RATIO_16_9}
+#ifdef FORMAT_PC
+	/* PC Formats */
+	/* 60 HZ */
+	, {dl_hdmitx_vfmt_pc_640x480p_60hz,     640,   480,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_60hz,     800,   600,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1152x960p_60hz,    1152,  960,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_6_5},
+	{dl_hdmitx_vfmt_pc_1024x768p_60hz,    1024,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x768p_60hz,    1280,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_5_3},
+	{dl_hdmitx_vfmt_pc_1280x1024p_60hz,   1280,  1024,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	{dl_hdmitx_vfmt_pc_1360x768p_60hz,    1360,  768,    false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_16_9},
+	{dl_hdmitx_vfmt_pc_1400x1050p_60hz,   1400,  1050,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1600x1200p_60hz,   1600,  1200,   false,  dl_hdmitx_vfreq_60hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 70 HZ */
+	{dl_hdmitx_vfmt_pc_1024x768p_70hz,    1024,  768,    false,  dl_hdmitx_vfreq_70hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 72 HZ */
+	{dl_hdmitx_vfmt_pc_640x480p_72hz,     640,   480,    false,  dl_hdmitx_vfreq_72hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_72hz,     800,   600,    false,  dl_hdmitx_vfreq_72hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	/* 75 HZ */
+	{dl_hdmitx_vfmt_pc_640x480p_75hz,     640,   480,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x768p_75hz,    1024,  768,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_75hz,     800,   600,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x864p_75hz,    1024,  864,    false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_UNDEFINED},
+	{dl_hdmitx_vfmt_pc_1280x1024p_75hz,   1280,  1024,   false,  dl_hdmitx_vfreq_75hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	/* 85 HZ */
+	{dl_hdmitx_vfmt_pc_640x350p_85hz,     640,   350,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_UNDEFINED},
+	{dl_hdmitx_vfmt_pc_640x400p_85hz,     640,   400,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_16_10},
+	{dl_hdmitx_vfmt_pc_720x400p_85hz,     720,   400,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_9_5},
+	{dl_hdmitx_vfmt_pc_640x480p_85hz,     640,   480,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_800x600p_85hz,     800,   600,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1024x768p_85hz,    1024,  768,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1152x864p_85hz,    1152,  864,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x960p_85hz,    1280,  960,    false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_4_3},
+	{dl_hdmitx_vfmt_pc_1280x1024p_85hz,   1280,  1024,   false,  dl_hdmitx_vfreq_85hz, DL_HDMITX_P_ASPECT_RATIO_5_4},
+	/* 87 HZ */
+	{dl_hdmitx_vfmt_pc_1024x768i_87hz,    1024,  768,    true,   dl_hdmitx_vfreq_87hz, DL_HDMITX_P_ASPECT_RATIO_4_3}
+#endif /* FORMAT_PC */
+};
+
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+tx_cfg_video_signal444 video_port_mapping_yuv444[MAX_UNITS][6] = {
+#else                           /* OS ARM7 */
+const tx_cfg_video_signal444 video_port_mapping_yuv444[MAX_UNITS][6] = {
+#endif                          /* endif TMFL_OS_WINDOWS */
+	{
+		DL_HDMITX_VID444_BU_0_TO_3,   /* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID444_BU_4_TO_7,   /* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID444_GY_0_TO_3,   /* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID444_GY_4_TO_7,   /* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID444_VR_0_TO_3,   /* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID444_VR_4_TO_7    /* Signals connected to VPC[4..7] */
+	}
+};
+
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+tx_cfg_video_signal444 video_port_mapping_rgb444[MAX_UNITS][6] = {
+#else                           /* OS ARM7 */
+const tx_cfg_video_signal444 video_port_mapping_rgb444[MAX_UNITS][6] = {
+#endif                          /* endif TMFL_OS_WINDOWS */
+	{
+		DL_HDMITX_VID444_BU_0_TO_3,   /* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID444_BU_4_TO_7,   /* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID444_GY_0_TO_3,   /* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID444_GY_4_TO_7,   /* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID444_VR_0_TO_3,   /* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID444_VR_4_TO_7    /* Signals connected to VPC[4..7] */
+	}
+};
+
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+tx_cfg_video_signal422 video_port_mapping_yuv422[MAX_UNITS][6] = {
+#else                           /* OS ARM7 */
+const tx_cfg_video_signal422 video_port_mapping_yuv422[MAX_UNITS][6] = {
+#endif                          /* endif TMFL_OS_WINDOWS */
+
+	{
+		/* Signals connected to VPA[0..3] */
+		DL_HDMITX_VID422_Y_4_TO_7,
+		/* Signals connected to VPA[4..7] */
+		DL_HDMITX_VID422_Y_8_TO_11,
+		/* Signals connected to VPB[0..3] */
+		DL_HDMITX_VID422_UV_4_TO_7,
+		/* Signals connected to VPB[4..7] */
+		DL_HDMITX_VID422_UV_8_TO_11,
+		/* Signals connected to VPC[0..3] */
+		DL_HDMITX_VID422_NOT_CONNECTED,
+		/* Signals connected to VPC[4..7] */
+		DL_HDMITX_VID422_NOT_CONNECTED
+	}
+};
+
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+tx_cfg_video_signal_ccir656 video_port_mapping_ccir656[MAX_UNITS][6] = {
+#else                           /* OS ARM7 */
+const tx_cfg_video_signal_ccir656 video_port_mapping_ccir656[MAX_UNITS][6] = {
+#endif                          /* endif TMFL_OS_WINDOWS */
+	{
+		/* Signals connected to VPA[0..3] */
+		DL_HDMITX_VIDCCIR_4_TO_7,
+		/* Signals connected to VPA[4..7] */
+		DL_HDMITX_VIDCCIR_8_TO_11,
+		/* Signals connected to VPB[0..3] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPB[4..7] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPC[0..3] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED,
+		/* Signals connected to VPC[4..7] */
+		DL_HDMITX_VIDCCIR_NOT_CONNECTED
+	}
+};
+
+/* Audio port configuration for SPDIF                                         */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortSPDIF and groundAudioPortSPDIF should be filled with a      */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortSPDIF and groundAudioClockPortSPDIF can be configured  */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+uint8 enable_audio_port_spdif[MAX_UNITS]      = {0x40};
+uint8 enable_audio_clock_port_spdif[MAX_UNITS] = {DISABLE_AUDIO_CLOCK_PORT};
+uint8 ground_audio_port_spdif[MAX_UNITS]      = {0xBF};
+uint8 ground_audio_clock_port_spdif[MAX_UNITS] = {ENABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for I2S                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortI2S and groundAudioPortI2S should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortI2S and groundAudioClockPortI2S can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+uint8 enable_audio_port_i2s[MAX_UNITS]        = {0x03};
+uint8 enable_audio_port_i2s8c[MAX_UNITS]      = {0x1F};
+uint8 enable_audio_clock_port_i2s[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+uint8 ground_audio_port_i2s[MAX_UNITS]        = {0xFC};
+uint8 ground_audio_port_i2s8c[MAX_UNITS]      = {0xE0};
+uint8 ground_audio_clock_port_i2s[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for OBA                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortOBA and groundAudioPortOBA should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortOBA and groundAudioClockPortOBA can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+uint8 enable_audio_port_oba[MAX_UNITS]        = {0xFF};
+uint8 enable_audio_clock_port_oba[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+uint8 ground_audio_port_oba[MAX_UNITS]        = {0x00};
+uint8 ground_audio_clock_port_oba[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for DST                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortDST and groundAudioPortDST should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortDST and groundAudioClockPortDST can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+uint8 enable_audio_port_dst[MAX_UNITS]        = {0xFF};
+uint8 enable_audio_clock_port_dst[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+uint8 ground_audio_port_dst[MAX_UNITS]        = {0x00};
+uint8 ground_audio_clock_port_dst[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Audio port configuration for HBR                                           */
+/* Here you can specify the audio port routing configuration for SPDIF input. */
+/* enableAudioPortHBR and groundAudioPortHBR should be filled with a          */
+/* value build as follows : each bit represent an audio port, LSB is port 0.  */
+/* enableAudioClockPortHBR and groundAudioClockPortHBR can be configured      */
+/* with the corresponding enums (See file tx_cfg.h for more details). */
+uint8 enable_audio_port_hbr[MAX_UNITS]        = {0x1F};
+uint8 enable_audio_clock_port_hbr[MAX_UNITS]   = {ENABLE_AUDIO_CLOCK_PORT};
+uint8 ground_audio_port_hbr[MAX_UNITS]        = {0xE0};
+uint8 ground_audio_clock_port_hbr[MAX_UNITS]   = {DISABLE_AUDIO_CLOCK_PORT_PULLDOWN};
+
+/* Do not modify, those tables are filled dynamically by dlHdmiTxGenerateCfgVideoPortTables API */
+uint8 mirror_table_ccir656[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 swap_table_ccir656[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 enable_video_port_ccir656[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+uint8 ground_video_port_ccir656[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+uint8 mirror_table_yuv422[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 swap_table_yuv422[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 enable_video_port_yuv422[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+uint8 ground_video_port_yuv422[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+uint8 mirror_table_yuv444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 swap_table_yuv444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 enable_video_port_yuv444[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+uint8 ground_video_port_yuv444[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+uint8 mirror_table_rgb444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 swap_table_rgb444[MAX_UNITS][6] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};
+uint8 enable_video_port_rgb444[MAX_UNITS][3] = {{0x00, 0x00, 0x00}};
+uint8 ground_video_port_rgb444[MAX_UNITS][3] = {{0xFF, 0xFF, 0xFF}};
+
+/**
+ * \brief Configuration Tables. This table can be modified by the customer
+ *            to choose its prefered configuration.
+ * */
+#ifdef TMFL_OS_WINDOWS         /* OS Windows */
+tx_driver_config_table_t driver_config_table_tx[MAX_UNITS] = {
+	{
+		COMMAND_TASK_PRIORITY_0,
+		COMMAND_TASK_STACKSIZE_0,
+		COMMAND_TASK_QUEUESIZE_0,
+		HDCP_CHECK_TASK_PRIORITY_0,
+		HDCP_CHECK_TASK_STACKSIZE_0,
+		UNIT_I2C_ADDRESS_0,
+		windows_i2c_read_function,
+		windows_i2c_write_function,
+		edid_read_function,
+		NULL,                           /* filled dynamically, do not modify */
+		RESOLUTION_NB,
+		/* filled dynamically, do not modify */
+		&mirror_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_rgb444[0][0],
+		&enable_audio_port_spdif[0],
+		&ground_audio_port_spdif[0],
+		&enable_audio_clock_port_spdif[0],
+		&ground_audio_clock_port_spdif[0],
+		&enable_audio_port_i2s[0],
+		&ground_audio_port_i2s[0],
+		&enable_audio_port_i2s8c[0],
+		&ground_audio_port_i2s8c[0],
+		&enable_audio_clock_port_i2s[0],
+		&ground_audio_clock_port_i2s[0],
+		&enable_audio_port_oba[0],
+		&ground_audio_port_oba[0],
+		&enable_audio_clock_port_oba[0],
+		&ground_audio_clock_port_oba[0],
+		&enable_audio_port_dst[0],
+		&ground_audio_port_dst[0],
+		&enable_audio_clock_port_dst[0],
+		&ground_audio_clock_port_dst[0],
+		&enable_audio_port_hbr[0],
+		&ground_audio_port_hbr[0],
+		&enable_audio_clock_port_hbr[0],
+		&ground_audio_clock_port_hbr[0],
+		KEY_SEED,
+		DL_HDMITX_PATTERN_BLUE,
+		/* by default, the DE signal is considered available */
+		1
+	}
+};
+#else            /* OS ARM7 */
+tx_driver_config_table_t driver_config_table_tx[MAX_UNITS] = {
+	{
+		COMMAND_TASK_PRIORITY_0,
+		COMMAND_TASK_STACKSIZE_0,
+		COMMAND_TASK_QUEUESIZE_0,
+		HDCP_CHECK_TASK_PRIORITY_0,
+		HDCP_CHECK_TASK_STACKSIZE_0,
+		UNIT_I2C_ADDRESS_0,
+		rtx_tx_i2c_read_function,
+		rtx_tx_i2c_write_function,
+		edid_read_function,
+		NULL,                           /* filled dynamically, do not modify */
+		RESOLUTION_NB,
+		/* filled dynamically, do not modify */
+		&mirror_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_ccir656[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv422[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_yuv444[0][0],
+		/* filled dynamically, do not modify */
+		&mirror_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&swap_table_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&enable_video_port_rgb444[0][0],
+		/* filled dynamically, do not modify */
+		&ground_video_port_rgb444[0][0],
+		&enable_audio_port_spdif[0],
+		&ground_audio_port_spdif[0],
+		&enable_audio_clock_port_spdif[0],
+		&ground_audio_clock_port_spdif[0],
+		&enable_audio_port_i2s[0],
+		&ground_audio_port_i2s[0],
+		&enable_audio_port_i2s8c[0],
+		&ground_audio_port_i2s8c[0],
+		&enable_audio_clock_port_i2s[0],
+		&ground_audio_clock_port_i2s[0],
+		&enable_audio_port_oba[0],
+		&ground_audio_port_oba[0],
+		&enable_audio_clock_port_oba[0],
+		&ground_audio_clock_port_oba[0],
+		&enable_audio_port_dst[0],
+		&ground_audio_port_dst[0],
+		&enable_audio_clock_port_dst[0],
+		&ground_audio_clock_port_dst[0],
+		&enable_audio_port_hbr[0],
+		&ground_audio_port_hbr[0],
+		&enable_audio_clock_port_hbr[0],
+		&ground_audio_clock_port_hbr[0],
+		KEY_SEED,
+		DL_HDMITX_PATTERN_BLUE,
+		/* by default, the DE signal is considered available */
+		1
+	}
+};
+#endif              /* endif TMFL_OS_WINDOWS */
+
+/*============================================================================*/
+/*                              FUNCTIONS                                     */
+/*============================================================================*/
+#ifdef TMFL_OS_WINDOWS          /* OS Windows */
+/******************************************************************************
+ *    \brief Read to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C read structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t windows_i2c_read_function
+(
+    bsl_sys_args_t    *p_sys_args
+)
+{
+	error_code_t   err;
+
+	err = i2c_read(reg_tda_998x, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+
+/******************************************************************************
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C write structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t windows_i2c_write_function
+(
+    bsl_sys_args_t    *p_sys_args
+)
+{
+	error_code_t   err;
+
+	err = i2c_write(reg_tda_998x, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+
+#else         /* OS ARM7 */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C read structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+rtx_tx_i2c_read_function
+(
+    bsl_sys_args_t        *p_sys_args
+)
+{
+	error_code_t               err;
+
+	err = i2c_read(reg_tda_998x, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+
+/******************************************************************************
+ *    \brief Write to BSL driver through I2C bus
+ *
+ *    \param pSysArgs Pointer to the I2C write structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *
+ ******************************************************************************/
+error_code_t
+rtx_tx_i2c_write_function
+(
+    bsl_sys_args_t *p_sys_args
+)
+{
+	error_code_t               err;
+
+	err = i2c_write(reg_tda_998x, (bsl_hdmi_sys_args_t *) p_sys_args);
+
+	return err;
+}
+
+#endif      /* endif TMFL_OS_WINDOWS */
+
+/*****************************************************************************
+ ******************************************************************************
+ *                THIS PART MUST NOT BE MODIFIED BY CUSTOMER                  *
+ ******************************************************************************
+ *****************************************************************************/
+
+/******************************************************************************
+ *    \brief  Generate swap and mirror tables in function
+ *            of video port mapping tables.
+ *
+ *    \param unit     Unit identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_generate_cfg_video_port_tables
+(
+    unit_select_t                  unit,
+    tx_driver_config_table_t   *p_config
+)
+{
+	u8   i;
+
+	for(i = 0; i < 6; i++) {
+		/* CCIR656 */
+		if(video_port_mapping_ccir656[unit][i] != DL_HDMITX_VIDCCIR_NOT_CONNECTED) {
+			p_config->p_swap_table_ccir656[video_port_mapping_ccir656[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_ccir656[video_port_mapping_ccir656[unit][i] & 0x07F] = (u8)(video_port_mapping_ccir656[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_ccir656[i/2] |= 0x0F;
+				p_config->p_ground_video_port_ccir656[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_ccir656[i/2] |= 0xF0;
+				p_config->p_ground_video_port_ccir656[i/2] &= 0x0F;
+			}
+		}
+
+		/* YUV422 */
+		if(video_port_mapping_yuv422[unit][i] != DL_HDMITX_VID422_NOT_CONNECTED) {
+			p_config->p_swap_table_yuv422[video_port_mapping_yuv422[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_yuv422[video_port_mapping_yuv422[unit][i] & 0x07F] = (u8)(video_port_mapping_yuv422[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_yuv422[i/2] |= 0x0F;
+				p_config->p_ground_video_port_yuv422[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_yuv422[i/2] |= 0xF0;
+				p_config->p_ground_video_port_yuv422[i/2] &= 0x0F;
+			}
+		}
+
+		/* YUV444 */
+		if(video_port_mapping_yuv444[unit][i] != DL_HDMITX_VID444_NOT_CONNECTED) {
+			p_config->p_swap_table_yuv444[video_port_mapping_yuv444[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_yuv444[video_port_mapping_yuv444[unit][i] & 0x07F] = (u8)(video_port_mapping_yuv444[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_yuv444[i/2] |= 0x0F;
+				p_config->p_ground_video_port_yuv444[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_yuv444[i/2] |= 0xF0;
+				p_config->p_ground_video_port_yuv444[i/2] &= 0x0F;
+			}
+		}
+
+		/* RGB444 */
+		if(video_port_mapping_rgb444[unit][i] != DL_HDMITX_VID444_NOT_CONNECTED) {
+			p_config->p_swap_table_rgb444[video_port_mapping_rgb444[unit][i] & 0x07F] = 5 - i;
+			p_config->p_mirror_table_rgb444[video_port_mapping_rgb444[unit][i] & 0x07F] = (u8)(video_port_mapping_rgb444[unit][i] >> 7);
+			/* Enable port and disable ground port */
+			if(((5 - i) % 2) == 0) {
+				p_config->p_enable_video_port_rgb444[i/2] |= 0x0F;
+				p_config->p_ground_video_port_rgb444[i/2] &= 0xF0;
+			} else {
+				p_config->p_enable_video_port_rgb444[i/2] |= 0xF0;
+				p_config->p_ground_video_port_rgb444[i/2] &= 0x0F;
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *    \brief This function allows to the main driver to retrieve its
+ *           configuration parameters.
+ *
+ *    \param pConfig Pointer to the config structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_cfg_get_config
+(
+    unit_select_t                  unit,
+    tx_driver_config_table_t   *p_config
+)
+{
+	/* Check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMITX_BAD_UNIT_NUMBER)
+
+	/* Check if pointer is NULL */
+	RETIF(p_config == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	*p_config = driver_config_table_tx[unit];
+
+	/* Done here because of const declaration of tables in ARM7 case */
+	p_config->p_resolution_info = (ptx_cfg_resolution_t)resolution_info_tx;
+
+	/* Generate swap and mirror tables in function of video port mapping tables */
+	dl_hdmi_tx_generate_cfg_video_port_tables(unit, p_config);
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Driver callback function for i2c EDID read (REQUIRED SW INTERFACE)
+ *
+ *    \param
+ *    \param
+ *
+ *    \return The call result:
+ *            0: the call was successfull
+ *            ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ ******************************************************************************/
+error_code_t edid_read_function(bsl_sys_args_edid_t *p_sys_args)
+{
+	u8 seg_address = p_sys_args->seg_ptr_addr;
+	u8 segptr = p_sys_args->seg_ptr;
+	u8 data_address = p_sys_args->data_reg_addr;
+	u8 offset = p_sys_args->word_offset;
+	u8 *ptr = p_sys_args->p_data;
+	u8 nb_char = p_sys_args->len_data;
+	u8 i = 0;
+	error_code_t       err;
+
+	do {
+		err = (i2c_read_edid(seg_address, segptr, data_address, offset, nb_char, ptr)) ? ERR_HDMI_I2C_READ : 0;
+		i++;
+	} while((err != 0) && (i < 3));
+
+	return err;
+}
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.h b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.h
new file mode 100755
index 0000000..f30c47a
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/cfg/tmdlHdmiTx_cfg.h
@@ -0,0 +1,246 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_cfg.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 08/08/07 11:00 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: bsl_cfg.h $
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 08/08/07  Time: 11:00
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*****************************************************************************/
+/*****************************************************************************/
+/*                THIS FILE MUST NOT BE MODIFIED BY CUSTOMER                 */
+/*****************************************************************************/
+/*****************************************************************************/
+
+#ifndef DLHDMITX_CFG_H
+#define DLHDMITX_CFG_H
+
+#include "tmNxTypes.h"
+#include "tmbslHdmiTx.h"
+#include "tmdlHdmiTx_Types.h"
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+typedef struct _tx_cfg_resolution_t {
+	tx_vid_fmt_t          resolution_id;
+	u16                      width;
+	u16                      height;
+	bool                        interlaced;
+	tx_vfreq_t           vfrequency;
+	tx_pict_aspect_ratio_t aspect_ratio;
+} tx_cfg_resolution_t, *ptx_cfg_resolution_t;
+
+/**
+ * \brief Video signals that can be input to video ports in RGB/YUV 4:4:4 mode
+ * */
+typedef enum {
+	/**< Video signal G/Y, bits 4 to 7 */
+	DL_HDMITX_VID444_GY_4_TO_7 = 0x00,
+	/**< Video signal G/Y, bits 0 to 3 */
+	DL_HDMITX_VID444_GY_0_TO_3 = 0x01,
+	/**< Video signal B/U, bits 4 to 7 */
+	DL_HDMITX_VID444_BU_4_TO_7 = 0x02,
+	/**< Video signal B/U, bits 0 to 3 */
+	DL_HDMITX_VID444_BU_0_TO_3 = 0x03,
+	/**< Video signal V/R, bits 4 to 7 */
+	DL_HDMITX_VID444_VR_4_TO_7 = 0x04,
+	/**< Video signal V/R, bits 0 to 3 */
+	DL_HDMITX_VID444_VR_0_TO_3 = 0x05,
+	/**< Video signal G/Y, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VID444_GY_7_TO_4 = 0x80,
+	/**< Video signal G/Y, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VID444_GY_3_TO_0 = 0x81,
+	/**< Video signal B/U, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VID444_BU_7_TO_4 = 0x82,
+	/**< Video signal B/U, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VID444_BU_3_TO_0 = 0x83,
+	/**< Video signal V/R, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VID444_VR_7_TO_4 = 0x84,
+	/**< Video signal V/R, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VID444_VR_3_TO_0 = 0x85,
+	DL_HDMITX_VID444_NOT_CONNECTED = 0x100    /**< No signal connected */
+} tx_cfg_video_signal444;
+
+/**
+ * \brief Video signals that can be input to video ports in semi-planar YUV 4:2:2 mode
+ * */
+typedef enum {
+	/**< Video signal G/Y, bits 8 to 11 */
+	DL_HDMITX_VID422_Y_8_TO_11     = 0x00,
+	/**< Video signal G/Y, bits 4 to 7 */
+	DL_HDMITX_VID422_Y_4_TO_7      = 0x01,
+	/**< Video signal G/Y, bits 0 to 3 */
+	DL_HDMITX_VID422_Y_0_TO_3      = 0x02,
+	/**< Video signal B/U, bits 8 to 11 */
+	DL_HDMITX_VID422_UV_8_TO_11    = 0x03,
+	/**< Video signal B/U, bits 4 to 7 */
+	DL_HDMITX_VID422_UV_4_TO_7     = 0x04,
+	/**< Video signal B/U, bits 0 to 3 */
+	DL_HDMITX_VID422_UV_0_TO_3     = 0x05,
+	/**< Video signal G/Y, bits 11 to 8 (mirrored) */
+	DL_HDMITX_VID422_Y_11_TO_8     = 0x80,
+	/**< Video signal G/Y, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VID422_Y_7_TO_4      = 0x81,
+	/**< Video signal G/Y, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VID422_Y_3_TO_0      = 0x82,
+	/**< Video signal B/U, bits 11 to 8 (mirrored) */
+	DL_HDMITX_VID422_UV_11_TO_8    = 0x83,
+	/**< Video signal B/U, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VID422_UV_7_TO_4     = 0x84,
+	/**< Video signal B/U, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VID422_UV_3_TO_0     = 0x85,
+	DL_HDMITX_VID422_NOT_CONNECTED = 0x100    /**< No signal connected */
+} tx_cfg_video_signal422;
+
+/**
+ *
+ * \brief Video signals that can be input to video ports in semi-planar CCIR 656 mode
+ * */
+typedef enum {
+	/**< Video signal CCIR, bits 8 to 11 */
+	DL_HDMITX_VIDCCIR_8_TO_11       = 0x00,
+	/**< Video signal CCIR, bits 4 to 7 */
+	DL_HDMITX_VIDCCIR_4_TO_7        = 0x01,
+	/**< Video signal CCIR, bits 0 to 3 */
+	DL_HDMITX_VIDCCIR_0_TO_3        = 0x02,
+	/**< Video signal CCIR, bits 11 to 8 (mirrored) */
+	DL_HDMITX_VIDCCIR_11_TO_8       = 0x80,
+	/**< Video signal CCIR, bits 7 to 4 (mirrored) */
+	DL_HDMITX_VIDCCIR_7_TO_4        = 0x81,
+	/**< Video signal CCIR, bits 3 to 0 (mirrored) */
+	DL_HDMITX_VIDCCIR_3_TO_0        = 0x82,
+	DL_HDMITX_VIDCCIR_NOT_CONNECTED = 0x100   /**< No signal connected */
+} tx_cfg_video_signal_ccir656;
+
+typedef struct {
+	u8                       command_task_priority;
+	u8                       command_task_stack_size;
+	u8                       command_task_queue_size;
+	u8                       hdcp_task_priority;
+	u8                       hdcp_task_stack_size;
+	u8                       i2c_address;
+	pbsl_sys_func_t       i2c_read_function;
+	pbsl_sys_func_t       i2c_write_function;
+	pbsl_sys_func_edid_t   edid_read_function;
+	ptx_cfg_resolution_t  p_resolution_info;
+	u8                       resolution_nb;
+	u8                       *p_mirror_table_ccir656;
+	u8                       *p_swap_table_ccir656;
+	u8                       *p_enable_video_port_ccir656;
+	u8                       *p_ground_video_port_ccir656;
+	u8                       *p_mirror_table_yuv422;
+	u8                       *p_swap_table_yuv422;
+	u8                       *p_enable_video_port_yuv422;
+	u8                       *p_ground_video_port_yuv422;
+	u8                       *p_mirror_table_yuv444;
+	u8                       *p_swap_table_yuv444;
+	u8                       *p_enable_video_port_yuv444;
+	u8                       *p_ground_video_port_yuv444;
+	u8                       *p_mirror_table_rgb444;
+	u8                       *p_swap_table_rgb444;
+	u8                       *p_enable_video_port_rgb444;
+	u8                       *p_ground_video_port_rgb444;
+	u8                       *p_enable_audio_port_spdif;
+	u8                       *p_ground_audio_port_spdif;
+	u8                       *p_enable_audio_clock_port_spdif;
+	u8                       *p_ground_audio_clock_port_spdif;
+	u8                       *p_enable_audio_port_i2s;
+	u8                       *p_ground_audio_port_i2s;
+	u8                       *p_enable_audio_port_i2s8c;
+	u8                       *p_ground_audio_port_i2s8c;
+	u8                       *p_enable_audio_clock_port_i2s;
+	u8                       *p_ground_audio_clock_port_i2s;
+	u8                       *p_enable_audio_port_oba;
+	u8                       *p_ground_audio_port_oba;
+	u8                       *p_enable_audio_clock_port_oba;
+	u8                       *p_ground_audio_clock_port_oba;
+	u8                       *p_enable_audio_port_dst;
+	u8                       *p_ground_audio_port_dst;
+	u8                       *p_enable_audio_clock_port_dst;
+	u8                       *p_ground_audio_clock_port_dst;
+	u8                       *p_enable_audio_port_hbr;
+	u8                       *p_ground_audio_port_hbr;
+	u8                       *p_enable_audio_clock_port_hbr;
+	u8                       *p_ground_audio_clock_port_hbr;
+	u16                      key_seed;
+	tx_test_pattern_t     pattern;
+	/* 0 DE is NOT available, 1 DE is there */
+	u8                       data_enable_signal_available;
+} tx_driver_config_table_t;
+
+/*============================================================================*/
+/*                       FUNCTIONS DECLARATIONS                               */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief This function allows to the main driver to retrieve its
+ *           configuration parameters.
+ *
+ *    \param pConfig Pointer to the config structure
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_cfg_get_config
+(
+    unit_select_t                  unit,
+    tx_driver_config_table_t   *p_config
+);
+
+#ifdef TMFL_CEC_AVAILABLE
+
+#include "tmdlHdmiCEC_Types.h"
+
+typedef struct {
+	u8                         command_task_priority;
+	u8                         command_task_stack_size;
+	u8                         command_task_queue_size;
+	u8                         i2c_address;
+	ptmdl_hdmi_cec_sys_func_t         i2c_read_function;
+	ptmdl_hdmi_cec_sys_func_t         i2c_write_function;
+	dl_hdmi_cec_capabilities_t     *p_capabilities_list;
+} dl_hdmi_cec_driver_config_table_t;
+
+error_code_t dl_hdmi_cec_cfg_get_config
+(
+    unit_select_t                 unit,
+    dl_hdmi_cec_driver_config_table_t *p_config
+);
+#endif
+
+#endif /* DLHDMITX_CFG_H */
+
+/*============================================================================*/
+/*                               END OF FILE                                  */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx.h b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx.h
new file mode 100755
index 0000000..f8efa14
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx.h
@@ -0,0 +1,54 @@
+/**
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 02/08/07 08:32 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ * HDMI Tx Driver - tx - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: tx.h $
+ *
+ * *****************  Version 13  *****************
+ * User: Demoment     Date: 02/08/07   Time: 08:32
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef DLHDMITX_H
+#define DLHDMITX_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+#include "tmNxCompId.h"
+#include "tmdlHdmiTx_Types.h"
+#include "tmdlHdmiTx_Functions.h"
+
+/* Number of HW units supported by SW driver */
+#define MAX_UNITS 1
+
+#endif /* DLHDMITX_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Functions.h b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Functions.h
new file mode 100755
index 0000000..f3c1886
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Functions.h
@@ -0,0 +1,1446 @@
+/**
+ * Copyright (C) 2007 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_Functions.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 02/08/07 8:32 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ * HDMI Tx Driver - tx - SCS.doc
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: tx_Functions.h $
+ *
+ * *****************  Version 1  *****************
+ * User: Demoment     Date: 02/08/07   Time: 8:32
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef DLHDMITX_FUNCTIONS_H
+#define DLHDMITX_FUNCTIONS_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#include "tmNxTypes.h"
+#include "tmdlHdmiTx_Types.h"
+
+/*============================================================================*/
+/*                       EXTERN FUNCTION PROTOTYPES                           */
+/*============================================================================*/
+
+/*****************************************************************************/
+/**
+ *    \brief Get the software version of the driver.
+ *
+ *    \param pSWVersion Pointer to the version structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_get_swversion
+(
+    swversion_t  *p_swversion
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get the number of available HDMI transmitters devices in the system.
+ *           A unit directly represents a physical device.
+ *
+ *    \param pUnitCount Pointer to the number of available units.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_get_number_of_units
+(
+    u32  *p_unit_count
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get the capabilities of unit 0. Capabilities are stored into a
+ *           dedicated structure and are directly read from the HW device.
+ *
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_capabilities
+(
+    tx_capabilities_t *p_capabilities
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get the capabilities of a specific unit. Capabilities are stored
+ *           into a dedicated structure and are directly read from the HW
+ *           device.
+ *
+ *    \param unit          Unit to be probed.
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_capabilities_m
+(
+    unit_select_t            unit,
+    tx_capabilities_t *p_capabilities
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Open unit 0 of HdmiTx driver and provides the instance number to
+ *           the caller. Note that one unit of HdmiTx represents one physical
+ *           HDMI transmitter and that only one instance per unit can be opened.
+ *
+ *    \param pInstance Pointer to the variable that will receive the instance
+ *                     identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the transmitter instance is not initialised
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: the unit is not initialized
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_INIT_FAILED: the unit instance is already
+ *              initialised
+ *            - ERR_HDMI_COMPATIBILITY: the driver is not compatiable
+ *              with the internal device version code
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_open
+(
+    instance_t   *p_instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Open a specific unit of HdmiTx driver and provides the instance
+ *           number to the caller. Note that one unit of HdmiTx represents one
+ *           physical HDMI transmitter and that only one instance per unit can be
+ *           opened. This function switches driver's state machine to
+ *           "initialized" state.
+ *
+ *    \param pInstance Pointer to the structure that will receive the instance
+ *                     identifier.
+ *    \param unit      Unit number to be opened.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the transmitter instance is not initialised
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: the unit is not initialized
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_INIT_FAILED: the unit instance is already
+ *              initialised
+ *            - ERR_HDMI_COMPATIBILITY: the driver is not compatiable
+ *              with the internal device version code
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_open_m
+(
+    instance_t   *p_instance,
+    unit_select_t  unit
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Close an instance of HdmiTx driver.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_close
+(
+    instance_t   instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Set the power state of an instance of the HDMI transmitter.
+ *
+ *    \param instance   Instance identifier.
+ *    \param powerState Power state to set.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_set_power_state
+(
+    instance_t    instance,
+    power_state_t  power_state
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get the power state of an instance of the HDMI transmitter.
+ *
+ *    \param instance    Instance identifier.
+ *    \param pPowerState Pointer to the power state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_power_state
+(
+    instance_t    instance,
+    power_state_t  *p_power_state
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Set the configuration of instance attributes. This function is
+ *           required by DVP architecture rules but actually does nothing in this
+ *           driver
+ *
+ *    \param instance    Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *
+ ******************************************************************************/
+error_code_t tx_instance_config
+(
+    instance_t    instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration like enabling HDCP, choosing
+ *           HDCP encryption mode or enabling HDCP repeater mode.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ ******************************************************************************/
+error_code_t tx_instance_setup
+(
+    instance_t                    instance,
+    tx_instance_setup_info_t   *p_setup_info
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get instance setup parameters.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure that will receive setup
+ *                      parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_get_instance_setup
+(
+    instance_t                    instance,
+    tx_instance_setup_info_t   *p_setup_info
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Make device library handle an incoming interrupt. This function is
+ *           used by application to tell the device library that the hardware
+ *           sent an interrupt.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_handle_interrupt
+(
+    instance_t    instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Register event callbacks. Only one callback is registered through
+ *           this API. This callback will received the type of event that
+ *           occured throug a dedicated parameter and will be called as many
+ *           times as there is pending events.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pCallback  Pointer to the callback function that will handle events
+ *                      from the devlib.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ ******************************************************************************/
+error_code_t tx_register_callbacks
+(
+    instance_t            instance,
+    ptx_callback_t   p_callback
+);
+
+/*****************************************************************************/
+/**
+ *    \brief This function allows enabling a specific event. By default, all
+ *           events are disabled, except input lock.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to enable.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_enable_event
+(
+    instance_t      instance,
+    tx_event_t event
+);
+
+/*****************************************************************************/
+/**
+ *    \brief This function allows disabling a specific event. By default, all
+ *           events are disabled, except input lock.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to disable.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_disable_event
+(
+    instance_t      instance,
+    tx_event_t event
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get specifications of a given video format. Application can use
+ *           this function to retreives all specifications (frequencies,
+ *           resolution, etc.) of a given IA/CEA 861-D video format.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param resolutionID     ID of the resolution to retrieve specs from.
+ *    \param pResolutionSpecs Pointer to the structure receiving specs.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOLUTION_UNKNOWN: the resolution is unknown
+ *
+ ******************************************************************************/
+error_code_t tx_get_video_format_specs
+(
+    instance_t            instance,
+    tx_vid_fmt_t      resolution_id,
+    tx_vid_fmt_specs_t *p_resolution_specs
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Configures all input and output parameters : format, modes, rates,
+ *           etc. This is the main configuration function of the driver. Here
+ *           are transmitted all crucial input and output parameters of the
+ *           device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param videoInputConfig  Configuration of the input video.
+ *    \param videoOutputConfig Configuration of the output video.
+ *    \param audioInputConfig  Configuration of the input audio.
+ *    \param sinkType          Type of sink connected to the output of the Tx.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_input_output
+(
+    instance_t               instance,
+    tx_video_in_config_t  video_input_config,
+    tx_video_out_config_t video_output_config,
+    tx_audio_in_config_t  audio_input_config,
+    tx_sink_type_t       sink_type
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Configures audio input parameters : format, rate, etc.
+ *           This function is similar to txSetInputOutput except that
+ *           video is not reconfigured.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param audioInputConfig  Configuration of the input audio.
+ *    \param sinkType          Type of sink connected to the output of the Tx.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_input
+(
+    instance_t                instance,
+    tx_audio_in_config_t   audio_input_config,
+    tx_sink_type_t        sink_type
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of AVI infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAviIfData   Pointer to the structure containing AVI infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_video_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_avi_if_data_t   *p_avi_if_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of AUD infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAudIfData   Pointer to the structure containing AUD infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_aud_if_data_t   *p_aud_if_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of the audio content protection packet to be
+ *           sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAcpPktData  Pointer to the structure containing ACP infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_acppacket
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_acp_pkt_data_t  *p_acp_pkt_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of the General Control packet to be sent by Tx
+ *           device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pGcpPktData  Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_general_control_packet
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_gcp_pkt_data_t  *p_gcp_pkt_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of ISRC1 packet to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param enable           Enable/disable infoframe insertion.
+ *    \param pIsrc1PktData    Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_isrc1packet
+(
+    instance_t                instance,
+    bool                        enable,
+    tx_isrc1pkt_data_t    *p_isrc1pkt_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of ISRC2 packet to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param enable           Enable/disable infoframe insertion.
+ *    \param pIsrc2PktData    Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_isrc2packet
+(
+    instance_t                instance,
+    bool                        enable,
+    tx_isrc2pkt_data_t    *p_isrc2pkt_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of MPS infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pMpsIfData   Pointer to the structure containing MPS infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_mpsinfoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_mps_if_data_t   *p_mps_if_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of SPD infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pSpdIfData   Pointer to the structure containing SPD infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_spd_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_spd_if_data_t   *p_spd_if_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Defines the content of VS infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pVsIfData    Pointer to the structure containing VS infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_vs_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_vs_pkt_data_t   *p_vs_if_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Enables/disables NULL packet sending (only used for debug purpose).
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *    \param enable    Enable/disable packet insertion.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_debug_set_null_packet
+(
+    instance_t    instance,
+    bool            enable
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Send one single NULL packet (only used for debug purpose).
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_debug_set_single_null_packet
+(
+    instance_t    instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Set the audio output mute status. This function can be used to mute
+ *           audio output, without muting video. This can be typically used when
+ *           reconfiguring the audio HW after a sample rate change.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param muteStatus Mute status (true/false).
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_mute
+(
+    instance_t instance,
+    bool         audio_mute
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Reset audio CTS.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_reset_audio_cts
+(
+    instance_t instance
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieve EDID Status from driver.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pEdidStatus      Pointer to the array that will receive the EDID Status.
+ *    \param pEdidBlkCount    Pointer to the integer that will receive the number of
+ *                            read EDID block.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_status
+(
+    instance_t            instance,
+    tx_edid_status_t  *p_edid_status,
+    u8                   *p_edid_blk_count
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves audio descriptors from receiver's EDID. This function
+ *           parses the EDID of Tx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param pAudioDescs          Pointer to the array that will receive audio
+ *                                descriptors.
+ *    \param maxAudioDescs        Size of the array.
+ *    \param pWrittenAudioDescs   Pointer to the integer that will receive the actual
+ *                                number of written descriptors.
+ *    \param pAudioFlags          Pointer to the byte to receive Audio Capabilities Flags.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_audio_caps
+(
+    instance_t                instance,
+    tx_edid_audio_desc_t   *p_audio_descs,
+    uint                        max_audio_descs,
+    uint                        *p_written_audio_descs,
+    u8                       *p_audio_flags
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported video formats (short descriptors) from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param pVideoDesc           Pointer to the structure that will receive short
+ *                                video descriptors.
+ *    \param maxVideoFormats      Size of the array.
+ *    \param pWrittenVideoFormats Pointer to the integer that will receive the actual
+ *                                number of written descriptors.
+ *    \param pVideoFlags          Pointer to the byte to receive Video Capability Flags.
+ *                                b7: underscan supported
+ *                                b6: YCbCr 4:4:4 supported
+ *                                b5: YCbCr 4:2:2 supported
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_video_caps
+(
+    instance_t                instance,
+    tx_short_vid_desc_t    *p_video_desc,
+    uint                        max_video_formats,
+    uint                        *p_written_video_formats,
+    u8                       *p_video_flags
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported video formats (short descriptors) from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance                 Instance identifier.
+ *    \param pPreferredVideoFormat    Pointer to the array that will receive video
+ *                                    timing descriptor.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_video_preferred
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_preferred_video_format
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves the sink type from receiver's EDID (HDMI or DVI). This
+ *           function parses the EDID of Rx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *    \param pSinkType Pointer to the array that will receive sink type.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_DLHDMITX_NOT_INITIALIZED: the transmitter is not initialized
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_sink_type
+(
+    instance_t            instance,
+    tx_sink_type_t    *p_sink_type
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves source address from receivers's EDID. This
+ *           function parses the EDID of Rx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pSourceAddress   Pointer to the integer that will receive the EDID source
+ *                            address.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_source_address
+(
+    instance_t    instance,
+    u16          *p_source_address
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retreives KSV list received by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param pKsv         Pointer to the array that will receive the KSV list.
+ *    \param maxKsv       Maximum number of KSV that the array can store.
+ *    \param pWrittenKsv  Actual number of KSV written into the array.
+ *    \param pDepth       Connection tree depth.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_get_ksv_list
+(
+    instance_t    instance,
+    u8           *p_ksv,
+    u8           max_ksv,
+    u8           *p_written_ksv,
+    u8           *p_depth,
+    bool            *p_max_casc_exd,
+    bool            *p_max_devs_exd
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Enable/Disable HDCP encryption.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param hdcpEnable HDCP On/Off (true = On, false = Off).
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_RESOLUTION_UNKNOWN: the resolution is unknown
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_set_hdcp
+(
+    instance_t instance,
+    bool         hdcp_enable
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Get the driver HDCP state.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param pHdcpCheckState   Pointer to the integer that will receive the HDCP check state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_get_hdcp_state
+(
+    instance_t            instance,
+    tx_hdcp_check_t   *p_hdcp_check_state
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Check the result of an HDCP encryption attempt, called at
+ *           intervals (set by timeSinceLastCall) after txSetHdcp(true).
+ *           This API must be used only in case of No Operating System. if OS,
+ *           this is manage internally of this device library.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param timeSinceLastCall    Time passed in milliseconds since last call,
+ *                                must be shorter than 600 ms.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *            - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *            - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_hdcp_check
+(
+    instance_t    instance,
+    u16          time_since_last_call
+);
+
+/*****************************************************************************/
+/**
+ *    \brief This function loads a gamut metadata packet into the HW. HW will
+ *           actually send it at the beginning of next VS, during the vertical
+ *           blanking.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable gamut metadata packet insertion.
+ *    \param pGamutData   Pointer to the structure containing gamut metadata
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_gamut_packet
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_gamut_data_t   *p_gamut_data
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported detailled video descriptors from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pDTDescriptors   Pointer to the array that will receive detailled
+ *                            timing descriptors.
+ *    \param maxDTDesc        Size of the array.
+ *    \param pWrittenDesc     Pointer to the integer that will receive the actual
+ *                            number of written descriptors.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_detailled_timing_descriptors
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    u8                           max_dtdesc,
+    u8                           *p_written_dtdesc
+);
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported monitor descriptor from receiver's EDID.
+ *           This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pEdidFirstMD     Pointer to the array that will receive the first monitor
+ *                            descriptors.
+ *    \param pEdidSecondMD    Pointer to the array that will receive the second monitor
+ *                            descriptors.
+ *    \param pEdidOtherMD     Pointer to the array that will receive the other monitor
+ *                            descriptors.
+ *    \param maxOtherMD       Size of the array.
+ *    \param pWrittenOtherMD  Pointer to the integer that will receive the actual
+ *                            number of written descriptors.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_monitor_descriptors
+(
+    instance_t                instance,
+    tx_edid_first_md_t     *p_edid_first_md,
+    tx_edid_second_md_t    *p_edid_second_md,
+    tx_edid_other_md_t     *p_edid_other_md,
+    u8                       max_other_md,
+    u8                       *p_written_other_md
+);
+
+/******************************************************************************
+ *    \brief This function set the revocation list use for HDCP
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param listPtr      Pointer on revocation list provide by application.
+ *    \param length       length of revocation list.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ ******************************************************************************/
+
+error_code_t tx_set_hdcprevocation_list(
+    instance_t    instance,
+    void            *list_ptr,
+    u32          length
+);
+
+error_code_t tx_get_hpdstatus
+(
+    instance_t            instance,
+    tx_hot_plug_t    *p_hpdstatus
+);
+
+#endif /* DLHDMITX_FUNCTIONS_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Types.h b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Types.h
new file mode 100755
index 0000000..906af9d
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/inc/tmdlHdmiTx_Types.h
@@ -0,0 +1,839 @@
+/**
+ * copyright (C) 2007 NXP N.V., all rights reserved.
+ * this source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. under no circumstances
+ * is this software to be  exposed to or placed under an open source license of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_types.h
+ *
+ * \version       $revision: 1 $
+ *
+ * \date          $date: 02/08/07 08:32 $
+ *
+ * \brief         devlib driver component API for the tda_998x HDMI transmitters
+ *
+ * \section refs  reference documents
+ * HDMI tx driver - FRS.doc,
+ * HDMI tx driver - tx - SCS.doc
+ *
+ * \section info  change information
+ *
+ * \verbatim
+ *
+ *  $history: tx_types.h $
+ *
+ * *****************  version 1  *****************
+ * user: demoment     date: 02/08/07   time: 08:32
+ * updated in $/source/tx/inc
+ * initial version
+ *
+ *  \endverbatim
+ *
+ * */
+
+#ifndef DLHDMITX_TYPES_H
+#define DLHDMITX_TYPES_H
+
+/*============================================================================*/
+/*                       INCLUDE FILES                                        */
+/*============================================================================*/
+
+#include "tmNxTypes.h"
+
+/*============================================================================*/
+/*                       MACRO DEFINITIONS                                    */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                                DEFINES                                     */
+/*============================================================================*/
+
+/**< Error Codes */
+#define ERR_DLHDMITX_BASE                      0x100
+#define ERR_DLHDMITX_COMPATIBILITY             (ERR_DLHDMITX_BASE + ERR_COMPATIBILITY)             /**< SW Interface compatibility   */
+#define ERR_DLHDMITX_MAJOR_VERSION             (ERR_DLHDMITX_BASE + ERR_MAJOR_VERSION)             /**< SW Major Version error       */
+#define ERR_DLHDMITX_COMP_VERSION              (ERR_DLHDMITX_BASE + ERR_COMP_VERSION)              /**< SW component version error   */
+#define ERR_DLHDMITX_BAD_UNIT_NUMBER           (ERR_DLHDMITX_BASE + ERR_BAD_UNIT_NUMBER)           /**< Invalid device unit number   */
+#define ERR_DLHDMITX_BAD_INSTANCE              (ERR_DLHDMITX_BASE + ERR_BAD_INSTANCE)              /**< Bad input instance value     */
+#define ERR_DLHDMITX_BAD_HANDLE                (ERR_DLHDMITX_BASE + ERR_BAD_HANDLE)                /**< Bad input handle             */
+#define ERR_DLHDMITX_BAD_PARAMETER             (ERR_DLHDMITX_BASE + ERR_BAD_PARAMETER)             /**< Invalid input parameter      */
+#define ERR_DLHDMITX_NO_RESOURCES              (ERR_DLHDMITX_BASE + ERR_NO_RESOURCES)              /**< Resource is not available    */
+#define ERR_DLHDMITX_RESOURCE_OWNED            (ERR_DLHDMITX_BASE + ERR_RESOURCE_OWNED)            /**< Resource is already in use   */
+#define ERR_DLHDMITX_RESOURCE_NOT_OWNED        (ERR_DLHDMITX_BASE + ERR_RESOURCE_NOT_OWNED)        /**< Caller does not own resource */
+#define ERR_DLHDMITX_INCONSISTENT_PARAMS       (ERR_DLHDMITX_BASE + ERR_INCONSISTENT_PARAMS)       /**< Inconsistent input params    */
+#define ERR_DLHDMITX_NOT_INITIALIZED           (ERR_DLHDMITX_BASE + ERR_NOT_INITIALIZED)           /**< Component is not initialized */
+#define ERR_DLHDMITX_NOT_SUPPORTED             (ERR_DLHDMITX_BASE + ERR_NOT_SUPPORTED)             /**< Function is not supported    */
+#define ERR_DLHDMITX_INIT_FAILED               (ERR_DLHDMITX_BASE + ERR_INIT_FAILED)               /**< Initialization failed        */
+#define ERR_DLHDMITX_BUSY                      (ERR_DLHDMITX_BASE + ERR_BUSY)                      /**< Component is busy            */
+#define ERR_DLHDMITX_I2C_READ                  (ERR_DLHDMITX_BASE + ERR_READ)                      /**< Read error                   */
+#define ERR_DLHDMITX_I2C_WRITE                 (ERR_DLHDMITX_BASE + ERR_WRITE)                     /**< Write error                  */
+#define ERR_DLHDMITX_FULL                      (ERR_DLHDMITX_BASE + ERR_FULL)                      /**< Queue is full                */
+#define ERR_DLHDMITX_NOT_STARTED               (ERR_DLHDMITX_BASE + ERR_NOT_STARTED)               /**< Function is not started      */
+#define ERR_DLHDMITX_ALREADY_STARTED           (ERR_DLHDMITX_BASE + ERR_ALREADY_STARTED)           /**< Function is already started  */
+#define ERR_DLHDMITX_ASSERTION                 (ERR_DLHDMITX_BASE + ERR_ASSERTION)                 /**< Assertion failure            */
+#define ERR_DLHDMITX_INVALID_STATE             (ERR_DLHDMITX_BASE + ERR_INVALID_STATE)             /**< Invalid state for function   */
+#define ERR_DLHDMITX_OPERATION_NOT_PERMITTED   (ERR_DLHDMITX_BASE + ERR_OPERATION_NOT_PERMITTED)   /**< Corresponds to posix EPERM   */
+#define ERR_DLHDMITX_RESOLUTION_UNKNOWN        (ERR_DLHDMITX_BASE + ERR_BAD_FORMAT)                /**< Bad format                   */
+
+/* Defined here for tx_CmpTst */
+#define ERR_DLHDMITX_COMP                      ERR_DLHDMITX_BASE | ERR_COMP_UNIQUE_START
+#define DL_DLHDMITX_HDCP_SECURE                   (ERR_DLHDMITX_COMP + 0x0001) /**< Revocation list is secure */
+#define DL_DLHDMITX_HDCP_NOT_SECURE               (ERR_DLHDMITX_COMP + 0x0002) /**< Revocation list is NOT secure */
+
+/*============================================================================*/
+/*                       ENUM OR TYPE DEFINITIONS                             */
+/*============================================================================*/
+
+/**
+ * \brief Enum listing all events that can be signalled to application
+ * */
+typedef enum {
+	/**< HDCP encryption status switched to active */
+	DL_HDMITX_HDCP_ACTIVE         = 0,
+	/**< HDCP encryption status switched to inactive */
+	DL_HDMITX_HDCP_INACTIVE       = 1,
+	/**< Hotplug status switched to active */
+	DL_HDMITX_HPD_ACTIVE          = 2,
+	/**< Hotplug status switched to inactive */
+	DL_HDMITX_HPD_INACTIVE        = 3,
+	DL_HDMITX_RX_KEYS_RECEIVED    = 4,    /**< Receiver(s) key(s) received */
+	/**< Rx device is connected and active */
+	DL_HDMITX_RX_DEVICE_ACTIVE    = 5,
+	/**< Rx device is connected but inactive (standby) */
+	DL_HDMITX_RX_DEVICE_INACTIVE  = 6,
+	DL_HDMITX_EDID_RECEIVED       = 7,    /**< EDID has been received */
+	/**< VS interrupt has been received */
+	DL_HDMITX_VS_RPT_RECEIVED     = 8
+} tx_event_t;
+
+/**
+ * \brief Enum listing all available event status
+ * */
+typedef enum {
+	DL_HDMITX_EVENT_ENABLED,  /**< Event is enabled */
+	DL_HDMITX_EVENT_DISABLED  /**< Event is disabled */
+} tx_event_status_t;
+
+/**
+ * \brief Callback function pointer type, used to allow driver to callback
+ *          application when activity status is changing at input.
+ * \param Event Identifier of the source event.
+ * */
+typedef void (*ptx_callback_t)(tx_event_t event);
+
+/**
+ * \brief Enum listing all supported device versions
+ * */
+typedef enum {
+	DL_HDMITX_DEVICE_UNKNOWN,  /**< HW device is unknown */
+	DL_HDMITX_DEVICE_TDA9984,  /**< HW device is IC TDA9984 */
+	DL_HDMITX_DEVICE_TDA9989,  /**< HW device is IC TDA9989 */
+	DL_HDMITX_DEVICE_LIPP4200, /**< HW device is IP LIPP4200 */
+	DL_HDMITX_DEVICE_TDA9981,  /**< HW device is IC TDA9981 */
+	DL_HDMITX_DEVICE_TDA9983   /**< HW device is IC TDA9983 */
+} tx_device_version_t;
+
+/**
+ * \brief Enum defining the supported HDMI standard version
+ * */
+typedef enum {
+	DL_HDMITX_HDMI_VERSION_UNKNOWN, /**< Unknown   */
+	DL_HDMITX_HDMI_VERSION_1_1,     /**< HDMI 1.1  */
+	dl_hdmitx_hdmi_version_1_2a,    /**< HDMI 1.2a */
+	dl_hdmitx_hdmi_version_1_3a     /**< HDMI 1.3  */
+} tx_hdmi_version_t;
+
+/**
+ * \brief Enum listing all color depth (8 bits/color, 10 bits/color, etc.)
+ * */
+typedef enum {
+	DL_HDMITX_COLORDEPTH_24   = 0,    /**< 8 bits per color */
+	DL_HDMITX_COLORDEPTH_30   = 1,    /**< 10 bits per color */
+	DL_HDMITX_COLORDEPTH_36   = 2,    /**< 12 bits per color */
+	DL_HDMITX_COLORDEPTH_48   = 3,    /**< 16 bits per color */
+} tx_color_depth_t;
+
+/**
+ * \brief Enum defining the EDID Status
+ * */
+typedef enum {
+	DL_HDMITX_EDID_READ                = 0,   /**< All blocks read OK */
+	/**< All blocks read OK but buffer too small to return all of them */
+	DL_HDMITX_EDID_READ_INCOMPLETE     = 1,
+	DL_HDMITX_EDID_ERROR_CHK_BLOCK_0   = 2,   /**< Block 0 checksum error */
+	/**< Block 0 OK, checksum error in one or more other blocks */
+	DL_HDMITX_EDID_ERROR_CHK           = 3,
+	DL_HDMITX_EDID_NOT_READ            = 4,   /**< EDID not read */
+	DL_HDMITX_EDID_STATUS_INVALID      = 5    /**< Invalid   */
+} tx_edid_status_t;
+
+/**
+ * \brief Structure defining the supported audio packets
+ * */
+typedef struct {
+	bool HBR;              /**< High Bitrate Audio packet */
+	bool DST;              /**< Direct Stream Transport audio packet */
+	bool one_bit_audio;      /**< One Bit Audio sample packet */
+} tx_audio_packet_t;
+
+/**
+ * \brief Enum listing all possible audio input formats
+ * */
+typedef enum {
+	DL_HDMITX_AFMT_SPDIF      = 0, /**< SPDIF */
+	DL_HDMITX_AFMT_I2S        = 1, /**< I2S */
+	DL_HDMITX_AFMT_OBA        = 2, /**< One bit audio / DSD */
+	DL_HDMITX_AFMT_DST        = 3, /**< DST */
+	DL_HDMITX_AFMT_HBR        = 4  /**< HBR */
+} tx_audio_format_t;
+
+/**
+ * \brief Enum listing all possible audio input sample rates
+ * */
+typedef enum {
+	DL_HDMITX_AFS_32K           = 0, /**< 32kHz    */
+	DL_HDMITX_AFS_44K           = 1, /**< 44.1kHz  */
+	DL_HDMITX_AFS_48K           = 2, /**< 48kHz    */
+	DL_HDMITX_AFS_88K           = 3, /**< 88.2kHz  */
+	DL_HDMITX_AFS_96K           = 4, /**< 96kHz    */
+	DL_HDMITX_AFS_176K          = 5, /**< 176.4kHz */
+	DL_HDMITX_AFS_192K          = 6  /**< 192kHz   */
+} tx_audio_rate_t;
+
+/**
+ * \brief Enum listing all possible audio input sample rates
+ * */
+typedef enum {
+	DL_HDMITX_I2SQ_16BITS       = 16, /**< 16 bits */
+	DL_HDMITX_I2SQ_32BITS       = 32, /**< 32 bits */
+	DL_HDMITX_I2SQ_OTHERS       = 0,  /**< for SPDIF and DSD */
+} tx_audio_i2squalifier_t;
+
+/**
+ * \brief Enum listing all possible audio I2S formats
+ * */
+typedef enum {
+	DL_HDMITX_I2SFOR_PHILIPS_L   = 0,	/**< Philips like format */
+	/**< Other non Philips left justified */
+	DL_HDMITX_I2SFOR_OTH_L       = 2,
+	/**< Other non Philips right justified */
+	DL_HDMITX_I2SFOR_OTH_R	   = 3,
+	DL_HDMITX_I2SFOR_INVALID     = 4	/**< Invalid format */
+} tx_audio_i2sformat_t;
+
+/**
+ * \brief Enum listing all possible DST data transfer rates
+ * */
+typedef enum {
+	DL_HDMITX_DSTRATE_SINGLE  = 0,    /**< Single transfer rate */
+	DL_HDMITX_DSTRATE_DOUBLE  = 1     /**< Double data rate */
+} tx_dst_rate_t;
+
+/**
+ * \brief Structure describing unit capabilities
+ * */
+typedef struct {
+	tx_device_version_t   device_version;  /**< HW device version */
+	/**< Supported HDMI standard version  */
+	tx_hdmi_version_t     hdmi_version;
+	tx_audio_packet_t     audio_packet;    /**< Supported audio packets */
+	tx_color_depth_t      color_depth;     /**< Supported color depth */
+	/**< Supported Hdcp encryption (true/false) */
+	bool                        hdcp;
+	/**< Supported scaler (true/false) */
+	bool                        scaler;
+} tx_capabilities_t;
+
+/**
+ * \brief Structure gathering all instance setup parameters
+ * */
+typedef struct {
+	bool    simplay_hd;          /**< Enable simplayHD support */
+	bool    repeater_enable;     /**< Enable repeater mode */
+	u8   *p_edid_buffer;       /**< Pointer to raw EDID data */
+	u32  edid_buffer_size;     /**< Size of buffer for raw EDID data */
+} tx_instance_setup_info_t;
+
+/**
+ * \brief Enum listing all IA/CEA 861-D video formats
+ * */
+typedef enum {
+	/**< Not a valid format...        */
+	DL_HDMITX_VFMT_NULL               = 0,
+	/**< ...or no change required     */
+	DL_HDMITX_VFMT_NO_CHANGE          = 0,
+	/**< Lowest valid format          */
+	DL_HDMITX_VFMT_MIN                = 1,
+	/**< Lowest valid TV format       */
+	DL_HDMITX_VFMT_TV_MIN             = 1,
+	/**< Format 01 640  x 480p  60Hz  */
+	dl_hdmitx_vfmt_01_640x480p_60hz   = 1,
+	/**< Format 02 720  x 480p  60Hz  */
+	dl_hdmitx_vfmt_02_720x480p_60hz   = 2,
+	/**< Format 03 720  x 480p  60Hz  */
+	dl_hdmitx_vfmt_03_720x480p_60hz   = 3,
+	/**< Format 04 1280 x 720p  60Hz  */
+	dl_hdmitx_vfmt_04_1280x720p_60hz  = 4,
+	/**< Format 05 1920 x 1080i 60Hz  */
+	dl_hdmitx_vfmt_05_1920x1080i_60hz = 5,
+	/**< Format 06 720  x 480i  60Hz  */
+	dl_hdmitx_vfmt_06_720x480i_60hz   = 6,
+	/**< Format 07 720  x 480i  60Hz  */
+	dl_hdmitx_vfmt_07_720x480i_60hz   = 7,
+	/**< Format 08 720  x 240p  60Hz  */
+	dl_hdmitx_vfmt_08_720x240p_60hz   = 8,
+	/**< Format 09 720  x 240p  60Hz  */
+	dl_hdmitx_vfmt_09_720x240p_60hz   = 9,
+	/**< Format 10 720  x 480i  60Hz  */
+	dl_hdmitx_vfmt_10_720x480i_60hz   = 10,
+	/**< Format 11 720  x 480i  60Hz  */
+	dl_hdmitx_vfmt_11_720x480i_60hz   = 11,
+	/**< Format 12 720  x 240p  60Hz  */
+	dl_hdmitx_vfmt_12_720x240p_60hz   = 12,
+	/**< Format 13 720  x 240p  60Hz  */
+	dl_hdmitx_vfmt_13_720x240p_60hz   = 13,
+	/**< Format 14 1440 x 480p  60Hz  */
+	dl_hdmitx_vfmt_14_1440x480p_60hz  = 14,
+	/**< Format 15 1440 x 480p  60Hz  */
+	dl_hdmitx_vfmt_15_1440x480p_60hz  = 15,
+	/**< Format 16 1920 x 1080p 60Hz  */
+	dl_hdmitx_vfmt_16_1920x1080p_60hz = 16,
+	/**< Format 17 720  x 576p  50Hz  */
+	dl_hdmitx_vfmt_17_720x576p_50hz   = 17,
+	/**< Format 18 720  x 576p  50Hz  */
+	dl_hdmitx_vfmt_18_720x576p_50hz   = 18,
+	/**< Format 19 1280 x 720p  50Hz  */
+	dl_hdmitx_vfmt_19_1280x720p_50hz  = 19,
+	/**< Format 20 1920 x 1080i 50Hz  */
+	dl_hdmitx_vfmt_20_1920x1080i_50hz = 20,
+	/**< Format 21 720  x 576i  50Hz  */
+	dl_hdmitx_vfmt_21_720x576i_50hz   = 21,
+	/**< Format 22 720  x 576i  50Hz  */
+	dl_hdmitx_vfmt_22_720x576i_50hz   = 22,
+	/**< Format 23 720  x 288p  50Hz  */
+	dl_hdmitx_vfmt_23_720x288p_50hz   = 23,
+	/**< Format 24 720  x 288p  50Hz  */
+	dl_hdmitx_vfmt_24_720x288p_50hz   = 24,
+	/**< Format 25 720  x 576i  50Hz  */
+	dl_hdmitx_vfmt_25_720x576i_50hz   = 25,
+	/**< Format 26 720  x 576i  50Hz  */
+	dl_hdmitx_vfmt_26_720x576i_50hz   = 26,
+	/**< Format 27 720  x 288p  50Hz  */
+	dl_hdmitx_vfmt_27_720x288p_50hz   = 27,
+	/**< Format 28 720  x 288p  50Hz  */
+	dl_hdmitx_vfmt_28_720x288p_50hz   = 28,
+	/**< Format 29 1440 x 576p  50Hz  */
+	dl_hdmitx_vfmt_29_1440x576p_50hz  = 29,
+	/**< Format 30 1440 x 576p  50Hz  */
+	dl_hdmitx_vfmt_30_1440x576p_50hz  = 30,
+	/**< Format 31 1920 x 1080p 50Hz  */
+	dl_hdmitx_vfmt_31_1920x1080p_50hz = 31,
+	/**< Format 32 1920 x 1080p 24Hz  */
+	dl_hdmitx_vfmt_32_1920x1080p_24hz = 32,
+	/**< Format 33 1920 x 1080p 25Hz  */
+	dl_hdmitx_vfmt_33_1920x1080p_25hz = 33,
+	/**< Format 34 1920 x 1080p 30Hz  */
+	dl_hdmitx_vfmt_34_1920x1080p_30hz = 34,
+	/**< Highest valid TV format      */
+	DL_HDMITX_VFMT_TV_MAX             = 34,
+	/**< Lowest TV format without prefetched table */
+	DL_HDMITX_VFMT_TV_NO_REG_MIN      = 32,
+	/**< Number of TV formats & null  */
+	DL_HDMITX_VFMT_TV_NUM             = 35,
+	/**< Lowest valid PC format       */
+	DL_HDMITX_VFMT_PC_MIN             = 128,
+	/**< PC format 128                */
+	dl_hdmitx_vfmt_pc_640x480p_60hz   = 128,
+	/**< PC format 129                */
+	dl_hdmitx_vfmt_pc_800x600p_60hz   = 129,
+	/**< PC format 130                */
+	dl_hdmitx_vfmt_pc_1152x960p_60hz  = 130,
+	/**< PC format 131                */
+	dl_hdmitx_vfmt_pc_1024x768p_60hz  = 131,
+	/**< PC format 132                */
+	dl_hdmitx_vfmt_pc_1280x768p_60hz  = 132,
+	/**< PC format 133                */
+	dl_hdmitx_vfmt_pc_1280x1024p_60hz = 133,
+	/**< PC format 134                */
+	dl_hdmitx_vfmt_pc_1360x768p_60hz  = 134,
+	/**< PC format 135                */
+	dl_hdmitx_vfmt_pc_1400x1050p_60hz = 135,
+	/**< PC format 136                */
+	dl_hdmitx_vfmt_pc_1600x1200p_60hz = 136,
+	/**< PC format 137                */
+	dl_hdmitx_vfmt_pc_1024x768p_70hz  = 137,
+	/**< PC format 138                */
+	dl_hdmitx_vfmt_pc_640x480p_72hz   = 138,
+	/**< PC format 139                */
+	dl_hdmitx_vfmt_pc_800x600p_72hz   = 139,
+	/**< PC format 140                */
+	dl_hdmitx_vfmt_pc_640x480p_75hz   = 140,
+	/**< PC format 141                */
+	dl_hdmitx_vfmt_pc_1024x768p_75hz  = 141,
+	/**< PC format 142                */
+	dl_hdmitx_vfmt_pc_800x600p_75hz   = 142,
+	/**< PC format 143                */
+	dl_hdmitx_vfmt_pc_1024x864p_75hz  = 143,
+	/**< PC format 144                */
+	dl_hdmitx_vfmt_pc_1280x1024p_75hz = 144,
+	/**< PC format 145                */
+	dl_hdmitx_vfmt_pc_640x350p_85hz   = 145,
+	/**< PC format 146                */
+	dl_hdmitx_vfmt_pc_640x400p_85hz   = 146,
+	/**< PC format 147                */
+	dl_hdmitx_vfmt_pc_720x400p_85hz   = 147,
+	/**< PC format 148                */
+	dl_hdmitx_vfmt_pc_640x480p_85hz   = 148,
+	/**< PC format 149                */
+	dl_hdmitx_vfmt_pc_800x600p_85hz   = 149,
+	/**< PC format 150                */
+	dl_hdmitx_vfmt_pc_1024x768p_85hz  = 150,
+	/**< PC format 151                */
+	dl_hdmitx_vfmt_pc_1152x864p_85hz  = 151,
+	/**< PC format 152                */
+	dl_hdmitx_vfmt_pc_1280x960p_85hz  = 152,
+	/**< PC format 153                */
+	dl_hdmitx_vfmt_pc_1280x1024p_85hz = 153,
+	/**< PC format 154                */
+	dl_hdmitx_vfmt_pc_1024x768i_87hz  = 154,
+	/**< Highest valid PC format      */
+	DL_HDMITX_VFMT_PC_MAX             = 154,
+	/**< Number of PC formats         */
+	DL_HDMITX_VFMT_PC_NUM             = (1 + 154 - 128)
+} tx_vid_fmt_t;
+
+/**
+ * \brief Structure defining the EDID short video descriptor
+ * */
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tx_vid_fmt_t  video_format;
+	/**< true if format is the preferred video format */
+	bool                native_video_format;
+} tx_short_vid_desc_t;
+
+/**
+ * \brief Enum listing all picture aspect ratio (H:V) (4:3, 16:9)
+ * */
+typedef enum {
+	/**< Undefined picture aspect ratio */
+	DL_HDMITX_P_ASPECT_RATIO_UNDEFINED    = 0,
+	/**< 6:5 picture aspect ratio (PAR) */
+	DL_HDMITX_P_ASPECT_RATIO_6_5          = 1,
+	DL_HDMITX_P_ASPECT_RATIO_5_4          = 2,    /**< 5:4 PAR */
+	DL_HDMITX_P_ASPECT_RATIO_4_3          = 3,    /**< 4:3 PAR */
+	DL_HDMITX_P_ASPECT_RATIO_16_10        = 4,    /**< 16:10 PAR */
+	DL_HDMITX_P_ASPECT_RATIO_5_3          = 5,    /**< 5:3 PAR */
+	DL_HDMITX_P_ASPECT_RATIO_16_9         = 6,    /**< 16:9 PAR */
+	DL_HDMITX_P_ASPECT_RATIO_9_5          = 7,    /**< 9:5 PAR */
+} tx_pict_aspect_ratio_t;
+
+/**
+ * \brief Enum listing all vertical frequency
+ * */
+typedef enum {
+	dl_hdmitx_vfreq_24hz      = 0,    /**< 24Hz          */
+	dl_hdmitx_vfreq_25hz      = 1,    /**< 25Hz          */
+	dl_hdmitx_vfreq_30hz      = 2,    /**< 30Hz          */
+	dl_hdmitx_vfreq_50hz      = 3,    /**< 50Hz          */
+	dl_hdmitx_vfreq_59hz      = 4,    /**< 59.94Hz       */
+	dl_hdmitx_vfreq_60hz      = 5,    /**< 60Hz          */
+#ifndef FORMAT_PC
+	DL_HDMITX_VFREQ_INVALID   = 6,    /**< Invalid       */
+	DL_HDMITX_VFREQ_NUM       = 6     /**< No. of values */
+#else /* FORMAT_PC */
+	dl_hdmitx_vfreq_70hz      = 6,    /**< 70Hz          */
+	dl_hdmitx_vfreq_72hz      = 7,    /**< 72Hz          */
+	dl_hdmitx_vfreq_75hz      = 8,    /**< 75Hz          */
+	dl_hdmitx_vfreq_85hz      = 9,    /**< 85Hz          */
+	dl_hdmitx_vfreq_87hz      = 10,   /**< 87Hz          */
+	DL_HDMITX_VFREQ_INVALID   = 11,   /**< Invalid       */
+	DL_HDMITX_VFREQ_NUM       = 11    /**< No. of values */
+#endif /* FORMAT_PC */
+} tx_vfreq_t;
+
+/**
+ * \brief Structure storing specifications of a video resolution
+ * */
+typedef struct {
+	/**< Width of the frame in pixels */
+	u16                      width;
+	/**< Height of the frame in pixels */
+	u16                      height;
+	/**< Interlaced mode (true/false) */
+	bool                        interlaced;
+	tx_vfreq_t           vfrequency;    /**< Vertical frequency in Hz */
+	tx_pict_aspect_ratio_t aspect_ratio;   /**< Picture aspect ratio (H:V) */
+} tx_vid_fmt_specs_t;
+
+/**
+ * \brief Enum listing all video input modes (CCIR, RGB, etc.)
+ * */
+typedef enum {
+	DL_HDMITX_VINMODE_CCIR656     = 0,    /**< CCIR656 */
+	DL_HDMITX_VINMODE_RGB444      = 1,    /**< RGB444  */
+	DL_HDMITX_VINMODE_YUV444      = 2,    /**< YUV444  */
+	DL_HDMITX_VINMODE_YUV422      = 3,    /**< YUV422  */
+	DL_HDMITX_VINMODE_NO_CHANGE   = 4,    /**< No change */
+	DL_HDMITX_VINMODE_INVALID     = 5     /**< Invalid */
+} tx_vin_mode_t;
+
+/**
+ * \brief Enum listing all possible sync sources
+ * */
+typedef enum {
+	DL_HDMITX_SYNCSRC_EMBEDDED = 0, /**< Embedded sync */
+	DL_HDMITX_SYNCSRC_EXT_VREF = 1, /**< External sync Vref, Href, Fref */
+	DL_HDMITX_SYNCSRC_EXT_VS   = 2, /**< External sync Vs, Hs */
+} tx_sync_source_t;
+
+/**
+ * \brief Enum listing all output pixel rate (Single, Double, etc.)
+ * */
+typedef enum {
+	DL_HDMITX_PIXRATE_DOUBLE          = 0,        /**< Double pixel rate */
+	DL_HDMITX_PIXRATE_SINGLE          = 1,        /**< Single pixel rate */
+	/**< Single pixel repeated */
+	DL_HDMITX_PIXRATE_SINGLE_REPEATED = 2,
+} tx_pix_rate_t;
+
+/**
+ * \brief Structure defining the video input configuration
+ * */
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tx_vid_fmt_t       format;
+	tx_vin_mode_t      mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
+	tx_sync_source_t   sync_source; /**< Sync source type */
+	tx_pix_rate_t      pixel_rate;  /**< Pixel rate */
+} tx_video_in_config_t;
+
+/**
+ * \brief Enum listing all video output modes (YUV, RGB, etc.)
+ * */
+typedef enum {
+	DL_HDMITX_VOUTMODE_RGB444     = 0,    /**< RGB444    */
+	DL_HDMITX_VOUTMODE_YUV422     = 1,    /**< YUV422    */
+	DL_HDMITX_VOUTMODE_YUV444     = 2,    /**< YUV444    */
+} tx_vout_mode_t;
+
+/**
+ * \brief Enum defining possible quantization range
+ * */
+typedef enum {
+	DL_HDMITX_VQR_DEFAULT = 0, /* Follow HDMI spec. */
+	DL_HDMITX_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
+	DL_HDMITX_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
+} tx_vqr_t;
+
+/**
+ * \brief Structure defining the video output configuration
+ * */
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tx_vid_fmt_t       format;
+	tx_vout_mode_t     mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
+	tx_color_depth_t   color_depth; /**< Color depth */
+	tx_vqr_t          dvi_vqr;     /**< VQR applied in DVI mode */
+} tx_video_out_config_t;
+
+/**
+ * \brief Structure defining the audio input configuration
+ * */
+typedef struct {
+	/**< Audio format (I2S, SPDIF, etc.) */
+	tx_audio_format_t          format;
+	tx_audio_rate_t            rate;           /**< Audio sampling rate */
+	/**< I2S format of the audio input */
+	tx_audio_i2sformat_t       i2s_format;
+	/**< I2S qualifier of the audio input (8,16,32 bits) */
+	tx_audio_i2squalifier_t    i2s_qualifier;
+	tx_dst_rate_t              dst_rate;        /**< DST data transfer rate */
+	/**< Ref to CEA-861D p85 */
+	u8                            channel_allocation;
+} tx_audio_in_config_t;
+
+/**
+ * \brief Enum listing all the type of sunk
+ * */
+typedef enum {
+	DL_HDMITX_SINK_DVI  = 0, /**< DVI  */
+	DL_HDMITX_SINK_HDMI = 1, /**< HDMI */
+	DL_HDMITX_SINK_EDID = 2, /**< As currently defined in EDID */
+} tx_sink_type_t;
+
+/**
+ * \brief Structure defining the content of a gamut packet
+ * */
+typedef struct {
+	/**< Gamut relevant for field following packet insertion */
+	bool   next_field;
+	/**< Profile of the gamut packet : 0 = P0, 1 = P1 */
+	u8  gbd_profile;
+	/**< Gamut sequence number of the field that have to be affected by this gamut packet */
+	u8  affected_gamut_seq_num;
+	/**< Current field not using specific gamut */
+	bool   no_current_gbd;
+	/**< Gamut sequence number of the current field */
+	u8  current_gamut_seq_num;
+	/**< Sequence of the packet inside a multiple packet gamut */
+	u8  packet_sequence;
+	u8  payload[28];         /**< Payload of the gamut packet */
+} tx_gamut_data_t;
+
+/**
+ * \brief Type defining the content of a generic packet
+ * */
+typedef u8 tx_generic_packet[28];
+
+/**
+ * \brief Structure defining the content of an ACP packet
+ * */
+typedef struct {
+	u8 acp_type;
+	u8 acp_data[28];
+} tx_acp_pkt_data_t;
+
+/**
+ * \brief Structure defining the content of an AVI infoframe
+ * */
+typedef struct {
+	/**< RGB or YCbCr indicator. See CEA-861-B table 8 for details */
+	u8  color_indicator;
+	/**< Active information present. Indicates if activeFormatAspectRatio field is valid */
+	u8  active_info_present;
+	u8  bar_information_data_valid;       /**< Bar information data valid */
+	/**< Scan information. See CEA-861-B table 8 for details */
+	u8  scan_information;
+	/**< Colorimetry. See CEA-861-B table 9 for details */
+	u8  colorimetry;
+	/**< Picture aspect ratio. See CEA-861-B table 9 for details */
+	u8  picture_aspect_ratio;
+	/**< Active Format aspect ratio. See CEA-861-B table 10 and Annex H for details */
+	u8  active_format_aspect_ratio;
+	/**< Non-uniform picture scaling. See CEA-861-B table 11 for details */
+	u8  non_uniform_picture_scaling;
+	/**< Video format indentification code. See CEA-861-B section 6.3 for details */
+	u8  video_format_identification_code;
+	/**< Pixel repetition factor. See CEA-861-B table 11 for details */
+	u8  pixel_repetition_factor;
+	u16 line_number_end_top_bar;
+	u16 line_number_start_bottom_bar;
+	u16 line_number_end_left_bar;
+	u16 line_number_start_right_bar;
+} tx_avi_if_data_t;
+
+/**
+ * \brief Structure defining the content of an ACP packet
+ * */
+typedef struct {
+	bool av_mute;
+} tx_gcp_pkt_data_t;
+
+/**
+ * \brief Structure defining the content of an AUD infoframe
+ * */
+typedef struct {
+	u8 coding_type;        /**< Coding type (always set to zero) */
+	/**< Channel count. See CEA-861-B table 17 for details */
+	u8 channel_count;
+	/**< Sample frequency. See CEA-861-B table 18 for details */
+	u8 samplefrequency;
+	/**< Sample frequency. See CEA-861-B table 18 for details */
+	u8 sample_size;
+	/**< Channel allocation. See CEA-861-B section 6.3.2 for details */
+	u8 channel_allocation;
+	/**< Downmix inhibit. See CEA-861-B section 6.3.2 for details */
+	bool  downmix_inhibit;
+	/**< level shift value for downmixing. See CEA-861-B section 6.3.2 and table 23 for details */
+	u8 level_shift_value;
+} tx_aud_if_data_t;
+
+/**
+ * \brief Structure defining the content of an ISRC1 packet
+ * */
+typedef struct {
+	bool  isrc_cont;         /**< ISRC packet continued in next packet */
+	/**< Set to one when ISRCStatus and UPC_EAN_ISRC_xx are valid */
+	bool  isrc_valid;
+	u8 isrc_status;       /**< ISRC status */
+	u8 UPC_EAN_ISRC[16]; /**< ISRC packet data */
+} tx_isrc1pkt_data_t;
+
+/**
+ * \brief Structure defining the content of an ISRC2 packet
+ * */
+typedef struct {
+	u8 UPC_EAN_ISRC[16];  /**< ISRC packet data */
+} tx_isrc2pkt_data_t;
+
+/**
+ * \brief Structure defining the content of an MPS infoframe
+ * */
+typedef struct {
+	u32 bit_rate;         /**< MPEG bit rate in Hz */
+	u32 frame_type;       /**< MPEG frame type */
+	bool   field_repeat;     /**< 0: new field, 1:repeated field */
+} tx_mps_if_data_t;
+
+/**
+ * \brief Structure defining the content of an SPD infoframe
+ * */
+typedef struct {
+	u8   vendor_name[8];   /**< Vendor name */
+	u8   product_desc[16]; /**< Product Description */
+	u32  source_dev_info;   /**< Source Device Info */
+} tx_spd_if_data_t;
+
+/**
+ * \brief Structure defining the content of a VS packet
+ * */
+typedef struct {
+	u8 version;
+	u8 vs_data[27];
+} tx_vs_pkt_data_t;
+
+/**
+ * \brief Structure defining the Edid audio descriptor
+ * */
+typedef struct {
+	u8 format;         /* EIA/CEA861 mode */
+	u8 channels;       /* number of channels */
+	u8 supported_freqs; /* bitmask of supported frequencies */
+	u8 supported_res;   /* bitmask of supported resolutions (LPCM only) */
+	/* Maximum bitrate divided by 8KHz (compressed formats only) */
+	u8 max_bitrate;
+} tx_edid_audio_desc_t;
+
+/**
+ * \brief Structure defining detailed timings of a video format
+ * */
+typedef struct {
+	u16  pixel_clock;        /**< Pixel Clock/10 000         */
+	u16  h_active_pixels;     /**< Horizontal Active Pixels   */
+	u16  h_blank_pixels;      /**< Horizontal Blanking Pixels */
+	u16  v_active_lines;      /**< Vertical Active Lines      */
+	u16  v_blank_lines;       /**< Vertical Blanking Lines    */
+	u16  h_sync_offset;       /**< Horizontal Sync Offset     */
+	u16  h_sync_width;        /**< Horiz. Sync Pulse Width    */
+	u16  v_sync_offset;       /**< Vertical Sync Offset       */
+	u16  v_sync_width;        /**< Vertical Sync Pulse Width  */
+	u16  h_image_size;        /**< Horizontal Image Size      */
+	u16  v_image_size;        /**< Vertical Image Size        */
+	u16  h_border_pixels;     /**< Horizontal Border          */
+	u16  v_border_pixels;     /**< Vertical Border            */
+	u8   flags;             /**< Interlace/sync info        */
+} tx_edid_video_timings_t;
+
+/** size descriptor block of monitor descriptor */
+#define EDID_MONITOR_DESCRIPTOR_SIZE   13
+
+/**
+ * \brief Structure defining the first monitor descriptor
+ * */
+typedef struct {
+	/**< true when parameters of struct are available   */
+	bool    desc_record;
+	/**< Monitor Name                                   */
+	u8   monitor_name[EDID_MONITOR_DESCRIPTOR_SIZE];
+} tx_edid_first_md_t;
+
+/**
+ * \brief Structure defining the second monitor descriptor
+ * */
+typedef struct {
+	/**< true when parameters of struct are available   */
+	bool    desc_record;
+	/**< Min vertical rate in Hz                        */
+	u8   min_vertical_rate;
+	/**< Max vertical rate in Hz                        */
+	u8   max_vertical_rate;
+	/**< Min horizontal rate in Hz                      */
+	u8   min_horizontal_rate;
+	/**< Max horizontal rate in Hz                      */
+	u8   max_horizontal_rate;
+	/**< Max suuported pixel clock rate in MHz          */
+	u8   max_supported_pixel_clk;
+} tx_edid_second_md_t;
+
+/**
+ * \brief Structure defining the other monitor descriptor
+ * */
+typedef struct {
+	/**< true when parameters of struct are available   */
+	bool    desc_record;
+	/**< Other monitor Descriptor                       */
+	u8   other_descriptor[EDID_MONITOR_DESCRIPTOR_SIZE];
+} tx_edid_other_md_t;
+
+/**
+ * \brief Test pattern types
+ * */
+typedef enum {
+	DL_HDMITX_PATTERN_OFF     = 0, /**< Insert test pattern       */
+	DL_HDMITX_PATTERN_CBAR4   = 1, /**< Insert 4-bar colour bar   */
+	DL_HDMITX_PATTERN_CBAR8   = 2, /**< Insert 8-bar colour bar   */
+	DL_HDMITX_PATTERN_BLUE	= 3, /**< Insert Blue screen        */
+	DL_HDMITX_PATTERN_BLACK   = 4, /**< Insert Black screen       */
+	DL_HDMITX_PATTERN_INVALID = 5  /**< Invalid pattern		    */
+} tx_test_pattern_t;
+
+/**
+ * \brief Enum listing all hdcp state
+ * */
+typedef enum {
+	DL_HDMITX_HDCP_CHECK_NOT_STARTED       = 0,    /**< Check not started */
+	/**< No failures, more to do */
+	DL_HDMITX_HDCP_CHECK_IN_PROGRESS       = 1,
+	/**< Final check has passed */
+	DL_HDMITX_HDCP_CHECK_PASS              = 2,
+	/**< First check failure code */
+	DL_HDMITX_HDCP_CHECK_FAIL_FIRST        = 3,
+	/**< Driver not AUTHENTICATED */
+	DL_HDMITX_HDCP_CHECK_FAIL_DRIVER_STATE = 3,
+	/**< A T0 interrupt occurred */
+	DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_T0    = 4,
+	DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_RI    = 5,    /**< Device RI changed */
+	DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM   = 6,    /**< Device FSM not 10h */
+	/**< Number of check results */
+	DL_HDMITX_HDCP_CHECK_NUM               = 7
+} tx_hdcp_check_t;
+
+/**
+ * \brief Enum listing all hdcp option flags
+ * */
+typedef enum {
+	/* Not set: obey PJ result     */
+	DL_HDMITX_HDCP_OPTION_FORCE_PJ_IGNORED    = 0x01,
+	/* Not set: obey BCAPS setting */
+	DL_HDMITX_HDCP_OPTION_FORCE_SLOW_DDC      = 0x02,
+	/* Not set: obey BCAPS setting */
+	DL_HDMITX_HDCP_OPTION_FORCE_NO_1_1        = 0x04,
+	/* Not set: obey BCAPS setting */
+	DL_HDMITX_HDCP_OPTION_FORCE_REPEATER      = 0x08,
+	/* Not set: obey BCAPS setting */
+	DL_HDMITX_HDCP_OPTION_FORCE_NO_REPEATER   = 0x10,
+	/* Not set: obey V=V' result   */
+	DL_HDMITX_HDCP_OPTION_FORCE_V_EQU_VBAR    = 0x20,
+	DL_HDMITX_HDCP_OPTION_FORCE_VSLOW_DDC     = 0x40, /* Set: 50kHz DDC */
+	/* All the above Not Set vals */
+	DL_HDMITX_HDCP_OPTION_DEFAULT             = 0x00,
+	/* Only these bits are allowed */
+	DL_HDMITX_HDCP_OPTION_MASK                = 0x7F,
+	/* These bits are not allowed  */
+	DL_HDMITX_HDCP_OPTION_MASK_BAD            = 0x80
+} tx_hdcp_options_t;
+
+typedef enum {
+	DL_HDMITX_HOTPLUG_INACTIVE    = 0,    /**< Hotplug inactive */
+	DL_HDMITX_HOTPLUG_ACTIVE      = 1,    /**< Hotplug active   */
+	DL_HDMITX_HOTPLUG_INVALID     = 2     /**< Invalid Hotplug  */
+} tx_hot_plug_t;
+
+#endif /* DLHDMITX_TYPES_H */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
+
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx.c b/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx.c
new file mode 100755
index 0000000..9864072
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx.c
@@ -0,0 +1,5163 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx.c
+ *
+ * \version       Revision: 1
+ *
+ * \date          Date: 10/08/07 10:00
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   History:       tx.c
+ *
+ * *****************  Version 1  *****************
+ * User: J. Lamotte Date: 10/08/07   Time: 10:00
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *   \endverbatim
+ *
+ * */
+
+/*============================================================================*/
+/*                             INCLUDE FILES                                  */
+/*============================================================================*/
+#include "tmdlHdmiTx_IW.h"
+#include "tmdlHdmiTx.h"
+#include "tmdlHdmiTx_local.h"
+#include "tmbslHdmiTx.h"
+#include "tmdlHdmiTx_cfg.h"
+
+/*============================================================================*/
+/*                          TYPES DECLARATIONS                                */
+/*============================================================================*/
+
+/* Macro to avoid compilation warnings */
+#ifdef TMFL_OS_WINDOWS
+#define DUMMY_ACCESS(x) x
+#else
+#define DUMMY_ACCESS(x)
+#endif
+
+/*============================================================================*/
+/*                       CONSTANTS DECLARATIONS                               */
+/*============================================================================*/
+
+/*============================================================================*/
+/*                         FUNCTION PROTOTYPES                                */
+/*============================================================================*/
+
+extern error_code_t bsl_debug_write_fake_reg_page(unit_select_t tx_unit);
+
+/* Prototypes of internal functions */
+/* Task functions */
+#ifndef TMFL_NO_RTOS
+static void command_task_unit0(void);
+static void hdcp_task_unit0(void);
+#endif /* TMFL_NO_RTOS */
+
+/* Interrupt callback functions */
+static void dl_hdmi_tx_handle_encrypt(instance_t instance);
+static void dl_hdmi_tx_handle_hpd(instance_t instance);
+static void dl_hdmi_tx_handle_t0(instance_t instance);
+static void dl_hdmi_tx_handle_bcaps(instance_t instance);
+static void dl_hdmi_tx_handle_bstatus(instance_t instance);
+static void dl_hdmi_tx_handle_sha_1(instance_t instance);
+static void dl_hdmi_tx_handle_pj(instance_t instance);
+#ifdef TMFL_TDA9981_SUPPORT
+static void dl_hdmi_tx_handle_r0(instance_t instance);
+static void dl_hdmi_tx_handle_sw_int(instance_t instance);
+#endif
+#ifdef TMFL_RX_SENSE_ON
+static void dl_hdmi_tx_handle_rx_sense(instance_t instance);
+#endif
+static void dl_hdmi_tx_handle_edid_read(instance_t instance);
+#if 0
+static void dl_hdmi_tx_handle_vs_rpt(instance_t instance);
+#endif
+
+/* Devlib internal color bar management functions */
+static void dl_hdmi_tx_check_color_bar(instance_t instance);
+static void dl_hdmi_tx_check_hdcp_color_bar(instance_t instance);
+
+/* Set the state machine of device library */
+static void dl_hdmi_tx_set_state
+(
+    instance_t instance,
+    tx_driver_state_t state
+);
+
+/* Get the event status (enable or disable) in order to known
+ *   if event should be signaled */
+static tx_event_status_t dl_hdmi_tx_get_event_status
+(
+    instance_t        instance,
+    tx_event_t   event
+);
+
+/* Use by txSetInputOutput in scaler mode */
+static bool dl_hdmi_tx_get_refline_refpix
+(
+    tx_vid_fmt_t      vin_fmt,
+    tx_vin_mode_t     vin_mode,
+    tx_vid_fmt_t      vout_fmt,
+    u8                   sync_in,
+    tx_pix_rate_t     pix_rate,
+    u16                  *p_ref_pix,
+    u16                  *p_ref_line,
+    u16                  *p_sc_ref_pix,
+    u16                  *p_sc_ref_line,
+    bool                    *pb_verified
+);
+
+/* Use by txSetInputOutput to set AVI infoframe */
+static error_code_t dl_hdmi_tx_set_video_infoframe
+(
+    instance_t            instance,
+    tx_vid_fmt_t      vout_fmt,
+    tx_vout_mode_t    vout_mode
+);
+
+/* Get DTD from BSL */
+static error_code_t dl_hdmi_tx_edid_get_dtd
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    u8                           max_dtdesc,
+    u8                           *p_written_dtdesc
+);
+
+/* Convert DTD to CEA */
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_640hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_720hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1280hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1920hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    bool                            format_interlaced
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1440hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio,
+    bool                            format_interlaced
+);
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_2880hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio,
+    bool                            format_interlaced
+);
+
+static tx_pict_aspect_ratio_t dl_hdmi_tx_calc_aspect_ratio(
+    u16    himage_size,
+    u16    vimage_size
+);
+
+/* IMPORTANT: The 3 functions define below should not be declared in static
+ *   in order to allow applicative API to call them. Those functions are not
+ *   in tx_Functions.h but are in txCore.def */
+
+/* Get the device library state */
+tx_driver_state_t dl_hdmi_tx_get_state(instance_t instance);
+
+/* Set pattern ON (Blue screen or color bar) */
+error_code_t dl_hdmi_tx_set_test_pattern_on
+(
+    instance_t            instance,
+    tx_vid_fmt_t		vout_fmt,
+    tx_vout_mode_t    vout_mode,
+    tx_test_pattern_t pattern
+);
+
+/* Set pattern OFF */
+error_code_t dl_hdmi_tx_set_test_pattern_off
+(
+    instance_t            instance,
+    tx_vid_fmt_t      vout_fmt,
+    tx_vout_mode_t    vout_mode
+);
+
+static void dl_hdmi_tx_check_hdcp_bksv
+
+(
+    instance_t    instance,
+    u8          *p_hdcp_bksv_tested,
+    bool           *pb_bksv_secure,
+    bool            b_big_endian
+);
+
+/*============================================================================*/
+/*                       VARIABLES DECLARATIONS                               */
+/*============================================================================*/
+
+tx_iwsem_handle_t dl_hdmi_tx_it_semaphore[MAX_UNITS];
+
+/* Unit configuration structure (device library system configuration) */
+unit_config_t unit_table_tx[MAX_UNITS] = {
+	{
+		false,
+		false,
+		(tx_hdcp_options_t)HDCP_OPT_DEFAULT,
+		false,
+		false,
+		DL_HDMITX_DEVICE_UNKNOWN,
+		0,
+		0,
+		(tx_iwtask_handle_t)0,
+		(tx_iwqueue_handle_t)0,
+		(tx_iwtask_handle_t)0,
+		STATE_NOT_INITIALIZED,
+		(ptx_callback_t)0,
+		{NULL, 0}
+	}
+};
+
+#ifndef TMFL_NO_RTOS
+
+tx_iwfunc_ptr_t command_task_table_tx[MAX_UNITS] = {
+	command_task_unit0
+};
+
+tx_iwfunc_ptr_t hdcp_task_table_tx[MAX_UNITS] = {
+	hdcp_task_unit0
+};
+
+#endif /* TMFL_NO_RTOS */
+
+bsl_callback_list_t callback_func_table_tx;
+
+/* Device library configuration structure completed by txCfgGetConfig with
+ *   informations contained in config file */
+tx_driver_config_table_t gtx_driver_config_table[MAX_UNITS];
+
+/* Video info (see instanceStatusInfoTx) */
+tx_video_info_t video_info_list_tx = {
+	false,
+	{dl_hdmitx_vfmt_03_720x480p_60hz, DL_HDMITX_VINMODE_YUV422, DL_HDMITX_SYNCSRC_EXT_VS, DL_HDMITX_PIXRATE_SINGLE},
+	{dl_hdmitx_vfmt_03_720x480p_60hz, DL_HDMITX_VOUTMODE_YUV422, DL_HDMITX_COLORDEPTH_24}
+};
+
+/* Audio info (see instanceStatusInfoTx) */
+tx_audio_info_t audio_info_list_tx = {
+	false,
+	{
+		DL_HDMITX_AFMT_SPDIF, DL_HDMITX_AFS_48K,
+		DL_HDMITX_I2SFOR_PHILIPS_L, DL_HDMITX_I2SQ_16BITS, DL_HDMITX_DSTRATE_SINGLE, 0x00
+	}
+};
+
+/* Event state (see instanceStatusInfoTx) */
+tx_event_state_t event_state_list_tx[EVENT_NB] = {
+	{DL_HDMITX_HDCP_ACTIVE,           DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_HDCP_INACTIVE,         DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_HPD_ACTIVE,            DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_HPD_INACTIVE,          DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_RX_KEYS_RECEIVED,      DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_RX_DEVICE_ACTIVE,      DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_RX_DEVICE_INACTIVE,    DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_EDID_RECEIVED,         DL_HDMITX_EVENT_DISABLED},
+	{DL_HDMITX_VS_RPT_RECEIVED,       DL_HDMITX_EVENT_DISABLED}
+};
+
+/* Color bars state (see instanceStatusInfoTx) */
+tx_col_bar_state_t color_bar_state_tx = {
+	false,
+	true,
+	true,
+	false,
+	false,
+	true,
+	false
+};
+
+/* Instance status (save the actual configuration) */
+instance_status_t instance_status_info_tx[MAX_UNITS] = {
+	{
+		(ptx_video_info_t)  &video_info_list_tx,
+		(ptx_audio_info_t)  &audio_info_list_tx,
+		(ptx_event_state_t) event_state_list_tx,
+		(ptx_col_bar_state_t) &color_bar_state_tx,
+		0
+	}
+	/*     &videoInfoListTx, */
+	/*     &audioInfoListTx, */
+	/*     eventStateListTx, */
+	/*     &colorBarStateTx, */
+	/*     0 */
+};
+
+/* HDCP seed table, arranged as pairs of 16-bit integers: lookup value, seed value.
+ * If no table is programmed and if KEY_SEED in config file is null, HDCP will be disabled */
+#define SEED_TABLE_LEN 10
+static const u16 k_seed_table[SEED_TABLE_LEN][2] = {
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0},
+	{0, 0}
+};
+
+/* EDID status */
+u8 edid_data_status = HDMITX_EDID_NOT_READ;
+
+/* Flag set in case HDP ACTIVE is detected during initialization */
+bool event_hpdactive_flag = false;
+bool event_call_hpdactive_cback    = false;
+bool event_call_rxsens_active_cback = false;
+
+/* To remove the warnings */
+u8 g_no_warning;
+
+/* For debug purpose only, used to manage underlying I2C accessed */
+static bool g_i2cdebug_accesses_enabled = true;
+
+static u8 g_ksv_secure_timer_counter = 0;
+
+/*============================================================================*/
+/*                              FUNCTIONS                                     */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief Get the software version of the driver.
+ *
+ *    \param pSWVersion Pointer to the version structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_get_swversion
+(
+    swversion_t   *p_swversion
+)
+{
+	/* Check if SWVersion pointer is NULL */
+	RETIF(p_swversion == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Copy SW version */
+	p_swversion->compatibility_nr = VERSION_COMPATIBILITY;
+	p_swversion->major_version_nr = VERSION_MAJOR;
+	p_swversion->minor_version_nr = VERSION_MINOR;
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Get the number of available HDMI transmitters devices in the system.
+ *           A unit directly represents a physical device.
+ *
+ *    \param pUnitCount Pointer to the number of available units.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *
+ ******************************************************************************/
+error_code_t tx_get_number_of_units
+(
+    u32  *p_unit_count
+)
+{
+	/* Check if UnitCount pointer is NULL */
+	RETIF(p_unit_count == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Copy the maximum number of units */
+	*p_unit_count = MAX_UNITS;
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Get the capabilities of unit 0. Capabilities are stored into a
+ *           dedicated structure and are directly read from the HW device.
+ *
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_capabilities
+(
+    tx_capabilities_t    *p_capabilities
+)
+{
+	/* Directly call GetCapabilitiesM function for unit 0 and return the result */
+	return(tx_get_capabilities_m((unit_select_t)0, p_capabilities));
+}
+
+/******************************************************************************
+ *    \brief Get the capabilities of a specific unit. Capabilities are stored
+ *           into a dedicated structure and are directly read from the HW
+ *           device.
+ *
+ *    \param unit          Unit to be probed.
+ *    \param pCapabilities Pointer to the capabilities structure.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the receiver instance is not initialised
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_capabilities_m
+(
+    unit_select_t           unit,
+    tx_capabilities_t *p_capabilities
+)
+{
+	error_code_t   err = 0;
+	bsl_hw_feature_t  bsl_device_capabilities;
+
+	/* Check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMITX_BAD_UNIT_NUMBER)
+
+	/* Check if Capalities pointer is NULL */
+	RETIF(p_capabilities == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Device version */
+	p_capabilities->device_version = unit_table_tx[unit].device_version ;
+
+	/* Retrieve the capabilities from the BSL layer */
+	RETIF((err = bsl_hw_get_capabilities(unit, &bsl_device_capabilities)) != 0, err)
+
+	switch(bsl_device_capabilities) {
+	case bsl_hw_none:    /* None           feature */
+		p_capabilities->hdcp = false;
+		p_capabilities->scaler = false;
+		p_capabilities->audio_packet.HBR = false;
+		p_capabilities->audio_packet.one_bit_audio = true;
+		p_capabilities->audio_packet.DST = false;
+		p_capabilities->hdmi_version = dl_hdmitx_hdmi_version_1_2a;
+		p_capabilities->color_depth = DL_HDMITX_COLORDEPTH_24;
+		break;
+
+	case bsl_hw_hdcp:    /* HDCP           feature */
+		p_capabilities->hdcp = true;
+		p_capabilities->scaler = false;
+		p_capabilities->audio_packet.HBR = false;
+		p_capabilities->audio_packet.one_bit_audio = true;
+		p_capabilities->audio_packet.DST = false;
+		p_capabilities->hdmi_version = dl_hdmitx_hdmi_version_1_2a;
+		p_capabilities->color_depth = DL_HDMITX_COLORDEPTH_24;
+		break;
+
+	case bsl_hw_scaler:  /* Scaler         feature */
+		p_capabilities->hdcp = false;
+		p_capabilities->scaler = true;
+		p_capabilities->audio_packet.HBR = false;
+		p_capabilities->audio_packet.one_bit_audio = true;
+		p_capabilities->audio_packet.DST = false;
+		p_capabilities->hdmi_version = dl_hdmitx_hdmi_version_1_2a;
+		p_capabilities->color_depth = DL_HDMITX_COLORDEPTH_24;
+		break;
+
+	case bsl_hw_hdcpscaler:   /* HDCP & Scaler  feature  */
+		p_capabilities->hdcp = true;
+		p_capabilities->scaler = true;
+		p_capabilities->audio_packet.HBR = false;
+		p_capabilities->audio_packet.one_bit_audio = true;
+		p_capabilities->audio_packet.DST = false;
+		p_capabilities->hdmi_version = dl_hdmitx_hdmi_version_1_2a;
+		p_capabilities->color_depth = DL_HDMITX_COLORDEPTH_24;
+		break;
+	}
+
+	return err;
+}
+
+/******************************************************************************
+ *    \brief Open unit 0 of HdmiTx driver and provides the instance number to
+ *           the caller. Note that one unit of HdmiTx represents one physical
+ *           HDMI transmitter and that only one instance per unit can be opened.
+ *
+ *    \param pInstance Pointer to the variable that will receive the instance
+ *                     identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the transmitter instance is not initialised
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: the unit is not initialized
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_INIT_FAILED: the unit instance is already
+ *              initialised
+ *            - ERR_HDMI_COMPATIBILITY: the driver is not compatiable
+ *              with the internal device version code
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_open
+(
+    instance_t   *p_instance
+)
+{
+	/* Directly call OpenM function for unit 0 and return the result */
+	return(tx_open_m(p_instance, (unit_select_t)0));
+}
+
+/******************************************************************************
+ *    \brief Open a specific unit of HdmiTx driver and provides the instance
+ *           number to the caller. Note that one unit of HdmiTx represents one
+ *           physical HDMI transmitter and that only one instance per unit can be
+ *           opened. This function switches driver's state machine to
+ *           "initialized" state.
+ *
+ *    \param pInstance Pointer to the structure that will receive the instance
+ *                     identifier.
+ *    \param unit      Unit number to be opened.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_UNIT_NUMBER: the unit number is wrong or
+ *              the transmitter instance is not initialised
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_OWNED: the resource is already in use
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INIT_FAILED: the unit instance is already
+ *              initialised or something wrong happened at lower level.
+ *            - ERR_DLHDMITX_NO_RESOURCES: the resource is not available
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: the unit is not initialized
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter is invalid or out
+ *              of range
+ *            - ERR_HDMI_INIT_FAILED: the unit instance is already
+ *              initialised
+ *            - ERR_HDMI_COMPATIBILITY: the driver is not compatiable
+ *              with the internal device version code
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_open_m
+(
+    instance_t   *p_instance,
+    unit_select_t  unit
+)
+{
+	error_code_t           err;
+	u16                  i;
+	u8                   device_version;
+	bsl_hw_feature_t  feature_supported;
+
+	/* Check if unit number is in range */
+	RETIF((unit < 0) || (unit >= MAX_UNITS), ERR_DLHDMITX_BAD_UNIT_NUMBER)
+
+	/* Check if Instance pointer is NULL */
+	RETIF(p_instance == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Create the semaphore to protect variables modified under interruption */
+	RETIF((err = tx_iwsemaphore_create(&dl_hdmi_tx_it_semaphore[unit])) != 0, err)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[unit])) != 0, err)
+
+	/* Check if unit is already instanciated */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          unit_table_tx[unit].opened == true, ERR_DLHDMITX_RESOURCE_OWNED)
+
+	/* Check the state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          dl_hdmi_tx_get_state(unit) != STATE_NOT_INITIALIZED, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Instanciate unit and return corresponding instance number */
+	/* Since HW unit are only instanciable once, instance = unit */
+	unit_table_tx[unit].opened          = true;
+	unit_table_tx[unit].hdcp_enable      = false;
+	unit_table_tx[unit].repeater_enable  = false;
+	unit_table_tx[unit].device_version   = DL_HDMITX_DEVICE_UNKNOWN;
+	unit_table_tx[unit].simplay_hd       = false;
+	unit_table_tx[unit].p_callback       = NULL;
+	unit_table_tx[unit].revocation_list.p_list  = NULL;
+
+	unit_table_tx[unit].revocation_list.length = 0;
+
+	/* Recover the configuration of the device library */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_cfg_get_config(unit, &gtx_driver_config_table[unit]) != 0, ERR_DLHDMITX_INIT_FAILED)
+
+#ifndef TMFL_NO_RTOS
+	/* Create message queue associated to this instance/unit */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_iwqueue_create(gtx_driver_config_table[unit].command_task_queue_size,
+	                            &(unit_table_tx[unit].queue_handle)) != 0, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* Create the command task associated to this instance/unit */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_iwtask_create(command_task_table_tx[unit],
+	                           gtx_driver_config_table[unit].command_task_priority,
+	                           gtx_driver_config_table[unit].command_task_stack_size,
+	                           &(unit_table_tx[unit].command_task_handle)) != 0, ERR_DLHDMITX_NO_RESOURCES)
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_iwtask_start(unit_table_tx[unit].command_task_handle) != 0, ERR_DLHDMITX_NO_RESOURCES)
+
+	/* Create the hdcp check task associated to this instance/unit */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_iwtask_create(hdcp_task_table_tx[unit],
+	                           gtx_driver_config_table[unit].hdcp_task_priority,
+	                           gtx_driver_config_table[unit].hdcp_task_stack_size,
+	                           &(unit_table_tx[unit].hdcp_task_handle)) != 0, ERR_DLHDMITX_NO_RESOURCES)
+
+#endif /* TMFL_NO_RTOS */
+
+	*p_instance = (instance_t)unit;
+
+	/* Init the BSL */
+	/* Make sure all events are disabled */
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_HDCP_ACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_HDCP_INACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_HPD_ACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_HPD_INACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_RX_KEYS_RECEIVED].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_RX_DEVICE_ACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_RX_DEVICE_INACTIVE].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_EDID_RECEIVED].status = DL_HDMITX_EVENT_DISABLED;
+	instance_status_info_tx[unit].p_event_state[DL_HDMITX_VS_RPT_RECEIVED].status = DL_HDMITX_EVENT_DISABLED;
+
+	instance_status_info_tx[unit].p_col_bar_state->disable_color_bar_on_r0 = false;
+	instance_status_info_tx[unit].p_col_bar_state->hdcp_colbar_change = false;
+	instance_status_info_tx[unit].p_col_bar_state->hdcp_encrypt_or_t0 = true;
+	instance_status_info_tx[unit].p_col_bar_state->hdcp_secure_or_t0 = false;
+	instance_status_info_tx[unit].p_col_bar_state->in_out_first_set_done = false;
+	instance_status_info_tx[unit].p_col_bar_state->color_bar_on = true;
+	instance_status_info_tx[unit].p_col_bar_state->change_color_bar_now = true;
+
+	/* use buffer 0 by default */
+	instance_status_info_tx[unit].gamut_buf_num = 0;
+
+	/* The funcCallback is not the same between BSL, so fill it dynamically */
+	for(i = 0; i < HDMITX_CALLBACK_INT_NUM; i++) {
+		callback_func_table_tx.func_callback[i] = NULL;
+	}
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_ENCRYPT] = dl_hdmi_tx_handle_encrypt;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_HPD] = dl_hdmi_tx_handle_hpd;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_T0] = dl_hdmi_tx_handle_t0;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_BCAPS] = dl_hdmi_tx_handle_bcaps;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_BSTATUS] = dl_hdmi_tx_handle_bstatus;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_SHA_1] = dl_hdmi_tx_handle_sha_1;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_PJ] = dl_hdmi_tx_handle_pj;
+
+#ifdef TMFL_TDA9981_SUPPORT
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_R0] = dl_hdmi_tx_handle_r0;
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_SW_INT] = dl_hdmi_tx_handle_sw_int;
+#endif
+
+#ifdef TMFL_RX_SENSE_ON
+	callback_func_table_tx.func_callback[HDMITX_CALLBACK_INT_RX_SENSE] = dl_hdmi_tx_handle_rx_sense;
+#endif
+
+	/* Prepare static TDA9984 driver data as the compiler doesn't seem to */
+	bsl_hw_startup();
+
+	err = bsl_init(*p_instance,
+	               gtx_driver_config_table[unit].i2c_address,
+	               gtx_driver_config_table[unit].i2c_write_function,
+	               gtx_driver_config_table[unit].i2c_read_function,
+	               /* required for TDA9983 */
+	               (pbsl_sys_func_edid_t)gtx_driver_config_table[unit].edid_read_function,
+	               (pbsl_sys_func_timer_t)tx_iwwait,
+	               &callback_func_table_tx,
+	               false, /* Alternate EDID address not used */
+	               (bsl_vid_fmt_t)instance_status_info_tx[unit].p_video_info->video_in_config.format,
+	               (bsl_pix_rate_t)instance_status_info_tx[unit].p_video_info->video_in_config.pixel_rate);
+
+	if(err != 0) {
+		/* Init failed */
+		bsl_deinit(unit);
+
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[unit])) != 0, err)
+
+		return err;
+	} else {
+		/* Init passed, continue */
+		/* Start by forcing the TMDS ouputs off */
+		err = bsl_tmds_set_outputs(unit,
+		                           HDMITX_TMDSOUT_FORCED0);
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[unit], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+		          (err = bsl_hw_get_capabilities(unit, &feature_supported)) != 0, err)
+
+		/* Retrieve the hardware device version from the BSL layer */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+		          (err = bsl_hw_get_version(unit,
+		                                    &device_version)) != 0, err)
+
+		/* Store the hardware device version in the global variable */
+
+		switch(device_version) {
+		case BSLHDMITX_TDA9981:
+			unit_table_tx[unit].device_version = DL_HDMITX_DEVICE_TDA9981;
+			break;
+
+		case BSLHDMITX_TDA9983:
+			unit_table_tx[unit].device_version = DL_HDMITX_DEVICE_TDA9983;
+			break;
+
+		default:
+			unit_table_tx[unit].device_version = DL_HDMITX_DEVICE_UNKNOWN;
+			break;
+		}
+
+	}
+
+#ifndef TMFL_NO_RTOS
+	/* Start HDCP check task */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[unit],
+	          tx_iwtask_start(unit_table_tx[unit].hdcp_task_handle) != 0, ERR_DLHDMITX_NO_RESOURCES)
+
+#endif /* TMFL_NO_RTOS */
+
+	/* Set the state machine to initialized */
+	dl_hdmi_tx_set_state(unit, STATE_INITIALIZED);
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[unit])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Close an instance of HdmiTx driver.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_close
+(
+    instance_t    instance
+)
+{
+	error_code_t   err = 0;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check if unit corresponding to instance is opened */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          unit_table_tx[instance].opened == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	/* Close instance */
+	unit_table_tx[instance].opened = false;
+
+	/* Set the state machine */
+	dl_hdmi_tx_set_state(instance, STATE_NOT_INITIALIZED);
+
+	/* Destroy resources allocated for this instance/unit */
+
+#ifndef TMFL_NO_RTOS
+	tx_iwtask_destroy(unit_table_tx[instance].hdcp_task_handle);
+	tx_iwtask_destroy(unit_table_tx[instance].command_task_handle);
+	tx_iwqueue_destroy(unit_table_tx[instance].queue_handle);
+
+#endif /* TMFL_NO_RTOS */
+
+	/* Reset an instance of an HDMI transmitter */
+	bsl_deinit(instance);
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Close the handle to the semaphore */
+	RETIF((err == tx_iwsemaphore_destroy(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Set the power state of an instance of the HDMI transmitter.
+ *
+ *    \param instance   Instance identifier.
+ *    \param powerState Power state to set.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *
+ ******************************************************************************/
+error_code_t tx_set_power_state
+(
+    instance_t    instance,
+    power_state_t  power_state
+)
+{
+	error_code_t           err;
+	bsl_hot_plug_t    hpd_status;  /* HPD status */
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(unit_table_tx[instance].device_version == DL_HDMITX_DEVICE_TDA9984) {
+		if(power_state == power_suspend) {
+			return ERR_DLHDMITX_NOT_SUPPORTED;
+		}
+	}
+
+	/* Switch off HDCP */
+	if((power_state == power_off) && (unit_table_tx[instance].hdcp_enable == true)) {
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+		/* Switch off HDCP */
+		RETIF((err = tx_set_hdcp(instance, false)) != 0, err)
+		/* Take the sempahore */
+		RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+	}
+
+	/* CBE */
+	if(power_state == power_off) {
+		dl_hdmi_tx_set_state(instance, STATE_INITIALIZED);
+	}
+
+	/* Set the power state of the transmitter */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_power_set_state(instance,
+	                                     power_state)) != 0, err)
+
+	/* Get Hot Plug status */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_hot_plug_get_status(instance,
+	                  &hpd_status)) != 0, err)
+
+	if(power_state == power_on) {
+		if((hpd_status == HDMITX_HOTPLUG_ACTIVE) && (dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE)) {
+			/* Yes: Wait for DDC line to settle before reading EDID */
+			bsl_sys_timer_wait(instance, 500); /* ms */
+
+			/* EDID read */
+
+			RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+			          (err = bsl_edid_get_block_data(instance,
+			                  unit_table_tx[instance].p_edid_buffer, (u32)((unit_table_tx[instance].edid_buffer_size) >> 7),
+			                  unit_table_tx[instance].edid_buffer_size, &edid_data_status)) != 0, err)
+
+			dl_hdmi_tx_handle_edid_read(instance);
+		}
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Get the power state of an instance of the HDMI transmitter.
+ *
+ *    \param instance    Instance identifier.
+ *    \param pPowerState Pointer to the power state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_power_state
+(
+    instance_t    instance,
+    power_state_t  *p_power_state
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if PowerState pointer is NULL */
+	RETIF(p_power_state == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Get the power state of the transmitter */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_power_get_state(instance,
+	                                     p_power_state)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Set the configuration of instance attributes. This function is
+ *           required by DVP architecture rules but actually does nothing in this
+ *           driver.
+ *
+ *    \param instance    Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *
+ ******************************************************************************/
+error_code_t tx_instance_config
+(
+    instance_t    instance
+)
+{
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Setup the instance with its configuration parameters. This function
+ *           allows basic instance configuration like enabling HDCP, choosing
+ *           HDCP encryption mode or enabling HDCP repeater mode.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure containing all setup parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ ******************************************************************************/
+error_code_t tx_instance_setup
+(
+    instance_t                    instance,
+    tx_instance_setup_info_t   *p_setup_info
+)
+{
+	error_code_t   err;
+
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if SetupInfo pointer is NULL */
+	RETIF(p_setup_info == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check if unit corresponding to instance is opened */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          unit_table_tx[instance].opened == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	/* Check the state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_INITIALIZED, ERR_DLHDMITX_INVALID_STATE)
+
+	unit_table_tx[instance].repeater_enable = p_setup_info->repeater_enable;
+	unit_table_tx[instance].simplay_hd = p_setup_info->simplay_hd;
+	unit_table_tx[instance].p_edid_buffer = p_setup_info->p_edid_buffer;
+	unit_table_tx[instance].edid_buffer_size = p_setup_info->edid_buffer_size;
+
+	/* Set state machine to Unplugged */
+	dl_hdmi_tx_set_state(instance, STATE_UNPLUGGED);
+
+	if(event_hpdactive_flag == true) {
+		/* if the HPD active was rased during the initialisation, raise the event HPD */
+		dl_hdmi_tx_handle_hpd(instance);
+		event_hpdactive_flag = false;
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Get instance setup parameters.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pSetupInfo Pointer to the structure that will receive setup
+ *                      parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *
+ ******************************************************************************/
+error_code_t tx_get_instance_setup
+(
+    instance_t                    instance,
+    tx_instance_setup_info_t   *p_setup_info
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if SetupInfo pointer is NULL */
+	RETIF(p_setup_info == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check if unit corresponding to instance is opened */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          unit_table_tx[instance].opened == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	p_setup_info->simplay_hd          = unit_table_tx[instance].simplay_hd;
+	p_setup_info->repeater_enable     = unit_table_tx[instance].repeater_enable;
+	/* JL, TODO */
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Make device library handle an incoming interrupt. This function is
+ *           used by application to tell the device library that the hardware
+ *           sent an interrupt.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_FULL: the queue is full
+ *
+ ******************************************************************************/
+error_code_t tx_handle_interrupt
+(
+    instance_t    instance
+)
+{
+#ifndef TMFL_NO_RTOS
+	error_code_t err;
+	u8         message = 0;
+#endif /* TMFL_NO_RTOS */
+
+	error_code_t err     = 0;
+
+	(void)err;
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+#ifndef TMFL_NO_RTOS
+	RETIF((err = tx_iwqueue_send(unit_table_tx[instance].queue_handle, message)) != 0, err)
+
+	/* Disable interrupts for Tx until the callbacks have been done by the command task */
+	switch(instance) {
+	case INSTANCE_0:
+		tx_iwdisable_interrupts(DL_HDMI_IW_TX_1);
+		break;
+	case INSTANCE_1:
+		tx_iwdisable_interrupts(DL_HDMI_IW_TX_2);
+		break;
+	default:
+		return ERR_DLHDMITX_BAD_INSTANCE;
+	}
+
+#endif /* TMFL_NO_RTOS */
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Register event callbacks. Only one callback is registered through
+ *           this API. This callback will received the type of event that
+ *           occured throug a dedicated parameter and will be called as many
+ *           times as there is pending events.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param pCallback  Pointer to the callback function that will handle events
+ *                      from the devlib.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_RESOURCE_NOT_OWNED: the caller does not own
+ *              the resource
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *
+ ******************************************************************************/
+error_code_t tx_register_callbacks
+(
+    instance_t            instance,
+    ptx_callback_t   p_callback
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check if unit corresponding to instance is opened */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          unit_table_tx[instance].opened == false, ERR_DLHDMITX_RESOURCE_NOT_OWNED)
+
+	/* Check if instance state is correct */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_INITIALIZED, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Store callback pointers */
+	unit_table_tx[instance].p_callback = p_callback;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief This function allows enabling a specific event. By default, all
+ *           events are disabled, except input lock.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to enable.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_enable_event
+(
+    instance_t        instance,
+    tx_event_t   event
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if the event exists */
+	RETIF_BADPARAM(event >= EVENT_NB)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Protect the access to this ressource */
+	instance_status_info_tx[instance].p_event_state[event].status = DL_HDMITX_EVENT_ENABLED;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	switch(event) {
+	case DL_HDMITX_HPD_ACTIVE:
+		if(event_call_hpdactive_cback) {
+			event_call_hpdactive_cback = false;
+			unit_table_tx[instance].p_callback(DL_HDMITX_HPD_ACTIVE);
+		}
+		break;
+
+	case DL_HDMITX_RX_DEVICE_ACTIVE:
+		if(event_call_rxsens_active_cback) {
+			event_call_rxsens_active_cback = false;
+			unit_table_tx[instance].p_callback(DL_HDMITX_RX_DEVICE_ACTIVE);
+		}
+		break;
+
+	default:
+		break;
+
+	}
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief This function allows disabling a specific event. By default, all
+ *           events are disabled, except input lock.
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to disable.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ ******************************************************************************/
+error_code_t tx_disable_event
+(
+    instance_t        instance,
+    tx_event_t   event
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if the event exists */
+	RETIF_BADPARAM(event >= EVENT_NB)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Protect the access to this ressource */
+	instance_status_info_tx[instance].p_event_state[event].status = DL_HDMITX_EVENT_DISABLED;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Get specifications of a given video format. Application can use
+ *           this function to retreives all specifications (frequencies,
+ *           resolution, etc.) of a given IA/CEA 861-D video format.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param resolutionID     ID of the resolution to retrieve specs from.
+ *    \param pResolutionSpecs Pointer to the structure receiving specs.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_RESOLUTION_UNKNOWN: the resolution is unknown
+ *
+ ******************************************************************************/
+error_code_t tx_get_video_format_specs
+(
+    instance_t            instance,
+    tx_vid_fmt_t      resolution_id,
+    tx_vid_fmt_specs_t *p_resolution_specs
+)
+{
+	u8	i;
+	bool    find = false;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if ResolutionSpecs pointer is NULL */
+	RETIF(p_resolution_specs == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	for(i = 0; i < gtx_driver_config_table[instance].resolution_nb; i++) {
+		if(resolution_id == gtx_driver_config_table[instance].p_resolution_info[i].resolution_id) {
+			find = true;
+			p_resolution_specs->height      = gtx_driver_config_table[instance].p_resolution_info[i].height;
+			p_resolution_specs->width       = gtx_driver_config_table[instance].p_resolution_info[i].width;
+			p_resolution_specs->interlaced  = gtx_driver_config_table[instance].p_resolution_info[i].interlaced;
+			p_resolution_specs->vfrequency  = gtx_driver_config_table[instance].p_resolution_info[i].vfrequency;
+			p_resolution_specs->aspect_ratio = gtx_driver_config_table[instance].p_resolution_info[i].aspect_ratio;
+			break;
+		}
+	}
+
+	/* Resolution not found in table */
+	RETIF(find == false, ERR_DLHDMITX_RESOLUTION_UNKNOWN)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Configures all input and output parameters : format, modes, rates,
+ *           etc. This is the main configuration function of the driver. Here
+ *           are transmitted all crucial input and output parameters of the
+ *           device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param videoInputConfig  Configuration of the input video.
+ *    \param videoOutputConfig Configuration of the output video.
+ *    \param audioInputConfig  Configuration of the input audio.
+ *    \param sinkType          Type of sink connected to the output of the Tx.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_input_output
+(
+    instance_t                instance,
+    tx_video_in_config_t   video_input_config,
+    tx_video_out_config_t  video_output_config,
+    tx_audio_in_config_t   audio_input_config,
+    tx_sink_type_t        sink_type
+)
+{
+	error_code_t           err;
+	u8                   pix_repeat;                  /* Pixel repetition */
+	bsl_vout_dbits_t  path_bits;                   /* Data path bit width */
+	bsl_pix_edge_t    pixel_edge;                  /* Pixel sampling edge */
+	bsl_vs_meth_t     sync_method;                 /* Sync method */
+	bsl_pix_togl_t    toggle;                     /* Toggling */
+	/* Embedded or external */
+	u8                   sync_in;
+	bsl_pix_subpkt_t  sp_sync;                     /* Subpacket sync */
+	bsl_blnk_src_t    blankit;                    /* Blanking */
+	/* HDMITX_PIXRATE_SINGLE */
+	bsl_pix_rate_t    pix_rate_single_double;
+	u16                  u_ref_pix;                    /* REFPIX for output */
+	u16                  u_ref_line;                   /* REFLINE for output */
+	u16                  u_sc_ref_pix;                  /* REFPIX for scaler */
+	/* REFLINE for scaler */
+	u16                  u_sc_ref_line;
+	/* Scaler setting verified */
+	bool                    b_verified;
+	/* Adjustment for interlaced output */
+	bsl_top_sel_t     top_sel;
+	/* Line/pixel counters sync */
+	bsl_vs_once_t     once;
+	bsl_sca_mode_t    scaler_mode;                 /* Current scaler mode */
+
+	tx_capabilities_t audio_capabilities;
+
+	/* Initialized after (depend on video mode used) */
+	u8                   *p_swap_table = NULL;
+	/* Initialized after (depend on video mode used) */
+	u8                   *p_mirror_table = NULL;
+	/* Initialized after (depend on video mode used) */
+	u8                   *p_ena_video_port_table = NULL;
+	/* Initialized after (depend on video mode used) */
+	u8                   *p_gnd_video_port_table = NULL;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Update the instance status information */
+	instance_status_info_tx[instance].p_video_info->video_in_config.format       = video_input_config.format;
+	instance_status_info_tx[instance].p_video_info->video_in_config.mode         = video_input_config.mode;
+	instance_status_info_tx[instance].p_video_info->video_in_config.sync_source   = video_input_config.sync_source;
+	instance_status_info_tx[instance].p_video_info->video_in_config.pixel_rate    = video_input_config.pixel_rate;
+
+	instance_status_info_tx[instance].p_video_info->video_out_config.format      = video_output_config.format;
+	instance_status_info_tx[instance].p_video_info->video_out_config.mode        = video_output_config.mode;
+	instance_status_info_tx[instance].p_video_info->video_out_config.color_depth  = video_output_config.color_depth;
+
+	/* TODO */
+	/*instanceStatusInfoTx[instance].pVideoInfo->videoMuteState            = */
+
+	/* Audio support */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = tx_get_capabilities_m(instance, &audio_capabilities)) != 0, err)
+
+	/* Test if audio input format is supported */
+	if(((audio_input_config.format == DL_HDMITX_AFMT_OBA) && (audio_capabilities.audio_packet.one_bit_audio == false)) ||
+	   ((audio_input_config.format == DL_HDMITX_AFMT_DST) && (audio_capabilities.audio_packet.DST == false)) ||
+	   ((audio_input_config.format == DL_HDMITX_AFMT_HBR) && (audio_capabilities.audio_packet.HBR == false))) {
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+		return ERR_DLHDMITX_NOT_SUPPORTED;
+	}
+
+	instance_status_info_tx[instance].p_audio_info->audio_in_cfg.format            = audio_input_config.format;
+	instance_status_info_tx[instance].p_audio_info->audio_in_cfg.i2s_format         = audio_input_config.i2s_format;
+	instance_status_info_tx[instance].p_audio_info->audio_in_cfg.i2s_qualifier      = audio_input_config.i2s_qualifier;
+	instance_status_info_tx[instance].p_audio_info->audio_in_cfg.rate              = audio_input_config.rate;
+	instance_status_info_tx[instance].p_audio_info->audio_in_cfg.channel_allocation = audio_input_config.channel_allocation;
+
+	/* TODO */
+	/*instanceStatusInfoTx[instance].pAudioInfo->audioMuteState            = */
+
+	if(sink_type == DL_HDMITX_SINK_EDID) {
+		/* Change sink type with the currently defined in EDID */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_edid_get_sink_type(instance,
+		                                        (bsl_sink_type_t *)&sink_type)) != 0, err)
+	}
+
+	if((sink_type == DL_HDMITX_SINK_DVI) &&
+	   ((video_output_config.format ==  dl_hdmitx_vfmt_06_720x480i_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_07_720x480i_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_10_720x480i_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_11_720x480i_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_21_720x576i_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_22_720x576i_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_25_720x576i_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_26_720x576i_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_08_720x240p_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_09_720x240p_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_12_720x240p_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_13_720x240p_60hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_23_720x288p_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_24_720x288p_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_27_720x288p_50hz) ||
+	    (video_output_config.format ==  dl_hdmitx_vfmt_28_720x288p_50hz)
+	   )
+	  )
+		/* forbid format with pixel repetition in DVI */
+	{
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+		return ERR_DLHDMITX_BAD_PARAMETER;
+	}
+
+	/* Set the TMDS outputs to a forced state */
+	err = bsl_tmds_set_outputs(instance,
+	                           HDMITX_TMDSOUT_FORCED0);
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+	/* Fine-tune the TMDS serializer */
+	err = bsl_tmds_set_serializer(instance,
+	                              4, 8);
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+	/* Set video output configuration */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_video_out_set_config(instance,
+	                  (bsl_sink_type_t)sink_type, (bsl_vout_mode_t)video_output_config.mode, HDMITX_VOUT_PREFIL_OFF,
+	                  HDMITX_VOUT_YUV_BLNK_16, HDMITX_VOUT_QRANGE_FS)) != 0, err)
+
+	/* Set default config */
+	pix_repeat   = HDMITX_PIXREP_DEFAULT;
+	path_bits    = HDMITX_VOUT_DBITS_12;
+	pixel_edge   = HDMITX_PIXEDGE_CLK_POS;
+	sync_method  = HDMITX_VSMETH_V_H;
+	toggle      = HDMITX_PIXTOGL_ENABLE;
+
+	/* Set sync details */
+	if(video_input_config.sync_source == DL_HDMITX_SYNCSRC_EMBEDDED) {
+		/* Embedded sync */
+		sync_in      = EMB;
+		sp_sync      = HDMITX_PIXSUBPKT_SYNC_HEMB;
+		blankit     = HDMITX_BLNKSRC_VS_HEMB_VEMB;
+		sync_method  = HDMITX_VSMETH_V_XDE;
+	} else {
+		/* External sync */
+		sync_in  = EXT;
+
+		if(gtx_driver_config_table[instance].data_enable_signal_available == 1) {
+			/* DE is available */
+			sp_sync  = HDMITX_PIXSUBPKT_SYNC_DE;
+		} else {
+			/* DE is NOT available */
+			sp_sync  = HDMITX_PIXSUBPKT_SYNC_HS;
+		}
+
+		blankit = HDMITX_BLNKSRC_NOT_DE;
+	}
+
+	/* Port swap table */
+	switch(video_input_config.mode) {
+	case DL_HDMITX_VINMODE_CCIR656:
+		path_bits = HDMITX_VOUT_DBITS_8;
+		pixel_edge = HDMITX_PIXEDGE_CLK_NEG;
+		p_swap_table = gtx_driver_config_table[instance].p_swap_table_ccir656;
+		p_mirror_table = gtx_driver_config_table[instance].p_mirror_table_ccir656;
+		p_ena_video_port_table = gtx_driver_config_table[instance].p_enable_video_port_ccir656;
+		p_gnd_video_port_table = gtx_driver_config_table[instance].p_ground_video_port_ccir656;
+		break;
+
+	case DL_HDMITX_VINMODE_RGB444:
+		p_swap_table = gtx_driver_config_table[instance].p_swap_table_rgb444;
+		p_mirror_table = gtx_driver_config_table[instance].p_mirror_table_rgb444;
+		p_ena_video_port_table = gtx_driver_config_table[instance].p_enable_video_port_rgb444;
+		p_gnd_video_port_table = gtx_driver_config_table[instance].p_ground_video_port_rgb444;
+		break;
+
+	case DL_HDMITX_VINMODE_YUV444:
+		p_swap_table = gtx_driver_config_table[instance].p_swap_table_yuv444;
+		p_mirror_table = gtx_driver_config_table[instance].p_mirror_table_yuv444;
+		p_ena_video_port_table = gtx_driver_config_table[instance].p_enable_video_port_yuv444;
+		p_gnd_video_port_table = gtx_driver_config_table[instance].p_ground_video_port_yuv444;
+		break;
+
+	case DL_HDMITX_VINMODE_YUV422:
+		p_swap_table = gtx_driver_config_table[instance].p_swap_table_yuv422;
+		p_mirror_table = gtx_driver_config_table[instance].p_mirror_table_yuv422;
+		p_ena_video_port_table = gtx_driver_config_table[instance].p_enable_video_port_yuv422;
+		p_gnd_video_port_table = gtx_driver_config_table[instance].p_ground_video_port_yuv422;
+		break;
+
+	default:
+		break;
+	}
+
+	/* Set the audio and video input port configuration */
+	err = bsl_set_video_port_config(instance,
+	                                p_ena_video_port_table, p_gnd_video_port_table);
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+	/* No possible to set the audio clock port config on TDA9983 */
+
+	/* Video input mapping */
+	err = bsl_video_in_set_mapping(instance,
+	                               p_swap_table, p_mirror_table);
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+	/* Set fine image position */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err = bsl_video_in_set_fine(instance, sp_sync, HDMITX_PIXTOGL_NO_ACTION)) != 0, err)
+
+	/* Set input blanking */
+	err = bsl_video_in_set_blanking(instance, blankit, HDMITX_BLNKCODE_ALL_0);
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+	/* Configure video input options and control the upsampler */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_video_in_set_config(instance,
+	                  /* (bslVidFmt_t)videoOutputConfig.format ,*/
+	                  (bsl_vin_mode_t)video_input_config.mode,  pixel_edge,
+	                  (bsl_pix_rate_t)video_input_config.pixel_rate, HDMITX_UPSAMPLE_AUTO)) != 0, err)
+
+	/* Only set audio for HDMI, not DVI */
+	if(sink_type == DL_HDMITX_SINK_HDMI) {
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+		/* Set audio parameters */
+		RETIF((err = tx_set_audio_input(instance, audio_input_config, sink_type)) != 0, err)
+		/* Take the sempahore */
+		RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+	}
+
+	/* Output fine adjustment */
+	pix_rate_single_double = (bsl_pix_rate_t)video_input_config.pixel_rate;
+	if(video_input_config.pixel_rate == HDMITX_PIXRATE_SINGLE_REPEATED) {
+		pix_rate_single_double = HDMITX_PIXRATE_SINGLE;
+	}
+
+	/* Set input ouput - may give NOT_SUPPORTED error */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_video_set_in_out(instance,
+	                                      (bsl_vid_fmt_t)video_input_config.format, HDMITX_SCAMODE_AUTO, (bsl_vid_fmt_t)video_output_config.format,
+	                                      pix_repeat, HDMITX_MATMODE_AUTO, path_bits, (bsl_vqr_t) video_output_config.dvi_vqr)) != 0, err)
+
+	if(dl_hdmi_tx_get_refline_refpix(video_input_config.format, video_input_config.mode, video_output_config.format,
+	                                 sync_in, (tx_pix_rate_t)pix_rate_single_double, &u_ref_pix, &u_ref_line,
+	                                 &u_sc_ref_pix, &u_sc_ref_line, &b_verified) > 0) {
+		/* From 720p50/60 or 1080i50/60 up-scaling to 1080p50/60, when external sync,
+		 *		   toggleV, toggleH and toggleX need to be set to 0 */
+		if(sync_in == EXT) {
+			switch(video_input_config.format) {
+			case hdmitx_vfmt_04_1280x720p_60hz:
+			case hdmitx_vfmt_19_1280x720p_50hz:
+			case hdmitx_vfmt_05_1920x1080i_60hz:
+			case hdmitx_vfmt_20_1920x1080i_50hz:
+				if((video_output_config.format == hdmitx_vfmt_16_1920x1080p_60hz)
+				   || (video_output_config.format == hdmitx_vfmt_31_1920x1080p_50hz)) {
+					toggle = HDMITX_PIXTOGL_NO_ACTION;
+				}
+				break;
+			default:
+				toggle = HDMITX_PIXTOGL_ENABLE;
+				break;
+			}
+		}
+
+		/* Combination found in table for scaler: configure input manually */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_video_in_set_sync_manual(instance,
+		                  (bsl_sync_source_t)video_input_config.sync_source, sync_method, toggle, toggle, toggle, u_ref_pix, u_ref_line)) != 0, err)
+	} else {
+		/* Not found so assume non-scaler and auto-configure input */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_video_in_set_sync_auto(instance,
+		                  (bsl_sync_source_t)video_input_config.sync_source, (bsl_vid_fmt_t)video_input_config.format,
+		                  (bsl_vin_mode_t)video_input_config.mode)) != 0, err)
+	}
+
+	/* Only set infoframes for HDMI, not DVI */
+	if(sink_type == DL_HDMITX_SINK_HDMI) {
+		/* Set avi infoframe */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = dl_hdmi_tx_set_video_infoframe(instance, video_output_config.format, video_output_config.mode)) != 0,
+		          err)
+	}
+
+	err = bsl_scaler_get_mode(instance, &scaler_mode);
+
+	/* Ignore scaler ERR_HDMI_NOT_SUPPORTED error */
+	if((err == 0) && (scaler_mode == HDMITX_SCAMODE_ON)) {
+		/* Enable scaler mode */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_scaler_in_disable(instance,
+		                                       false)) != 0, err)
+
+		/* Correction to interlace */
+		top_sel = HDMITX_TOPSEL_INTERNAL;
+		if((video_output_config.format == dl_hdmitx_vfmt_05_1920x1080i_60hz)
+		   || (video_output_config.format == dl_hdmitx_vfmt_20_1920x1080i_50hz)) {
+			/* video input format is range-checked by bslVideoSetInOut above */
+			if((k_vfmt_to_short_fmt_tv[video_input_config.format] == TV_480p_60HZ)
+			   || (k_vfmt_to_short_fmt_tv[video_input_config.format] == TV_576p_50HZ)) {
+				/* Correct for 1080i output for p->i conversion only */
+				top_sel = HDMITX_TOPSEL_VRF;
+			}
+		}
+
+		/* Set scaler field positions */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_scaler_set_field_order(instance,
+		                  HDMITX_INTEXT_NO_CHANGE, HDMITX_INTEXT_NO_CHANGE, top_sel, HDMITX_TOPTGL_NO_CHANGE)) != 0, err)
+
+		/* Scaler fine adjustment */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_scaler_set_fine(instance,
+		                                     u_sc_ref_pix, u_sc_ref_line)) != 0, err)
+
+		/* Not possible to set the scaler latency & phase on TDA9983 */
+
+		/* Set scaler synchronisation option */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_scaler_set_sync(instance,
+		                                     sync_method, HDMITX_VSONCE_EACH_FRAME)) != 0, err)
+
+		/* With scaler, use Only Once setting for bslVideoOutSetSync */
+		once = HDMITX_VSONCE_ONCE;
+	} else {
+		once = HDMITX_VSONCE_EACH_FRAME;
+	}
+
+	/* Set video synchronisation */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_video_out_set_sync(instance,
+	                                        HDMITX_VSSRC_INTERNAL, HDMITX_VSSRC_INTERNAL, HDMITX_VSSRC_INTERNAL,
+	                                        HDMITX_VSTGL_TABLE, once)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	instance_status_info_tx[instance].p_col_bar_state->in_out_first_set_done = true;
+
+	/* Test if pattern is already on */
+	if(instance_status_info_tx[instance].p_col_bar_state->color_bar_on == true) {
+		/* If pattern is On, apply new settings */
+		instance_status_info_tx[instance].p_col_bar_state->change_color_bar_now = true;
+	}
+
+	return 0;
+}
+
+/*****************************************************************************/
+/**
+ *    \brief Configures audio input parameters : format, rate, etc.
+ *           This function is similar to txSetInputOutput except that
+ *           video is not reconfigured.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param audioInputConfig  Configuration of the input audio.
+ *    \param sinkType          Type of sink connected to the output of the Tx.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_input
+(
+    instance_t                instance,
+    tx_audio_in_config_t   audio_input_config,
+    tx_sink_type_t        sink_type
+)
+{
+	error_code_t           err;
+	/* Used to convert video format to video frequency */
+	tx_vid_fmt_specs_t resolution_specs;
+	u8                   layout;                     /* 0 or 1 */
+	/* audio info frame channels */
+	u8                   aif_channel_count_code = 0;
+	/* Vertical output frequency */
+	bsl_vfreq_t      v_out_freq;
+	bslcts_ref_t     cts_ref;                     /* CTS ref source */
+	u16                  u_cts_x;                      /* CtsX value */
+	bsl_pkt_aif_t     pkt_aif;                     /* Audio infoframe packet */
+	tx_capabilities_t audio_capabilities;
+	u8                   *p_ena_audio_port_cfg;
+	u8                   *p_gnd_audio_port_cfg;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Audio support */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = tx_get_capabilities_m(instance, &audio_capabilities)) != 0, err)
+
+	/* Test if audio input format is supported */
+	if(((audio_input_config.format == DL_HDMITX_AFMT_OBA) && (audio_capabilities.audio_packet.one_bit_audio == false)) ||
+	   ((audio_input_config.format == DL_HDMITX_AFMT_DST) && (audio_capabilities.audio_packet.DST == false)) ||
+	   ((audio_input_config.format == DL_HDMITX_AFMT_HBR) && (audio_capabilities.audio_packet.HBR == false)))
+
+	{
+		/* Release the sempahore */
+		RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+		return ERR_DLHDMITX_NOT_SUPPORTED;
+	}
+
+	if(sink_type == DL_HDMITX_SINK_EDID) {
+		/* Change sink type with the currently defined in EDID */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_edid_get_sink_type(instance, (bsl_sink_type_t *)&sink_type)) != 0, err)
+	}
+
+	if(sink_type == DL_HDMITX_SINK_HDMI) {
+
+		layout = 1;
+
+		if(audio_input_config.channel_allocation == 0x00) {
+			layout = 0;
+		}
+
+		aif_channel_count_code = k_chan_alloc_chan_num[audio_input_config.channel_allocation] - 1;
+
+		/* Port audio configuration */
+		switch(audio_input_config.format) {
+		case DL_HDMITX_AFMT_SPDIF:
+			p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_spdif;
+			p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_spdif;
+			break;
+
+		case DL_HDMITX_AFMT_I2S:
+
+			if(aif_channel_count_code >= 1) { /* For multi-channel */
+				p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_i2s8c;
+				p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_i2s8c;
+			} else {
+				p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_i2s;
+				p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_i2s;
+			}
+			break;
+
+		case DL_HDMITX_AFMT_OBA:
+			p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_oba;
+			p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_oba;
+			break;
+
+		case DL_HDMITX_AFMT_DST:
+			p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_dst;
+			p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_dst;
+			break;
+
+		case DL_HDMITX_AFMT_HBR:
+			p_ena_audio_port_cfg = gtx_driver_config_table[instance].p_enable_audio_port_hbr;
+			p_gnd_audio_port_cfg = gtx_driver_config_table[instance].p_ground_audio_port_hbr;
+			break;
+
+		default:
+			/* Release the sempahore */
+			RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+			return ERR_DLHDMITX_BAD_PARAMETER;
+		}
+
+		err = bsl_set_audio_port_config(instance, p_ena_audio_port_cfg, p_gnd_audio_port_cfg);
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], (err != 0) && (err != ERR_HDMI_NOT_SUPPORTED), err)
+
+		/* Not possible to set the Clock port configuration on TDA9983 */
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_audio_in_set_config(instance, (bsla_fmt_t)audio_input_config.format,
+		                  audio_input_config.channel_allocation, HDMITX_CHAN_NO_CHANGE, HDMITX_CLKPOLDSD_NO_CHANGE, HDMITX_SWAPDSD_NO_CHANGE,
+		                  layout, 0x80)) != 0, err)
+
+		/* Find output vertical frequency from output format */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = tx_get_video_format_specs(instance, instance_status_info_tx[instance].p_video_info->video_out_config.format,
+		                  &resolution_specs)) != 0, err)
+		v_out_freq = (bsl_vfreq_t)resolution_specs.vfrequency;
+
+		if((audio_input_config.format == DL_HDMITX_AFMT_SPDIF)
+		   || (audio_input_config.format == DL_HDMITX_AFMT_OBA)) {
+			cts_ref = HDMITX_CTSREF_FS64SPDIF;
+			u_cts_x = HDMITX_CTSX_64;
+		} else { /* I2S */
+			cts_ref = HDMITX_CTSREF_ACLK;
+			if(audio_input_config.i2s_qualifier == DL_HDMITX_I2SQ_32BITS) {
+				u_cts_x = HDMITX_CTSX_64;
+			} else {
+				u_cts_x = HDMITX_CTSX_32;
+			}
+		}
+
+		/* Set the Clock Time Stamp generator in HDMI mode only */
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_audio_in_set_cts(instance, cts_ref, (bslafs_t)audio_input_config.rate,
+		                                      (bsl_vid_fmt_t)instance_status_info_tx[instance].p_video_info->video_out_config.format,
+		                                      v_out_freq, HDMITX_CTS_AUTO, u_cts_x, HDMITX_CTSK_USE_CTSX, HDMITX_CTSMTS_USE_CTSX)) != 0, err)
+
+		/* Set Channel Status registers
+		 *		    No need to call bslTDA9984AudioOutSetChanStatusMapping, since default Byte 2
+		 *		    values of "Do not take into account" are adequate */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_audio_out_set_chan_status(instance, HDMITX_CSFI_PCM_2CHAN_NO_PRE,
+		                  HDMITX_CSCOPYRIGHT_PROTECTED, 0x00, (bslafs_t)audio_input_config.rate,
+		                  HDMITX_CSCLK_LEVEL_II, HDMITX_CSMAX_LENGTH_20, HDMITX_CSWORD_DEFAULT,
+		                  HDMITX_CSOFREQ_NOT_INDICATED)) != 0, err)
+
+		/* Set reset_fifo to 1 */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_audio_out_set_mute(instance, HDMITX_AMUTE_ON)) != 0, err)
+		/* Wait for 20 ms */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = tx_iwwait(20)) != 0, err)
+		/* Set reset_fifo to 0 */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_audio_out_set_mute(instance, HDMITX_AMUTE_OFF)) != 0, err)
+
+		/* Set audio infoframe */
+		pkt_aif.channel_count     = aif_channel_count_code;
+		pkt_aif.coding_type       = 0; /* refer to stream header */
+		pkt_aif.sample_size       = 0; /* refer to stream header */
+		pkt_aif.channel_alloc     = audio_input_config.channel_allocation;
+		pkt_aif.level_shift       = 0; /* 0dB level shift */
+		pkt_aif.down_mix_inhibit   = 0; /* down-mix stereo permitted */
+		/* refer to stream header */
+		pkt_aif.sample_freq       = AIF_SF_REFER_TO_STREAM_HEADER;
+
+		/* SampleFreq parameter need to be set for OBA and DST audio stream */
+		if((audio_input_config.format == DL_HDMITX_AFMT_OBA) ||
+		   (audio_input_config.format == DL_HDMITX_AFMT_DST)) {
+			switch(audio_input_config.rate) {
+			case DL_HDMITX_AFS_32K:
+				pkt_aif.sample_freq = AIF_SF_32K; /* see table 18 of CEA-861 */
+				break;
+			case DL_HDMITX_AFS_44K:
+				pkt_aif.sample_freq = AIF_SF_44K;
+				break;
+			case DL_HDMITX_AFS_48K:
+				pkt_aif.sample_freq = AIF_SF_48K;
+				break;
+			case DL_HDMITX_AFS_88K:
+				pkt_aif.sample_freq = AIF_SF_88K;
+				break;
+			case DL_HDMITX_AFS_96K:
+				pkt_aif.sample_freq = AIF_SF_96K;
+				break;
+			case DL_HDMITX_AFS_176K:
+				pkt_aif.sample_freq = AIF_SF_176K;
+				break;
+			case DL_HDMITX_AFS_192K:
+				pkt_aif.sample_freq = AIF_SF_192K;
+				break;
+			default:
+				/* refer to stream header */
+				pkt_aif.sample_freq = AIF_SF_REFER_TO_STREAM_HEADER;
+				break;
+			}
+		}
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_audio_infoframe(instance, &pkt_aif, true)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of AVI infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAviIfData   Pointer to the structure containing AVI infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_video_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_avi_if_data_t   *p_avi_if_data
+)
+{
+	error_code_t       err;
+	bsl_pkt_vif_t pkt_vif;
+	bsl_vid_fmt_t vif_info_frame;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if AviIfData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_avi_if_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		/* 3rd api_set_avi_infoframe param */
+		pkt_vif.colour             = p_avi_if_data->color_indicator;
+		pkt_vif.active_info         = p_avi_if_data->active_info_present;
+		pkt_vif.bar_info            = p_avi_if_data->bar_information_data_valid;
+		pkt_vif.scan_info           = p_avi_if_data->scan_information;
+		pkt_vif.colorimetry        = p_avi_if_data->colorimetry;
+#ifndef FORMAT_PC
+		pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[p_avi_if_data->video_format_identification_code];
+#else /* FORMAT_PC */
+		if((p_avi_if_data->video_format_identification_code >= DL_HDMITX_VFMT_PC_MIN)
+		   && (p_avi_if_data->video_format_identification_code <= DL_HDMITX_VFMT_PC_MAX)) {
+			pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[p_avi_if_data->video_format_identification_code - DL_HDMITX_VFMT_PC_MIN + 1];
+		} else
+			pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[p_avi_if_data->video_format_identification_code];
+#endif /* FORMAT_PC */
+		pkt_vif.active_format_ratio  = p_avi_if_data->active_format_aspect_ratio;
+		pkt_vif.scaling            = p_avi_if_data->non_uniform_picture_scaling;
+
+#ifdef FORMAT_PC
+		if(p_avi_if_data->video_format_identification_code >= HDMITX_VFMT_PC_MIN) {
+			if(p_avi_if_data->video_format_identification_code == hdmitx_vfmt_pc_640x480p_60hz) {
+				vif_info_frame = hdmitx_vfmt_01_640x480p_60hz;
+			} else {
+				/* Format PC not Valid in EIA861b */
+				vif_info_frame = HDMITX_VFMT_NULL;
+			}
+		} else {
+#endif /* FORMAT_PC */
+
+			vif_info_frame = (bsl_vid_fmt_t)p_avi_if_data->video_format_identification_code;
+
+#ifdef FORMAT_PC
+		}
+#endif /* FORMAT_PC */
+
+		pkt_vif.vid_format = vif_info_frame;
+
+		if(((p_avi_if_data->video_format_identification_code >= hdmitx_vfmt_06_720x480i_60hz)
+		    && (p_avi_if_data->video_format_identification_code <= hdmitx_vfmt_09_720x240p_60hz))
+		   || ((p_avi_if_data->video_format_identification_code >= hdmitx_vfmt_21_720x576i_50hz)
+		       && (p_avi_if_data->video_format_identification_code <= hdmitx_vfmt_24_720x288p_50hz))) {
+			/* Force pixel repeat for formats where it's mandatory */
+			pkt_vif.pixel_repeat    = 1;
+		} else {
+			/* Default to no repeat for all other formats */
+			pkt_vif.pixel_repeat    = HDMITX_PIXREP_NONE;
+		}
+
+		pkt_vif.end_top_bar_line      = p_avi_if_data->line_number_end_top_bar;
+		pkt_vif.start_bottom_bar_line = p_avi_if_data->line_number_start_bottom_bar;
+		pkt_vif.end_left_bar_pixel    = p_avi_if_data->line_number_end_left_bar;
+		pkt_vif.start_right_bar_pixel = p_avi_if_data->line_number_start_right_bar;
+
+		err = bsl_pkt_set_video_infoframe(instance,
+		                                  &pkt_vif, enable);
+	} else {
+		err = bsl_pkt_set_video_infoframe(instance,
+		                                  NULL, enable);
+	}
+
+	/* Ignore infoframe interlock in DVI mode */
+	if(err == ERR_HDMI_OPERATION_NOT_PERMITTED) {
+		err = 0;
+	}
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], err != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of AUD infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAudIfData   Pointer to the structure containing AUD infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_aud_if_data_t   *p_aud_if_data
+)
+{
+	error_code_t       err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if AudIfData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_aud_if_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_audio_infoframe(instance,
+		                  (bsl_pkt_aif_t *)p_aud_if_data, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_audio_infoframe(instance,
+		                  NULL, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of the audio content protection packet to be
+ *           sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pAcpPktData  Pointer to the structure containing ACP infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_acppacket
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_acp_pkt_data_t  *p_acp_pkt_data
+)
+{
+	error_code_t       err;
+	bsl_pkt_t    pkt;
+	u8               i;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if AcpPktData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_acp_pkt_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		switch(p_acp_pkt_data->acp_type) {
+			/* Make sure bytes reserved are 0 */
+		case 0 : /* Generic audio */
+			for(i = 0; i < 28; i++) {
+				pkt.data_byte[i] = 0;
+			}
+			break;
+
+		case 1 : /* IEC 60958 identified audio */
+			for(i = 0; i < 28; i++) {
+				pkt.data_byte[i] = 0;
+			}
+			break;
+
+		case 2 : /* DVD Audio */
+			for(i = 0; i < 2; i++) {
+				pkt.data_byte[i] = p_acp_pkt_data->acp_data[i];
+			}
+			for(i = 2; i < 28; i++) {
+				pkt.data_byte[i] = 0;
+			}
+			break;
+
+		case 3 : /* SuperAudio CD */
+			for(i = 0; i < 17; i++) {
+				pkt.data_byte[i] = p_acp_pkt_data->acp_data[i];
+			}
+			for(i = 17; i < 28; i++) {
+				pkt.data_byte[i] = 0;
+			}
+			break;
+
+		default :
+			/* Release the sempahore */
+			RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+			return ERR_DLHDMITX_INCONSISTENT_PARAMS;
+		}
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_acp(instance,
+		                                 &pkt, 28, p_acp_pkt_data->acp_type, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_acp(instance,
+		                                 NULL, 0, 0, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of the General Control packet to be sent by Tx
+ *           device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pGcpPktData  Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_general_control_packet
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_gcp_pkt_data_t  *p_gcp_pkt_data
+)
+{
+	error_code_t       err;
+	bsla_mute_t  a_mute;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if GcpPktData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_gcp_pkt_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		if(p_gcp_pkt_data->av_mute == false) {
+			a_mute = HDMITX_AMUTE_OFF;
+		} else {
+			a_mute = HDMITX_AMUTE_ON;
+		}
+
+		/* Set contents of general control packet & enable/disable packet insertion */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_general_cntrl(instance,
+		                  &a_mute, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_general_cntrl(instance,
+		                  NULL, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of ISRC1 packet to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param enable           Enable/disable infoframe insertion.
+ *    \param pIsrc1PktData    Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_isrc1packet
+(
+    instance_t                instance,
+    bool                        enable,
+    tx_isrc1pkt_data_t    *p_isrc1pkt_data
+)
+{
+	error_code_t       err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if Isrc1PktData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_isrc1pkt_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_isrc1(instance,
+		                                   (bsl_pkt_t *)p_isrc1pkt_data->UPC_EAN_ISRC, 16, p_isrc1pkt_data->isrc_cont,
+		                                   p_isrc1pkt_data->isrc_valid, p_isrc1pkt_data->isrc_status, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_isrc1(instance,
+		                                   NULL, 0, 0, 0, 0, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of ISRC2 packet to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param enable           Enable/disable infoframe insertion.
+ *    \param pIsrc2PktData    Pointer to the structure containing GCP packet parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_isrc2packet
+(
+    instance_t                instance,
+    bool                        enable,
+    tx_isrc2pkt_data_t    *p_isrc2pkt_data
+)
+{
+	error_code_t       err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if Isrc1PktData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_isrc2pkt_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_isrc2(instance,
+		                                   (bsl_pkt_t *)p_isrc2pkt_data->UPC_EAN_ISRC, 16, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_isrc2(instance,
+		                                   NULL, 0, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of MPS infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pMpsIfData   Pointer to the structure containing MPS infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_mpsinfoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_mps_if_data_t   *p_mps_if_data
+)
+{
+	error_code_t           err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if MpsIfData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_mps_if_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_mpeg_infoframe(instance,
+		                  (bsl_pkt_mpeg_t *)p_mps_if_data, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_mpeg_infoframe(instance,
+		                  NULL, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of SPD infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pSpdIfData   Pointer to the structure containing SPD infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_spd_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_spd_if_data_t   *p_spd_if_data
+)
+{
+	error_code_t       err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if SpdIfData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_spd_if_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_spd_infoframe(instance,
+		                  (bsl_pkt_spd_t *)p_spd_if_data, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_spd_infoframe(instance,
+		                  NULL, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Defines the content of VS infoframe to be sent by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable infoframe insertion.
+ *    \param pVsIfData    Pointer to the structure containing VS infoframe
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_vs_infoframe
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_vs_pkt_data_t   *p_vs_if_data
+)
+{
+	error_code_t       err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	if(enable == true) {
+		/* Check if VsIfData pointer is NULL */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_vs_if_data == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_vs_infoframe(instance,
+		                  (bsl_pkt_t *)p_vs_if_data->vs_data, 27, p_vs_if_data->version, enable)) != 0, err)
+	} else {
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_pkt_set_vs_infoframe(instance,
+		                  NULL, 0, p_vs_if_data->version, enable)) != 0, err)
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Enables/disables NULL packet sending (only used for debug purpose).
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *    \param enable    Enable/disable packet insertion.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_debug_set_null_packet
+(
+    instance_t    instance,
+    bool            enable
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_pkt_set_null_insert(instance,
+	                  enable)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Send one single NULL packet (only used for debug purpose).
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_debug_set_single_null_packet
+(
+    instance_t    instance
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_pkt_set_null_single(instance))
+	          != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Set the audio output mute status. This function can be used to mute
+ *           audio output, without muting video. This can be typically used when
+ *           reconfiguring the audio HW after a sample rate change.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param muteStatus Mute status (true/false).
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_audio_mute
+(
+    instance_t    instance,
+    bool            audio_mute
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Mute or Un-mute the audio output */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_audio_out_set_mute(instance,
+	                                        (bsla_mute_t)audio_mute)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Reset audio CTS.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_reset_audio_cts
+(
+    instance_t    instance
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Reset the audio Clock Time Stamp generator */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_audio_in_reset_cts(instance)
+	          ) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retrieve EDID Status from driver.
+ *           This function is synchronous.
+ *           This function is ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pEdidStatus      Pointer to the array that will receive the EDID Status.
+ *    \param pEdidBlkCount    Pointer to the integer that will receive the number of
+ *                            read EDID block.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_status
+(
+    instance_t            instance,
+    tx_edid_status_t  *p_edid_status,
+    u8                   *p_edid_blk_count
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if EdidStatus and pReadBytesNumber pointers are NULL */
+	RETIF(p_edid_status == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_edid_blk_count == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Get the EDID status from BSL driver */
+	*p_edid_status = (tx_edid_status_t)edid_data_status;
+	*p_edid_blk_count = 0;
+
+	if(edid_data_status == DL_HDMITX_EDID_READ) {
+		/* Get the read EDID block number from BSL driver */
+		RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+		          (err = bsl_edid_get_block_count(instance,
+		                  p_edid_blk_count)) != 0, err)
+
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retrieves audio descriptors from receiver's EDID. This function
+ *           parses the EDID of Tx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param pAudioDescs          Pointer to the array that will receive audio
+ *                                descriptors.
+ *    \param maxAudioDescs        Size of the array.
+ *    \param pWrittenAudioDescs   Pointer to the integer that will receive the actual
+ *                                number of written descriptors.
+ *    \param pAudioFlags          Pointer to the byte to receive Audio Capabilities Flags.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_audio_caps
+(
+    instance_t                instance,
+    tx_edid_audio_desc_t   *p_audio_descs,
+    uint                        max_audio_descs,
+    uint                        *p_written_audio_descs,
+    u8                       *p_audio_flags
+)
+{
+	error_code_t           err;
+	bsl_edid_sad_t    edid_sad[HDMI_TX_SAD_MAX_CNT];
+	uint                    i;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if AudioDescs, WrittenAudioDescs and AudioFlags pointers are NULL */
+	RETIF(p_audio_descs == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_written_audio_descs == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_audio_flags == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get video capabilities from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_audio_capabilities(instance,
+	                  edid_sad, max_audio_descs, p_written_audio_descs, p_audio_flags)) != 0, err)
+
+	for(i = 0; i < *p_written_audio_descs; i++) {
+		/* Bits[6:3]: EIA/CEA861 mode */
+		p_audio_descs[i].format            = (edid_sad[i].mode_chans & 0x78) >> 3;
+		/* Bits[2:0]: channels */
+		p_audio_descs[i].channels          = edid_sad[i].mode_chans & 0x07;
+		/* Supported frequencies */
+		p_audio_descs[i].supported_freqs    = edid_sad[i].freqs;
+
+		if(p_audio_descs[i].format == 1) {            /* LPCM format */
+			p_audio_descs[i].supported_res = edid_sad[i].byte3 & 0x07;
+			p_audio_descs[i].max_bitrate   = 0x00;
+		} else if((p_audio_descs[i].format >= 2) &&   /* Compressed format */
+		          (p_audio_descs[i].format <= 8)) {
+			p_audio_descs[i].supported_res = 0x00;
+			p_audio_descs[i].max_bitrate   = edid_sad[i].byte3;
+		} else {
+			p_audio_descs[i].supported_res = 0x00;
+			p_audio_descs[i].max_bitrate   = 0x00;
+		}
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retrieves supported video formats (short descriptors) from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param pVideoDesc           Pointer to the structure that will receive short
+ *                                video descriptors.
+ *    \param maxVideoFormats      Size of the array.
+ *    \param pWrittenVideoFormats Pointer to the integer that will receive the actual
+ *                                number of written descriptors.
+ *    \param pVideoFlags          Pointer to the byte to receive Video Capability Flags.
+ *                                b7: underscan supported
+ *                                b6: YCbCr 4:4:4 supported
+ *                                b5: YCbCr 4:2:2 supported
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_video_caps
+(
+    instance_t                instance,
+    tx_short_vid_desc_t    *p_video_desc,
+    uint                        max_video_formats,
+    uint                        *p_written_video_formats,
+    u8                       *p_video_flags
+)
+{
+	error_code_t                   err;
+	u8                           edid_vfmts_buffer[HDMI_TX_SVD_MAX_CNT];
+	tx_edid_video_timings_t    edid_dtdbuffer[NUMBER_DTD_STORED];
+	u8                           i;
+	u8                           written_dtd = 0;
+	u8                           dtd_counter = 0;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if Videoformats, WrittenVideoFormats and VideoFlags pointers are NULL */
+	RETIF(p_video_desc == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_written_video_formats == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_video_flags == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(max_video_formats == 0, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get video capabilities from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_video_capabilities(instance,
+	                  edid_vfmts_buffer, HDMI_TX_SVD_MAX_CNT, p_written_video_formats, p_video_flags)) != 0, err)
+
+	/* Get detailled descriptors from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = dl_hdmi_tx_edid_get_dtd(instance, edid_dtdbuffer, NUMBER_DTD_STORED, &written_dtd)) != 0, err)
+
+	dtd_counter = 0;
+	if(written_dtd > 0) {
+		/* Write first DTD in first position of table video desc  */
+		p_video_desc[0].video_format = dl_hdmi_tx_convert_dtdto_cea(&(edid_dtdbuffer[dtd_counter]));
+		dtd_counter++;
+
+		p_video_desc[0].native_video_format = false;
+	}
+
+	/* Start with i = 1 keep the first position for the first DTD */
+	for(i = dtd_counter; i < max_video_formats ; i++) {
+		if((i < (HDMI_TX_SVD_MAX_CNT + dtd_counter)) && (i < ((*p_written_video_formats) + dtd_counter))) {
+			/* Store SVD */
+			p_video_desc[i].video_format = (tx_vid_fmt_t)((int)edid_vfmts_buffer[i - dtd_counter] & 0x7F);
+			/* if bit 7 is true, it means that is a preferred video format */
+			if((edid_vfmts_buffer[i] & 0x80) == 0x80) {
+				p_video_desc[i].native_video_format = true;
+			} else {
+				p_video_desc[i].native_video_format = false;
+			}
+		} else {
+			if((dtd_counter < NUMBER_DTD_STORED) && (dtd_counter < written_dtd)) {
+				/* Store DTD except first DTD */
+				p_video_desc[i].video_format = dl_hdmi_tx_convert_dtdto_cea(&(edid_dtdbuffer[dtd_counter]));
+				dtd_counter++;
+
+				p_video_desc[i].native_video_format = false;
+			} else {
+				/* VGA is always supported */
+				p_video_desc[i].video_format = dl_hdmitx_vfmt_01_640x480p_60hz;
+				p_video_desc[i].native_video_format = false;
+				/* Last format supported exit from loop for */
+				break;
+			}
+		}
+	}
+
+	/* + 1 for VGA format */
+	*p_written_video_formats = *p_written_video_formats + dtd_counter + 1;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retrieves supported video formats (short descriptors) from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance                 Instance identifier.
+ *    \param pPreferredVideoFormat    Pointer to the array that will receive video
+ *                                    timing descriptor.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_video_preferred
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_preferred_video_format
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if PreferredVideoFormat pointer is NULL */
+	RETIF(p_preferred_video_format == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get preferred video format from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_video_preferred(instance,
+	                  (bsl_edid_dtd_t *)p_preferred_video_format)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported detailled video descriptors from
+ *           receiver's EDID. This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pDTDescriptors   Pointer to the array that will receive detailled
+ *                            timing descriptors.
+ *    \param maxDTDesc        Size of the array.
+ *    \param pWrittenDesc     Pointer to the integer that will receive the actual
+ *                            number of written descriptors.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_detailled_timing_descriptors
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    u8                           max_dtdesc,
+    u8                           *p_written_dtdesc
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if DTDescriptors, WrittenDTDesc pointers are NULL */
+	RETIF(p_dtdescriptors == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_written_dtdesc == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get detailled descriptors from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_detailed_timing_descriptors(instance,
+	                  (bsl_edid_dtd_t *)p_dtdescriptors, max_dtdesc, p_written_dtdesc)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/*****************************************************************************/
+/**
+ *    \brief Retrieves supported monitor descriptor from receiver's EDID.
+ *           This function parses the EDID of Rx device to get
+ *           the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pEdidFirstMD     Pointer to the array that will receive the first monitor
+ *                            descriptors.
+ *    \param pEdidSecondMD    Pointer to the array that will receive the second monitor
+ *                            descriptors.
+ *    \param pEdidOtherMD     Pointer to the array that will receive the other monitor
+ *                            descriptors.
+ *    \param maxOtherMD       Size of the array.
+ *    \param pWrittenOtherMD  Pointer to the integer that will receive the actual
+ *                            number of written descriptors.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_monitor_descriptors
+(
+    instance_t                instance,
+    tx_edid_first_md_t     *p_edid_first_md,
+    tx_edid_second_md_t    *p_edid_second_md,
+    tx_edid_other_md_t     *p_edid_other_md,
+    u8                       max_other_md,
+    u8                       *p_written_other_md
+)
+{
+#ifdef IMPLEMENTED_IN_BSL
+
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if DTDescriptors, WrittenDTDesc pointers are NULL */
+	RETIF(p_edid_first_md == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_edid_second_md == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_edid_other_md == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get monitor descriptors from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_monitor_descriptors(instance,
+	                  (bsl_edid_first_md_t *)p_edid_first_md, (bsl_edid_second_md_t *)p_edid_second_md,
+	                  (bsl_edid_other_md_t *)p_edid_other_md, max_other_md, p_written_other_md)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+
+#else /* IMPLEMENTED_IN_BSL */
+
+	g_no_warning = (u8)instance;
+	if(p_edid_first_md) g_no_warning = 0;
+	if(p_edid_second_md) g_no_warning = 0;
+	if(p_edid_other_md) g_no_warning = 0;
+	g_no_warning = (u8)max_other_md;
+	if(p_written_other_md) g_no_warning = 0;
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+
+#endif /* IMPLEMENTED_IN_BSL */
+
+}
+
+/******************************************************************************
+ *    \brief Retrieves the sink type from receiver's EDID (HDMI or DVI). This
+ *           function parses the EDID of Rx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance  Instance identifier.
+ *    \param pSinkType Pointer to the array that will receive sink type.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_sink_type
+(
+    instance_t            instance,
+    tx_sink_type_t    *p_sink_type
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if SinkType pointer is NULL */
+	RETIF(p_sink_type == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Read the source address from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_sink_type(instance,
+	                                        (bsl_sink_type_t *)p_sink_type)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retrieves source address from receivers's EDID. This
+ *           function parses the EDID of Rx device to get the relevant data.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance         Instance identifier.
+ *    \param pSourceAddress   Pointer to the integer that will receive the EDID source
+ *                            address.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_RESOURCE_NOT_AVAILABLE : EDID not read
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *
+ ******************************************************************************/
+error_code_t tx_get_edid_source_address
+(
+    instance_t    instance,
+    u16          *p_source_address
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if SourceAddress pointer is NULL */
+	RETIF(p_source_address == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Read the source address from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_edid_get_source_address(instance,
+	                  p_source_address)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Retreives KSV list received by Tx device.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param pKsv         Pointer to the array that will receive the KSV list.
+ *    \param maxKsv       Maximum number of KSV that the array can store.
+ *    \param pWrittenKsv  Actual number of KSV written into the array.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_get_ksv_list
+(
+    instance_t    instance,
+    u8           *p_ksv,
+    u8           max_ksv,
+    u8           *p_written_ksv,
+    u8           *p_depth,
+    bool            *p_max_casc_exd,
+    bool            *p_max_devs_exd
+)
+{
+
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check if pDepth, Ksv and WrittenKsv pointers are NULL */
+	RETIF(p_ksv == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_written_ksv == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_depth == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_max_casc_exd == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+	RETIF(p_max_devs_exd == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Maximum Ksv is HDMITX_KSV_LIST_MAX_DEVICES, 128 devices */
+	RETIF_BADPARAM(max_ksv > HDMITX_KSV_LIST_MAX_DEVICES)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Make sure that *pWrittenKsv is 0 */
+	*p_written_ksv = 0;
+
+	/* Make sure that *pDepth is 0 */
+	*p_depth = 0;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+
+}
+
+/******************************************************************************
+ *    \brief Enable/Disable HDCP encryption.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance   Instance identifier.
+ *    \param hdcpEnable HDCP On/Off (true = On, false = Off).
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_RESOLUTION_UNKNOWN: the resolution is unknown
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_set_hdcp
+(
+    instance_t    instance,
+    bool            hdcp_enable
+)
+{
+	error_code_t               err;
+	bsl_rx_sense_t        rx_sense_status;  /* Rx Sense status */
+	bsl_hot_plug_t        hpd_status;      /* HPD status */
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check the current state */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Hdcp is not supported if keySeed is null */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          gtx_driver_config_table[instance].key_seed == HDCP_SEED_NULL, ERR_DLHDMITX_NOT_SUPPORTED)
+
+	/* Read rxSenseStatus and hpdStatus to authorize HDCP only if active */
+#ifdef TMFL_RX_SENSE_ON
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_rx_sense_get_status(instance,
+	                  &rx_sense_status)) != 0, err)
+#else
+	rx_sense_status = HDMITX_RX_SENSE_ACTIVE;
+#endif
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_hot_plug_get_status(instance,
+	                  &hpd_status)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+}
+
+/******************************************************************************
+ *    \brief Get the driver HDCP state.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance          Instance identifier.
+ *    \param pHdcpCheckState   Pointer to the integer that will receive the HDCP check state.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_get_hdcp_state
+(
+    instance_t            instance,
+    tx_hdcp_check_t   *p_hdcp_check_state
+)
+{
+	error_code_t               err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Check if HdcpCheckState pointer is NULL */
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance], p_hdcp_check_state == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	*p_hdcp_check_state = DL_HDMITX_HDCP_CHECK_NOT_STARTED;
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+}
+
+/******************************************************************************
+ *    \brief Check the result of an HDCP encryption attempt, called at
+ *           intervals (set by timeSinceLastCall) after txSetHdcp(true).
+ *           This API must be used only in case of No Operating System. if OS,
+ *           this is manage internally of this device library.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance             Instance identifier.
+ *    \param timeSinceLastCall    Time passed in milliseconds since last call,
+ *                                must be shorter than 600 ms.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_NOT_SUPPORTED: device does not support HDCP
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_READ: failed when reading the I2C bus
+ *            - ERR_HDMI_I2C_WRITE: failed when writing the I2C bus
+ *            - ERR_HDMI_NOT_SUPPORTED: device does not support HDCP
+ *
+ ******************************************************************************/
+error_code_t tx_hdcp_check
+(
+    instance_t    instance,
+    u16          time_since_last_call
+)
+{
+	error_code_t           err;
+	bsl_hw_feature_t feature_supported;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	RETIF_SEM(dl_hdmi_tx_it_semaphore[instance],
+	          (err = bsl_hw_get_capabilities(instance, &feature_supported)) != 0, err)
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+}
+
+/******************************************************************************
+ *    \brief This function loads a gamut metadata packet into the HW. HW will
+ *           actually send it at the beginning of next VS, during the vertical
+ *           blanking.
+ *           This function is synchronous.
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *    \param enable       Enable/disable gamut metadata packet insertion.
+ *    \param pGamutData   Pointer to the structure containing gamut metadata
+ *                        parameters.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *            - ERR_DLHDMITX_INVALID_STATE: the state is invalid for
+ *              the function
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *              inconsistent
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+error_code_t tx_set_gamut_packet
+(
+    instance_t            instance,
+    bool                    enable,
+    tx_gamut_data_t   *p_gamut_data
+)
+{
+	/* Not supported for TDA9983 */
+
+	g_no_warning = (u8)instance;
+	g_no_warning = (u8)enable;
+	if(p_gamut_data) g_no_warning = 0;
+
+	return ERR_DLHDMITX_NOT_SUPPORTED;
+
+}
+
+/******************************************************************************
+ *
+ *    \brief This function set the revocation list use for HDCP
+ *
+ *           This function is synchronous.
+ *
+ *           This function is not ISR friendly.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \param listPtr      Pointer on revocation list provide by application.
+ *
+ *    \param length       length of revocation list.
+ *
+ *    \return The call result:
+ *
+ *            - 0: the call was successful
+ *
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *
+ *              out of range
+ *
+ *            - ERR_DLHDMITX_BAD_HANDLE: the handle number is wrong
+ *
+ *            - ERR_DLHDMITX_INCONSISTENT_PARAMS: an input parameter is
+ *
+ *              inconsistent
+ *
+ ******************************************************************************/
+
+error_code_t tx_set_hdcprevocation_list(
+
+    instance_t    instance,
+
+    void            *list_ptr,
+
+    u32          length
+
+)
+
+{
+
+	error_code_t           err;
+
+	/* Check if instance number is in range */
+
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* Check parameters */
+
+	RETIF((list_ptr == NULL) || (length == 0), ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	unit_table_tx[instance].revocation_list.p_list  = list_ptr;
+
+	unit_table_tx[instance].revocation_list.length = length;
+
+	/* Release the sempahore */
+
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+
+}
+
+/*============================================================================*/
+/*                           INTERNAL FUNCTION                                */
+/*============================================================================*/
+
+/******************************************************************************
+ *    \brief Get the REFPIX and REFLINE for output and scaler
+ *            for the current settings.
+ *
+ *    \param vinFmt       Video input format.
+ *    \param vinMode      Video input mode.
+ *    \param voutFmt      Video output format.
+ *    \param syncIn       Type of synchro (ext or emb).
+ *    \param pixRate      Video pixel rate.
+ *    \param pRefPix      RefPix for output.
+ *    \param pRefLine     RefLine for output.
+ *    \param pScRefPix    RefPix for scaler.
+ *    \param pScRefLine   RefLine for scaler.
+ *    \param pbVerified   Pointer to the boolean that will receive the fact that
+ *                        this scaler setting was verified.
+ *
+ *    \return true (Found) or false (Not found).
+ *
+ ******************************************************************************/
+static bool dl_hdmi_tx_get_refline_refpix
+(
+    tx_vid_fmt_t      vin_fmt,
+    tx_vin_mode_t     vin_mode,
+    tx_vid_fmt_t      vout_fmt,
+    u8                   sync_in,
+    tx_pix_rate_t     pix_rate,
+    u16                  *p_ref_pix,
+    u16                  *p_ref_line,
+    u16                  *p_sc_ref_pix,
+    u16                  *p_sc_ref_line,
+    bool                    *pb_verified
+)
+{
+	u8 short_vin_fmt;
+	u8 short_vout_fmt;
+	int i;
+	bool b_found;
+
+	/* Search for all values to match in table, until table end is reached
+	 * when both refPix values are zero */
+	*p_ref_pix    = 0;
+	*p_ref_line   = 0;
+	*p_sc_ref_pix  = 0;
+	*p_sc_ref_line = 0;
+
+	/* If match is not found in table, we can assume a verified non-scaler
+	 * combination */
+	*pb_verified = 1;
+	b_found = false;
+
+	if(vout_fmt  <  DL_HDMITX_VFMT_TV_NO_REG_MIN) {
+		short_vin_fmt  = k_vfmt_to_short_fmt_tv[vin_fmt];
+		short_vout_fmt = k_vfmt_to_short_fmt_tv[vout_fmt];
+
+		for(i = 0; k_refpix_refline[i].short_vin_fmt != TV_INVALID; i++) {
+			if((k_refpix_refline[i].short_vin_fmt == short_vin_fmt)
+			   && (UNPKMODE(k_refpix_refline[i].mode_rate_sync_verf) == vin_mode)
+			   && (k_refpix_refline[i].short_vout_fmt == short_vout_fmt)
+			   && (UNPKRATE(k_refpix_refline[i].mode_rate_sync_verf) == pix_rate)
+			   && (UNPKSYNC(k_refpix_refline[i].mode_rate_sync_verf) == sync_in)) {
+				*p_ref_pix    = k_refpix_refline[i].ref_pix;
+				*p_ref_line   = k_refpix_refline[i].ref_line;
+				*p_sc_ref_pix  = k_refpix_refline[i].sc_ref_pix;
+				*p_sc_ref_line = k_refpix_refline[i].sc_ref_line;
+				*pb_verified = UNPKVERF(k_refpix_refline[i].mode_rate_sync_verf);
+				b_found = true;
+				break;
+			}
+		}
+	}
+
+	return b_found;
+}
+
+/******************************************************************************
+ *    \brief Set the video infoframe.
+ *
+ *    \param instance     Instance identifier.
+ *    \param voutFmt      Video output format.
+ *    \param voutMode     Video output mode.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *            - ERR_HDMI_I2C_READ: failed when reading to the I2C bus
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_OPERATION_NOT_PERMITTED: not allowed in DVI mode
+ *
+ ******************************************************************************/
+static error_code_t dl_hdmi_tx_set_video_infoframe
+(
+    instance_t            instance,
+    tx_vid_fmt_t      vout_fmt,
+    tx_vout_mode_t    vout_mode
+)
+{
+	error_code_t       err;
+	bsl_pkt_vif_t pkt_vif;
+	bsl_vid_fmt_t vif_info_frame;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	/* 3rd api_set_avi_infoframe param */
+	pkt_vif.colour             = vout_mode;
+	pkt_vif.active_info         = 0;
+	pkt_vif.bar_info            = 0;
+	pkt_vif.scan_info           = 0;
+#ifndef FORMAT_PC
+	pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[vout_fmt];
+#else /* FORMAT_PC */
+	if((vout_fmt >= DL_HDMITX_VFMT_PC_MIN)
+	   && (vout_fmt <= DL_HDMITX_VFMT_PC_MAX)) {
+		pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[vout_fmt - DL_HDMITX_VFMT_PC_MIN + 1];
+	} else
+		pkt_vif.picture_aspect_ratio = k_vfmt_to_aspect_tv[vout_fmt];
+#endif /* FORMAT_PC */
+	pkt_vif.active_format_ratio  = 8;
+	pkt_vif.scaling            = 0;
+
+#ifdef FORMAT_PC
+	if(vout_fmt >= DL_HDMITX_VFMT_PC_MIN) {
+		if(vout_fmt == dl_hdmitx_vfmt_pc_640x480p_60hz) {
+			vif_info_frame = (bsl_vid_fmt_t)dl_hdmitx_vfmt_01_640x480p_60hz;
+		} else {
+			/* Format PC not Valid in EIA861b */
+			vif_info_frame = (bsl_vid_fmt_t)DL_HDMITX_VFMT_NULL;
+		}
+	} else {
+#endif /* FORMAT_PC */
+
+		vif_info_frame = (bsl_vid_fmt_t)vout_fmt;
+
+#ifdef FORMAT_PC
+	}
+#endif /* FORMAT_PC */
+
+	pkt_vif.vid_format = vif_info_frame;
+	if(((vout_fmt >= dl_hdmitx_vfmt_06_720x480i_60hz) && (vout_fmt <= dl_hdmitx_vfmt_09_720x240p_60hz))
+	   || ((vout_fmt >= dl_hdmitx_vfmt_21_720x576i_50hz) && (vout_fmt <= dl_hdmitx_vfmt_24_720x288p_50hz))) {
+		/* Force pixel repeat for formats where it's mandatory */
+		pkt_vif.pixel_repeat = 1;
+	} else {
+		/* Default to no repeat for all other formats */
+		pkt_vif.pixel_repeat = HDMITX_PIXREP_NONE;
+	}
+
+	switch(vout_fmt) {
+	case dl_hdmitx_vfmt_04_1280x720p_60hz:
+	case dl_hdmitx_vfmt_05_1920x1080i_60hz:
+	case dl_hdmitx_vfmt_16_1920x1080p_60hz:
+	case dl_hdmitx_vfmt_19_1280x720p_50hz:
+	case dl_hdmitx_vfmt_20_1920x1080i_50hz:
+	case dl_hdmitx_vfmt_31_1920x1080p_50hz:
+		pkt_vif.colorimetry = (u8)DL_HDMITX_COLORIMETRY_ITU709;
+		break;
+
+	default:
+		pkt_vif.colorimetry = (u8)DL_HDMITX_COLORIMETRY_ITU601;
+		break;
+	}
+
+	pkt_vif.end_top_bar_line      = 0;
+	pkt_vif.start_bottom_bar_line = 0;
+	pkt_vif.end_left_bar_pixel    = 0;
+	pkt_vif.start_right_bar_pixel = 0;
+
+	err = bsl_pkt_set_video_infoframe(instance,
+	                                  &pkt_vif, true);
+
+	/* Ignore infoframe interlock in DVI mode */
+	if(err == ERR_HDMI_OPERATION_NOT_PERMITTED) {
+		err = 0;
+	}
+
+	return err;
+}
+
+/******************************************************************************
+ *    \brief Set colourbar test pattern on with RGB infoframe
+ *
+ *    \param instance     Instance identifier.
+ *    \param voutFmt      Video output format.
+ *    \param voutMode     Video output mode.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ ******************************************************************************/
+error_code_t dl_hdmi_tx_set_test_pattern_on
+(
+    instance_t            instance,
+    tx_vid_fmt_t		vout_fmt,
+    tx_vout_mode_t    vout_mode,
+    tx_test_pattern_t pattern
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	RETIF((err = bsl_test_set_pattern(instance,
+	                                  (bsl_test_pattern_t)pattern)) != 0, err)
+
+	if(pattern > DL_HDMITX_PATTERN_CBAR8) {
+		RETIF((err = dl_hdmi_tx_set_video_infoframe(instance, vout_fmt, vout_mode)) != 0, err)
+	} else {
+		/* For DL_HDMITX_PATTERN_CBAR8 and DL_HDMITX_PATTERN_CBAR4, video mode in infoframe should be RGB */
+		RETIF((err = dl_hdmi_tx_set_video_infoframe(instance, vout_fmt, DL_HDMITX_VOUTMODE_RGB444)) != 0, err)
+	}
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief Set colourbar test pattern off with previous infoframe
+ *
+ *    \param instance     Instance identifier.
+ *    \param voutFmt      Video output format.
+ *    \param voutMode     Video output mode.
+ *
+ *    \return The call result:
+ *            - 0: the call was successful
+ *            - ERR_DLHDMITX_BAD_INSTANCE: the instance number is wrong or
+ *              out of range
+ *            - ERR_HDMI_BAD_UNIT_NUMBER: bad transmitter unit number
+ *            - ERR_HDMI_BAD_PARAMETER: a parameter was out of range
+ *            - ERR_HDMI_NOT_INITIALIZED: transmitter not initialized
+ *            - ERR_HDMI_I2C_WRITE: failed when writing to the I2C bus
+ *
+ ******************************************************************************/
+error_code_t dl_hdmi_tx_set_test_pattern_off
+(
+    instance_t            instance,
+    tx_vid_fmt_t      vout_fmt,
+    tx_vout_mode_t    vout_mode
+)
+{
+	error_code_t err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	RETIF((err = bsl_test_set_pattern(instance,
+	                                  (bsl_test_pattern_t)DL_HDMITX_PATTERN_OFF)) != 0, err)
+
+	/* Restore video infoframe */
+	RETIF((err = dl_hdmi_tx_set_video_infoframe(instance, vout_fmt, vout_mode)) != 0, err)
+
+	return 0;
+}
+
+/******************************************************************************
+ *    \brief HDCP ENCRYPT interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_encrypt
+(
+    instance_t    instance
+)
+{
+   (void)instance; /* Remove compiler warning */
+}
+
+/******************************************************************************
+ *    \brief HPD interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_hpd
+(
+    instance_t    instance
+)
+{
+	error_code_t           err;
+	bsl_hot_plug_t    hpd_status;  /* HPD status */
+	power_state_t          power_state; /* Power state of transmitter */
+
+	/* Get the current state */
+
+	/* If the current state is NOT_INITALIZED, set a flag */
+	if(dl_hdmi_tx_get_state(instance) == STATE_NOT_INITIALIZED) {
+		/* Get Hot Plug status */
+		err = bsl_hot_plug_get_status(instance, &hpd_status);
+
+		if(err != 0) return;
+
+		if(hpd_status == HDMITX_HOTPLUG_ACTIVE) {
+			event_hpdactive_flag = true;
+		} else {
+			event_hpdactive_flag = false;
+		}
+	} else {
+		hpd_status = HDMITX_HOTPLUG_INVALID;
+
+		/* Reset the EDID status */
+		edid_data_status = HDMITX_EDID_NOT_READ;
+
+		/* Get Hot Plug status */
+		err = bsl_hot_plug_get_status(instance, &hpd_status);
+
+		if(err != 0) return;
+
+		/* Get the power state of the transmitter */
+		err = bsl_power_get_state(instance, &power_state);
+
+		if(err != 0) return;
+
+		/* Has hot plug changed to Active? */
+		if(hpd_status == HDMITX_HOTPLUG_ACTIVE) {
+			/* Set state machine to Plugged */
+			dl_hdmi_tx_set_state(instance, STATE_PLUGGED);
+
+			if(dl_hdmi_tx_get_event_status(instance, DL_HDMITX_HPD_ACTIVE) == DL_HDMITX_EVENT_ENABLED) {
+				event_call_hpdactive_cback = false;
+				/* Release the sempahore */
+				(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance]);
+				unit_table_tx[instance].p_callback(DL_HDMITX_HPD_ACTIVE);
+				/* Take the sempahore */
+				(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance]);
+			} else {
+				event_call_hpdactive_cback = true;
+			}
+
+			if(power_state == power_on) {
+				/* Yes: Wait for DDC line to settle before reading EDID */
+				bsl_sys_timer_wait(instance, 500); /* ms */
+
+				/* EDID read */
+				err = bsl_edid_get_block_data(instance,
+				                              unit_table_tx[instance].p_edid_buffer, (u32)((unit_table_tx[instance].edid_buffer_size) >> 7),
+				                              unit_table_tx[instance].edid_buffer_size, &edid_data_status);
+
+				dl_hdmi_tx_handle_edid_read(instance);
+
+			}
+		} else {
+			event_call_hpdactive_cback = false;
+			/* Set state machine to Unplugged */
+			dl_hdmi_tx_set_state(instance, STATE_UNPLUGGED);
+
+			if(dl_hdmi_tx_get_event_status(instance, DL_HDMITX_HPD_INACTIVE) == DL_HDMITX_EVENT_ENABLED) {
+				/* Release the sempahore */
+				(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance]);
+				unit_table_tx[instance].p_callback(DL_HDMITX_HPD_INACTIVE);
+				/* Take the sempahore */
+				(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance]);
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *    \brief T0 interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_t0
+(
+    instance_t    instance
+)
+{
+	(void)instance;
+}
+
+/******************************************************************************
+ *    \brief BCAPS interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_bcaps
+(
+    instance_t    instance
+)
+{
+	(void)instance;
+}
+
+/******************************************************************************
+ *    \brief BSTATUS interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_bstatus
+(
+    instance_t    instance
+)
+{
+	(void)instance;
+}
+
+/******************************************************************************
+ *    \brief SHA_1 interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_sha_1
+(
+    instance_t    instance
+)
+{
+	(void)instance;
+}
+
+/******************************************************************************
+ *    \brief PJ interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_pj
+(
+    instance_t    instance
+)
+{
+	(void)instance;
+}
+
+#ifdef TMFL_TDA9981_SUPPORT
+/******************************************************************************
+ *    \brief R0 interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_r0
+(
+    instance_t    instance
+)
+{
+	instance_status_info_tx[instance].p_col_bar_state->hdcp_secure_or_t0      = false;
+	instance_status_info_tx[instance].p_col_bar_state->disable_color_bar_on_r0 = true;
+	instance_status_info_tx[instance].p_col_bar_state->hdcp_colbar_change    = true;
+}
+
+/******************************************************************************
+ *    \brief SW_INT interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_sw_int
+(
+    instance_t    instance
+)
+{
+	DUMMY_ACCESS(instance);
+}
+#endif
+
+/******************************************************************************
+ *    \brief RX_SENSE interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+#ifdef TMFL_RX_SENSE_ON
+static void dl_hdmi_tx_handle_rx_sense
+(
+    instance_t    instance
+)
+{
+	error_code_t           err;
+	bsl_rx_sense_t    rx_sense_status;  /* Rx Sense status */
+	bsl_hot_plug_t    hpd_status;      /* HPD status */
+
+	err = bsl_rx_sense_get_status(instance,
+	                              &rx_sense_status);
+
+	if(err != 0) return;
+
+	err = bsl_hot_plug_get_status(instance,
+	                              &hpd_status);
+
+	if(err != 0) return;
+
+	/*    if (hpdStatus == HDMITX_HOTPLUG_ACTIVE)
+	 *	    {*/
+	if(rx_sense_status == HDMITX_RX_SENSE_ACTIVE) {
+		if(dl_hdmi_tx_get_event_status(instance, DL_HDMITX_RX_DEVICE_ACTIVE) == DL_HDMITX_EVENT_ENABLED) {
+			event_call_rxsens_active_cback = false;
+			/* Release the sempahore */
+			(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance]);
+			unit_table_tx[instance].p_callback(DL_HDMITX_RX_DEVICE_ACTIVE);
+			/* Take the sempahore */
+			(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance]);
+		} else {
+			event_call_rxsens_active_cback = true;
+		}
+	} else if(rx_sense_status == HDMITX_RX_SENSE_INACTIVE) {
+		event_call_rxsens_active_cback = false;
+	}
+	/*    }*/
+}
+#endif
+
+/******************************************************************************
+ *    \brief EDID_READ interrupt callback.
+ *
+ *    \param instance     Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_handle_edid_read
+(
+    instance_t    instance
+)
+{
+	error_code_t           err = 0;
+	u8                   edid_status = DL_HDMITX_EDID_NOT_READ;
+
+	/* Get the edid status and read the connected device's EDID */
+
+	/* Get Edid status */
+	edid_status = edid_data_status;
+
+	if(err != 0) {
+		/* Set state machine to Plugged */
+		dl_hdmi_tx_set_state(instance, STATE_PLUGGED);
+		return;
+	}
+
+	/* Has hot plug changed to Active? */
+	if((edid_status == DL_HDMITX_EDID_READ) ||
+	   (edid_status == DL_HDMITX_EDID_ERROR_CHK)) {
+		/* Set state machine to EDID available */
+		dl_hdmi_tx_set_state(instance, STATE_EDID_AVAILABLE);
+	} else {
+		/* Set state machine to Plugged */
+		dl_hdmi_tx_set_state(instance, STATE_PLUGGED);
+	}
+
+	if(dl_hdmi_tx_get_event_status(instance, DL_HDMITX_EDID_RECEIVED) == DL_HDMITX_EVENT_ENABLED) {
+		/* Release the sempahore */
+		(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance]);
+		unit_table_tx[instance].p_callback(DL_HDMITX_EDID_RECEIVED);
+		/* Take the sempahore */
+		(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance]);
+	}
+}
+
+/******************************************************************************
+ *    \brief Command processing task, dedicated to unit/instance 0.
+ *
+ *    \param NA.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+#ifndef TMFL_NO_RTOS
+static void command_task_unit0()
+{
+	u8                   command;
+	/* Just to avoid compiler warning */
+	bool                    loop = true;
+
+	while(loop) {
+		tx_iwqueue_receive(unit_table_tx[0].queue_handle, &command);
+
+		/* Take the sempahore */
+		(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[0]);
+
+		/* Clear T0 flag before polling for interrupts */
+		instance_status_info_tx[0].p_col_bar_state->hdcp_secure_or_t0 = false;
+
+		if(g_i2cdebug_accesses_enabled == true) {
+			bsl_hw_handle_interrupt(0);
+
+		} /* gI2CDebugAccessesEnabled */
+
+		/* Enable interrupts for Tx (interrupts are disabled in the HandleInterrupt function) */
+		tx_iwenable_interrupts(DL_HDMI_IW_TX_1);
+
+		/* Release the sempahore */
+		(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[0]);
+	};
+}
+
+/******************************************************************************
+ *    \brief Command processing task, dedicated to unit/instance 1.
+ *
+ *    \param NA.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void command_task_unit1()
+{
+	u8                   command;
+	/* Just to avoid compiler warning */
+	bool                    loop = true;
+
+	while(loop) {
+		tx_iwqueue_receive(unit_table_tx[1].queue_handle, &command);
+
+		/* Take the sempahore */
+		(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[1]);
+
+		/* Clear T0 flag before polling for interrupts */
+		instance_status_info_tx[1].p_col_bar_state->hdcp_secure_or_t0 = false;
+
+		bsl_hw_handle_interrupt(1);
+
+		/* Enable interrupts for Tx (interrupts are disabled in the HandleInterrupt function) */
+		tx_iwenable_interrupts(DL_HDMI_IW_TX_2);
+
+		/* Release the sempahore */
+		(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[1]);
+	};
+}
+
+/******************************************************************************
+ *    \brief Hdcp check task, dedicated to unit/instance 0.
+ *
+ *    \param NA.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void hdcp_task_unit0()
+{
+	bool loop = true;    /* Just to avoid compiler warning */
+	bsl_hw_feature_t feature_supported;
+
+	bsl_hw_get_capabilities(0, &feature_supported);
+
+	while(loop) {
+		(void)tx_iwwait(35);
+
+		/* Take the sempahore */
+		(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[0]);
+
+		if(g_i2cdebug_accesses_enabled == true) {
+
+			if(g_ksv_secure_timer_counter) {
+				g_ksv_secure_timer_counter++;
+
+				if(g_ksv_secure_timer_counter == 5) {
+#ifdef TMFL_TDA9981_SUPPORT
+					dl_hdmi_tx_handle_r0(0);
+#endif
+					g_ksv_secure_timer_counter = 0;
+				}
+
+			}
+
+			dl_hdmi_tx_check_color_bar(0);
+			dl_hdmi_tx_check_hdcp_color_bar(0);
+
+		} /*  gI2CDebugAccessesEnabled == true*/
+
+		/* Release the sempahore */
+		(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[0]);
+	};
+}
+
+/******************************************************************************
+ *    \brief Hdcp check task, dedicated to unit/instance 1.
+ *
+ *    \param NA.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void hdcp_task_unit1()
+{
+	bool loop = true;    /* Just to avoid compiler warning */
+	bsl_hw_feature_t feature_supported;
+
+	bsl_hw_get_capabilities(1, &feature_supported);
+
+	while(loop) {
+		(void)tx_iwwait(35);
+
+		/* Take the sempahore */
+		(void)tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[1]);
+
+		dl_hdmi_tx_check_color_bar(1);
+		dl_hdmi_tx_check_hdcp_color_bar(1);
+
+		/* Release the sempahore */
+		(void)tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[1]);
+	};
+}
+#endif /* TMFL_NO_RTOS */
+
+/******************************************************************************
+ *    \brief Check hdcp state to manage color bar.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_check_hdcp_color_bar
+(
+    instance_t instance
+)
+{
+	/* Use HDCP check result to control HDCP colour bars */
+	if((instance_status_info_tx[instance].p_col_bar_state->disable_color_bar_on_r0 == true)
+	   && (instance_status_info_tx[instance].p_col_bar_state->hdcp_colbar_change == true)
+	   && (instance_status_info_tx[instance].p_col_bar_state->hdcp_secure_or_t0 == false)) {
+		/* Remove test pattern once if Authenticated with no error interrupts */
+		if(instance_status_info_tx[instance].p_col_bar_state->color_bar_on != false) {
+			instance_status_info_tx[instance].p_col_bar_state->color_bar_on = false;
+			instance_status_info_tx[instance].p_col_bar_state->change_color_bar_now = true;
+		}
+		/* Reset state flags */
+		instance_status_info_tx[instance].p_col_bar_state->hdcp_colbar_change = false;
+		instance_status_info_tx[instance].p_col_bar_state->hdcp_secure_or_t0 = true;
+	}
+
+	if((instance_status_info_tx[instance].p_col_bar_state->hdcp_encrypt_or_t0 == true)
+	   && (instance_status_info_tx[instance].p_col_bar_state->in_out_first_set_done == true)) {
+		/* Set test pattern once if not Authenticated, to mask HDCP failure */
+		if(instance_status_info_tx[instance].p_col_bar_state->color_bar_on != true) {
+			instance_status_info_tx[instance].p_col_bar_state->color_bar_on = true;
+			instance_status_info_tx[instance].p_col_bar_state->change_color_bar_now = true;
+		}
+		/* Reset state flag */
+		instance_status_info_tx[instance].p_col_bar_state->hdcp_encrypt_or_t0 = false;
+	}
+}
+
+/******************************************************************************
+ *    \brief Show color bars or restore the last video format.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_check_color_bar
+(
+    instance_t instance
+)
+{
+	if((instance_status_info_tx[instance].p_col_bar_state->in_out_first_set_done == true)
+	   && (instance_status_info_tx[instance].p_col_bar_state->change_color_bar_now == true)) {
+		instance_status_info_tx[instance].p_col_bar_state->change_color_bar_now = false;
+
+		if(unit_table_tx[instance].simplay_hd == true) {
+			if(instance_status_info_tx[instance].p_col_bar_state->color_bar_on == true) {
+				/* Set service mode colour bar on/off (also used as HDCP logo pattern) */
+				(void)dl_hdmi_tx_set_test_pattern_on(instance, instance_status_info_tx[instance].p_video_info->video_out_config.format,
+				                                     instance_status_info_tx[instance].p_video_info->video_out_config.mode,
+				                                     gtx_driver_config_table[instance].pattern);
+			} else {
+				/* Restore last output format and mode */
+				(void)dl_hdmi_tx_set_test_pattern_off(instance,
+				                                      instance_status_info_tx[instance].p_video_info->video_out_config.format,
+				                                      instance_status_info_tx[instance].p_video_info->video_out_config.mode);
+			}
+		}
+	}
+}
+
+/******************************************************************************
+ *    \brief Set the state of the state machine.
+ *
+ *    \param instance Instance identifier.
+ *    \param state    State of the state machine.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_set_state
+(
+    instance_t            instance,
+    tx_driver_state_t state
+)
+{
+	/* Set the state */
+	unit_table_tx[instance].state = state;
+}
+
+/******************************************************************************
+ *    \brief Get the state of the state machine.
+ *
+ *    \param instance Instance identifier.
+ *
+ *    \return txDriverState_t Current State of the state machine.
+ *
+ ******************************************************************************/
+tx_driver_state_t dl_hdmi_tx_get_state
+(
+    instance_t instance
+)
+{
+	tx_driver_state_t state;
+
+	/* Get the state */
+	state = unit_table_tx[instance].state;
+
+	return (state);
+}
+
+/******************************************************************************
+ *    \brief Get the state of the event (enabled or disabled).
+ *
+ *    \param instance Instance identifier.
+ *    \param event    Event to give the state.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_event_status_t dl_hdmi_tx_get_event_status
+(
+    instance_t        instance,
+    tx_event_t   event
+)
+{
+	tx_event_status_t   event_status;
+
+	/* Get the event status */
+	event_status = instance_status_info_tx[instance].p_event_state[event].status;
+
+	return (event_status);
+}
+
+error_code_t tx_debug_enable_i2caccesses(instance_t instance,
+        bool         enable_i2c)
+{
+	error_code_t   err = 0;
+
+	/* Check if instance number is in range */
+	if((instance < 0) || (instance >= MAX_UNITS)) {
+		err = ERR_DLHDMITX_BAD_INSTANCE;
+		return err;
+	}
+
+	if(enable_i2c == true) {
+		err = bsl_debug_write_fake_reg_page(instance);
+		g_i2cdebug_accesses_enabled = true;
+	} else {
+		g_i2cdebug_accesses_enabled = false;
+	}
+
+	return err;
+}
+
+error_code_t dl_hdmi_tx_edid_get_dtd
+(
+    instance_t                    instance,
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    u8                           max_dtdesc,
+    u8                           *p_written_dtdesc
+)
+{
+	error_code_t   err;
+
+	/* Check the current state */
+	RETIF(dl_hdmi_tx_get_state(instance) != STATE_EDID_AVAILABLE, ERR_DLHDMITX_INVALID_STATE)
+
+	/* Get detailled descriptors from EDID, return ERR_DLHDMITX_NO_RESOURCES if EDID are not read */
+	RETIF((err = bsl_edid_get_detailed_timing_descriptors(
+	                 instance, (bsl_edid_dtd_t *)p_dtdescriptors, max_dtdesc, p_written_dtdesc)) != 0, err);
+
+	return 0;
+}
+
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+)
+{
+
+	tx_vid_fmt_t          code_cea;
+	tx_pict_aspect_ratio_t picture_aspect_ratio;
+	bool                        format_interlaced;
+
+	format_interlaced = false;
+
+	if((p_dtdescriptors->flags) & 0x80) {
+		format_interlaced = true;
+	}
+
+	picture_aspect_ratio = dl_hdmi_tx_calc_aspect_ratio(p_dtdescriptors->h_image_size, p_dtdescriptors->v_image_size);
+
+	switch(p_dtdescriptors->h_active_pixels) {
+	case 640:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_640hap(p_dtdescriptors);
+		break;
+
+	case 720:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_720hap(p_dtdescriptors, picture_aspect_ratio);
+		break;
+
+	case 1280:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_1280hap(p_dtdescriptors);
+		break;
+
+	case 1920:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_1920hap(p_dtdescriptors, format_interlaced);
+		break;
+
+	case 1440:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_1440hap(p_dtdescriptors, picture_aspect_ratio, format_interlaced);
+		break;
+
+	case 2880:
+		code_cea = dl_hdmi_tx_convert_dtdto_cea_2880hap(p_dtdescriptors, picture_aspect_ratio, format_interlaced);
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_640HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_640hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->v_active_lines) {
+	case 480:
+		code_cea = dl_hdmitx_vfmt_01_640x480p_60hz;
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_720HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_720hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->v_active_lines) {
+	case 480:
+		if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+			code_cea = dl_hdmitx_vfmt_02_720x480p_60hz;
+		} else {
+			code_cea = dl_hdmitx_vfmt_03_720x480p_60hz;
+		}
+		break;
+
+	case 576:
+		if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+			code_cea = dl_hdmitx_vfmt_17_720x576p_50hz;
+		} else {
+			code_cea = dl_hdmitx_vfmt_18_720x576p_50hz;
+		}
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+
+}
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_1280HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1280hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->v_active_lines) {
+	case 720:
+		switch(p_dtdescriptors->h_blank_pixels) {
+		case 370:
+			code_cea = dl_hdmitx_vfmt_04_1280x720p_60hz;
+			break;
+
+		case 700:
+			code_cea = dl_hdmitx_vfmt_19_1280x720p_50hz;
+			break;
+
+		default:
+			/* Not a valid format */
+			code_cea = DL_HDMITX_VFMT_NULL;
+			break;
+		}
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_1920HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1920hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    bool                            format_interlaced
+
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->h_blank_pixels) {
+	case 280:
+		if(format_interlaced) {
+			code_cea = dl_hdmitx_vfmt_05_1920x1080i_60hz;
+		} else {
+			if(p_dtdescriptors->pixel_clock == 14850) {
+				code_cea = dl_hdmitx_vfmt_16_1920x1080p_60hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_34_1920x1080p_30hz;
+			}
+		}
+		break;
+
+	case 720:
+		if(format_interlaced) {
+			code_cea = dl_hdmitx_vfmt_20_1920x1080i_50hz;
+		} else {
+			switch(p_dtdescriptors->pixel_clock) {
+			case 14850:
+				code_cea = dl_hdmitx_vfmt_31_1920x1080p_50hz;
+				break;
+
+			case 7425:
+				code_cea = dl_hdmitx_vfmt_33_1920x1080p_25hz;
+				break;
+			default:
+				/* Not a valid format */
+				code_cea = DL_HDMITX_VFMT_NULL;
+				break;
+			}
+		}
+		break;
+
+	case 830:
+		code_cea = dl_hdmitx_vfmt_32_1920x1080p_24hz;
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_1440HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_1440hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio,
+    bool                            format_interlaced
+
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->v_active_lines) {
+	case 240:
+		if(format_interlaced) {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_06_720x480i_60hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_07_720x480i_60hz;
+			}
+		} else {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_08_720x240p_60hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_09_720x240p_60hz;
+			}
+		}
+		break;
+
+	case 288:
+		if(format_interlaced) {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_21_720x576i_50hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_22_720x576i_50hz;
+			}
+		} else {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_23_720x288p_50hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_24_720x288p_50hz;
+			}
+		}
+		break;
+
+	case 480:
+		if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+			code_cea = dl_hdmitx_vfmt_14_1440x480p_60hz;
+		} else {
+			code_cea = dl_hdmitx_vfmt_15_1440x480p_60hz;
+		}
+		break;
+
+	case 576:
+		if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+			code_cea = dl_hdmitx_vfmt_29_1440x576p_50hz;
+		} else {
+			code_cea = dl_hdmitx_vfmt_30_1440x576p_50hz;
+		}
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxConvertDTDtoCEA_2880HAP .
+ *
+ *    \param  pDTDescriptors      DTD to convert.
+ *            pictureAspectRatio  aspect ratio of DTD
+ *            formatInterlaced    DTD Interlaced or progressif
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_vid_fmt_t dl_hdmi_tx_convert_dtdto_cea_2880hap
+(
+    tx_edid_video_timings_t    *p_dtdescriptors,
+    tx_pict_aspect_ratio_t     picture_aspect_ratio,
+    bool                            format_interlaced
+)
+{
+	tx_vid_fmt_t          code_cea;
+
+	switch(p_dtdescriptors->v_active_lines) {
+	case 240:
+		if(format_interlaced) {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_10_720x480i_60hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_11_720x480i_60hz;
+			}
+		} else {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_12_720x240p_60hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_13_720x240p_60hz;
+			}
+		}
+		break;
+
+	case 288:
+		if(format_interlaced) {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_25_720x576i_50hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_26_720x576i_50hz;
+			}
+		} else {
+			if(picture_aspect_ratio == DL_HDMITX_P_ASPECT_RATIO_4_3) {
+				code_cea = dl_hdmitx_vfmt_27_720x288p_50hz;
+			} else {
+				code_cea = dl_hdmitx_vfmt_28_720x288p_50hz;
+			}
+		}
+		break;
+
+	default:
+		/* Not a valid format */
+		code_cea = DL_HDMITX_VFMT_NULL;
+		break;
+	}
+
+	return code_cea;
+}
+
+/******************************************************************************
+ *    \brief Caculation of aspect ratio.
+ *
+ *    \param HImageSize Horizontal image size.
+ *    \param VImageSize Vertical image size.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static tx_pict_aspect_ratio_t dl_hdmi_tx_calc_aspect_ratio(
+    u16    himage_size,
+    u16    vimage_size
+)
+{
+	tx_pict_aspect_ratio_t    picture_aspect_ratio;
+	u16                         calc_picture_aspect_ratio;
+
+	/* Define picture Aspect Ratio                                          */
+	/* 16/9 = 1.77777 so the result approach is 2                           */
+	/* 4/3 = 1.33333 so the result approach is 1                            */
+	/*  operation :                                                         */
+	/* ImageSize + (vImageSize/2)                                           */
+	/* -------------------------- > vImageSize     ->true 16/9 false 4/3    */
+	/*           2                                                          */
+
+	calc_picture_aspect_ratio = ((u16)(himage_size + ((vimage_size) >> 1))) >> 1;
+
+	if(calc_picture_aspect_ratio > vimage_size) {
+		picture_aspect_ratio = DL_HDMITX_P_ASPECT_RATIO_16_9;
+	} else {
+		picture_aspect_ratio = DL_HDMITX_P_ASPECT_RATIO_4_3;
+	}
+
+	return picture_aspect_ratio;
+
+}
+
+/******************************************************************************
+ *    \brief dlHdmiTxCheckHdcpBksv .
+ *
+ *    \param pHdcpBksvTested  ksv To test.
+ *    \param pbBksvSecure     Test result.
+ *    \param bBigEndian       ksv provide by hardware are in little or big endian.
+ *
+ *    \return NA.
+ *
+ ******************************************************************************/
+static void dl_hdmi_tx_check_hdcp_bksv
+(
+    instance_t    instance,
+    u8          *p_hdcp_bksv_tested,
+    bool           *pb_bksv_secure,
+    bool            b_big_endian
+)
+{
+	u32 nb_in_revocation_list;
+
+	nb_in_revocation_list = 0;
+
+	if((unit_table_tx[instance].revocation_list.p_list != NULL) && (unit_table_tx[instance].revocation_list.length > 0)) {
+		while((*pb_bksv_secure == true) && (nb_in_revocation_list < unit_table_tx[instance].revocation_list.length)) {
+			if(b_big_endian) {
+				if((p_hdcp_bksv_tested[0] == unit_table_tx[instance].revocation_list.p_list[nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE])
+				   &&
+				   (p_hdcp_bksv_tested[1] == unit_table_tx[instance].revocation_list.p_list[1 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[2] == unit_table_tx[instance].revocation_list.p_list[2 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[3] == unit_table_tx[instance].revocation_list.p_list[3 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[4] == unit_table_tx[instance].revocation_list.p_list[4 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				  ) {
+					*pb_bksv_secure = false;
+				}
+			} else {
+				if((p_hdcp_bksv_tested[4] == unit_table_tx[instance].revocation_list.p_list[nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE])
+				   &&
+				   (p_hdcp_bksv_tested[3] == unit_table_tx[instance].revocation_list.p_list[1 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[2] == unit_table_tx[instance].revocation_list.p_list[2 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[1] == unit_table_tx[instance].revocation_list.p_list[3 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				   &&
+				   (p_hdcp_bksv_tested[0] == unit_table_tx[instance].revocation_list.p_list[4 + (nb_in_revocation_list * HDMITX_KSV_BYTES_PER_DEVICE)])
+				  ) {
+					*pb_bksv_secure = false;
+				}
+			}
+			nb_in_revocation_list++;
+		}
+	}
+}
+
+error_code_t tx_get_hpdstatus
+(
+    instance_t            instance,
+    tx_hot_plug_t    *p_hpdstatus
+)
+{
+	error_code_t   err;
+
+	/* Check if instance number is in range */
+	RETIF((instance < 0) || (instance >= MAX_UNITS), ERR_DLHDMITX_BAD_INSTANCE)
+
+	RETIF(p_hpdstatus == NULL, ERR_DLHDMITX_INCONSISTENT_PARAMS)
+
+	/* Take the sempahore */
+	RETIF((err = tx_iwsemaphore_p(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	/* Get the HPD status from BSL driver */
+	err = bsl_hot_plug_get_status(instance, (bsl_hot_plug_t *)p_hpdstatus);
+
+	if(err == 0) {
+		/* do nothing */
+	} else {
+		*p_hpdstatus = DL_HDMITX_HOTPLUG_INVALID;
+	}
+
+	/* Release the sempahore */
+	RETIF((err = tx_iwsemaphore_v(dl_hdmi_tx_it_semaphore[instance])) != 0, err)
+
+	return 0;
+
+} /* txGetHPDStatus */
+
+/*============================================================================*/
+/*                            END OF FILE                                     */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx_local.h b/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx_local.h
new file mode 100755
index 0000000..847ca8d
--- /dev/null
+++ b/drivers/video/hdmi/comps/tmdlTDA9983/src/tmdlHdmiTx_local.h
@@ -0,0 +1,802 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * \file          tx_local.h
+ *
+ * \version       $Revision: 1 $
+ *
+ * \date          $Date: 02/08/07 08:32 $
+ *
+ * \brief         devlib driver component API for the TDA998x HDMI Transmitters
+ *
+ * \section refs  Reference Documents
+ * HDMI Tx Driver - FRS.doc,
+ *
+ * \section info  Change Information
+ *
+ * \verbatim
+ *
+ *   $History: tx_local.h $
+ *
+ * *****************  Version 13  *****************
+ * User: J. Lamotte Date: 02/08/07   Time: 08:32
+ * Updated in $/Source/tx/inc
+ * initial version
+ *
+ *
+ *   \endverbatim
+ *
+ * */
+
+#ifndef DLHDMITX_LOCAL_H
+#define DLHDMITX_LOCAL_H
+
+#include "tmdlHdmiTx_IW.h"
+#include "tmNxTypes.h"
+#include "tmdlHdmiTx_Types.h"
+
+/*============================================================================*/
+/*                            MACRO DEFINITIONS                               */
+/*============================================================================*/
+
+/* Version of the SW driver */
+#define VERSION_COMPATIBILITY 0
+#define VERSION_MAJOR         4
+#define VERSION_MINOR         18
+
+/* Invalid HDCP seed */
+#define HDCP_SEED_NULL      0
+
+/* A default seed value may be defined here, or set to HDCP_SEED_NULL.
+ * If HDCP_SEED_NULL, a table of seeds may instead be programmed separately
+ * into flash at the location of kSeedTable, below */
+#define HDCP_SEED_DEFAULT   HDCP_SEED_NULL
+
+/* Default SHA-1 test handling */
+#define HDCP_OPT_DEFAULT    ( DL_HDMITX_HDCP_OPTION_FORCE_PJ_IGNORED \
+                              | DL_HDMITX_HDCP_OPTION_FORCE_VSLOW_DDC \
+                              | DL_HDMITX_HDCP_OPTION_FORCE_NO_1_1 )
+
+/**
+ * A macro to check a condition and if true return a result
+ * */
+#define RETIF(cond, rslt)       if ((cond)){return (rslt);}
+
+/**
+ * A macro to check a condition and if true return
+ * ERR_DLHDMITX_BAD_PARAMETER.
+ * To save code space, it can be compiled out by defining NO_RETIF_BADPARAM on
+ * the compiler command line.
+ * */
+#ifdef NO_RETIF_BADPARAM
+#define RETIF_BADPARAM(cond)
+#else
+#define RETIF_BADPARAM(cond)  if ((cond)){return ERR_DLHDMITX_BAD_PARAMETER;}
+#endif
+
+/**
+ * A macro to check a condition and if true, release the semaphore describe by handle and return a result
+ * */
+#define RETIF_SEM(handle, cond, rslt)       if ((cond)){tx_iwsemaphore_v(handle); return (rslt);}
+
+/* Instance number */
+#define INSTANCE_0  0
+#define INSTANCE_1  1
+
+/* Number of event */
+#define EVENT_NB    9
+
+/* Size of a KSV is five bytes */
+#define KSV_SIZE  5
+
+/* Arbitrary short TV format values */
+#define TV_INVALID      0
+#define TV_VGA_60HZ     1
+#define TV_240p_60HZ    2
+#define TV_480p_60HZ    3
+#define TV_480i_60HZ    4
+#define TV_720p_60HZ    5
+#define TV_1080p_60HZ   6
+#define TV_1080i_60HZ   7
+#define TV_288p_50HZ    8
+#define TV_576p_50HZ    9
+#define TV_576i_50HZ    10
+#define TV_720p_50HZ    11
+#define TV_1080p_50HZ   12
+#define TV_1080i_50HZ   13
+
+/* Shorthands for vinMode values in bslTDA9984.h */
+#define iINVALID DL_HDMITX_VINMODE_INVALID
+#define iCCIR656 DL_HDMITX_VINMODE_CCIR656
+#define iRGB444  DL_HDMITX_VINMODE_RGB444
+#define iYUV444  DL_HDMITX_VINMODE_YUV444
+#define iYUV422  DL_HDMITX_VINMODE_YUV422
+
+/* Shorthands for input sync */
+#define EMB      1
+#define EXT      0
+
+/* Shorthands for single/double pixel rate in bslTDA9984.h */
+#define SINGLE   DL_HDMITX_PIXRATE_SINGLE
+#define DOUBLE   DL_HDMITX_PIXRATE_DOUBLE
+
+/* Shorthands for sampling frequency in txSetAudioInput API */
+#define AIF_SF_REFER_TO_STREAM_HEADER   0
+#define AIF_SF_32K                      1
+#define AIF_SF_44K                      2
+#define AIF_SF_48K                      3
+#define AIF_SF_88K                      4
+#define AIF_SF_96K                      5
+#define AIF_SF_176K                     6
+#define AIF_SF_192K                     7
+
+/* HDCP check interval in milliseconds */
+#define HDCP_CHECK_INTERVAL_MS  2500
+
+/* Number of HDCP checks to carry out after HDCP is started */
+#define HDCP_NUM_CHECKS         5
+
+#define DL_HDMITX_CHANNELALLOC_LUT_SIZE 32
+
+static CONST_DAT u8 k_chan_alloc_chan_num[DL_HDMITX_CHANNELALLOC_LUT_SIZE] = \
+{2, 3, 3, 4, 3, 4, 4, 5, 4, 5, 5, 6, 5, 6, 6, 7, 6, 7, 7, 8, 4, 5, 5, 6, 5, 6, 6, 7, 6, 7, 7, 8 };
+
+/**
+ * Lookup table to convert from EIA/CEA TV video format to
+ * aspect ratio used in video infoframe:
+ * Aspect ratio 1=4:3, 2=16:9
+ * */
+#ifndef FORMAT_PC
+static CONST_DAT u8 k_vfmt_to_aspect_tv[DL_HDMITX_VFMT_TV_NUM] =
+#else /* FORMAT_PC */
+static CONST_DAT u8 k_vfmt_to_aspect_tv[DL_HDMITX_VFMT_TV_NUM + DL_HDMITX_VFMT_PC_NUM] =
+#endif /* FORMAT_PC */
+{
+	0,  /* HDMITX_VFMT_NULL                */
+	1,  /* HDMITX_VFMT_01_640x480p_60HZ    */
+	1,  /* HDMITX_VFMT_02_720x480p_60HZ    */
+	2,  /* HDMITX_VFMT_03_720x480p_60HZ    */
+	2,  /* HDMITX_VFMT_04_1280x720p_60HZ   */
+	2,  /* HDMITX_VFMT_05_1920x1080i_60HZ  */
+	1,  /* HDMITX_VFMT_06_720x480i_60HZ    */
+	2,  /* HDMITX_VFMT_07_720x480i_60HZ    */
+	1,  /* HDMITX_VFMT_08_720x240p_60HZ    */
+	2,  /* HDMITX_VFMT_09_720x240p_60HZ    */
+	1,  /* HDMITX_VFMT_10_720x480i_60HZ    */
+	2,  /* HDMITX_VFMT_11_720x480i_60HZ    */
+	1,  /* HDMITX_VFMT_12_720x240p_60HZ    */
+	2,  /* HDMITX_VFMT_13_720x240p_60HZ    */
+	1,  /* HDMITX_VFMT_14_1440x480p_60HZ   */
+	2,  /* HDMITX_VFMT_15_1440x480p_60HZ   */
+	2,  /* HDMITX_VFMT_16_1920x1080p_60HZ  */
+	1,  /* HDMITX_VFMT_17_720x576p_50HZ    */
+	2,  /* HDMITX_VFMT_18_720x576p_50HZ    */
+	2,  /* HDMITX_VFMT_19_1280x720p_50HZ   */
+	2,  /* HDMITX_VFMT_20_1920x1080i_50HZ  */
+	1,  /* HDMITX_VFMT_21_720x576i_50HZ    */
+	2,  /* HDMITX_VFMT_22_720x576i_50HZ    */
+	1,  /* HDMITX_VFMT_23_720x288p_50HZ    */
+	2,  /* HDMITX_VFMT_24_720x288p_50HZ    */
+	1,  /* HDMITX_VFMT_25_720x576i_50HZ    */
+	2,  /* HDMITX_VFMT_26_720x576i_50HZ    */
+	1,  /* HDMITX_VFMT_27_720x288p_50HZ    */
+	2,  /* HDMITX_VFMT_28_720x288p_50HZ    */
+	1,  /* HDMITX_VFMT_29_1440x576p_50HZ   */
+	2,  /* HDMITX_VFMT_30_1440x576p_50HZ   */
+	2,  /* HDMITX_VFMT_31_1920x1080p_50HZ  */
+	2,  /* HDMITX_VFMT_32_1920x1080p_24HZ  */
+	2,  /* HDMITX_VFMT_33_1920x1080p_25HZ  */
+	2   /* HDMITX_VFMT_34_1920x1080p_30HZ  */
+#ifdef FORMAT_PC
+	, 1, /* HDMITX_VFMT_PC_640x480p_60HZ    */
+	1,  /* HDMITX_VFMT_PC_800x600p_60HZ    */
+	1,  /* HDMITX_VFMT_PC_1152x960p_60HZ   */
+	1,  /* HDMITX_VFMT_PC_1024x768p_60HZ   */
+	1,  /* HDMITX_VFMT_PC_1280x768p_60HZ   */
+	1,  /* HDMITX_VFMT_PC_1280x1024p_60HZ  */
+	1,  /* HDMITX_VFMT_PC_1360x768p_60HZ   */
+	1,  /* HDMITX_VFMT_PC_1400x1050p_60HZ  */
+	1,  /* HDMITX_VFMT_PC_1600x1200p_60HZ  */
+	1,  /* HDMITX_VFMT_PC_1024x768p_70HZ   */
+	1,  /* HDMITX_VFMT_PC_640x480p_72HZ    */
+	1,  /* HDMITX_VFMT_PC_800x600p_72HZ    */
+	1,  /* HDMITX_VFMT_PC_640x480p_75HZ    */
+	1,  /* HDMITX_VFMT_PC_1024x768p_75HZ   */
+	1,  /* HDMITX_VFMT_PC_800x600p_75HZ    */
+	1,  /* HDMITX_VFMT_PC_1024x864p_75HZ   */
+	1,  /* HDMITX_VFMT_PC_1280x1024p_75HZ  */
+	1,  /* HDMITX_VFMT_PC_640x350p_85HZ    */
+	1,  /* HDMITX_VFMT_PC_640x400p_85HZ    */
+	1,  /* HDMITX_VFMT_PC_720x400p_85HZ    */
+	1,  /* HDMITX_VFMT_PC_640x480p_85HZ    */
+	1,  /* HDMITX_VFMT_PC_800x600p_85HZ    */
+	1,  /* HDMITX_VFMT_PC_1024x768p_85HZ   */
+	1,  /* HDMITX_VFMT_PC_1152x864p_85HZ   */
+	1,  /* HDMITX_VFMT_PC_1280x960p_85HZ   */
+	1,  /* HDMITX_VFMT_PC_1280x1024p_85HZ  */
+	1   /* HDMITX_VFMT_PC_1024x768i_87HZ   */
+#endif /* FORMAT_PC */
+};
+
+/**
+ * Lookup table to convert from EIA/CEA TV video format to
+ * the short format of resolution/interlace/frequency
+ * */
+static CONST_DAT u8 k_vfmt_to_short_fmt_tv[DL_HDMITX_VFMT_TV_NUM] = {
+	TV_INVALID,         /* HDMITX_VFMT_NULL               */
+	TV_VGA_60HZ,        /* HDMITX_VFMT_01_640x480p_60HZ   */
+	TV_480p_60HZ,       /* HDMITX_VFMT_02_720x480p_60HZ   */
+	TV_480p_60HZ,       /* HDMITX_VFMT_03_720x480p_60HZ   */
+	TV_720p_60HZ,       /* HDMITX_VFMT_04_1280x720p_60HZ  */
+	TV_1080i_60HZ,      /* HDMITX_VFMT_05_1920x1080i_60HZ */
+	TV_480i_60HZ,       /* HDMITX_VFMT_06_720x480i_60HZ   */
+	TV_480i_60HZ,       /* HDMITX_VFMT_07_720x480i_60HZ   */
+	TV_240p_60HZ,       /* HDMITX_VFMT_08_720x240p_60HZ   */
+	TV_240p_60HZ,       /* HDMITX_VFMT_09_720x240p_60HZ   */
+	TV_480i_60HZ,       /* HDMITX_VFMT_10_720x480i_60HZ   */
+	TV_480i_60HZ,       /* HDMITX_VFMT_11_720x480i_60HZ   */
+	TV_240p_60HZ,       /* HDMITX_VFMT_12_720x240p_60HZ   */
+	TV_240p_60HZ,       /* HDMITX_VFMT_13_720x240p_60HZ   */
+	TV_480p_60HZ,       /* HDMITX_VFMT_14_1440x480p_60HZ  */
+	TV_480p_60HZ,       /* HDMITX_VFMT_15_1440x480p_60HZ  */
+	TV_1080p_60HZ,      /* HDMITX_VFMT_16_1920x1080p_60HZ */
+	TV_576p_50HZ,       /* HDMITX_VFMT_17_720x576p_50HZ   */
+	TV_576p_50HZ,       /* HDMITX_VFMT_18_720x576p_50HZ   */
+	TV_720p_50HZ,       /* HDMITX_VFMT_19_1280x720p_50HZ  */
+	TV_1080i_50HZ,      /* HDMITX_VFMT_20_1920x1080i_50HZ */
+	TV_576i_50HZ,       /* HDMITX_VFMT_21_720x576i_50HZ   */
+	TV_576i_50HZ,       /* HDMITX_VFMT_22_720x576i_50HZ   */
+	TV_288p_50HZ,       /* HDMITX_VFMT_23_720x288p_50HZ   */
+	TV_288p_50HZ,       /* HDMITX_VFMT_24_720x288p_50HZ   */
+	TV_576i_50HZ,       /* HDMITX_VFMT_25_720x576i_50HZ   */
+	TV_576i_50HZ,       /* HDMITX_VFMT_26_720x576i_50HZ   */
+	TV_288p_50HZ,       /* HDMITX_VFMT_27_720x288p_50HZ   */
+	TV_288p_50HZ,       /* HDMITX_VFMT_28_720x288p_50HZ   */
+	TV_576p_50HZ,       /* HDMITX_VFMT_29_1440x576p_50HZ  */
+	TV_576p_50HZ,       /* HDMITX_VFMT_30_1440x576p_50HZ  */
+	TV_1080p_50HZ       /* HDMITX_VFMT_31_1920x1080p_50HZ */
+};
+
+/**
+ * Macro to pack vinMode(0-5), pixRate(0-1), syncIn(0-1) and bVerified(0-1)
+ * into a byte
+ * */
+#define PKBYTE(mode,rate,sync,verf) (((rate)<<7)|((sync)<<6)|((verf)<<5)|((mode)&0x1F))
+
+/**
+ * Macros to unpack vinMode(0-5), pixRate(0-1), syncIn(0-1) and bVerified(0-1)
+ * from a byte
+ * */
+#define UNPKRATE(byte) (((byte)>>7)&1)
+#define UNPKSYNC(byte) (((byte)>>6)&1)
+#define UNPKVERF(byte) (((byte)>>5)&1)
+#define UNPKMODE(byte) ((byte)&0x1F)
+
+/**
+ * Lookup table to match main video settings and look up sets of
+ * Refpix and Refline values
+ * */
+static CONST_DAT struct {
+	/* Values to match */
+	/* Packed vinMode, pixRate, syncIn, bVerified */
+	u8   mode_rate_sync_verf;
+	u8   short_vin_fmt;
+	u8   short_vout_fmt;
+	/* Values to look up */
+	u16  ref_pix;             /* Output values */
+	u16  ref_line;
+	u16  sc_ref_pix;           /* Scaler values */
+	u16  sc_ref_line;
+} k_refpix_refline [] = {
+	/*************************************************************/
+	/** Rows formatted in "Refpix_Refline.xls" and pasted here  **/
+	/** DO NOT DELETE ANY ROWS, to keep all scaler combinations **/
+	/*************************************************************/
+	/*        mode_____Rate___Sync_Verf  shortVinFmt     shortVoutFmt    refPix  refLine  scRefPix  scRefLine  Test ID  */
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x08b,  0x024,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x08b,  0x012,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x08b,  0x00e,   0x078,    0x017},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x08b,  0x021,   0x078,    0x017},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x08b,  0x017,   0x078,    0x02c},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x08b,  0x013,   0x078,    0x02c},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x08b,  0x027,   0x078,    0x02c},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x091,  0x026,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x091,  0x013,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x091,  0x00f,   0x085,    0x018},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x091,  0x022,   0x085,    0x018},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x091,  0x019,   0x085,    0x02e},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x091,  0x014,   0x085,    0x02e},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x091,  0x028,   0x085,    0x02e},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x014,  0x20d,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x014,  0x2cb,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x014,  0x44c,   0x359,    0x004},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x014,  0x436,   0x359,    0x004},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x011,  0x2d3,   0x358,    0x007},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x011,  0x452,   0x358,    0x007},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x011,  0x43e,   0x358,    0x007},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x00d,  0x26b,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x00d,  0x2cb,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x00d,  0x44b,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x00d,  0x435,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x00d,  0x2d1,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x00d,  0x451,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iCCIR656, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x00d,  0x43d,   0x35f,    0x001},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x08b,  0x024,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x08b,  0x012,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x08b,  0x00e,   0x078,    0x017},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x08b,  0x021,   0x078,    0x017},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x08b,  0x017,   0x078,    0x02c},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x08b,  0x013,   0x078,    0x02c},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x08b,  0x027,   0x078,    0x02c},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x091,  0x026,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x091,  0x013,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x091,  0x00f,   0x085,    0x018},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x091,  0x022,   0x085,    0x018},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x091,  0x019,   0x085,    0x02e},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x091,  0x014,   0x085,    0x02e},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EMB, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x091,  0x028,   0x085,    0x02e},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x014,  0x20d,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x014,  0x2cb,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x014,  0x44c,   0x359,    0x004},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x014,  0x436,   0x359,    0x004},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x011,  0x2d3,   0x358,    0x007},
+	/* VID_F_01 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x011,  0x452,   0x358,    0x007},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x011,  0x43e,   0x358,    0x007},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x00d,  0x26b,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x00d,  0x2cb,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x00d,  0x44b,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x00d,  0x435,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x00d,  0x2d1,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x00d,  0x451,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iCCIR656, DOUBLE, EXT, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x00d,  0x43d,   0x35f,    0x001},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x08d,  0x028,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x08d,  0x014,   0x078,    0x017},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x08d,  0x010,   0x078,    0x017},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x08d,  0x021,   0x078,    0x017},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x08d,  0x017,   0x078,    0x02c},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x08d,  0x014,   0x078,    0x02c},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x08d,  0x027,   0x078,    0x02c},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x093,  0x02a,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x093,  0x013,   0x085,    0x018},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x093,  0x00e,   0x085,    0x018},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x093,  0x022,   0x085,    0x018},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x093,  0x019,   0x085,    0x02e},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x093,  0x014,   0x085,    0x02e},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x093,  0x028,   0x085,    0x02e},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_720p_50HZ,   TV_1080p_50HZ,  0x2bf,  0x024,   0x105,    0x019},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_720p_60HZ,   TV_1080p_60HZ,  0x175,  0x024,   0x105,    0x019},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_1080i_50HZ,  TV_1080p_50HZ,  0x2d3,  0x023,   0x0c3,    0x014},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EMB, 1),   TV_1080i_60HZ,  TV_1080p_60HZ,  0x11b,  0x023,   0x0c3,    0x014},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_480p_60HZ,   0x016,  0x20d,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_720p_60HZ,   0x016,  0x2cb,   0x359,    0x004},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_1080i_60HZ,  0x016,  0x44c,   0x359,    0x004},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480i_60HZ,   TV_1080p_60HZ,  0x016,  0x436,   0x359,    0x004},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_720p_60HZ,   0x013,  0x2d3,   0x358,    0x007},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_1080i_60HZ,  0x013,  0x452,   0x358,    0x007},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_480p_60HZ,   TV_1080p_60HZ,  0x013,  0x43e,   0x358,    0x007},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_576p_50HZ,   0x00f,  0x26b,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_720p_50HZ,   0x00f,  0x2cb,   0x35f,    0x001},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_1080i_50HZ,  0x00f,  0x44b,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576i_50HZ,   TV_1080p_50HZ,  0x00f,  0x435,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_720p_50HZ,   0x00f,  0x2d1,   0x35f,    0x001},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_1080i_50HZ,  0x00f,  0x451,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_576p_50HZ,   TV_1080p_50HZ,  0x00f,  0x43d,   0x35f,    0x001},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_720p_50HZ,   TV_1080p_50HZ,  0x1bb,  0x463,   0x7bb,    0x000},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_720p_60HZ,   TV_1080p_60HZ,  0x071,  0x463,   0x671,    0x000},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_1080i_50HZ,  TV_1080p_50HZ,  0x213,  0x460,   0xa4f,    0x000},
+	/*  */
+	{PKBYTE(iYUV422, SINGLE, EXT, 1),   TV_1080i_60HZ,  TV_1080p_60HZ,  0x05b,  0x460,   0x897,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV422, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, SINGLE, EMB, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, SINGLE, EXT, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iYUV444, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, SINGLE, EMB, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_480p_60HZ,   TV_VGA_60HZ,    0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, SINGLE, EXT, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, DOUBLE, EMB, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_480p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_04 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_480i_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_720p_60HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_01 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_480p_60HZ,   TV_1080i_60HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_576p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_09 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_576i_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_720p_50HZ,   0x000,  0x000,   0x000,    0x000},
+	/* VID_F_06 */
+	{PKBYTE(iRGB444, DOUBLE, EXT, 0),   TV_576p_50HZ,   TV_1080i_50HZ,  0x000,  0x000,   0x000,    0x000},
+	/* EndTable */
+	{PKBYTE(iINVALID, DOUBLE, EMB, 0),   TV_INVALID,     TV_INVALID,     0x000,  0x000,   0x000,    0x000}
+};
+
+/*============================================================================*/
+/*                         ENUM OR TYPE DEFINITIONS                           */
+/*============================================================================*/
+/* Enum listing all the type of colorimetry */
+typedef enum {
+	DL_HDMITX_COLORIMETRY_NO_DATA  = 0,
+	DL_HDMITX_COLORIMETRY_ITU601   = 1,
+	DL_HDMITX_COLORIMETRY_ITU709   = 2,
+	DL_HDMITX_COLORIMETRY_EXTENDED = 3
+} tx_colorimetry_t;
+
+/* Possible states of the state machine */
+typedef enum {
+	STATE_NOT_INITIALIZED,  /**< Driver is not initialized */
+	STATE_INITIALIZED,      /**< Driver is initialized */
+	STATE_UNPLUGGED,        /**< Receiver device not connected */
+	STATE_PLUGGED,          /**< Receiver device connected, clock lock */
+	STATE_EDID_AVAILABLE    /**< Managed to read receiver's EDID */
+} tx_driver_state_t;
+
+/* revocation list structure */
+typedef struct {
+	u8                      *p_list;
+	u32                      length;
+} revocation_list_t;
+
+/* unit configuration structure */
+typedef struct {
+	/**< Is unit instanciated ? */
+	bool                        opened;
+	/**< Is HDCP enabled ? */
+	bool                        hdcp_enable;
+	tx_hdcp_options_t     hdcp_options;			/**< HDCP options */
+	/**< Is repeater enabled ? */
+	bool                        repeater_enable;
+	/**< Enable simplayHD support */
+	bool                        simplay_hd;
+	/**< Version of the HW device */
+	tx_device_version_t   device_version;
+	/**< Pointer to raw EDID data */
+	u8                       *p_edid_buffer;
+	/**< Size of buffer for raw EDID data */
+	u32                      edid_buffer_size;
+	/**< Handle of the command task associated to this unit */
+	tx_iwtask_handle_t    command_task_handle;
+	/**< Handle of the message queue associated to this unit */
+	tx_iwqueue_handle_t   queue_handle;
+	/**< Handle of the hdcp check task associated to this unit */
+	tx_iwtask_handle_t	hdcp_task_handle;
+	/**< Current state of the driver */
+	tx_driver_state_t     state;
+	ptx_callback_t       p_callback;				/**< Data callback */
+	/**< Revolation List */
+	revocation_list_t            revocation_list;
+} unit_config_t;
+
+/* Instance status */
+
+/* Video information structure */
+typedef struct _tx_video_info_t {
+	/* Video mute state: on/off */
+	bool                        video_mute_state;
+	tx_video_in_config_t   video_in_config;  /* Video input configuration */
+	tx_video_out_config_t  video_out_config; /* Video output configuration */
+} tx_video_info_t, *ptx_video_info_t;
+
+/* Audio information structure */
+typedef struct _tx_audio_info_t {
+	/* Audio mute state: on/off */
+	bool                        audio_mute_state;
+	tx_audio_in_config_t   audio_in_cfg;     /* Audio input configuration */
+} tx_audio_info_t, *ptx_audio_info_t;
+
+/* Event state structure */
+typedef struct _tx_event_state_t {
+	tx_event_t       event;  /* Event */
+	tx_event_status_t status; /* Event status: enabled or disabled */
+} tx_event_state_t, *ptx_event_state_t;
+
+/* Color bars state structure */
+typedef struct _tx_col_bar_state_t {
+	/* To be able to disable colorBar */
+	bool disable_color_bar_on_r0;
+	/* Used to auto-reset colour bars */
+	bool hdcp_colbar_change;
+	/* true when ENCRYPT or T0 interrupt */
+	bool hdcp_encrypt_or_t0;
+	/* true when BKSV secure or T0 */
+	bool hdcp_secure_or_t0;
+	/* API txSetInputOutput call at least one time*/
+	bool in_out_first_set_done;
+	bool color_bar_on;
+	bool change_color_bar_now;
+} tx_col_bar_state_t, *ptx_col_bar_state_t;
+
+/* instance status structure */
+typedef struct {
+	/* Video information: current mode and format... */
+	ptx_video_info_t      p_video_info;
+	/* Audio information: current mode and format... */
+	ptx_audio_info_t      p_audio_info;
+	/* Event state: enabled or disabled */
+	ptx_event_state_t     p_event_state;
+	ptx_col_bar_state_t    p_col_bar_state;   /* Color bars state */
+	/* Numero of the buffer used for Gamut metadata (0 or 1) */
+	u8                       gamut_buf_num;
+} instance_status_t;
+
+#endif /* DLHDMITX_LOCAL_H */
+
+/*============================================================================*/
+/*                               END OF FILE                                  */
+/*============================================================================*/
diff --git a/drivers/video/hdmi/inc/tmNxCompId.h b/drivers/video/hdmi/inc/tmNxCompId.h
new file mode 100644
index 0000000..7cdcd58
--- /dev/null
+++ b/drivers/video/hdmi/inc/tmNxCompId.h
@@ -0,0 +1,287 @@
+/* -------------------------------------------------------------------------- */
+/* (C) Copyright 2000-2005              Koninklijke Philips Electronics N.V., */
+/*     All rights reserved                                                    */
+/*                                                                            */
+/* This source code and any compilation or derivative thereof is the          */
+/* proprietary information of Konlinklijke Philips Electronics N.V. and is    */
+/* Confidential in nature.                                                    */
+/* Under no circumstances is this software to be exposed to or placed under an*/
+/* Open Source License of any type without the expressed written permission of*/
+/* Koninklijke Philips Electronics N.V.                                       */
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/* MoReUse - 2005-10-24   Version 118                                         */
+/*                                                                            */
+/* Added:                                                                     */
+/*    CID_AACPENC                                                             */
+/*                                                                            */
+/*                                                                            */
+/* Changed:                                                                   */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* Removed:                                                                   */
+/*                                                                            */
+/*                                                                            */
+/*                                                                            */
+/* General Error Codes Added                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+/* FILE NAME:    tmNxCompId.h                                                 */
+/*                                                                            */
+/* DESCRIPTION:  This header file identifies the standard component           */
+/*               identifiers (CIDs) and interface identifiers (IID) for       */
+/*               Nexperia platforms.                                          */
+/*               The objective of these identifiers is to enable unique       */
+/*               identification of software components and interfaces.        */
+/*               In addition, standard status values are also defined to make */
+/*               determination of typical error cases much easier.            */
+/*                                                                            */
+/*               Functional errors are not real errors in the sense of        */
+/*               unexpected behaviour but are part of the normal communication*/
+/*               between a client an a server component. They are linked to   */
+/*               an interface, rather than to a component. All implementations*/
+/*               of an interface must have the same behaviour with respect to */
+/*               functional errors. Functional erros are all positive         */
+/*               One global functional error is defined:  0 0x00000000    */
+/*                                                                            */
+/*               Non-functional errors (all negative numbers) indicate        */
+/*               unexpected behaviour. They are linked to concrete component  */
+/*               implementations                                              */
+/*                                                                            */
+/*               NOTE: The current implementation is different from the prev. */
+/*                     component identifier implementation, based on classes, */
+/*                     types and layers. However, the new system is backward  */
+/*                     compatitible with the old implementation.              */
+/*                                                                            */
+/*               tmNxCompId.h defines a number of general error codes that can*/
+/*               be used by all components. These error codes are concatenated*/
+/*               to the CID or IID value in the local component headerfile of */
+/*               the component that wants to (re-)use this general error code */
+/*               General error codes can be used for both functional and      */
+/*               non-functional errors. They should only be used if they      */
+/*               semantically fully match (if not, defined a new component or */
+/*               interface specific error code.                               */
+/*                                                                            */
+/* General Rules:                                                             */
+/*               A return value has a length of 32 bits. At the binary level, */
+/*               1 bit indicates the component or interface flag; 16 bits are */
+/*               used for the actual component id (CID) or interface id (IID) */
+/*               and 12 bits for the return status.                           */
+/*                     The component/interface flag is bit 31.                */
+/*                     Bits 30--28 are all 0.                                 */
+/*                     The component/interface id occupies bits 27--12.       */
+/*                     The return status occupies bits 11--0.                 */
+/*                                                                            */
+/*                     +--------+-----+-------+-----------+                   */
+/*                     | flag:1 | 0:3 | id:16 | status:12 |                   */
+/*                     +--------+-----+-------+-----------+                   */
+/*                                                                            */
+/*                     Format of interface ids:                               */
+/*                                                                            */
+/*                     +-----+-----+--------+-----------+                     */
+/*                     | 0:1 | 0:3 | iid:16 | status:12 |                     */
+/*                     +-----+-----+--------+-----------+                     */
+/*                                                                            */
+/*                     Format of component ids:                               */
+/*                                                                            */
+/*                     +-----+-----+--------+-----------+                     */
+/*                     | 1:1 | 0:3 | cid:16 | status:12 |                     */
+/*                     +-----+-----+--------+-----------+                     */
+/*                                                                            */
+/*               At the macro level, we use the prefix "CID_" for component   */
+/*               ids (previous version "CID_COMP_") and "IID_" for interface  */
+/*               ids.                                                         */
+/*                                                                            */
+/*               Each component id will be used by only one component; each   */
+/*               component will have its own component id.                    */
+/*               Each interface id will be used by only one interface; each   */
+/*               interface will have its own interface id.                    */
+/*                                                                            */
+/*               In order to avoid problems when promoting a UNIQUE interface */
+/*               to a SEPARATE interface, the ranges for CIDs and IIDS must   */
+/*               not overlap.                                                 */
+/*                                                                            */
+/*               Component names and component ids have to be registered      */
+/*               together; the same applies for interface names and ids.      */
+/*                                                                            */
+/*           NOTE about Compatibility                                         */
+/*               In the previous implementation the first four bits were      */
+/*               reserved for class, and there were separate fields for       */
+/*               type and tag, like this:                                     */
+/*                                                                            */
+/*                     +---------+--------+-------+---------+-----------+     */
+/*                     | class:4 | type:4 | tag:8 | layer:4 | status:12 |     */
+/*                     +---------+--------+-------+---------+-----------+     */
+/*                                                                            */
+/*               The values 0 or 8 are not valid classes, and this fact       */
+/*               can be used to distinguish a new-style IID (class == 0),     */
+/*               a new-style CID (class == 8), and an old-style CID           */
+/*               (otherwise).                                                 */
+/*                                                                            */
+/*           NOTE about error codes                                           */
+/*               The general error codes use the range 0x001 to 0x7FF.        */
+/*               The component specific error codes are defined in the        */
+/*               local component header file and can use 0x800 to 0xFFF.      */
+/*               0 has the value 0x00000000.                              */
+/*               The proposed error code ranges (general and specific) are    */
+/*               the same for functional and non-functional errors.           */
+/*                                                                            */
+/*               The previously defined ranges for external customers,        */
+/*               assert errors and fatal errors have been dropped.            */
+/*               The previously defined range for general errors started      */
+/*               at 0x000 instead of 0x001                                    */
+/*                                                                            */
+/* DOCUMENT REF: Nexperia/MoReUse Naming Conventions                          */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+#ifndef TMNXCOMPID_H
+#define TMNXCOMPID_H
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*   Standard include files:                                                  */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#include "tmNxTypes.h"
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*    Types and defines:                                                      */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*   0 is the 32 bit global status value used by all Nexperia components  */
+/*   to indicate successful function/operation status.  If a non-zero value is*/
+/*   returned as status, it should use the component ID formats defined.      */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+
+/* -------------------------------------------------------------------------- */
+/*                                                                            */
+/*     General Defines                                                        */
+/*                                                                            */
+/* -------------------------------------------------------------------------- */
+#define CID_IID_FLAG_BITSHIFT    31
+#define CID_ID_BITSHIFT          12
+#define IID_ID_BITSHIFT          12
+
+#define CID_FLAG                 (0x1U << CID_IID_FLAG_BITSHIFT)
+#define IID_FLAG                 (0x0U << CID_IID_FLAG_BITSHIFT)
+
+#define CID_ID(number)           ((number) << CID_ID_BITSHIFT)
+#define CID_ID_BITMASK           (0x7FFFFU  << CID_ID_BITSHIFT)
+
+#define IID_ID(number)           ((number) << IID_ID_BITSHIFT)
+#define IID_ID_BITMASK           (0x7FFFFU  << IID_ID_BITSHIFT)
+
+#define CID_ERR_BITMASK                 0xFFFU
+#define CID_ERR_BITSHIFT                0
+#define CID_GET_ERROR(compId)   ((compId & CID_ERR_BITMASK) >> CID_ERR_BITSHIFT)
+
+#define CID_BSL_HDMITX              (CID_ID(0x8240U) | CID_FLAG)
+
+#define ERR_COMPATIBILITY            0x001U /* SW Interface compatibility   */
+#define ERR_MAJOR_VERSION            0x002U /* SW Major Version error       */
+#define ERR_COMP_VERSION             0x003U /* SW component version error   */
+#define ERR_BAD_MODULE_ID            0x004U /* SW - HW module ID error      */
+#define ERR_BAD_UNIT_NUMBER          0x005U /* Invalid device unit number   */
+#define ERR_BAD_INSTANCE             0x006U /* Bad input instance value     */
+#define ERR_BAD_HANDLE               0x007U /* Bad input handle             */
+#define ERR_BAD_INDEX                0x008U /* Bad input index              */
+#define ERR_BAD_PARAMETER            0x009U /* Invalid input parameter      */
+#define ERR_NO_INSTANCES             0x00AU /* No instances available       */
+#define ERR_NO_COMPONENT             0x00BU /* Component is not present     */
+#define ERR_NO_RESOURCES             0x00CU /* Resource is not available    */
+#define ERR_INSTANCE_IN_USE          0x00DU /* Instance is already in use   */
+#define ERR_RESOURCE_OWNED           0x00EU /* Resource is already in use   */
+#define ERR_RESOURCE_NOT_OWNED       0x00FU /* Caller does not own resource */
+#define ERR_INCONSISTENT_PARAMS      0x010U /* Inconsistent input params    */
+#define ERR_NOT_INITIALIZED          0x011U /* Component is not initialized */
+#define ERR_NOT_ENABLED              0x012U /* Component is not enabled     */
+#define ERR_NOT_SUPPORTED            0x013U /* Function is not supported    */
+#define ERR_INIT_FAILED              0x014U /* Initialization failed        */
+#define ERR_BUSY                     0x015U /* Component is busy            */
+#define ERR_NOT_BUSY                 0x016U /* Component is not busy        */
+#define ERR_READ                     0x017U /* Read error                   */
+#define ERR_WRITE                    0x018U /* Write error                  */
+#define ERR_ERASE                    0x019U /* Erase error                  */
+#define ERR_LOCK                     0x01AU /* Lock error                   */
+#define ERR_UNLOCK                   0x01BU /* Unlock error                 */
+#define ERR_OUT_OF_MEMORY            0x01CU /* Memory allocation failed     */
+#define ERR_BAD_VIRT_ADDRESS         0x01DU /* Bad virtual address          */
+#define ERR_BAD_PHYS_ADDRESS         0x01EU /* Bad physical address         */
+#define ERR_TIMEOUT                  0x01FU /* Timeout error                */
+#define ERR_OVERFLOW                 0x020U /* Data overflow/overrun error  */
+#define ERR_FULL                     0x021U /* Queue (etc.) is full         */
+#define ERR_EMPTY                    0x022U /* Queue (etc.) is empty        */
+#define ERR_NOT_STARTED              0x023U /* Streaming function failed    */
+#define ERR_ALREADY_STARTED          0x024U /* Start function failed        */
+#define ERR_NOT_STOPPED              0x025U /* Non-streaming function failed*/
+#define ERR_ALREADY_STOPPED          0x026U /* Stop function failed         */
+#define ERR_ALREADY_SETUP            0x027U /* Setup function failed        */
+#define ERR_NULL_PARAMETER           0x028U /* NULL input parameter         */
+#define ERR_NULL_DATAINFUNC          0x029U /* NULL data input function     */
+#define ERR_NULL_DATAOUTFUNC         0x02AU /* NULL data output function    */
+#define ERR_NULL_CONTROLFUNC         0x02BU /* NULL control function        */
+#define ERR_NULL_COMPLETIONFUNC      0x02CU /* NULL completion function     */
+#define ERR_NULL_PROGRESSFUNC        0x02DU /* NULL progress function       */
+#define ERR_NULL_ERRORFUNC           0x02EU /* NULL error handler function  */
+#define ERR_NULL_MEMALLOCFUNC        0x02FU /* NULL memory alloc function   */
+#define ERR_NULL_MEMFREEFUNC         0x030U /* NULL memory free  function   */
+#define ERR_NULL_CONFIGFUNC          0x031U /* NULL configuration function  */
+#define ERR_NULL_PARENT              0x032U /* NULL parent data             */
+#define ERR_NULL_IODESC              0x033U /* NULL in/out descriptor       */
+#define ERR_NULL_CTRLDESC            0x034U /* NULL control descriptor      */
+#define ERR_UNSUPPORTED_DATACLASS    0x035U /* Unsupported data class       */
+#define ERR_UNSUPPORTED_DATATYPE     0x036U /* Unsupported data type        */
+#define ERR_UNSUPPORTED_DATASUBTYPE  0x037U /* Unsupported data subtype     */
+#define ERR_FORMAT                   0x038U /* Invalid/unsupported format   */
+#define ERR_INPUT_DESC_FLAGS         0x039U /* Bad input  descriptor flags  */
+#define ERR_OUTPUT_DESC_FLAGS        0x03AU /* Bad output descriptor flags  */
+#define ERR_CAP_REQUIRED             0x03BU /* Capabilities required ???    */
+#define ERR_BAD_TMALFUNC_TABLE       0x03CU /* Bad TMAL function table      */
+#define ERR_INVALID_CHANNEL_ID       0x03DU /* Invalid channel identifier   */
+#define ERR_INVALID_COMMAND          0x03EU /* Invalid command/request      */
+#define ERR_STREAM_MODE_CONFUSION    0x03FU /* Stream mode config conflict  */
+#define ERR_UNDERRUN                 0x040U /* Data underflow/underrun      */
+#define ERR_EMPTY_PACKET_RECVD       0x041U /* Empty data packet received   */
+#define ERR_OTHER_DATAINOUT_ERR      0x042U /* Other data input/output err  */
+#define ERR_STOP_REQUESTED           0x043U /* Stop in progress             */
+#define ERR_ASSERTION                0x049U /* Assertion failure            */
+#define ERR_HIGHWAY_BANDWIDTH        0x04AU /* Highway bandwidth bus error  */
+#define ERR_HW_RESET_FAILED          0x04BU /* Hardware reset failed        */
+#define ERR_BAD_FLAGS                0x04DU /* Bad flags                    */
+#define ERR_BAD_PRIORITY             0x04EU /* Bad priority                 */
+#define ERR_BAD_REFERENCE_COUNT      0x04FU /* Bad reference count          */
+#define ERR_BAD_SETUP                0x050U /* Bad setup                    */
+#define ERR_BAD_STACK_SIZE           0x051U /* Bad stack size               */
+#define ERR_BAD_TEE                  0x052U /* Bad tee                      */
+#define ERR_IN_PLACE                 0x053U /* In place                     */
+#define ERR_NOT_CACHE_ALIGNED        0x054U /* Not cache aligned            */
+#define ERR_NO_ROOT_TEE              0x055U /* No root tee                  */
+#define ERR_NO_TEE_ALLOWED           0x056U /* No tee allowed               */
+#define ERR_NO_TEE_EMPTY_PACKET      0x057U /* No tee empty packet          */
+#define ERR_NULL_PACKET              0x059U /* NULL packet                  */
+#define ERR_FORMAT_FREED             0x05AU /* Format freed                 */
+#define ERR_FORMAT_INTERNAL          0x05BU /* Format internal              */
+#define ERR_BAD_FORMAT               0x05CU /* Bad format                   */
+#define ERR_FORMAT_NEGOTIATE_DATACLASS 0x05DU /* Format negotiate class     */
+#define ERR_FORMAT_NEGOTIATE_DATATYPE 0x05EU /* Format negotiate type       */
+#define ERR_FORMAT_NEGOTIATE_DATASUBTYPE 0x05FU /* Format negotiate subtype */
+#define ERR_FORMAT_NEGOTIATE_DESCRIPTION 0x060U /* Format negotiate desc    */
+#define ERR_NULL_FORMAT              0x061U /* NULL format                  */
+#define ERR_FORMAT_REFERENCE_COUNT   0x062U /* Format reference count       */
+#define ERR_FORMAT_NOT_UNIQUE        0x063U /* Format not unique            */
+#define NEW_FORMAT                   0x064U /* New format (not an error)    */
+#define ERR_FORMAT_NEGOTIATE_EXTENSION 0x065U /* Format negotiate extension */
+#define ERR_INVALID_STATE            0x066U /* Invalid state for function   */
+#define ERR_NULL_CONNECTION          0x067U /* No connection to this pin    */
+#define ERR_OPERATION_NOT_PERMITTED  0x068U /* corresponds to posix EPERM   */
+#define ERR_NOT_CLOCKED              0x069U /* Power down - clocked off     */
+
+
+#endif /* TMNXCOMPID_H ----------------- */
diff --git a/drivers/video/hdmi/inc/tmNxTypes.h b/drivers/video/hdmi/inc/tmNxTypes.h
new file mode 100644
index 0000000..645a779
--- /dev/null
+++ b/drivers/video/hdmi/inc/tmNxTypes.h
@@ -0,0 +1,177 @@
+/*==========================================================================*/
+/*     (Copyright (C) 2003 Koninklijke Philips Electronics N.V.             */
+/*     All rights reserved.                                                 */
+/*     This source code and any compilation or derivative thereof is the    */
+/*     proprietary information of Koninklijke Philips Electronics N.V.      */
+/*     and is confidential in nature.                                       */
+/*     Under no circumstances is this software to be exposed to or placed   */
+/*     under an Open Source License of any type without the expressed       */
+/*     written permission of Koninklijke Philips Electronics N.V.           */
+/*==========================================================================*/
+/*
+ * Copyright (C) 2000,2001
+ *               Koninklijke Philips Electronics N.V.
+ *               All Rights Reserved.
+ *
+ * Copyright (C) 2000,2001 TriMedia Technologies, Inc.
+ *               All Rights Reserved.
+ *
+ *############################################################
+ *
+ * Module name  : tmNxTypes.h  %version: 7 %
+ *
+ * Last Update  : %date_modified: Tue Jul  8 18:08:00 2003 %
+ *
+ * Description: TriMedia/MIPS global type definitions.
+ *
+ * Document Ref: DVP Software Coding Guidelines Specification
+ * DVP/MoReUse Naming Conventions specification
+ * DVP Software Versioning Specification
+ * DVP Device Library Architecture Specification
+ * DVP Board Support Library Architecture Specification
+ * DVP Hardware API Architecture Specification
+ *
+ *
+ *############################################################
+ * */
+
+#ifndef TMNXTYPES_H
+#define TMNXTYPES_H
+
+#include <linux/kernel.h>
+
+#ifndef _TMtypes_h
+#define _TMtypes_h
+
+#define false           0
+#define true            1
+
+/*----------------------------------------------------------------------------- */
+/* Legacy TM Types/Structures (Not necessarily DVP Coding Guideline compliant) */
+/* NOTE: For DVP Coding Gudeline compliant code, do not use these types. */
+
+typedef char          *address;        /* Ready for address-arithmetic */
+typedef char const    *const_address;
+typedef unsigned char  byte;           /* Raw byte */
+typedef float          float32;        /* Single-precision float */
+typedef double         float64;        /* Double-precision float */
+typedef void          *pointer;        /* Pointer to anonymous object */
+typedef void const    *const_pointer;
+typedef char const    *const_string;
+
+typedef int             endian;
+#define BigEndian       0
+#define LittleEndian    1
+
+typedef struct version {
+	u8 major_version;
+	u8 minor_version;
+	u16 build_version;
+}   version_t, *p_version_t;
+#endif /*ndef _TMtypes_h*/
+
+#define TMFL_ENDIAN_BIG               1
+#define TMFL_ENDIAN_LITTLE            0
+#define TMFL_ENDIAN                   (TMFL_ENDIAN_LITTLE)
+
+/*Define DVP types that are not TCS types.*/
+/*
+ ** ===== updated from SDE2/2.3_beta/sde_template/inc/nx_types.h =====
+ **
+ ** NOTE: ibits32/ubits32 types are defined for use with 32 bit bitfields.
+ **       this is done because ANSI/ISO compliant compilers require bitfields
+ **       to be of type "int" else a large number of compiler warnings will
+ **       result.  to avoid the risks associated with redefining int32/u32
+ **       to type "int" instead of type "long" (which are the same size on 32
+ **       bit cpus) separate 32bit signed/unsigned bitfield types are defined.
+ * */
+/* FIXME */
+typedef signed   int    ibits32;    /* 32 bit   signed integer bitfields */
+typedef unsigned int    ubits32;    /* 32 bit unsigned integer bitfields */
+typedef ibits32 *p_ibits32;          /* 32 bit   signed integer bitfield ptr */
+typedef ubits32 *p_ubits32;          /* 32 bit unsigned integer bitfield ptr */
+
+typedef char   *p_int8;            /*  8 bit   signed integer */
+typedef s16  *p_int16;           /* 16 bit   signed integer */
+typedef s32  *p_int32;           /* 32 bit   signed integer */
+typedef u8  *p_uint8;           /*  8 bit unsigned integer */
+typedef u16 *p_uint16;          /* 16 bit unsigned integer */
+typedef u32 *p_uint32;          /* 32 bit unsigned integer */
+typedef void *p_void;           /* void (typeless) */
+typedef float  *p_float;           /* 32 bit floating point */
+typedef double  *p_double; /* 32/64 bit floating point */
+typedef bool   *p_bool;            /* Boolean (true/false) */
+typedef char   *p_char;            /* character, character array ptr */
+typedef int    *p_int;             /* machine-natural integer */
+typedef uint   *p_uint;            /* machine-natural unsigned integer */
+
+/* Maximum length of device name in all BSP and capability structures */
+#define HAL_DEVICE_NAME_LENGTH 16
+
+typedef u32 error_code_t;
+typedef u32 progress_code_t;
+
+
+//-----------------------------------------------------------------------------
+// Hardware device power states
+//
+typedef enum tmPowerState
+{
+    power_on,                          // Device powered on      (D0 state)
+    power_standby,                     // Device power standby   (D1 state)
+    power_suspend,                     // Device power suspended (D2 state)
+    power_off                          // Device powered off     (D3 state)
+
+}   power_state_t, *p_power_state_t;
+
+/*----------------------------------------------------------------------------- */
+/* Software Version Structure */
+
+typedef struct swversion {
+	u32      compatibility_nr;        /* Interface compatibility number */
+	u32      major_version_nr;         /* Interface major version number */
+	u32      minor_version_nr;         /* Interface minor version number */
+
+}   swversion_t, *p_swversion_t;
+
+/*Under the TCS, <tm1/tmBoardDef.h> may have been included by our client. In
+ *    order to avoid errors, we take account of this possibility, but in order to
+ *    support environments where the TCS is not available, we do not include the
+ *    file by name.*/
+#ifndef _TMBOARDDEF_H_
+#define _TMBOARDDEF_H_
+
+/*----------------------------------------------------------------------------- */
+/* HW Unit Selection */
+
+typedef int unit_select_t, *p_unit_select_t;
+
+#define tmUnitNone (-1)
+#define tmUnit0    0
+#define tmUnit1    1
+#define tmUnit2    2
+#define tmUnit3    3
+#define tmUnit4    4
+
+/*+compatibility*/
+#define unitSelect_t       tmUnitSelect_t
+#define unit0              tmUnit0
+#define unit1              tmUnit1
+#define unit2              tmUnit2
+#define unit3              tmUnit3
+#define unit4              tmUnit4
+#define DEVICE_NAME_LENGTH HAL_DEVICE_NAME_LENGTH
+/*-compatibility*/
+
+#endif /*ndef _TMBOARDDEF_H_ */
+
+/*----------------------------------------------------------------------------- */
+/* Instance handle */
+
+typedef int instance_t, *p_instance_t;
+
+/* Callback function declaration */
+typedef void(*p_callback_t)(u32 events, void *p_data, u32 user_data);
+#define tmCallback_t ptmCallback_t /*compatibility*/
+
+#endif /*ndef TMNXTYPES_H */
diff --git a/drivers/video/hdmi/release_note.txt b/drivers/video/hdmi/release_note.txt
new file mode 100644
index 0000000..4d427e8
--- /dev/null
+++ b/drivers/video/hdmi/release_note.txt
@@ -0,0 +1,305 @@
+Release note:
+
+-------------------------------
+   HDMI Tx modules for TDA998x
+             by
+    NXP Semiconductors BV
+-------------------------------
+
+The release note gives all necessary detail for installation in Linux
+kernel and application tunning. Installation is Linux typical and does
+not require any HDMI background. A default video and audio setting is
+defined in hdmi_tx_init function. It can be changed at will.
+There is no porting to do, it is already provided in module. And the
+classical HDMI DevLib is embedded in it. But the UserManual is still
+usefull for customers who like to optimise the module according to
+their needs. If so, feedback is welcome. ;)
+Customers who like to drive the module from userland can do it using
+IOCTL. IOCTL maps the classical HDMI API. Using the WAIT_FRAME IOCTL,
+userland can catch HDMI events like Hot Plug Detect, RxSens or EDID.
+
+So the two main functions the customer needs to take care are :
+- hdmi_tx_init
+- eventCallbackTx
+
+For OMAP architecture, a DSS plugin is provided. So in order to activate
+HDMI (switch DSS to HDMI output) just prompt on target:
+echo "3" > /sys/power/vdd2_lock
+echo "1" > /sys/devices/platform/omapdss/display2/enabled
+And desactivate : 
+echo "0" > /sys/devices/platform/omapdss/display2/enabled
+
+-------------------------------
+
+- Contains : 
+  . HdmiTx Linux module
+  . HdmiCec linux module
+  . HDCP linux module (on request only)
+  . test_hdmi/demo_tda test application
+  . TRANSMITTER_TDA998X_SW_UM_Devlib.pdf for HDMI TX API
+  . HDMI_CEC_User_Manual.pdf for HDMI CEC API
+  . this release note
+
+- Features :
+  . HDMI transmiter
+  . Hot Plug Detection
+  . HDCP (on request only)
+  . Customer Electronics Control (v1.4)
+
+- Target :
+  . OMAP3430-ZOOMII (http://omappedia.org/wiki/Android_Getting_Started)
+
+- OS :
+  . Linux Kernel 2.6.29, Android RLS25.12
+
+- Directory :
+  . driver/video/hdmi
+  . driver/video/hdcp (only if hdcp is delivered)
+
+- Compilation tool :
+  . arm-2007q3-51-arm-none-linux-gnueabi-i686-pc-linux-gnu
+
+-------------------------------
+
+- Release :
+
+ * V1.0: 2010, 1st Jully by Andre Lepine
+  . ATC compliancy
+  . BCaps polling during 5s when CCLK is not devided by 2
+  . It HPD+RxSens rebound (several changes before SW polling)
+  . EDID used for video mode switch (HDMI, DVI)
+  . blue screen before the HDCP authentification is passed
+  . TDA reset when removing Linux module
+  . hdcp_fail_status not used in TDA9981
+ * V0.964: 2010, 25th may by Andre Lepine
+  . Check incoming REQUEST_ACTIVE_SOURCE is a broadcast
+ * V0.963: 2010, 21th may by Andre Lepine
+  . External HDCP module validation 
+ * V0.963: 2010, 18th may by Andre Lepine
+  . External HDCP module validation 
+ * V0.962: 2010, 11th may by Andre Lepine
+  . Clean up
+ * V0.961: 2010, 4th may by Andre Lepine
+  . Put image_view_on under compilation flag because it is not suitable for
+    "only hdmi with videoplay" usecase
+  . DEVICE_VENDOR_ID boradcast after logical address retrival
+  . Allow CEC_OPCODE_VENDOR_COMMAND and CEC_OPCODE_DEVICE_VENDOR_ID (not send FEATURE ABORTED)
+ * V0.96: 2010, 16th april by Andre Lepine
+  . Accept HDCP support using the proprietary module nwolc.ko
+ * V0.95: 2010, 23th march by Andre Lepine
+  . Add TDA9981 driver
+ * V0.94: 2010, 19th march by Andre Lepine
+  . Merge TDA19989, TDA9984 and TDA9983 drivers
+ * V0.92: 2010, 11th march by Andre Lepine
+  . Clean-up
+  . DSS pixclock inversion
+ * V0.91: 2010, 18th february by Andre Lepine
+  . porting for TDA9983
+ * V0.9: 2010, 2nd february by Andre Lepine
+  . Change directory structure
+  . Update NXP DevLib
+  . CEC & HDP event handeling fix
+ * V0.8: 2010, 18 january by Andre Lepine
+  . Pure IRQ (remove IRQ flag for polling with timer)
+  . Merge with last HdmiTx and HdmiCec version
+  . Cec initialization and power state
+  . Check argument of IOCTL and use -EFAULT when inconsistant
+ * V0.7: 2010, 11 january by Andre Lepine
+  . Automatic CEC answering for following opcodes :
+     > GIVE_PHYSICAL_ADDRESS
+     > GET_CEC_VERSION
+     > GIVE_OSD_NAME
+     > GIVE_DEVICE_VENDOR_ID
+     > REQUEST_ACTIVE_SOURCE
+     > GIVE_DEVICE_POWER_STATUS
+     > STANDBY
+     > SET_STREAM_PATH
+     > ROUTING_CHANGE
+     > ABORT_MESSAGE
+  . Automatic logical address negociation
+  . HdmiCec gets EDID physical address and HDMI status from HdmiTx
+
+-------------------------------
+
+- Installation :
+
+ * On host:
+  . mkdir $KERNEL_MODULES
+  . cp linux-hdmi-nxp-modules.v##.cvfj $KERNEL_MODULES/.
+  . cd $KERNEL_MODULES
+  . tar xvfj linux-hdmi-nxp-modules.v##.cvfj
+  . update LINUX_DIR in hdmi/MakeModules with your kernel directory path
+  . select your TDA target in Makefile :  for example TDA_TX := TDA9984  !!! CAUTION, don't forget this !!!
+  . select your platform in Makefile :  for example TDA_PLATFORM := ZOOMII
+  . cd hdmi
+  . make -f MakeModules clean (optional for the first time)
+  . make -f MakeModules
+  . make -f MakeModules uptx (or any download mean that does not use adb)
+  . make -f MakeModules upcec (or any download mean that does not use adb)
+  . cd hdcp
+  . make -f MakeModules
+  . make -f MakeModules up (or any download mean that does not use adb)
+ * Application (optional), better use your own, this one is just a sample
+  . cd test
+  . make clean (optional for the first time)
+  . make
+  . make upload (or any download mean that does not use adb)
+ * On target:
+  . insmod hdmitx.ko verbose=1 (remove verbose to make the module silent)
+  . insmod hdmicec.ko verbose=1 device=4 (remove verbose to make the module silent)
+  . insmod nwolc.ko (only for HDCP)
+ * On TV
+  . connect TV to target
+
+- Usage :
+
+  . hdmitx module parameters used with insmod :
+    > verbose: Make the driver verbose
+    > major: The major number of the device mapper
+  . hdmicec module parameters used with insmod :
+    > verbose: Make the driver verbose
+    > major: The major number of the device mapper
+    > device: Device type can be 0:tv, 1:rec 3:tuner 4:mediaplayer, 5:audio
+    > addr: Physical address (until EDID received)
+  . modules handles automaticaly HPD, EDID and following CEC messaging :
+    device connectivity and addressing, routing, standby, OSD name,
+    vendor name features.
+  . tda_demo test application show how to take control of the two modules
+    from userland and catch CEC messages
+    BUT HDMI MODULES CAN RUN WITHOUT IT
+  . HDCP feature is only supported if nwolc module is installed, you can
+    add it or remove it dynamically using insmod nwolc.ko and rmmod nwolk.
+
+- FAQ :
+
+  . "this->driver.i2c_client not allocated" :
+    1) Declare your I2C bus usage in arch/arm/mach-omap2/board-zoom2.c as follow :
+    | static struct i2c_board_info __initdata zoom2_i2c_bus3_info[] = {
+	|        {I2C_BOARD_INFO(TX_NAME,  TDA998X_I2C_SLAVEADDRESS),},
+	|        {I2C_BOARD_INFO(CEC_NAME,  TDA99XCEC_I2C_SLAVEADDRESS),},
+    | };
+    2) Check the TDA target in Makefile :  for example TDA_TX := TDA9984
+
+  . "Video format and plan are strange..." :
+    Check tda.setio.videoout/in in hdmi_tx_init() function of tda998x.c
+
+  . "The resolution is not the one I want" :
+    Update or create your own omap_video_timings structure and change
+    the video resolution of this->tda.setio.video_out.format in hdmi_tx_init()
+
+  . I want "720p@60Hz" :
+    1- Line 860: Uncomment> /*    this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_04_1280x720p_60Hz; */
+    2- Line 862: Comment> this->tda.setio.video_out.format = TMDL_HDMITX_VFMT_02_720x480p_60Hz;
+    3- Line 1051: Replace> video_720x480at60Hz_panel_timings with video_1280x720at60Hz_panel_timings
+
+  . "Where can I find all video format definition ?":
+    in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
+
+  . "Where can I find all audio format definition ?":
+    in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
+
+  . "Where can I find all HDMI types definition ?":
+    in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
+
+  . "Where can I find all power management types definition ?":
+    in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Types.h
+
+  . "Where can I find all HDMI Tx API definition ?":
+    in hdmi/comps/tmdlHdmiTx/inc/tmdlHdmiTx_Functions.h
+
+  . "Where can I find all HDMI CEC types definition ?":
+    in hdmi/comps/tmdlHdmiCec/inc/tmdlHdmiCec_Types.h
+
+  . "Where can I find all HDMI CEC API definition ?":
+    in hdmi/comps/tmdlHdmiCec/inc/tmdlHdmiCec_Functions.h
+
+  . "I would like to get debug message" :
+    Install the module with debug messages > insmod hdmitx.ko verbose=1 
+
+  . "I would like to see the EDID of the TV" :
+    Install the module with debug messages > insmod hdmitx.ko verbose=1 
+
+
+  . "On the TV display some pixel are flickering" :
+    Check the OMAP DSS setup and update the dssdev->panel.config parameters
+
+  . "CEC send Samsung vendor ID" :
+    Yes, otherwise you cannot use Samsung devices... replace is by your own
+
+  . "I don't use OMAP"
+    This module contains an OMAP Display SubSystem plugin that automatically
+    drives video output of OMAP (video input of TDA). If you don't have OMAP
+    remove the ANDROID_DSS (or add your PLATFORM flag in Makefile) and do
+    the video bus configuration at your convience. Anyhow, any other usefull 
+    plugin is welcome... So please feedback ;)
+
+  . "How to install HDMI module ?"
+    See installation chapter above.
+
+  . "HDCP is not supported"
+    Ask NXP to deliver you the proprietary HDCP module
+
+  . "HDCP module does not work"
+    Ask NXP to provide you your customer seed number...
+
+  . "How can I control the HDMI with my apps ?"
+    Use open("/dev/hdmitx") to get access to HdmiTx module.
+    Then use ioctl as described in tda998x_ioctl.h.
+
+  . "How can I control CEC with my apps ?"
+    Use open("/dev/hdmicec") to get access to HdmiCec module.
+    Then use ioctl as described in tda998x_ioctl.h.
+
+  . "How can my application get the HDMI event ?"
+    Create a dedicated incoming event thread in your apps and use ioctl WAIT_EVENT
+
+  . "Is is mandatory to create an incoming event thread in my apps ?"
+    No if you don't care.
+
+  . "Did I need to create some apps to make HDMI running ?"
+    No, you can modify hdmi_tx_init according to your needs and install the
+    modules in your init.rc. Hdmi will run automatically.
+
+- Restriction :
+
+  . Remove IRQ flag in Makefile for timer based polling
+  . Add ZOOMII_PATCH to reverse clock edge in ZOOMII
+  . add TWL4030_HACK to get keypad handle and inject CEC::USER_CONTROL events
+  . omap_dss_driver might not be supported by kernel, then hdmi_enable
+    and hdmi_disable should be triggered by any other kernel means or
+    replaced by direct call from application using:
+    -->  ioctl(my_fd,TDA_IOCTL_SET_POWER,[tmPowerOn|tmPowerStandby]);
+  . HDCP can not be switch off dynamically with TDA_IOCTL_SET_HDCP but
+    removing nwolc.ko module
+
+- License :
+
+  . hdmitx and hdmicec modules are free software; you can redistribute
+    it and/or modify it under the terms of the GNU General Public License
+    as published by the Free Software Foundation, using version 2 of the License.
+    These modules are distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
+    for more details.
+  . nwolc module source code and any compilation or derivative thereof is
+    the proprietary information of NXP N.V. and is confidential in nature.
+    Under no circumstances is this software to be exposed to or placed under
+    an Open Source License of any type without the expressed written permission
+    of NXP N.V.
+
+- DV :
+
+  . How to create a DV :
+    -> update tda998xversion.h and set PATCH_LEVEL to 0
+    -> update release_note.txt
+    $>cd driver/video/hdmi
+    $>make -f MakeModules clean
+    $>cd ..
+    $>tar cvfj $DV_FOLDER/linux-hdmi-nxp-modules.vXYZ.tar.cvfj hdmi
+
+-----------------------------------
+
+- Feedback : andre.lepine@nxp.com -
+
+-----------------------------------
+
diff --git a/drivers/video/hdmi/tda998x.c b/drivers/video/hdmi/tda998x.c
new file mode 100644
index 0000000..f2c531c
--- /dev/null
+++ b/drivers/video/hdmi/tda998x.c
@@ -0,0 +1,2481 @@
+/*****************************************************************************/
+/* Copyright (c) 2009 NXP Semiconductors BV                                  */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#define _tx_c_
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+/*#include <mach/gpio.h>*/
+#include <asm/gpio.h>
+/*#include <mach/display.h> */
+
+/* HDMI DevLib */
+#include "tmNxCompId.h"
+#include "tmdlHdmiTx_Types.h"
+#include "tmdlHdmiTx_Functions.h"
+
+/* local */
+#include "tda998x_version.h"
+#include "tda998x.h"
+#include "tda998x_ioctl.h"
+
+#ifdef ANDROID_DSS
+/* DSS hack */
+#include <../omap2/dss/dss.h>
+#endif
+
+/*
+ *
+ * DEFINITION
+ * ----------
+ * LEVEL 0
+ *
+ * */
+
+/*
+ *  Global
+ * */
+
+tda_instance our_instance;
+static struct cdev our_cdev, *this_cdev = &our_cdev;
+#ifdef ANDROID_DSS
+static struct omap_video_timings video_640x480at60hz_panel_timings = {
+	.x_res          = 640,
+	.y_res          = 480,
+	.pixel_clock    = 25175,
+	.hfp            = 16,
+	.hsw            = 96,
+	.hbp            = 48,
+	.vfp            = 10,
+	.vsw            = 2,
+	.vbp            = 33,
+};
+static struct omap_video_timings video_640x480at72hz_panel_timings = {
+	.x_res          = 640,
+	.y_res          = 480,
+	.pixel_clock    = 31500,
+	.hfp            = 24,
+	.hsw            = 40,
+	.hbp            = 128,
+	.vfp            = 9,
+	.vsw            = 3,
+	.vbp            = 28,
+};
+static struct omap_video_timings video_720x480at60hz_panel_timings = {
+	.x_res          = 720,
+	.y_res          = 480,
+	.pixel_clock    = 27027,
+	.hfp            = 16,
+	.hbp            = 60,
+	.hsw            = 62,
+	.vfp            = 9,
+	.vbp            = 30,
+	.vsw            = 6,
+};
+static struct omap_video_timings video_1280x720at50hz_panel_timings = {
+	.x_res          = 1280,
+	.y_res          = 720,
+	.pixel_clock    = 74250,
+#ifdef ZOOMII_PATCH
+	.hfp            = 400,
+	.hbp            = 260,
+#else
+	.hfp            = 440,
+	.hbp            = 220,
+#endif
+	.hsw            = 40,
+	.vfp            = 5,
+	.vbp            = 20,
+	.vsw            = 5,
+};
+static struct omap_video_timings video_1280x720at60hz_panel_timings = {
+	.x_res          = 1280,
+	.y_res          = 720,
+	.pixel_clock    = 74250,
+#ifdef ZOOMII_PATCH
+	.hfp            = 70,
+	.hbp            = 260,
+#else
+	.hfp            = 110,
+	.hbp            = 220,
+#endif
+	.hsw            = 40,
+	.vfp            = 5,
+	.vbp            = 20,
+	.vsw            = 5,
+};
+static struct omap_video_timings video_1920x1080at50hz_panel_timings = {
+	.x_res          = 1920,
+	.y_res          = 1080,
+	.pixel_clock    = 148500, /* 2640 x 1125 x 50 /2 */
+#ifdef ZOOMII_PATCH
+	.hfp            = 488,
+	.hbp            = 188,
+#else
+	.hfp            = 528,
+	.hbp            = 148,
+#endif
+	.hsw            = 44,
+	.vfp            = 4,
+	.vbp            = 36,
+	.vsw            = 5,
+};
+static struct omap_video_timings video_800x480at60hz_panel_timings = {
+	/*    .x_res = 800 /\* 1280 *\/, */
+	/*    .y_res = 480 /\* 720 *\/, */
+	/*    .pixel_clock = 21800 /\* 21800 23800 25700 *\/, */
+	.x_res = 800,
+	.y_res = 480,
+	.pixel_clock = 21800,
+	.hfp = 6,
+	.hsw = 1,
+	.hbp = 4,
+	.vfp = 3,
+	.vsw = 1,
+	.vbp = 4,
+};
+
+struct omap_dss_device *sysdss;
+#endif
+
+/* #define HDCP_TEST 1 */
+#ifdef HDCP_TEST
+/* TEST */
+int test = 0;
+#endif
+
+/*
+ *  Module params
+ * */
+
+static int param_verbose = 0, param_major = 0, param_minor = 0;
+module_param_named(verbose, param_verbose, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(verbose, "make the driver verbose");
+module_param_named(major, param_major, int, S_IRUGO);
+MODULE_PARM_DESC(major, "the major number of the device mapper");
+
+/*
+ *
+ * TOOLBOX
+ * -------
+ * LEVEL 1
+ *
+ * - i2c read/write
+ * - chip Id check
+ * - i2c client info
+ *
+ * */
+
+/*
+ *  no mknod nor busybox, so patch it
+ * */
+/* static int create_dev(char *name, dev_t dev) */
+/* { */
+/*    sys_unlink(name); */
+/*    return sys_mknod((const char __user *) name, S_IFCHR|0666 /\* S_IFCHR | S_IRUSR | S_IWUSR *\/, new_encode_dev(dev)); */
+/* } */
+
+/*
+ *  Get main and unique I2C Client driver handle
+ * */
+struct i2c_client *get_this_i2c_client(void) {
+	tda_instance *this = &our_instance;
+	return this->driver.i2c_client;
+}
+
+/*
+ * error handling
+ * */
+char *hdmi_tx_err_string(int err)
+{
+	switch(err & 0x0FFF) {
+	case ERR_COMPATIBILITY: {
+		return "SW interface compatibility";
+		break;
+	}
+	case ERR_MAJOR_VERSION: {
+		return "SW major version error";
+		break;
+	}
+	case ERR_COMP_VERSION: {
+		return "SW component version error";
+		break;
+	}
+	case ERR_BAD_UNIT_NUMBER: {
+		return "invalid device unit number";
+		break;
+	}
+	case ERR_BAD_INSTANCE: {
+		return "bad input instance value  ";
+		break;
+	}
+	case ERR_BAD_HANDLE: {
+		return "bad input handle";
+		break;
+	}
+	case ERR_BAD_PARAMETER: {
+		return "invalid input parameter";
+		break;
+	}
+	case ERR_NO_RESOURCES: {
+		return "resource is not available ";
+		break;
+	}
+	case ERR_RESOURCE_OWNED: {
+		return "resource is already in use";
+		break;
+	}
+	case ERR_RESOURCE_NOT_OWNED: {
+		return "caller does not own resource";
+		break;
+	}
+	case ERR_INCONSISTENT_PARAMS: {
+		return "inconsistent input params";
+		break;
+	}
+	case ERR_NOT_INITIALIZED: {
+		return "component is not initialised";
+		break;
+	}
+	case ERR_NOT_SUPPORTED: {
+		return "function is not supported";
+		break;
+	}
+	case ERR_INIT_FAILED: {
+		return "initialization failed";
+		break;
+	}
+	case ERR_BUSY: {
+		return "component is busy";
+		break;
+	}
+	case ERR_DLHDMITX_I2C_READ: {
+		return "read error";
+		break;
+	}
+	case ERR_DLHDMITX_I2C_WRITE: {
+		return "write error";
+		break;
+	}
+	case ERR_FULL: {
+		return "queue is full";
+		break;
+	}
+	case ERR_NOT_STARTED: {
+		return "function is not started";
+		break;
+	}
+	case ERR_ALREADY_STARTED: {
+		return "function is already starte";
+		break;
+	}
+	case ERR_ASSERTION: {
+		return "assertion failure";
+		break;
+	}
+	case ERR_INVALID_STATE: {
+		return "invalid state for function";
+		break;
+	}
+	case ERR_OPERATION_NOT_PERMITTED: {
+		return "corresponds to posix EPERM";
+		break;
+	}
+	case ERR_DLHDMITX_RESOLUTION_UNKNOWN: {
+		return "bad format";
+		break;
+	}
+	case 0: {
+		return "OK";
+		break;
+	}
+	default : {
+		printk(KERN_INFO "(err:%x) ", err);
+		return "unknown";
+		break;
+	}
+	}
+}
+
+static char *tda_spy_event(int event)
+{
+	switch(event) {
+	case DL_HDMITX_HDCP_ACTIVE: {
+		return "HDCP active";
+		break;
+	}
+	case DL_HDMITX_HDCP_INACTIVE: {
+		return "HDCP inactive";
+		break;
+	}
+	case DL_HDMITX_HPD_ACTIVE: {
+		return "HPD active";
+		break;
+	}
+	case DL_HDMITX_HPD_INACTIVE: {
+		return "HPD inactive";
+		break;
+	}
+	case DL_HDMITX_RX_KEYS_RECEIVED: {
+		return "rx keys received";
+		break;
+	}
+	case DL_HDMITX_RX_DEVICE_ACTIVE: {
+		return "rx device active";
+		break;
+	}
+	case DL_HDMITX_RX_DEVICE_INACTIVE: {
+		return "rx device inactive";
+		break;
+	}
+	case DL_HDMITX_EDID_RECEIVED: {
+		return "EDID received";
+		break;
+	}
+	case DL_HDMITX_VS_RPT_RECEIVED: {
+		return "VS interrupt has been received";
+		break;
+	}
+	/*       case DL_HDMITX_B_STATUS: {return "TX received BStatus";break;} */
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+	case DL_HDMITX_DEBUG_EVENT_1: {
+		return "DEBUG_EVENT_1";
+		break;
+	}
+#endif
+	default : {
+		return "unkonwn event";
+		break;
+	}
+	}
+}
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+static char *tda_spy_hsdc_fail_status(int fail)
+{
+	switch(fail) {
+	case DL_HDMITX_HDCP_OK: {
+		return "ok";
+		break;
+	}
+	case  DL_HDMITX_HDCP_BKSV_RCV_FAIL: {
+		return "source does not receive sink bksv ";
+		break;
+	}
+	case DL_HDMITX_HDCP_BKSV_CHECK_FAIL: {
+		return "bksv does not contain 20 zeros and 20 ones";
+		break;
+	}
+	case DL_HDMITX_HDCP_BCAPS_RCV_FAIL: {
+		return "source does not receive sink bcaps";
+		break;
+	}
+	case DL_HDMITX_HDCP_AKSV_SEND_FAIL: {
+		return "source does not send aksv";
+		break;
+	}
+	case DL_HDMITX_HDCP_R0_RCV_FAIL: {
+		return "source does not receive R'0";
+		break;
+	}
+	case DL_HDMITX_HDCP_R0_CHECK_FAIL: {
+		return "R0 = R'0 check fail";
+		break;
+	}
+	case DL_HDMITX_HDCP_BKSV_NOT_SECURE: {
+		return "bksv not secure";
+		break;
+	}
+	case DL_HDMITX_HDCP_RI_RCV_FAIL: {
+		return "source does not receive R'i";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_RI_RCV_FAIL: {
+		return "source does not receive R'i repeater mode";
+		break;
+	}
+	case DL_HDMITX_HDCP_RI_CHECK_FAIL: {
+		return "RI = R'I check fail";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_RI_CHECK_FAIL: {
+		return "RI = R'I check fail repeater mode";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_BCAPS_RCV_FAIL: {
+		return "source does not receive sink bcaps repeater mode";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_BCAPS_READY_TIMEOUT: {
+		return "bcaps ready timeout";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_V_RCV_FAIL: {
+		return "source does not receive V";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_BSTATUS_RCV_FAIL: {
+		return "source does not receive BSTATUS repeater mode";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_KSVLIST_RCV_FAIL: {
+		return "source does not receive ksv list in repeater mode";
+		break;
+	}
+	case DL_HDMITX_HDCP_RPT_KSVLIST_NOT_SECURE: {
+		return "ksvlist not secure";
+		break;
+	}
+	default: {
+		return "";
+		break;
+	}
+	}
+}
+
+static char *tda_spy_hdcp_status(int status)
+{
+	switch(status) {
+	case DL_HDMITX_HDCP_CHECK_NOT_STARTED: {
+		return "check not started";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_IN_PROGRESS: {
+		return "no failures, more to do";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_PASS: {
+		return "final check has passed";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_FAIL_FIRST: {
+		return "first check failure code\n_driver not AUTHENTICATED";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_T0: {
+		return "A T0 interrupt occurred";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_RI: {
+		return "device RI changed";
+		break;
+	}
+	case DL_HDMITX_HDCP_CHECK_FAIL_DEVICE_FSM: {
+		return "device FSM not 10h";
+		break;
+	}
+	default : {
+		return "unknown hdcp status";
+		break;
+	}
+	}
+
+}
+#endif
+
+static char *tda_spy_sink(int sink)
+{
+	switch(sink) {
+	case DL_HDMITX_SINK_DVI: {
+		return "DVI";
+		break;
+	}
+	case DL_HDMITX_SINK_HDMI: {
+		return "HDMI";
+		break;
+	}
+	case DL_HDMITX_SINK_EDID: {
+		return "as currently defined in EDID";
+		break;
+	}
+	default : {
+		return "unkonwn sink";
+		break;
+	}
+	}
+}
+
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+static char *tda_spy_aspect_ratio(int ar)
+{
+	switch(ar) {
+	case DL_HDMITX_P_ASPECT_RATIO_UNDEFINED: {
+		return "undefined picture aspect rati";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_6_5: {
+		return "6:5 picture aspect ratio (PAR";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_5_4: {
+		return "5:4 PA";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_4_3: {
+		return "4:3 PA";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_16_10: {
+		return "16:10 PA";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_5_3: {
+		return "5:3 PA";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_16_9: {
+		return "16:9 PA";
+		break;
+	}
+	case DL_HDMITX_P_ASPECT_RATIO_9_5: {
+		return "9:5 PA";
+		break;
+	}
+	default : {
+		return "unknown aspect ratio";
+		break;
+	}
+	}
+}
+
+#if 0 /* no more used */
+static char *tda_spy_edid_status(int status)
+{
+	switch(status) {
+	case DL_HDMITX_EDID_READ: {
+		return "all blocks read";
+		break;
+	}
+	case DL_HDMITX_EDID_READ_INCOMPLETE: {
+		return "all blocks read OK but buffer too small to return all of the";
+		break;
+	}
+	case DL_HDMITX_EDID_ERROR_CHK_BLOCK_0: {
+		return "block 0 checksum erro";
+		break;
+	}
+	case DL_HDMITX_EDID_ERROR_CHK: {
+		return "block 0 OK, checksum error in one or more other block";
+		break;
+	}
+	case DL_HDMITX_EDID_NOT_READ: {
+		return "EDID not read";
+		break;
+	}
+	case DL_HDMITX_EDID_STATUS_INVALID: {
+		return "invalid ";
+		break;
+	}
+	default : {
+		return "unknown edid status";
+		break;
+	}
+	}
+}
+#endif
+
+static char *tda_spy_vfmt(int fmt)
+{
+	switch(fmt) {
+	case ERR_DLHDMITX_COMPATIBILITY: {
+		return "SW interface compatibility";
+		break;
+	}
+	case ERR_DLHDMITX_MAJOR_VERSION: {
+		return "SW major version error";
+		break;
+	}
+
+	case DL_HDMITX_VFMT_NULL: {
+		return "not a valid format...";
+		break;
+	}
+	case dl_hdmitx_vfmt_01_640x480p_60hz: {
+		return "format 01 640  x 480p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_02_720x480p_60hz: {
+		return "format 02 720  x 480p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_03_720x480p_60hz: {
+		return "format 03 720  x 480p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_04_1280x720p_60hz: {
+		return "format 04 1280 x 720p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_05_1920x1080i_60hz: {
+		return "format 05 1920 x 1080i 60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_06_720x480i_60hz: {
+		return "format 06 720  x 480i  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_07_720x480i_60hz: {
+		return "format 07 720  x 480i  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_08_720x240p_60hz: {
+		return "format 08 720  x 240p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_09_720x240p_60hz: {
+		return "format 09 720  x 240p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_10_720x480i_60hz: {
+		return "format 10 720  x 480i  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_11_720x480i_60hz: {
+		return "format 11 720  x 480i  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_12_720x240p_60hz: {
+		return "format 12 720  x 240p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_13_720x240p_60hz: {
+		return "format 13 720  x 240p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_14_1440x480p_60hz: {
+		return "format 14 1440 x 480p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_15_1440x480p_60hz: {
+		return "format 15 1440 x 480p  60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_16_1920x1080p_60hz: {
+		return "format 16 1920 x 1080p 60hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_17_720x576p_50hz: {
+		return "format 17 720  x 576p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_18_720x576p_50hz: {
+		return "format 18 720  x 576p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_19_1280x720p_50hz: {
+		return "format 19 1280 x 720p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_20_1920x1080i_50hz: {
+		return "format 20 1920 x 1080i 50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_21_720x576i_50hz: {
+		return "format 21 720  x 576i  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_22_720x576i_50hz: {
+		return "format 22 720  x 576i  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_23_720x288p_50hz: {
+		return "format 23 720  x 288p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_24_720x288p_50hz: {
+		return "format 24 720  x 288p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_25_720x576i_50hz: {
+		return "format 25 720  x 576i  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_26_720x576i_50hz: {
+		return "format 26 720  x 576i  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_27_720x288p_50hz: {
+		return "format 27 720  x 288p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_28_720x288p_50hz: {
+		return "format 28 720  x 288p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_29_1440x576p_50hz: {
+		return "format 29 1440 x 576p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_30_1440x576p_50hz: {
+		return "format 30 1440 x 576p  50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_31_1920x1080p_50hz: {
+		return "format 31 1920 x 1080p 50hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_32_1920x1080p_24hz: {
+		return "format 32 1920 x 1080p 24hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_33_1920x1080p_25hz: {
+		return "format 33 1920 x 1080p 25hz";
+		break;
+	}
+	case dl_hdmitx_vfmt_34_1920x1080p_30hz: {
+		return "format 34 1920 x 1080p 30hz";
+		break;
+	}
+	case DL_HDMITX_VFMT_TV_NUM: {
+		return "number of TV formats & null";
+		break;
+	}
+	case DL_HDMITX_VFMT_PC_MIN: {
+		return "lowest valid PC format";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_800x600p_60hz: {
+		return "PC format 129";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1152x960p_60hz: {
+		return "PC format 130";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x768p_60hz: {
+		return "PC format 131";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1280x768p_60hz: {
+		return "PC format 132";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1280x1024p_60hz: {
+		return "PC format 133";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1360x768p_60hz: {
+		return "PC format 134";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1400x1050p_60hz: {
+		return "PC format 135";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1600x1200p_60hz: {
+		return "PC format 136";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x768p_70hz: {
+		return "PC format 137";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_640x480p_72hz: {
+		return "PC format 138";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_800x600p_72hz: {
+		return "PC format 139";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_640x480p_75hz: {
+		return "PC format 140";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x768p_75hz: {
+		return "PC format 141";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_800x600p_75hz: {
+		return "PC format 142";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x864p_75hz: {
+		return "PC format 143";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1280x1024p_75hz: {
+		return "PC format 144";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_640x350p_85hz: {
+		return "PC format 145";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_640x400p_85hz: {
+		return "PC format 146";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_720x400p_85hz: {
+		return "PC format 147";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_640x480p_85hz: {
+		return "PC format 148";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_800x600p_85hz: {
+		return "PC format 149";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x768p_85hz: {
+		return "PC format 150";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1152x864p_85hz: {
+		return "PC format 151";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1280x960p_85hz: {
+		return "PC format 152";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1280x1024p_85hz: {
+		return "PC format 153";
+		break;
+	}
+	case dl_hdmitx_vfmt_pc_1024x768i_87hz: {
+		return "PC format 154";
+		break;
+	}
+	default : {
+		return "unknown video format";
+		break;
+	}
+	}
+}
+#endif
+
+static char *tda_ioctl(int io)
+{
+	switch(io) {
+	case TDA_VERBOSE_ON_CMD: {
+		return "TDA_VERBOSE_ON_CMD";
+		break;
+	}
+	case TDA_VERBOSE_OFF_CMD: {
+		return "TDA_VERBOSE_OFF_CMD";
+		break;
+	}
+	case TDA_BYEBYE_CMD: {
+		return "TDA_BYEBYE_CMD";
+		break;
+	}
+	case TDA_GET_SW_VERSION_CMD: {
+		return "TDA_GET_SW_VERSION_CMD";
+		break;
+	}
+	case TDA_SET_POWER_CMD: {
+		return "TDA_SET_POWER_CMD";
+		break;
+	}
+	case TDA_GET_POWER_CMD: {
+		return "TDA_GET_POWER_CMD";
+		break;
+	}
+	case TDA_SETUP_CMD: {
+		return "TDA_SETUP_CMD";
+		break;
+	}
+	case TDA_GET_SETUP_CMD: {
+		return "TDA_GET_SETUP_CMD";
+		break;
+	}
+	case TDA_WAIT_EVENT_CMD: {
+		return "TDA_WAIT_EVENT_CMD";
+		break;
+	}
+	case TDA_ENABLE_EVENT_CMD: {
+		return "TDA_ENABLE_EVENT_CMD";
+		break;
+	}
+	case TDA_DISABLE_EVENT_CMD: {
+		return "TDA_DISABLE_EVENT_CMD";
+		break;
+	}
+	case TDA_GET_VIDEO_SPEC_CMD: {
+		return "TDA_GET_VIDEO_SPEC_CMD";
+		break;
+	}
+	case TDA_SET_INPUT_OUTPUT_CMD: {
+		return "TDA_SET_INPUT_OUTPUT_CMD";
+		break;
+	}
+	case TDA_SET_AUDIO_INPUT_CMD: {
+		return "TDA_SET_AUDIO_INPUT_CMD";
+		break;
+	}
+	case TDA_SET_VIDEO_INFOFRAME_CMD: {
+		return "TDA_SET_VIDEO_INFOFRAME_CMD";
+		break;
+	}
+	case TDA_SET_AUDIO_INFOFRAME_CMD: {
+		return "TDA_SET_AUDIO_INFOFRAME_CMD";
+		break;
+	}
+	case TDA_SET_ACP_CMD: {
+		return "TDA_SET_ACP_CMD";
+		break;
+	}
+	case TDA_SET_GCP_CMD: {
+		return "TDA_SET_GCP_CMD";
+		break;
+	}
+	case TDA_SET_ISRC1_CMD: {
+		return "TDA_SET_ISRC1_CMD";
+		break;
+	}
+	case TDA_SET_ISRC2_CMD: {
+		return "TDA_SET_ISRC2_CMD";
+		break;
+	}
+	case TDA_SET_MPS_INFOFRAME_CMD: {
+		return "TDA_SET_MPS_INFOFRAME_CMD";
+		break;
+	}
+	case TDA_SET_SPD_INFOFRAME_CMD: {
+		return "TDA_SET_SPD_INFOFRAME_CMD";
+		break;
+	}
+	case TDA_SET_VS_INFOFRAME_CMD: {
+		return "TDA_SET_VS_INFOFRAME_CMD";
+		break;
+	}
+	case TDA_SET_AUDIO_MUTE_CMD: {
+		return "TDA_SET_AUDIO_MUTE_CMD";
+		break;
+	}
+	case TDA_RESET_AUDIO_CTS_CMD: {
+		return "TDA_RESET_AUDIO_CTS_CMD";
+		break;
+	}
+	case TDA_GET_EDID_STATUS_CMD: {
+		return "TDA_GET_EDID_STATUS_CMD";
+		break;
+	}
+	case TDA_GET_EDID_AUDIO_CAPS_CMD: {
+		return "TDA_GET_EDID_AUDIO_CAPS_CMD";
+		break;
+	}
+	case TDA_GET_EDID_VIDEO_CAPS_CMD: {
+		return "TDA_GET_EDID_VIDEO_CAPS_CMD";
+		break;
+	}
+	case TDA_GET_EDID_VIDEO_PREF_CMD: {
+		return "TDA_GET_EDID_VIDEO_PREF_CMD";
+		break;
+	}
+	case TDA_GET_EDID_SINK_TYPE_CMD: {
+		return "TDA_GET_EDID_SINK_TYPE_CMD";
+		break;
+	}
+	case TDA_GET_EDID_SOURCE_ADDRESS_CMD: {
+		return "TDA_GET_EDID_SOURCE_ADDRESS_CMD";
+		break;
+	}
+	case TDA_SET_GAMMUT_CMD: {
+		return "TDA_SET_GAMMUT_CMD";
+		break;
+	}
+	case TDA_GET_EDID_DTD_CMD: {
+		return "TDA_GET_EDID_DTD_CMD";
+		break;
+	}
+	case TDA_GET_EDID_MD_CMD: {
+		return "TDA_GET_EDID_MD_CMD";
+		break;
+	}
+	case TDA_GET_EDID_TV_ASPECT_RATIO_CMD: {
+		return "TDA_GET_EDID_TV_ASPECT_RATIO_CMD";
+		break;
+	}
+	case TDA_GET_EDID_LATENCY_CMD: {
+		return "TDA_GET_EDID_LATENCY_CMD";
+		break;
+	}
+	default : {
+		return "unknown";
+		break;
+	}
+	}
+
+}
+
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+/*
+ *
+ * */
+static int tda_spy(int verbose)
+{
+	tda_instance *this = &our_instance;
+	int i, err = 0;
+
+	if(!verbose) {
+		return err;
+	}
+
+	printk(KERN_INFO "\n<edid video caps>\n");
+	this->tda.edid_video_caps.max = EXAMPLE_MAX_SVD;
+	TRY(tx_get_edid_video_caps(this->tda.instance,              \
+	                           this->tda.edid_video_caps.desc, \
+	                           this->tda.edid_video_caps.max,      \
+	                           &this->tda.edid_video_caps.written, \
+	                           &this->tda.edid_video_caps.flags));
+	printk(KERN_INFO "written:%d\n", this->tda.edid_video_caps.written);
+	printk(KERN_INFO "flags:0X%x\n", this->tda.edid_video_caps.flags);
+	if(this->tda.edid_video_caps.written > this->tda.edid_video_caps.max) {
+		printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
+		       this->tda.edid_video_caps.written,                     \
+		       this->tda.edid_video_caps.max);
+		this->tda.edid_video_caps.written = this->tda.edid_video_caps.max;
+	}
+	for(i = 0; i < this->tda.edid_video_caps.written; i++) {
+		printk(KERN_INFO "video_format:%s\n", tda_spy_vfmt(this->tda.edid_video_caps.desc[i].video_format));
+		printk(KERN_INFO "native_video_format:%s\n", (this->tda.edid_video_caps.desc[i].native_video_format ? "yes" : "no"));
+	}
+
+	printk(KERN_INFO "\n<edid video timings>\n");
+	TRY(tx_get_edid_video_preferred(this->tda.instance, \
+	                                &this->tda.edid_video_timings));
+	printk(KERN_INFO "pixel clock/10 000:%d\n", this->tda.edid_video_timings.pixel_clock);
+	printk(KERN_INFO "horizontal active pixels:%d\n", this->tda.edid_video_timings.h_active_pixels);
+	printk(KERN_INFO "horizontal blanking pixels:%d\n", this->tda.edid_video_timings.h_blank_pixels);
+	printk(KERN_INFO "vertical active lines:%d\n", this->tda.edid_video_timings.v_active_lines);
+	printk(KERN_INFO "vertical blanking lines:%d\n", this->tda.edid_video_timings.v_blank_lines);
+	printk(KERN_INFO "horizontal sync offset:%d\n", this->tda.edid_video_timings.h_sync_offset);
+	printk(KERN_INFO "horiz. sync pulse width:%d\n", this->tda.edid_video_timings.h_sync_width);
+	printk(KERN_INFO "vertical sync offset:%d\n", this->tda.edid_video_timings.v_sync_offset);
+	printk(KERN_INFO "vertical sync pulse width:%d\n", this->tda.edid_video_timings.v_sync_width);
+	printk(KERN_INFO "horizontal image size:%d\n", this->tda.edid_video_timings.h_image_size);
+	printk(KERN_INFO "vertical image size:%d\n", this->tda.edid_video_timings.v_image_size);
+	printk(KERN_INFO "horizontal border:%d\n", this->tda.edid_video_timings.h_border_pixels);
+	printk(KERN_INFO "vertical border:%d\n", this->tda.edid_video_timings.v_border_pixels);
+	printk(KERN_INFO "interlace/sync info:%x\n", this->tda.edid_video_timings.flags);
+
+	printk(KERN_INFO "\n<sink type>\n");
+	TRY(tx_get_edid_sink_type(this->tda.instance,    \
+	                          &this->tda.setio.sink));
+	printk(KERN_INFO "%s\n", tda_spy_sink(this->tda.setio.sink));
+	printk(KERN_INFO "\n<source address>\n");
+	TRY(tx_get_edid_source_address(this->tda.instance,   \
+	                               &this->tda.src_address));
+	printk(KERN_INFO "%x\n", this->tda.src_address);
+	printk(KERN_INFO "\n<detailled timing descriptors>\n");
+	this->tda.edid_dtd.max = EXAMPLE_MAX_SVD;
+	TRY(tx_get_edid_detailled_timing_descriptors(this->tda.instance,  \
+	        this->tda.edid_dtd.desc, \
+	        this->tda.edid_dtd.max, \
+	        &this->tda.edid_dtd.written));
+	printk(KERN_INFO "interlace/sync info:%x\n", this->tda.edid_dtd.desc[i].flags);
+	printk(KERN_INFO "written:%d\n", this->tda.edid_dtd.written);
+	if(this->tda.edid_dtd.written > this->tda.edid_dtd.max) {
+		printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
+		       this->tda.edid_dtd.written,                     \
+		       this->tda.edid_dtd.max);
+		this->tda.edid_dtd.written = this->tda.edid_dtd.max;
+	}
+	for(i = 0; i < this->tda.edid_dtd.written; i++) {
+		printk(KERN_INFO "pixel clock/10 000:%d\n", this->tda.edid_dtd.desc[i].pixel_clock);
+		printk(KERN_INFO "horizontal active pixels:%d\n", this->tda.edid_dtd.desc[i].h_active_pixels);
+		printk(KERN_INFO "horizontal blanking pixels:%d\n", this->tda.edid_dtd.desc[i].h_blank_pixels);
+		printk(KERN_INFO "vertical active lines:%d\n", this->tda.edid_dtd.desc[i].v_active_lines);
+		printk(KERN_INFO "vertical blanking lines:%d\n", this->tda.edid_dtd.desc[i].v_blank_lines);
+		printk(KERN_INFO "horizontal sync offset:%d\n", this->tda.edid_dtd.desc[i].h_sync_offset);
+		printk(KERN_INFO "horiz. sync pulse width:%d\n", this->tda.edid_dtd.desc[i].h_sync_width);
+		printk(KERN_INFO "vertical sync offset:%d\n", this->tda.edid_dtd.desc[i].v_sync_offset);
+		printk(KERN_INFO "vertical sync pulse width:%d\n", this->tda.edid_dtd.desc[i].v_sync_width);
+		printk(KERN_INFO "horizontal image size:%d\n", this->tda.edid_dtd.desc[i].h_image_size);
+		printk(KERN_INFO "vertical image size:%d\n", this->tda.edid_dtd.desc[i].v_image_size);
+		printk(KERN_INFO "horizontal border:%d\n", this->tda.edid_dtd.desc[i].h_border_pixels);
+		printk(KERN_INFO "vertical border:%d\n", this->tda.edid_dtd.desc[i].v_border_pixels);
+	}
+
+	printk(KERN_INFO "\n<monitor descriptors>\n");
+	this->tda.edid_md.max = EXAMPLE_MAX_SVD;
+	TRY(tx_get_edid_monitor_descriptors(this->tda.instance,  \
+	                                    this->tda.edid_md.desc1,    \
+	                                    this->tda.edid_md.desc2,    \
+	                                    this->tda.edid_md.other,    \
+	                                    this->tda.edid_md.max,       \
+	                                    &this->tda.edid_md.written));
+	printk(KERN_INFO "written:%d\n", this->tda.edid_md.written);
+	if(this->tda.edid_md.written > this->tda.edid_md.max) {
+		printk(KERN_ERR "get %d video caps but was waiting for %d\n", \
+		       this->tda.edid_md.written,                     \
+		       this->tda.edid_md.max);
+		this->tda.edid_md.written = this->tda.edid_md.max;
+	}
+	for(i = 0; i < this->tda.edid_md.written; i++) {
+		if(this->tda.edid_md.desc1[i].desc_record) {
+			this->tda.edid_md.desc1[i].monitor_name[EDID_MONITOR_DESCRIPTOR_SIZE] = 0;
+			printk(KERN_INFO "monitor name:%s\n", this->tda.edid_md.desc1[i].monitor_name);
+		}
+		if(this->tda.edid_md.desc1[i].desc_record) {
+			printk(KERN_INFO "min vertical rate in hz:%d\n", this->tda.edid_md.desc2[i].min_vertical_rate);
+			printk(KERN_INFO "max vertical rate in hz:%d\n", this->tda.edid_md.desc2[i].max_vertical_rate);
+			printk(KERN_INFO "min horizontal rate in hz:%d\n", this->tda.edid_md.desc2[i].min_horizontal_rate);
+			printk(KERN_INFO "max horizontal rate in hz:%d\n", this->tda.edid_md.desc2[i].max_horizontal_rate);
+			printk(KERN_INFO "max suuported pixel clock rate in mhz:%d\n", this->tda.edid_md.desc2[i].max_supported_pixel_clk);
+		}
+	}
+
+	printk(KERN_INFO "\n<TV picture ratio>\n");
+	TRY(tx_get_edid_tvpicture_ratio(this->tda.instance,  \
+	                                &this->tda.edid_tv_aspect_ratio));
+	printk(KERN_INFO "%s\n", tda_spy_aspect_ratio(this->tda.edid_tv_aspect_ratio));
+
+	printk(KERN_INFO "\n<latency info>\n");
+	TRY(tx_get_edid_latency_info(this->tda.instance, \
+	                             &this->tda.edid_latency));
+	if(this->tda.edid_latency.latency_available) {
+		printk(KERN_INFO "edid video:%d\n", this->tda.edid_latency.edidvideo_latency);
+		printk(KERN_INFO "edid audio:%d\n", this->tda.edid_latency.edidaudio_latency);
+	}
+	if(this->tda.edid_latency.ilatency_available) {
+		printk(KERN_INFO "edid ivideo:%d\n", this->tda.edid_latency.edid_ivideo_latency);
+		printk(KERN_INFO "edid iaudio:%d\n", this->tda.edid_latency.edid_iaudio_latency);
+	}
+TRY_DONE:
+	return err;
+}
+#endif
+
+/*
+ *
+ * PROCESSING
+ * ----------
+ * LEVEL 2
+ *
+ * -
+ *
+ * */
+
+/*
+ * On/Off HDCP
+ * */
+void hdcp_onoff(tda_instance *this)
+{
+
+	int err = 0;
+
+	/*    printk("DBG %s status:%d enable:%d\n",__func__,this->tda.hdcp_status,this->tda.hdcp_enable); */
+	if(this->tda.rx_device_active) {
+		if(this->tda.hot_plug_detect == DL_HDMITX_HOTPLUG_ACTIVE) {
+			if(this->tda.power == power_on) {
+				if(this->tda.src_address != 0xFFFF) {
+					/* ugly is bad */
+					if(this->tda.hdcp_status != DL_HDMITX_HDCP_CHECK_NUM) {
+						if(this->tda.hdcp_status == DL_HDMITX_HDCP_CHECK_NOT_STARTED) {
+							if(this->tda.hdcp_enable) {
+								TRY(tx_set_hdcp(this->tda.instance, true));
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+								TRY(tx_set_bscreen(this->tda.instance, DL_HDMITX_PATTERN_BLUE));
+#endif
+							}
+						} else if(this->tda.hdcp_status != DL_HDMITX_HDCP_CHECK_NOT_STARTED) {
+							if(!this->tda.hdcp_enable) {
+								TRY(tx_set_hdcp(this->tda.instance, false));
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+TRY_DONE:
+	(void)0;
+}
+
+/*
+ * Run video
+ * */
+void show_video(tda_instance *this)
+{
+
+	int err = 0;
+
+	if(this->tda.rx_device_active) {
+		if(this->tda.hot_plug_detect == DL_HDMITX_HOTPLUG_ACTIVE) {
+			if(this->tda.power == power_on) {
+				/*            if (this->tda.src_address != 0xFFFF) { */
+				TRY(tx_set_input_output(this->tda.instance,         \
+				                        this->tda.setio.video_in,   \
+				                        this->tda.setio.video_out,  \
+				                        this->tda.setio.audio_in,   \
+				                        this->tda.setio.sink));
+				hdcp_onoff(this);
+				/*            } */
+			}
+		}
+	}
+TRY_DONE:
+	(void)0;
+}
+
+/*
+ *  TDA interrupt polling
+ * */
+static void interrupt_polling(struct work_struct *dummy)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	/* Tx part */
+	TRY(tx_handle_interrupt(this->tda.instance));
+
+	/* CEC part */
+	if(this->driver.cec_callback) this->driver.cec_callback(dummy);
+
+	/* FIX : IT anti debounce */
+	TRY(tx_handle_interrupt(this->tda.instance));
+
+TRY_DONE:
+
+	/* setup next polling */
+#ifndef IRQ
+	mod_timer(&this->driver.no_irq_timer, jiffies + (CHECK_EVERY_XX_MS * HZ / 1000));
+#endif
+
+	(void)0;
+}
+
+/*
+ *  TDA interrupt polling
+ * */
+static void hdcp_check(struct work_struct *dummy)
+{
+	int err = 0;
+	tda_instance *this = &our_instance;
+	tx_hdcp_check_t hdcp_status;
+
+	down(&this->driver.sem);
+
+	/* ugly is bad */
+	if(this->tda.hdcp_status == DL_HDMITX_HDCP_CHECK_NUM) goto TRY_DONE;
+
+	TRY(tx_hdcp_check(this->tda.instance, HDCP_CHECK_EVERY_MS));
+	TRY(tx_get_hdcp_state(this->tda.instance, &hdcp_status));
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+	if(this->tda.hdcp_status != hdcp_status) {
+		LOG(KERN_INFO, "HDCP status:%s\n", tda_spy_hdcp_status(hdcp_status));
+		this->tda.hdcp_status = hdcp_status;
+	}
+#endif
+#ifdef HDCP_TEST
+	/* TEST */
+	if(test++ > 500) {
+		test = 0;
+		this->tda.hdcp_enable = 1 - this->tda.hdcp_enable;
+		printk("TEST hdcp:%d\n", this->tda.hdcp_enable);
+		hdcp_onoff(this);
+	}
+#endif
+
+TRY_DONE:
+
+	/* setup next polling */
+	mod_timer(&this->driver.hdcp_check, jiffies + (HDCP_CHECK_EVERY_MS * HZ / 1000));
+
+	up(&this->driver.sem);
+}
+
+void register_cec_interrupt(cec_callback_t fct)
+{
+	tda_instance *this = &our_instance;
+
+	this->driver.cec_callback = fct;
+}
+EXPORT_SYMBOL(register_cec_interrupt);
+
+void unregister_cec_interrupt(void)
+{
+	tda_instance *this = &our_instance;
+
+	this->driver.cec_callback = NULL;
+}
+EXPORT_SYMBOL(unregister_cec_interrupt);
+
+static DECLARE_WORK(wq_irq, interrupt_polling);
+void polling_timeout(unsigned long arg)
+{
+	/* derefered because ATOMIC context of timer does not support I2C_transfert */
+	schedule_work(&wq_irq);
+}
+
+static DECLARE_WORK(wq_hdcp, hdcp_check);
+void hdcp_check_timeout(unsigned long arg)
+{
+	/* derefered because ATOMIC context of timer does not support I2C_transfert */
+	schedule_work(&wq_hdcp);
+}
+
+#ifdef IRQ
+/*
+ *  TDA irq
+ * */
+static irqreturn_t tda_irq(int irq, void *_udc)
+{
+
+	/* do it now */
+	schedule_work(&wq_irq);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*
+ *  TDA callback
+ * */
+static void event_callback_tx(tx_event_t event)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+	unsigned short new_addr;
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+	tda_hdcp_fail hdcp_fail;
+#endif
+
+	this->tda.event = event;
+	if(DL_HDMITX_HDCP_INACTIVE != event) {
+		printk(KERN_INFO "hdmi %s\n", tda_spy_event(event));
+	}
+
+	switch(event) {
+	case DL_HDMITX_EDID_RECEIVED:
+		TRY(tx_get_edid_source_address(this->tda.instance,        \
+		                               &new_addr));
+		LOG(KERN_INFO, "phy.@:%x\n", new_addr);
+		/*       if (this->tda.src_address == new_addr) { */
+		/*          break; */
+		/*       } */
+		this->tda.src_address = new_addr;
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+		tda_spy(this->param.verbose > 1);
+#endif
+		/*
+		 *		   Customer may add stuff to analyse EDID (see tda_spy())
+		 *		   and select automatically some video/audio settings.
+		 *		   By default, let go on with next case and activate
+		 *		   default video/audio settings with txSetInputOutput()
+		 *		*/
+
+		TRY(tx_get_edid_sink_type(this->tda.instance,     \
+		                          &this->tda.setio.sink));
+		if(DL_HDMITX_SINK_HDMI != this->tda.setio.sink) {
+			printk(KERN_INFO "/!\\ CAUTION /!\\ sink is not HDMI but %s\n", tda_spy_sink(this->tda.setio.sink));
+		}
+
+		msleep(100);
+	case DL_HDMITX_RX_DEVICE_ACTIVE:
+		this->tda.rx_device_active = 1;
+		show_video(this);
+		break;
+	case DL_HDMITX_RX_DEVICE_INACTIVE:
+		this->tda.rx_device_active = 0;
+		break;
+	case DL_HDMITX_HPD_ACTIVE:
+		this->tda.hot_plug_detect = DL_HDMITX_HOTPLUG_ACTIVE;
+		show_video(this);
+		break;
+	case DL_HDMITX_HPD_INACTIVE:
+		this->tda.hot_plug_detect = DL_HDMITX_HOTPLUG_INACTIVE;
+		this->tda.src_address = 0xFFFF;
+		break;
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+	case DL_HDMITX_HDCP_INACTIVE:
+		tx_get_hdcp_fail_status(this->tda.instance, \
+		                        &hdcp_fail, \
+		                        &this->tda.hdcp_raw_status);
+		if(this->tda.hdcp_fail != hdcp_fail) {
+			if(this->tda.hdcp_fail) {
+				LOG(KERN_INFO, "%s (%d)\n", tda_spy_hsdc_fail_status(this->tda.hdcp_fail), this->tda.hdcp_raw_status);
+			}
+			this->tda.hdcp_fail = hdcp_fail;
+			tx_set_bscreen(this->tda.instance, DL_HDMITX_PATTERN_BLUE);
+		}
+		break;
+	case DL_HDMITX_RX_KEYS_RECEIVED:
+		tx_remove_bscreen(this->tda.instance);
+		break;
+#endif
+	default:
+		break;
+	}
+
+	this->driver.poll_done = true;
+	wake_up_interruptible(&this->driver.wait);
+
+TRY_DONE:
+	(void)0;
+}
+
+/*
+ *  hdmi Tx init
+ * */
+static int hdmi_tx_init(tda_instance *this)
+{
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	/*Initialize HDMI Transmiter*/
+	TRY(tx_open(&this->tda.instance));
+	/* Register the HDMI TX events callbacks */
+	TRY(tx_register_callbacks(this->tda.instance, (ptx_callback_t)event_callback_tx));
+
+	/* Size of the application EDID buffer */
+	this->tda.setup.edid_buffer_size = EDID_BLOCK_COUNT * EDID_BLOCK_SIZE;
+	/* Buffer to store the application EDID data */
+	this->tda.setup.p_edid_buffer = this->tda.raw_edid;
+	/* To Enable/disable repeater feature, nor relevant here */
+	this->tda.setup.repeater_enable = false;
+	/* To enable/disable simplayHD feature: blue screen when not authenticated */
+	this->tda.setup.simplay_hd = false;
+
+	/* Provides HDMI TX instance configuration */
+	TRY(tx_instance_setup(this->tda.instance, &this->tda.setup));
+	/* Get IC version */
+	TRY(tx_get_capabilities(&this->tda.capabilities));
+
+	/* Main settings */
+	this->tda.setio.video_out.mode = DL_HDMITX_VOUTMODE_RGB444;
+	this->tda.setio.video_out.color_depth = DL_HDMITX_COLORDEPTH_24;
+#ifdef TMFL_TDA19989
+	/* Use HDMI rules for DVI output */
+	this->tda.setio.video_out.dvi_vqr = DL_HDMITX_VQR_DEFAULT;
+#endif
+	/*    this->tda.setio.video_out.format = DL_HDMITX_VFMT_31_1920x1080p_50Hz; */
+	/*    this->tda.setio.video_out.format = DL_HDMITX_VFMT_PC_640x480p_60Hz; */
+	/*    this->tda.setio.video_out.format = DL_HDMITX_VFMT_PC_640x480p_72Hz; */
+	/*    this->tda.setio.video_out.format = DL_HDMITX_VFMT_04_1280x720p_60Hz; */
+	/*    this->tda.setio.video_out.format = DL_HDMITX_VFMT_19_1280x720p_50Hz; */
+
+	this->tda.setio.video_out.format = dl_hdmitx_vfmt_04_1280x720p_60hz;
+
+	this->tda.setio.video_in.mode = DL_HDMITX_VINMODE_RGB444;
+	/*    this->tda.setio.video_in.mode = DL_HDMITX_VINMODE_YUV422; */
+	this->tda.setio.video_in.format = this->tda.setio.video_out.format;
+	this->tda.setio.video_in.pixel_rate = DL_HDMITX_PIXRATE_SINGLE;
+	/* we use HS,VS as synchronisation source */
+	this->tda.setio.video_in.sync_source = 1;
+
+	this->tda.setio.audio_in.format = DL_HDMITX_AFMT_I2S;
+	this->tda.setio.audio_in.rate = DL_HDMITX_AFS_48K;
+	this->tda.setio.audio_in.i2s_format = DL_HDMITX_I2SFOR_PHILIPS_L;
+	this->tda.setio.audio_in.i2s_qualifier = DL_HDMITX_I2SQ_32BITS;
+	/* not relevant here */
+	this->tda.setio.audio_in.dst_rate = DL_HDMITX_DSTRATE_SINGLE;
+	/* audio channel allocation (Ref to CEA-861D p85) */
+	this->tda.setio.audio_in.channel_allocation = 0;
+
+	this->tda.setio.sink = DL_HDMITX_SINK_HDMI; /* skip edid reading */
+	/*    this->tda.src_address = 0x1000; /\* debug *\/ */
+	this->tda.src_address = NO_PHY_ADDR; /* it's unref */
+
+	/* EnableEvent, all by default */
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_HDCP_ACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_HDCP_INACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_HPD_ACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_HPD_INACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_RX_KEYS_RECEIVED));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_RX_DEVICE_ACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_RX_DEVICE_INACTIVE));
+	TRY(tx_enable_event(this->tda.instance, DL_HDMITX_EDID_RECEIVED));
+TRY_DONE:
+	return err;
+}
+
+void reset_hdmi(int hdcp_module)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	down(&this->driver.sem);
+
+	/* PATCH because of SetPowerState that calls SetHdcp that has just been removed by nwolc :( */
+	if(hdcp_module == 2) {
+		tx_set_hdcp(this->tda.instance, 0);
+		goto TRY_DONE;
+	}
+
+	TRY(tx_set_power_state(this->tda.instance, power_standby));
+	tx_close(this->tda.instance);
+	/* reset */
+	hdmi_tx_init(this);
+	/* recover previous power state */
+	TRY(tx_set_power_state(this->tda.instance, this->tda.power));
+	/* check if activ for timer */
+	tx_get_hpdstatus(this->tda.instance, &this->tda.hot_plug_detect);
+	show_video(this);
+
+	/* wake up or shut down hdcp checking */
+	if(hdcp_module) {
+		this->driver.hdcp_check.expires = jiffies + (HDCP_CHECK_EVERY_MS * HZ / 1000);
+		add_timer(&this->driver.hdcp_check);
+		/* ugly is bad ! */
+		this->tda.hdcp_status = DL_HDMITX_HDCP_CHECK_NOT_STARTED;
+		this->tda.hdcp_enable = 1; /* FIXME : fallback 4 HDCP on/off is ok */
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+		tx_set_bscreen(this->tda.instance, DL_HDMITX_PATTERN_BLUE);
+#endif
+	} else {
+		del_timer(&this->driver.hdcp_check);
+		this->tda.hdcp_status = DL_HDMITX_HDCP_CHECK_NUM; /* ugly is bad ! */
+		this->tda.hdcp_enable = 0; /* FIXME : fallback 4 HDCP on/off is ok */
+	}
+
+TRY_DONE:
+	up(&this->driver.sem);
+}
+EXPORT_SYMBOL(reset_hdmi);
+
+/*
+ *
+ * */
+short edid_phy_addr(void)
+{
+	tda_instance *this = &our_instance;
+
+	return this->tda.src_address;
+}
+EXPORT_SYMBOL(edid_phy_addr);
+
+/*
+ *
+ * */
+tda_power get_hdmi_status(void)
+{
+	tda_instance *this = &our_instance;
+
+	return this->tda.power;
+}
+EXPORT_SYMBOL(get_hdmi_status);
+
+/*
+ *
+ * */
+tda_power get_hpd_status(void)
+{
+	tda_instance *this = &our_instance;
+
+	return (this->tda.hot_plug_detect == DL_HDMITX_HOTPLUG_ACTIVE);
+}
+EXPORT_SYMBOL(get_hpd_status);
+
+/*
+ *
+ * */
+int edid_received(void)
+{
+	tda_instance *this = &our_instance;
+
+	return (this->tda.event == DL_HDMITX_EDID_RECEIVED);
+}
+EXPORT_SYMBOL(edid_received);
+
+/*
+ *
+ * */
+int hdmi_enable(void)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	down(&this->driver.sem);
+
+	this->tda.power = power_on;
+	TRY(tx_set_power_state(this->tda.instance, this->tda.power));
+	if(err == ERR_NO_RESOURCES) {
+		LOG(KERN_INFO, "busy...\n");
+		TRY(tx_handle_interrupt(this->tda.instance));
+		TRY(tx_handle_interrupt(this->tda.instance));
+		TRY(tx_handle_interrupt(this->tda.instance));
+	}
+	tx_get_hpdstatus(this->tda.instance, &this->tda.hot_plug_detect);
+	show_video(this); /* FIXME : mind usecases without HPD and RX_SEND... */
+
+TRY_DONE:
+	up(&this->driver.sem);
+	return err;
+}
+EXPORT_SYMBOL(hdmi_enable);
+
+/*
+ *
+ * */
+int hdmi_disable(int event_tracking)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	down(&this->driver.sem);
+
+	this->tda.power = (event_tracking ? power_suspend : power_standby);
+	TRY(tx_set_power_state(this->tda.instance, this->tda.power));
+
+TRY_DONE:
+	up(&this->driver.sem);
+	return err;
+}
+EXPORT_SYMBOL(hdmi_disable);
+
+/*
+ *
+ * ENTRY POINTS
+ * ------------
+ * LEVEL 3
+ *
+ * -
+ *
+ * */
+
+#ifdef ANDROID_DSS
+/*
+ *  DSS driver :: probe
+ * */
+static int hdmi_panel_probe(struct omap_dss_device *dssdev)
+{
+	tda_instance *this = &our_instance;
+
+	LOG(KERN_INFO, " called\n");
+
+	sysdss = dssdev;
+
+	/* 	OMAP_DSS_LCD_IVS		= 1<<0, */
+	/* 	OMAP_DSS_LCD_IHS		= 1<<1, */
+	/* 	OMAP_DSS_LCD_IPC		= 1<<2, */
+	/* 	OMAP_DSS_LCD_IEO		= 1<<3, */
+	/* 	OMAP_DSS_LCD_RF			= 1<<4, */
+	/* 	OMAP_DSS_LCD_ONOFF		= 1<<5, */
+	/* 	OMAP_DSS_LCD_TFT		= 1<<20, */
+
+	dssdev->panel.config = OMAP_DSS_LCD_ONOFF | OMAP_DSS_LCD_IPC |  \
+	                       OMAP_DSS_LCD_TFT | OMAP_DSS_LCD_IVS | OMAP_DSS_LCD_IHS;
+	dssdev->panel.timings = video_720x480at60hz_panel_timings;
+	(void)video_1280x720at60hz_panel_timings;
+	(void)video_720x480at60hz_panel_timings;
+	(void)video_1280x720at50hz_panel_timings;
+	(void)video_800x480at60hz_panel_timings;
+	(void)video_1280x720at50hz_panel_timings;
+	(void)video_1920x1080at50hz_panel_timings;
+	(void)video_640x480at72hz_panel_timings;
+	(void)video_640x480at60hz_panel_timings;
+
+	return 0;
+}
+
+/*
+ *  DSS driver :: enable
+ * */
+static void hdmi_panel_remove(struct omap_dss_device *dssdev)
+{
+}
+
+/*
+ *  DSS driver :: enable
+ * */
+static int hdmi_panel_enable(struct omap_dss_device *dssdev)
+{
+	int r = 0;
+
+	if(dssdev->platform_enable)
+		r = dssdev->platform_enable(dssdev);
+
+	if(r)
+		goto ERROR0;
+
+	r = hdmi_enable();
+	if(r)
+		goto ERROR0;
+	/* wait couple of vsyncs until enabling the LCD */
+	msleep(50);
+
+	return 0;
+ERROR0:
+	return r;
+}
+
+/*
+ *  DSS driver :: disable
+ * */
+static void hdmi_panel_disable(struct omap_dss_device *dssdev)
+{
+	hdmi_disable(0);
+
+	/* wait couple of vsyncs until enabling the hdmi */
+	msleep(50);
+
+	if(dssdev->platform_disable)
+		dssdev->platform_disable(dssdev);
+}
+
+/*
+ *  DSS driver :: suspend
+ * */
+static int hdmi_panel_suspend(struct omap_dss_device *dssdev)
+{
+	hdmi_panel_disable(dssdev);
+	return 0;
+}
+
+/*
+ *  DSS driver :: resume
+ * */
+static int hdmi_panel_resume(struct omap_dss_device *dssdev)
+{
+	return hdmi_panel_enable(dssdev);
+}
+
+/*
+ *  DSS driver (frontend with omapzoom)
+ *  -----------------------------------
+ * */
+static struct omap_dss_driver hdmi_driver = {
+	.probe = hdmi_panel_probe,
+	.remove = hdmi_panel_remove,
+	.enable = hdmi_panel_enable,
+	.disable = hdmi_panel_disable,
+	.suspend = hdmi_panel_suspend,
+	.resume = hdmi_panel_resume,
+	.driver = {
+		.name = "hdmi_panel",
+		.owner = THIS_MODULE,
+	}
+};
+#endif
+
+/*
+ *  ioctl driver :: opening
+ * */
+
+static int this_cdev_open(struct inode *p_inode, struct file *p_file)
+{
+	tda_instance *this;
+	int minor = iminor(p_inode);
+
+	if(minor >= MAX_MINOR) {
+		printk(KERN_ERR "hdmitx:%s:only one tda can be open\n", __func__);
+		return -EINVAL;
+	}
+
+	if((p_file->private_data != NULL) && (p_file->private_data != &our_instance)) {
+		printk(KERN_ERR "hdmitx:%s:p_file missmatch\n", __func__);
+	}
+	this = p_file->private_data = &our_instance;
+	down(&this->driver.sem);
+
+	LOG(KERN_INFO, "major:%d minor:%d user:%d\n", imajor(p_inode), iminor(p_inode), this->driver.user_counter);
+
+	if((this->driver.user_counter++) && (this->driver.minor == minor)) {
+		/* init already done */
+		up(&this->driver.sem);
+		return 0;
+	}
+	this->driver.minor = minor;
+
+	up(&this->driver.sem);
+	return 0;
+}
+
+/*
+ *  ioctl driver :: ioctl
+ * */
+static int this_cdev_ioctl(struct inode *p_inode, struct file *p_file, unsigned int cmd, unsigned long arg)
+{
+	tda_instance *this = p_file->private_data;
+	int err = 0;
+
+	LOG(KERN_INFO, ":%s\n", tda_ioctl(_IOC_NR(cmd)));
+
+	BUG_ON(this->driver.minor != iminor(p_inode));
+	if(_IOC_TYPE(cmd) != TDA_IOCTL_BASE) {
+		printk(KERN_INFO "hdmitx:%s:unknown ioctl type: %x\n", __func__, _IOC_TYPE(cmd));
+		return -ENOIOCTLCMD;
+	}
+
+	if(_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+	if(err) {
+		printk(KERN_ERR "hdmitx:%s:argument access denied (check address vs value)\n", __func__);
+		printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n", _IOC_DIR(cmd), arg);
+		return -EFAULT;
+	}
+
+	down(&this->driver.sem);
+
+	/* Check DevLib consistancy here */
+
+	switch(_IOC_NR(cmd)) {
+	case TDA_VERBOSE_ON_CMD: {
+		this->param.verbose = 1;
+		printk(KERN_INFO "hdmitx:verbose on\n");
+		break;
+	}
+
+	case TDA_VERBOSE_OFF_CMD: {
+		printk(KERN_INFO "hdmitx:verbose off\n");
+		this->param.verbose = 0;
+		break;
+	}
+
+	case TDA_BYEBYE_CMD: {
+		LOG(KERN_INFO, "release event handeling request\n");
+		this->tda.event = RELEASE;
+		this->driver.poll_done = true;
+		wake_up_interruptible(&this->driver.wait);
+		break;
+	}
+
+	case TDA_GET_SW_VERSION_CMD: {
+		TRY(tx_get_swversion(&this->tda.version));
+		BUG_ON(copy_to_user((tda_version *)arg, &this->tda.version, sizeof(tda_version)) != 0);
+		break;
+	}
+
+	case TDA_SET_POWER_CMD: {
+		BUG_ON(copy_from_user(&this->tda.power, (tda_power *)arg, sizeof(tda_power)) != 0);
+		TRY(tx_set_power_state(this->tda.instance, \
+		                       this->tda.power));
+		break;
+	}
+
+	case TDA_GET_POWER_CMD: {
+		TRY(tx_get_power_state(this->tda.instance, \
+		                       &this->tda.power));
+		BUG_ON(copy_to_user((tda_power *)arg, &this->tda.power, sizeof(tda_power)) != 0);
+		break;
+	}
+
+	case TDA_SETUP_CMD: {
+		BUG_ON(copy_from_user(&this->tda.setup, (tda_setup_info *)arg, sizeof(tda_setup_info)) != 0);
+		TRY(tx_instance_setup(this->tda.instance, \
+		                      &this->tda.setup));
+		break;
+	}
+
+	case TDA_GET_SETUP_CMD: {
+		TRY(tx_get_instance_setup(this->tda.instance, \
+		                          &this->tda.setup));
+		BUG_ON(copy_to_user((tda_setup *)arg, &this->tda.setup, sizeof(tda_setup)) != 0);
+		break;
+	}
+
+	case TDA_WAIT_EVENT_CMD: {
+		this->driver.poll_done = false;
+		up(&this->driver.sem);
+		if(wait_event_interruptible(this->driver.wait, this->driver.poll_done)) return -ERESTARTSYS;
+		down(&this->driver.sem);
+		BUG_ON(copy_to_user((tda_event *)arg, &this->tda.event, sizeof(tda_event)) != 0);
+		break;
+	}
+
+	case TDA_ENABLE_EVENT_CMD: {
+		tx_event_t event;
+		BUG_ON(copy_from_user(&event, (tx_event_t *)arg, sizeof(tx_event_t)) != 0);
+		TRY(tx_enable_event(this->tda.instance, event));
+		break;
+	}
+
+	case TDA_DISABLE_EVENT_CMD: {
+		tx_event_t event;
+		BUG_ON(copy_from_user(&event, (tx_event_t *)arg, sizeof(tx_event_t)) != 0);
+		TRY(tx_disable_event(this->tda.instance, event));
+		break;
+	}
+
+	case TDA_GET_VIDEO_SPEC_CMD: {
+		TRY(tx_get_video_format_specs(this->tda.instance, \
+		                              this->tda.video_fmt.id, \
+		                              &this->tda.video_fmt.spec));
+		BUG_ON(copy_to_user((tda_video_format *)arg, &this->tda.video_fmt, sizeof(tda_video_format)) != 0);
+		break;
+	}
+
+	case TDA_SET_INPUT_OUTPUT_CMD: {
+		BUG_ON(copy_from_user(&this->tda.setio, (tda_set_in_out *)arg, sizeof(tda_set_in_out)) != 0);
+
+		TRY(tx_set_input_output(this->tda.instance, \
+		                        this->tda.setio.video_in, \
+		                        this->tda.setio.video_out, \
+		                        this->tda.setio.audio_in, \
+		                        this->tda.setio.sink));
+		break;
+	}
+
+	case TDA_SET_AUDIO_INPUT_CMD: {
+		BUG_ON(copy_from_user(&this->tda.setio.audio_in, (tda_set_audio_in *)arg, sizeof(tda_set_audio_in)) != 0);
+		TRY(tx_set_audio_input(this->tda.instance, \
+		                       this->tda.setio.audio_in, \
+		                       this->tda.setio.sink));
+		break;
+	}
+
+	case TDA_SET_VIDEO_INFOFRAME_CMD: {
+		BUG_ON(copy_from_user(&this->tda.video_infoframe, (tda_video_infoframe *)arg, sizeof(tda_video_infoframe)) != 0);
+		TRY(tx_set_video_infoframe(this->tda.instance, \
+		                           this->tda.video_infoframe.enable, \
+		                           &this->tda.video_infoframe.data));
+		break;
+	}
+
+	case TDA_SET_AUDIO_INFOFRAME_CMD: {
+		BUG_ON(copy_from_user(&this->tda.audio_infoframe, (tda_audio_infoframe *)arg, sizeof(tda_audio_infoframe)) != 0);
+		TRY(tx_set_audio_infoframe(this->tda.instance, \
+		                           this->tda.audio_infoframe.enable, \
+		                           &this->tda.audio_infoframe.data));
+		break;
+	}
+
+	case TDA_SET_ACP_CMD: {
+		BUG_ON(copy_from_user(&this->tda.acp, (tda_acp *)arg, sizeof(tda_acp)) != 0);
+		TRY(tx_set_acppacket(this->tda.instance, \
+		                     this->tda.acp.enable, \
+		                     &this->tda.acp.data));
+		break;
+	}
+
+	case TDA_SET_GCP_CMD: {
+		BUG_ON(copy_from_user(&this->tda.gcp, (tda_gcp *)arg, sizeof(tda_gcp)) != 0);
+		TRY(tx_set_general_control_packet(this->tda.instance, \
+		                                  this->tda.gcp.enable, \
+		                                  &this->tda.gcp.data));
+		break;
+	}
+
+	case TDA_SET_ISRC1_CMD: {
+		BUG_ON(copy_from_user(&this->tda.isrc1, (tda_isrc1 *)arg, sizeof(tda_isrc1)) != 0);
+		TRY(tx_set_isrc1packet(this->tda.instance, \
+		                       this->tda.isrc1.enable, \
+		                       &this->tda.isrc1.data));
+		break;
+	}
+
+	case TDA_SET_MPS_INFOFRAME_CMD: {
+		BUG_ON(copy_from_user(&this->tda.mps_infoframe, (tda_mps_infoframe *)arg, sizeof(tda_mps_infoframe)) != 0);
+		TRY(tx_set_mpsinfoframe(this->tda.instance, \
+		                        this->tda.mps_infoframe.enable, \
+		                        &this->tda.mps_infoframe.data));
+		break;
+	}
+
+	case TDA_SET_SPD_INFOFRAME_CMD: {
+		BUG_ON(copy_from_user(&this->tda.spd_infoframe, (tda_spd_infoframe *)arg, sizeof(tda_spd_infoframe)) != 0);
+		TRY(tx_set_spd_infoframe(this->tda.instance, \
+		                         this->tda.spd_infoframe.enable, \
+		                         &this->tda.spd_infoframe.data));
+		break;
+	}
+
+	case TDA_SET_VS_INFOFRAME_CMD: {
+		BUG_ON(copy_from_user(&this->tda.vs_infoframe, (tda_vs_infoframe *)arg, sizeof(tda_vs_infoframe)) != 0);
+		TRY(tx_set_vs_infoframe(this->tda.instance, \
+		                        this->tda.vs_infoframe.enable, \
+		                        &this->tda.vs_infoframe.data));
+		break;
+	}
+
+	case TDA_SET_AUDIO_MUTE_CMD: {
+		BUG_ON(copy_from_user(&this->tda.audio_mute, (bool *)arg, sizeof(bool)) != 0);
+		TRY(tx_set_audio_mute(this->tda.instance,			\
+		                      this->tda.audio_mute));
+		break;
+	}
+
+	case TDA_RESET_AUDIO_CTS_CMD: {
+		TRY(tx_reset_audio_cts(this->tda.instance));
+		break;
+	}
+
+	case TDA_GET_EDID_STATUS_CMD: {
+		TRY(tx_get_edid_status(this->tda.instance, \
+		                       &this->tda.edid.status, \
+		                       &this->tda.edid.block_count));
+		BUG_ON(copy_to_user((tda_edid *)arg, &this->tda.edid, sizeof(tda_edid)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_AUDIO_CAPS_CMD: {
+		TRY(tx_get_edid_audio_caps(this->tda.instance, \
+		                           this->tda.edid_audio_caps.desc, \
+		                           this->tda.edid_audio_caps.max, \
+		                           &this->tda.edid_audio_caps.written, \
+		                           &this->tda.edid_audio_caps.flags));
+		BUG_ON(copy_to_user((tda_edid_audio_caps *)arg, &this->tda.edid_audio_caps, sizeof(tda_edid_audio_caps)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_VIDEO_CAPS_CMD: {
+		TRY(tx_get_edid_video_caps(this->tda.instance, \
+		                           this->tda.edid_video_caps.desc, \
+		                           this->tda.edid_video_caps.max, \
+		                           &this->tda.edid_video_caps.written, \
+		                           &this->tda.edid_video_caps.flags));
+		BUG_ON(copy_to_user((tda_edid_video_caps *)arg, &this->tda.edid_video_caps, sizeof(tda_edid_video_caps)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_VIDEO_PREF_CMD: {
+		TRY(tx_get_edid_video_preferred(this->tda.instance, \
+		                                &this->tda.edid_video_timings));
+		BUG_ON(copy_to_user((tda_edid_video_timings *)arg, &this->tda.edid_video_timings, sizeof(tda_edid_video_timings)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_SINK_TYPE_CMD: {
+		TRY(tx_get_edid_sink_type(this->tda.instance, \
+		                          &this->tda.setio.sink));
+		BUG_ON(copy_to_user((tda_sink *)arg, &this->tda.setio.sink, sizeof(tda_sink)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_SOURCE_ADDRESS_CMD: {
+		TRY(tx_get_edid_source_address(this->tda.instance, \
+		                               &this->tda.src_address));
+		BUG_ON(copy_to_user((unsigned short *)arg, &this->tda.src_address, sizeof(unsigned short)) != 0);
+		break;
+	}
+
+	case TDA_SET_GAMMUT_CMD: {
+		BUG_ON(copy_from_user(&this->tda.gammut, (tda_gammut *)arg, sizeof(tda_gammut)) != 0);
+		TRY(tx_set_gamut_packet(this->tda.instance, \
+		                        this->tda.gammut.enable, \
+		                        &this->tda.gammut.data));
+		break;
+	}
+
+	case TDA_GET_EDID_DTD_CMD: {
+		TRY(tx_get_edid_detailled_timing_descriptors(this->tda.instance, \
+		        this->tda.edid_dtd.desc, \
+		        this->tda.edid_dtd.max, \
+		        &this->tda.edid_dtd.written));
+		BUG_ON(copy_to_user((tda_edid_dtd *)arg, &this->tda.edid_dtd, sizeof(tda_edid_dtd)) != 0);
+		break;
+	}
+
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+	case TDA_GET_EDID_MD_CMD: {
+		TRY(tx_get_edid_monitor_descriptors(this->tda.instance, \
+		                                    this->tda.edid_md.desc1, \
+		                                    this->tda.edid_md.desc2, \
+		                                    this->tda.edid_md.other, \
+		                                    this->tda.edid_md.max, \
+		                                    &this->tda.edid_md.written));
+		BUG_ON(copy_to_user((tda_edid_md *)arg, &this->tda.edid_md, sizeof(tda_edid_md)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_TV_ASPECT_RATIO_CMD: {
+		TRY(tx_get_edid_tvpicture_ratio(this->tda.instance, \
+		                                &this->tda.edid_tv_aspect_ratio));
+		BUG_ON(copy_to_user((tda_edid_tv_aspect_ratio *)arg, &this->tda.edid_tv_aspect_ratio, sizeof(tda_edid_tv_aspect_ratio)) != 0);
+		break;
+	}
+
+	case TDA_GET_EDID_LATENCY_CMD: {
+		TRY(tx_get_edid_latency_info(this->tda.instance, \
+		                             &this->tda.edid_latency));
+		BUG_ON(copy_to_user((tda_edid_latency *)arg, &this->tda.edid_latency, sizeof(tda_edid_latency)) != 0);
+		break;
+	}
+
+	case TDA_SET_HDCP_CMD: {
+		BUG_ON(copy_from_user(&this->tda.hdcp_enable, (bool *)arg, sizeof(bool)) != 0);
+		break;
+	}
+
+	case TDA_GET_HDCP_STATUS_CMD: {
+		BUG_ON(copy_to_user((tda_edid_latency *)arg, &this->tda.hdcp_status, sizeof(tda_hdcp_status)) != 0);
+		break;
+	}
+#endif
+
+	default: {
+		/* unrecognized ioctl */
+		printk(KERN_INFO "hdmitx:%s:unknown ioctl number: %x\n", __func__, cmd);
+		up(&this->driver.sem);
+		return -ENOIOCTLCMD;
+	}
+	}
+
+TRY_DONE:
+	up(&this->driver.sem);
+	return err;
+}
+
+/*
+ *  ioctl driver :: releasing
+ * */
+static int this_cdev_release(struct inode *p_inode, struct file *p_file)
+{
+	tda_instance *this = p_file->private_data;
+	int minor = iminor(p_inode);
+
+	LOG(KERN_INFO, "called\n");
+
+	if(minor >= MAX_MINOR) {
+		LOG(KERN_ERR, "minor too big!\n");
+		return -EINVAL;
+	}
+
+	BUG_ON(this->driver.minor != iminor(p_inode));
+	down(&this->driver.sem);
+
+	this->driver.user_counter--;
+	if(this->driver.user_counter == 0) {
+		p_file->private_data = NULL;
+	} else {
+		LOG(KERN_INFO, "still %d users pending\n", this->driver.user_counter);
+	}
+
+	up(&this->driver.sem);
+	return 0;
+}
+
+/*
+ *  I2C client :: creation
+ * */
+static int this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	/*
+	 *	  I2C setup
+	 *	*/
+	if(this->driver.i2c_client) {
+		dev_err(&this->driver.i2c_client->dev, "<%s> HDMI device already created \n",
+		        __func__);
+		return -ENODEV;
+	}
+
+	this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if(!this->driver.i2c_client) {
+		return -ENOMEM;
+	}
+	memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
+
+	strncpy(this->driver.i2c_client->name, TX_NAME, I2C_NAME_SIZE);
+	this->driver.i2c_client->addr = TDA998X_I2C_SLAVEADDRESS;
+	this->driver.i2c_client->adapter = client->adapter;
+
+	i2c_set_clientdata(client, this->driver.i2c_client);
+
+#ifdef ANDROID_DSS
+	/* probe DSS */
+	err = omap_dss_register_driver(&hdmi_driver);
+#endif
+	if(err) goto i2c_tx_out;
+
+	/* prepare event */
+	this->driver.poll_done = true; /* currently idle */
+	init_waitqueue_head(&this->driver.wait);
+
+	/* I2C ok, then let's startup TDA */
+	err = hdmi_tx_init(this);
+	if(err) {
+		goto i2c_out;
+	}
+	this->tda.hdcp_enable = 0;
+	/* Standby the HDMI TX instance */
+	this->tda.power = power_standby;
+	tx_set_power_state(this->tda.instance, this->tda.power);
+	/* update HPD */
+	tx_get_hpdstatus(this->tda.instance, &this->tda.hot_plug_detect);
+
+#ifdef IRQ
+	/* FRO calibration */
+	err = gpio_request(TDA_IRQ_CALIB, "tda998x calibration");
+	if(err < 0) {
+		printk(KERN_ERR "hdmitx:%s:cannot use GPIO %d\n", __func__, TDA_IRQ_CALIB);
+		goto i2c_out;
+	}
+	/* turn GPIO into IRQ */
+	gpio_direction_input(TDA_IRQ_CALIB);
+	msleep(1);
+	if(request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
+	               tda_irq, IRQF_TRIGGER_FALLING | IRQF_DISABLED, "TDA IRQ", NULL)) {
+		printk(KERN_ERR "hdmitx:%s:cannot request irq, err:%d\n", __func__, err);
+		gpio_free(TDA_IRQ_CALIB);
+		goto i2c_out;
+	}
+#else
+	init_timer(&this->driver.no_irq_timer);
+	this->driver.no_irq_timer.function = polling_timeout;
+	this->driver.no_irq_timer.data = 0;
+	/* start polling in one sec */
+	this->driver.no_irq_timer.expires = jiffies + HZ;
+	add_timer(&this->driver.no_irq_timer);
+#endif
+
+	/* setup hdcp check timer */
+	init_timer(&this->driver.hdcp_check);
+	this->driver.hdcp_check.function = hdcp_check_timeout;
+	this->driver.hdcp_check.data = 0;
+
+	tx_get_swversion(&this->tda.version);
+	printk(KERN_INFO "HDMI TX SW version:%ul.%ul compatibility:%ul\n",   \
+	       this->tda.version.major_version_nr, \
+	       this->tda.version.minor_version_nr, \
+	       this->tda.version.compatibility_nr);
+
+	return 0;
+
+i2c_tx_out:
+	LOG(KERN_INFO, "tx closed\n");
+	/* close DevLib */
+	err = tx_close(this->tda.instance);
+
+i2c_out:
+	LOG(KERN_INFO, "this->driver.i2c_client removed\n");
+	kfree(this->driver.i2c_client);
+	this->driver.i2c_client = NULL;
+
+	return err;
+}
+
+/*
+ *  I2C client :: destroy
+ * */
+static int this_i2c_remove(struct i2c_client *client)
+{
+	tda_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+#ifdef ANDROID_DSS
+	/* unplug DSS */
+	omap_dss_unregister_driver(&hdmi_driver);
+#endif
+
+	if(!client->adapter) {
+		dev_err(&this->driver.i2c_client->dev, "<%s> no HDMI device \n",
+		        __func__);
+		return -ENODEV;
+	}
+	kfree(this->driver.i2c_client);
+	this->driver.i2c_client = NULL;
+
+	return err;
+}
+
+/*
+ *  I2C client driver (backend)
+ *  -----------------
+ * */
+static const struct i2c_device_id this_i2c_id[] = {
+	{ TX_NAME, 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(i2c, this_i2c_id);
+
+static struct i2c_driver this_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = TX_NAME,
+	},
+	.probe = this_i2c_probe,
+	 .remove = this_i2c_remove,
+	  .id_table = this_i2c_id,
+   };
+
+/*
+ *  ioctl driver (userland frontend)
+ *  ------------
+ * */
+static struct file_operations this_cdev_fops = {
+owner:
+	THIS_MODULE,
+open:
+	this_cdev_open,
+release:
+	this_cdev_release,
+/*ioctl:*/
+unlocked_ioctl:
+	this_cdev_ioctl,
+};
+
+/*
+ *  Module :: start up
+ * */
+static int __init tx_init(void)
+{
+	tda_instance *this = &our_instance;
+	dev_t dev = 0;
+	int err = 0;
+
+	/*
+	 *	   general device context
+	 *	*/
+	memset(this, 0, sizeof(tda_instance));
+	this->param.verbose = param_verbose;
+	this->param.major = param_major;
+	this->param.minor = param_minor;
+
+	/* Hello word */
+	printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMITX_NAME, TDA_NAME,
+	       TDA_VERSION_MAJOR,
+	       TDA_VERSION_MINOR,
+	       TDA_VERSION_PATCHLEVEL,
+	       __DATE__, __TIME__, TDA_VERSION_EXTRA);
+	if(this->param.verbose) LOG(KERN_INFO, ".verbose mode\n");
+
+	/*
+	 *	  plug I2C (backend : Hw interfacing)
+	 *	*/
+	err = i2c_add_driver(&this_i2c_driver);
+	if(err < 0) {
+		printk(KERN_ERR "driver registration failed\n");
+		return -ENODEV;
+	}
+
+	if(this->driver.i2c_client == NULL) {
+		printk(KERN_ERR "this->driver.i2c_client not allocated\n");
+		/* unregister i2c */
+		err = -ENODEV;
+		goto init_out;
+	}
+
+	/*
+	 *	  cdev init (userland frontend)
+	 *	*/
+
+	/* arbitray range of device numbers */
+	if(this->param.major) {
+		/* user force major number @ insmod */
+		dev = MKDEV(this->param.major, this->param.minor);
+		err = register_chrdev_region(dev, MAX_MINOR, HDMITX_NAME);
+		if(err) {
+			printk(KERN_ERR "unable to register %s, dev=%d %s\n", HDMITX_NAME, dev, ERR_TO_STR(err));
+			goto init_out;
+		}
+	} else {
+		/* fully dynamic major number */
+		err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR, HDMITX_NAME);
+		if(err) {
+			printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n", HDMITX_NAME, dev, ERR_TO_STR(err));
+			goto init_out;
+		}
+		this->param.major = MAJOR(dev);
+		this->param.minor = MINOR(dev);
+		/*       create_dev("/dev/hdmitx",dev); */
+		LOG(KERN_INFO, "/dev/hdmitx created major:%d minor:%d\n", this->param.major, this->param.minor);
+	}
+
+	cdev_init(this_cdev, &this_cdev_fops);
+	this_cdev->owner = THIS_MODULE;
+
+	this->driver.class = class_create(THIS_MODULE, HDMITX_NAME);
+	if(IS_ERR(this->driver.class)) {
+		printk(KERN_INFO "error creating mmap device class.\n");
+		err = -EIO;
+		goto init_out;
+	}
+	/* parent */
+	this->driver.dev = device_create(this->driver.class, NULL , dev, NULL, HDMITX_NAME);
+
+	this->driver.devno = dev;
+	err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
+	if(err) {
+		printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n", HDMITX_NAME, this->driver.devno, ERR_TO_STR(err));
+		device_destroy(this->driver.class, this->driver.devno);
+		class_destroy(this->driver.class);
+		unregister_chrdev_region(this->driver.devno, MAX_MINOR);
+		goto init_out;
+	}
+
+	/*
+	 *	   general device context
+	 *	*/
+	init_MUTEX(&this->driver.sem);
+	hdmi_enable();
+	return 0;
+
+init_out:
+	i2c_del_driver(&this_i2c_driver);
+	return err;
+}
+
+/*
+ *  Module :: shut down
+ * */
+static void __exit tx_exit(void)
+{
+	tda_instance *this = &our_instance;
+
+	LOG(KERN_INFO, "called\n");
+
+#ifdef IRQ
+	free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
+	gpio_free(TDA_IRQ_CALIB);
+#else
+	del_timer(&this->driver.no_irq_timer);
+#endif
+
+	del_timer(&this->driver.hdcp_check);
+	msleep(100);
+
+	/* close DevLib */
+	tx_close(this->tda.instance);
+
+	/* unregister cdevice */
+	cdev_del(this_cdev);
+	unregister_chrdev_region(this->driver.devno, MAX_MINOR);
+
+	/* unregister device */
+	device_destroy(this->driver.class, this->driver.devno);
+	class_destroy(this->driver.class);
+
+	/* unregister i2c */
+	i2c_del_driver(&this_i2c_driver);
+}
+
+/*
+ *  Module
+ *  ------
+ * */
+/* late_initcall(tx_init); */
+module_init(tx_init);
+module_exit(tx_exit);
+
+/*
+ *  Disclamer
+ *  ---------
+ * */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("andre lepine <andre.lepine@nxp.com>");
+MODULE_DESCRIPTION(HDMITX_NAME " driver");
diff --git a/drivers/video/hdmi/tda998x.h b/drivers/video/hdmi/tda998x.h
new file mode 100644
index 0000000..008d1c5
--- /dev/null
+++ b/drivers/video/hdmi/tda998x.h
@@ -0,0 +1,139 @@
+/*****************************************************************************/
+/* Copyright (c) 2009 NXP Semiconductors BV                                  */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#ifndef __tx_h__
+#define __tx_h__
+
+#include "tda998x_ioctl.h"
+
+#define HDMITX_NAME "hdmitx"
+
+#define POLLING_WQ_NAME "TDA_POLLING"
+#define HDCP_CHECK_EVERY_MS 35
+#define CHECK_EVERY_XX_MS 200
+#define OMAP_LCD_GPIO 8
+
+#define TDA_MAJOR 234 /* old-style interval of device numbers */
+#define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
+
+/* common I2C define with kernel */
+/* should be the same as arch/arm/mach-omap2/board-zoom2.c */
+#define TX_NAME "tda998X"
+#define TDA998X_I2C_SLAVEADDRESS 0x70
+
+/* On gplugD GPIO # 84 is connected to HDMI interrupt line */
+#define TDA_IRQ_CALIB 84
+
+#define EDID_BLOCK_COUNT 4
+#define EDID_BLOCK_SIZE 128
+#define MAX_EDID_TRIAL 5
+#define NO_PHY_ADDR 0xFFFF
+
+#define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMITX_NAME":%s:" fmt, __func__, ## args);}}
+/* not found the kernel "strerror" one! If someone knows, please replace it */
+#define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
+                      (e == -ENOMEM)? "ENOMEM, no memory available":\
+                      (e == -EINVAL)? "EINVAL, invalid argument":\
+                      (e == -EIO)? "EIO, input/output error":\
+                      (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
+                      (e == -EBUSY)? "EBUSY, device or resource busy":\
+                      (e == -ENOENT)? "ENOENT, no such file or directory":\
+                      (e == -EACCES)? "EACCES, permission denied":\
+                      (e == 0)?       "":\
+                      "!UNKNOWN!")
+
+#define TRY(fct) do { \
+		err=(fct);                                                        \
+		if (err) {                                                        \
+			printk(KERN_ERR "%s returned in %s line %d\n",hdmi_tx_err_string(err),__func__,__LINE__); \
+			goto TRY_DONE;                                                 \
+		}                                                                 \
+	}while(0)
+
+typedef void (*cec_callback_t)(struct work_struct *dummy);
+
+typedef struct {
+	/* module params */
+	struct {
+		int verbose;
+		int major;
+		int minor;
+	} param;
+	/* driver */
+	struct {
+		struct class *class;
+		struct device *dev;
+		int devno;
+		struct i2c_client *i2c_client;
+		struct semaphore sem;
+		int user_counter;
+		int minor;
+		wait_queue_head_t wait;
+		bool poll_done;
+#ifndef IRQ
+		struct timer_list no_irq_timer;
+#endif
+		struct timer_list hdcp_check;
+		cec_callback_t cec_callback;
+	} driver;
+	/* HDMI */
+	struct {
+		int instance;
+		tda_version version;
+		tda_setup setup;
+		tda_power power;
+		tx_hot_plug_t hot_plug_detect;
+		bool rx_device_active;
+		tda_video_format video_fmt;
+		tda_set_in_out setio;
+		bool audio_mute;
+		tda_video_infoframe video_infoframe;
+		tda_audio_infoframe audio_infoframe;
+		tda_acp acp;
+		tda_gcp gcp;
+		tda_isrc1 isrc1;
+		tda_isrc2 isrc2;
+		tda_gammut gammut;
+		tda_mps_infoframe mps_infoframe;
+		tda_spd_infoframe spd_infoframe;
+		tda_vs_infoframe vs_infoframe;
+		tda_edid edid;
+		tda_edid_dtd edid_dtd;
+		tda_edid_md edid_md;
+		tda_edid_audio_caps edid_audio_caps;
+		tda_edid_video_caps edid_video_caps;
+		tda_edid_video_timings edid_video_timings;
+		tda_edid_tv_aspect_ratio edid_tv_aspect_ratio;
+#ifdef TMFL_TDA19989
+		tda_edid_latency edid_latency;
+#endif
+		unsigned short src_address;
+		unsigned char raw_edid[EDID_BLOCK_COUNT *EDID_BLOCK_SIZE];
+		tda_capabilities capabilities;
+		tda_event event;
+		tda_hdcp_status hdcp_status;
+		bool hdcp_enable;
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+		tda_hdcp_fail hdcp_fail;
+#endif
+		unsigned char hdcp_raw_status;
+	} tda;
+} tda_instance;
+
+#endif /* __tx_h__ */
diff --git a/drivers/video/hdmi/tda998x_cec.c b/drivers/video/hdmi/tda998x_cec.c
new file mode 100644
index 0000000..103acbd
--- /dev/null
+++ b/drivers/video/hdmi/tda998x_cec.c
@@ -0,0 +1,2629 @@
+/*****************************************************************************/
+/* Copyright (c) 2009 NXP Semiconductors BV                                  */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#define _cec_c_
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/i2c.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/input.h>
+#include <asm/uaccess.h>
+#include <mach/gpio.h>
+
+/* HDMI DevLib */
+#include "tmNxCompId.h"
+#include "tmdlHdmiCEC.h"
+#include "tmdlHdmiCEC_local.h"
+
+/* local */
+#include "tda998x_version.h"
+#include "tda998x_cec.h"
+#include "tda998x_ioctl.h"
+
+/*
+ *
+ * DEFINITION
+ * ----------
+ * LEVEL 0
+ *
+ * */
+
+/*
+ *  Global
+ * */
+
+MODULE_DEVICE_TABLE(i2c, this_i2c_id);
+static const struct i2c_device_id this_i2c_id[] = {
+	{ CEC_NAME, 0 },
+	{ },
+};
+cec_instance our_instance;
+static struct cdev our_cdev, *this_cdev = &our_cdev;
+
+#ifdef TWL4030_HACK
+/* AL : hack to bypass keypad */
+struct input_dev *gkp_input;
+extern struct input_dev *get_twm4030_input(void);
+#endif
+
+/*
+ * Dependancies to HdmiTx module
+ * */
+
+extern void register_cec_interrupt(cec_callback_t fct);
+extern void unregister_cec_interrupt(void);
+extern short edid_phy_addr(void);
+extern int hdmi_enable(void);
+extern int hdmi_disable(int event_tracking);
+extern cec_power get_hdmi_status(void);
+extern cec_power get_hpd_status(void);
+extern int edid_received(void);
+
+/*
+ *  Module params
+ * */
+
+static int param_verbose = 0, param_major = 0, param_minor = 0, param_device = 4, param_addr = 0xFFFF;
+module_param_named(verbose, param_verbose, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(verbose, "make the driver verbose");
+module_param_named(major, param_major, int, S_IRUGO);
+MODULE_PARM_DESC(major, "the major number of the device mapper");
+module_param_named(device, param_device, int, S_IRUGO);
+MODULE_PARM_DESC(device, "device type can be 0:tv, 1:rec 3:tuner 4:mediaplayer, 5:audio");
+module_param_named(addr, param_addr, int, S_IRUGO);
+MODULE_PARM_DESC(addr, "physical address (until EDID received)");
+
+/*
+ *
+ * TOOLBOX
+ * -------
+ * LEVEL 1
+ *
+ * - i2c read/write
+ * - chip Id check
+ * - i2c client info
+ *
+ * */
+
+/*
+ *  Get main and unique I2C Client driver handle
+ * */
+struct i2c_client *get_this_i2c_client(void) {
+	cec_instance *this = &our_instance;
+	return this->driver.i2c_client;
+}
+
+/*
+ * error handling
+ * */
+static char *hdmi_cec_err_string(int err)
+{
+	switch(err) {
+	case ERR_DLHDMICEC_COMPATIBILITY: {
+		return "SW interface compatibility";
+		break;
+	}
+	case ERR_DLHDMICEC_MAJOR_VERSION: {
+		return "SW major version error";
+		break;
+	}
+	case ERR_DLHDMICEC_COMP_VERSION: {
+		return "SW component version error";
+		break;
+	}
+	case ERR_DLHDMICEC_BAD_UNIT_NUMBER: {
+		return "invalid device unit number";
+		break;
+	}
+	case ERR_DLHDMICEC_BAD_INSTANCE: {
+		return "bad input instance value  ";
+		break;
+	}
+	case ERR_DLHDMICEC_BAD_HANDLE: {
+		return "bad input handle";
+		break;
+	}
+	case ERR_DLHDMICEC_BAD_PARAMETER: {
+		return "invalid input parameter";
+		break;
+	}
+	case ERR_DLHDMICEC_NO_RESOURCES: {
+		return "resource is not available ";
+		break;
+	}
+	case ERR_DLHDMICEC_RESOURCE_OWNED: {
+		return "resource is already in use";
+		break;
+	}
+	case ERR_DLHDMICEC_RESOURCE_NOT_OWNED: {
+		return "caller does not own resource";
+		break;
+	}
+	case ERR_DLHDMICEC_INCONSISTENT_PARAMS: {
+		return "inconsistent input params";
+		break;
+	}
+	case ERR_DLHDMICEC_NOT_INITIALIZED: {
+		return "component is not initializ";
+		break;
+	}
+	case ERR_DLHDMICEC_NOT_SUPPORTED: {
+		return "function is not supported";
+		break;
+	}
+	case ERR_DLHDMICEC_INIT_FAILED: {
+		return "initialization failed";
+		break;
+	}
+	case ERR_DLHDMICEC_BUSY: {
+		return "component is busy";
+		break;
+	}
+	case ERR_DLHDMICEC_I2C_READ: {
+		return "read error";
+		break;
+	}
+	case ERR_DLHDMICEC_I2C_WRITE: {
+		return "write error";
+		break;
+	}
+	case ERR_DLHDMICEC_FULL: {
+		return "queue is full";
+		break;
+	}
+	case ERR_DLHDMICEC_NOT_STARTED: {
+		return "function is not started";
+		break;
+	}
+	case ERR_DLHDMICEC_ALREADY_STARTED: {
+		return "function is already starte";
+		break;
+	}
+	case ERR_DLHDMICEC_ASSERTION: {
+		return "assertion failure";
+		break;
+	}
+	case ERR_DLHDMICEC_INVALID_STATE: {
+		return "invalid state for function";
+		break;
+	}
+	case ERR_DLHDMICEC_OPERATION_NOT_PERMITTED: {
+		return "corresponds to posix EPERM";
+		break;
+	}
+	default : {
+		return "unexpected error";
+		break;
+	}
+	}
+}
+
+char *cec_opcode(int op)
+{
+	switch(op) {
+	case CEC_OPCODE_FEATURE_ABORT: {
+		return "CEC_OPCODE_FEATURE_ABORT";
+		break;
+	}
+	case CEC_OPCODE_IMAGE_VIEW_ON: {
+		return "CEC_OPCODE_IMAGE_VIEW_ON";
+		break;
+	}
+	case CEC_OPCODE_TUNER_STEP_INCREMENT: {
+		return "CEC_OPCODE_TUNER_STEP_INCREMENT";
+		break;
+	}
+	case CEC_OPCODE_TUNER_STEP_DECREMENT: {
+		return "CEC_OPCODE_TUNER_STEP_DECREMENT";
+		break;
+	}
+	case CEC_OPCODE_TUNER_DEVICE_STATUS: {
+		return "CEC_OPCODE_TUNER_DEVICE_STATUS";
+		break;
+	}
+	case CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS: {
+		return "CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS";
+		break;
+	}
+	case CEC_OPCODE_RECORD_ON: {
+		return "CEC_OPCODE_RECORD_ON";
+		break;
+	}
+	case CEC_OPCODE_RECORD_STATUS: {
+		return "CEC_OPCODE_RECORD_STATUS";
+		break;
+	}
+	case CEC_OPCODE_RECORD_OFF: {
+		return "CEC_OPCODE_RECORD_OFF";
+		break;
+	}
+	case CEC_OPCODE_TEXT_VIEW_ON: {
+		return "CEC_OPCODE_TEXT_VIEW_ON";
+		break;
+	}
+	case CEC_OPCODE_RECORD_TV_SCREEN: {
+		return "CEC_OPCODE_RECORD_TV_SCREEN";
+		break;
+	}
+	case CEC_OPCODE_GIVE_DECK_STATUS: {
+		return "CEC_OPCODE_GIVE_DECK_STATUS";
+		break;
+	}
+	case CEC_OPCODE_DECK_STATUS: {
+		return "CEC_OPCODE_DECK_STATUS";
+		break;
+	}
+	case CEC_OPCODE_SET_MENU_LANGUAGE: {
+		return "CEC_OPCODE_SET_MENU_LANGUAGE";
+		break;
+	}
+	case CEC_OPCODE_CLEAR_ANALOGUE_TIMER: {
+		return "CEC_OPCODE_CLEAR_ANALOGUE_TIMER";
+		break;
+	}
+	case CEC_OPCODE_SET_ANALOGUE_TIMER: {
+		return "CEC_OPCODE_SET_ANALOGUE_TIMER";
+		break;
+	}
+	case CEC_OPCODE_TIMER_STATUS: {
+		return "CEC_OPCODE_TIMER_STATUS";
+		break;
+	}
+	case CEC_OPCODE_STANDBY: {
+		return "CEC_OPCODE_STANDBY";
+		break;
+	}
+	case CEC_OPCODE_PLAY: {
+		return "CEC_OPCODE_PLAY";
+		break;
+	}
+	/*       case CEC_OPCODE_DECK_CONTROL: {return "CEC_OPCODE_DECK_CONTROL";break;} */
+	case CEC_OPCODE_TIMER_CLEARED_STATUS: {
+		return "CEC_OPCODE_TIMER_CLEARED_STATUS";
+		break;
+	}
+	case CEC_OPCODE_USER_CONTROL_PRESSED: {
+		return "CEC_OPCODE_USER_CONTROL_PRESSED";
+		break;
+	}
+	case CEC_OPCODE_USER_CONTROL_RELEASED: {
+		return "CEC_OPCODE_USER_CONTROL_RELEASED";
+		break;
+	}
+	case CEC_OPCODE_GIVE_OSD_NAME: {
+		return "CEC_OPCODE_GIVE_OSD_NAME";
+		break;
+	}
+	case CEC_OPCODE_SET_OSD_NAME: {
+		return "CEC_OPCODE_SET_OSD_NAME";
+		break;
+	}
+	case CEC_OPCODE_SET_OSD_STRING: {
+		return "CEC_OPCODE_SET_OSD_STRING";
+		break;
+	}
+	case CEC_OPCODE_SET_TIMER_PROGRAM_TITLE: {
+		return "CEC_OPCODE_SET_TIMER_PROGRAM_TITLE";
+		break;
+	}
+	case CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST: {
+		return "CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST";
+		break;
+	}
+	case CEC_OPCODE_GIVE_AUDIO_STATUS: {
+		return "CEC_OPCODE_GIVE_AUDIO_STATUS";
+		break;
+	}
+	case CEC_OPCODE_SET_SYSTEM_AUDIO_MODE: {
+		return "CEC_OPCODE_SET_SYSTEM_AUDIO_MODE";
+		break;
+	}
+	case CEC_OPCODE_REPORT_AUDIO_STATUS: {
+		return "CEC_OPCODE_REPORT_AUDIO_STATUS";
+		break;
+	}
+	case CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS: {
+		return "CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS";
+		break;
+	}
+	case CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS: {
+		return "CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS";
+		break;
+	}
+	case CEC_OPCODE_ROUTING_CHANGE: {
+		return "CEC_OPCODE_ROUTING_CHANGE";
+		break;
+	}
+	case CEC_OPCODE_ROUTING_INFORMATION: {
+		return "CEC_OPCODE_ROUTING_INFORMATION";
+		break;
+	}
+	case CEC_OPCODE_ACTIVE_SOURCE: {
+		return "CEC_OPCODE_ACTIVE_SOURCE";
+		break;
+	}
+	case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS: {
+		return "CEC_OPCODE_GIVE_PHYSICAL_ADDRESS";
+		break;
+	}
+	case CEC_OPCODE_REPORT_PHYSICAL_ADDRESS: {
+		return "CEC_OPCODE_REPORT_PHYSICAL_ADDRESS";
+		break;
+	}
+	case CEC_OPCODE_REQUEST_ACTIVE_SOURCE: {
+		return "CEC_OPCODE_REQUEST_ACTIVE_SOURCE";
+		break;
+	}
+	case CEC_OPCODE_SET_STREAM_PATH: {
+		return "CEC_OPCODE_SET_STREAM_PATH";
+		break;
+	}
+	case CEC_OPCODE_DEVICE_VENDOR_ID: {
+		return "CEC_OPCODE_DEVICE_VENDOR_ID";
+		break;
+	}
+	case CEC_OPCODE_VENDOR_COMMAND: {
+		return "CEC_OPCODE_VENDOR_COMMAND";
+		break;
+	}
+	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN: {
+		return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN";
+		break;
+	}
+	case CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP: {
+		return "CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP";
+		break;
+	}
+	case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID: {
+		return "CEC_OPCODE_GIVE_DEVICE_VENDOR_ID";
+		break;
+	}
+	case CEC_OPCODE_MENU_REQUEST: {
+		return "CEC_OPCODE_MENU_REQUEST";
+		break;
+	}
+	case CEC_OPCODE_MENU_STATUS: {
+		return "CEC_OPCODE_MENU_STATUS";
+		break;
+	}
+	case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS: {
+		return "CEC_OPCODE_GIVE_DEVICE_POWER_STATUS";
+		break;
+	}
+	case CEC_OPCODE_REPORT_POWER_STATUS: {
+		return "CEC_OPCODE_REPORT_POWER_STATUS";
+		break;
+	}
+	case CEC_OPCODE_GET_MENU_LANGUAGE: {
+		return "CEC_OPCODE_GET_MENU_LANGUAGE";
+		break;
+	}
+	case CEC_OPCODE_SET_ANALOGUE_SERVICE: {
+		return "CEC_OPCODE_SET_ANALOGUE_SERVICE";
+		break;
+	}
+	case CEC_OPCODE_SET_DIGITAL_SERVICE: {
+		return "CEC_OPCODE_SET_DIGITAL_SERVICE";
+		break;
+	}
+	case CEC_OPCODE_SET_DIGITAL_TIMER: {
+		return "CEC_OPCODE_SET_DIGITAL_TIMER";
+		break;
+	}
+	case CEC_OPCODE_CLEAR_DIGITAL_TIMER: {
+		return "CEC_OPCODE_CLEAR_DIGITAL_TIMER";
+		break;
+	}
+	case CEC_OPCODE_SET_AUDIO_RATE: {
+		return "CEC_OPCODE_SET_AUDIO_RATE";
+		break;
+	}
+	case CEC_OPCODE_INACTIVE_SOURCE: {
+		return "CEC_OPCODE_INACTIVE_SOURCE";
+		break;
+	}
+	case CEC_OPCODE_CEC_VERSION: {
+		return "CEC_OPCODE_CEC_VERSION";
+		break;
+	}
+	case CEC_OPCODE_GET_CEC_VERSION: {
+		return "CEC_OPCODE_GET_CEC_VERSION";
+		break;
+	}
+	case CEC_OPCODE_VENDOR_COMMAND_WITH_ID: {
+		return "CEC_OPCODE_VENDOR_COMMAND_WITH_ID";
+		break;
+	}
+	case CEC_OPCODE_CLEAR_EXTERNAL_TIMER: {
+		return "CEC_OPCODE_CLEAR_EXTERNAL_TIMER";
+		break;
+	}
+	case CEC_OPCODE_SET_EXTERNAL_TIMER: {
+		return "CEC_OPCODE_SET_EXTERNAL_TIMER";
+		break;
+	}
+	case CEC_OPCODE_ABORT_MESSAGE: {
+		return "CEC_OPCODE_ABORT_MESSAGE";
+		break;
+	}
+	default : {
+		return "unknown";
+		break;
+	}
+	}
+}
+
+static char *cec_ioctl(int io)
+{
+	switch(io) {
+	case CEC_VERBOSE_ON_CMD: {
+		return "CEC_VERBOSE_ON_CMD";
+		break;
+	}
+	case CEC_VERBOSE_OFF_CMD: {
+		return "CEC_VERBOSE_OFF_CMD";
+		break;
+	}
+	case CEC_BYEBYE_CMD: {
+		return "CEC_BYEBYE_CMD";
+		break;
+	}
+	case CEC_IOCTL_RX_ADDR_CMD: {
+		return "CEC_IOCTL_RX_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_WAIT_FRAME_CMD: {
+		return "CEC_IOCTL_WAIT_FRAME_CMD";
+		break;
+	}
+	case CEC_IOCTL_ABORT_MSG_CMD: {
+		return "CEC_IOCTL_ABORT_MSG_CMD";
+		break;
+	}
+	case CEC_IOCTL_ACTIVE_SRC_CMD: {
+		return "CEC_IOCTL_ACTIVE_SRC_CMD";
+		break;
+	}
+	case CEC_IOCTL_VERSION_CMD: {
+		return "CEC_IOCTL_VERSION_CMD";
+		break;
+	}
+	case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD: {
+		return "CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD";
+		break;
+	}
+	case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD: {
+		return "CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD";
+		break;
+	}
+	case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD: {
+		return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD";
+		break;
+	}
+	case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_DECK_CTRL_CMD: {
+		return "CEC_IOCTL_DECK_CTRL_CMD";
+		break;
+	}
+	case CEC_IOCTL_DECK_STATUS_CMD: {
+		return "CEC_IOCTL_DECK_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_DEVICE_VENDOR_ID_CMD: {
+		return "CEC_IOCTL_DEVICE_VENDOR_ID_CMD";
+		break;
+	}
+	case CEC_IOCTL_FEATURE_ABORT_CMD: {
+		return "CEC_IOCTL_FEATURE_ABORT_CMD";
+		break;
+	}
+	case CEC_IOCTL_GET_CEC_VERSION_CMD: {
+		return "CEC_IOCTL_GET_CEC_VERSION_CMD";
+		break;
+	}
+	case CEC_IOCTL_GET_MENU_LANGUAGE_CMD: {
+		return "CEC_IOCTL_GET_MENU_LANGUAGE_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD: {
+		return "CEC_IOCTL_GIVE_AUDIO_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_DECK_STATUS_CMD: {
+		return "CEC_IOCTL_GIVE_DECK_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD: {
+		return "CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD: {
+		return "CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_OSD_NAME_CMD: {
+		return "CEC_IOCTL_GIVE_OSD_NAME_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_GIVE_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD: {
+		return "CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD: {
+		return "CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_IMAGE_VIEW_ON_CMD: {
+		return "CEC_IOCTL_IMAGE_VIEW_ON_CMD";
+		break;
+	}
+	case CEC_IOCTL_INACTIVE_SRC_CMD: {
+		return "CEC_IOCTL_INACTIVE_SRC_CMD";
+		break;
+	}
+	case CEC_IOCTL_MENU_REQUEST_CMD: {
+		return "CEC_IOCTL_MENU_REQUEST_CMD";
+		break;
+	}
+	case CEC_IOCTL_MENU_STATUS_CMD: {
+		return "CEC_IOCTL_MENU_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_PLAY_CMD: {
+		return "CEC_IOCTL_PLAY_CMD";
+		break;
+	}
+	case CEC_IOCTL_POLLING_MSG_CMD: {
+		return "CEC_IOCTL_POLLING_MSG_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_OFF_CMD: {
+		return "CEC_IOCTL_REC_OFF_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD: {
+		return "CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD: {
+		return "CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_ON_EXT_PLUG_CMD: {
+		return "CEC_IOCTL_REC_ON_EXT_PLUG_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_ON_OWN_SRC_CMD: {
+		return "CEC_IOCTL_REC_ON_OWN_SRC_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_STATUS_CMD: {
+		return "CEC_IOCTL_REC_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_REC_TV_SCREEN_CMD: {
+		return "CEC_IOCTL_REC_TV_SCREEN_CMD";
+		break;
+	}
+	case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD: {
+		return "CEC_IOCTL_REPORT_AUDIO_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_REPORT_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_REPORT_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_REPORT_POWER_STATUS_CMD: {
+		return "CEC_IOCTL_REPORT_POWER_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD: {
+		return "CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD";
+		break;
+	}
+	case CEC_IOCTL_ROUTING_CHANGE_CMD: {
+		return "CEC_IOCTL_ROUTING_CHANGE_CMD";
+		break;
+	}
+	case CEC_IOCTL_ROUTING_INFORMATION_CMD: {
+		return "CEC_IOCTL_ROUTING_INFORMATION_CMD";
+		break;
+	}
+	case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD: {
+		return "CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD";
+		break;
+	}
+	case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD: {
+		return "CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD: {
+		return "CEC_IOCTL_SET_ANALOGUE_TIMER_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_AUDIO_RATE_CMD: {
+		return "CEC_IOCTL_SET_AUDIO_RATE_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_DIGITAL_TIMER_CMD: {
+		return "CEC_IOCTL_SET_DIGITAL_TIMER_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD: {
+		return "CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD: {
+		return "CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_MENU_LANGUAGE_CMD: {
+		return "CEC_IOCTL_SET_MENU_LANGUAGE_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_OSD_NAME_CMD: {
+		return "CEC_IOCTL_SET_OSD_NAME_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_OSD_STRING_CMD: {
+		return "CEC_IOCTL_SET_OSD_STRING_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_STREAM_PATH_CMD: {
+		return "CEC_IOCTL_SET_STREAM_PATH_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD: {
+		return "CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD: {
+		return "CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD";
+		break;
+	}
+	case CEC_IOCTL_STANDBY_CMD: {
+		return "CEC_IOCTL_STANDBY_CMD";
+		break;
+	}
+	case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD: {
+		return "CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD";
+		break;
+	}
+	case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD: {
+		return "CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_TEXT_VIEW_ON_CMD: {
+		return "CEC_IOCTL_TEXT_VIEW_ON_CMD";
+		break;
+	}
+	case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD: {
+		return "CEC_IOCTL_TIMER_CLEARED_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_TIMER_STATUS_CMD: {
+		return "CEC_IOCTL_TIMER_STATUS_CMD";
+		break;
+	}
+	case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD: {
+		return "CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD";
+		break;
+	}
+	case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD: {
+		return "CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD";
+		break;
+	}
+	case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD: {
+		return "CEC_IOCTL_TUNER_STEP_DECREMENT_CMD";
+		break;
+	}
+	case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD: {
+		return "CEC_IOCTL_TUNER_STEP_INCREMENT_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_CMD: {
+		return "CEC_IOCTL_USER_CTRL_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_PLAY_CMD: {
+		return "CEC_IOCTL_USER_CTRL_PLAY_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD: {
+		return "CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD: {
+		return "CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD: {
+		return "CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_TUNE_CMD: {
+		return "CEC_IOCTL_USER_CTRL_TUNE_CMD";
+		break;
+	}
+	case CEC_IOCTL_USER_CTRL_RELEASED_CMD: {
+		return "CEC_IOCTL_USER_CTRL_RELEASED_CMD";
+		break;
+	}
+	case CEC_IOCTL_VENDOR_COMMAND_CMD: {
+		return "CEC_IOCTL_VENDOR_COMMAND_CMD";
+		break;
+	}
+	case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD: {
+		return "CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD";
+		break;
+	}
+	case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD: {
+		return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD";
+		break;
+	}
+	case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD: {
+		return "CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD";
+		break;
+	}
+	case CEC_IOCTL_GET_SW_VERSION_CMD: {
+		return "CEC_IOCTL_GET_SW_VERSION_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_POWER_STATE_CMD: {
+		return "CEC_IOCTL_SET_POWER_STATE_CMD";
+		break;
+	}
+	case CEC_IOCTL_GET_POWER_STATE_CMD: {
+		return "CEC_IOCTL_GET_POWER_STATE_CMD";
+		break;
+	}
+	case CEC_IOCTL_INSTANCE_CONFIG_CMD: {
+		return "CEC_IOCTL_INSTANCE_CONFIG_CMD";
+		break;
+	}
+	case CEC_IOCTL_INSTANCE_SETUP_CMD: {
+		return "CEC_IOCTL_INSTANCE_SETUP_CMD";
+		break;
+	}
+	case CEC_IOCTL_GET_INSTANCE_SETUP_CMD: {
+		return "CEC_IOCTL_GET_INSTANCE_SETUP_CMD";
+		break;
+	}
+	case CEC_IOCTL_ENABLE_EVENT_CMD: {
+		return "CEC_IOCTL_ENABLE_EVENT_CMD";
+		break;
+	}
+	case CEC_IOCTL_DISABLE_EVENT_CMD: {
+		return "CEC_IOCTL_DISABLE_EVENT_CMD";
+		break;
+	}
+	case CEC_IOCTL_ENABLE_CALIBRATION_CMD: {
+		return "CEC_IOCTL_ENABLE_CALIBRATION_CMD";
+		break;
+	}
+	case CEC_IOCTL_DISABLE_CALIBRATION_CMD: {
+		return "CEC_IOCTL_DISABLE_CALIBRATION_CMD";
+		break;
+	}
+	case CEC_IOCTL_SEND_MSG_CMD: {
+		return "CEC_IOCTL_SEND_MSG_CMD";
+		break;
+	}
+	case CEC_IOCTL_SET_REGISTER_CMD: {
+		return "CEC_IOCTL_SET_REGISTER_CMD";
+		break;
+	}
+	default : {
+		return "unknown";
+		break;
+	}
+	}
+}
+
+static char *cec_rxstatus(int s)
+{
+	switch(s) {
+	case CEC_MSG_SUCCESS : {
+		return "success";
+		break;
+	}
+	case CEC_MSG_FAIL_DATA_NOT_ACK : {
+		return "data not ack";
+		break;
+	}
+	case CEC_CSP_OFF_STATE : {
+		return "CSP off";
+		break;
+	}
+	case CEC_BAD_REQ_SERVICE : {
+		return "bad req";
+		break;
+	}
+	case CEC_MSG_FAIL_UNABLE_TO_ACCESS : {
+		return "CEC line error";
+		break;
+	}
+	case CEC_MSG_FAIL_ARBITRATION_ERROR : {
+		return "arb error";
+		break;
+	}
+	case CEC_MSG_FAIL_BIT_TIMMING_ERROR : {
+		return "bit error";
+		break;
+	}
+	case CEC_MSG_FAIL_DEST_NOT_ACK : {
+		return "destination not ack";
+		break;
+	}
+	default : {
+		return "unknown";
+		break;
+	}
+	}
+}
+
+static unsigned char get_next_logical_addr(cec_device_type device, unsigned char la)
+{
+	switch(device) {
+	case CEC_DEVICE_TYPE_TV:
+		switch(la) {
+		case CEC_LOGICAL_ADDRESS_TV:
+			return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		default:
+			return CEC_LOGICAL_ADDRESS_TV;
+		}
+	case CEC_DEVICE_TYPE_REC_DEVICE:
+		switch(la) {
+		case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1:
+			return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2;
+		case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_2:
+			return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3;
+		case CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_3:
+			return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		default:
+			return CEC_LOGICAL_ADDRESS_RECORDING_DEVICE_1;
+		}
+	case CEC_DEVICE_TYPE_TUNER:
+		switch(la) {
+		case CEC_LOGICAL_ADDRESS_TUNER_1:
+			return CEC_LOGICAL_ADDRESS_TUNER_2;
+		case CEC_LOGICAL_ADDRESS_TUNER_2:
+			return CEC_LOGICAL_ADDRESS_TUNER_3;
+		case CEC_LOGICAL_ADDRESS_TUNER_3:
+			return CEC_LOGICAL_ADDRESS_TUNER_4;
+		case CEC_LOGICAL_ADDRESS_TUNER_4:
+			return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		default:
+			return CEC_LOGICAL_ADDRESS_TUNER_1;
+		}
+	case CEC_DEVICE_TYPE_PLAYBACK_DEVICE:
+		switch(la) {
+		case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1:
+			return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2;
+		case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_2:
+			return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3;
+		case CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_3:
+			return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		default:
+			return CEC_LOGICAL_ADDRESS_PLAYBACK_DEVICE_1;
+		}
+	case CEC_DEVICE_TYPE_AUDIO_DEVICE:
+		switch(la) {
+		case CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM:
+			return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		default:
+			return CEC_LOGICAL_ADDRESS_AUDIO_SYSTEM;
+		}
+	default:
+		return CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+	}
+}
+
+static int device_type(int type)
+{
+	printk(KERN_INFO "hdmicec declared as a ");
+	switch(type) {
+	case CEC_DEVICE_TYPE_TV:
+		printk("TV");
+		break;
+	case CEC_DEVICE_TYPE_REC_DEVICE:
+		printk("record");
+		break;
+	case CEC_DEVICE_TYPE_TUNER:
+		printk("tuner");
+		break;
+	case CEC_DEVICE_TYPE_PLAYBACK_DEVICE:
+		printk("playback");
+		break;
+	case CEC_DEVICE_TYPE_AUDIO_DEVICE:
+		printk("audio");
+		break;
+	default:
+		printk("default (playback)");
+		type = CEC_DEVICE_TYPE_PLAYBACK_DEVICE;
+		break;
+	}
+	printk(" device type\n");
+	return type;
+}
+
+/*
+ *
+ * PROCESSING
+ * ----------
+ * LEVEL 2
+ *
+ * */
+
+/*
+ *  CEC Power On
+ * */
+static void cec_on(cec_instance *this)
+{
+	int err;
+	struct task_struct *tsk = current;
+
+	disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
+
+	this->cec.power = power_on;
+	TRY(dl_hdmi_cec_set_power_state(this->cec.inst, this->cec.power));
+
+	/* turn GPIO into calib pulse generator */
+	/* output (1 means try-state or high) */
+	gpio_direction_output(TDA_IRQ_CALIB, 0);
+	__gpio_set_value(TDA_IRQ_CALIB, 1);
+	this->cec.clock = DL_HDMICEC_CLOCK_FRO;
+	TRY(dl_hdmi_cec_enable_calibration(this->cec.inst, this->cec.clock));
+	msleep(10);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+
+	/* CAUTION : TDA needs a real 10ms pulse */
+	cpu_relax();
+	spin_lock_irq(&tsk->sighand->siglock);
+	__gpio_set_value(TDA_IRQ_CALIB, 0);
+	__udelay(10000);
+	__gpio_set_value(TDA_IRQ_CALIB, 1);
+	spin_unlock_irq(&tsk->sighand->siglock);
+
+	msleep(10);
+	TRY(dl_hdmi_cec_disable_calibration(this->cec.inst));
+
+	/* setup */
+	TRY(dl_hdmi_cec_get_instance_setup(this->cec.inst, &this->cec.setup));
+	this->cec.setup.device_logical_address = this->cec.rx_addr;
+	this->cec.clock = DL_HDMICEC_CLOCK_FRO;
+	this->cec.setup.cec_clock_source = this->cec.clock;
+	TRY(dl_hdmi_cec_instance_setup(this->cec.inst, &this->cec.setup));
+
+	/* turn GPIO into IRQ */
+	gpio_direction_input(TDA_IRQ_CALIB);
+	enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
+
+	LOG(KERN_INFO, "standby --> on\n");
+
+TRY_DONE:
+	(void)0;
+}
+
+/*
+ *  CEC Power Off
+ * */
+static void cec_standby(cec_instance *this)
+{
+	int err;
+
+	this->cec.power = power_standby;
+	TRY(dl_hdmi_cec_set_power_state(this->cec.inst, this->cec.power));
+
+	LOG(KERN_INFO, "on --> standby\n");
+
+TRY_DONE:
+	(void)0;
+}
+
+/*
+ *  CEC interrupt polling
+ * */
+static void cec_interrupt(struct work_struct *dummy)
+{
+	cec_instance *this = &our_instance;
+	unsigned short new_phy_addr = edid_phy_addr();
+	int err = 0;
+
+	LOG(KERN_INFO, "%s called\n", __func__);
+
+	/* switch on/off CEC */
+	if(!get_hpd_status() &&                     \
+	   (this->cec.power == power_on)) {
+		this->cec.source_status = CEC_POWER_STATUS_STANDBY;
+		/*       TRY(dlHdmiCecInactiveSource(this->cec.inst,             \ */
+		/*                                        this->cec.initiator,     \ */
+		/*                                        this->cec.phy_addr)); */
+		cec_standby(this);
+	} else if(get_hpd_status() &&                         \
+	          (this->cec.power == power_standby)) {
+		/* send active msg when hdmi has been abled */
+		cec_on(this);
+	}
+	/* new phy addr means new EDID, mean HPD ! */
+	else if((this->cec.phy_addr != new_phy_addr) &&        \
+	        (this->cec.source_status == CEC_POWER_STATUS_ON)) {
+		LOG(KERN_INFO, "new physical address %02x\n", new_phy_addr);
+		this->cec.phy_addr = new_phy_addr;
+		if(this->cec.phy_addr != 0xFFFF) {
+			this->cec.rx_addr = get_next_logical_addr(this->cec.device_type, CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST);
+			TRY(dl_hdmi_cec_polling_message(this->cec.inst, this->cec.rx_addr));
+		} else {
+			this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+		}
+	}
+#ifdef GUI_OVER_HDMI
+	else if(edid_received()) {  /* Check me */
+		if(this->cec.source_status == CEC_POWER_STATUS_STANDBY) {
+			/* only for GFX on HDMI, do not use if only video playback on HDMI */
+			TRY(dl_hdmi_cec_image_view_on(this->cec.inst, this->cec.initiator));
+			TRY(dl_hdmi_cec_handle_interrupt(this->cec.inst));
+			msleep(200);
+			TRY(dl_hdmi_cec_active_source(this->cec.inst, this->cec.phy_addr));
+			this->cec.source_status = CEC_POWER_STATUS_ON;
+		}
+	}
+#endif
+
+#if 0
+	if(this->cec.phy_addr != 0xFFFF) {
+
+		/* claim source status */
+		if((get_hdmi_status() ==  power_standby) &&             \
+		   (this->cec.source_status == CEC_POWER_STATUS_ON)) {
+			/* send inactive msg when hdmi has been disabled */
+			this->cec.source_status = CEC_POWER_STATUS_STANDBY;
+			TRY(dl_hdmi_cec_inactive_source(this->cec.inst,          \
+			                                this->cec.initiator,     \
+			                                this->cec.phy_addr));
+		} else if((get_hdmi_status() ==  power_on) &&                     \
+		          (this->cec.source_status == CEC_POWER_STATUS_STANDBY)) {
+			/* send active msg when hdmi has been abled */
+			this->cec.source_status = CEC_POWER_STATUS_ON;
+			TRY(dl_hdmi_cec_active_source(this->cec.inst,        \
+			                              this->cec.phy_addr));
+		}
+		/*       printk(KERN_INFO "DBG phd_status:%s cec.power:%s\n", \ */
+		/*              get_hpd_status()?"Active":"Inactive",                                      \ */
+		/*              (this->cec.power==tmPowerOn)?"On":"Standby"); */
+	}
+#endif
+
+	/* internal handeling */
+	TRY(dl_hdmi_cec_handle_interrupt(this->cec.inst));
+
+TRY_DONE:
+
+	/* setup next tick */
+	if(!this->driver.deinit_req) {
+		/* setup next polling */
+#ifndef IRQ
+		/*       this->driver.timer.expires = jiffies + ( CHECK_EVERY_XX_MS * HZ / 1000 ); */
+		/*       add_timer(&this->driver.timer); */
+		mod_timer(&this->driver.timer, jiffies + (CHECK_EVERY_XX_MS * HZ / 1000));
+#endif
+	} else {
+		this->driver.deinit_req++;
+		wake_up_interruptible(&this->driver.wait);
+	}
+}
+
+#ifndef IRQ
+static DECLARE_WORK(wq_name, cec_interrupt);
+
+void polling_timeout(unsigned long arg)
+{
+
+#if 0
+	/* fake frame for equipement-less testing */
+
+	cec_instance *this = &our_instance;
+
+	if(this->driver.timer.data++ > 1000) {
+		printk(KERN_INFO "fake rx message\n");
+		this->driver.timer.data = 0;
+
+		this->cec.frame.count = 4;
+		this->cec.frame.addr = 4; /* 0-->4 (TV-->MediaPlayer1) */
+		this->cec.frame.data[0] = 0x46; /* opcode: "GiveOsd" */
+		this->cec.frame.service = CEC_RX_DONE;
+
+		this->driver.poll_done = true;
+		wake_up_interruptible(&this->driver.wait);
+	}
+#endif
+
+	/* derefered because ATOMIC context of timer does not support I2C_transfert */
+	schedule_work(&wq_name);
+
+}
+#endif
+
+#ifndef IRQ
+/*
+ *  TDA irq
+ * */
+static irqreturn_t tda_irq(int irq, void *_udc)
+{
+	cec_instance *this = &our_instance;
+	/*    printk(KERN_INFO "DBG caught irq:%d\n",irq); */
+
+	/* do it now */
+	mod_timer(&this->driver.timer, jiffies);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+#ifdef TWL4030_HACK
+/*
+ *  User Control
+ * */
+static void user_control(int key, int press)
+{
+	input_report_key(gkp_input, key, press);
+	input_sync(gkp_input);
+	msleep(20);
+	input_report_key(gkp_input, key, 0);
+	input_sync(gkp_input);
+}
+#endif
+
+/*
+ *  CEC callback
+ * */
+static void event_callback_cec(dl_hdmi_cec_event_t event, unsigned char *data, unsigned char length)
+{
+	int err = 0;
+	cec_instance *this = &our_instance;
+	int opcode;
+	int initiator, receiver;
+
+	if(event == DL_HDMICEC_CALLBACK_MESSAGE_AVAILABLE) {
+
+		this->cec.frame.count = length;
+		this->cec.frame.addr = data[1]; /* .AddressByte */
+		initiator = (this->cec.frame.addr >> 4) & 0x0F;
+		this->cec.initiator = initiator;
+		receiver = this->cec.frame.addr & 0x0F;
+		/* .DataBytes[], length - siezof(length,addr,ack) */
+		memcpy(&this->cec.frame.data, &data[2], length - 2);
+		opcode = this->cec.frame.data[0];
+		printk(KERN_INFO "hdmicec:rx:[%x--->%x] %s length:%d addr:%d %02x%02x%02x%02x\n", initiator, receiver, cec_opcode(opcode), \
+		       length, data[1],
+		       this->cec.frame.data[0],                                      \
+		       this->cec.frame.data[1],                                      \
+		       this->cec.frame.data[2],                                      \
+		       this->cec.frame.data[3]);
+		this->cec.frame.service = CEC_RX_DONE;
+
+		msleep(20);
+
+		/* automatic answering */
+		switch(opcode) {
+		case CEC_OPCODE_GIVE_PHYSICAL_ADDRESS:
+			TRY(dl_hdmi_cec_report_physical_address(this->cec.inst,           \
+			                                        this->cec.phy_addr,       \
+			                                        this->cec.device_type));
+			break;
+		case CEC_OPCODE_GET_CEC_VERSION:
+			TRY(dl_hdmi_cec_version(this->cec.inst,                         \
+			                        this->cec.initiator,                    \
+			                        this->cec.version));
+			break;
+		case CEC_OPCODE_GIVE_OSD_NAME:
+			TRY(dl_hdmi_cec_set_osd_name(this->cec.inst,         \
+			                             this->cec.initiator,        \
+			                             this->cec.osd_name.data,         \
+			                             this->cec.osd_name.length));
+			break;
+		case CEC_OPCODE_GIVE_DEVICE_VENDOR_ID:
+			TRY(dl_hdmi_cec_device_vendor_id(this->cec.inst,              \
+			                                 this->cec.vendor_id));
+			break;
+		case CEC_OPCODE_REQUEST_ACTIVE_SOURCE:
+			if(this->cec.source_status == CEC_POWER_STATUS_ON) {
+				if(this->cec.initiator != 0x0F) {
+					if(receiver == 0x0F) {
+						TRY(dl_hdmi_cec_active_source(this->cec.inst, this->cec.phy_addr));
+					}
+				}
+			}
+			break;
+		case CEC_OPCODE_ACTIVE_SOURCE:
+			if(this->cec.source_status == CEC_POWER_STATUS_ON) {
+				this->cec.source_status = CEC_POWER_STATUS_STANDBY;
+				hdmi_disable(1);
+				this->cec.power = power_on;
+				/* keeps CEC alive */
+				TRY(dl_hdmi_cec_set_power_state(this->cec.inst, this->cec.power));
+			}
+			break;
+		case CEC_OPCODE_GIVE_DEVICE_POWER_STATUS:
+			TRY(dl_hdmi_cec_report_power_status(this->cec.inst,               \
+			                                    this->cec.initiator,          \
+			                                    this->cec.source_status));
+			break;
+		case CEC_OPCODE_STANDBY:
+			/* mind recording device can only be stopped by appli */
+			if(this->cec.device_type != CEC_DEVICE_TYPE_REC_DEVICE) {
+				this->cec.source_status = CEC_POWER_STATUS_STANDBY;
+				hdmi_disable(1);
+				this->cec.power = power_on;
+				/* keeps CEC alive */
+				TRY(dl_hdmi_cec_set_power_state(this->cec.inst, this->cec.power));
+			}
+			break;
+		case CEC_OPCODE_ROUTING_INFORMATION:
+		case CEC_OPCODE_SET_STREAM_PATH:
+			/* wake-up if called */
+			if(this->cec.phy_addr == (((int)this->cec.frame.data[1] << 8) + this->cec.frame.data[2])) {
+				if(this->cec.source_status != CEC_POWER_STATUS_ON) {
+					this->cec.source_status = CEC_POWER_STATUS_ON;
+					hdmi_enable();
+				}
+				TRY(dl_hdmi_cec_active_source(this->cec.inst, this->cec.phy_addr));
+			}
+			break;
+			/*       case /\* NEW DECK ??? *\/ */
+		case CEC_OPCODE_ROUTING_CHANGE:
+			/* wake-up if called */
+			if(this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
+				if(this->cec.source_status != CEC_POWER_STATUS_ON) {
+					this->cec.source_status = CEC_POWER_STATUS_ON;
+					hdmi_enable();
+				}
+				TRY(dl_hdmi_cec_active_source(this->cec.inst, this->cec.phy_addr));
+			}
+			break;
+		case CEC_OPCODE_ABORT_MESSAGE:
+			if(this->cec.phy_addr == (((int)this->cec.frame.data[3] << 8) + this->cec.frame.data[4])) {
+				TRY(dl_hdmi_cec_feature_abort(this->cec.inst, \
+				                              this->cec.initiator, \
+				                              this->cec.feature_abort.feature_opcode, \
+				                              this->cec.feature_abort.abort_reason));
+			}
+			break;
+		case CEC_OPCODE_MENU_REQUEST:
+#ifdef TWL4030_HACK
+			this->cec.menu_status = CEC_MENU_STATE_ACTIVATE;
+			TRY(dl_hdmi_cec_menu_status(this->cec.inst, \
+			                            this->cec.initiator, \
+			                            this->cec.menu_status));
+			break;
+#endif
+		case CEC_OPCODE_USER_CONTROL_PRESSED:
+			switch(this->cec.frame.data[1]) {
+#ifdef TWL4030_HACK /* AL : hack to bypass keypad */
+			case CEC_REMOTE_BUTTON_SELECT:
+				user_control(353, 64);
+				break;
+			case CEC_REMOTE_BUTTON_UP:
+				user_control(103, 128);
+				break;
+			case CEC_REMOTE_BUTTON_DOWN:
+				user_control(108, 128);
+				break;
+			case CEC_REMOTE_BUTTON_LEFT:
+				user_control(105, 128);
+				break;
+			case CEC_REMOTE_BUTTON_RIGHT:
+				user_control(106, 128);
+				break;
+			case CEC_REMOTE_BUTTON_EXIT:
+				user_control(14, 8);
+				break;
+#endif
+			case CEC_REMOTE_BUTTON_POWER:
+				this->cec.source_status = CEC_POWER_STATUS_ON;
+				hdmi_enable();
+				break;
+			default:
+				this->cec.feature_abort.feature_opcode = opcode;
+				this->cec.feature_abort.abort_reason = CEC_ABORT_INVALID_OPERAND;
+				TRY(dl_hdmi_cec_feature_abort(this->cec.inst, \
+				                              this->cec.initiator, \
+				                              this->cec.feature_abort.feature_opcode, \
+				                              this->cec.feature_abort.abort_reason));
+				break;
+			}
+			break;
+#ifdef TWL4030_HACK
+		case CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN:
+			user_control(59, 8);
+#endif
+			break;
+		case CEC_OPCODE_FEATURE_ABORT:
+			/* stop any state machine transition */
+			break;
+		case CEC_OPCODE_VENDOR_COMMAND:
+		case CEC_OPCODE_DEVICE_VENDOR_ID:
+			/* hopefully will be handle in userspace */
+			break;
+		default:
+			if(receiver != 0x0F) {
+				this->cec.feature_abort.feature_opcode = opcode;
+				this->cec.feature_abort.abort_reason = CEC_ABORT_UNKNOWN_OPCODE;
+				TRY(dl_hdmi_cec_feature_abort(this->cec.inst,                 \
+				                              this->cec.initiator,            \
+				                              this->cec.feature_abort.feature_opcode, \
+				                              this->cec.feature_abort.abort_reason));
+			}
+			break;
+		}
+		this->driver.poll_done = true;
+		wake_up_interruptible(&this->driver.wait);
+	} else if(event == DL_HDMICEC_CALLBACK_STATUS) {
+
+		this->cec.frame.count = length;
+		this->cec.frame.addr = data[1]; /* .AddressByte */
+		initiator = (this->cec.frame.addr >> 4) & 0x0F;
+		receiver = this->cec.frame.addr & 0x0F;
+		/* .DataBytes[], length - siezof(length,addr)  */
+		memcpy(&this->cec.frame.data, &data[2], length - 2);
+		opcode = this->cec.frame.data[0];
+		this->cec.frame.service = CEC_TX_DONE;
+
+		if(length == POLLING_LENGTH) {
+			if(opcode == CEC_MSG_FAIL_DEST_NOT_ACK) {
+				/* no echo means it's mine ! */
+				TRY(dl_hdmi_cec_set_logical_address(this->cec.inst, this->cec.rx_addr));
+				TRY(dl_hdmi_cec_report_physical_address(this->cec.inst,        \
+				                                        this->cec.phy_addr,    \
+				                                        this->cec.device_type));
+				/* DEVICE VENDOR ID sending after logicial address allocation according to spec 1.4 */
+				TRY(dl_hdmi_cec_device_vendor_id(this->cec.inst, this->cec.vendor_id));
+			} else if(opcode == CEC_MSG_SUCCESS) {
+				/* try next one */
+				this->cec.rx_addr = get_next_logical_addr(this->cec.device_type, this->cec.rx_addr);
+				if(this->cec.rx_addr != CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST) {
+					TRY(dl_hdmi_cec_polling_message(this->cec.inst, this->cec.rx_addr));
+				} else {
+					/* no more room, keep and claim unregistred */
+					TRY(dl_hdmi_cec_set_logical_address(this->cec.inst, this->cec.rx_addr));
+					TRY(dl_hdmi_cec_report_physical_address(this->cec.inst,     \
+					                                        this->cec.phy_addr, \
+					                                        this->cec.device_type));
+				}
+			} else {
+				printk(KERN_INFO "ACK [%x--->%x] %s\n", initiator, receiver, cec_rxstatus(opcode));
+			}
+		} else {
+			if(CEC_MSG_SUCCESS != opcode) {
+				printk(KERN_INFO "ACK [%x--->%x] %s\n", initiator, receiver, cec_rxstatus(opcode));
+			}
+		}
+
+		this->driver.poll_done = true;
+		wake_up_interruptible(&this->driver.wait);
+
+	} else {
+		LOG(KERN_ERR, "oups ! callback got invalid event %d !\n", event);
+	}
+
+TRY_DONE:
+	(void)err;
+}
+
+/*
+ *  DevLib CEC opening
+ * */
+static int hdmi_cec_init(cec_instance *this)
+{
+	int err = 0;
+
+	/* Real opening */
+	TRY(dl_hdmi_cec_open(&this->cec.inst));
+
+	/*    this->cec.vendor_id = 0x006037;   /\* NXP (IEEE OUI) *\/ */
+	/*    this->cec.vendor_id = 0x0000f0;   /\* Samsung *\/ */
+	this->cec.vendor_id = 0x00e091;   /* LGE */
+
+	/*    this->cec.version = CEC_VERSION_1_4; */
+	this->cec.version = cec_version_1_3a;
+	this->cec.osd_name.data[0] = 0x54; /* TDA19989 by default */
+	this->cec.osd_name.data[1] = 0x44;
+	this->cec.osd_name.data[2] = 0x41;
+	this->cec.osd_name.data[3] = 0x31;
+	this->cec.osd_name.data[4] = 0x39;
+	this->cec.osd_name.data[5] = 0x39;
+	this->cec.osd_name.data[6] = 0x38;
+	this->cec.osd_name.data[7] = 0x39;
+	this->cec.osd_name.length = 8;
+
+	TRY(dl_hdmi_cec_register_callbacks(this->cec.inst, event_callback_cec));
+
+	this->cec.phy_addr = param_addr;
+	this->cec.device_type = device_type(param_device);
+
+TRY_DONE:
+	return err;
+}
+
+/*
+ *
+ * ENTRY POINTS
+ * ------------
+ * LEVEL 3
+ *
+ * -
+ *
+ * */
+
+/*
+ *  ioctl driver :: opening
+ * */
+
+static int this_cdev_open(struct inode *p_inode, struct file *p_file)
+{
+	cec_instance *this;
+	int minor = iminor(p_inode);
+
+	if(minor >= MAX_MINOR) {
+		printk(KERN_ERR "hdmicec:%s:only one cec opening please\n", __func__);
+		return -EINVAL;
+	}
+
+	if((p_file->private_data != NULL) && (p_file->private_data != &our_instance)) {
+		printk(KERN_ERR "hdmicec:%s:p_file missmatch\n", __func__);
+	}
+	this = p_file->private_data = &our_instance;
+	down(&this->driver.sem);
+
+	LOG(KERN_INFO, "major:%d minor:%d user:%d\n", imajor(p_inode), iminor(p_inode), this->driver.user_counter);
+
+	if((this->driver.user_counter++) && (this->driver.minor == minor)) {
+		/* init already done */
+		up(&this->driver.sem);
+		return 0;
+	}
+	this->driver.minor = minor;
+
+	up(&this->driver.sem);
+	return 0;
+}
+
+/*
+ *  ioctl driver :: ioctl
+ * */
+static int this_cdev_ioctl(struct inode *p_inode, struct file *p_file, unsigned int cmd, unsigned long arg)
+{
+	cec_instance *this = p_file->private_data;
+	int err = 0;
+
+	LOG(KERN_INFO, ":%s\n", cec_ioctl(_IOC_NR(cmd)));
+
+	BUG_ON(this->driver.minor != iminor(p_inode));
+	if(_IOC_TYPE(cmd) != CEC_IOCTL_BASE) {
+		printk(KERN_INFO "hdmicec:%s:unknown ioctl type: %x\n", __func__, _IOC_TYPE(cmd));
+		return -ENOIOCTLCMD;
+	}
+
+	if(_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+	else if(_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd)) || !arg;
+	if(err) {
+		printk(KERN_ERR "hdmicec:%s:argument access denied (check address vs value)\n", __func__);
+		printk(KERN_ERR "_IOC_DIR:%d arg:%lx\n", _IOC_DIR(cmd), arg);
+		return -EFAULT;
+	}
+
+	down(&this->driver.sem);
+
+	/* Check DevLib consistancy here */
+
+	switch(_IOC_NR(cmd)) {
+	case CEC_VERBOSE_ON_CMD: {
+		printk(KERN_INFO "verbose on\n");
+		this->param.verbose = 1;
+		break;
+	}
+
+	case CEC_VERBOSE_OFF_CMD: {
+		printk(KERN_INFO "verbose off\n");
+		this->param.verbose = 0;
+		break;
+	}
+
+	case CEC_BYEBYE_CMD: {
+		LOG(KERN_INFO, "callback release request\n");
+		this->cec.frame.service = CEC_RELEASE;
+		this->driver.poll_done = true;
+		wake_up_interruptible(&this->driver.wait);
+		break;
+	}
+
+	/*
+	 *	  no param
+	 *	*/
+
+	case CEC_IOCTL_DISABLE_CALIBRATION_CMD: {
+		TRY(dl_hdmi_cec_disable_calibration(this->cec.inst));
+		break;
+	}
+
+	case CEC_IOCTL_INSTANCE_CONFIG_CMD: {
+		TRY(dl_hdmi_cec_instance_config(this->cec.inst));
+		break;
+	}
+
+	case CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD: {
+		TRY(dl_hdmi_cec_request_active_source(this->cec.inst));
+		break;
+	}
+
+	case CEC_IOCTL_ABORT_MSG_CMD: {
+		TRY(dl_hdmi_cec_abort_message(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GET_MENU_LANGUAGE_CMD: {
+		TRY(dl_hdmi_cec_get_menu_language(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_AUDIO_STATUS_CMD: {
+		TRY(dl_hdmi_cec_give_audio_status(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD: {
+		TRY(dl_hdmi_cec_give_device_power_status(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD: {
+		TRY(dl_hdmi_cec_give_device_vendor_id(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_OSD_NAME_CMD: {
+		TRY(dl_hdmi_cec_give_osd_name(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_PHY_ADDR_CMD: {
+		TRY(dl_hdmi_cec_give_physical_address(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD: {
+		TRY(dl_hdmi_cec_give_system_audio_mode_status(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_IMAGE_VIEW_ON_CMD: {
+		TRY(dl_hdmi_cec_image_view_on(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_POLLING_MSG_CMD: {
+		TRY(dl_hdmi_cec_polling_message(this->cec.inst, this->cec.rx_addr));
+		break;
+	}
+
+	case CEC_IOCTL_REC_OFF_CMD: {
+		TRY(dl_hdmi_cec_record_off(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_REC_ON_OWN_SRC_CMD: {
+		TRY(dl_hdmi_cec_record_on_own_source(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_REC_TV_SCREEN_CMD: {
+		TRY(dl_hdmi_cec_record_tv_screen(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_STANDBY_CMD: {
+		TRY(dl_hdmi_cec_standby(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_TEXT_VIEW_ON_CMD: {
+		TRY(dl_hdmi_cec_text_view_on(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_TUNER_STEP_DECREMENT_CMD: {
+		TRY(dl_hdmi_cec_tuner_step_decrement(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_TUNER_STEP_INCREMENT_CMD: {
+		TRY(dl_hdmi_cec_tuner_step_increment(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_RELEASED_CMD: {
+		TRY(dl_hdmi_cec_user_control_released(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD: {
+		TRY(dl_hdmi_cec_vendor_remote_button_up(this->cec.inst, this->cec.initiator));
+		break;
+	}
+
+	case CEC_IOCTL_ROUTING_INFORMATION_CMD: {
+		TRY(dl_hdmi_cec_routing_information(this->cec.inst, this->cec.phy_addr));
+		break;
+	}
+
+	case CEC_IOCTL_SET_STREAM_PATH_CMD: {
+		TRY(dl_hdmi_cec_set_stream_path(this->cec.inst, this->cec.phy_addr));
+		break;
+	}
+
+	case CEC_IOCTL_ACTIVE_SRC_CMD: {
+		/* NEW first do a <image view on> */
+		/* NEW when switch by DSS and was inactive */
+		TRY(dl_hdmi_cec_active_source(this->cec.inst, this->cec.phy_addr));
+		break;
+	}
+
+	case CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD: {
+		TRY(dl_hdmi_cec_system_audio_mode_request(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.phy_addr));
+		break;
+	}
+
+	/*
+	 *	  1 param
+	 *	*/
+
+	case CEC_IOCTL_RX_ADDR_CMD: {
+		/* 	    BUG_ON(copy_from_user(&this->cec.rx_addr,(unsigned char*)arg,sizeof(unsigned char)) != 0); */
+		this->cec.rx_addr = arg;
+		TRY(dl_hdmi_cec_set_logical_address(this->cec.inst, this->cec.rx_addr));
+		break;
+	}
+
+	case CEC_IOCTL_PHY_ADDR_CMD: {
+		BUG_ON(copy_from_user(&this->cec.phy_addr, (unsigned short *)arg, sizeof(unsigned short)) != 0);
+		break;
+	}
+
+	case CEC_IOCTL_GET_CEC_VERSION_CMD: {
+		BUG_ON(copy_from_user(&this->cec.version, (cec_version *)arg, sizeof(cec_version)) != 0);
+		TRY(dl_hdmi_cec_get_cec_version(this->cec.inst, this->cec.version));
+		break;
+	}
+
+	case CEC_IOCTL_GET_SW_VERSION_CMD: {
+		TRY(dl_hdmi_cec_get_swversion(&this->cec.sw_version));
+		BUG_ON(copy_to_user((cec_sw_version *)arg, &this->cec.sw_version, sizeof(cec_sw_version)) != 0);
+		break;
+	}
+
+	case CEC_IOCTL_SET_POWER_STATE_CMD: {
+		/* NEW : log : please use DSS */
+		BUG_ON(copy_from_user(&this->cec.power, (cec_power *)arg, sizeof(cec_power)) != 0);
+		TRY(dl_hdmi_cec_set_power_state(this->cec.inst, this->cec.power));
+		break;
+	}
+
+	case CEC_IOCTL_GET_POWER_STATE_CMD: {
+		TRY(dl_hdmi_cec_get_power_state(this->cec.inst, &this->cec.power));
+		BUG_ON(copy_to_user((cec_power *)arg, &this->cec.power, sizeof(cec_power)) != 0);
+		break;
+	}
+
+	case CEC_IOCTL_INSTANCE_SETUP_CMD: {
+		BUG_ON(copy_from_user(&this->cec.setup, (cec_setup *)arg, sizeof(cec_setup)) != 0);
+		TRY(dl_hdmi_cec_instance_setup(this->cec.inst, &this->cec.setup));
+		break;
+	}
+
+	case CEC_IOCTL_GET_INSTANCE_SETUP_CMD: {
+		TRY(dl_hdmi_cec_get_instance_setup(this->cec.inst, &this->cec.setup));
+		BUG_ON(copy_to_user((cec_setup *)arg, &this->cec.setup, sizeof(cec_setup)) != 0);
+		break;
+	}
+
+	/*
+	 *	  case CEC_IOCTL_ENABLE_EVENT_CMD:
+	 *	  {
+	 *	  BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
+	 *	  TRY(dlHdmiCecEnableEvent(this->cec.inst,this->cec.an_event));
+	 *	  break;
+	 *	  }
+	 *
+	 *	  case CEC_IOCTL_DISABLE_EVENT_CMD:
+	 *	  {
+	 *	  BUG_ON(copy_from_user(&this->cec.an_event,(cec_event*)arg,sizeof(cec_event)) != 0);
+	 *	  TRY(dlHdmiCecDisableEvent(this->cec.inst,this->cec.an_event));
+	 *	  break;
+	 *	  }
+	 *	*/
+
+	case CEC_IOCTL_SET_MENU_LANGUAGE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.clock, (cec_string *)arg, sizeof(cec_string)) != 0);
+		TRY(dl_hdmi_cec_set_menu_language(this->cec.inst, this->cec.string.data));
+		break;
+	}
+
+	case CEC_IOCTL_ENABLE_CALIBRATION_CMD: {
+		BUG_ON(copy_from_user(&this->cec.clock, (cec_clock *)arg, sizeof(cec_clock)) != 0);
+		TRY(dl_hdmi_cec_enable_calibration(this->cec.inst, this->cec.clock));
+		break;
+	}
+
+	/*
+	 *	  >1 param
+	 *	*/
+
+	case CEC_IOCTL_WAIT_FRAME_CMD: {
+		this->cec.frame.service = CEC_WAITING;
+		this->driver.poll_done = false;
+		up(&this->driver.sem);
+		if(wait_event_interruptible(this->driver.wait, this->driver.poll_done)) return -ERESTARTSYS;
+		down(&this->driver.sem);
+		BUG_ON(copy_to_user((cec_frame *)arg, &this->cec.frame, sizeof(cec_frame)) != 0);
+		break;
+	}
+
+	case CEC_IOCTL_VERSION_CMD: {
+		BUG_ON(copy_from_user(&this->cec.version, (cec_version *)arg, sizeof(cec_version)) != 0);
+		TRY(dl_hdmi_cec_version(this->cec.inst, \
+		                        this->cec.initiator, \
+		                        this->cec.version));
+		break;
+	}
+
+	case CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD: {
+		BUG_ON(copy_from_user(&this->cec.analog_timer, (cec_analogue_timer *)arg, sizeof(cec_analogue_timer)) != 0);
+		TRY(dl_hdmi_cec_clear_analogue_timer(this->cec.inst, \
+		                                     this->cec.initiator, \
+		                                     this->cec.analog_timer.day_of_month, \
+		                                     this->cec.analog_timer.month_of_year, \
+		                                     this->cec.analog_timer.start_time, \
+		                                     &this->cec.analog_timer.duration, \
+		                                     this->cec.analog_timer.recording_sequence, \
+		                                     this->cec.analog_timer.analogue_broadcast_type, \
+		                                     this->cec.analog_timer.analogue_frequency, \
+		                                     this->cec.analog_timer.broadcast_system));
+		break;
+	}
+
+	case CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD: {
+		BUG_ON(copy_from_user(&this->cec.digital_timer, (cec_digital_timer *)arg, sizeof(cec_digital_timer)) != 0);
+		TRY(dl_hdmi_cec_clear_digital_timer(this->cec.inst, \
+		                                    this->cec.initiator, \
+		                                    this->cec.digital_timer.day_of_month, \
+		                                    this->cec.digital_timer.month_of_year, \
+		                                    this->cec.digital_timer.start_time, \
+		                                    &this->cec.digital_timer.duration, \
+		                                    this->cec.digital_timer.recording_sequence, \
+		                                    &this->cec.digital_timer.service_identification));
+		break;
+	}
+
+	case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD: {
+		BUG_ON(copy_from_user(&this->cec.etwep, (cec_ext_timer_with_ext_plug *)arg, sizeof(cec_ext_timer_with_ext_plug)) != 0);
+		TRY(dl_hdmi_cec_clear_external_timer_with_external_plug(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.etwep.day_of_month, \
+		        this->cec.etwep.month_of_year, \
+		        this->cec.etwep.start_time, \
+		        &this->cec.etwep.duration, \
+		        this->cec.etwep.recording_sequence, \
+		        this->cec.etwep.external_plug));
+		break;
+	}
+
+	case CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD: {
+		BUG_ON(copy_from_user(&this->cec.etwpa, (cec_ext_timer_with_phy_addr *)arg, sizeof(cec_ext_timer_with_phy_addr)) != 0);
+		TRY(dl_hdmi_cec_clear_external_timer_with_physical_address(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.etwpa.day_of_month, \
+		        this->cec.etwpa.month_of_year, \
+		        this->cec.etwpa.start_time, \
+		        &this->cec.etwpa.duration, \
+		        this->cec.etwpa.recording_sequence, \
+		        this->cec.etwpa.external_physical_address));
+		break;
+	}
+
+	case CEC_IOCTL_DECK_CTRL_CMD: {
+		BUG_ON(copy_from_user(&this->cec.deck_ctrl, (cec_deck_ctrl *)arg, sizeof(cec_deck_ctrl)) != 0);
+		TRY(dl_hdmi_cec_deck_control(this->cec.inst, \
+		                             this->cec.initiator, \
+		                             this->cec.deck_ctrl));
+		break;
+	}
+
+	case CEC_IOCTL_DECK_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.deck_status, (cec_deck_status *)arg, sizeof(cec_deck_status)) != 0);
+		TRY(dl_hdmi_cec_deck_status(this->cec.inst, \
+		                            this->cec.initiator, \
+		                            this->cec.deck_status));
+		break;
+	}
+
+	case CEC_IOCTL_DEVICE_VENDOR_ID_CMD: {
+		BUG_ON(copy_from_user(&this->cec.vendor_id, (unsigned long *)arg, sizeof(unsigned long)) != 0);
+		TRY(dl_hdmi_cec_device_vendor_id(this->cec.inst, \
+		                                 this->cec.vendor_id));
+		break;
+	}
+
+	case CEC_IOCTL_FEATURE_ABORT_CMD: {
+		BUG_ON(copy_from_user(&this->cec.feature_abort, (cec_feature_abort *)arg, sizeof(cec_feature_abort)) != 0);
+		TRY(dl_hdmi_cec_feature_abort(this->cec.inst, \
+		                              this->cec.initiator, \
+		                              this->cec.feature_abort.feature_opcode, \
+		                              this->cec.feature_abort.abort_reason));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_DECK_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.satus_request, (cec_status_request *)arg, sizeof(cec_status_request)) != 0);
+		TRY(dl_hdmi_cec_give_deck_status(this->cec.inst, \
+		                                 this->cec.initiator, \
+		                                 this->cec.satus_request));
+		break;
+	}
+
+	case CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.satus_request, (cec_status_request *)arg, sizeof(cec_status_request *)) != 0);
+		TRY(dl_hdmi_cec_give_tuner_device_status(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.satus_request));
+		break;
+	}
+
+	case CEC_IOCTL_INACTIVE_SRC_CMD: {
+		/* NEW first stand by video */
+		/* NEW when hdmi_disable and was active */
+		TRY(dl_hdmi_cec_inactive_source(this->cec.inst, \
+		                                this->cec.initiator, \
+		                                this->cec.phy_addr));
+		break;
+	}
+
+	case CEC_IOCTL_MENU_REQUEST_CMD: {
+		BUG_ON(copy_from_user(&this->cec.menu_request, (cec_menu_request *)arg, sizeof(cec_menu_request)) != 0);
+		TRY(dl_hdmi_cec_menu_request(this->cec.inst, \
+		                             this->cec.initiator, \
+		                             this->cec.menu_request));
+		break;
+	}
+
+	case CEC_IOCTL_MENU_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.menu_status, (cec_menu_status *)arg, sizeof(cec_menu_status)) != 0);
+		TRY(dl_hdmi_cec_menu_status(this->cec.inst, \
+		                            this->cec.initiator, \
+		                            this->cec.menu_status));
+		break;
+	}
+
+	case CEC_IOCTL_PLAY_CMD: {
+		BUG_ON(copy_from_user(&this->cec.play, (cec_play *)arg, sizeof(cec_play)) != 0);
+		TRY(dl_hdmi_cec_play(this->cec.inst, \
+		                     this->cec.initiator, \
+		                     this->cec.play));
+		break;
+	}
+
+	case CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.analog_service, (cec_analogue_service *)arg, sizeof(cec_analogue_service)) != 0);
+		TRY(dl_hdmi_cec_record_on_analogue_service(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.analog_service.analogue_broadcast_type, \
+		        this->cec.analog_service.analogue_frequency, \
+		        this->cec.analog_service.broadcast_system));
+		break;
+	}
+
+	case CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.digital_service, (cec_digital_service *)arg, sizeof(cec_digital_service)) != 0);
+		TRY(dl_hdmi_cec_record_on_digital_service(this->cec.inst, \
+		        this->cec.initiator, \
+		        &this->cec.digital_service));
+		break;
+	}
+
+	case CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD: {
+		TRY(dl_hdmi_cec_record_on_external_physical_address(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.phy_addr));
+		break;
+	}
+
+	case CEC_IOCTL_REC_ON_EXT_PLUG_CMD: {
+		BUG_ON(copy_from_user(&this->cec.ext_plug, (cec_ext_plug *)arg, sizeof(cec_ext_plug)) != 0);
+		TRY(dl_hdmi_cec_record_on_external_plug(this->cec.inst, \
+		                                        this->cec.initiator, \
+		                                        this->cec.ext_plug));
+		break;
+	}
+
+	case CEC_IOCTL_REC_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.rec_status, (cec_rec_status *)arg, sizeof(cec_rec_status)) != 0);
+		TRY(dl_hdmi_cec_record_status(this->cec.inst, \
+		                              this->cec.initiator, \
+		                              this->cec.rec_status));
+		break;
+	}
+
+	case CEC_IOCTL_REPORT_AUDIO_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.audio_status, (cec_audio_status *)arg, sizeof(cec_audio_status)) != 0);
+		TRY(dl_hdmi_cec_report_audio_status(this->cec.inst, \
+		                                    this->cec.initiator, \
+		                                    &this->cec.audio_status));
+		break;
+	}
+
+	case CEC_IOCTL_REPORT_PHY_ADDR_CMD: {
+		BUG_ON(copy_from_user(&this->cec.device_type, (cec_device_type *)arg, sizeof(cec_device_type)) != 0);
+		TRY(dl_hdmi_cec_report_physical_address(this->cec.inst, \
+		                                        this->cec.phy_addr, \
+		                                        this->cec.device_type));
+		break;
+	}
+
+	case CEC_IOCTL_REPORT_POWER_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.source_status, (cec_power_status *)arg, sizeof(cec_power_status)) != 0);
+		TRY(dl_hdmi_cec_report_power_status(this->cec.inst, \
+		                                    this->cec.initiator, \
+		                                    this->cec.source_status));
+		break;
+	}
+
+	case CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.analog_service, (cec_analogue_service *)arg, sizeof(cec_analogue_service)) != 0);
+		TRY(dl_hdmi_cec_select_analogue_service(this->cec.inst, \
+		                                        this->cec.initiator, \
+		                                        this->cec.analog_service.analogue_broadcast_type, \
+		                                        this->cec.analog_service.analogue_frequency, \
+		                                        this->cec.analog_service.broadcast_system));
+		break;
+	}
+
+	case CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.digital_service, (cec_digital_service *)arg, sizeof(cec_digital_service)) != 0);
+		TRY(dl_hdmi_cec_select_digital_service(this->cec.inst, \
+		                                       this->cec.initiator, \
+		                                       &this->cec.digital_service));
+		break;
+	}
+
+	case CEC_IOCTL_SET_ANALOGUE_TIMER_CMD: {
+		BUG_ON(copy_from_user(&this->cec.analog_timer, (cec_analogue_timer *)arg, sizeof(cec_analogue_timer)) != 0);
+		TRY(dl_hdmi_cec_set_analogue_timer(this->cec.inst, \
+		                                   this->cec.initiator, \
+		                                   this->cec.analog_timer.day_of_month, \
+		                                   this->cec.analog_timer.month_of_year, \
+		                                   this->cec.analog_timer.start_time, \
+		                                   &this->cec.analog_timer.duration, \
+		                                   this->cec.analog_timer.recording_sequence, \
+		                                   this->cec.analog_timer.analogue_broadcast_type, \
+		                                   this->cec.analog_timer.analogue_frequency, \
+		                                   this->cec.analog_timer.broadcast_system));
+		break;
+	}
+
+	case CEC_IOCTL_SET_AUDIO_RATE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.audio_rate, (cec_audio_rate *)arg, sizeof(cec_audio_rate)) != 0);
+		TRY(dl_hdmi_cec_set_audio_rate(this->cec.inst, \
+		                               this->cec.initiator, \
+		                               this->cec.audio_rate));
+		break;
+	}
+
+	case CEC_IOCTL_SET_DIGITAL_TIMER_CMD: {
+		BUG_ON(copy_from_user(&this->cec.digital_timer, (cec_digital_timer *)arg, sizeof(cec_digital_timer)) != 0);
+		TRY(dl_hdmi_cec_set_digital_timer(this->cec.inst, \
+		                                  this->cec.initiator, \
+		                                  this->cec.digital_timer.day_of_month, \
+		                                  this->cec.digital_timer.month_of_year, \
+		                                  this->cec.digital_timer.start_time, \
+		                                  &this->cec.digital_timer.duration, \
+		                                  this->cec.digital_timer.recording_sequence, \
+		                                  &this->cec.digital_timer.service_identification));
+		break;
+	}
+
+	case CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD: {
+		BUG_ON(copy_from_user(&this->cec.etwep, (cec_ext_timer_with_ext_plug *)arg, sizeof(cec_ext_timer_with_ext_plug)) != 0);
+		TRY(dl_hdmi_cec_set_external_timer_with_external_plug(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.etwep.day_of_month, \
+		        this->cec.etwep.month_of_year, \
+		        this->cec.etwep.start_time, \
+		        &this->cec.etwep.duration, \
+		        this->cec.etwep.recording_sequence, \
+		        this->cec.etwep.external_plug));
+		break;
+	}
+
+	case CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD: {
+		BUG_ON(copy_from_user(&this->cec.etwpa, (cec_ext_timer_with_phy_addr *)arg, sizeof(cec_ext_timer_with_phy_addr)) != 0);
+		TRY(dl_hdmi_cec_set_external_timer_with_physical_address(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.etwpa.day_of_month, \
+		        this->cec.etwpa.month_of_year, \
+		        this->cec.etwpa.start_time, \
+		        &this->cec.etwpa.duration, \
+		        this->cec.etwpa.recording_sequence, \
+		        this->cec.etwpa.external_physical_address));
+		break;
+	}
+
+	case CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.sys_audio_status, (cec_sys_audio_status *)arg, sizeof(cec_sys_audio_status)) != 0);
+		TRY(dl_hdmi_cec_set_system_audio_mode(this->cec.inst, \
+		                                      this->cec.initiator, \
+		                                      this->cec.sys_audio_status));
+		break;
+	}
+
+	case CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.sys_audio_status, (cec_sys_audio_status *)arg, sizeof(cec_sys_audio_status)) != 0);
+		TRY(dl_hdmi_cec_system_audio_mode_status(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.sys_audio_status));
+		break;
+	}
+
+	case CEC_IOCTL_TIMER_CLEARED_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.timer_cleared_status, (cec_timer_cleared_status *)arg, sizeof(cec_timer_cleared_status)) != 0);
+		TRY(dl_hdmi_cec_timer_cleared_status(this->cec.inst, \
+		                                     this->cec.initiator, \
+		                                     this->cec.timer_cleared_status));
+		break;
+	}
+
+	case CEC_IOCTL_TIMER_STATUS_CMD: {
+		BUG_ON(copy_from_user(&this->cec.timer_status, (cec_timer_status *)arg, sizeof(cec_timer_status)) != 0);
+		TRY(dl_hdmi_cec_timer_status(this->cec.inst, \
+		                             this->cec.initiator, \
+		                             &this->cec.timer_status));
+		break;
+	}
+
+	case CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.tdsa, (cec_tuner_device_status_analogue *)arg, sizeof(cec_tuner_device_status_analogue)) != 0);
+		TRY(dl_hdmi_cec_tuner_device_status_analogue(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.tdsa.recording_flag, \
+		        this->cec.tdsa.tuner_display_info, \
+		        this->cec.tdsa.analogue_broadcast_type, \
+		        this->cec.tdsa.analogue_frequency, \
+		        this->cec.tdsa.broadcast_system));
+		break;
+	}
+
+	case CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD: {
+		BUG_ON(copy_from_user(&this->cec.tdsd, (cec_tuner_device_status_digital *)arg, sizeof(cec_tuner_device_status_digital)) != 0);
+		TRY(dl_hdmi_cec_tuner_device_status_digital(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.tdsd.recording_flag, \
+		        this->cec.tdsd.tuner_display_info, \
+		        &this->cec.tdsd.service_identification));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_CMD: {
+		BUG_ON(copy_from_user(&this->cec.user_ctrl, (cec_user_ctrl *)arg, sizeof(cec_user_ctrl)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed(this->cec.inst, \
+		                                     this->cec.initiator, \
+		                                     this->cec.user_ctrl));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_PLAY_CMD: {
+		BUG_ON(copy_from_user(&this->cec.play, (cec_play *)arg, sizeof(cec_play)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed_play(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.play));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD: {
+		BUG_ON(copy_from_user(&this->cec.select, (unsigned char *)arg, sizeof(unsigned char)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed_select_audio_input(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.select));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD: {
+		BUG_ON(copy_from_user(&this->cec.select, (unsigned char *)arg, sizeof(unsigned char)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed_select_avinput(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.select));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD: {
+		BUG_ON(copy_from_user(&this->cec.select, (unsigned char *)arg, sizeof(unsigned char)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed_select_media(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.select));
+		break;
+	}
+
+	case CEC_IOCTL_USER_CTRL_TUNE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.user_ctrl_tune, (cec_user_ctrl_tune *)arg, sizeof(cec_user_ctrl_tune)) != 0);
+		TRY(dl_hdmi_cec_user_control_pressed_tune(this->cec.inst, \
+		        this->cec.initiator, \
+		        &this->cec.user_ctrl_tune));
+		break;
+	}
+
+	case CEC_IOCTL_SET_OSD_NAME_CMD: {
+		BUG_ON(copy_from_user(&this->cec.osd_name, (cec_string *)arg, sizeof(cec_string)) != 0);
+		TRY(dl_hdmi_cec_set_osd_name(this->cec.inst,      \
+		                             this->cec.initiator, \
+		                             this->cec.osd_name.data, \
+		                             this->cec.osd_name.length));
+		break;
+	}
+
+	case CEC_IOCTL_SET_OSD_STRING_CMD: {
+		BUG_ON(copy_from_user(&this->cec.osd_string, (cec_osd_string *)arg, sizeof(cec_osd_string)) != 0);
+		TRY(dl_hdmi_cec_set_osd_string(this->cec.inst, \
+		                               this->cec.initiator, \
+		                               this->cec.osd_string.display_control, \
+		                               this->cec.osd_string.data, \
+		                               this->cec.osd_string.length));
+		break;
+	}
+
+	case CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD: {
+		BUG_ON(copy_from_user(&this->cec.string, (cec_string *)arg, sizeof(cec_string)) != 0);
+		TRY(dl_hdmi_cec_set_timer_program_title(this->cec.inst, \
+		                                        this->cec.initiator, \
+		                                        this->cec.string.data, \
+		                                        this->cec.string.length));
+		break;
+	}
+
+	case CEC_IOCTL_VENDOR_COMMAND_CMD: {
+		BUG_ON(copy_from_user(&this->cec.string, (cec_string *)arg, sizeof(cec_string)) != 0);
+		TRY(dl_hdmi_cec_vendor_command(this->cec.inst, \
+		                               this->cec.initiator, \
+		                               this->cec.string.data, \
+		                               this->cec.string.length));
+		break;
+	}
+
+	case CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD: {
+		BUG_ON(copy_from_user(&this->cec.string, (cec_string *)arg, sizeof(cec_string)) != 0);
+		TRY(dl_hdmi_cec_vendor_remote_button_down(this->cec.inst, \
+		        this->cec.initiator, \
+		        this->cec.string.data, \
+		        this->cec.string.length));
+		break;
+	}
+
+	case CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD: {
+		BUG_ON(copy_from_user(&this->cec.vcwi, (cec_vendor_command_with_id *)arg, sizeof(cec_vendor_command_with_id)) != 0);
+		TRY(dl_hdmi_cec_vendor_command_with_id(this->cec.inst,	\
+		                                       this->cec.initiator,	\
+		                                       this->cec.vcwi.vendor_id, \
+		                                       this->cec.vcwi.cmd.data, \
+		                                       this->cec.vcwi.cmd.length));
+		break;
+	}
+
+	/*       case : */
+	/* 	 { */
+	/* 	    BUG_ON(copy_from_user(&this->cec.,(*)arg,sizeof()) != 0); */
+	/* 	    TRY((this->cec.inst, \ */
+	/* 		 this->cec.,	 \ */
+	/* 		 &this->cec.)); */
+	/* 	    break; */
+	/* 	 } */
+
+	default: {
+		/* unrecognized ioctl */
+		printk(KERN_INFO " unknown ioctl %x\n", cmd);
+		up(&this->driver.sem);
+		return -ENOIOCTLCMD;
+	}
+	}
+
+TRY_DONE:
+	up(&this->driver.sem);
+	return err;
+}
+
+/*
+ *  ioctl driver :: releasing
+ * */
+static int this_cdev_release(struct inode *p_inode, struct file *p_file)
+{
+	cec_instance *this = p_file->private_data;
+	int minor = iminor(p_inode);
+
+	LOG(KERN_INFO, "called\n");
+
+	if(minor >= MAX_MINOR) {
+		return -EINVAL;
+	}
+
+	BUG_ON(this->driver.minor != iminor(p_inode));
+	down(&this->driver.sem);
+
+	this->driver.user_counter--;
+	if(this->driver.user_counter == 0) {
+		p_file->private_data = NULL;
+	} else {
+		LOG(KERN_INFO, "still %d user pending\n", this->driver.user_counter);
+	}
+
+	up(&this->driver.sem);
+	return 0;
+}
+
+/*
+ *  I2C client :: creation
+ * */
+static int __devinit this_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	cec_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	/*
+	 *	  I2C setup
+	 *	*/
+	if(this->driver.i2c_client) {
+		dev_err(&this->driver.i2c_client->dev, "<%s> CEC device already created \n",
+		        __func__);
+		return -ENODEV;
+	}
+
+	this->driver.i2c_client = kmalloc(sizeof(struct i2c_client), GFP_KERNEL);
+	if(!this->driver.i2c_client) {
+		return -ENOMEM;
+	}
+	memset(this->driver.i2c_client, 0, sizeof(struct i2c_client));
+
+	strncpy(this->driver.i2c_client->name, CEC_NAME, I2C_NAME_SIZE);
+	this->driver.i2c_client->addr = TDA99XCEC_I2C_SLAVEADDRESS;
+	this->driver.i2c_client->adapter = client->adapter;
+
+	i2c_set_clientdata(client, this->driver.i2c_client);
+
+	dl_hdmi_cec_get_swversion(&this->cec.sw_version);
+	LOG(KERN_INFO, "HDMI CEC SW version:%ul.%ul compatibility:%ul\n", \
+	    this->cec.sw_version.major_version_nr, \
+	    this->cec.sw_version.minor_version_nr, \
+	    this->cec.sw_version.compatibility_nr);
+
+	/* I2C ok, then let's startup CEC */
+
+	/* prepare event */
+	this->driver.poll_done = true; /* currently idle */
+	init_waitqueue_head(&this->driver.wait);
+#ifndef IRQ
+	init_timer(&this->driver.timer); /* do it before request_irq */
+	this->driver.timer.function = polling_timeout;
+	this->driver.timer.data = 0;
+	this->driver.timer.expires = jiffies + HZ; /* start polling in one sec */
+	add_timer(&this->driver.timer);
+#else
+	register_cec_interrupt((cec_callback_t)cec_interrupt);
+#endif
+
+#ifndef IRQ
+	/* FRO calibration */
+	err = gpio_request(TDA_IRQ_CALIB, "tda19989 calibration");
+	if(err < 0) {
+		printk(KERN_ERR "hdmicec:%s:cannot use GPIO 107\n", __func__);
+		goto i2c_out;
+	}
+	/* turn GPIO into IRQ */
+	gpio_direction_input(TDA_IRQ_CALIB);
+	msleep(1);
+	if(request_irq(gpio_to_irq(TDA_IRQ_CALIB), \
+	               tda_irq, IRQF_TRIGGER_FALLING | IRQF_DISABLED, "TDA IRQ", NULL)) {
+		printk(KERN_ERR "hdmicec:%s:cannot request irq, err:%d\n", __func__, err);
+		gpio_free(TDA_IRQ_CALIB);
+		goto i2c_out;
+	}
+#endif
+
+	err = hdmi_cec_init(this);
+	if(err) goto i2c_out;
+	this->cec.rx_addr = CEC_LOGICAL_ADDRESS_UNREGISTRED_BROADCAST;
+
+	if(get_hpd_status()) {
+		cec_on(this);
+		disable_irq(gpio_to_irq(TDA_IRQ_CALIB));
+		cec_interrupt(NULL); /* initiate polling */
+		enable_irq(gpio_to_irq(TDA_IRQ_CALIB));
+	} else {
+		cec_standby(this);
+	}
+
+	return 0;
+
+i2c_out:
+	LOG(KERN_INFO, "HDMICEC eject: this->driver.i2c_client removed\n");
+	dl_hdmi_cec_close(this->cec.inst);
+	kfree(this->driver.i2c_client);
+	this->driver.i2c_client = NULL;
+
+	return err;
+}
+
+/*
+ *  I2C client :: destroy
+ * */
+static int this_i2c_remove(struct i2c_client *client)
+{
+	cec_instance *this = &our_instance;
+	int err = 0;
+
+	LOG(KERN_INFO, "called\n");
+
+	err = dl_hdmi_cec_close(this->cec.inst);
+
+	if(!client->adapter) {
+		dev_err(&this->driver.i2c_client->dev, "<%s> no CEC device \n",
+		        __func__);
+		return -ENODEV;
+	}
+	kfree(this->driver.i2c_client);
+	this->driver.i2c_client = NULL;
+
+	return err;
+}
+
+/*
+ *  I2C client driver (backend)
+ *  -----------------
+ * */
+static struct i2c_driver this_i2c_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = CEC_NAME,
+	},
+	.probe = this_i2c_probe,
+	 .remove = this_i2c_remove,
+	  .id_table = this_i2c_id,
+   };
+
+/*
+ *  ioctl driver (userland frontend)
+ *  ------------
+ * */
+static struct file_operations this_cdev_fops = {
+owner:
+	THIS_MODULE,
+open:
+	this_cdev_open,
+release:
+	this_cdev_release,
+ioctl:
+	this_cdev_ioctl,
+};
+
+/*
+ *  Module :: start up
+ * */
+static int __init cec_init(void)
+{
+	cec_instance *this = &our_instance;
+	dev_t dev = 0;
+	int err = 0;
+
+	/*
+	 *	   general device context
+	 *	*/
+	memset(this, 0, sizeof(cec_instance));
+	this->param.verbose = param_verbose;
+	this->param.major = param_major;
+	this->param.minor = param_minor;
+
+	/* Hello word */
+	printk(KERN_INFO "%s(%s) %d.%d.%d compiled: %s %s %s\n", HDMICEC_NAME, TDA_NAME, TDA_VERSION_MAJOR,
+	       TDA_VERSION_MINOR, TDA_VERSION_PATCHLEVEL, __DATE__, __TIME__, TDA_VERSION_EXTRA);
+	if(this->param.verbose) LOG(KERN_INFO, ".verbose mode\n");
+
+	/*
+	 *	  plug I2C (backend : Hw interfacing)
+	 *	*/
+	err = i2c_add_driver(&this_i2c_driver);
+	if(err < 0) {
+		printk(KERN_ERR "driver registration failed\n");
+		return -ENODEV;
+	}
+
+	if(this->driver.i2c_client == NULL) {
+		printk(KERN_ERR "this->driver.i2c_client not allocated\n");
+		err = -ENODEV;
+		goto init_out;
+	}
+
+	/*
+	 *	  cdev init (userland frontend)
+	 *	*/
+
+	/* arbitray range of device numbers */
+	if(this->param.major) {
+		/* user force major number @ insmod */
+		dev = MKDEV(this->param.major, this->param.minor);
+		err = register_chrdev_region(dev, MAX_MINOR, HDMICEC_NAME);
+		if(err) {
+			printk(KERN_ERR "unable to register %s, dev=%d %s\n", HDMICEC_NAME, dev, ERR_TO_STR(err));
+			goto init_out;
+		}
+	} else {
+		/* fully dynamic major number */
+		err = alloc_chrdev_region(&dev, this->param.minor, MAX_MINOR, HDMICEC_NAME);
+		if(err) {
+			printk(KERN_ERR "unable to alloc chrdev region for %s, dev=%d %s\n", HDMICEC_NAME, dev, ERR_TO_STR(err));
+			goto init_out;
+		}
+		this->param.major = MAJOR(dev);
+	}
+
+	cdev_init(this_cdev, &this_cdev_fops);
+	this_cdev->owner = THIS_MODULE;
+
+	this->driver.class = class_create(THIS_MODULE, HDMICEC_NAME);
+	if(IS_ERR(this->driver.class)) {
+		printk(KERN_INFO "error creating mmap device class.\n");
+		err = -EIO;
+		goto init_out;
+	}
+	this->driver.dev = device_create(this->driver.class, NULL, dev, NULL, HDMICEC_NAME);
+
+	this->driver.devno = dev;
+	err = cdev_add(this_cdev, this->driver.devno, MAX_MINOR);
+	if(err) {
+		printk(KERN_INFO "unable to add device for %s, ipp_driver.devno=%d %s\n", HDMICEC_NAME, this->driver.devno, ERR_TO_STR(err));
+		device_destroy(this->driver.class, this->driver.devno);
+		class_destroy(this->driver.class);
+		unregister_chrdev_region(this->driver.devno, MAX_MINOR);
+		goto init_out;
+	}
+
+#ifdef TWL4030_HACK
+	/* AL : hack to bypass keypad */
+	gkp_input = get_twm4030_input();
+#endif
+
+	/*
+	 *	   general device context
+	 *	*/
+	init_MUTEX(&this->driver.sem);
+	this->driver.deinit_req = 0;
+
+#if 0
+	/* TEST START */
+	{
+		struct device *dev, *devn;
+		struct kset *dev_kset;
+		int cpt = 0;
+
+		dev_kset = this->driver.dev->kobj.kset;
+		list_for_each_entry_safe_reverse(dev, devn, &dev_kset->list, kobj.entry) {
+			cpt++;
+			if((dev->bus_id[0] == 'h') \
+			   && (dev->bus_id[1] == 'd') \
+			   && (dev->bus_id[2] == 'm') \
+			   && (dev->bus_id[3] == 'i')) {
+				printk("DBG -%s-\n", dev->bus_id);
+			}
+		}
+		printk("DBG get %d devices\n", cpt);
+	}
+	/* TEST STOP */
+#endif
+
+	return 0;
+
+init_out:
+	i2c_del_driver(&this_i2c_driver);
+	return err;
+}
+
+/*
+ *  Module :: shut down
+ * */
+static void __exit cec_exit(void)
+{
+	cec_instance *this = &our_instance;
+
+	LOG(KERN_INFO, "called\n");
+
+#ifndef IRQ
+	free_irq(gpio_to_irq(TDA_IRQ_CALIB), NULL);
+#endif
+
+	unregister_cec_interrupt();
+	this->driver.deinit_req = 1;
+#ifndef IRQ
+	if(wait_event_interruptible(this->driver.wait, this->driver.deinit_req > 1)) {
+		/* oups... just wait... */
+		msleep(CHECK_EVERY_XX_MS * 20);
+	}
+#endif
+
+#ifndef IRQ
+	/* release GPIO */
+	gpio_free(TDA_IRQ_CALIB);
+#endif
+
+	/* unregister cdevice */
+	cdev_del(this_cdev);
+	unregister_chrdev_region(this->driver.devno, MAX_MINOR);
+
+	/* unregister device */
+	device_destroy(this->driver.class, this->driver.devno);
+	class_destroy(this->driver.class);
+
+	/* unregister i2c */
+	i2c_del_driver(&this_i2c_driver);
+
+}
+
+/*
+ *  Module
+ *  ------
+ * */
+/* late_initcall(cec_init); */
+module_init(cec_init);
+module_exit(cec_exit);
+
+/*
+ *  Disclamer
+ *  ---------
+ * */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("andre lepine <andre.lepine@nxp.com>");
+MODULE_DESCRIPTION(HDMICEC_NAME " driver");
diff --git a/drivers/video/hdmi/tda998x_cec.h b/drivers/video/hdmi/tda998x_cec.h
new file mode 100644
index 0000000..4504d12
--- /dev/null
+++ b/drivers/video/hdmi/tda998x_cec.h
@@ -0,0 +1,140 @@
+/*****************************************************************************/
+/* Copyright (c) 2009 NXP Semiconductors BV                                  */
+/*                                                                           */
+/* This program is free software; you can redistribute it and/or modify      */
+/* it under the terms of the GNU General Public License as published by      */
+/* the Free Software Foundation, using version 2 of the License.             */
+/*                                                                           */
+/* This program is distributed in the hope that it will be useful,           */
+/* but WITHOUT ANY WARRANTY; without even the implied warranty of            */
+/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the              */
+/* GNU General Public License for more details.                              */
+/*                                                                           */
+/* You should have received a copy of the GNU General Public License         */
+/* along with this program; if not, write to the Free Software               */
+/* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307       */
+/* USA.                                                                      */
+/*                                                                           */
+/*****************************************************************************/
+
+#ifndef __cec_h__
+#define __cec_h__
+
+#include "tda998x_ioctl.h"
+
+#define HDMICEC_NAME "hdmicec"
+
+#define CEC_MAJOR 234 /* old-style interval of device numbers */
+#define MAX_MINOR 1 /* 1 minor but 2 access : 1 more for pooling */
+
+/* common I2C define with kernel */
+/* should be the same as arch/arm/mach-omap2/board-zoom2.c */
+#define CEC_NAME "tda99Xcec"
+#define TDA99XCEC_I2C_SLAVEADDRESS 0x34
+
+/* On gplugD GPIO # 36 is connected to CEC interrupt line */
+#define TDA_IRQ_CALIB 36
+#define POLLING_LENGTH 3
+
+#define EDID_BLOCK_COUNT    4
+#define EDID_BLOCK_SIZE     128
+
+#ifdef GPL
+#define CHECK_EVERY_XX_MS 500 /* ms */
+#else
+#define CHECK_EVERY_XX_MS 10 /* ms */
+#endif
+
+#define LOG(type,fmt,args...) {if (this->param.verbose) {printk(type HDMICEC_NAME":%s:" fmt, __func__, ## args);}}
+/* not found the kernel "strerror" one! If someone knows, please replace it */
+#define ERR_TO_STR(e)((e == -ENODATA)?"ENODATA, no data available":\
+                      (e == -ENOMEM)? "ENOMEM, no memory available":\
+                      (e == -EINVAL)? "EINVAL, invalid argument":\
+                      (e == -EIO)? "EIO, input/output error":\
+                      (e == -ETIMEDOUT)? "ETIMEOUT, timeout has expired":\
+                      (e == -EBUSY)? "EBUSY, device or resource busy":\
+                      (e == -ENOENT)? "ENOENT, no such file or directory":\
+                      (e == -EACCES)? "EACCES, permission denied":\
+                      (e == 0)?       "":\
+                      "!UNKNOWN!")
+
+#define TRY(fct) do { \
+		err=(fct); \
+		if (err) { \
+			printk(KERN_ERR "%s? in %s line %d\n",hdmi_cec_err_string(err),__func__,__LINE__); \
+			goto TRY_DONE; \
+		} \
+	}while(0)
+
+typedef void (*cec_callback_t)(struct work_struct *dummy);
+
+typedef struct {
+	/* module params */
+	struct {
+		int verbose;
+		int major;
+		int minor;
+	} param;
+	/* driver */
+	struct {
+		struct class *class;
+		struct device *dev;
+		int devno;
+		struct i2c_client *i2c_client;
+		struct semaphore sem;
+		int user_counter;
+		int minor;
+		wait_queue_head_t wait;
+		bool poll_done;
+		int deinit_req;
+		struct timer_list timer;
+	} driver;
+	/* cec */
+	struct {
+		int inst;
+		unsigned char rx_addr;
+		unsigned short phy_addr;
+		unsigned char initiator;
+		cec_version version;
+		cec_sw_version sw_version;
+		cec_power power;
+		cec_setup setup;
+		cec_clock clock;
+		cec_analogue_timer analog_timer;
+		cec_digital_timer digital_timer;
+		cec_ext_timer_with_ext_plug etwep;
+		cec_ext_timer_with_phy_addr etwpa;
+		cec_deck_ctrl deck_ctrl;
+		cec_deck_status deck_status;
+		unsigned long vendor_id;
+		cec_feature_abort feature_abort;
+		cec_status_request satus_request;
+		cec_menu_request menu_request;
+		cec_menu_status menu_status;
+		cec_play play;
+		cec_analogue_service analog_service;
+		cec_digital_service digital_service;
+		cec_ext_plug ext_plug;
+		cec_rec_status rec_status;
+		cec_audio_status audio_status;
+		cec_device_type device_type;
+		cec_power_status source_status;
+		cec_audio_rate audio_rate;
+		cec_sys_audio_status sys_audio_status;
+		cec_timer_cleared_status timer_cleared_status;
+		cec_timer_status timer_status;
+		cec_tuner_device_status_analogue tdsa;
+		cec_tuner_device_status_digital tdsd;
+		cec_user_ctrl user_ctrl;
+		unsigned char select;
+		cec_user_ctrl_tune user_ctrl_tune;
+		cec_frame frame;
+		bool byebye;
+		cec_string string;
+		cec_string osd_name;
+		cec_osd_string osd_string;
+		cec_vendor_command_with_id vcwi;
+	} cec;
+} cec_instance;
+
+#endif /* __cec_h__ */
diff --git a/drivers/video/hdmi/tda998x_ioctl.h b/drivers/video/hdmi/tda998x_ioctl.h
new file mode 100644
index 0000000..fc8f3c9
--- /dev/null
+++ b/drivers/video/hdmi/tda998x_ioctl.h
@@ -0,0 +1,1142 @@
+/**
+ * Copyright (C) 2006 NXP N.V., All Rights Reserved.
+ * This source code and any compilation or derivative thereof is the proprietary
+ * information of NXP N.V. and is confidential in nature. Under no circumstances
+ * is this software to be  exposed to or placed under an Open Source License of
+ * any type without the expressed written permission of NXP N.V.
+ *
+ * Version       Revision: 1.0
+ *
+ * Date          Date: 27/10/09
+ *
+ * Brief         API for the TDA1998x HDMI Transmitters
+ *
+ **/
+
+#include <linux/types.h>
+
+#ifndef __tx_ioctl__
+#define __tx_ioctl__
+
+#ifdef __tx_h__
+
+#define TRANS_TYPE 1
+
+#if TRANS_TYPE
+
+#define EXAMPLE_MAX_SVD 30
+
+/*
+ *  trans-type
+ * */
+typedef swversion_t tda_version;
+typedef power_state_t tda_power;
+typedef tx_instance_setup_info_t tda_setup;
+typedef tx_capabilities_t tda_capabilities;
+typedef tx_video_out_config_t tda_video_out;
+typedef tx_video_in_config_t tda_video_in;
+typedef tx_sink_type_t tda_sink;
+typedef tx_audio_in_config_t tda_audio_in;
+typedef tx_edid_audio_desc_t tda_edid_audio_desc;
+typedef tx_short_vid_desc_t tda_edid_video_desc;
+typedef tx_event_t tda_event;
+typedef tx_instance_setup_info_t tda_setup_info;
+typedef tx_edid_video_timings_t tda_edid_video_timings;
+typedef tx_pict_aspect_ratio_t tda_edid_tv_aspect_ratio;
+typedef tx_hdcp_check_t tda_hdcp_status;
+#if defined (TMFL_TDA19989) || defined (TMFL_TDA9984)
+typedef tx_hdcp_status_t tda_hdcp_fail;
+#endif
+#ifdef TMFL_TDA19989
+typedef tx_edid_latency_t tda_edid_latency;
+#endif
+
+typedef struct {
+	bool enable;
+	tx_gamut_data_t data;
+} tda_gammut;
+
+typedef struct {
+	bool enable;
+	tx_vs_pkt_data_t data;
+} tda_vs_infoframe;
+
+typedef struct {
+	bool enable;
+	tx_spd_if_data_t data;
+} tda_spd_infoframe;
+
+typedef struct {
+	bool enable;
+	tx_mps_if_data_t data;
+} tda_mps_infoframe;
+
+typedef struct {
+	bool enable;
+	tx_isrc1pkt_data_t data;
+} tda_isrc1;
+
+typedef struct {
+	bool enable;
+	tx_isrc2pkt_data_t data;
+} tda_isrc2;
+
+typedef struct {
+	bool enable;
+	tx_acp_pkt_data_t data;
+} tda_acp;
+
+typedef struct {
+	bool enable;
+	tx_gcp_pkt_data_t data;
+} tda_gcp;
+
+typedef struct {
+	bool enable;
+	tx_avi_if_data_t data;
+} tda_video_infoframe;
+
+typedef struct {
+	bool enable;
+	tx_aud_if_data_t data;
+} tda_audio_infoframe;
+
+typedef struct {
+	tx_vid_fmt_t id;
+	tx_vid_fmt_specs_t spec;
+} tda_video_format;
+
+typedef struct {
+	tda_video_in video_in;
+	tda_video_out video_out;
+	tda_audio_in audio_in; /* Mind tda_set_audio_in if you change this */
+	tda_sink sink; /* Mind tda_set_audio_in if you change this */
+} tda_set_in_out;
+
+typedef struct {
+	tda_audio_in audio_in;
+	tda_sink sink;
+} tda_set_audio_in;
+
+typedef struct {
+	tda_edid_audio_desc desc[EXAMPLE_MAX_SVD];
+	unsigned int max;
+	unsigned int written;
+	unsigned char flags;
+} tda_edid_audio_caps;
+
+typedef struct {
+	tda_edid_video_desc desc[EXAMPLE_MAX_SVD];
+	unsigned int max;
+	unsigned int written;
+	unsigned char flags;
+} tda_edid_video_caps;
+
+typedef struct {
+	tx_edid_status_t status;
+	unsigned char block_count;
+} tda_edid;
+
+typedef struct {
+	tx_edid_video_timings_t desc[EXAMPLE_MAX_SVD];
+	unsigned char max;
+	unsigned char written;
+} tda_edid_dtd;
+
+typedef struct {
+	tx_edid_first_md_t desc1[EXAMPLE_MAX_SVD];
+	tx_edid_second_md_t desc2[EXAMPLE_MAX_SVD];
+	tx_edid_other_md_t other[EXAMPLE_MAX_SVD];
+	unsigned char max;
+	unsigned char written;
+} tda_edid_md;
+
+#else
+
+#error do not compiled this !
+
+typedef enum {
+	/**< HDCP encryption status switched to active */
+	TDA_HDCP_ACTIVE         = 0,
+	/**< HDCP encryption status switched to inactive */
+	TDA_HDCP_INACTIVE       = 1,
+	TDA_HPD_ACTIVE          = 2,    /**< Hotplug status switched to active */
+	TDA_HPD_INACTIVE        = 3,    /**< Hotplug status switched to inactive */
+	TDA_RX_KEYS_RECEIVED    = 4,    /**< Receiver(s) key(s) received */
+	TDA_RX_DEVICE_ACTIVE    = 5,    /**< Rx device is connected and active */
+	/**< Rx device is connected but inactive (standby) */
+	TDA_RX_DEVICE_INACTIVE  = 6,
+	TDA_EDID_RECEIVED       = 7,    /**< EDID has been received */
+	TDA_VS_RPT_RECEIVED     = 8,    /**< VS interrupt has been received */
+#ifdef HDMI_TX_REPEATER_ISR_MODE
+	TDA_B_STATUS            = 9,    /**< TX received BStatus */
+#endif /* HDMI_TX_REPEATER_ISR_MODE */
+	TDA_DEBUG_EVENT_1       = 10     /**< This is a debug event */
+} tda_event;
+
+typedef struct {
+	unsigned char format;         /* EIA/CEA861 mode */
+	unsigned char channels;       /* number of channels */
+	unsigned char supported_freqs; /* bitmask of supported frequencies */
+	/* bitmask of supported resolutions (LPCM only) */
+	unsigned char supported_res;
+	/* Maximum bitrate divided by 8KHz (compressed formats only) */
+	unsigned char max_bitrate;
+} tda_edid_audio_desc;
+
+typedef enum {
+	TDA_EDID_READ                = 0,   /**< All blocks read OK */
+	/**< All blocks read OK but buffer too small to return all of them */
+	TDA_EDID_READ_INCOMPLETE     = 1,
+	TDA_EDID_ERROR_CHK_BLOCK_0   = 2,   /**< Block 0 checksum error */
+	/**< Block 0 OK, checksum error in one or more other blocks */
+	TDA_EDID_ERROR_CHK           = 3,
+	TDA_EDID_NOT_READ            = 4,   /**< EDID not read */
+	TDA_EDID_STATUS_INVALID      = 5    /**< Invalid   */
+} tda_edid_status;
+
+typedef struct {
+	int HBR;              /**< High Bitrate Audio packet */
+	int DST;              /**< Direct Stream Transport audio packet */
+	int one_bit_audio;      /**< One Bit Audio sample packet */
+} tda_audio_packet;
+
+typedef enum {
+	TDA_AFMT_SPDIF      = 0, /**< SPDIF */
+	TDA_AFMT_I2S        = 1, /**< I2S */
+	TDA_AFMT_OBA        = 2, /**< One bit audio / DSD */
+	TDA_AFMT_DST        = 3, /**< DST */
+	TDA_AFMT_HBR        = 4  /**< HBR */
+} tda_audio_format;
+
+typedef enum {
+	TDA_AFS_32K           = 0, /**< 32kHz    */
+	TDA_AFS_44K           = 1, /**< 44.1kHz  */
+	TDA_AFS_48K           = 2, /**< 48kHz    */
+	TDA_AFS_88K           = 3, /**< 88.2kHz  */
+	TDA_AFS_96K           = 4, /**< 96kHz    */
+	TDA_AFS_176K          = 5, /**< 176.4kHz */
+	TDA_AFS_192K          = 6  /**< 192kHz   */
+} tda_audio_rate;
+
+typedef enum {
+	TDA_I2SQ_16BITS       = 16, /**< 16 bits */
+	TDA_I2SQ_32BITS       = 32, /**< 32 bits */
+	TDA_I2SQ_OTHERS       = 0   /**< for SPDIF and DSD */
+} tda_audio_i2s_qualifier;
+
+typedef enum {
+	TDA_I2SFOR_PHILIPS_L   = 0,	/**< Philips like format */
+	TDA_I2SFOR_OTH_L       = 2,	/**< Other non Philips left justified */
+	TDA_I2SFOR_OTH_R	   = 3,	/**< Other non Philips right justified */
+	TDA_I2SFOR_INVALID     = 4	/**< Invalid format */
+} tda_audio_i2s_format;
+
+typedef enum {
+	TDA_DSTRATE_SINGLE  = 0,    /**< Single transfer rate */
+	TDA_DSTRATE_DOUBLE  = 1     /**< Double data rate */
+} tda_dst_rate;
+
+typedef struct {
+	int    simplay_hd;          /**< Enable simplayHD support */
+	int    repeater_enable;     /**< Enable repeater mode */
+	unsigned char   *p_edid_buffer;       /**< Pointer to raw EDID data */
+	/**< Size of buffer for raw EDID data */
+	unsigned long  edid_buffer_size;
+} tda_instance_setup_info;
+
+typedef enum {
+	TDA_VFMT_NULL               = 0,    /**< Not a valid format...        */
+	TDA_VFMT_NO_CHANGE          = 0,    /**< ...or no change required     */
+	TDA_VFMT_MIN                = 1,    /**< Lowest valid format          */
+	TDA_VFMT_TV_MIN             = 1,    /**< Lowest valid TV format       */
+	tda_vfmt_01_640x480p_60hz   = 1,    /**< Format 01 640  x 480p  60Hz  */
+	tda_vfmt_02_720x480p_60hz   = 2,    /**< Format 02 720  x 480p  60Hz  */
+	tda_vfmt_03_720x480p_60hz   = 3,    /**< Format 03 720  x 480p  60Hz  */
+	tda_vfmt_04_1280x720p_60hz  = 4,    /**< Format 04 1280 x 720p  60Hz  */
+	tda_vfmt_05_1920x1080i_60hz = 5,    /**< Format 05 1920 x 1080i 60Hz  */
+	tda_vfmt_06_720x480i_60hz   = 6,    /**< Format 06 720  x 480i  60Hz  */
+	tda_vfmt_07_720x480i_60hz   = 7,    /**< Format 07 720  x 480i  60Hz  */
+	tda_vfmt_08_720x240p_60hz   = 8,    /**< Format 08 720  x 240p  60Hz  */
+	tda_vfmt_09_720x240p_60hz   = 9,    /**< Format 09 720  x 240p  60Hz  */
+	tda_vfmt_10_720x480i_60hz   = 10,   /**< Format 10 720  x 480i  60Hz  */
+	tda_vfmt_11_720x480i_60hz   = 11,   /**< Format 11 720  x 480i  60Hz  */
+	tda_vfmt_12_720x240p_60hz   = 12,   /**< Format 12 720  x 240p  60Hz  */
+	tda_vfmt_13_720x240p_60hz   = 13,   /**< Format 13 720  x 240p  60Hz  */
+	tda_vfmt_14_1440x480p_60hz  = 14,   /**< Format 14 1440 x 480p  60Hz  */
+	tda_vfmt_15_1440x480p_60hz  = 15,   /**< Format 15 1440 x 480p  60Hz  */
+	tda_vfmt_16_1920x1080p_60hz = 16,   /**< Format 16 1920 x 1080p 60Hz  */
+	tda_vfmt_17_720x576p_50hz   = 17,   /**< Format 17 720  x 576p  50Hz  */
+	tda_vfmt_18_720x576p_50hz   = 18,   /**< Format 18 720  x 576p  50Hz  */
+	tda_vfmt_19_1280x720p_50hz  = 19,   /**< Format 19 1280 x 720p  50Hz  */
+	tda_vfmt_20_1920x1080i_50hz = 20,   /**< Format 20 1920 x 1080i 50Hz  */
+	tda_vfmt_21_720x576i_50hz   = 21,   /**< Format 21 720  x 576i  50Hz  */
+	tda_vfmt_22_720x576i_50hz   = 22,   /**< Format 22 720  x 576i  50Hz  */
+	tda_vfmt_23_720x288p_50hz   = 23,   /**< Format 23 720  x 288p  50Hz  */
+	tda_vfmt_24_720x288p_50hz   = 24,   /**< Format 24 720  x 288p  50Hz  */
+	tda_vfmt_25_720x576i_50hz   = 25,   /**< Format 25 720  x 576i  50Hz  */
+	tda_vfmt_26_720x576i_50hz   = 26,   /**< Format 26 720  x 576i  50Hz  */
+	tda_vfmt_27_720x288p_50hz   = 27,   /**< Format 27 720  x 288p  50Hz  */
+	tda_vfmt_28_720x288p_50hz   = 28,   /**< Format 28 720  x 288p  50Hz  */
+	tda_vfmt_29_1440x576p_50hz  = 29,   /**< Format 29 1440 x 576p  50Hz  */
+	tda_vfmt_30_1440x576p_50hz  = 30,   /**< Format 30 1440 x 576p  50Hz  */
+	tda_vfmt_31_1920x1080p_50hz = 31,   /**< Format 31 1920 x 1080p 50Hz  */
+	tda_vfmt_32_1920x1080p_24hz = 32,   /**< Format 32 1920 x 1080p 24Hz  */
+	tda_vfmt_33_1920x1080p_25hz = 33,   /**< Format 33 1920 x 1080p 25Hz  */
+	tda_vfmt_34_1920x1080p_30hz = 34,   /**< Format 34 1920 x 1080p 30Hz  */
+	TDA_VFMT_TV_MAX             = 34,   /**< Highest valid TV format      */
+	/**< Lowest TV format without prefetched table */
+	TDA_VFMT_TV_NO_REG_MIN      = 32,
+	TDA_VFMT_TV_NUM             = 35,   /**< Number of TV formats & null  */
+	TDA_VFMT_PC_MIN             = 128,  /**< Lowest valid PC format       */
+	tda_vfmt_pc_640x480p_60hz   = 128,  /**< PC format 128                */
+	tda_vfmt_pc_800x600p_60hz   = 129,  /**< PC format 129                */
+	tda_vfmt_pc_1152x960p_60hz  = 130,  /**< PC format 130                */
+	tda_vfmt_pc_1024x768p_60hz  = 131,  /**< PC format 131                */
+	tda_vfmt_pc_1280x768p_60hz  = 132,  /**< PC format 132                */
+	tda_vfmt_pc_1280x1024p_60hz = 133,  /**< PC format 133                */
+	tda_vfmt_pc_1360x768p_60hz  = 134,  /**< PC format 134                */
+	tda_vfmt_pc_1400x1050p_60hz = 135,  /**< PC format 135                */
+	tda_vfmt_pc_1600x1200p_60hz = 136,  /**< PC format 136                */
+	tda_vfmt_pc_1024x768p_70hz  = 137,  /**< PC format 137                */
+	tda_vfmt_pc_640x480p_72hz   = 138,  /**< PC format 138                */
+	tda_vfmt_pc_800x600p_72hz   = 139,  /**< PC format 139                */
+	tda_vfmt_pc_640x480p_75hz   = 140,  /**< PC format 140                */
+	tda_vfmt_pc_1024x768p_75hz  = 141,  /**< PC format 141                */
+	tda_vfmt_pc_800x600p_75hz   = 142,  /**< PC format 142                */
+	tda_vfmt_pc_1024x864p_75hz  = 143,  /**< PC format 143                */
+	tda_vfmt_pc_1280x1024p_75hz = 144,  /**< PC format 144                */
+	tda_vfmt_pc_640x350p_85hz   = 145,  /**< PC format 145                */
+	tda_vfmt_pc_640x400p_85hz   = 146,  /**< PC format 146                */
+	tda_vfmt_pc_720x400p_85hz   = 147,  /**< PC format 147                */
+	tda_vfmt_pc_640x480p_85hz   = 148,  /**< PC format 148                */
+	tda_vfmt_pc_800x600p_85hz   = 149,  /**< PC format 149                */
+	tda_vfmt_pc_1024x768p_85hz  = 150,  /**< PC format 150                */
+	tda_vfmt_pc_1152x864p_85hz  = 151,  /**< PC format 151                */
+	tda_vfmt_pc_1280x960p_85hz  = 152,  /**< PC format 152                */
+	tda_vfmt_pc_1280x1024p_85hz = 153,  /**< PC format 153                */
+	tda_vfmt_pc_1024x768i_87hz  = 154,  /**< PC format 154                */
+	TDA_VFMT_PC_MAX             = 154,  /**< Highest valid PC format      */
+	/**< Number of PC formats         */
+	TDA_VFMT_PC_NUM             = (1 + 154 - 128)
+} tda_video_fmt_id;
+
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tda_video_fmt_id video_format;
+	/**< true if format is the preferred video format */
+	int              native_video_format;
+} tda_edid_video_desc;
+
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tda_video_fmt_id video_format;
+	/**< true if format is the preferred video format */
+	int              native_video_format;
+} tda_short_video_desc;
+
+typedef enum {
+	/**< Undefined picture aspect ratio */
+	TDA_P_ASPECT_RATIO_UNDEFINED    = 0,
+	/**< 6:5 picture aspect ratio (PAR) */
+	TDA_P_ASPECT_RATIO_6_5          = 1,
+	TDA_P_ASPECT_RATIO_5_4          = 2,    /**< 5:4 PAR */
+	TDA_P_ASPECT_RATIO_4_3          = 3,    /**< 4:3 PAR */
+	TDA_P_ASPECT_RATIO_16_10        = 4,    /**< 16:10 PAR */
+	TDA_P_ASPECT_RATIO_5_3          = 5,    /**< 5:3 PAR */
+	TDA_P_ASPECT_RATIO_16_9         = 6,    /**< 16:9 PAR */
+	TDA_P_ASPECT_RATIO_9_5          = 7     /**< 9:5 PAR */
+} tda_pict_aspect_ratio;
+
+typedef enum {
+	tda_vfreq_24hz      = 0,    /**< 24Hz          */
+	tda_vfreq_25hz      = 1,    /**< 25Hz          */
+	tda_vfreq_30hz      = 2,    /**< 30Hz          */
+	tda_vfreq_50hz      = 3,    /**< 50Hz          */
+	tda_vfreq_59hz      = 4,    /**< 59.94Hz       */
+	tda_vfreq_60hz      = 5,    /**< 60Hz          */
+	tda_vfreq_70hz      = 6,    /**< 70Hz          */
+	tda_vfreq_72hz      = 7,    /**< 72Hz          */
+	tda_vfreq_75hz      = 8,    /**< 75Hz          */
+	tda_vfreq_85hz      = 9,    /**< 85Hz          */
+	tda_vfreq_87hz      = 10,   /**< 87Hz          */
+	TDA_VFREQ_INVALID   = 11,   /**< Invalid       */
+	TDA_VFREQ_NUM       = 11    /**< No. of values */
+} tda_vfreq;
+
+typedef struct {
+	/**< Width of the frame in pixels */
+	unsigned short                      width;
+	/**< Height of the frame in pixels */
+	unsigned short                      height;
+	/**< Interlaced mode (true/false) */
+	int                        interlaced;
+	tda_vfreq           vfrequency;    /**< Vertical frequency in Hz */
+	tda_pict_aspect_ratio aspect_ratio;   /**< Picture aspect ratio (H:V) */
+} tda_video_fmt_specs;
+
+typedef enum {
+	TDA_VINMODE_CCIR656     = 0,    /**< CCIR656 */
+	TDA_VINMODE_RGB444      = 1,    /**< RGB444  */
+	TDA_VINMODE_YUV444      = 2,    /**< YUV444  */
+	TDA_VINMODE_YUV422      = 3,    /**< YUV422  */
+	TDA_VINMODE_NO_CHANGE   = 4,    /**< No change */
+	TDA_VINMODE_INVALID     = 5     /**< Invalid */
+} tda_vinmode;
+
+typedef enum {
+	TDA_SYNCSRC_EMBEDDED = 0, /**< Embedded sync */
+	TDA_SYNCSRC_EXT_VREF = 1, /**< External sync Vref, Href, Fref */
+	TDA_SYNCSRC_EXT_VS   = 2  /**< External sync Vs, Hs */
+} tda_sync_source;
+
+typedef enum {
+	TDA_PIXRATE_DOUBLE          = 0,        /**< Double pixel rate */
+	TDA_PIXRATE_SINGLE          = 1,        /**< Single pixel rate */
+	TDA_PIXRATE_SINGLE_REPEATED = 2         /**< Single pixel repeated */
+} tda_pix_rate;
+
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tda_video_fmt_id       format;
+	tda_vinmode      mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
+	tda_sync_source   sync_source; /**< Sync source type */
+	tda_pix_rate      pixel_rate;  /**< Pixel rate */
+} tda_video_in;
+
+typedef enum {
+	TDA_VOUTMODE_RGB444     = 0,    /**< RGB444    */
+	TDA_VOUTMODE_YUV422     = 1,    /**< YUV422    */
+	TDA_VOUTMODE_YUV444     = 2     /**< YUV444    */
+} tda_vout_mode;
+
+typedef enum {
+	TDA_VQR_DEFAULT = 0, /* Follow HDMI spec. */
+	TDA_RGB_FULL    = 1, /* Force RGB FULL , DVI only */
+	TDA_RGB_LIMITED = 2  /* Force RGB LIMITED , DVI only */
+} tda_vqr;
+
+typedef enum {
+	TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
+	TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
+	TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
+	TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
+} tda_color_depth;
+
+typedef struct {
+	/**< Video format as defined by EIA/CEA 861-D */
+	tda_video_fmt_id       format;
+	tda_vout_mode     mode;       /**< Video mode (CCIR, RGB, YUV, etc.) */
+	tda_color_depth  color_depth; /**< Color depth */
+	tda_vqr          dvi_vqr;     /**< VQR applied in DVI mode */
+} tda_video_out;
+
+typedef struct {
+	/**< Audio format (I2S, SPDIF, etc.) */
+	tda_audio_format          format;
+	tda_audio_rate            rate;               /**< Audio sampling rate */
+	/**< I2S format of the audio input */
+	tda_audio_i2s_format       i2s_format;
+	/**< I2S qualifier of the audio input (8,16,32 bits) */
+	tda_audio_i2s_qualifier    i2s_qualifier;
+	/**< DST data transfer rate */
+	tda_dst_rate              dst_rate;
+	/**< Ref to CEA-861D p85 */
+	unsigned char                            channel_allocation;
+} tda_audio_in;
+
+typedef enum {
+	TDA_SINK_DVI  = 0, /**< DVI  */
+	TDA_SINK_HDMI = 1, /**< HDMI */
+	TDA_SINK_EDID = 2  /**< As currently defined in EDID */
+} tda_sink;
+
+typedef enum {
+	TDA_DEVICE_UNKNOWN,   /**< HW device is unknown */
+	TDA_DEVICE_TDA9984,   /**< HW device is IC TDA9984 */
+	TDA_DEVICE_TDA9989,   /**< HW device is IC TDA9989 */
+	TDA_DEVICE_TDA9981,   /**< HW device is IC TDA9981 */
+	TDA_DEVICE_TDA9983,   /**< HW device is IC TDA9983 */
+	TDA_DEVICE_TDA19989   /**< HW device is IC TDA19989 */
+} tda_device_version;
+
+typedef enum {
+	TDA_HDMI_VERSION_UNKNOWN, /**< Unknown   */
+	TDA_HDMI_VERSION_1_1,     /**< HDMI 1.1  */
+	tda_hdmi_version_1_2a,    /**< HDMI 1.2a */
+	tda_hdmi_version_1_3a     /**< HDMI 1.3  */
+} tda_hdmi_version;
+
+typedef struct {
+	int HBR;              /**< High Bitrate Audio packet */
+	int DST;              /**< Direct Stream Transport audio packet */
+	int one_bit_audio;      /**< One Bit Audio sample packet */
+} tda_audio_packet;
+
+typedef enum {
+	TDA_COLORDEPTH_24   = 0,    /**< 8 bits per color */
+	TDA_COLORDEPTH_30   = 1,    /**< 10 bits per color */
+	TDA_COLORDEPTH_36   = 2,    /**< 12 bits per color */
+	TDA_COLORDEPTH_48   = 3     /**< 16 bits per color */
+} tda_color_depth;
+
+typedef struct {
+	tda_device_version device_version;  /**< HW device version */
+	tda_hdmi_version hdmi_version;    /**< Supported HDMI standard version  */
+	tda_audio_packet audio_packet;    /**< Supported audio packets */
+	tda_color_depth color_depth;     /**< Supported color depth */
+	int hdcp;           /**< Supported Hdcp encryption (true/false) */
+	int scaler;         /**< Supported scaler (true/false) */
+} tda_capabilities;
+
+typedef struct {
+	unsigned long compatibility_nr;        /* Interface compatibility number */
+	/* Interface major version number */
+	unsigned long major_version_nr;
+	/* Interface minor version number */
+	unsigned long minor_version_nr;
+} tda_version;
+
+typedef enum {
+	power_on,                          /* Device powered on      (D0 state) */
+	power_standby,                     /* Device power standby   (D1 state) */
+	power_suspend,                     /* Device power suspended (D2 state) */
+	power_off                          /* Device powered off     (D3 state) */
+} tda_power_xxx;
+
+typedef struct {
+	unsigned int simplay_hd;          /**< Enable simplayHD support */
+	unsigned int repeater_enable;     /**< Enable repeater mode */
+	unsigned char *p_edid_buffer;       /**< Pointer to raw EDID data */
+	/**< Size of buffer for raw EDID data */
+	unsigned long edid_buffer_size;
+} tda_setup;
+
+typedef struct {
+	tda_video_fmt_id id;
+	tda_video_fmt_specs spec;
+} tda_video_format;
+
+typedef struct {
+	tda_video_in video_in;
+	tda_video_out video_out;
+	tda_audio_in audio_in;
+} tda_set_in_out;
+
+typedef struct {
+	tda_edid_audio_desc desc;
+	unsigned int max;
+	unsigned int written;
+	unsigned char flags;
+} tda_edid_audio_caps;
+
+typedef struct {
+	tda_edid_video_desc desc;
+	unsigned int max;
+	unsigned int written;
+	unsigned char flags;
+} tda_edid_video_caps;
+
+typedef struct {
+	tda_edid_status status;
+	unsigned char block_count;
+} tda_edid;
+
+#endif
+
+#define TDA_IOCTL_BASE 0x40
+#define RELEASE 0xFF
+
+enum {
+	/* driver specific */
+	TDA_VERBOSE_ON_CMD = 0,
+	TDA_VERBOSE_OFF_CMD,
+	TDA_BYEBYE_CMD,
+	/* HDMI Tx */
+	TDA_GET_SW_VERSION_CMD,
+	TDA_SET_POWER_CMD,
+	TDA_GET_POWER_CMD,
+	TDA_SETUP_CMD,
+	TDA_GET_SETUP_CMD,
+	TDA_WAIT_EVENT_CMD,
+	TDA_ENABLE_EVENT_CMD,
+	TDA_DISABLE_EVENT_CMD,
+	TDA_GET_VIDEO_SPEC_CMD,
+	TDA_SET_INPUT_OUTPUT_CMD,
+	TDA_SET_AUDIO_INPUT_CMD,
+	TDA_SET_VIDEO_INFOFRAME_CMD,
+	TDA_SET_AUDIO_INFOFRAME_CMD,
+	TDA_SET_ACP_CMD,
+	TDA_SET_GCP_CMD,
+	TDA_SET_ISRC1_CMD,
+	TDA_SET_ISRC2_CMD,
+	TDA_SET_MPS_INFOFRAME_CMD,
+	TDA_SET_SPD_INFOFRAME_CMD,
+	TDA_SET_VS_INFOFRAME_CMD,
+	TDA_SET_AUDIO_MUTE_CMD,
+	TDA_RESET_AUDIO_CTS_CMD,
+	TDA_GET_EDID_STATUS_CMD,
+	TDA_GET_EDID_AUDIO_CAPS_CMD,
+	TDA_GET_EDID_VIDEO_CAPS_CMD,
+	TDA_GET_EDID_VIDEO_PREF_CMD,
+	TDA_GET_EDID_SINK_TYPE_CMD,
+	TDA_GET_EDID_SOURCE_ADDRESS_CMD,
+	TDA_SET_GAMMUT_CMD,
+	TDA_GET_EDID_DTD_CMD,
+	TDA_GET_EDID_MD_CMD,
+	TDA_GET_EDID_TV_ASPECT_RATIO_CMD,
+	TDA_GET_EDID_LATENCY_CMD,
+	TDA_SET_HDCP_CMD,
+	TDA_GET_HDCP_STATUS_CMD,
+};
+
+/* driver specific */
+#define TDA_IOCTL_VERBOSE_ON     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_ON_CMD)
+#define TDA_IOCTL_VERBOSE_OFF     _IO(TDA_IOCTL_BASE, TDA_VERBOSE_OFF_CMD)
+#define TDA_IOCTL_BYEBYE     _IO(TDA_IOCTL_BASE, TDA_BYEBYE_CMD)
+/* HDMI Tx */
+#define TDA_IOCTL_GET_SW_VERSION     _IOWR(TDA_IOCTL_BASE, TDA_GET_SW_VERSION_CMD,tda_version)
+#define TDA_IOCTL_SET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_SET_POWER_CMD,tda_power)
+#define TDA_IOCTL_GET_POWER     _IOWR(TDA_IOCTL_BASE, TDA_GET_POWER_CMD,tda_power)
+#define TDA_IOCTL_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_SETUP_CMD,tda_setup_info)
+#define TDA_IOCTL_GET_SETUP     _IOWR(TDA_IOCTL_BASE, TDA_GET_SETUP_CMD,tda_setup_info)
+#define TDA_IOCTL_WAIT_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_WAIT_EVENT_CMD,tda_event)
+#define TDA_IOCTL_ENABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_ENABLE_EVENT_CMD,tda_event)
+#define TDA_IOCTL_DISABLE_EVENT     _IOWR(TDA_IOCTL_BASE, TDA_DISABLE_EVENT_CMD,tda_event)
+#define TDA_IOCTL_GET_VIDEO_SPEC     _IOWR(TDA_IOCTL_BASE, TDA_GET_VIDEO_SPEC_CMD,tda_video_format)
+#define TDA_IOCTL_SET_INPUT_OUTPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_INPUT_OUTPUT_CMD,tda_set_in_out)
+#define TDA_IOCTL_SET_AUDIO_INPUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INPUT_CMD,tda_audio_in)
+#define TDA_IOCTL_SET_VIDEO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VIDEO_INFOFRAME_CMD,tda_video_infoframe)
+#define TDA_IOCTL_SET_AUDIO_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_INFOFRAME_CMD,tda_audio_infoframe)
+#define TDA_IOCTL_SET_ACP     _IOWR(TDA_IOCTL_BASE, TDA_SET_ACP_CMD,tda_acp)
+#define TDA_IOCTL_SET_GCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_GCP_CMD,tda_gcp)
+#define TDA_IOCTL_SET_ISRC1     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC1_CMD,tda_isrc1)
+#define TDA_IOCTL_SET_ISRC2     _IOWR(TDA_IOCTL_BASE, TDA_SET_ISRC2_CMD,tda_isrc2)
+#define TDA_IOCTL_SET_MPS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_MPS_INFOFRAME_CMD,tda_mps_infoframe)
+#define TDA_IOCTL_SET_SPD_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_SPD_INFOFRAME_CMD,tda_spd_infoframe)
+#define TDA_IOCTL_SET_VS_INFOFRAME     _IOWR(TDA_IOCTL_BASE, TDA_SET_VS_INFOFRAME_CMD,tda_vs_infoframe)
+#define TDA_IOCTL_SET_AUDIO_MUTE     _IOWR(TDA_IOCTL_BASE, TDA_SET_AUDIO_MUTE_CMD,bool)
+#define TDA_IOCTL_RESET_AUDIO_CTS     _IO(TDA_IOCTL_BASE, TDA_RESET_AUDIO_CTS_CMD)
+#define TDA_IOCTL_GET_EDID_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_STATUS_CMD,tda_edid)
+#define TDA_IOCTL_GET_EDID_AUDIO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_AUDIO_CAPS_CMD,tda_edid_audio_caps)
+#define TDA_IOCTL_GET_EDID_VIDEO_CAPS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_CAPS_CMD,tda_edid_video_caps)
+#define TDA_IOCTL_GET_EDID_VIDEO_PREF     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_VIDEO_PREF_CMD,tda_edid_video_timings)
+#define TDA_IOCTL_GET_EDID_SINK_TYPE     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SINK_TYPE_CMD,tda_sink)
+#define TDA_IOCTL_GET_EDID_SOURCE_ADDRESS     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_SOURCE_ADDRESS_CMD,unsigned short)
+#define TDA_IOCTL_SET_GAMMUT     _IOWR(TDA_IOCTL_BASE, TDA_SET_GAMMUT_CMD,tda_gammut)
+#define TDA_IOCTL_GET_EDID_DTD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_DTD_CMD,tda_edid_dtd)
+#define TDA_IOCTL_GET_EDID_MD     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_MD_CMD,tda_edid_md)
+#define TDA_IOCTL_GET_EDID_TV_ASPECT_RATIO     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_TV_ASPECT_RATIO_CMD,tda_edid_tv_aspect_ratio)
+#ifdef TMFL_TDA19989
+#define TDA_IOCTL_GET_EDID_LATENCY     _IOWR(TDA_IOCTL_BASE, TDA_GET_EDID_LATENCY_CMD,tda_edid_latency)
+#define TDA_IOCTL_SET_HDCP     _IOWR(TDA_IOCTL_BASE, TDA_SET_HDCP_CMD,bool)
+#define TDA_IOCTL_GET_HDCP_STATUS     _IOWR(TDA_IOCTL_BASE, TDA_GET_HDCP_STATUS_CMD,tda_hdcp_status)
+#endif
+
+/* --- Full list --- */
+
+/* legend: */
+/* ------- */
+/* [ ] : not supported */
+/* [x] : IOCTL */
+/* [i] : open, init... */
+
+/* [x] txGetSWVersion */
+/* [ ] txGetNumberOfUnits */
+/* [i] txGetCapabilities */
+/* [ ] txGetCapabilitiesM */
+/* [i] txOpen */
+/* [ ] txOpenM */
+/* [i] txClose */
+/* [x] txSetPowerState */
+/* [x] txGetPowerState */
+/* [ ] txInstanceConfig */
+/* [xi] txInstanceSetup */
+/* [x] txGetInstanceSetup */
+/* [x] txHandleInterrupt see IOCTL_WAIT_EVENT */
+/* [i] txRegisterCallbacks */
+/* [x] txEnableEvent */
+/* [x] txDisableEvent */
+/* [x] txGetVideoFormatSpecs */
+/* [x] txSetInputOutput */
+/* [x] txSetAudioInput */
+/* [x] txSetVideoInfoframe */
+/* [x] txSetAudioInfoframe */
+/* [x] txSetACPPacket */
+/* [x] txSetGeneralControlPacket */
+/* [x] txSetISRC1Packet */
+/* [x] txSetISRC2Packet */
+/* [x] txSetMPSInfoframe */
+/* [x] txSetSpdInfoframe */
+/* [x] txSetVsInfoframe */
+/* [ ] txDebugSetNullPacket */
+/* [ ] txDebugSetSingleNullPacket */
+/* [x] txSetAudioMute */
+/* [x] txResetAudioCts */
+/* [x] txGetEdidStatus */
+/* [x] txGetEdidAudioCaps */
+/* [x] txGetEdidVideoCaps */
+/* [x] txGetEdidVideoPreferred */
+/* [x] txGetEdidSinkType */
+/* [x] txGetEdidSourceAddress */
+/* [ ] txGetKsvList */
+/* [ ] txGetDepth */
+/* [ ] txGeneSHA_1_IT */
+/* [ ] txSetHdcp */
+/* [ ] txGetHdcpState */
+/* [ ] txHdcpCheck */
+/* [x] txSetGamutPacket */
+/* [x] txGetEdidDetailledTimingDescriptors */
+/* [x] txGetEdidMonitorDescriptors */
+/* [x] txGetEdidTVPictureRatio */
+/* [ ] txSetHDCPRevocationList */
+/* [ ] txGetHdcpFailStatus */
+/* [x] txGetEdidLatencyInfo */
+/* [ ] txSetBScreen */
+/* [ ] txRemoveBScreen */
+
+#endif /* __tx_h__ */
+#endif /* __tx_ioctl__ */
+
+#ifndef __cec_ioctl__
+#define __cec_ioctl__
+
+#ifdef __cec_h__
+
+typedef struct {
+	u8 day_of_month;
+	u8 month_of_year;
+	u16 start_time;
+	dl_hdmi_cecduration_t duration;
+	u8 recording_sequence;
+	dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type;
+	u16 analogue_frequency;
+	dl_hdmi_cecbroadcast_system_t broadcast_system;
+} cec_analogue_timer;
+
+typedef struct {
+	u8 day_of_month;
+	u8 month_of_year;
+	u16 start_time;
+	dl_hdmi_cecduration_t duration;
+	u8 recording_sequence;
+	dl_hdmi_cecdigital_service_identification_t service_identification;
+} cec_digital_timer;
+
+typedef struct {
+	u8 day_of_month;
+	u8 month_of_year;
+	u16 start_time;
+	dl_hdmi_cecduration_t duration;
+	u8 recording_sequence;
+	dl_hdmi_cecexternal_plug_t external_plug;
+} cec_ext_timer_with_ext_plug;
+
+typedef struct {
+	u8 day_of_month;
+	u8 month_of_year;
+	u16 start_time;
+	dl_hdmi_cecduration_t duration;
+	u8 recording_sequence;
+	dl_hdmi_cecexternal_physical_address_t external_physical_address;
+} cec_ext_timer_with_phy_addr;
+
+typedef struct {
+	dl_hdmi_cecfeature_opcode_t feature_opcode;
+	dl_hdmi_cecabort_reason_t abort_reason;
+} cec_feature_abort;
+
+typedef struct {
+	dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type;
+	u16 analogue_frequency;
+	dl_hdmi_cecbroadcast_system_t broadcast_system;
+} cec_analogue_service;
+
+typedef struct {
+	u16 original_address;
+	u16 new_address;
+} cec_routing_change;
+
+typedef struct {
+	char data[15];
+	unsigned char length;
+} cec_string;
+
+typedef struct {
+	dl_hdmi_cecdisplay_control_t display_control;
+	char data[15];
+	unsigned char length;
+} cec_osd_string;
+
+typedef struct {
+	dl_hdmi_cecrecording_flag_t recording_flag;
+	dl_hdmi_cectuner_display_info_t tuner_display_info;
+	dl_hdmi_cecanalogue_broadcast_type_t analogue_broadcast_type;
+	u16 analogue_frequency;
+	dl_hdmi_cecbroadcast_system_t broadcast_system;
+} cec_tuner_device_status_analogue;
+
+typedef struct {
+	dl_hdmi_cecrecording_flag_t recording_flag;
+	dl_hdmi_cectuner_display_info_t tuner_display_info;
+	dl_hdmi_cecdigital_service_identification_t service_identification;
+} cec_tuner_device_status_digital;
+
+typedef struct {
+	unsigned long vendor_id;
+	cec_string cmd;
+} cec_vendor_command_with_id;
+
+/*
+ *  typedef struct {
+ *  u8 *pData;
+ *  u16 lenData;
+ *  } cec_send_msg;
+ * */
+
+typedef struct {
+	unsigned char count;
+	unsigned char service;
+	unsigned char addr;
+	unsigned char data[15];
+} cec_frame;
+/* typedef dlHdmiCecFrameFormat_t cec_frame; */
+
+typedef swversion_t cec_sw_version;
+typedef power_state_t cec_power;
+typedef dl_hdmi_cec_instance_setup_t cec_setup;
+typedef dl_hdmi_cec_event_t cec_event;
+typedef dl_hdmi_cec_clock_source_t cec_clock;
+typedef dl_hdmi_cecsystem_audio_status_t cec_sys_audio_status;
+typedef dl_hdmi_cecaudio_rate_t cec_audio_rate;
+typedef dl_hdmi_cecdigital_service_identification_t cec_digital_service;
+typedef dl_hdmi_cecversion_t cec_version;
+typedef dl_hdmi_cecdec_control_mode_t cec_deck_ctrl;
+typedef dl_hdmi_cecdec_info_t cec_deck_status;
+typedef dl_hdmi_cecstatus_request_t cec_status_request;
+typedef dl_hdmi_cecmenu_request_type_t cec_menu_request;
+typedef dl_hdmi_cecmenu_state_t cec_menu_status;
+typedef dl_hdmi_cecplay_mode_t cec_play;
+typedef dl_hdmi_cecexternal_plug_t cec_ext_plug;
+typedef dl_hdmi_cecrecord_status_info_t cec_rec_status;
+typedef dl_hdmi_cecaudio_status_t cec_audio_status;
+typedef dl_hdmi_cecpower_status_t cec_power_status;
+typedef dl_hdmi_cectimer_cleared_status_data_t cec_timer_cleared_status;
+typedef dl_hdmi_cectimer_status_data_t cec_timer_status;
+typedef dl_hdmi_cecuser_remote_control_command_t cec_user_ctrl;
+typedef dl_hdmi_cecchannel_identifier_t cec_user_ctrl_tune;
+typedef dl_hdmi_cecdevice_type_t cec_device_type;
+
+#define CEC_IOCTL_BASE 0x40
+
+/* service */
+enum {
+	CEC_WAITING = 0x80,
+	CEC_RELEASE,
+	CEC_RX_DONE,
+	CEC_TX_DONE
+};
+
+enum {
+	/* driver specific */
+	CEC_VERBOSE_ON_CMD = 0,
+	CEC_VERBOSE_OFF_CMD,
+	CEC_BYEBYE_CMD,
+
+	/* CEC */
+	CEC_IOCTL_RX_ADDR_CMD, /* receiver logical address selector */
+	CEC_IOCTL_PHY_ADDR_CMD, /* physical address selector */
+	CEC_IOCTL_WAIT_FRAME_CMD,
+	CEC_IOCTL_ABORT_MSG_CMD,
+	CEC_IOCTL_ACTIVE_SRC_CMD,
+	CEC_IOCTL_VERSION_CMD,
+	CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,
+	CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,
+	CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,
+	CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,
+	CEC_IOCTL_DECK_CTRL_CMD,
+	CEC_IOCTL_DECK_STATUS_CMD,
+	CEC_IOCTL_DEVICE_VENDOR_ID_CMD,
+	CEC_IOCTL_FEATURE_ABORT_CMD,
+	CEC_IOCTL_GET_CEC_VERSION_CMD,
+	CEC_IOCTL_GET_MENU_LANGUAGE_CMD,
+	CEC_IOCTL_GIVE_AUDIO_STATUS_CMD,
+	CEC_IOCTL_GIVE_DECK_STATUS_CMD,
+	CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD,
+	CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD,
+	CEC_IOCTL_GIVE_OSD_NAME_CMD,
+	CEC_IOCTL_GIVE_PHY_ADDR_CMD,
+	CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD,
+	CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,
+	CEC_IOCTL_IMAGE_VIEW_ON_CMD,
+	CEC_IOCTL_INACTIVE_SRC_CMD,
+	CEC_IOCTL_MENU_REQUEST_CMD,
+	CEC_IOCTL_MENU_STATUS_CMD,
+	CEC_IOCTL_PLAY_CMD,
+	CEC_IOCTL_POLLING_MSG_CMD,
+	CEC_IOCTL_REC_OFF_CMD,
+	CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,
+	CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,
+	CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD,
+	CEC_IOCTL_REC_ON_EXT_PLUG_CMD,
+	CEC_IOCTL_REC_ON_OWN_SRC_CMD,
+	CEC_IOCTL_REC_STATUS_CMD,
+	CEC_IOCTL_REC_TV_SCREEN_CMD,
+	CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,
+	CEC_IOCTL_REPORT_PHY_ADDR_CMD,
+	CEC_IOCTL_REPORT_POWER_STATUS_CMD,
+	CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD,
+	CEC_IOCTL_ROUTING_CHANGE_CMD,
+	CEC_IOCTL_ROUTING_INFORMATION_CMD,
+	CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,
+	CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,
+	CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,
+	CEC_IOCTL_SET_AUDIO_RATE_CMD,
+	CEC_IOCTL_SET_DIGITAL_TIMER_CMD,
+	CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,
+	CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,
+	CEC_IOCTL_SET_MENU_LANGUAGE_CMD,
+	CEC_IOCTL_SET_OSD_NAME_CMD,
+	CEC_IOCTL_SET_OSD_STRING_CMD,
+	CEC_IOCTL_SET_STREAM_PATH_CMD,
+	CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,
+	CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,
+	CEC_IOCTL_STANDBY_CMD,
+	CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD,
+	CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,
+	CEC_IOCTL_TEXT_VIEW_ON_CMD,
+	CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,
+	CEC_IOCTL_TIMER_STATUS_CMD,
+	CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,
+	CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,
+	CEC_IOCTL_TUNER_STEP_DECREMENT_CMD,
+	CEC_IOCTL_TUNER_STEP_INCREMENT_CMD,
+	CEC_IOCTL_USER_CTRL_CMD,
+	CEC_IOCTL_USER_CTRL_PLAY_CMD,
+	CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,
+	CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,
+	CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,
+	CEC_IOCTL_USER_CTRL_TUNE_CMD,
+	CEC_IOCTL_USER_CTRL_RELEASED_CMD,
+	CEC_IOCTL_VENDOR_COMMAND_CMD,
+	CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,
+	CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,
+	CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD,
+	CEC_IOCTL_GET_SW_VERSION_CMD,
+	CEC_IOCTL_SET_POWER_STATE_CMD,
+	CEC_IOCTL_GET_POWER_STATE_CMD,
+	CEC_IOCTL_INSTANCE_CONFIG_CMD,
+	CEC_IOCTL_INSTANCE_SETUP_CMD,
+	CEC_IOCTL_GET_INSTANCE_SETUP_CMD,
+	CEC_IOCTL_ENABLE_EVENT_CMD,
+	CEC_IOCTL_DISABLE_EVENT_CMD,
+	CEC_IOCTL_ENABLE_CALIBRATION_CMD,
+	CEC_IOCTL_DISABLE_CALIBRATION_CMD,
+	CEC_IOCTL_SEND_MSG_CMD,
+	CEC_IOCTL_SET_REGISTER_CMD
+};
+
+/* driver specific */
+#define CEC_IOCTL_VERBOSE_ON       _IO(CEC_IOCTL_BASE, CEC_VERBOSE_ON_CMD)
+#define CEC_IOCTL_VERBOSE_OFF      _IO(CEC_IOCTL_BASE, CEC_VERBOSE_OFF_CMD)
+#define CEC_IOCTL_BYEBYE      _IO(CEC_IOCTL_BASE, CEC_BYEBYE_CMD)
+
+/* CEC */
+#define CEC_IOCTL_RX_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_RX_ADDR_CMD,unsigned char)
+#define CEC_IOCTL_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PHY_ADDR_CMD,unsigned short)
+#define CEC_IOCTL_WAIT_FRAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_WAIT_FRAME_CMD,cec_frame)
+#define CEC_IOCTL_ABORT_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ABORT_MSG_CMD)
+#define CEC_IOCTL_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ACTIVE_SRC_CMD)
+#define CEC_IOCTL_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VERSION_CMD,cec_version)
+#define CEC_IOCTL_CLEAR_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_ANALOGUE_TIMER_CMD,cec_analogue_timer)
+#define CEC_IOCTL_CLEAR_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_DIGITAL_TIMER_CMD,cec_digital_timer)
+#define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
+#define CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_CLEAR_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
+#define CEC_IOCTL_DECK_CTRL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_CTRL_CMD,cec_deck_ctrl)
+#define CEC_IOCTL_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DECK_STATUS_CMD,cec_deck_status)
+#define CEC_IOCTL_DEVICE_VENDOR_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DEVICE_VENDOR_ID_CMD,unsigned long)
+#define CEC_IOCTL_FEATURE_ABORT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_FEATURE_ABORT_CMD,cec_feature_abort)
+#define CEC_IOCTL_GET_CEC_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_CEC_VERSION_CMD,unsigned char)
+#define CEC_IOCTL_GET_MENU_LANGUAGE      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GET_MENU_LANGUAGE_CMD)
+#define CEC_IOCTL_GIVE_AUDIO_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_AUDIO_STATUS_CMD)
+#define CEC_IOCTL_GIVE_DECK_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DECK_STATUS_CMD,cec_status_request)
+#define CEC_IOCTL_GIVE_DEVICE_POWER_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_POWER_STATUS_CMD)
+#define CEC_IOCTL_GIVE_DEVICE_VENDOR_ID      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_DEVICE_VENDOR_ID_CMD)
+#define CEC_IOCTL_GIVE_OSD_NAME      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_OSD_NAME_CMD)
+#define CEC_IOCTL_GIVE_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_PHY_ADDR_CMD)
+#define CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS      _IO(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_SYS_AUDIO_MODE_STATUS_CMD)
+#define CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GIVE_TUNER_DEVICE_STATUS_CMD,cec_status_request)
+#define CEC_IOCTL_IMAGE_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_IMAGE_VIEW_ON_CMD)
+#define CEC_IOCTL_INACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INACTIVE_SRC_CMD)
+#define CEC_IOCTL_MENU_REQUEST      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_REQUEST_CMD,cec_menu_request)
+#define CEC_IOCTL_MENU_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_MENU_STATUS_CMD,cec_menu_status)
+#define CEC_IOCTL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_PLAY_CMD,cec_play)
+#define CEC_IOCTL_POLLING_MSG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_POLLING_MSG_CMD)
+#define CEC_IOCTL_REC_OFF      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_OFF_CMD)
+#define CEC_IOCTL_REC_ON_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_ANALOGUE_SERVICE_CMD,cec_analogue_service)
+#define CEC_IOCTL_REC_ON_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_DIGITAL_SERVICE_CMD,cec_digital_service)
+#define CEC_IOCTL_REC_ON_EXT_PHY_ADDR      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PHY_ADDR_CMD)
+#define CEC_IOCTL_REC_ON_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_EXT_PLUG_CMD,cec_ext_plug)
+#define CEC_IOCTL_REC_ON_OWN_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_ON_OWN_SRC_CMD)
+#define CEC_IOCTL_REC_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REC_STATUS_CMD,cec_rec_status)
+#define CEC_IOCTL_REC_TV_SCREEN      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REC_TV_SCREEN_CMD)
+#define CEC_IOCTL_REPORT_AUDIO_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_AUDIO_STATUS_CMD,cec_audio_status)
+#define CEC_IOCTL_REPORT_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_PHY_ADDR_CMD,cec_device_type)
+#define CEC_IOCTL_REPORT_POWER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_REPORT_POWER_STATUS_CMD,cec_power_status)
+#define CEC_IOCTL_REQUEST_ACTIVE_SRC      _IO(CEC_IOCTL_BASE,CEC_IOCTL_REQUEST_ACTIVE_SRC_CMD)
+#define CEC_IOCTL_ROUTING_CHANGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_CHANGE_CMD,cec_routing_change)
+#define CEC_IOCTL_ROUTING_INFORMATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_ROUTING_INFORMATION_CMD)
+#define CEC_IOCTL_SELECT_ANALOGUE_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_ANALOGUE_SERVICE_CMD,cec_analogue_service)
+#define CEC_IOCTL_SELECT_DIGITAL_SERVICE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SELECT_DIGITAL_SERVICE_CMD,cec_digital_service)
+#define CEC_IOCTL_SET_ANALOGUE_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_ANALOGUE_TIMER_CMD,cec_analogue_timer)
+#define CEC_IOCTL_SET_AUDIO_RATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_AUDIO_RATE_CMD,cec_audio_rate)
+#define CEC_IOCTL_SET_DIGITAL_TIMER      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_DIGITAL_TIMER_CMD,cec_digital_timer)
+#define CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_EXT_PLUG_CMD,cec_ext_timer_with_ext_plug)
+#define CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_EXT_TIMER_WITH_PHY_ADDR_CMD,cec_ext_timer_with_phy_addr)
+#define CEC_IOCTL_SET_MENU_LANGUAGE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_MENU_LANGUAGE_CMD,cec_string)
+#define CEC_IOCTL_SET_OSD_NAME      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_NAME_CMD,cec_string)
+#define CEC_IOCTL_SET_OSD_STRING      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_OSD_STRING_CMD,cec_osd_string)
+#define CEC_IOCTL_SET_STREAM_PATH      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SET_STREAM_PATH_CMD)
+#define CEC_IOCTL_SET_SYS_AUDIO_MODE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_SYS_AUDIO_MODE_CMD,cec_sys_audio_status)
+#define CEC_IOCTL_SET_TIMER_PROGRAM_TITLE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_TIMER_PROGRAM_TITLE_CMD,cec_string)
+#define CEC_IOCTL_STANDBY      _IO(CEC_IOCTL_BASE,CEC_IOCTL_STANDBY_CMD)
+#define CEC_IOCTL_SYS_AUDIO_MODE_REQUEST      _IO(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_REQUEST_CMD)
+#define CEC_IOCTL_SYS_AUDIO_MODE_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SYS_AUDIO_MODE_STATUS_CMD,cec_sys_audio_status)
+#define CEC_IOCTL_TEXT_VIEW_ON      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TEXT_VIEW_ON_CMD)
+#define CEC_IOCTL_TIMER_CLEARED_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_CLEARED_STATUS_CMD,cec_timer_cleared_status)
+#define CEC_IOCTL_TIMER_STATUS      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TIMER_STATUS_CMD,cec_timer_status)
+#define CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_ANALOGUE_CMD,cec_tuner_device_status_analogue)
+#define CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_DEVICE_STATUS_DIGITAL_CMD,cec_tuner_device_status_digital)
+#define CEC_IOCTL_TUNER_STEP_DECREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_DECREMENT_CMD)
+#define CEC_IOCTL_TUNER_STEP_INCREMENT      _IO(CEC_IOCTL_BASE,CEC_IOCTL_TUNER_STEP_INCREMENT_CMD)
+#define CEC_IOCTL_USER_CTRL_PRESSED      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_CMD,cec_user_ctrl)
+#define CEC_IOCTL_USER_CTRL_PLAY      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_PLAY_CMD,cec_play)
+#define CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AUDIOINPUT_CMD,unsigned char)
+#define CEC_IOCTL_USER_CTRL_SELECT_AVINPUT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_AVINPUT_CMD,unsigned char)
+#define CEC_IOCTL_USER_CTRL_SELECT_MEDIA      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_SELECT_MEDIA_CMD,unsigned char)
+#define CEC_IOCTL_USER_CTRL_TUNE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_TUNE_CMD,cec_user_ctrl_tune)
+#define CEC_IOCTL_USER_CTRL_RELEASED      _IO(CEC_IOCTL_BASE,CEC_IOCTL_USER_CTRL_RELEASED_CMD)
+#define CEC_IOCTL_VENDOR_COMMAND      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_CMD,cec_string)
+#define CEC_IOCTL_VENDOR_COMMAND_WITH_ID      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_COMMAND_WITH_ID_CMD,cec_vendor_command_with_id)
+#define CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_DOWN_CMD,cec_string)
+#define CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP      _IO(CEC_IOCTL_BASE,CEC_IOCTL_VENDOR_REMOTE_BUTTON_UP_CMD)
+#define CEC_IOCTL_GET_SW_VERSION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_SW_VERSION_CMD,cec_sw_version)
+#define CEC_IOCTL_SET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SET_POWER_STATE_CMD,cec_power)
+#define CEC_IOCTL_GET_POWER_STATE      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_POWER_STATE_CMD,cec_power)
+#define CEC_IOCTL_INSTANCE_CONFIG      _IO(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_CONFIG_CMD)
+#define CEC_IOCTL_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_INSTANCE_SETUP_CMD,cec_setup)
+#define CEC_IOCTL_GET_INSTANCE_SETUP      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_GET_INSTANCE_SETUP_CMD,cec_setup)
+#define CEC_IOCTL_ENABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_EVENT_CMD,cec_event)
+#define CEC_IOCTL_DISABLE_EVENT      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_EVENT_CMD,cec_event)
+#define CEC_IOCTL_ENABLE_CALIBRATION      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_ENABLE_CALIBRATION_CMD,cec_clock)
+#define CEC_IOCTL_DISABLE_CALIBRATION      _IO(CEC_IOCTL_BASE,CEC_IOCTL_DISABLE_CALIBRATION_CMD)
+/*#define CEC_IOCTL_SEND_MSG      _IOWR(CEC_IOCTL_BASE,CEC_IOCTL_SEND_MSG_CMD,cec_send_msg) */
+
+/* --- Full list --- */
+
+/* legend: */
+/* ------- */
+/* [ ] : not supported */
+/* [x] : IOCTL */
+/* [i] : open, init... */
+
+/* [ ] dlHdmiCecAbortMessage */
+/* [ ] dlHdmiCecActiveSource */
+/* [ ] dlHdmiCecVersion */
+/* [ ] dlHdmiCecClearAnalogueTimer */
+/* [ ] dlHdmiCecClearDigitalTimer */
+/* [ ] dlHdmiCecClearExternalTimerWithExternalPlug */
+/* [ ] dlHdmiCecClearExternalTimerWithPhysicalAddress */
+/* [ ] dlHdmiCecDeckControl */
+/* [ ] dlHdmiCecDeckStatus */
+/* [ ] dlHdmiCecDeviceVendorID */
+/* [ ] dlHdmiCecFeatureAbort */
+/* [ ] dlHdmiCecGetCecVersion */
+/* [ ] dlHdmiCecGetMenuLanguage */
+/* [ ] dlHdmiCecGiveAudioStatus */
+/* [ ] dlHdmiCecGiveDeckStatus */
+/* [ ] dlHdmiCecGiveDevicePowerStatus */
+/* [ ] dlHdmiCecGiveDeviceVendorID */
+/* [ ] dlHdmiCecGiveOsdName */
+/* [ ] dlHdmiCecGivePhysicalAddress */
+/* [ ] dlHdmiCecGiveSystemAudioModeStatus */
+/* [ ] dlHdmiCecGiveTunerDeviceStatus */
+/* [ ] dlHdmiCecImageViewOn */
+/* [ ] dlHdmiCecInactiveSource */
+/* [ ] dlHdmiCecMenuRequest */
+/* [ ] dlHdmiCecMenuStatus */
+/* [ ] dlHdmiCecPlay */
+/* [ ] dlHdmiCecPollingMessage */
+/* [ ] dlHdmiCecRecordOff */
+/* [ ] dlHdmiCecRecordOnAnalogueService */
+/* [ ] dlHdmiCecRecordOnDigitalService */
+/* [ ] dlHdmiCecRecordOnExternalPhysicalAddress */
+/* [ ] dlHdmiCecRecordOnExternalPlug */
+/* [ ] dlHdmiCecRecordOnOwnSource */
+/* [ ] dlHdmiCecRecordStatus */
+/* [ ] dlHdmiCecRecordTvScreen */
+/* [ ] dlHdmiCecReportAudioStatus */
+/* [ ] dlHdmiCecReportPhysicalAddress */
+/* [ ] dlHdmiCecReportPowerStatus */
+/* [ ] dlHdmiCecRequestActiveSource */
+/* [ ] dlHdmiCecRoutingChange */
+/* [ ] dlHdmiCecRoutingInformation */
+/* [ ] dlHdmiCecSelectAnalogueService */
+/* [ ] dlHdmiCecSelectDigitalService */
+/* [ ] dlHdmiCecSetAnalogueTimer */
+/* [ ] dlHdmiCecSetAudioRate */
+/* [ ] dlHdmiCecSetDigitalTimer */
+/* [ ] dlHdmiCecSetExternalTimerWithExternalPlug */
+/* [ ] dlHdmiCecSetExternalTimerWithPhysicalAddress */
+/* [ ] dlHdmiCecSetMenuLanguage */
+/* [ ] dlHdmiCecSetOsdName */
+/* [ ] dlHdmiCecSetOsdString */
+/* [ ] dlHdmiCecSetStreamPath */
+/* [ ] dlHdmiCecSetSystemAudioMode */
+/* [ ] dlHdmiCecSetTimerProgramTitle */
+/* [ ] dlHdmiCecStandby */
+/* [ ] dlHdmiCecSystemAudioModeRequest */
+/* [ ] dlHdmiCecSystemAudioModeStatus */
+/* [ ] dlHdmiCecTextViewOn */
+/* [ ] dlHdmiCecTimerClearedStatus */
+/* [ ] dlHdmiCecTimerStatus */
+/* [ ] dlHdmiCecTunerDeviceStatusAnalogue */
+/* [ ] dlHdmiCecTunerDeviceStatusDigital */
+/* [ ] dlHdmiCecTunerStepDecrement */
+/* [ ] dlHdmiCecTunerStepIncrement */
+/* [ ] dlHdmiCecUserControlPressed */
+/* [ ] dlHdmiCecUserControlPressedPlay */
+/* [ ] dlHdmiCecUserControlPressedSelectAudioInput */
+/* [ ] dlHdmiCecUserControlPressedSelectAVInput */
+/* [ ] dlHdmiCecUserControlPressedSelectMedia */
+/* [ ] dlHdmiCecUserControlPressedTune */
+/* [ ] dlHdmiCecUserControlReleased */
+/* [ ] dlHdmiCecVendorCommand */
+/* [ ] dlHdmiCecVendorCommandWithID */
+/* [ ] dlHdmiCecVendorRemoteButtonDown */
+/* [ ] dlHdmiCecVendorRemoteButtonUp */
+/* [ ] dlHdmiCecGetSWVersion */
+/* [ ] dlHdmiCecGetNumberOfUnits */
+/* [ ] dlHdmiCecGetCapabilities */
+/* [ ] dlHdmiCecGetCapabilitiesM */
+/* [ ] dlHdmiCecOpen */
+/* [ ] dlHdmiCecOpenM */
+/* [ ] dlHdmiCecClose */
+/* [ ] dlHdmiCecSetPowerState */
+/* [ ] dlHdmiCecGetPowerState */
+/* [ ] dlHdmiCecInstanceConfig */
+/* [ ] dlHdmiCecInstanceSetup */
+/* [ ] dlHdmiCecGetInstanceSetup */
+/* [ ] dlHdmiCecHandleInterrupt */
+/* [ ] dlHdmiCecRegisterCallbacks */
+/* [ ] dlHdmiCecSetAutoAnswer */
+/* [ ] dlHdmiCecSetLogicalAddress */
+/* [ ] dlHdmiCecEnableEvent */
+/* [ ] dlHdmiCecDisableEvent */
+/* [ ] dlHdmiCecEnableCalibration */
+/* [ ] dlHdmiCecDisableCalibration */
+/* [ ] dlHdmiCecSendMessage */
+/* [ ] dlHdmiCecSetRegister */
+
+#endif /* __cec_h__ */
+#endif /* __cec_ioctl__ */
diff --git a/drivers/video/hdmi/tda998x_version.h b/drivers/video/hdmi/tda998x_version.h
new file mode 100644
index 0000000..5edc5c1
--- /dev/null
+++ b/drivers/video/hdmi/tda998x_version.h
@@ -0,0 +1,16 @@
+#ifndef __tda_version__
+#define __tda_version__
+
+/* version */
+#define TDA_VERSION_MAJOR	1
+#define TDA_VERSION_MINOR	1
+#define TDA_VERSION_PATCHLEVEL 0
+#define TDA_VERSION_EXTRA	"-ioctl (2009-10-15)"
+
+/* TDA TX chip list */
+#define TDA19989 "tda19989"
+#define TDA9984  "tda9984"
+#define TDA9983  "tda9983"
+#define TDA9981  "tda9981"
+
+#endif
diff --git a/drivers/video/pxa168fb.c b/drivers/video/pxa168fb.c
index aa9bd1f..4ae8924 100644
--- a/drivers/video/pxa168fb.c
+++ b/drivers/video/pxa168fb.c
@@ -30,67 +30,243 @@
 #include <linux/uaccess.h>
 #include <video/pxa168fb.h>
 
+#include <linux/gpio.h>
 #include "pxa168fb.h"
 
-#define DEFAULT_REFRESH		60	/* Hz */
+#include <asm/mach-types.h>
 
-static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
+#ifdef CONFIG_DVFM
+#include <mach/dvfm.h>
+
+static int dvfm_dev_idx;
+static void set_dvfm_constraint(void)
 {
-	/*
-	 * Pseudocolor mode?
-	 */
-	if (var->bits_per_pixel == 8)
-		return PIX_FMT_PSEUDOCOLOR;
+	/* Disable Lowpower mode */
+	dvfm_disable_op_name("apps_idle", dvfm_dev_idx);
+	dvfm_disable_op_name("apps_sleep", dvfm_dev_idx);
+	dvfm_disable_op_name("sys_sleep", dvfm_dev_idx);
+	dvfm_disable_op_name("26MHz", dvfm_dev_idx);
+}
 
-	/*
-	 * Check for 565/1555.
-	 */
-	if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
-	    var->green.length <= 6 && var->blue.length <= 5) {
-		if (var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB565;
-			else
-				return PIX_FMT_BGR565;
-		}
+static void unset_dvfm_constraint(void)
+{
+	/* Enable Lowpower mode */
+	dvfm_enable_op_name("apps_idle", dvfm_dev_idx);
+	dvfm_enable_op_name("apps_sleep", dvfm_dev_idx);
+	dvfm_enable_op_name("sys_sleep", dvfm_dev_idx);
+	dvfm_enable_op_name("26MHz", dvfm_dev_idx);
+}
 
-		if (var->transp.length == 1 && var->green.length <= 5) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB1555;
-			else
-				return PIX_FMT_BGR1555;
-		}
+#else
+static void set_dvfm_constraint(void) {}
+static void unset_dvfm_constraint(void) {}
+#endif
 
-		/* fall through */
-	}
+#define MAX_HWC_SIZE		(64*64*2)
+#define MAX_REFRESH_RATE	100	/* Hz */
+#define MIN_REFRESH_RATE	47	/* Hz */
+#define DEFAULT_REFRESH		60	/* Hz */
 
-	/*
-	 * Check for 888/A888.
-	 */
-	if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
-	    var->green.length <= 8 && var->blue.length <= 8) {
-		if (var->bits_per_pixel == 24 && var->transp.length == 0) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888PACK;
-			else
-				return PIX_FMT_BGR888PACK;
+/* Compatibility mode global switch .....
+ *
+ * This is a secret switch for user space programs that may want to
+ * select color spaces and set resolutions the same as legacy PXA display
+ * drivers. The switch is set and unset by setting a specific value in the
+ * var_screeninfo.nonstd variable.
+ *
+ * To turn on compatibility with older PXA, set the MSB of nonstd to 0xAA.
+ * To turn off compatibility with older PXA, set the MSB of nonstd to 0x55.
+ */
+
+static unsigned int COMPAT_MODE;
+unsigned int gra_dma_base_address;
+EXPORT_SYMBOL(gra_dma_base_address);
+static unsigned int max_fb_size = 0;
+
+#ifdef CONFIG_PM
+static int _pxa168fb_resume(struct pxa168fb_info *fbi);
+static int _pxa168fb_suspend(struct pxa168fb_info *fbi, pm_message_t mesg);
+#endif
+
+void pxa168fb_spi_send(struct pxa168fb_info *fbi, void *value, int count, unsigned int spi_gpio_cs)
+{
+	u32 x, spi_byte_len;
+	u8 *cmd = (u8 *)value;
+	int i, err, isr, iopad;
+
+	if (spi_gpio_cs != -1) {
+		err = gpio_request(spi_gpio_cs, "LCD_SPI_CS");
+		if (err) {
+			printk("failed to request GPIO for LCD CS\n");
+			return;
+		}
+		gpio_direction_output(spi_gpio_cs, 1);
+	}
+	/* get spi data size */
+	spi_byte_len = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+	spi_byte_len = (spi_byte_len >> 8) & 0xff;
+	/* It should be (spi_byte_len + 7) >> 3, but spi controller request set one less than bit length */
+	spi_byte_len = (spi_byte_len + 8) >> 3;
+	/* spi command provided by platform should be 1, 2, or 4 byte aligned */
+	if(spi_byte_len == 3)
+		spi_byte_len = 4;
+
+	iopad = readl(fbi->reg_base + SPU_IOPAD_CONTROL);
+	for (i = 0; i < count; i++) {
+		if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI) {
+			writel(iopad & ~CFG_IOPADMODE_MASK, fbi->reg_base + SPU_IOPAD_CONTROL);
+			writel(iopad | PIN_MODE_DUMB_18_SPI, fbi->reg_base + SPU_IOPAD_CONTROL);
 		}
+		if (spi_gpio_cs != -1)
+			gpio_set_value(spi_gpio_cs, 0);
+		isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+		writel((isr & ~SPI_IRQ_ENA_MASK), fbi->reg_base + SPU_IRQ_ISR);
+		switch (spi_byte_len){
+		case 1:
+			writel(*cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 2:
+			writel(*(u16*)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		case 4:
+			writel(*(u32*)cmd, fbi->reg_base + LCD_SPU_SPI_TXDATA);
+			break;
+		default:
+			printk("Wrong spi bit length\n");
+		}
+		cmd += spi_byte_len;
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x |= 0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+		while(!(isr & SPI_IRQ_ENA_MASK)) {
+			udelay(1);
+			isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+		}
+		x = readl(fbi->reg_base + LCD_SPU_SPI_CTRL);
+		x &= ~0x1;
+		writel(x, fbi->reg_base + LCD_SPU_SPI_CTRL);
+		if (spi_gpio_cs != -1)
+			gpio_set_value(spi_gpio_cs, 1);
+		if ((iopad & CFG_IOPADMODE_MASK) != PIN_MODE_DUMB_18_SPI)
+			writel(iopad, fbi->reg_base + SPU_IOPAD_CONTROL);
+	}
+	if (spi_gpio_cs != -1)
+		gpio_free(spi_gpio_cs);
+}
+EXPORT_SYMBOL(pxa168fb_spi_send);
 
-		if (var->bits_per_pixel == 32 && var->transp.length == 8) {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGBA888;
-			else
-				return PIX_FMT_BGRA888;
-		} else {
-			if (var->red.offset >= var->blue.offset)
-				return PIX_FMT_RGB888UNPACK;
+static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
+{
+        unsigned char pxa_format;
+
+        /* compatibility switch: if var->nonstd MSB is 0xAA then skip to 
+         * using the nonstd variable to select the color space.
+         */
+        if(COMPAT_MODE != 0x2625) {
+
+                /*
+                 * Pseudocolor mode?
+                 */
+                if (var->bits_per_pixel == 8)
+                        return PIX_FMT_PSEUDOCOLOR;
+
+		/*
+                 * Check for YUV422PACK.
+                 */
+                if (var->bits_per_pixel == 16 && var->red.length == 16 &&
+                    var->green.length == 16 && var->blue.length == 16) {
+                        if (var->red.offset >= var->blue.offset) {
+			if (var->red.offset == 4)
+				return PIX_FMT_YUV422PACK;
 			else
-				return PIX_FMT_BGR888UNPACK;
+				return PIX_FMT_YUYV422PACK;
+                        } else
+                                return PIX_FMT_YVU422PACK;
+                }
+
+                /*
+                 * Check for 565/1555.
+                 */
+                if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
+                    var->green.length <= 6 && var->blue.length <= 5) {
+                        if (var->transp.length == 0) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB565;
+                                else
+                                        return PIX_FMT_BGR565;
+                        }
+
+                        if (var->transp.length == 1 && var->green.length <= 5) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB1555;
+                                else
+                                        return PIX_FMT_BGR1555;
+                        }
+
+                        /* fall through */
+                }
+
+                /*
+                 * Check for 888/A888.
+                 */
+                if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
+                    var->green.length <= 8 && var->blue.length <= 8) {
+                        if (var->bits_per_pixel == 24 && var->transp.length == 0) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB888PACK;
+                                else
+                                        return PIX_FMT_BGR888PACK;
+                        }
+
+			if (var->bits_per_pixel == 32 && var->transp.length == 8) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGBA888;
+				else
+					return PIX_FMT_BGRA888;
+			} else {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGB888UNPACK;
+				else
+					return PIX_FMT_BGR888UNPACK;
+			}
+
+			/* fall through */
 		}
 
-		/* fall through */
 	}
 
+        else {
+
+                pxa_format = (var->nonstd >> 20) & 0xf;
+        
+                switch (pxa_format) {
+                case 0:
+                        return PIX_FMT_RGB565;
+                        break;
+                case 5:
+                        return PIX_FMT_RGB1555;
+                        break;
+                case 6:
+                        return PIX_FMT_RGB888PACK;
+                        break;
+                case 7:
+                        return PIX_FMT_RGB888UNPACK;
+                        break;
+                case 8:
+                        return PIX_FMT_RGBA888;
+                        break;
+                case 9:
+                        return PIX_FMT_YUV422PACK;
+                        break;
+
+                default:
+                        return -EINVAL;
+                }
+        }
+
+        
+
 	return -EINVAL;
 }
 
@@ -103,6 +279,7 @@ static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
 		var->green.offset = 5;   var->green.length = 6;
 		var->blue.offset = 0;    var->blue.length = 5;
 		var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
 		break;
 	case PIX_FMT_BGR565:
 		var->bits_per_pixel = 16;
@@ -110,6 +287,7 @@ static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
 		var->green.offset = 5;   var->green.length = 6;
 		var->blue.offset = 11;   var->blue.length = 5;
 		var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
 		break;
 	case PIX_FMT_RGB1555:
 		var->bits_per_pixel = 16;
@@ -117,6 +295,8 @@ static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
 		var->green.offset = 5;   var->green.length = 5;
 		var->blue.offset = 0;    var->blue.length = 5;
 		var->transp.offset = 15; var->transp.length = 1;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 5 << 20;
 		break;
 	case PIX_FMT_BGR1555:
 		var->bits_per_pixel = 16;
@@ -124,35 +304,91 @@ static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
 		var->green.offset = 5;   var->green.length = 5;
 		var->blue.offset = 10;   var->blue.length = 5;
 		var->transp.offset = 15; var->transp.length = 1;
-		break;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 5 << 20;
+                break;
 	case PIX_FMT_RGB888PACK:
 		var->bits_per_pixel = 24;
 		var->red.offset = 16;    var->red.length = 8;
 		var->green.offset = 8;   var->green.length = 8;
 		var->blue.offset = 0;    var->blue.length = 8;
 		var->transp.offset = 0;  var->transp.length = 0;
-		break;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 6 << 20;
+                break;
 	case PIX_FMT_BGR888PACK:
 		var->bits_per_pixel = 24;
 		var->red.offset = 0;     var->red.length = 8;
 		var->green.offset = 8;   var->green.length = 8;
 		var->blue.offset = 16;   var->blue.length = 8;
 		var->transp.offset = 0;  var->transp.length = 0;
-		break;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 6 << 20;
+                break;
+	case PIX_FMT_RGB888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 7 << 20;
+                break;
+	case PIX_FMT_BGR888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 7 << 20;
+                break;
 	case PIX_FMT_RGBA888:
 		var->bits_per_pixel = 32;
 		var->red.offset = 16;    var->red.length = 8;
 		var->green.offset = 8;   var->green.length = 8;
 		var->blue.offset = 0;    var->blue.length = 8;
 		var->transp.offset = 24; var->transp.length = 8;
-		break;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 8 << 20;
+                break;
 	case PIX_FMT_BGRA888:
 		var->bits_per_pixel = 32;
 		var->red.offset = 0;     var->red.length = 8;
 		var->green.offset = 8;   var->green.length = 8;
 		var->blue.offset = 16;   var->blue.length = 8;
 		var->transp.offset = 24; var->transp.length = 8;
-		break;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 8 << 20;
+                break;
+        case PIX_FMT_YUYV422PACK:
+                var->bits_per_pixel = 16;
+                var->red.offset = 8;     var->red.length = 16;
+                var->green.offset = 4;   var->green.length = 16;
+                var->blue.offset = 0;   var->blue.length = 16;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+        case PIX_FMT_YVU422PACK:
+                var->bits_per_pixel = 16;
+                var->red.offset = 0;     var->red.length = 16;
+                var->green.offset = 8;   var->green.length = 16;
+                var->blue.offset = 12;   var->blue.length = 16;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+        case PIX_FMT_YUV422PACK:
+                var->bits_per_pixel = 16;
+                var->red.offset = 4;     var->red.length = 16;
+                var->green.offset = 12;   var->green.length = 16;
+                var->blue.offset = 0;    var->blue.length = 16;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+
 	case PIX_FMT_PSEUDOCOLOR:
 		var->bits_per_pixel = 8;
 		var->red.offset = 0;     var->red.length = 8;
@@ -164,18 +400,17 @@ static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
 }
 
 static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
-		     struct fb_videomode *mode, int pix_fmt, int ystretch)
+		     const struct fb_videomode *mode, int pix_fmt, int ystretch)
 {
-	struct fb_info *info = fbi->info;
 
-	set_pix_fmt(var, pix_fmt);
+	dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+        set_pix_fmt(var, pix_fmt);
 
 	var->xres = mode->xres;
 	var->yres = mode->yres;
 	var->xres_virtual = max(var->xres, var->xres_virtual);
 	if (ystretch)
-		var->yres_virtual = info->fix.smem_len /
-			(var->xres_virtual * (var->bits_per_pixel >> 3));
+                var->yres_virtual = var->yres *2;
 	else
 		var->yres_virtual = max(var->yres, var->yres_virtual);
 	var->grayscale = 0;
@@ -195,17 +430,19 @@ static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
 static int pxa168fb_check_var(struct fb_var_screeninfo *var,
 			      struct fb_info *info)
 {
-	struct pxa168fb_info *fbi = info->par;
-	int pix_fmt;
+	dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+        if (var->bits_per_pixel == 8)
+		return -EINVAL;
 
-	/*
-	 * Determine which pixel format we're going to use.
-	 */
-	pix_fmt = determine_best_pix_fmt(var);
-	if (pix_fmt < 0)
-		return pix_fmt;
-	set_pix_fmt(var, pix_fmt);
-	fbi->pix_fmt = pix_fmt;
+        /* compatibility mode: if the MSB of var->nonstd is 0xAA then 
+         * set xres_virtual and yres_virtual to xres and yres.
+         */
+
+        if((var->nonstd >> 24) == 0xAA) 
+                COMPAT_MODE = 0x2625;
+
+        if((var->nonstd >> 24) == 0x55)
+                COMPAT_MODE = 0x0;
 
 	/*
 	 * Basic geometry sanity checks.
@@ -225,7 +462,7 @@ static int pxa168fb_check_var(struct fb_var_screeninfo *var,
 	 * Check size of framebuffer.
 	 */
 	if (var->xres_virtual * var->yres_virtual *
-	    (var->bits_per_pixel >> 3) > info->fix.smem_len)
+	    (var->bits_per_pixel >> 3) > max_fb_size)
 		return -EINVAL;
 
 	return 0;
@@ -249,6 +486,17 @@ static void set_clock_divider(struct pxa168fb_info *fbi,
 	u64 div_result;
 	u32 x = 0;
 
+	/* gplugd uses external clock */
+	if (machine_is_gplugd()) {
+		/* Clear bi 31, set bit 28 to use External Clock;
+		 * set clock divider*/
+		x = (1 << 28);
+
+		/* Set CLK_INT_DIV to 1 */
+		x |= 0x1;
+		writel(x, fbi->reg_base + LCD_CFG_SCLK_DIV);
+		return;
+	}
 	/*
 	 * Notice: The field pixclock is used by linux fb
 	 * is in pixel second. E.g. struct fb_videomode &
@@ -258,8 +506,9 @@ static void set_clock_divider(struct pxa168fb_info *fbi,
 	/*
 	 * Check input values.
 	 */
-	if (!m || !m->pixclock || !m->refresh) {
-		dev_err(fbi->dev, "Input refresh or pixclock is wrong.\n");
+	dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+        if (!m || !m->pixclock || !m->refresh) {
+		printk(KERN_ERR "Input refresh or pixclock is wrong.\n");
 		return;
 	}
 
@@ -279,8 +528,8 @@ static void set_clock_divider(struct pxa168fb_info *fbi,
 
 	/* check whether divisor is too small. */
 	if (divider_int < 2) {
-		dev_warn(fbi->dev, "Warning: clock source is too slow."
-				"Try smaller resolution\n");
+		printk(KERN_WARNING "Warning: clock source is too slow."
+				 "Try smaller resolution\n");
 		divider_int = 2;
 	}
 
@@ -295,12 +544,13 @@ static void set_dma_control0(struct pxa168fb_info *fbi)
 {
 	u32 x;
 
+
+        dev_dbg(fbi->info->dev,"Enter %s\n", __FUNCTION__);
 	/*
 	 * Set bit to enable graphics DMA.
 	 */
 	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	x &= ~CFG_GRA_ENA_MASK;
-	x |= fbi->active ? CFG_GRA_ENA(1) : CFG_GRA_ENA(0);
+	x |= fbi->active ? 0x00000100 : 0;
 
 	/*
 	 * If we are in a pseudo-color mode, we need to enable
@@ -316,12 +566,27 @@ static void set_dma_control0(struct pxa168fb_info *fbi)
 	x |= (fbi->pix_fmt >> 1) << 16;
 
 	/*
-	 * Check red and blue pixel swap.
-	 * 1. source data swap
-	 * 2. panel output data swap
+	 * Check YUV422PACK 
 	 */
-	x &= ~(1 << 12);
-	x |= ((fbi->pix_fmt & 1) ^ (fbi->panel_rbswap)) << 12;
+	x &= ~((1 << 9) | (1 << 11) | (1 << 10) | (1 << 12));
+	if (((fbi->pix_fmt >> 1) == 5) || (fbi->pix_fmt & 0x1000)) {
+		x |= 1 << 9;
+		x |= (fbi->panel_rbswap) << 12;
+		if (fbi->pix_fmt == 11)
+			x |= 1 << 11;
+		if (fbi->pix_fmt & 0x1000)
+			x |= 1 << 10;
+	} else {
+
+		/*
+		 * Check red and blue pixel swap.
+		 * 1. source data swap. BGR[M:L] rather than RGB[M:L] is stored in memeory as source format.
+		 * 2. panel output data swap
+		 */
+		x |= (((fbi->pix_fmt & 1) ^ 1) ^ (fbi->panel_rbswap)) << 12;
+	}
+
+        x |= CFG_ARBFAST_ENA(1);
 
 	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
 }
@@ -330,14 +595,14 @@ static void set_dma_control1(struct pxa168fb_info *fbi, int sync)
 {
 	u32 x;
 
-	/*
+	dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+        /*
 	 * Configure default bits: vsync triggers DMA, gated clock
 	 * enable, power save enable, configure alpha registers to
 	 * display 100% graphics, and set pixel command.
 	 */
 	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
-	x |= 0x2032ff81;
-
+	
 	/*
 	 * We trigger DMA on the falling edge of vsync if vsync is
 	 * active low, or on the rising edge if vsync is active high.
@@ -345,6 +610,7 @@ static void set_dma_control1(struct pxa168fb_info *fbi, int sync)
 	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
 		x |= 0x08000000;
 
+
 	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);
 }
 
@@ -355,10 +621,26 @@ static void set_graphics_start(struct fb_info *info, int xoffset, int yoffset)
 	int pixel_offset;
 	unsigned long addr;
 
-	pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+        pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+        /*pixel_offset = (100 * var->xres_virtual) + 100;*/
 
 	addr = fbi->fb_start_dma + (pixel_offset * (var->bits_per_pixel >> 3));
-	writel(addr, fbi->reg_base + LCD_CFG_GRA_START_ADDR0);
+
+	/* The video layer will write this address at VSync time */
+
+	gra_dma_base_address = addr;
+
+	if (0/*is_android()*/) {
+		writel(gra_dma_base_address,
+		       fbi->reg_base + LCD_CFG_GRA_START_ADDR0);
+	} else {
+		/* Enable the interrupt */
+		writel(readl(fbi->reg_base+SPU_IRQ_ENA)
+		       |VSYNC_IRQ_ENA(0x1),
+		       fbi->reg_base+SPU_IRQ_ENA);
+	}
+
+
 }
 
 static void set_dumb_panel_control(struct fb_info *info)
@@ -367,7 +649,9 @@ static void set_dumb_panel_control(struct fb_info *info)
 	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
 	u32 x;
 
-	/*
+        dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+
+        /*
 	 * Preserve enable flag.
 	 */
 	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL) & 0x00000001;
@@ -379,8 +663,8 @@ static void set_dumb_panel_control(struct fb_info *info)
 	x |= mi->invert_composite_blank ? 0x00000040 : 0;
 	x |= (info->var.sync & FB_SYNC_COMP_HIGH_ACT) ? 0x00000020 : 0;
 	x |= mi->invert_pix_val_ena ? 0x00000010 : 0;
-	x |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0 : 0x00000008;
-	x |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0 : 0x00000004;
+	x |= (info->var.sync & FB_SYNC_VERT_HIGH_ACT) ? 0x00000008 : 0;
+	x |= (info->var.sync & FB_SYNC_HOR_HIGH_ACT) ? 0x00000004 : 0;
 	x |= mi->invert_pixclock ? 0x00000002 : 0;
 
 	writel(x, fbi->reg_base + LCD_SPU_DUMB_CTRL);
@@ -393,37 +677,49 @@ static void set_dumb_screen_dimensions(struct fb_info *info)
 	int x;
 	int y;
 
-	x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
+	dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+
+        x = v->xres + v->right_margin + v->hsync_len + v->left_margin;
 	y = v->yres + v->lower_margin + v->vsync_len + v->upper_margin;
 
 	writel((y << 16) | x, fbi->reg_base + LCD_SPUT_V_H_TOTAL);
 }
 
+static void pxa168fb_clear_framebuffer(struct fb_info *info)
+{
+        struct pxa168fb_info *fbi = info->par;
+
+        memset(fbi->fb_start, 0, fbi->fb_size);
+}
+
 static int pxa168fb_set_par(struct fb_info *info)
 {
 	struct pxa168fb_info *fbi = info->par;
 	struct fb_var_screeninfo *var = &info->var;
-	struct fb_videomode mode;
+	const struct fb_videomode *mode;
+	int pix_fmt;
 	u32 x;
 	struct pxa168fb_mach_info *mi;
 
-	mi = fbi->dev->platform_data;
+	dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+	
+        mi = fbi->dev->platform_data;
+	/*
+	 * Determine which pixel format we're going to use.
+	 */
+	pix_fmt = determine_best_pix_fmt(&info->var);
+	if (pix_fmt < 0)
+		return pix_fmt;
+	fbi->pix_fmt = pix_fmt;
+        dev_dbg(info->dev, "Pixel Format = %d\n", pix_fmt);
 
 	/*
 	 * Set additional mode info.
 	 */
-	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
 		info->fix.visual = FB_VISUAL_PSEUDOCOLOR;
 	else
 		info->fix.visual = FB_VISUAL_TRUECOLOR;
-	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
-	info->fix.ypanstep = var->yres;
-
-	/*
-	 * Disable panel output while we setup the display.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x & ~1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
 
 	/*
 	 * Configure global panel parameters.
@@ -431,13 +727,22 @@ static int pxa168fb_set_par(struct fb_info *info)
 	writel((var->yres << 16) | var->xres,
 		fbi->reg_base + LCD_SPU_V_H_ACTIVE);
 
+        dev_dbg(info->dev, "xres=%d yres=%d\n", var->xres, var->yres);
 	/*
 	 * convet var to video mode
 	 */
-	fb_var_to_videomode(&mode, &info->var);
+
+	mode = fb_find_best_mode(var, &info->modelist);
+	set_mode(fbi, var, mode, pix_fmt, 1);
+	
+	info->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+	info->fix.ypanstep = var->yres;
+
+        info->fix.smem_len = var->xres_virtual * var->yres_virtual * var->bits_per_pixel/8;
+        info->screen_size = info->fix.smem_len;
 
 	/* Calculate clock divisor. */
-	set_clock_divider(fbi, &mode);
+	set_clock_divider(fbi, mode);
 
 	/* Configure dma ctrl regs. */
 	set_dma_control0(fbi);
@@ -446,6 +751,7 @@ static int pxa168fb_set_par(struct fb_info *info)
 	/*
 	 * Configure graphics DMA parameters.
 	 */
+	set_graphics_start(info, info->var.xoffset, info->var.yoffset);
 	x = readl(fbi->reg_base + LCD_CFG_GRA_PITCH);
 	x = (x & ~0xFFFF) | ((var->xres_virtual * var->bits_per_pixel) >> 3);
 	writel(x, fbi->reg_base + LCD_CFG_GRA_PITCH);
@@ -465,12 +771,10 @@ static int pxa168fb_set_par(struct fb_info *info)
 	writel((var->upper_margin << 16) | var->lower_margin,
 			fbi->reg_base + LCD_SPU_V_PORCH);
 
-	/*
-	 * Re-enable panel output.
-	 */
-	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
-	writel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
 
+	x = readl(fbi->reg_base + LCD_SPU_DUMB_CTRL);
+	if ((x & 1) == 0)
+		writel(x | 1, fbi->reg_base + LCD_SPU_DUMB_CTRL);
 	return 0;
 }
 
@@ -495,7 +799,7 @@ static u32 to_rgb(u16 red, u16 green, u16 blue)
 	struct pxa168fb_info *fbi = info->par;
 	u32 val;
 
-	if (info->var.grayscale)
+        if (info->var.grayscale)
 		red = green = blue = (19595 * red + 38470 * green +
 					7471 * blue) >> 16;
 
@@ -519,38 +823,228 @@ static int pxa168fb_blank(int blank, struct fb_info *info)
 {
 	struct pxa168fb_info *fbi = info->par;
 
+#ifdef CONFIG_PM
+
+	pm_message_t mesg = PMSG_SUSPEND;
+
+		switch (blank) {
+			case FB_BLANK_POWERDOWN:
+			case FB_BLANK_VSYNC_SUSPEND:
+			case FB_BLANK_HSYNC_SUSPEND:
+			case FB_BLANK_NORMAL:
+				_pxa168fb_suspend(fbi, mesg);
+				break;
+
+			case FB_BLANK_UNBLANK:
+				_pxa168fb_resume(fbi);
+				break;
+			default:
+				break;
+		}
+		return 0;
+#else
+
 	fbi->is_blanked = (blank == FB_BLANK_UNBLANK) ? 0 : 1;
 	set_dumb_panel_control(info);
 
 	return 0;
+#endif
 }
 
 static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
 				struct fb_info *info)
 {
-	set_graphics_start(info, var->xoffset, var->yoffset);
+	dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+        set_graphics_start(info, var->xoffset, var->yoffset);
 
 	return 0;
 }
 
 static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
 {
-	struct pxa168fb_info *fbi = dev_id;
-	u32 isr = readl(fbi->reg_base + SPU_IRQ_ISR);
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)dev_id;
+	u32     isr;
+
+	isr = readl(fbi->reg_base+SPU_IRQ_ISR);
 
 	if ((isr & GRA_FRAME_IRQ0_ENA_MASK)) {
+		/* wake up queue. */
+		atomic_set(&fbi->w_intr, 1);
+		wake_up(&fbi->w_intr_wq);
 
 		writel(isr & (~GRA_FRAME_IRQ0_ENA_MASK),
-			fbi->reg_base + SPU_IRQ_ISR);
+			fbi->reg_base+SPU_IRQ_ISR);
 
 		return IRQ_HANDLED;
 	}
+
 	return IRQ_NONE;
 }
 
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+static void debug_identify_called_ioctl(struct fb_info *info, int cmd, unsigned long arg)
+{
+	switch (cmd) {
+	case FBIO_CLEAR_FRAMEBUFFER:
+		dev_dbg(info->dev, " FBIO_CLEAR_FRAMEBUFFER\n");
+		break;
+	case FBIOPUT_SWAP_GRAPHIC_RED_BLUE:
+		dev_dbg(info->dev,
+			" FBIOPUT_SWAP_GRAPHIC_RED_BLUE with arg = %08x\n",
+			(unsigned int)arg);
+		break;
+	case FBIOPUT_SWAP_GRAPHIC_U_V:
+		dev_dbg(info->dev,
+			" FBIOPUT_SWAP_GRAPHIC_U_V with arg = %08x\n",
+			(unsigned int)arg);
+		break;
+	case FBIOPUT_SWAP_GRAPHIC_Y_UV:
+		dev_dbg(info->dev,
+			" FBIOPUT_SWAP_GRAPHIC_Y_UV with arg = %08x\n",
+			(unsigned int)arg);
+		break;
+	case FBIOPUT_VIDEO_ALPHABLEND:
+		dev_dbg(info->dev,
+			" FBIOPUT_VIDEO_ALPHABLEND with arg = %08x\n",
+			(unsigned int)arg);
+		break;
+	case FBIOPUT_GLOBAL_ALPHABLEND:
+		dev_dbg(info->dev,
+			" FBIOPUT_GLOBAL_ALPHABLEND with arg = %08x\n",
+			(unsigned int) arg);
+		break;
+	case FBIOPUT_GRAPHIC_ALPHABLEND:
+		dev_dbg(info->dev,
+			" FBIOPUT_GRAPHIC_ALPHABLEND with arg = %08x\n",
+			(unsigned int)arg);
+		break;
+
+	}
+}
+#endif
+
+static int pxa168_graphic_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+        int blendval;
+        int val;
+        unsigned char param;
+        struct pxa168fb_info *fbi = info->par;
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+        debug_identify_called_ioctl(info, cmd, arg);
+#endif
+
+        switch (cmd) {
+        
+        case FBIO_CLEAR_FRAMEBUFFER:
+                pxa168fb_clear_framebuffer(info);
+                return 0;
+                break;
+
+        case FBIOPUT_VIDEO_ALPHABLEND:
+                /*
+                 *  This puts the blending control to the Video layer.
+                 */
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                val &= ~CFG_ALPHA_MODE_MASK;
+                val &= ~CFG_ALPHA_MASK;
+                val |= CFG_ALPHA_MODE(0);
+                val |= CFG_ALPHA(0xff);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                return 0;
+                break;
+
+        case FBIOPUT_GLOBAL_ALPHABLEND:
+                /*
+                 *  The userspace application can specify a byte value for the amount of global blend 
+                 *  between the video layer and the graphic layer. 
+                 *
+                 *  The alpha blending is per the formula below: 
+                 *  P = (V[P] * blendval/255) + (G[P] * (1 - blendval/255))
+                 *
+                 *     where: P = Pixel value, V = Video Layer, and G = Graphic Layer
+                 */
+                blendval = (arg & 0xff);
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                val &= ~CFG_ALPHA_MODE_MASK;
+                val &= ~CFG_ALPHA_MASK;
+                val |= CFG_ALPHA_MODE(2);
+                val |= CFG_ALPHA(blendval);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                return 0;
+                break;
+
+	case FBIOPUT_GRAPHIC_ALPHABLEND:
+		/*
+		 *  This puts the blending back to the default mode of allowing
+		 *  the graphic layer to do pixel level blending.
+		 */
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+		val &= ~CFG_ALPHA_MODE_MASK;
+		val &= ~CFG_ALPHA_MASK;
+		val |= CFG_ALPHA_MODE(1);
+		val |= CFG_ALPHA(0xff);
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+		return 0;
+		break;
+
+        case FBIOPUT_SWAP_GRAPHIC_RED_BLUE:
+                param = (arg & 0x1);
+
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                val &= ~CFG_GRA_SWAPRB_MASK;
+                val |= CFG_GRA_SWAPRB(param);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                return 0;
+                break;
+
+        case FBIOPUT_SWAP_GRAPHIC_U_V:
+                param = (arg & 0x1);
+
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                val &= ~CFG_GRA_SWAPUV_MASK;
+                val |= CFG_GRA_SWAPUV(param);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                return 0;
+                break;
+
+        case FBIOPUT_SWAP_GRAPHIC_Y_UV:
+                param = (arg & 0x1);
+
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                val &= ~CFG_GRA_SWAPYU_MASK;
+                val |= CFG_GRA_SWAPYU(param);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+                return 0;
+                break;
+
+
+
+        default:
+                break;
+ 
+        }
+        return 0;
+}
+
+static int pxa168fb_release(struct fb_info *info, int user)
+{
+        struct fb_var_screeninfo *var = &info->var;
+
+        dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+        
+        /* Turn off compatibility mode */
+
+        var->nonstd &= ~0xff000000;
+        COMPAT_MODE = 0;
+	return 0;
+}
+
+
 static struct fb_ops pxa168fb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_check_var	= pxa168fb_check_var,
+	.fb_release	= pxa168fb_release,
 	.fb_set_par	= pxa168fb_set_par,
 	.fb_setcolreg	= pxa168fb_setcolreg,
 	.fb_blank	= pxa168fb_blank,
@@ -558,6 +1052,7 @@ static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
 	.fb_fillrect	= cfb_fillrect,
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
+        .fb_ioctl       = pxa168_graphic_ioctl,
 };
 
 static int pxa168fb_init_mode(struct fb_info *info,
@@ -570,11 +1065,24 @@ static int pxa168fb_init_mode(struct fb_info *info,
 	u64 div_result;
 	const struct fb_videomode *m;
 
+        dev_dbg(info->dev, "Enter %s\n", __FUNCTION__);
+
 	/*
 	 * Set default value
 	 */
 	refresh = DEFAULT_REFRESH;
 
+	/*
+	 * If has bootargs, apply it first.
+	 */
+	if (fbi->dft_vmode.xres && fbi->dft_vmode.yres &&
+	    fbi->dft_vmode.refresh) {
+		/* set data according bootargs */
+		var->xres = fbi->dft_vmode.xres;
+		var->yres = fbi->dft_vmode.yres;
+		refresh = fbi->dft_vmode.refresh;
+	}
+
 	/* try to find best video mode. */
 	m = fb_find_best_mode(&info->var, &info->modelist);
 	if (m)
@@ -582,10 +1090,7 @@ static int pxa168fb_init_mode(struct fb_info *info,
 
 	/* Init settings. */
 	var->xres_virtual = var->xres;
-	var->yres_virtual = info->fix.smem_len /
-		(var->xres_virtual * (var->bits_per_pixel >> 3));
-	dev_dbg(fbi->dev, "pxa168fb: find best mode: res = %dx%d\n",
-				var->xres, var->yres);
+	var->yres_virtual = var->yres * 2;
 
 	/* correct pixclock. */
 	total_w = var->xres + var->left_margin + var->right_margin +
@@ -600,7 +1105,57 @@ static int pxa168fb_init_mode(struct fb_info *info,
 	return ret;
 }
 
-static int pxa168fb_probe(struct platform_device *pdev)
+static void pxa168fb_set_default(struct pxa168fb_info *fbi, struct pxa168fb_mach_info *mi)
+{
+	/*
+	 * Configure default register values.
+	 */
+	/*writel(0x00000000, fbi->reg_base + LCD_SPU_BLANKCOLOR);*/
+	writel(0x55aa55aa, fbi->reg_base + LCD_SPU_BLANKCOLOR);
+	writel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);
+	writel(0x00000000, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);
+	writel(0x00000000, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);
+	writel(0x0, fbi->reg_base + LCD_SPU_SRAM_PARA0);
+	writel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),
+		fbi->reg_base + LCD_SPU_SRAM_PARA1);
+        writel(VIDEO_FIFO(1) | GRAPHIC_FIFO(1) , fbi->reg_base + LCD_FIFO_DEPTH);
+
+
+        /*
+	 * Configure default bits: vsync triggers DMA, 
+         * power save enable, configure alpha registers to
+	 * display 100% graphics, and set pixel command.
+	 */
+	writel(0x2011ff81, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+	/*writel(0x2001ff81, fbi->reg_base + LCD_SPU_DMA_CTRL1);*/
+}
+
+static void pxa168fb_power(struct pxa168fb_info *fbi, struct pxa168fb_mach_info *mi, int on)
+{
+	if (on)
+		set_dvfm_constraint();
+
+	if ((mi->spi_ctrl != -1) && (mi->spi_ctrl & CFG_SPI_ENA_MASK))
+		writel(mi->spi_ctrl, fbi->reg_base + LCD_SPU_SPI_CTRL);
+
+	if (mi->pxa168fb_lcd_power)
+		mi->pxa168fb_lcd_power(fbi, mi->spi_gpio_cs, mi->spi_gpio_reset, on);
+
+	if (!on)
+		unset_dvfm_constraint();
+}
+
+static int __init get_fb_size(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_fb_size = n;
+	return 1;
+}
+__setup("fb_size=", get_fb_size);
+
+static int  pxa168fb_probe(struct platform_device *pdev)
 {
 	struct pxa168fb_mach_info *mi;
 	struct fb_info *info = 0;
@@ -624,46 +1179,51 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (res == NULL) {
 		dev_err(&pdev->dev, "no IO memory defined\n");
-		ret = -ENOENT;
-		goto failed_put_clk;
+		return -ENOENT;
 	}
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
 		dev_err(&pdev->dev, "no IRQ defined\n");
-		ret = -ENOENT;
-		goto failed_put_clk;
+		return -ENOENT;
 	}
 
 	info = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
-	if (info == NULL) {
-		ret = -ENOMEM;
-		goto failed_put_clk;
-	}
+	if (info == NULL)
+		return -ENOMEM;
 
 	/* Initialize private data */
 	fbi = info->par;
 	fbi->info = info;
+	platform_set_drvdata(pdev, fbi);
 	fbi->clk = clk;
-	fbi->dev = info->dev = &pdev->dev;
+	fbi->dev = &pdev->dev;
 	fbi->panel_rbswap = mi->panel_rbswap;
 	fbi->is_blanked = 0;
+	fbi->debug = 0;
 	fbi->active = mi->active;
 
+	/* Initialize boot setting */
+	fbi->dft_vmode.xres = mi->modes->xres;
+	fbi->dft_vmode.yres = mi->modes->yres;
+	fbi->dft_vmode.refresh = mi->modes->refresh;
+
+	init_waitqueue_head(&fbi->w_intr_wq);
+
 	/*
 	 * Initialise static fb parameters.
 	 */
 	info->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
-		      FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+			FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
 	info->node = -1;
-	strlcpy(info->fix.id, mi->id, 16);
+	strcpy(info->fix.id, mi->id);
 	info->fix.type = FB_TYPE_PACKED_PIXELS;
 	info->fix.type_aux = 0;
 	info->fix.xpanstep = 0;
 	info->fix.ypanstep = 0;
 	info->fix.ywrapstep = 0;
 	info->fix.mmio_start = res->start;
-	info->fix.mmio_len = resource_size(res);
+	info->fix.mmio_len = res->end - res->start + 1;
 	info->fix.accel = FB_ACCEL_NONE;
 	info->fbops = &pxa168fb_ops;
 	info->pseudo_palette = fbi->pseudo_palette;
@@ -671,27 +1231,47 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	/*
 	 * Map LCD controller registers.
 	 */
-	fbi->reg_base = devm_ioremap_nocache(&pdev->dev, res->start,
-					     resource_size(res));
+	fbi->reg_base = ioremap_nocache(res->start, res->end - res->start);
 	if (fbi->reg_base == NULL) {
 		ret = -ENOMEM;
-		goto failed_free_info;
+		goto failed;
 	}
 
 	/*
 	 * Allocate framebuffer memory.
 	 */
-	info->fix.smem_len = PAGE_ALIGN(DEFAULT_FB_SIZE);
 
-	info->screen_base = dma_alloc_writecombine(fbi->dev, info->fix.smem_len,
-						&fbi->fb_start_dma, GFP_KERNEL);
-	if (info->screen_base == NULL) {
+	if (!max_fb_size) {
+		if (mi->max_fb_size)
+			max_fb_size = mi->max_fb_size;
+		else
+			max_fb_size = DEFAULT_FB_SIZE;
+	}
+	max_fb_size = PAGE_ALIGN(max_fb_size);
+	fbi->fb_size = max_fb_size;
+
+	fbi->fb_start = dma_alloc_writecombine(fbi->dev, max_fb_size,
+						&fbi->fb_start_dma,
+						GFP_KERNEL);
+
+	if (!fbi->fb_start || !fbi->fb_start_dma) {
+		fbi->fb_start = (void *)__get_free_pages(GFP_DMA | GFP_KERNEL,
+						get_order(fbi->fb_size));
+		fbi->fb_start_dma = (dma_addr_t)__virt_to_phys((long unsigned int)fbi->fb_start);
+	}
+
+	if (fbi->fb_start == NULL) {
+		printk("%s: no enough memory!\n", __func__);
 		ret = -ENOMEM;
-		goto failed_free_info;
+		goto failed;
 	}
 
-	info->fix.smem_start = (unsigned long)fbi->fb_start_dma;
-	set_graphics_start(info, 0, 0);
+	memset(fbi->fb_start, 0, fbi->fb_size);
+	info->fix.smem_start = fbi->fb_start_dma;
+	info->fix.smem_len = fbi->fb_size;
+	info->screen_base = fbi->fb_start;
+	info->screen_size = fbi->fb_size;
+	gra_dma_base_address = (unsigned int)fbi->fb_start_dma;
 
 	/*
 	 * Set video mode according to platform data.
@@ -706,29 +1286,16 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	pxa168fb_init_mode(info, mi);
 
 	/*
-	 * Fill in sane defaults.
+	 * enable controller clock
 	 */
-	ret = pxa168fb_check_var(&info->var, info);
-	if (ret)
-		goto failed_free_fbmem;
+	clk_prepare_enable(fbi->clk);
 
 	/*
-	 * enable controller clock
+	 * Fill in sane defaults.
 	 */
-	clk_enable(fbi->clk);
-
 	pxa168fb_set_par(info);
 
-	/*
-	 * Configure default register values.
-	 */
-	writel(0, fbi->reg_base + LCD_SPU_BLANKCOLOR);
-	writel(mi->io_pin_allocation_mode, fbi->reg_base + SPU_IOPAD_CONTROL);
-	writel(0, fbi->reg_base + LCD_CFG_GRA_START_ADDR1);
-	writel(0, fbi->reg_base + LCD_SPU_GRA_OVSA_HPXL_VLN);
-	writel(0, fbi->reg_base + LCD_SPU_SRAM_PARA0);
-	writel(CFG_CSB_256x32(0x1)|CFG_CSB_256x24(0x1)|CFG_CSB_256x8(0x1),
-		fbi->reg_base + LCD_SPU_SRAM_PARA1);
+	pxa168fb_set_default(fbi, mi);
 
 	/*
 	 * Allocate color map.
@@ -741,13 +1308,13 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	/*
 	 * Register irq handler.
 	 */
-	ret = devm_request_irq(&pdev->dev, irq, pxa168fb_handle_irq,
-			       IRQF_SHARED, info->fix.id, fbi);
+	ret = request_irq(irq, pxa168fb_handle_irq, IRQF_SHARED, mi->id, fbi);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "unable to request IRQ\n");
 		ret = -ENXIO;
 		goto failed_free_cmap;
 	}
+	writel(0x0, fbi->reg_base + SPU_IRQ_ISR);
 
 	/*
 	 * Enable GFX interrupt
@@ -761,77 +1328,151 @@ static int pxa168fb_probe(struct platform_device *pdev)
 	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to register pxa168-fb: %d\n", ret);
 		ret = -ENXIO;
-		goto failed_free_cmap;
+		goto failed_free_irq;
 	}
+        printk(KERN_INFO "pxa168fb: frame buffer device was loaded"
+                " to /dev/fb%d <%s>.\n", info->node, info->fix.id);
 
-	platform_set_drvdata(pdev, fbi);
+	pxa168fb_power(fbi, mi, 1);
 	return 0;
 
+failed_free_irq:
+	free_irq(irq, fbi);
 failed_free_cmap:
 	fb_dealloc_cmap(&info->cmap);
 failed_free_clk:
-	clk_disable(fbi->clk);
-failed_free_fbmem:
-	dma_free_coherent(fbi->dev, info->fix.smem_len,
-			info->screen_base, fbi->fb_start_dma);
-failed_free_info:
-	kfree(info);
-failed_put_clk:
-	clk_put(clk);
-
-	dev_err(&pdev->dev, "frame buffer device init failed with %d\n", ret);
+	clk_disable_unprepare(fbi->clk);
+	clk_put(fbi->clk);
+failed:
+	pr_err("pxa168-fb: frame buffer device init failed\n");
+	platform_set_drvdata(pdev, NULL);
+	fb_dealloc_cmap(&info->cmap);
+
+	if (fbi && fbi->reg_base) {
+		iounmap(fbi->reg_base);
+		kfree(fbi);
+	}
+
 	return ret;
 }
 
-static int pxa168fb_remove(struct platform_device *pdev)
+#ifdef CONFIG_PM
+static int _pxa168fb_suspend(struct pxa168fb_info *fbi, pm_message_t mesg)
 {
-	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
-	struct fb_info *info;
-	int irq;
-	unsigned int data;
+	struct fb_info *info = fbi->info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	unsigned int reg;
+	unsigned int cntrl0;
 
-	if (!fbi)
+	printk(KERN_INFO "_pxa168fb_suspend(): state = %d.\n", mesg.event);
+
+	if(FBINFO_STATE_SUSPENDED == info->state)
 		return 0;
 
-	/* disable DMA transfer */
-	data = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
-	data &= ~CFG_GRA_ENA_MASK;
-	writel(data, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+        /* disable the graphic place DMA to prevent disruption of the
+	 * TPO display calibration on the resume cycle.
+	 */
+	cntrl0 = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	fbi->active = 0;
+	if (cntrl0 & CFG_GRA_ENA_MASK) {
+		fbi->active = 1;
+		writel(cntrl0 & ~CFG_GRA_ENA_MASK,
+				fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	}
 
-	info = fbi->info;
+	pxa168fb_power(fbi, mi, 0);
 
-	unregister_framebuffer(info);
+	/* Disable interrupts */
+	reg = readl(fbi->reg_base+SPU_IRQ_ENA);
+	reg &= ~GRA_FRAME_IRQ0_ENA_MASK;
+	writel(reg, fbi->reg_base+SPU_IRQ_ENA);
 
-	writel(GRA_FRAME_IRQ0_ENA(0x0), fbi->reg_base + SPU_IRQ_ENA);
+	fb_set_suspend(info, 1);
 
-	if (info->cmap.len)
-		fb_dealloc_cmap(&info->cmap);
+	clk_disable(fbi->clk);
 
-	irq = platform_get_irq(pdev, 0);
+	return 0;
+}
 
-	dma_free_writecombine(fbi->dev, PAGE_ALIGN(info->fix.smem_len),
-				info->screen_base, info->fix.smem_start);
+static int _pxa168fb_resume(struct pxa168fb_info *fbi)
+{
+	struct fb_info *info = fbi->info;
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	unsigned int cntrl0;
 
-	clk_disable(fbi->clk);
-	clk_put(fbi->clk);
+	printk(KERN_INFO "pxa168fb resuming...\n");
+
+	if(FBINFO_STATE_RUNNING == info->state)
+		return 0;
+
+	clk_enable(fbi->clk);
+
+	pxa168fb_set_par(info);
+
+	pxa168fb_power(fbi, mi, 1);
+
+	pxa168fb_set_default(fbi, mi);
+
+	fb_set_suspend(info, 0);
+
+	/* Enable interrupts */
+	writel(0x0, fbi->reg_base + SPU_IRQ_ISR);
+	writel(readl(fbi->reg_base + SPU_IRQ_ENA) | GRA_FRAME_IRQ0_ENA_MASK,
+			fbi->reg_base + SPU_IRQ_ENA);
+
+	/* Re-enable the graphic DMA only after the display has been
+	 * calibrated.
+	 */
 
-	framebuffer_release(info);
+	if (fbi->active) {
+		cntrl0 = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		writel(cntrl0 | CFG_GRA_ENA_MASK,
+				fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	}
+
+	printk(KERN_INFO "pxa168fb resumed\n");
+	return 0;
+}
+
+static int pxa168fb_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+
+	_pxa168fb_suspend(fbi, mesg);
+	pdev->dev.power.power_state = mesg;
 
 	return 0;
 }
 
+static int pxa168fb_resume(struct platform_device *pdev)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	_pxa168fb_resume(fbi);
+	return 0;
+}
+#endif
+
 static struct platform_driver pxa168fb_driver = {
 	.driver		= {
 		.name	= "pxa168-fb",
 		.owner	= THIS_MODULE,
 	},
 	.probe		= pxa168fb_probe,
-	.remove		= pxa168fb_remove,
+#ifdef CONFIG_PM
+	.suspend	= pxa168fb_suspend,
+	.resume		= pxa168fb_resume,
+#endif
 };
 
-module_platform_driver(pxa168fb_driver);
+static int pxa168fb_init(void)
+{
+#ifdef CONFIG_DVFM
+	dvfm_register("LCD Base", &dvfm_dev_idx);
+#endif
+	return platform_driver_register(&pxa168fb_driver);
+}
+module_init(pxa168fb_init);
 
-MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com> "
-	      "Green Wan <gwan@marvell.com>");
-MODULE_DESCRIPTION("Framebuffer driver for PXA168/910");
+MODULE_AUTHOR("Lennert Buytenhek <buytenh@marvell.com>");
+MODULE_DESCRIPTION("Framebuffer driver for PXA168");
 MODULE_LICENSE("GPL");
diff --git a/drivers/video/pxa168fb.h b/drivers/video/pxa168fb.h
index eee0927..fc8bb61 100644
--- a/drivers/video/pxa168fb.h
+++ b/drivers/video/pxa168fb.h
@@ -461,6 +461,13 @@
 #define     PWRDN_IRQ_MASK			0x00020000
 #define     ERR_IRQ(irq)			((irq) << 16)
 #define     ERR_IRQ_MASK			0x00010000
+
+#define LCD_FIFO_DEPTH                          0x01c8
+#define     VIDEO_FIFO(fi)                      (fi << 0)
+#define     VIDEO_FIFO_MASK                     0x00000003
+#define     GRAPHIC_FIFO(fi)                    (fi << 2)
+#define     GRAPHIC_FIFO_MASK                   0x0000000c
+
 /* read-only */
 #define     DMA_FRAME_IRQ0_LEVEL_MASK		0x00008000
 #define     DMA_FRAME_IRQ1_LEVEL_MASK		0x00004000
diff --git a/drivers/video/pxa168fb_ovly.c b/drivers/video/pxa168fb_ovly.c
new file mode 100644
index 0000000..522093f
--- /dev/null
+++ b/drivers/video/pxa168fb_ovly.c
@@ -0,0 +1,2209 @@
+/**************************************************************************
+ *
+ * Copyright (c) 2009, 2010 Marvell International Ltd.
+ *
+ * This file is part of GNU program.
+ *
+ * GNU program is free software: you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation, either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * GNU program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ * Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program.
+ *
+ * If not, see http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
+ *
+ *************************************************************************/
+
+/*
+ * linux/drivers/video/pxa168fb_ovly.c -- Marvell PXA168 LCD Controller
+ *
+ * 2009-03-19   adapted from original version for PXA168
+ * 		Green Wan <gwan@marvell.com>
+ *		Kevin Liu <kliu5@marvell.com>
+ */
+
+/*
+ * 1. Adapted from:  linux/drivers/video/skeletonfb.c
+ * 2. Merged from: linux/drivers/video/dovefb.c (Lennert Buytenhek)
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/cpufreq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+
+//#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+
+/*#include <mach/pxa168fb.h>*/
+#include <video/pxa168fb.h>
+
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+#include <asm/mach-types.h>
+#include "pxa168fb.h"
+
+#ifdef CONFIG_DVFM
+#include <mach/dvfm.h>
+static int dvfm_dev_idx;
+static void set_dvfm_constraint(void)
+{
+	/* Disable Lowpower mode */
+	dvfm_disable_op_name("apps_idle", dvfm_dev_idx);
+	dvfm_disable_op_name("apps_sleep", dvfm_dev_idx);
+	dvfm_disable_op_name("sys_sleep", dvfm_dev_idx);
+}
+
+static void unset_dvfm_constraint(void)
+{
+	/* Enable Lowpower mode */
+	dvfm_enable_op_name("apps_idle", dvfm_dev_idx);
+	dvfm_enable_op_name("apps_sleep", dvfm_dev_idx);
+	dvfm_enable_op_name("sys_sleep", dvfm_dev_idx);
+}
+#else
+static void set_dvfm_constraint(void) {}
+static void unset_dvfm_constraint(void) {}
+#endif
+
+#define RESET_BUF	0x1
+#define FREE_ENTRY	0x2
+
+static int pxa168fb_set_par(struct fb_info *fi);
+static void set_graphics_start(struct fb_info *fi, int xoffset, int yoffset);
+static void set_dma_control0(struct pxa168fb_info *fbi);
+static int wait_for_vsync(struct pxa168fb_info *fbi);
+static int pxa168fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *fi);
+
+static int pxa168fb_switch_buff(struct fb_info *fi);
+static int addFreeBuf(u8 **bufList, u8 *freeBuf);
+static void clearFreeBuf(u8 **bufList, int iFlag);
+static void clearFilterBuf(u8 *bufList[][3], int iFlag);
+static void collectFreeBuf(u8 *filterList[][3], u8 **freeList, int count);
+static u8 *filterBufList[MAX_QUEUE_NUM][3];
+static u8 *freeBufList[MAX_QUEUE_NUM];
+static atomic_t global_op_count = ATOMIC_INIT(0);
+static atomic_t dma_flag = ATOMIC_INIT(0);
+static unsigned int dma_base_address;
+static unsigned int max_fb_size = 0;
+static int gLastFrame = 0;
+
+/* Compatibility mode global switch .....
+ *
+ * This is a secret switch for user space programs that may want to 
+ * select color spaces and set overlay position through the nonstd 
+ * element of fb_var_screeninfo This is the way legacy PXA display
+ * drivers were used. The mode reverts back to normal mode on driver release. 
+ *
+ * To turn on compatibility with older PXA, set the MSB of nonstd to 0xAA.
+ */
+
+static unsigned int COMPAT_MODE;
+
+
+
+static struct _sViewPortInfo gViewPortInfo = {
+	.srcWidth = 640,	/* video source size */
+	.srcHeight = 480,
+	.zoomXSize = 640,	/* size after zooming */
+	.zoomYSize = 480,
+};
+
+static struct _sViewPortOffset gViewPortOffset = {
+	.xOffset = 0,	/* position on screen */
+	.yOffset = 0
+};
+
+#ifdef FB_PM_DEBUG
+static unsigned int g_regs[1024];
+static unsigned int g_regs1[1024];
+static unsigned int pxa168fb_rw_all_regs(struct pxa168fb_info *fbi,
+		unsigned int *regs, int is_read)
+{
+	u32 i;
+	u32 reg;
+
+	for (i = 0xC0; i <= 0x01C4; i += 4) {
+		if (is_read) {
+			reg = readl(fbi->reg_base + i);
+			regs[i] = reg;
+		} else {
+			writel(regs[i], fbi->reg_base + i);
+		}
+	}
+
+	return 0;
+}
+#endif
+
+static void pxa168fb_do_tasklet(unsigned long data)
+{
+	struct fb_info *fi;
+
+	fi = (struct fb_info *)data;
+	pxa168fb_switch_buff(fi);
+}
+
+#if 0
+static struct fb_videomode *
+find_best_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var)
+{
+	struct pxa168fb_mach_info *mi = fbi->dev->platform_data;
+	struct fb_videomode *best_mode;
+	int i;
+
+        dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+	best_mode = NULL;
+	for (i = 0; i < mi->num_modes; i++) {
+		struct fb_videomode *m = mi->modes + i;
+
+		/*
+		 * Check whether this mode is suitable.
+		 */
+		if (var->xres > m->xres)
+			continue;
+		if (var->yres > m->yres)
+			continue;
+
+		/*
+		 * Check whether this mode is more suitable than
+		 * the best mode so far.
+		 */
+		if (best_mode != NULL &&
+		    (best_mode->xres < m->xres ||
+		     best_mode->yres < m->yres ||
+		     best_mode->pixclock > m->pixclock))
+			continue;
+
+		best_mode = m;
+	}
+
+	return best_mode;
+}
+#endif
+
+static int determine_best_pix_fmt(struct fb_var_screeninfo *var)
+{
+	unsigned char pxa_format;
+
+        /* compatibility switch: if var->nonstd MSB is 0xAA then skip to 
+         * using the nonstd variable to select the color space.
+         */
+        if(COMPAT_MODE != 0x2625) {        
+
+                /*
+                 * Pseudocolor mode?
+                 */
+                if (var->bits_per_pixel == 8)
+                        return PIX_FMT_PSEUDOCOLOR;
+                /*
+                 * Check for YUV422PACK.
+                 */
+                if (var->bits_per_pixel == 16 && var->red.length == 16 &&
+                    var->green.length == 16 && var->blue.length == 16) {
+                        if (var->red.offset >= var->blue.offset) {
+                                if (var->red.offset == 4)
+                                        return PIX_FMT_YUV422PACK;
+                                else
+                                        return PIX_FMT_YUYV422PACK;
+                        } else
+                                return PIX_FMT_YVU422PACK;
+                }
+                /*
+                 * Check for YUV422PLANAR.
+                 */
+                if (var->bits_per_pixel == 16 && var->red.length == 8 &&
+                    var->green.length == 4 && var->blue.length == 4) {
+                        if (var->red.offset >= var->blue.offset)
+                                return PIX_FMT_YUV422PLANAR;
+                        else
+                                return PIX_FMT_YVU422PLANAR;
+                }
+
+                /*
+                 * Check for YUV420PLANAR.
+                 */
+                if (var->bits_per_pixel == 12 && var->red.length == 8 &&
+                    var->green.length == 2 && var->blue.length == 2) {
+                        if (var->red.offset >= var->blue.offset)
+                                return PIX_FMT_YUV420PLANAR;
+                        else
+                                return PIX_FMT_YVU420PLANAR;
+                }
+                /*
+                 * Check for 565/1555.
+                 */
+                if (var->bits_per_pixel == 16 && var->red.length <= 5 &&
+                    var->green.length <= 6 && var->blue.length <= 5) {
+                        if (var->transp.length == 0) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB565;
+                                else
+                                        return PIX_FMT_BGR565;
+                        }
+
+                        if (var->transp.length == 1 && var->green.length <= 5) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB1555;
+                                else
+                                        return PIX_FMT_BGR1555;
+                        }
+
+                        /* fall through */
+                }
+
+                /*
+                 * Check for 888/A888.
+                 */
+                if (var->bits_per_pixel <= 32 && var->red.length <= 8 &&
+                    var->green.length <= 8 && var->blue.length <= 8) {
+                        if (var->bits_per_pixel == 24 && var->transp.length == 0) {
+                                if (var->red.offset >= var->blue.offset)
+                                        return PIX_FMT_RGB888PACK;
+                                else
+                                        return PIX_FMT_BGR888PACK;
+                        }
+
+			if (var->bits_per_pixel == 32 && var->transp.length == 8) {
+				if (var->red.offset >= var->blue.offset)
+					return PIX_FMT_RGBA888;
+				else
+					return PIX_FMT_BGRA888;
+			} else {
+				if (var->transp.offset == 24) {
+					if (var->red.offset >= var->blue.offset)
+						return PIX_FMT_RGB888UNPACK;
+					else
+						return PIX_FMT_BGR888UNPACK;
+				} else
+					return PIX_FMT_YUV422PACK_IRE_90_270;
+
+			}
+                        /* fall through */
+                }
+        } else {
+
+                pxa_format = (var->nonstd >> 20) & 0xf;
+        
+                switch (pxa_format) {
+                case 0:
+                        return PIX_FMT_RGB565;
+                        break;
+                case 3:
+                        return PIX_FMT_YUV422PLANAR;
+                        break;
+                case 4:
+                        return PIX_FMT_YUV420PLANAR;
+                        break;
+                case 5:
+                        return PIX_FMT_RGB1555;
+                        break;
+                case 6:
+                        return PIX_FMT_RGB888PACK;
+                        break;
+                case 7:
+                        return PIX_FMT_RGB888UNPACK;
+                        break;
+                case 8:
+                        return PIX_FMT_RGBA888;
+                        break;
+                case 9:
+                        return PIX_FMT_YUV422PACK;
+                        break;
+
+                default:
+                        return -EINVAL;
+                }
+        }
+
+
+
+	return -EINVAL;
+}
+
+static void set_pix_fmt(struct fb_var_screeninfo *var, int pix_fmt)
+{
+	switch (pix_fmt) {
+	case PIX_FMT_RGB565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 11;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_BGR565:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 6;
+		var->blue.offset = 11;   var->blue.length = 5;
+		var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+		break;
+	case PIX_FMT_RGB1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 10;    var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 0;    var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 5 << 20;
+		break;
+	case PIX_FMT_BGR1555:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;     var->red.length = 5;
+		var->green.offset = 5;   var->green.length = 5;
+		var->blue.offset = 10;   var->blue.length = 5;
+		var->transp.offset = 15; var->transp.length = 1;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 5 << 20;
+                break;
+	case PIX_FMT_RGB888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 6 << 20;
+                break;
+	case PIX_FMT_BGR888PACK:
+		var->bits_per_pixel = 24;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 6 << 20;
+                break;
+	case PIX_FMT_RGB888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 7 << 20;
+                break;
+	case PIX_FMT_BGR888UNPACK:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 24;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 7 << 20;
+                break;
+	case PIX_FMT_RGBA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 16;    var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 8 << 20;
+                break;
+	case PIX_FMT_BGRA888:
+		var->bits_per_pixel = 32;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 8;
+		var->blue.offset = 16;   var->blue.length = 8;
+		var->transp.offset = 24; var->transp.length = 8;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 8 << 20;
+                break;
+        case PIX_FMT_YUYV422PACK:
+                var->bits_per_pixel = 16;
+                var->red.offset = 8;     var->red.length = 16;
+                var->green.offset = 4;   var->green.length = 16;
+                var->blue.offset = 0;   var->blue.length = 16;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+        case PIX_FMT_YVU422PACK:
+                var->bits_per_pixel = 16;
+                var->red.offset = 0;     var->red.length = 16;
+                var->green.offset = 8;   var->green.length = 16;
+                var->blue.offset = 12;   var->blue.length = 16;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+	case PIX_FMT_YUV422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 8;	 var->red.length = 8;
+		var->green.offset = 4;   var->green.length = 4;
+		var->blue.offset = 0;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 3 << 20;
+                break;
+	case PIX_FMT_YVU422PLANAR:
+		var->bits_per_pixel = 16;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 4;
+		var->blue.offset = 12;   var->blue.length = 4;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 3 << 20;
+                break;
+	case PIX_FMT_YUV420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 4;	 var->red.length = 8;
+		var->green.offset = 2;   var->green.length = 2;
+		var->blue.offset = 0;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 4 << 20;
+                break;
+	case PIX_FMT_YVU420PLANAR:
+		var->bits_per_pixel = 12;
+		var->red.offset = 0;	 var->red.length = 8;
+		var->green.offset = 8;   var->green.length = 2;
+		var->blue.offset = 10;   var->blue.length = 2;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 4 << 20;
+                break;
+
+	case PIX_FMT_PSEUDOCOLOR:
+		var->bits_per_pixel = 8;
+		var->red.offset = 0;     var->red.length = 8;
+		var->green.offset = 0;   var->green.length = 8;
+		var->blue.offset = 0;    var->blue.length = 8;
+		var->transp.offset = 0;  var->transp.length = 0;
+		break;
+	case PIX_FMT_YUV422PACK:
+		var->bits_per_pixel = 16;
+		var->red.offset = 4;     var->red.length = 16;
+		var->green.offset = 12;   var->green.length = 16;
+		var->blue.offset = 0;    var->blue.length = 16;
+		var->transp.offset = 0;  var->transp.length = 0;
+		var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 9 << 20;
+                break;
+	case PIX_FMT_YUV422PACK_IRE_90_270:	/* YUV422 Packed will be YUV444 Packed after IRE 90 and 270 degree rotation*/
+                var->bits_per_pixel = 32;
+                var->red.offset = 16;    var->red.length = 8;
+                var->green.offset = 8;   var->green.length = 8;
+                var->blue.offset = 0;    var->blue.length = 8;
+                var->transp.offset = 0;  var->transp.length = 0;
+                var->nonstd &= ~0xff0fffff;
+                var->nonstd |= 7 << 20;
+		break;
+	default:
+		BUG();
+	}
+}
+
+static int convert_pix_fmt(u32 vmode)
+{
+/*	printk(KERN_INFO "vmode=%d\n", vmode); */
+	switch(vmode) {
+	case FB_VMODE_YUV422PACKED:
+		return PIX_FMT_YUV422PACK;
+	case FB_VMODE_YUV422PACKED_SWAPUV:
+		return PIX_FMT_YVU422PACK;
+	case FB_VMODE_YUV422PLANAR:
+		return PIX_FMT_YUV422PLANAR;
+	case FB_VMODE_YUV422PLANAR_SWAPUV:
+		return PIX_FMT_YVU422PLANAR;
+	case FB_VMODE_YUV420PLANAR:
+		return PIX_FMT_YUV420PLANAR;
+	case FB_VMODE_YUV420PLANAR_SWAPUV:
+		return PIX_FMT_YVU420PLANAR;
+	case FB_VMODE_YUV422PACKED_SWAPYUorV:
+		return PIX_FMT_YUYV422PACK;
+	case FB_VMODE_YUV422PACKED_IRE_90_270:
+		return PIX_FMT_YUV422PACK_IRE_90_270;
+	case FB_VMODE_RGB565:
+		return PIX_FMT_RGB565;
+	case FB_VMODE_BGR565:
+		return PIX_FMT_BGR565;
+	case FB_VMODE_RGB1555:
+		return PIX_FMT_RGB1555;
+	case FB_VMODE_BGR1555:
+		return PIX_FMT_BGR1555;
+	case FB_VMODE_RGB888PACK:
+		return PIX_FMT_RGB888PACK;
+	case FB_VMODE_BGR888PACK:
+		return PIX_FMT_BGR888PACK;
+	case FB_VMODE_RGBA888:
+		return PIX_FMT_RGBA888;
+	case FB_VMODE_BGRA888:
+		return PIX_FMT_BGRA888;
+	case FB_VMODE_RGB888UNPACK:
+	case FB_VMODE_BGR888UNPACK:
+	case FB_VMODE_YUV422PLANAR_SWAPYUorV:
+	case FB_VMODE_YUV420PLANAR_SWAPYUorV:
+	default:
+		return -1;
+	}
+}
+
+static void pxa168_sync_colorkey_structures(struct pxa168fb_info *fbi, int direction)
+{
+        struct _sColorKeyNAlpha *colorkey = &fbi->ckey_alpha;
+        struct pxa168_fb_chroma *chroma = &fbi->chroma;
+        unsigned int temp;
+        
+        dev_dbg(fbi->info->dev, "ENTER %s\n", __FUNCTION__);
+        if (direction == FB_SYNC_COLORKEY_TO_CHROMA) {
+                chroma->mode        = colorkey->mode;
+                chroma->y_alpha     = (colorkey->Y_ColorAlpha) & 0xff;
+                chroma->y           = (colorkey->Y_ColorAlpha >> 8) & 0xff;
+                chroma->y1          = (colorkey->Y_ColorAlpha >> 16) & 0xff;
+                chroma->y2          = (colorkey->Y_ColorAlpha >> 24) & 0xff;
+
+                chroma->u_alpha     = (colorkey->U_ColorAlpha) & 0xff;
+                chroma->u           = (colorkey->U_ColorAlpha >> 8) & 0xff;
+                chroma->u1          = (colorkey->U_ColorAlpha >> 16) & 0xff;
+                chroma->u2          = (colorkey->U_ColorAlpha >> 24) & 0xff;
+
+                chroma->v_alpha     = (colorkey->V_ColorAlpha) & 0xff;
+                chroma->v           = (colorkey->V_ColorAlpha >> 8) & 0xff;
+                chroma->v1          = (colorkey->V_ColorAlpha >> 16) & 0xff;
+                chroma->v2          = (colorkey->V_ColorAlpha >> 24) & 0xff;
+        }
+
+
+        if (direction == FB_SYNC_CHROMA_TO_COLORKEY) {
+       
+                colorkey->mode = chroma->mode;
+                temp = chroma->y_alpha;
+                temp |= chroma->y << 8;
+                temp |= chroma->y1 << 16;
+                temp |= chroma->y2 << 24;
+                colorkey->Y_ColorAlpha = temp;
+
+                temp = chroma->u_alpha;
+                temp |= chroma->u << 8;
+                temp |= chroma->u1 << 16;
+                temp |= chroma->u2 << 24;
+                colorkey->U_ColorAlpha = temp;
+
+                temp = chroma->v_alpha;
+                temp |= chroma->v << 8;
+                temp |= chroma->v1 << 16;
+                temp |= chroma->v2 << 24;
+                colorkey->V_ColorAlpha = temp;
+
+        }
+}
+
+/* check whether h/w turn on RB swap. */
+static u32 colorkey_rbswap(struct pxa168fb_info *fbi)
+{
+	unsigned int rb;
+	struct _sColorKeyNAlpha *color_a = &fbi->ckey_alpha;
+
+	rb = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	if (((color_a->alphapath == FB_GRA_PATH_ALPHA) && (rb & CFG_GRA_SWAPRB_MASK))
+		|| ((color_a->alphapath == FB_VID_PATH_ALPHA) && (rb & CFG_DMA_SWAPRB_MASK)))
+		return 1;
+	else
+		return 0;
+}
+
+static u32 pxa168fb_ovly_set_colorkeyalpha(struct pxa168fb_info *fbi)
+{
+	unsigned int temp;
+	unsigned int x;
+	struct _sColorKeyNAlpha *color_a = &fbi->ckey_alpha;
+
+        dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+	/* reset to 0x0 to disable color key. */
+	x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1) & ~(CFG_COLOR_KEY_MASK | CFG_ALPHA_MODE_MASK | CFG_ALPHA_MASK);
+
+	/* switch to color key mode */
+	switch (color_a->mode) {
+	case FB_DISABLE_COLORKEY_MODE:
+		/* do nothing */
+		break;
+	case FB_ENABLE_Y_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x1);
+		break;
+	case FB_ENABLE_U_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x2);
+		break;
+	case FB_ENABLE_V_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x4);
+		break;
+	case FB_ENABLE_RGB_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x3);
+		if (colorkey_rbswap(fbi)) {
+                        /* exchange r b fields. */
+                        temp = color_a->Y_ColorAlpha;
+                        color_a->Y_ColorAlpha = color_a->V_ColorAlpha;
+                        color_a->V_ColorAlpha = temp;
+		}
+		break;
+	case FB_ENABLE_R_COLORKEY_MODE:
+		if (colorkey_rbswap(fbi))
+			x |= CFG_COLOR_KEY_MODE(0x7);
+		else
+			x |= CFG_COLOR_KEY_MODE(0x5);
+		break;
+	case FB_ENABLE_G_COLORKEY_MODE:
+		x |= CFG_COLOR_KEY_MODE(0x6);
+	break;
+	case FB_ENABLE_B_COLORKEY_MODE:
+		if (colorkey_rbswap(fbi))
+			x |= CFG_COLOR_KEY_MODE(0x5);
+		else
+			x |= CFG_COLOR_KEY_MODE(0x7);
+		break;
+	default:
+		printk(KERN_INFO "unknown mode");
+		return -1;
+	}
+
+	/* switch to alpha path selection */
+	switch (color_a->alphapath) {
+	case FB_VID_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x0);
+		break;
+	case FB_GRA_PATH_ALPHA:
+		x |= CFG_ALPHA_MODE(0x1);
+		break;
+	case FB_CONFIG_ALPHA:
+		x |= CFG_ALPHA_MODE(0x2);
+		break;
+	default:
+		printk(KERN_INFO "unknown alpha path");
+		return -1;
+	}
+
+	/* configure alpha */
+	x |= CFG_ALPHA((color_a->config & 0xff));
+
+	writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+	writel(color_a->Y_ColorAlpha, fbi->reg_base + LCD_SPU_COLORKEY_Y);
+	writel(color_a->U_ColorAlpha, fbi->reg_base + LCD_SPU_COLORKEY_U);
+	writel(color_a->V_ColorAlpha, fbi->reg_base + LCD_SPU_COLORKEY_V);
+
+	return 0;
+}
+
+static int check_surface(struct fb_info *fi,
+			FBVideoMode new_mode,
+			struct _sViewPortInfo *new_info,
+			struct _sViewPortOffset *new_offset,
+			struct _sVideoBufferAddr *new_addr)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int changed = 0;
+	
+        dev_dbg(fi->dev, "Enter %s\n", __FUNCTION__);
+        
+        /*
+	 * check mode
+	 */
+	if (new_mode >= 0 && fbi->surface.videoMode != new_mode) {
+		fbi->surface.videoMode = new_mode;
+		fbi->pix_fmt = convert_pix_fmt(new_mode);
+		set_pix_fmt(var, fbi->pix_fmt);
+		changed = 1;
+	}
+
+	/*
+	 * check view port settings.
+	 */
+	if (new_info &&
+            (fbi->surface.viewPortInfo.srcWidth != new_info->srcWidth ||
+                 fbi->surface.viewPortInfo.srcHeight != new_info->srcHeight ||
+                 fbi->surface.viewPortInfo.zoomXSize != new_info->zoomXSize ||
+             fbi->surface.viewPortInfo.zoomYSize != new_info->zoomYSize ||
+		fbi->surface.viewPortInfo.yPitch != new_info->yPitch ||
+		fbi->surface.viewPortInfo.uPitch != new_info->uPitch ||
+		fbi->surface.viewPortInfo.vPitch != new_info->vPitch)) {
+                if (!(new_addr && new_addr->startAddr[0])) {
+			if (((new_info->srcWidth * new_info->srcHeight * var->bits_per_pixel / 8) * 2) > max_fb_size) {
+                                printk("%s: requested memory buffer size %d exceed the max limit %d!\n", __func__,
+					(new_info->srcWidth * new_info->srcHeight * var->bits_per_pixel / 4), max_fb_size);
+                                return changed;
+                        }
+                }
+                var->xres_virtual = new_info->srcWidth;
+                var->yres_virtual = new_info->srcHeight * 2;
+                var->xres = new_info->srcWidth;
+                var->yres = new_info->srcHeight;
+                fbi->surface.viewPortInfo = *new_info;
+                set_pix_fmt(var, fbi->pix_fmt);
+                changed = 1;
+        }
+
+	/*
+	 * Check offset
+	 */
+	if (new_offset &&
+	    (fbi->surface.viewPortOffset.xOffset != new_offset->xOffset ||
+	    fbi->surface.viewPortOffset.yOffset != new_offset->yOffset)) {
+		fbi->surface.viewPortOffset.xOffset = new_offset->xOffset;
+		fbi->surface.viewPortOffset.yOffset = new_offset->yOffset;
+		changed = 1;
+	}
+
+	/*
+	 * Check buffer address
+	 */
+	if (new_addr && new_addr->startAddr[0] &&
+	    fbi->new_addr[0] != (unsigned long)new_addr->startAddr[0]) {
+		fbi->new_addr[0] = (unsigned long)new_addr->startAddr[0];
+		fbi->new_addr[1] = (unsigned long)new_addr->startAddr[1];
+		fbi->new_addr[2] = (unsigned long)new_addr->startAddr[2];
+		changed = 1;
+	}
+
+	return changed;
+}
+
+static void pxa168fb_clear_framebuffer(struct fb_info *fi)
+{
+        struct pxa168fb_info *fbi = fi->par;
+
+        memset(fbi->fb_start, 0, fbi->fb_size);
+}
+
+
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+static void debug_identify_called_ioctl(struct fb_info *fi, int cmd, unsigned long arg)
+{
+        switch (cmd) {
+        case FBIO_CLEAR_FRAMEBUFFER:
+                dev_dbg(fi->dev," FBIO_CLEAR_FRAMEBUFFER\n");
+                break;
+        case FB_IOCTL_WAIT_VSYNC:
+                dev_dbg(fi->dev," FB_IOCTL_WAIT_VSYNC\n");
+                break;
+        case FB_IOCTL_GET_VIEWPORT_INFO:
+                dev_dbg(fi->dev," FB_IOCTL_GET_VIEWPORT_INFO with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SET_VIEWPORT_INFO:
+                dev_dbg(fi->dev," FB_IOCTL_SET_VIEWPORT_INFO with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SET_VIDEO_MODE:
+                dev_dbg(fi->dev," FB_IOCTL_SET_VIDEO_MODE with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_GET_VIDEO_MODE:
+                dev_dbg(fi->dev," FB_IOCTL_GET_VIDEO_MODE with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_FLIP_VID_BUFFER:
+                dev_dbg(fi->dev," FB_IOCTL_FLIP_VID_BUFFER with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_GET_FREELIST:
+                dev_dbg(fi->dev," FB_IOCTL_GET_FREELIST with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_GET_BUFF_ADDR:
+                dev_dbg(fi->dev," FB_IOCTL_GET_BUFF_ADDR with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SET_VID_OFFSET:
+                dev_dbg(fi->dev," FB_IOCTL_SET_VID_OFFSET with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_GET_VID_OFFSET:
+                dev_dbg(fi->dev," FB_IOCTL_GET_VID_OFFSET with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SET_MEMORY_TOGGLE:
+                dev_dbg(fi->dev," FB_IOCTL_SET_MEMORY_TOGGLE with arg = %08x\n",(unsigned int) arg);
+                break;
+        case FB_IOCTL_SET_COLORKEYnALPHA:
+                dev_dbg(fi->dev," FB_IOCTL_SET_COLORKEYnALPHA with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOGET_CHROMAKEYS:
+                dev_dbg(fi->dev," FBIOGET_CHROMAKEYS with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_CHROMAKEYS:
+                dev_dbg(fi->dev," FBIOPUT_CHROMAKEYS with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_GET_COLORKEYnALPHA:
+                dev_dbg(fi->dev," FB_IOCTL_GET_COLORKEYnALPHA with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SWITCH_VID_OVLY:
+                dev_dbg(fi->dev," FB_IOCTL_SWITCH_VID_OVLY with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FB_IOCTL_SWITCH_GRA_OVLY:
+                dev_dbg(fi->dev," FB_IOCTL_SWITCH_GRA_OVLY with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_SWAP_VIDEO_RED_BLUE:
+                dev_dbg(fi->dev," FBIOPUT_SWAP_VIDEO_RED_BLUE with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_SWAP_VIDEO_U_V:
+                dev_dbg(fi->dev," FBIOPUT_SWAP_VIDEO_U_V with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_SWAP_VIDEO_Y_UV:
+                dev_dbg(fi->dev," FBIOPUT_SWAP_VIDEO_Y_UV with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_VIDEO_ALPHABLEND:
+                dev_dbg(fi->dev," FBIOPUT_VIDEO_ALPHABLEND with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_GLOBAL_ALPHABLEND:
+                dev_dbg(fi->dev," FBIOPUT_GLOBAL_ALPHABLEND with arg = %08x\n", (unsigned int)arg);
+                break;
+        case FBIOPUT_GRAPHIC_ALPHABLEND:
+                dev_dbg(fi->dev," FBIOPUT_GRAPHIC_ALPHABLEND with arg = %08x\n", (unsigned int)arg);
+                break;
+
+        }
+}
+#endif
+
+static int pxa168fb_ioctl(struct fb_info *fi, unsigned int cmd,
+			unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	u32 x;
+	int vmode = 0;
+	int gfx_on = 1;
+	int vid_on = 1;
+        int val;
+        unsigned char param;
+        int blendval;
+
+#ifdef CONFIG_DYNAMIC_PRINTK_DEBUG
+        debug_identify_called_ioctl(fi, cmd, arg);
+#endif         
+
+	switch (cmd) {
+        case FBIO_CLEAR_FRAMEBUFFER:
+                pxa168fb_clear_framebuffer(fi);
+                return 0;
+                break;
+	case FB_IOCTL_WAIT_VSYNC:
+		wait_for_vsync(fbi);
+		break;
+	case FB_IOCTL_GET_VIEWPORT_INFO:
+		return copy_to_user(argp, &fbi->surface.viewPortInfo,
+			sizeof(struct _sViewPortInfo)) ? -EFAULT : 0;
+	case FB_IOCTL_SET_VIEWPORT_INFO:
+		mutex_lock(&fbi->access_ok);
+		if (copy_from_user(&gViewPortInfo, argp,
+				sizeof(gViewPortInfo))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		if (check_surface(fi, -1, &gViewPortInfo, 0, 0))
+			pxa168fb_set_par(fi);
+
+		mutex_unlock(&fbi->access_ok);
+		break;
+	case FB_IOCTL_SET_VIDEO_MODE:
+		/*
+		 * Get data from user space.
+		 */
+		if (copy_from_user(&vmode, argp, sizeof(vmode)))
+			return -EFAULT;
+
+		if (check_surface(fi, vmode, 0, 0, 0))
+			pxa168fb_set_par(fi);
+		break;
+	case FB_IOCTL_GET_VIDEO_MODE:
+		return copy_to_user(argp, &fbi->surface.videoMode,
+			sizeof(u32)) ? -EFAULT : 0;
+	case FB_IOCTL_FLIP_VID_BUFFER:
+	{
+		struct _sOvlySurface *surface = 0;
+		u8 *start_addr[3], *input_data;
+		u32 length;
+		surface = kmalloc(sizeof(struct _sOvlySurface),
+				GFP_KERNEL);
+
+		/* Get user-mode data. */
+		if (copy_from_user(surface, argp,
+					sizeof(struct _sOvlySurface))) {
+			kfree(surface);
+			return -EFAULT;
+		}
+
+		length = surface->videoBufferAddr.length;
+		start_addr[0] = surface->videoBufferAddr.startAddr[0];
+		input_data = surface->videoBufferAddr.inputData;
+
+		/*
+		 * Has DMA addr?
+		 */
+		if (start_addr[0] &&
+				(!input_data)) {
+			if (0 != addFreeBuf(freeBufList, (u8 *)surface)) {
+				printk(KERN_INFO "Error: addFreeBuf()\n");
+				mutex_unlock(&fbi->access_ok);
+				kfree(surface);
+				return -EFAULT;
+			}
+			tasklet_schedule(&fbi->tasklet);
+		} else {
+			if (check_surface(fi, surface->videoMode,
+						&surface->viewPortInfo,
+						&surface->viewPortOffset,
+						&surface->videoBufferAddr))
+				pxa168fb_set_par(fi);
+
+			/* copy buffer */
+			if (input_data) {
+				wait_for_vsync(fbi);
+				/* if support hw DMA, replace this. */
+				if (copy_from_user(fbi->fb_start,
+							input_data, length))
+					return -EFAULT;
+				return 0;
+			}
+
+			/*
+			 * if it has its own physical address,
+			 * switch to this memory. don't support YUV planar format
+			 * with split YUV buffers. but below code seems have no
+			 * chancee to execute. - FIXME
+			 */
+			if (start_addr[0]) {
+				if (fbi->mem_status)
+					free_pages(
+							(unsigned long)fbi->fb_start,
+							get_order(fbi->fb_size));
+				else
+					dma_free_writecombine(fbi->dev,
+							fbi->fb_size,
+							fbi->fb_start,
+							fbi->fb_start_dma);
+
+				fbi->fb_start = __va(start_addr[0]);
+				fbi->fb_size = length;
+				fbi->fb_start_dma =
+					(dma_addr_t)__pa(fbi->fb_start);
+				fbi->mem_status = 1;
+				fi->fix.smem_start = fbi->fb_start_dma;
+				fi->fix.smem_len = fbi->fb_size;
+				fi->screen_base = fbi->fb_start;
+				fi->screen_size = fbi->fb_size;
+			}
+
+			kfree(surface);
+		}
+
+		mutex_unlock(&fbi->access_ok);
+		return 0;
+	}
+	case FB_IOCTL_GET_FREELIST:
+	{
+		mutex_lock(&fbi->access_ok);
+
+		/* Collect expired frame to list */
+		collectFreeBuf(filterBufList, freeBufList, gLastFrame);
+
+		if (copy_to_user(argp, filterBufList,
+					3*MAX_QUEUE_NUM*sizeof(u8 *))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		clearFilterBuf(filterBufList, RESET_BUF);
+
+		mutex_unlock(&fbi->access_ok);
+		return 0;
+	}
+	case FB_IOCTL_GET_BUFF_ADDR:
+	{
+		return copy_to_user(argp, &fbi->surface.videoBufferAddr,
+			sizeof(struct _sVideoBufferAddr)) ? -EFAULT : 0;
+	}
+	case FB_IOCTL_SET_VID_OFFSET:
+		mutex_lock(&fbi->access_ok);
+		if (copy_from_user(&gViewPortOffset, argp,
+				sizeof(gViewPortOffset))) {
+			mutex_unlock(&fbi->access_ok);
+			return -EFAULT;
+		}
+
+		if (check_surface(fi, -1, 0, &gViewPortOffset, 0))
+			pxa168fb_set_par(fi);
+		mutex_unlock(&fbi->access_ok);
+		break;
+	case FB_IOCTL_GET_VID_OFFSET:
+		return copy_to_user(argp, &fbi->surface.viewPortOffset,
+			sizeof(struct _sViewPortOffset)) ? -EFAULT : 0;
+	case FB_IOCTL_SET_MEMORY_TOGGLE:
+		break;
+
+	case FB_IOCTL_SET_COLORKEYnALPHA:
+		if (copy_from_user(&fbi->ckey_alpha, argp,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+
+		pxa168fb_ovly_set_colorkeyalpha(fbi);
+		break;
+        case FBIOGET_CHROMAKEYS:
+                pxa168_sync_colorkey_structures(fbi, FB_SYNC_COLORKEY_TO_CHROMA);
+                return copy_to_user(argp, &fbi->chroma, sizeof(struct pxa168_fb_chroma)) ? -EFAULT : 0;
+        case FBIOPUT_CHROMAKEYS:
+                if (copy_from_user(&fbi->chroma, argp, sizeof(struct pxa168_fb_chroma)))
+                        return -EFAULT;
+                pxa168_sync_colorkey_structures(fbi, FB_SYNC_CHROMA_TO_COLORKEY);
+                pxa168fb_ovly_set_colorkeyalpha(fbi);
+                return copy_to_user(argp, &fbi->chroma, sizeof(struct pxa168_fb_chroma)) ? -EFAULT : 0;
+
+	case FB_IOCTL_GET_COLORKEYnALPHA:
+		if (copy_to_user(argp, &fbi->ckey_alpha,
+		    sizeof(struct _sColorKeyNAlpha)))
+			return -EFAULT;
+		break;
+	case FB_IOCTL_SWITCH_VID_OVLY:
+		if (copy_from_user(&vid_on, argp, sizeof(int)))
+			return -EFAULT;
+		if (0 == vid_on) {
+			x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0) &
+				~CFG_DMA_ENA_MASK;
+			writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+			atomic_set(&dma_flag, 0);
+		} else {
+			x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0) |
+				CFG_DMA_ENA(0x1);
+			writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+			atomic_set(&dma_flag, 1);
+		}
+		break;
+        case FB_IOCTL_SWITCH_GRA_OVLY:
+		if (copy_from_user(&gfx_on, argp, sizeof(int))){
+			return -EFAULT;
+		}
+		if (0 == gfx_on) {
+			x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0) &
+				~CFG_GRA_ENA_MASK;
+			writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		} else {
+			x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0) |
+				CFG_GRA_ENA(0x1);
+			writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		}
+		break;
+        case FBIOPUT_SWAP_VIDEO_RED_BLUE:
+                param = (arg & 0x1);
+
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		val &= ~CFG_DMA_SWAPRB_MASK;
+		val |= CFG_DMA_SWAPRB(param);
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+
+                return 0;
+                break;
+
+        case FBIOPUT_SWAP_VIDEO_U_V:
+                param = (arg & 0x1);
+
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		val &= ~CFG_DMA_SWAPUV_MASK;
+		val |= CFG_DMA_SWAPUV(param);
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+
+                return 0;
+                break;
+
+        case FBIOPUT_SWAP_VIDEO_Y_UV:
+                param = (arg & 0x1);
+
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		val &= ~CFG_DMA_SWAPYU_MASK;
+		val |= CFG_DMA_SWAPYU(param);
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+
+                return 0;
+
+                break;
+
+        case FBIOPUT_VIDEO_ALPHABLEND:
+                /*
+                 *  This puts the blending control to the Video layer.
+                 */
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                val &= ~CFG_ALPHA_MODE_MASK;
+                val &= ~CFG_ALPHA_MASK;
+                val |= CFG_ALPHA_MODE(0);
+                val |= CFG_ALPHA(0xff);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                return 0;
+                break;
+
+        case FBIOPUT_GLOBAL_ALPHABLEND:
+                /*
+                 *  The userspace application can specify a byte value for the amount of global blend 
+                 *  between the video layer and the graphic layer. 
+                 *
+                 *  The alpha blending is per the formula below: 
+                 *  P = (V[P] * blendval/255) + (G[P] * (1 - blendval/255))
+                 *
+                 *     where: P = Pixel value, V = Video Layer, and G = Graphic Layer
+                 */
+                blendval = (arg & 0xff);
+                val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                val &= ~CFG_ALPHA_MODE_MASK;
+                val &= ~CFG_ALPHA_MASK;
+                val |= CFG_ALPHA_MODE(2);
+                val |= CFG_ALPHA(blendval);
+                writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+                return 0;
+                break;
+
+	case FBIOPUT_GRAPHIC_ALPHABLEND:
+		/*
+		 *  This puts the blending back to the default mode of allowing
+		 *  the graphic layer to do pixel level blending.
+		 */
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+		val &= ~CFG_ALPHA_MODE_MASK;
+		val &= ~CFG_ALPHA_MASK;
+		val |= CFG_ALPHA_MODE(1);
+		val |= CFG_ALPHA(0xff);
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+		return 0;
+		break;
+
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static void collectFreeBuf(u8 *filterList[][3], u8 **freeList, int count)
+{
+	int i = 0, j = 0;
+	struct _sOvlySurface *srf = 0;
+	u8 *ptr;
+
+	if ((count < 1) || !filterList || !freeList)
+		return;
+
+	for (i = 0, j = 0; i < count; i++) {
+
+		ptr = freeList[i];
+
+		/* Check freeList's content. */
+		if (ptr) {
+			for (; j < MAX_QUEUE_NUM; j++) {
+				if (!(filterList[j][0])) {
+					/* get surface's ptr. */
+					srf = (struct _sOvlySurface *)ptr;
+
+					/*
+					 * save ptrs which need
+					 * to be freed.
+					 */
+					filterList[j][0] =	srf->videoBufferAddr.startAddr[0];
+                    filterList[j][1] =  srf->videoBufferAddr.startAddr[1];
+                    filterList[j][2] =  srf->videoBufferAddr.startAddr[2];
+					break;
+				}
+			}
+
+			if (j >= MAX_QUEUE_NUM)
+				break;
+
+			kfree(freeList[i]);
+			freeList[i] = 0;
+		}
+		else
+		{
+			/* till content is null. */
+			break;
+		}
+	}
+	for (i = (MAX_QUEUE_NUM-1); i >= 0; i--) {
+		if (freeList[i])
+			break;
+	}
+	for (j = count; j <= i; j++) {
+		freeList[j-count] = freeList[j];
+		freeList[j] = 0;
+	}
+//	freeList[0] = freeList[count];
+//	freeList[count] = 0;
+}
+
+static int addFreeBuf(u8 **ppBufList, u8 *pFreeBuf)
+{
+	int i = 0 ;
+	struct _sOvlySurface *srf0 = (struct _sOvlySurface *)(pFreeBuf);
+	struct _sOvlySurface *srf1 = 0;
+
+	/* Error checking */
+	if (!srf0) return -1;
+
+	for (; i < MAX_QUEUE_NUM; i++) {
+		srf1 = (struct _sOvlySurface *)ppBufList[i];
+
+		if (!srf1)
+		{
+			/* printk(KERN_INFO "Set pFreeBuf "
+			   "into %d entry.\n", i);
+			 */
+			ppBufList[i] = pFreeBuf;
+			return 0;
+		}
+
+		if (srf1->videoBufferAddr.startAddr[0] ==
+				srf0->videoBufferAddr.startAddr[0]) {
+			/* same address, free this request. */
+			kfree(pFreeBuf);
+			return 0;
+		}
+	}
+
+
+	if (i >= MAX_QUEUE_NUM)
+		printk(KERN_INFO "buffer overflow\n");
+
+	return -3;
+}
+
+static void clearFilterBuf(u8 *ppBufList[][3], int iFlag)
+{
+        /* Check null pointer. */
+        if (!ppBufList)
+                return;
+        if (RESET_BUF & iFlag)
+                memset(ppBufList, 0, 3 * MAX_QUEUE_NUM * sizeof(u8 *));
+}
+
+static void clearFreeBuf(u8 **ppBufList, int iFlag)
+{
+	int i = 0;
+
+	/* Check null pointer. */
+	if (!ppBufList)
+		return;
+
+	/* free */
+	if (FREE_ENTRY & iFlag) {
+		for (i = 0; i < MAX_QUEUE_NUM; i++) {
+			if (ppBufList && ppBufList[i])
+				kfree(ppBufList[i]);
+		}
+	}
+
+	if (RESET_BUF & iFlag)
+		memset(ppBufList, 0, MAX_QUEUE_NUM * sizeof(u8 *));
+}
+
+static int pxa168fb_open(struct fb_info *fi, int user)
+{
+	u32 val;
+        struct pxa168fb_mach_info *mi;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+
+	if (mutex_is_locked(&fbi->access_ok))
+		mutex_unlock(&fbi->access_ok);
+
+	set_dvfm_constraint();
+
+	atomic_inc(&global_op_count);
+
+	if (atomic_read(&global_op_count) == 1) {
+		mutex_lock(&fbi->access_ok);
+		mi = fbi->dev->platform_data;
+		fbi->new_addr[0] = 0;
+		fbi->new_addr[1] = 0;
+		fbi->new_addr[2] = 0;
+		fi->fix.smem_start = fbi->fb_start_dma;
+		fi->screen_base = fbi->fb_start;
+		fbi->surface.videoMode = -1;
+		fbi->surface.viewPortInfo.srcWidth = var->xres;
+		fbi->surface.viewPortInfo.srcHeight = var->yres;
+		fbi->active = 1;
+		set_pix_fmt(var, fbi->pix_fmt);
+		pxa168fb_set_par(fi);
+
+		/* clear buffer list. */
+
+		clearFilterBuf(filterBufList, RESET_BUF);
+		clearFreeBuf(freeBufList, RESET_BUF|FREE_ENTRY);
+
+		/* Compatibility with older PXA behavior.
+		   Force Video DMA engine on during the OPEN.
+		*/
+
+		val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		val |= CFG_DMA_ENA_MASK;
+		writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		mutex_unlock(&fbi->access_ok);
+	}
+	return 0;
+}
+
+static int pxa168fb_release(struct fb_info *fi, int user)
+{
+	u32 val;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+
+	dev_dbg(fi->dev, "Enter %s\n", __func__);
+
+
+	if (atomic_dec_and_test(&global_op_count)) {
+		/* clear buffer list. */
+		mutex_lock(&fbi->access_ok);
+		clearFilterBuf(filterBufList, RESET_BUF);
+		clearFreeBuf(freeBufList, RESET_BUF|FREE_ENTRY);
+		mutex_unlock(&fbi->access_ok);
+
+		/* Compatibility with older PXA behavior.
+		   Force Video DMA engine off at RELEASE.
+		*/
+		if (!atomic_read(&dma_flag)) {
+			val = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+			val &= ~(CFG_DMA_ENA_MASK);
+			writel(val, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		}
+	}
+	fbi->active = 0;
+
+        /* Turn off compatibility mode */
+
+        var->nonstd &= ~0xff000000;
+        COMPAT_MODE = 0;
+
+	unset_dvfm_constraint();
+
+	return 0;
+}
+
+static int pxa168fb_switch_buff(struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	int i = 0;
+	struct _sOvlySurface *pOvlySurface = 0;
+
+	/*
+	 * Find the latest frame.
+	 */
+	for (i = (MAX_QUEUE_NUM-1); i >= 0; i--) {
+		if (freeBufList[i]) {
+			pOvlySurface = (struct _sOvlySurface *)freeBufList[i];
+			break;
+		}
+	}
+	gLastFrame = i;
+	
+	/*
+	 * Got new frame?
+	 */
+	if (pOvlySurface && (fbi->new_addr[0] !=
+				(unsigned long)pOvlySurface->videoBufferAddr.startAddr[0])) {
+		/*
+		 * Update new surface.
+		 */
+		if (check_surface(fi, pOvlySurface->videoMode,
+					&pOvlySurface->viewPortInfo,
+					&pOvlySurface->viewPortOffset,
+					&pOvlySurface->videoBufferAddr))
+			pxa168fb_set_par(fi);
+	} else {
+		/*printk(KERN_INFO "********Oops: pOvlySurface"
+		  " is NULL!!!!\n\n");
+		 */
+		return -1;
+	}
+
+	return 0;
+}
+
+static void set_mode(struct pxa168fb_info *fbi, struct fb_var_screeninfo *var,
+		     struct fb_videomode *mode, int pix_fmt, int ystretch)
+{
+	dev_dbg(fbi->info->dev, "Enter %s\n", __FUNCTION__);
+        set_pix_fmt(var, pix_fmt);
+
+	var->xres = mode->xres;
+	var->yres = mode->yres;
+	var->xres_virtual = max(var->xres, var->xres_virtual);
+	if (ystretch)
+		var->yres_virtual = var->yres*2;
+	else
+		var->yres_virtual = max(var->yres, var->yres_virtual);
+
+	var->grayscale = 0;
+	var->accel_flags = FB_ACCEL_NONE;
+	var->pixclock = mode->pixclock;
+	var->left_margin = mode->left_margin;
+	var->right_margin = mode->right_margin;
+	var->upper_margin = mode->upper_margin;
+	var->lower_margin = mode->lower_margin;
+	var->hsync_len = mode->hsync_len;
+	var->vsync_len = mode->vsync_len;
+	var->sync = mode->sync;
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->rotate = FB_ROTATE_UR;
+}
+
+static int pxa168fb_check_var(struct fb_var_screeninfo *var, struct fb_info *fi)
+{
+	int pix_fmt;
+
+	dev_dbg(fi->dev, "Enter %s\n", __FUNCTION__);
+        if (var->bits_per_pixel == 8) {
+                printk("bits per pixel too small\n");
+		return -EINVAL;
+        }
+
+        /* compatibility mode: if the MSB of var->nonstd is 0xAA then 
+         * set xres_virtual and yres_virtual to xres and yres.
+         */
+
+        if((var->nonstd >> 24) == 0xAA) 
+                COMPAT_MODE = 0x2625;
+
+        if((var->nonstd >> 24) == 0x55)
+                COMPAT_MODE = 0x0;
+
+	/*
+	 * Basic geometry sanity checks.
+	 */
+
+	if (var->xoffset + var->xres > var->xres_virtual) {
+                printk("ERROR: xoffset + xres is greater than xres_virtual\n"); 
+		return -EINVAL;
+        }
+	if (var->yoffset + var->yres > var->yres_virtual) {
+		printk("ERROR: yoffset + yres is greater than yres_virtual\n");
+                return -EINVAL;
+        }
+
+	if (var->xres + var->right_margin +
+	    var->hsync_len + var->left_margin > 2048)
+		return -EINVAL;
+	if (var->yres + var->lower_margin +
+	    var->vsync_len + var->upper_margin > 2048)
+		return -EINVAL;
+
+	/*
+	 * Check size of framebuffer.
+	 */
+	if (var->xres_virtual * var->yres_virtual *
+	    (var->bits_per_pixel >> 3) > max_fb_size)
+		return -EINVAL;
+
+	/*
+	 * Select most suitable hardware pixel format.
+	 */
+	pix_fmt = determine_best_pix_fmt(var);
+        dev_dbg(fi->dev, "%s determine_best_pix_fmt returned: %d\n", __FUNCTION__, pix_fmt);
+	if (pix_fmt < 0)
+		return pix_fmt;
+
+	return 0;
+}
+
+static void set_dma_control0(struct pxa168fb_info *fbi)
+{
+	u32 x, x_bk;
+
+	dev_dbg(fbi->info->dev, "FB1: Enter %s\n", __FUNCTION__);
+        /*
+	 * Get reg's current value
+	 */
+	x_bk = x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	/*
+	 * clear video layer's field
+	 */
+	x &= 0xef0fff01;
+
+	/*
+	 * If we are in a pseudo-color mode, we need to enable
+	 * palette lookup.
+	 */
+	if (fbi->pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		x |= 0x10000000;
+
+	/*
+	 * Configure hardware pixel format.
+	 */
+	x |= ((fbi->pix_fmt & ~0x1000) >> 1) << 20;
+
+	/*
+	 * color format in memory:
+	 * PXA168/PXA910:
+	 * PIX_FMT_YUV422PACK: UYVY(CbY0CrY1)
+	 * PIX_FMT_YUV422PLANAR: YUV
+	 * PIX_FMT_YUV420PLANAR: YUV
+	*/
+	if (((fbi->pix_fmt & ~0x1000) >> 1) == 5) {
+		x |= 0x00000002;
+		if (fbi->pix_fmt & 0x1000) {
+			x |= ((fbi->panel_rbswap) ^ 1) << 4;    /* YUYV need swap RB after CSC. doc bug? */
+			x |= 1 << 2;    /* Y and U/V is swapped	*/
+		} else {
+			x |= (fbi->panel_rbswap) << 4;
+			x |= (fbi->pix_fmt & 1) << 3;
+		}
+	} else if (fbi->pix_fmt >= 12) {	/* PIX_FMT_YUV422PACK_IRE_90_270 is here */
+		x |= 0x00000002;
+		x |= (fbi->pix_fmt & 1) << 3;
+		x |= (fbi->panel_rbswap) << 4;
+	} else {
+		x |= (((fbi->pix_fmt & 1) ^ 1) ^ (fbi->panel_rbswap)) << 4;
+	}
+	if (x_bk != x)
+		writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+}
+
+static void set_dma_control1(struct pxa168fb_info *fbi, int sync)
+{
+	u32 x, x_bk;
+
+        dev_dbg(fbi->info->dev, "FB1: Enter %s\n", __FUNCTION__);
+	/*
+	 * Get current settings.
+	 */
+	x_bk = x = readl(fbi->reg_base + LCD_SPU_DMA_CTRL1);
+
+	/*
+	 * We trigger DMA on the falling edge of vsync if vsync is
+	 * active low, or on the rising edge if vsync is active high.
+	 */
+	if (!(sync & FB_SYNC_VERT_HIGH_ACT))
+		x |= 0x08000000;
+
+	
+	if (x_bk != x)
+		writel(x, fbi->reg_base + LCD_SPU_DMA_CTRL1);
+}
+
+static int wait_for_vsync(struct pxa168fb_info *fbi)
+{
+	if (fbi) {
+		wait_event_interruptible(fbi->w_intr_wq,
+		atomic_read(&fbi->w_intr));
+		atomic_set(&fbi->w_intr, 0);
+		return 0;
+	}
+
+	return 0;
+}
+
+static void set_graphics_start(struct fb_info *fi, int xoffset, int yoffset)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int pixel_offset;
+	unsigned long addr = 0;
+        static int debugcount = 0;
+
+	if(debugcount < 10)
+                debugcount++;
+        
+        if (debugcount < 9)
+                dev_dbg(fi->dev, "Enter %s\n", __FUNCTION__);
+
+
+	/* If we are not using the viewport functionality */
+	if (!(fbi->new_addr[0])) {
+		pixel_offset = (yoffset * var->xres_virtual) + xoffset;
+		/* Set this at VSync interrupt time */
+		dma_base_address = fbi->fb_start_dma +
+			((pixel_offset * var->bits_per_pixel) >> 3);
+	}
+
+	/* Android system does not want us to synchronize the
+	 *  dma address to VSync
+	 */
+	/* FIXME: At this stage do not check for Android system*/
+	/*if (is_android()) {*/
+	if (0) {
+		if (fbi->new_addr[0]) {
+			/* we are using the viewport functionality */
+			writel(fbi->new_addr[0], fbi->reg_base +
+			       LCD_SPU_DMA_START_ADDR_Y0);
+			if (fbi->pix_fmt >= 12 && fbi->pix_fmt <= 15) {
+				writel(fbi->new_addr[1], fbi->reg_base +
+				       LCD_SPU_DMA_START_ADDR_U0);
+				writel(fbi->new_addr[2], fbi->reg_base +
+				       LCD_SPU_DMA_START_ADDR_V0);
+			}
+		} else {
+			addr = dma_base_address;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_Y0);
+			if (fbi->pix_fmt >= 12 && fbi->pix_fmt <= 15)
+				addr += var->xres * var->yres;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_U0);
+			if ((fbi->pix_fmt>>1) == 6)
+				addr += var->xres * var->yres/2;
+			else if ((fbi->pix_fmt>>1) == 7)
+				addr += var->xres * var->yres/4;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_V0);
+		}
+	} else {
+		/* Enable the interrupt */
+		writel(readl(fbi->reg_base+SPU_IRQ_ENA)
+		       |VSYNC_IRQ_ENA(0x1),
+		       fbi->reg_base+SPU_IRQ_ENA);
+	}
+}
+
+static int pxa168fb_set_par(struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	int pix_fmt;
+	int xzoom, yzoom;
+        int xpos = 0;
+        int ypos = 0;
+
+	dev_dbg(fi->dev,"FB1: Enter %s\n", __FUNCTION__);
+        /*
+	 * Determine which pixel format we're going to use.
+	 */
+	pix_fmt = determine_best_pix_fmt(&fi->var);
+        dev_dbg(fi->dev,"determine_best_pix_fmt returned: %d\n", pix_fmt);
+	if (pix_fmt < 0)
+		return pix_fmt;
+	fbi->pix_fmt = pix_fmt;
+
+        dev_dbg(fi->dev, "pix_fmt=%d\n", pix_fmt);
+        dev_dbg(fi->dev,"BPP = %d\n", var->bits_per_pixel);
+	/*
+	 * Set additional mode info.
+	 */
+	if (pix_fmt == PIX_FMT_PSEUDOCOLOR)
+		fi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	else
+		fi->fix.visual = FB_VISUAL_TRUECOLOR;
+	fi->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	/*
+	 * Configure global panel parameters.
+	 */
+	set_dma_control0(fbi);
+	set_dma_control1(fbi, fi->var.sync);
+
+	/*
+	 * Configure graphics DMA parameters.
+	 */
+	set_graphics_start(fi, fi->var.xoffset, fi->var.yoffset);
+
+	if (((fbi->pix_fmt & ~0x1000) >> 1) < 6)
+		writel((fbi->surface.viewPortInfo.yPitch) ?
+			(fbi->surface.viewPortInfo.yPitch) :
+			var->xres * var->bits_per_pixel >> 3,
+			fbi->reg_base + LCD_SPU_DMA_PITCH_YC);
+
+	else {
+		writel(fbi->surface.viewPortInfo.yPitch ?
+			fbi->surface.viewPortInfo.yPitch : var->xres,
+			fbi->reg_base + LCD_SPU_DMA_PITCH_YC);
+		writel((fbi->surface.viewPortInfo.uPitch && fbi->surface.viewPortInfo.vPitch) ?
+			((fbi->surface.viewPortInfo.vPitch << 16) |
+			 (fbi->surface.viewPortInfo.uPitch)) :
+			((var->xres >> 1) << 16 | (var->xres >> 1)),
+			fbi->reg_base + LCD_SPU_DMA_PITCH_UV);
+	}
+
+        dev_dbg(fi->dev, "Executing Standard Mode\n");
+        writel((var->yres << 16) | var->xres,
+               fbi->reg_base + LCD_SPU_DMA_HPXL_VLN);
+        
+        yzoom = fbi->surface.viewPortInfo.zoomYSize;
+        xzoom = fbi->surface.viewPortInfo.zoomXSize;
+        
+        writel((yzoom << 16) | xzoom,
+               fbi->reg_base + LCD_SPU_DZM_HPXL_VLN);
+        
+        if(COMPAT_MODE != 0x2625) {
+                /* update video position offset */
+                dev_dbg(fi->dev, "Setting Surface offsets...\n");
+
+                writel(CFG_DMA_OVSA_VLN(fbi->surface.viewPortOffset.yOffset)|
+                       fbi->surface.viewPortOffset.xOffset,
+                       fbi->reg_base + LCD_SPUT_DMA_OVSA_HPXL_VLN);
+        }
+        else {
+                dev_dbg(fi->dev, "Executing 2625 compatibility mode\n");
+                xpos = (var->nonstd & 0x3ff);
+                ypos = (var->nonstd >> 10) & 0x3ff;
+                writel(CFG_DMA_OVSA_VLN(ypos) | xpos, fbi->reg_base + LCD_SPUT_DMA_OVSA_HPXL_VLN);
+                writel((var->height << 16) | var->width,
+                       fbi->reg_base + LCD_SPU_DZM_HPXL_VLN);
+        }
+
+        fi->fix.smem_len = var->xres_virtual * var->yres_virtual * var->bits_per_pixel/8;
+        fi->screen_size = fi->fix.smem_len;
+
+
+	return 0;
+}
+
+static unsigned int chan_to_field(unsigned int chan, struct fb_bitfield *bf)
+{
+	return ((chan & 0xffff) >> (16 - bf->length)) << bf->offset;
+}
+
+static u32 to_rgb(u16 red, u16 green, u16 blue)
+{
+	red >>= 8;
+	green >>= 8;
+	blue >>= 8;
+
+	return (red << 16) | (green << 8) | blue;
+}
+
+static int
+pxa168fb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,
+		 unsigned int blue, unsigned int trans, struct fb_info *fi)
+{
+	struct pxa168fb_info *fbi = fi->par;
+	u32 val;
+
+	if (fi->fix.visual == FB_VISUAL_TRUECOLOR && regno < 16) {
+		val =  chan_to_field(red,   &fi->var.red);
+		val |= chan_to_field(green, &fi->var.green);
+		val |= chan_to_field(blue , &fi->var.blue);
+		fbi->pseudo_palette[regno] = val;
+	}
+
+	if (fi->fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {
+		val = to_rgb(red, green, blue);
+		writel(val, fbi->reg_base + LCD_SPU_SRAM_WRDAT);
+		writel(0x8300 | regno, fbi->reg_base + LCD_SPU_SRAM_CTRL);
+	}
+
+	return 0;
+}
+
+static int pxa168fb_pan_display(struct fb_var_screeninfo *var,
+				struct fb_info *fi)
+{
+	set_graphics_start(fi, var->xoffset, var->yoffset);
+
+	return 0;
+}
+
+static int pxa168fb_fb_sync(struct fb_info *info)
+{
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)info->par;
+
+	return wait_for_vsync(fbi);
+}
+
+
+/*
+ *  pxa168fb_handle_irq(two lcd controllers)
+ */
+static irqreturn_t pxa168fb_handle_irq(int irq, void *dev_id)
+{
+	struct fb_info *fi = (struct fb_info *)dev_id;
+	struct pxa168fb_info *fbi = (struct pxa168fb_info *)fi->par;
+	struct fb_var_screeninfo *var = &fi->var;
+	u32     isr;
+	u32 addr;
+	u32 ret = IRQ_NONE;
+
+	isr = readl(fbi->reg_base+SPU_IRQ_ISR);
+
+	if ((isr & DMA_FRAME_IRQ0_ENA_MASK)) {
+		/* wake up queue. */
+		atomic_set(&fbi->w_intr, 1);
+		wake_up(&fbi->w_intr_wq);
+		writel(isr & (~DMA_FRAME_IRQ0_ENA_MASK),
+		       fbi->reg_base + SPU_IRQ_ISR);
+		ret = IRQ_HANDLED;
+	}
+
+	if ((isr & VSYNC_IRQ_ENA_MASK)) {
+		if (fbi->new_addr[0]) {
+			writel(fbi->new_addr[0], fbi->reg_base +
+			       LCD_SPU_DMA_START_ADDR_Y0);
+			if (fbi->pix_fmt >= 12 && fbi->pix_fmt <= 15) {
+				writel(fbi->new_addr[1], fbi->reg_base +
+				       LCD_SPU_DMA_START_ADDR_U0);
+				writel(fbi->new_addr[2], fbi->reg_base +
+				       LCD_SPU_DMA_START_ADDR_V0);
+			}
+		} else {
+			addr = dma_base_address;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_Y0);
+			if (fbi->pix_fmt >= 12 && fbi->pix_fmt <= 15)
+				addr += var->xres * var->yres;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_U0);
+			if ((fbi->pix_fmt>>1) == 6)
+				addr += var->xres * var->yres/2;
+			else if ((fbi->pix_fmt>>1) == 7)
+				addr += var->xres * var->yres/4;
+			writel(addr, fbi->reg_base + LCD_SPU_DMA_START_ADDR_V0);
+		}
+		/* write the graphic layer start address */
+		writel(gra_dma_base_address,
+		       fbi->reg_base + LCD_CFG_GRA_START_ADDR0);
+
+		writel(isr &= ~VSYNC_IRQ_ENA_MASK,
+		       fbi->reg_base + SPU_IRQ_ISR);
+
+		ret = IRQ_HANDLED;
+	}
+
+	return ret;
+}
+
+
+static struct fb_ops pxa168fb_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= pxa168fb_open,
+	.fb_release	= pxa168fb_release,
+
+	.fb_check_var	= pxa168fb_check_var,
+	.fb_set_par	= pxa168fb_set_par,
+	.fb_setcolreg	= pxa168fb_setcolreg,
+	.fb_pan_display	= pxa168fb_pan_display,
+	.fb_fillrect	= cfb_fillrect,
+	.fb_copyarea	= cfb_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_sync	= pxa168fb_fb_sync,
+	.fb_ioctl	= pxa168fb_ioctl,
+};
+
+static int __init get_ovly_size(char *str)
+{
+	int n;
+	if (!get_option(&str, &n))
+		return 0;
+	max_fb_size = n;
+	return 1;
+}
+__setup("ovly_size=", get_ovly_size);
+
+static int pxa168fb_probe(struct platform_device *pdev)
+{
+	struct pxa168fb_mach_info *mi;
+	struct fb_info *fi;
+	struct pxa168fb_info *fbi;
+	struct resource *res;
+	int ret;
+        int temp;
+
+	mi = pdev->dev.platform_data;
+	if (mi == NULL){
+		return -EINVAL;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL){
+		return -EINVAL;
+	}
+
+	fi = framebuffer_alloc(sizeof(struct pxa168fb_info), &pdev->dev);
+	if (fi == NULL){
+		printk("%s: no enough memory!\n", __func__);
+		return -ENOMEM;
+	}
+
+	fbi = fi->par;
+	platform_set_drvdata(pdev, fbi);
+	fbi->info = fi;
+	fbi->dev = &pdev->dev;
+	fbi->id = pdev->id;
+	fbi->panel_rbswap = mi->panel_rbswap;
+	fbi->is_blanked = 0;
+	fbi->cursor_enabled = 0;
+	fbi->debug = 0;
+	fbi->mem_status = 0;
+	init_waitqueue_head(&fbi->w_intr_wq);
+	mutex_init(&fbi->access_ok);
+
+	/* get LCD clock information. */
+	fbi->clk = clk_get(&pdev->dev, "LCDCLK");
+
+	/*
+	 * Initialise static fb parameters.
+	 */
+	fi->flags = FBINFO_DEFAULT | FBINFO_PARTIAL_PAN_OK |
+		    FBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;
+	fi->node = -1;
+	strcpy(fi->fix.id, mi->id);
+	fi->fix.type = FB_TYPE_PACKED_PIXELS;
+	fi->fix.type_aux = 0;
+	fi->fix.xpanstep = 1;
+	fi->fix.ypanstep = 1;
+	fi->fix.ywrapstep = 0;
+	fi->fix.mmio_start = res->start;
+	fi->fix.mmio_len = res->end - res->start + 1;
+	fi->fix.accel = FB_ACCEL_NONE;
+	fi->fbops = &pxa168fb_ops;
+	fi->pseudo_palette = fbi->pseudo_palette;
+
+	/*
+	 * Map LCD controller registers.
+	 */
+	fbi->reg_base = ioremap_nocache(res->start, res->end - res->start);
+	if (fbi->reg_base == NULL) {
+		printk("%s: no enough memory!\n", __func__);
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/*
+	 * Allocate framebuffer memory.
+	 */
+	if (!max_fb_size) {
+		if (mi->max_fb_size)
+			max_fb_size = mi->max_fb_size;
+		else
+			max_fb_size = DEFAULT_FB_SIZE;
+	}
+	max_fb_size = PAGE_ALIGN(max_fb_size);
+	fbi->fb_size = max_fb_size;
+
+	/*
+	 * FIXME, It may fail to alloc DMA buffer from dma_alloc_xxx
+	 */
+	fbi->fb_start = dma_alloc_writecombine(fbi->dev, max_fb_size,
+						&fbi->fb_start_dma,
+						GFP_KERNEL);
+	if (!fbi->fb_start || !fbi->fb_start_dma) {
+		fbi->new_addr[0] = 0;
+		fbi->new_addr[1] = 0;
+		fbi->new_addr[2] = 0;
+		fbi->mem_status = 1;
+		fbi->fb_start = (void *)__get_free_pages(GFP_DMA | GFP_KERNEL,
+					get_order(fbi->fb_size));
+		fbi->fb_start_dma = (dma_addr_t)__virt_to_phys((long unsigned int)fbi->fb_start);
+	}
+
+	if (fbi->fb_start == NULL) {
+		printk("%s: no enough memory!\n", __func__);
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	memset(fbi->fb_start, 0, fbi->fb_size);
+	fi->fix.smem_start = fbi->fb_start_dma;
+	fi->fix.smem_len = fbi->fb_size;
+	fi->screen_base = fbi->fb_start;
+	fi->screen_size = fbi->fb_size;
+	dma_base_address = (unsigned int)fbi->fb_start_dma;
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs, 1);
+#endif
+
+	/*
+	 * Fill in sane defaults.
+	 */
+	set_mode(fbi, &fi->var, mi->modes, mi->pix_fmt, 1);
+	pxa168fb_set_par(fi);
+	fbi->active = mi->active;
+
+	/*
+	 * Configure default register values.
+	 */
+	writel(0x00000000, fbi->reg_base + LCD_SPU_DMA_START_ADDR_Y1);
+	writel(0x00000000, fbi->reg_base + LCD_SPU_DMA_START_ADDR_U1);
+	writel(0x00000000, fbi->reg_base + LCD_SPU_DMA_START_ADDR_V1);
+	writel(0x00000000, fbi->reg_base + LCD_SPUT_DMA_OVSA_HPXL_VLN);
+
+        /* Set this frame off by default */
+        temp = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+        temp &= ~(CFG_DMA_ENA_MASK);
+        writel(temp, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+
+	/*
+	 * Allocate color map.
+	 */
+	if (fb_alloc_cmap(&fi->cmap, 256, 0) < 0) {
+		ret = -ENOMEM;
+		goto failed;
+	}
+
+	/*
+	 * Get IRQ number.
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (res == NULL)
+		return -EINVAL;
+
+	/*
+	 * Register irq handler.
+	 */
+	ret = request_irq(res->start, pxa168fb_handle_irq, IRQF_SHARED,
+				mi->id, fi);
+	if (ret < 0)
+	{
+		/*
+		 *
+		 */
+		dev_err(&pdev->dev, "Failed to register pxa168fb: %d\n", ret);
+		ret = -ENXIO;
+		goto failed;
+	}
+
+	/*
+	 * Enable Video interrupt
+	 */
+	fbi->tasklet.next = NULL;
+	fbi->tasklet.state = 0;
+	atomic_set(&fbi->tasklet.count, 0);
+	fbi->tasklet.func = pxa168fb_do_tasklet;
+	fbi->tasklet.data = (unsigned long)fi;
+
+	writel(readl(fbi->reg_base+SPU_IRQ_ENA)
+	       |DMA_FRAME_IRQ0_ENA(0x1),
+	       fbi->reg_base+SPU_IRQ_ENA);
+
+	/*
+	 * Register framebuffer.
+	 */
+	ret = register_framebuffer(fi);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Failed to register pxa168fb: %d\n", ret);
+		ret = -ENXIO;
+		goto failed;
+	}
+
+	printk(KERN_INFO "pxa168fb_ovly: frame buffer device was loaded"
+		" to /dev/fb%d <%s>.\n", fi->node, fi->fix.id);
+
+#ifdef CONFIG_DVFM
+	dvfm_register("overlay1", &dvfm_dev_idx);
+#endif
+	return 0;
+
+failed:
+	platform_set_drvdata(pdev, NULL);
+	fb_dealloc_cmap(&fi->cmap);
+	if (fbi->fb_start != NULL) {
+		if (fbi->mem_status)
+			free_pages((unsigned long)fbi->fb_start,
+				get_order(max_fb_size));
+		else
+			dma_free_writecombine(fbi->dev, max_fb_size,
+				fbi->fb_start, fbi->fb_start_dma);
+	}
+	if (fbi->reg_base != NULL)
+		iounmap(fbi->reg_base);
+	kfree(fbi);
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int pxa168fb_vid_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *fi = fbi->info;
+	unsigned int cntrl0;
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs1, 1);
+#endif
+
+	cntrl0 = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	fbi->active = 0;
+	if (cntrl0 & CFG_DMA_ENA_MASK) {
+		fbi->active = 1;
+		writel(cntrl0 & ~CFG_DMA_ENA_MASK,
+				fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	}
+
+	if (mesg.event & PM_EVENT_SLEEP)
+		fb_set_suspend(fi, 1);
+	pdev->dev.power.power_state = mesg;
+
+#ifdef FB_PM_DEBUG
+	pxa168fb_rw_all_regs(fbi, g_regs, 0);
+#endif
+
+	return 0;
+}
+
+static int pxa168fb_vid_resume(struct platform_device *pdev)
+{
+	struct pxa168fb_info *fbi = platform_get_drvdata(pdev);
+	struct fb_info *fi = fbi->info;
+	unsigned int temp;
+
+	clk_enable(fbi->clk);
+	if (pxa168fb_set_par(fi) != 0) {
+		printk(KERN_INFO "pxa168fb_vid_resume(): Failed in "
+				"pxa168fb_set_par().\n");
+		return -1;
+	}
+
+	fb_set_suspend(fi, 0);
+
+	if(fbi->active){
+	        temp = readl(fbi->reg_base + SPU_IRQ_ENA);
+		temp |= GRA_FRAME_IRQ0_ENA_MASK,
+		writel(temp, fbi->reg_base + SPU_IRQ_ENA);
+
+		temp = readl(fbi->reg_base + LCD_SPU_DMA_CTRL0);
+		temp |= CFG_DMA_ENA_MASK | 0x1;
+		writel(temp, fbi->reg_base + LCD_SPU_DMA_CTRL0);
+	}
+
+#ifdef FB_PM_DEBUG
+	{
+		u32 i;
+		u32 reg;
+
+		for (i = 0xC0; i <= 0x01C4; i += 4) {
+			reg = readl(fbi->reg_base + i);
+			if (reg != g_regs1[i])
+				printk("Register 0x%08x: 0x%08x - 0x%08x.\n",
+						i, g_regs1[i], reg);
+		}
+	}
+#endif
+
+	clk_disable(fbi->clk);
+	printk(KERN_INFO "pxa168fb_vid_resumed\n");
+
+	return 0;
+}
+#endif
+
+
+static struct platform_driver pxa168fb_driver = {
+	.probe		= pxa168fb_probe,
+/*	.remove		= pxa168fb_remove,		*/
+#ifdef CONFIG_PM
+	.suspend	= pxa168fb_vid_suspend,
+	.resume		= pxa168fb_vid_resume,
+#endif
+	.driver		= {
+		.name	= "pxa168fb_ovly",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int pxa168fb_init(void)
+{
+	return platform_driver_register(&pxa168fb_driver);
+}
+
+/*module_init(pxa168fb_init);*/
+late_initcall(pxa168fb_init);
+
+MODULE_DESCRIPTION("Framebuffer driver for PXA168");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/pxa168_eth.h b/include/linux/pxa168_eth.h
index 18d75e7..2df91c5 100644
--- a/include/linux/pxa168_eth.h
+++ b/include/linux/pxa168_eth.h
@@ -20,6 +20,8 @@ struct pxa168_eth_platform_data {
 	int	rx_queue_size;
 	int	tx_queue_size;
 
+	u8	mac_addr[6];	/* mac address if non-zero*/
+
 	/*
 	 * init callback is used for board specific initialization
 	 * e.g on Aspenite its used to initialize the PHY transceiver.
diff --git a/include/linux/pxa2xx_ssp.h b/include/linux/pxa2xx_ssp.h
index 467cc63..154e7f9 100644
--- a/include/linux/pxa2xx_ssp.h
+++ b/include/linux/pxa2xx_ssp.h
@@ -215,7 +215,8 @@ static inline u32 pxa_ssp_read_reg(struct ssp_device *dev, u32 reg)
 	return __raw_readl(dev->mmio_base + reg);
 }
 
-#ifdef CONFIG_ARCH_PXA
+#if defined(CONFIG_ARCH_PXA) || (\
+    defined(CONFIG_ARCH_MMP) && defined(CONFIG_MACH_GPLUGD) )
 struct ssp_device *pxa_ssp_request(int port, const char *label);
 void pxa_ssp_free(struct ssp_device *);
 #else
diff --git a/include/video/pxa168fb.h b/include/video/pxa168fb.h
index 8c2f385..e4cecce 100644
--- a/include/video/pxa168fb.h
+++ b/include/video/pxa168fb.h
@@ -14,6 +14,221 @@
 #include <linux/fb.h>
 #include <linux/interrupt.h>
 
+/* ---------------------------------------------- */
+/*              IOCTL Definition                  */
+/* ---------------------------------------------- */
+#define FB_IOC_MAGIC                        'm'
+#define FB_IOCTL_CONFIG_CURSOR              _IO(FB_IOC_MAGIC, 0)
+#define FB_IOCTL_DUMP_REGS                  _IO(FB_IOC_MAGIC, 1)
+#define FB_IOCTL_CLEAR_IRQ                  _IO(FB_IOC_MAGIC, 2)
+
+/*
+ * There are many video mode supported.
+ */
+#define FB_IOCTL_SET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 3)
+#define FB_IOCTL_GET_VIDEO_MODE             _IO(FB_IOC_MAGIC, 4)
+/* Request a new video buffer from driver. User program needs to free
+ * this memory.
+ */
+#define FB_IOCTL_CREATE_VID_BUFFER          _IO(FB_IOC_MAGIC, 5)
+
+/* Configure viewport in driver. */
+#define FB_IOCTL_SET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 6)
+#define FB_IOCTL_GET_VIEWPORT_INFO          _IO(FB_IOC_MAGIC, 7)
+
+/* Flip the video buffer from user mode. Vide buffer can be separated into:
+ * a. Current-used buffer - user program put any data into it. It will be
+ *    displayed immediately.
+ * b. Requested from driver but not current-used - user programe can put any
+ *    data into it. It will be displayed after calling
+ *    FB_IOCTL_FLIP_VID_BUFFER.
+ *    User program should free this memory when they don't use it any more.
+ * c. User program alloated - user program can allocated a contiguos DMA
+ *    buffer to store its video data. And flip it to driver. Notices that
+ *    this momory should be free by user programs. Driver won't take care of
+ *    this.
+ */
+#define FB_IOCTL_FLIP_VID_BUFFER            _IO(FB_IOC_MAGIC, 8)
+
+/* Get the current buffer information. User program could use it to display
+ * anything directly. If developer wants to allocate multiple video layers,
+ * try to use FB_IOCTL_CREATE_VID_BUFFER  to request a brand new video
+ * buffer.
+ */
+#define FB_IOCTL_GET_BUFF_ADDR              _IO(FB_IOC_MAGIC, 9)
+
+/* Get/Set offset position of screen */
+#define FB_IOCTL_SET_VID_OFFSET             _IO(FB_IOC_MAGIC, 10)
+#define FB_IOCTL_GET_VID_OFFSET             _IO(FB_IOC_MAGIC, 11)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_MEMORY_TOGGLE          _IO(FB_IOC_MAGIC, 12)
+
+/* Turn on the memory toggle function to improve the frame rate while playing
+ * movie.
+ */
+#define FB_IOCTL_SET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 13)
+#define FB_IOCTL_GET_COLORKEYnALPHA         _IO(FB_IOC_MAGIC, 14)
+#define FB_IOCTL_SWITCH_GRA_OVLY            _IO(FB_IOC_MAGIC, 15)
+#define FB_IOCTL_SWITCH_VID_OVLY            _IO(FB_IOC_MAGIC, 16)
+
+/* For VPro integration */
+#define FB_IOCTL_GET_FREELIST               _IO(FB_IOC_MAGIC, 17)
+
+/* Wait for vsync happen. */
+#define FB_IOCTL_WAIT_VSYNC                 _IO(FB_IOC_MAGIC, 18)
+
+/* clear framebuffer: Makes resolution or color space changes look nicer */
+#define FBIO_CLEAR_FRAMEBUFFER              _IO(FB_IOC_MAGIC, 19)
+
+/* Global alpha blend controls - Maintaining compatibility with existing 
+   user programs. */
+#define FBIOPUT_VIDEO_ALPHABLEND            0xeb
+#define FBIOPUT_GLOBAL_ALPHABLEND           0xe1
+#define FBIOPUT_GRAPHIC_ALPHABLEND          0xe2
+
+/* color swapping */
+#define FBIOPUT_SWAP_GRAPHIC_RED_BLUE       0xe3
+#define FBIOPUT_SWAP_GRAPHIC_U_V            0xe4
+#define FBIOPUT_SWAP_GRAPHIC_Y_UV           0xe5
+#define FBIOPUT_SWAP_VIDEO_RED_BLUE         0xe6
+#define FBIOPUT_SWAP_VIDEO_U_V              0xe7
+#define FBIOPUT_SWAP_VIDEO_Y_UV             0xe8
+
+/* colorkey compatibility */
+#define FBIOGET_CHROMAKEYS                  0xe9    
+#define FBIOPUT_CHROMAKEYS                  0xea    
+
+
+#define FB_VMODE_RGB565			0x100
+#define FB_VMODE_BGR565                 0x101
+#define FB_VMODE_RGB1555		0x102
+#define FB_VMODE_BGR1555                0x103
+#define FB_VMODE_RGB888PACK		0x104
+#define FB_VMODE_BGR888PACK		0x105
+#define FB_VMODE_RGB888UNPACK		0x106
+#define FB_VMODE_BGR888UNPACK		0x107
+#define FB_VMODE_RGBA888		0x108
+#define FB_VMODE_BGRA888		0x109
+
+#define FB_VMODE_YUV422PACKED               0x0
+#define FB_VMODE_YUV422PACKED_SWAPUV        0x1
+#define FB_VMODE_YUV422PACKED_SWAPYUorV     0x2
+#define FB_VMODE_YUV422PLANAR               0x3
+#define FB_VMODE_YUV422PLANAR_SWAPUV        0x4
+#define FB_VMODE_YUV422PLANAR_SWAPYUorV     0x5
+#define FB_VMODE_YUV420PLANAR               0x6
+#define FB_VMODE_YUV420PLANAR_SWAPUV        0x7
+#define FB_VMODE_YUV420PLANAR_SWAPYUorV     0x8
+#define FB_VMODE_YUV422PACKED_IRE_90_270    0x9
+
+#define FB_HWCMODE_1BITMODE                 0x0
+#define FB_HWCMODE_2BITMODE                 0x1
+
+#define FB_DISABLE_COLORKEY_MODE            0x0
+#define FB_ENABLE_Y_COLORKEY_MODE           0x1
+#define FB_ENABLE_U_COLORKEY_MODE           0x2
+#define FB_ENABLE_V_COLORKEY_MODE           0x4
+#define FB_ENABLE_RGB_COLORKEY_MODE         0x3
+#define FB_ENABLE_R_COLORKEY_MODE           0x5
+#define FB_ENABLE_G_COLORKEY_MODE           0x6
+#define FB_ENABLE_B_COLORKEY_MODE           0x7
+
+#define FB_VID_PATH_ALPHA		0x0
+#define FB_GRA_PATH_ALPHA		0x1
+#define FB_CONFIG_ALPHA			0x2
+
+#define FB_SYNC_COLORKEY_TO_CHROMA          1
+#define FB_SYNC_CHROMA_TO_COLORKEY          2
+
+#define PXA168FB_FB_NUM           2
+/* overlay max buffer number */
+#define MAX_QUEUE_NUM   30
+
+/* ---------------------------------------------- */
+/*              Data Structure                    */
+/* ---------------------------------------------- */
+/*
+ * The follow structures are used to pass data from
+ * user space into the kernel for the creation of
+ * overlay surfaces and setting the video mode.
+ */
+
+#define FBVideoMode int
+
+struct _sViewPortInfo {
+        unsigned short srcWidth;        /* video source size */
+        unsigned short srcHeight;
+        unsigned short zoomXSize;       /* size after zooming */
+        unsigned short zoomYSize;
+        unsigned short yPitch;
+        unsigned short uPitch;
+	unsigned short vPitch;
+};
+
+struct _sViewPortOffset {
+        unsigned short xOffset;         /* position on screen */
+        unsigned short yOffset;
+};
+
+struct _sVideoBufferAddr {
+        unsigned char   frameID;        /* which frame wants */
+        unsigned char *startAddr[3];    /* new buffer (PA). three addr for YUV planar */
+        unsigned char *inputData;       /* input buf address (VA) */
+        unsigned int length;            /* input data's length */
+};
+
+/* The pxa168_fb_chroma structure is here for legacy compatibility with former 
+ * PXA display driver usage. 
+ */
+
+struct pxa168_fb_chroma {
+        u_char     mode;
+        u_char     y_alpha;
+        u_char     y;
+        u_char     y1;
+        u_char     y2;
+        u_char     u_alpha;
+        u_char     u;
+        u_char     u1;
+        u_char     u2;
+        u_char     v_alpha;
+        u_char     v;
+        u_char     v1;
+        u_char     v2;
+};
+
+
+struct _sColorKeyNAlpha {
+	unsigned int mode;
+	unsigned int alphapath;
+	unsigned int config;
+	unsigned int Y_ColorAlpha;
+	unsigned int U_ColorAlpha;
+	unsigned int V_ColorAlpha;
+};
+
+struct _sOvlySurface {
+        FBVideoMode videoMode;
+        struct _sViewPortInfo viewPortInfo;
+        struct _sViewPortOffset viewPortOffset;
+        struct _sVideoBufferAddr videoBufferAddr;
+};
+
+struct _sCursorConfig {
+        unsigned char   enable;         /* enable cursor or not */
+        unsigned char   mode;           /* 1bit or 2bit mode */
+        unsigned int color1;            /* foreground color */
+        unsigned int color2;            /* background color */
+        unsigned short xoffset;
+        unsigned short yoffset;
+        unsigned short  width;
+        unsigned short height;
+        unsigned char *pBuffer;         /* cursor data */
+};
+
 /* Dumb interface */
 #define PIN_MODE_DUMB_24		0
 #define PIN_MODE_DUMB_18_SPI		1
@@ -60,6 +275,15 @@
 #define PIX_FMT_YVU420PLANAR	15
 #define PIX_FMT_PSEUDOCOLOR	20
 #define PIX_FMT_UYVY422PACK	(0x1000|PIX_FMT_YUV422PACK)
+#define PIX_FMT_YUYV422PACK	(0x1000|PIX_FMT_YUV422PACK)
+#define PIX_FMT_YUV422PACK_IRE_90_270	(0x1000|PIX_FMT_RGB888UNPACK)
+
+/*
+ * panel interface
+ */
+#define DPI		0
+#define DSI2DPI		1
+#define DSI		2
 
 /*
  * PXA LCD controller private state.
@@ -67,16 +291,47 @@
 struct pxa168fb_info {
 	struct device		*dev;
 	struct clk		*clk;
+	int		id;
+	void			*dsi1_reg_base;
+	void			*dsi2_reg_base;
+	unsigned long		new_addr[3];	/* three addr for YUV planar */
 	struct fb_info		*info;
 
 	void __iomem		*reg_base;
 	dma_addr_t		fb_start_dma;
+	void			*fb_start;
+	int			fb_size;
+	atomic_t		w_intr;
+	wait_queue_head_t	w_intr_wq;
+	struct mutex		access_ok;
+	struct _sOvlySurface	surface;
+	struct _sColorKeyNAlpha		ckey_alpha;
+	struct fb_videomode	dft_vmode;
+	struct fb_videomode		out_vmode;
+	int		fixed_output;
+	unsigned char		*hwc_buf;
+	struct tasklet_struct	tasklet;
+	char 			*mode_option;
+	int			io_pin_allocation;
 	u32			pseudo_palette[16];
 
 	int			pix_fmt;
 	unsigned		is_blanked:1;
+	unsigned		edid:1;
+	unsigned		cursor_enabled:1;
+	unsigned		cursor_cfg:1;
 	unsigned		panel_rbswap:1;
+	unsigned		debug:1;
 	unsigned		active:1;
+	unsigned		enabled:1;
+	unsigned		edid_en:1;
+
+	/*
+	 * 0: DMA mem is from DMA region.
+	 * 1: DMA mem is from normal region.
+	 */
+	unsigned		mem_status:1;
+	struct pxa168_fb_chroma chroma;
 };
 
 /*
@@ -84,9 +339,11 @@ struct pxa168fb_info {
  */
 struct pxa168fb_mach_info {
 	char	id[16];
+	unsigned int	sclk_clock;
 
 	int		num_modes;
 	struct fb_videomode *modes;
+	unsigned int max_fb_size;
 
 	/*
 	 * Pix_fmt
@@ -117,9 +374,31 @@ struct pxa168fb_mach_info {
 	unsigned	invert_composite_blank:1;
 	unsigned	invert_pix_val_ena:1;
 	unsigned	invert_pixclock:1;
+	unsigned	invert_vsync:1;
+	unsigned	invert_hsync:1;
 	unsigned	panel_rbswap:1;
 	unsigned	active:1;
 	unsigned	enable_lcd:1;
+	/*
+	 * SPI control
+	 */
+	unsigned int	spi_ctrl;
+	unsigned int	spi_gpio_cs;
+	unsigned int 	spi_gpio_reset;
+	/*
+	 * panel interface
+	*/
+	unsigned int 	display_interface;
+
+	/*
+	 * power on/off function.
+	 */
+	void (*pxa168fb_lcd_power)(struct pxa168fb_info *, unsigned int, unsigned int, int);
+	/*
+	 * dsi to dpi setting function
+	 */
+	void (*dsi2dpi_set)(struct pxa168fb_info *);
 };
+extern unsigned int gra_dma_base_address;
 
 #endif /* __ASM_MACH_PXA168FB_H */
-- 
1.8.1.6

