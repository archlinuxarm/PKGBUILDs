diff -ruN a/arch/arm/mach-kirkwood/bubba3-gpio.c b/arch/arm/mach-kirkwood/bubba3-gpio.c
--- a/arch/arm/mach-kirkwood/bubba3-gpio.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/bubba3-gpio.c	2013-09-16 01:27:45.727771513 -0600
@@ -0,0 +1,391 @@
+/*
+ * Excito BUBBA|3 led driver.
+ *
+ * Copyright (C) 2010 Excito Elektronik i Sk√•ne AB
+ * Author: "Tor Krill" <tor@excito.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This driver provides an interface to the GPIO functionality on BUBBA|3
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/bubba3.h>
+#include <asm/mach-types.h>
+
+/* Mark this file for ident */
+static char* ver="0.1";
+static char* build=__DATE__ " " __TIME__;
+
+#define DEVNAME "bubbatwo"
+#define LED_DEFAULT_FREQ 0x8000
+
+/* Meta information for this module */
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tor Krill <tor@excito.com>");
+MODULE_DESCRIPTION("BUBBA|3 led driver");
+
+/* Forwards */
+static int b3_probe(struct platform_device  *dev);
+static int b3_remove(struct platform_device *dev);
+static void b3_led_on(void);
+
+#define MODE_OFF	0
+#define MODE_BLINK	1
+#define MODE_LIT	2
+#define BUZZ_OFF	0
+#define BUZZ_ON		1
+#define LED_BLUE	0
+#define LED_RED		1
+#define LED_GREEN	2
+#define LED_BOOT	3
+#define LED_INSTALL	LED_GREEN
+
+struct b3_stateinfo{
+	u32 mode;
+	u32 freq;
+	u32 buzz;
+	u32 color;
+};
+
+static struct b3_stateinfo b3_data;
+
+static void b3_led_reset(void)
+{
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(1800);
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(1800);
+}
+
+static void b3_led_train_start(void)
+{
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(1800);
+}
+
+static void b3_led_train_end(void)
+{
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,1);
+	udelay(10);
+	gpio_set_value(B3_LED_INTERVAL,0);
+	udelay(1800);
+}
+
+static void b3_led_color(u32 color){
+	gpio_set_value(B3_FRONT_LED_RED,0);
+	gpio_set_value(B3_FRONT_LED_BLUE,0);
+	gpio_set_value(B3_FRONT_LED_GREEN,0);
+
+	switch(color){
+	case LED_BOOT:
+		gpio_set_value(B3_FRONT_LED_RED,1);
+		gpio_set_value(B3_FRONT_LED_BLUE,1);
+		break;
+	case LED_RED:
+		gpio_set_value(B3_FRONT_LED_RED,1);
+		break;
+	case LED_GREEN:
+		gpio_set_value(B3_FRONT_LED_GREEN,1);
+		break;
+	case LED_BLUE:
+	default:
+		gpio_set_value(B3_FRONT_LED_BLUE,1);
+		break;
+	}
+}
+
+static void b3_led_on(void)
+{
+	b3_led_color(b3_data.color);
+
+	b3_led_reset();
+
+	b3_led_train_start();
+	/* NOOP, pass through mode */
+	b3_led_train_end();
+
+	gpio_set_value(B3_LED_INTERVAL,1);
+}
+
+static void b3_led_off(void)
+{
+	gpio_set_value(B3_FRONT_LED_RED,0);
+	gpio_set_value(B3_FRONT_LED_BLUE,0);
+	gpio_set_value(B3_FRONT_LED_GREEN,0);
+
+	b3_led_reset();
+}
+
+static void b3_buzz_on(void)
+{
+	gpio_set_value(B3_BUZZER_ENABLE,1);
+}
+
+static void b3_buzz_off(void)
+{
+	gpio_set_value(B3_BUZZER_ENABLE,0);
+}
+
+
+static struct platform_device *b3_device;
+
+static struct platform_driver b3_driver = {
+		.driver = {
+				.name = DEVNAME,
+				.owner = THIS_MODULE,
+		},
+		.probe = b3_probe,
+		.remove = b3_remove,
+};
+
+static ssize_t	b3_show_ledmode(struct device *dev, struct device_attribute *attr, char *buffer)
+{
+	ssize_t len = 0;
+	switch(b3_data.mode){
+	case MODE_OFF:
+		len = sprintf (buffer+len, "off");
+		break;
+	case MODE_BLINK:
+		len = sprintf (buffer+len, "blink");
+		break;
+	case MODE_LIT:
+		len = sprintf (buffer+len, "lit");
+		break;
+	default:
+		len = sprintf (buffer+len, "unknown");
+	}
+
+	return len;
+}
+
+static ssize_t b3_store_ledmode(struct device *dev, struct device_attribute *attr,const char *buffer, size_t size)
+{
+
+	if(size<1){
+		return -EINVAL;
+	}
+	/* Do a nasty shortcut here only look at first char */
+	switch(buffer[0]){
+	case 'o':
+		b3_data.mode=MODE_OFF;
+		b3_led_off ();
+		break;
+	case 'b':
+		/* For now we dont allow blink. */
+	case 'l':
+		b3_data.mode=MODE_LIT;
+		b3_led_on ();
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t	b3_show_ledfreq(struct device *dev, struct device_attribute *attr, char *buffer)
+{
+	ssize_t len = 0;
+
+	len = sprintf (buffer+len, "%u", b3_data.freq);
+
+	return len;
+}
+
+static ssize_t b3_store_ledfreq(struct device *dev, struct device_attribute *attr,const char *buffer, size_t size)
+{
+
+	b3_data.freq = simple_strtoul(buffer,NULL,0);
+
+	return size;
+}
+
+static ssize_t	b3_show_buzzer(struct device *dev, struct device_attribute *attr, char *buffer)
+{
+	ssize_t len = 0;
+
+	len = sprintf (buffer+len, "%u", b3_data.buzz);
+
+	return len;
+}
+
+static ssize_t b3_store_buzzer(struct device *dev, struct device_attribute *attr,const char *buffer, size_t size)
+{
+
+	b3_data.buzz = simple_strtoul(buffer,NULL,0);
+
+	b3_data.buzz = (b3_data.buzz>0) ? BUZZ_ON : BUZZ_OFF;
+
+	if(b3_data.buzz==BUZZ_ON){
+		b3_buzz_on();
+	}else{
+		b3_buzz_off();
+	}
+
+	return size;
+}
+
+static ssize_t	b3_show_color(struct device *dev, struct device_attribute *attr, char *buffer)
+{
+	ssize_t len = 0;
+
+	len = sprintf (buffer+len, "%u", b3_data.color);
+
+	return len;
+}
+
+static ssize_t b3_store_color(struct device *dev, struct device_attribute *attr,const char *buffer, size_t size)
+{
+
+	b3_data.color = simple_strtoul(buffer,NULL,0);
+
+	b3_data.color = (b3_data.color>LED_BOOT) ? LED_BOOT : b3_data.color;
+
+	b3_led_color(b3_data.color);
+
+	return size;
+}
+
+static struct gpio bubba_gpios[] = {
+#ifdef CONFIG_BUBBA3_INSTALL
+	{ B3_FRONT_LED_RED, GPIOF_OUT_INIT_LOW, "Red LED"},
+	{ B3_FRONT_LED_BLUE, GPIOF_OUT_INIT_LOW, "Blue LED"},
+	{ B3_FRONT_LED_GREEN, GPIOF_OUT_INIT_HIGH, "Green LED"},
+#else
+	{ B3_FRONT_LED_RED, GPIOF_OUT_INIT_HIGH, "Red LED"},
+	{ B3_FRONT_LED_BLUE, GPIOF_OUT_INIT_HIGH, "Blue LED"},
+	{ B3_FRONT_LED_GREEN, GPIOF_OUT_INIT_LOW, "Green LED"},
+#endif
+	{ B3_LED_INTERVAL, GPIOF_OUT_INIT_HIGH, "LED interval"},
+	{ B3_BUZZER_ENABLE, GPIOF_OUT_INIT_LOW, "Buzzer"}
+};
+
+static int request_ioresources(void)
+{
+
+	if(gpio_request_array(bubba_gpios, ARRAY_SIZE(bubba_gpios))<0){
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+DEVICE_ATTR(ledmode, 0644, b3_show_ledmode, b3_store_ledmode);
+DEVICE_ATTR(ledfreq, 0644, b3_show_ledfreq, b3_store_ledfreq);
+DEVICE_ATTR(buzzer, 0644, b3_show_buzzer, b3_store_buzzer);
+DEVICE_ATTR(color, 0644, b3_show_color, b3_store_color);
+
+static int b3_probe(struct platform_device *dev)
+{
+	int ret=0;
+
+	if(request_ioresources()){
+		return -EINVAL;
+	}
+
+	ret = device_create_file(&b3_device->dev, &dev_attr_ledmode);
+	if(ret){
+		return -EINVAL;
+	}
+
+	ret = device_create_file(&b3_device->dev, &dev_attr_ledfreq);
+	if(ret){
+		device_remove_file(&b3_device->dev, &dev_attr_ledmode);
+		return -EINVAL;
+	}
+
+	ret = device_create_file(&b3_device->dev, &dev_attr_buzzer);
+	if(ret){
+		device_remove_file(&b3_device->dev, &dev_attr_ledfreq);
+		device_remove_file(&b3_device->dev, &dev_attr_ledmode);
+		return -EINVAL;
+	}
+
+	ret = device_create_file(&b3_device->dev, &dev_attr_color);
+	if(ret){
+		device_remove_file(&b3_device->dev, &dev_attr_buzzer);
+		device_remove_file(&b3_device->dev, &dev_attr_ledfreq);
+		device_remove_file(&b3_device->dev, &dev_attr_ledmode);
+		return -EINVAL;
+	}
+
+	b3_data.mode = MODE_LIT;
+	b3_data.freq = LED_DEFAULT_FREQ;
+	b3_data.buzz = BUZZ_OFF;
+#ifdef CONFIG_BUBBA3_INSTALL
+	b3_data.color = LED_INSTALL;
+#else
+	b3_data.color = LED_BOOT;
+#endif
+	return ret;
+}
+
+static int b3_remove(struct platform_device *dev)
+{
+
+	device_remove_file (&b3_device->dev, &dev_attr_ledmode);
+	device_remove_file (&b3_device->dev, &dev_attr_ledfreq);
+	device_remove_file(&b3_device->dev, &dev_attr_buzzer);
+	device_remove_file(&b3_device->dev, &dev_attr_color);
+
+	gpio_free_array(bubba_gpios, ARRAY_SIZE(bubba_gpios));
+	return 0;
+}
+
+static int __init bubba3_init(void){
+        int result;
+
+       if(!machine_is_bubba3()){
+               return -EINVAL;
+       }
+
+        result = platform_driver_register(&b3_driver);
+        if (result < 0) {
+                printk(KERN_ERR "bubba3: Failed to register driver\n");
+                return result;
+        }
+
+		b3_device = platform_device_alloc(DEVNAME,-1);
+		platform_device_add(b3_device);
+
+		printk(KERN_INFO "BUBBA3: driver ver %s (build %s) loaded\n",ver,build);
+
+        return result;
+
+}
+
+static void __exit bubba3_cleanup(void){
+
+        platform_device_del(b3_device);
+        platform_driver_unregister(&b3_driver);
+
+        printk(KERN_INFO "bubba3 driver removed\n");
+
+}
+/* register init and cleanup functions */
+module_init(bubba3_init);
+module_exit(bubba3_cleanup);
diff -ruN a/arch/arm/mach-kirkwood/bubba3-setup.c b/arch/arm/mach-kirkwood/bubba3-setup.c
--- a/arch/arm/mach-kirkwood/bubba3-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/bubba3-setup.c	2013-09-16 01:27:45.727771513 -0600
@@ -0,0 +1,232 @@
+/*
+ * arch/arm/mach-kirkwood/bubba3-setup.c
+ * based on
+ * arch/arm/mach-kirkwood/rd88f6281-setup.c
+ *
+ * For Bubba3 miniserver from Excito
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/irq.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/bubba3.h>
+#include <linux/gpio_keys.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/time.h>
+#include <mach/kirkwood.h>
+#include <mach/bridge-regs.h>
+#include <plat/time.h>
+#include "common.h"
+#include "mpp.h"
+
+/*****************************************************************************
+ * 2048KB SPI Flash on Boot Device (Numonyx MP25P16)
+ ****************************************************************************/
+
+static struct mtd_partition bubba3_flash_parts[] = {
+	{
+		.name = "u-boot",
+		.size = SZ_512K+SZ_256K,
+		.offset = 0,
+	},
+	{
+		.name = "env",
+		.size = SZ_128K,
+		.offset = MTDPART_OFS_NXTBLK,
+	},
+	{
+		.name = "data",
+		.size = MTDPART_SIZ_FULL,
+		.offset = MTDPART_OFS_NXTBLK,
+	},
+};
+
+static const struct flash_platform_data bubba3_flash = {
+	.type		= "m25p16",
+	.name		= "spi_flash",
+	.parts		= bubba3_flash_parts,
+	.nr_parts	= ARRAY_SIZE(bubba3_flash_parts),
+};
+
+static struct spi_board_info __initdata bubba3_spi_slave_info[] = {
+	{
+		.modalias	= "m25p80",
+		.platform_data	= &bubba3_flash,
+		.irq		= -1,
+		.max_speed_hz	= 40000000,
+		.bus_num	= 0,
+		.chip_select	= 0,
+	},
+};
+
+/*****************************************************************************
+ * GPIO and keys
+ ****************************************************************************/
+
+static struct gpio_keys_button bubba3_buttons[] = {
+	[0] = {
+		.code		= KEY_POWER,
+		.gpio		= B3_POWER_BUTTON,
+		.desc		= "Power button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data bubba3_button_data = {
+	.buttons	= bubba3_buttons,
+	.nbuttons	= ARRAY_SIZE(bubba3_buttons),
+};
+
+static struct platform_device bubba3_gpio_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.dev		= {
+		.platform_data 	= &bubba3_button_data,
+	},
+};
+
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+
+static struct mv643xx_eth_platform_data bubba3_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0x08),
+	/* in case a hardcoded MAC address is needed uncomment next line */
+	/* .mac_addr	= {0x00, 0x0c, 0xc6, 0x76, 0x76, 0x2b}, */
+};
+
+static struct mv643xx_eth_platform_data bubba3_ge01_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0x18),
+	/* in case a hardcoded MAC address is needed uncomment next line */
+	/* .mac_addr	= {0x00, 0x0c, 0xc6, 0x76, 0x76, 0x2c}, */
+};
+
+static struct mv_sata_platform_data bubba3_sata_data = {
+	.n_ports	= 2,
+};
+
+/*****************************************************************************
+ * Timer
+ ****************************************************************************/
+
+static unsigned int bubba3_mpp_config[] __initdata = {
+	MPP0_SPI_SCn,
+	MPP1_SPI_MOSI,
+	MPP2_SPI_SCK,
+	MPP3_SPI_MISO,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP6_SYSRST_OUTn,
+	MPP7_PEX_RST_OUTn,
+	MPP8_TW0_SDA,
+	MPP9_TW0_SCK,
+	MPP10_UART0_TXD,
+	MPP11_UART0_RXD,
+	MPP12_GPO,
+	MPP13_UART1_TXD,
+	MPP14_UART1_RXD,
+	MPP15_SATA0_ACTn,
+	MPP16_SATA1_ACTn,
+	MPP17_SATA0_PRESENTn,
+	MPP18_GPO,
+	MPP19_GPO,
+	MPP20_GE1_TXD0,
+	MPP21_GE1_TXD1,
+	MPP22_GE1_TXD2,
+	MPP23_GE1_TXD3,
+	MPP24_GE1_RXD0,
+	MPP25_GE1_RXD1,
+	MPP26_GE1_RXD2,
+	MPP27_GE1_RXD3,
+	MPP28_GPIO,
+	MPP29_GPIO,
+	MPP30_GE1_RXCTL,
+	MPP31_GE1_RXCLK,
+	MPP32_GE1_TCLKOUT,
+	MPP33_GE1_TXCTL,
+	MPP34_GPIO,
+	MPP35_GPIO,
+	MPP36_GPIO,
+	MPP37_GPIO,
+	MPP38_GPIO,
+	MPP39_GPIO,
+	MPP40_GPIO,
+	MPP41_GPIO,
+	MPP42_GPIO,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	MPP49_GPIO,
+	0
+};
+
+static void __init bubba3_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	kirkwood_mpp_conf(bubba3_mpp_config);
+
+	kirkwood_uart0_init();
+
+	spi_register_board_info(bubba3_spi_slave_info,
+				ARRAY_SIZE(bubba3_spi_slave_info));
+	kirkwood_spi_init();
+
+	kirkwood_i2c_init();
+
+	platform_device_register(&bubba3_gpio_buttons);
+
+	/* eth0 */
+	kirkwood_ge00_init(&bubba3_ge00_data);
+
+	/* eth1 */
+	if (gpio_request(28, "PHY2 reset") != 0 ||
+		gpio_direction_input(28) != 0) // high-z
+		printk(KERN_ERR "can't deassert GPIO 28 (PHY2 reset)\n");
+	else
+		kirkwood_ge01_init(&bubba3_ge01_data);
+
+	kirkwood_sata_init(&bubba3_sata_data);
+
+	kirkwood_ehci_init();
+
+}
+
+static int __init bubba3_pci_init(void)
+{
+	if (machine_is_bubba3())
+		kirkwood_pcie_init( KW_PCIE0 | KW_PCIE1 );
+
+	return 0;
+}
+subsys_initcall(bubba3_pci_init);
+
+MACHINE_START(BUBBA3, "BUBBA3 Kirkwood based miniserver")
+	/* Maintainer: Tor Krill <tor@excito.com> */
+	.boot_params	= 0x00000100,
+	.init_machine	= bubba3_init,
+	.map_io		= kirkwood_map_io,
+	.init_early 	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/dockstar-setup.c b/arch/arm/mach-kirkwood/dockstar-setup.c
--- a/arch/arm/mach-kirkwood/dockstar-setup.c	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/dockstar-setup.c	2013-09-16 01:27:45.737771377 -0600
@@ -19,7 +19,6 @@
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <mach/kirkwood.h>
-#include <plat/mvsdio.h>
 #include "common.h"
 #include "mpp.h"
 
@@ -33,6 +32,10 @@
 		.offset = MTDPART_OFS_NXTBLK,
 		.size = SZ_4M
 	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
 		.name = "root",
 		.offset = MTDPART_OFS_NXTBLK,
 		.size = MTDPART_SIZ_FULL
@@ -45,17 +48,17 @@
 
 static struct gpio_led dockstar_led_pins[] = {
 	{
-		.name			= "dockstar:green:health",
+		.name			= "status:green:health",
 		.default_trigger	= "default-on",
 		.gpio			= 46,
 		.active_low		= 1,
 	},
 	{
-		.name			= "dockstar:orange:misc",
+		.name			= "status:orange:fault",
 		.default_trigger	= "none",
 		.gpio			= 47,
 		.active_low		= 1,
-	},
+	}
 };
 
 static struct gpio_led_platform_data dockstar_led_data = {
@@ -73,8 +76,8 @@
 
 static unsigned int dockstar_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
-	MPP46_GPIO,	/* LED green */
-	MPP47_GPIO,	/* LED orange */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
 	0
 };
 
diff -ruN a/arch/arm/mach-kirkwood/goflexhome-setup.c b/arch/arm/mach-kirkwood/goflexhome-setup.c
--- a/arch/arm/mach-kirkwood/goflexhome-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/goflexhome-setup.c	2013-09-16 01:27:45.747771289 -0600
@@ -0,0 +1,123 @@
+/*
+ * arch/arm/mach-kirkwood/goflexhome-setup.c
+ *
+ * Seagate GoFlex Home Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexhome_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_2M + SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexhome_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexhome_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_led goflexhome_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:misc",
+		.default_trigger	= "none",
+		.gpio			= 40,
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexhome_led_data = {
+	.leds		= goflexhome_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexhome_led_pins),
+};
+
+static struct platform_device goflexhome_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexhome_led_data,
+	}
+};
+
+static unsigned int goflexhome_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP40_GPIO,	/* LED White */
+	0
+};
+
+static void __init goflexhome_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexhome_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexhome_nand_parts), 60);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexhome_ge00_data);
+	kirkwood_sata_init(&goflexhome_sata_data);
+
+	platform_device_register(&goflexhome_leds);
+}
+
+MACHINE_START(GOFLEXHOME, "Seagate GoFlex Home")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.boot_params	= 0x00000100,
+	.init_machine	= goflexhome_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
+
diff -ruN a/arch/arm/mach-kirkwood/goflexnet-setup.c b/arch/arm/mach-kirkwood/goflexnet-setup.c
--- a/arch/arm/mach-kirkwood/goflexnet-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/goflexnet-setup.c	2013-09-16 01:27:45.747771289 -0600
@@ -0,0 +1,176 @@
+/*
+ * arch/arm/mach-kirkwood/goflexnet-setup.c
+ *
+ * Seagate GoFlex Net Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition goflexnet_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data goflexnet_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data goflexnet_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led goflexnet_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 46, // 0x4000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 47, // 0x8000
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:white:left0",
+		.default_trigger	= "none",
+		.gpio			= 42, // 0x0400
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left1",
+		.default_trigger	= "none",
+		.gpio			= 43, // 0x0800
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left2",
+		.default_trigger	= "none",
+		.gpio			= 44, // 0x1000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:left3",
+		.default_trigger	= "none",
+		.gpio			= 45, // 0x2000
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right0",
+		.default_trigger	= "none",
+		.gpio			= 38, // 0x0040
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right1",
+		.default_trigger	= "none",
+		.gpio			= 39, // 0x0080
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right2",
+		.default_trigger	= "none",
+		.gpio			= 40, // 0x0100
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:white:right3",
+		.default_trigger	= "none",
+		.gpio			= 41, // 0x0200
+		.active_low		= 0,
+	}
+};
+
+static struct gpio_led_platform_data goflexnet_led_data = {
+	.leds		= goflexnet_led_pins,
+	.num_leds	= ARRAY_SIZE(goflexnet_led_pins),
+};
+
+static struct platform_device goflexnet_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &goflexnet_led_data,
+	}
+};
+
+static unsigned int goflexnet_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP47_GPIO,	/* LED Orange */
+	MPP46_GPIO,	/* LED Green */
+	MPP45_GPIO,	/* LED Left Capacity 3 */
+	MPP44_GPIO,	/* LED Left Capacity 2 */
+	MPP43_GPIO,	/* LED Left Capacity 1 */
+	MPP42_GPIO,	/* LED Left Capacity 0 */
+	MPP41_GPIO,	/* LED Right Capacity 3 */
+	MPP40_GPIO,	/* LED Right Capacity 2 */
+	MPP39_GPIO,	/* LED Right Capacity 1 */
+	MPP38_GPIO,	/* LED Right Capacity 0 */
+	0
+};
+
+static void __init goflexnet_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(goflexnet_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(goflexnet_nand_parts), 60);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&goflexnet_ge00_data);
+	kirkwood_sata_init(&goflexnet_sata_data);
+
+	platform_device_register(&goflexnet_leds);
+}
+
+MACHINE_START(GOFLEXNET, "Seagate GoFlex Net")
+	/* Maintainer: Peter Carmichael <peterjncarm@ovi.com> */
+	.boot_params	= 0x00000100,
+	.init_machine	= goflexnet_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
+
diff -ruN a/arch/arm/mach-kirkwood/guruplug-setup.c b/arch/arm/mach-kirkwood/guruplug-setup.c
--- a/arch/arm/mach-kirkwood/guruplug-setup.c	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/guruplug-setup.c	2013-09-16 01:49:14.268518934 -0600
@@ -16,6 +16,8 @@
 #include <linux/mv643xx_eth.h>
 #include <linux/gpio.h>
 #include <linux/leds.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
 #include <mach/kirkwood.h>
@@ -23,6 +25,36 @@
 #include "common.h"
 #include "mpp.h"
 
+static struct mtd_partition dreamplug_partitions[] = {
+ {
+ .name = "u-boot",
+ .size = SZ_512K,
+ .offset = 0,
+ }, {
+ .name = "u-boot env",
+ .size = SZ_64K,
+ .offset = SZ_512K + SZ_512K,
+ },
+};
+
+static const struct flash_platform_data dreamplug_spi_slave_data = {
+ .type = "mx25l1606e",
+ .name = "spi_flash",
+ .parts = dreamplug_partitions,
+ .nr_parts = ARRAY_SIZE(dreamplug_partitions),
+};
+
+static struct spi_board_info __initdata dreamplug_spi_slave_info[] = {
+ {
+ .modalias = "m25p80",
+ .platform_data = &dreamplug_spi_slave_data,
+ .irq = -1,
+ .max_speed_hz = 50000000,
+ .bus_num = 0,
+ .chip_select = 0,
+ },
+};
+
 static struct mtd_partition guruplug_nand_parts[] = {
 	{
 		.name = "u-boot",
@@ -57,22 +89,24 @@
 
 static struct gpio_led guruplug_led_pins[] = {
 	{
-		.name			= "guruplug:red:health",
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
 		.gpio			= 46,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:green:health",
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
 		.gpio			= 47,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:red:wmode",
+		.name			= "status:red:wmode",
 		.gpio			= 48,
 		.active_low		= 1,
 	},
 	{
-		.name			= "guruplug:green:wmode",
+		.name			= "status:green:wmode",
 		.gpio			= 49,
 		.active_low		= 1,
 	},
@@ -91,6 +125,41 @@
 	}
 };
 
+static struct gpio_led dreamplug_led_pins[] = {
+ 	{
+ 		.name = "status:blue:bt",
+ 		.gpio = 47,
+ 		.active_low = 1,
+ 	},
+ 	{
+ 		.name = "status:green:wifi",
+ 		.gpio = 48,
+ 		.active_low = 1,
+ 	},
+ 	{
+ 		.name = "status:blue:ap",
+ 		.gpio = 49,
+ 		.active_low = 1,
+ 	},
+};
+
+static struct gpio_led_platform_data dreamplug_led_data = {
+ 	.leds = dreamplug_led_pins,
+ 	.num_leds = ARRAY_SIZE(dreamplug_led_pins),
+};
+
+static unsigned int dreamplug_mpp_config[] __initdata = {
+ 	MPP0_SPI_SCn,
+ 	MPP1_SPI_MOSI,
+ 	MPP2_SPI_SCK,
+ 	MPP3_SPI_MISO,
+ 	MPP47_GPIO, /* Bluetooth LED */
+ 	MPP48_GPIO, /* Wifi LED */
+ 	MPP49_GPIO, /* Wifi AP LED */
+ 	0
+};
+
+
 static unsigned int guruplug_mpp_config[] __initdata = {
 	MPP46_GPIO,	/* M_RLED */
 	MPP47_GPIO,	/* M_GLED */
@@ -105,10 +174,21 @@
 	 * Basic setup. Needs to be called early.
 	 */
 	kirkwood_init();
-	kirkwood_mpp_conf(guruplug_mpp_config);
 
-	kirkwood_uart0_init();
-	kirkwood_nand_init(ARRAY_AND_SIZE(guruplug_nand_parts), 25);
+ if (machine_is_guruplug()) {
+ 		kirkwood_mpp_conf(guruplug_mpp_config);
+ 		kirkwood_uart0_init();
+ 		kirkwood_nand_init(ARRAY_AND_SIZE(guruplug_nand_parts), 25);
+ 	}
+
+ 	if (machine_is_dreamplug()) {
+ 		kirkwood_mpp_conf(dreamplug_mpp_config);
+ 		kirkwood_uart0_init();
+ 		spi_register_board_info(dreamplug_spi_slave_info,
+ 			ARRAY_SIZE(dreamplug_spi_slave_info));
+ 		kirkwood_spi_init();
+ 		guruplug_leds.dev.platform_data = &dreamplug_led_data;
+ 	}
 
 	kirkwood_ehci_init();
 	kirkwood_ge00_init(&guruplug_ge00_data);
@@ -119,6 +199,7 @@
 	platform_device_register(&guruplug_leds);
 }
 
+#ifdef CONFIG_MACH_GURUPLUG
 MACHINE_START(GURUPLUG, "Marvell GuruPlug Reference Board")
 	/* Maintainer: Siddarth Gore <gores@marvell.com> */
 	.boot_params	= 0x00000100,
@@ -128,3 +209,16 @@
 	.init_irq	= kirkwood_init_irq,
 	.timer		= &kirkwood_timer,
 MACHINE_END
+#endif
+
+#ifdef CONFIG_MACH_DREAMPLUG
+MACHINE_START(DREAMPLUG, "Marvell DreamPlug Reference Board")
+	 /* Maintainer: ? */
+        .boot_params    = 0x00000100,
+        .init_machine   = guruplug_init,
+        .map_io         = kirkwood_map_io,
+        .init_early     = kirkwood_init_early,
+        .init_irq       = kirkwood_init_irq,
+        .timer          = &kirkwood_timer,
+MACHINE_END
+#endif
diff -ruN a/arch/arm/mach-kirkwood/iconnect-setup.c b/arch/arm/mach-kirkwood/iconnect-setup.c
--- a/arch/arm/mach-kirkwood/iconnect-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/iconnect-setup.c	2013-09-16 01:27:45.747771289 -0600
@@ -0,0 +1,203 @@
+/*
+ * arch/arm/mach-kirkwood/iconnect-setup.c
+ *
+ * Iomega iConnect Wireless
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/i2c.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition iconnect_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_1M + SZ_2M
+	}, {
+		.name = "rootfs",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M,
+	}, {
+		.name = "data",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data iconnect_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(11),
+};
+
+static struct gpio_led iconnect_led_pins[] = {
+	{
+		.name			= "iconnect:led_level",
+		.default_trigger	= "default-on",
+		.gpio			= 41,
+	},
+	{
+		.name			= "iconnect:blue:power",
+		.default_trigger	= "default-on",
+		.gpio			= 42,
+	},
+	{
+		.name			= "iconnect:red:power",
+		.gpio			= 43,
+	},
+	{
+		.name			= "iconnect:blue:usb1",
+		.gpio			= 44,
+	},
+	{
+		.name			= "iconnect:blue:usb2",
+		.gpio			= 45,
+	},
+	{
+		.name			= "iconnect:blue:usb3",
+		.gpio			= 46,
+	},
+	{
+		.name			= "iconnect:blue:usb4",
+		.gpio			= 47,
+	},
+	{
+		.name			= "iconnect:blue:otb",
+		.gpio			= 48,
+	},
+};
+
+static struct gpio_led_platform_data iconnect_led_data = {
+	.leds		= iconnect_led_pins,
+	.num_leds	= ARRAY_SIZE(iconnect_led_pins),
+};
+
+static struct platform_device iconnect_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &iconnect_led_data,
+	}
+};
+
+#define ICONNECT_GPIO_KEY_RESET		12
+#define ICONNECT_GPIO_KEY_OTB		35
+
+#define ICONNECT_SW_RESET		0x00
+#define ICONNECT_SW_OTB			0x01
+
+static struct gpio_keys_button iconnect_buttons[] = {
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_RESET,
+		.gpio		= ICONNECT_GPIO_KEY_RESET,
+		.desc		= "Reset Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		}, 
+		{
+		.type		= EV_SW,
+		.code		= ICONNECT_SW_OTB,
+		.gpio		= ICONNECT_GPIO_KEY_OTB,
+		.desc		= "OTB Button",
+		.active_low	= 1,
+		.debounce_interval = 100,
+		},
+};
+
+static struct gpio_keys_platform_data iconnect_button_data = {
+	.buttons	= iconnect_buttons,
+	.nbuttons	= ARRAY_SIZE(iconnect_buttons),
+};
+
+static struct platform_device iconnect_button_device = {
+	.name	   = "gpio-keys",
+	.id	     = -1,
+	.num_resources	= 0,
+	.dev	    =	{
+					.platform_data  = &iconnect_button_data,
+					},
+};
+
+static unsigned int iconnect_mpp_config[] __initdata = {
+	MPP12_GPIO, /*Input for reset button*/
+	MPP35_GPIO, /*Input for OTB button*/
+	MPP41_GPIO,
+	MPP42_GPIO,
+	MPP43_GPIO,
+	MPP44_GPIO,
+	MPP45_GPIO,
+	MPP46_GPIO,
+	MPP47_GPIO,
+	MPP48_GPIO,
+	0
+};
+
+static struct i2c_board_info __initdata iconnect_i2c_rtc = {
+	I2C_BOARD_INFO("lm63", 0x4c),
+};
+
+static void __init iconnect_init(void)
+{
+	u32 dev, rev;
+
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(iconnect_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(iconnect_nand_parts), 60);
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&iconnect_ge00_data);
+	kirkwood_pcie_id(&dev, &rev);
+
+	kirkwood_uart0_init();
+
+	platform_device_register(&iconnect_leds);
+	platform_device_register(&iconnect_button_device);
+	
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &iconnect_i2c_rtc, 1);
+
+}
+
+static int __init iconnect_pci_init(void)
+{
+	if (machine_is_iconnect())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(iconnect_pci_init);
+
+
+MACHINE_START(ICONNECT, "Iomega iConnect Wireless")
+	.boot_params	= 0x00000100,
+	.init_machine	= iconnect_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/ionics-stratus-setup.c b/arch/arm/mach-kirkwood/ionics-stratus-setup.c
--- a/arch/arm/mach-kirkwood/ionics-stratus-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/ionics-stratus-setup.c	2013-09-16 01:27:45.747771289 -0600
@@ -0,0 +1,136 @@
+/*
+ * arch/arm/mach-kirkwood/ionics-stratus-setup.c
+ *
+ * Ionics Stratus Board Setup arcNumber 4184
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition ionics_stratus_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data ionics_stratus_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mvsdio_platform_data ionics_stratus_mvsdio_data = {
+	/* unfortunately the CD signal has not been connected */
+};
+
+static struct gpio_led ionics_stratus_led_pins[] = {
+	{
+		.name			= "status:green:led1",
+		.default_trigger	= "none",
+		.gpio			= 44,
+		.active_low		= 1,
+	},
+	{
+		.name           	= "status:green:led2",
+		.default_trigger    	= "none",
+		.gpio           	= 40,
+		.active_low     	= 1,
+	},
+	{
+		.name           	= "status:green:led3",
+		.default_trigger	= "default-on",
+		.gpio			= 36,
+		.active_low		= 1,
+	},
+        {
+                .name                   = "status:green:led4",
+                .default_trigger        = "default-on",
+                .gpio                   = 39,
+                .active_low             = 1,
+        },
+
+};
+
+static struct gpio_led_platform_data ionics_stratus_led_data = {
+	.leds		= ionics_stratus_led_pins,
+	.num_leds	= ARRAY_SIZE(ionics_stratus_led_pins),
+};
+
+static struct platform_device ionics_stratus_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+	.platform_data	= &ionics_stratus_led_data,
+	}
+};
+
+static unsigned int ionics_stratus_mpp_config[] __initdata = {
+	MPP21_GPIO,	/* USB PORT 1 Pw Enable */
+	MPP32_GPIO,	/* USB PORT 2 Pw Enable */
+	MPP48_GPIO,	/* WIFI Power Down */
+	MPP49_GPIO,	/* WIFI Host Wakeup */
+	MPP42_GPIO,	/* WIFI MAC Wakeup */
+	MPP44_GPIO,	/* LED 1 */
+	MPP40_GPIO,	/* LED 2 */
+	MPP36_GPIO,	/* LED 3 */
+	MPP39_GPIO,	/* LED 4 */
+	MPP23_GPIO,	/* BTN 1 */
+	MPP37_GPIO,	/* BTN 2 */
+	MPP38_GPIO,	/* BTN 3 */
+	0
+};
+
+static void __init ionics_stratus_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(ionics_stratus_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(ionics_stratus_nand_parts), 25);
+
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&ionics_stratus_ge00_data);
+	kirkwood_sdio_init(&ionics_stratus_mvsdio_data);
+
+	platform_device_register(&ionics_stratus_leds);
+}
+
+MACHINE_START(IONICS_STRATUS, "Ionics Plug Computer Plus - Stratus")
+	/* Maintainer: Mike Brown <mbrown@archlinuxarm.org> */
+	.boot_params	= 0x00000100,
+	.init_machine	= ionics_stratus_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/Kconfig b/arch/arm/mach-kirkwood/Kconfig
--- a/arch/arm/mach-kirkwood/Kconfig	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/Kconfig	2013-09-16 01:51:17.386658229 -0600
@@ -44,6 +44,12 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell GuruPlug Reference Board.
 
+config MACH_DREAMPLUG
+ 	bool "Marvell DreamPlug Reference Board"
+ 	help
+ 	  Say 'Y' here if you want your kernel to support the
+ 	  Marvell DreamPlug Reference Board.
+
 config MACH_TS219
 	bool "QNAP TS-110, TS-119, TS-119P+, TS-210, TS-219, TS-219P and TS-219P+ Turbo NAS"
 	help
@@ -64,6 +70,54 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Seagate FreeAgent DockStar.
 
+config MACH_GOFLEXNET
+        bool "Seagate GoFlex Net"
+        help
+          Say 'Y' here if you want your kernel to support the
+          Seagate GoFlex Net.
+
+config MACH_GOFLEXHOME
+        bool "Seagate GoFlex Home"
+        help
+          Say 'Y' here if you want your kernel to support the
+          Seagate GoFlex Home.
+
+config MACH_ICONNECT
+	bool "Iomega iConnect Wireless"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Iomega iConnect Wireless.
+
+config MACH_POGOPLUGV4
+	bool "Pogoplug Series 4"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Pogoplug Series 4.
+
+config MACH_POGO_E02
+	bool "CE Pogoplug E02"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  CloudEngines Pogoplug e02.
+
+config MACH_NAS6210
+	bool "RaidSonic ICY BOX IB-NAS6210"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  RaidSonic ICY BOX IB-NAS6210 device.
+
+config MACH_TOPKICK
+	bool "USI Topkick"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  USI Topkick.
+
+config MACH_IONICS_STRATUS
+	bool "Ionics Stratus"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Ionics Stratus.
+
 config MACH_OPENRD
         bool
 
@@ -88,6 +142,12 @@
 	  Say 'Y' here if you want your kernel to support the
 	  Marvell OpenRD Ultimate Board.
 
+config MACH_BUBBA3
+	bool "Bubba3 miniserver"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  Bubba3 miniserver.
+
 config MACH_NETSPACE_V2
 	bool "LaCie Network Space v2 NAS Board"
 	help
@@ -130,6 +190,24 @@
 	  Say 'Y' here if you want your kernel to support the
 	  HP t5325 Thin Client.
 
+config MACH_NSA310
+	bool "ZyXEL NSA310 1-Bay Power Media Server"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  ZyXEL NSA310.
+
+config MACH_NSA320
+	bool "ZyXEL NSA320 2-Bay Power Media Server"
+	help
+	  Say 'Y' here if you want your kernel to support the
+	  ZyXEL NSA320.
+
+config MACH_NSA325
+   bool "ZyXEL NSA325 2-Bay Power Media Server"
+   help
+     Say 'Y' here if you want your kernel to support the
+     ZyXel NSA325.
+
 endmenu
 
 endif
diff -ruN a/arch/arm/mach-kirkwood/Makefile b/arch/arm/mach-kirkwood/Makefile
--- a/arch/arm/mach-kirkwood/Makefile	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/Makefile	2013-09-16 01:52:10.805849910 -0600
@@ -7,7 +7,16 @@
 obj-$(CONFIG_MACH_SHEEVAPLUG)		+= sheevaplug-setup.o
 obj-$(CONFIG_MACH_ESATA_SHEEVAPLUG)	+= sheevaplug-setup.o
 obj-$(CONFIG_MACH_GURUPLUG)		+= guruplug-setup.o
+obj-$(CONFIG_MACH_DREAMPLUG)		+= guruplug-setup.o
 obj-$(CONFIG_MACH_DOCKSTAR)		+= dockstar-setup.o
+obj-$(CONFIG_MACH_GOFLEXNET)		+= goflexnet-setup.o
+obj-$(CONFIG_MACH_GOFLEXHOME)		+= goflexhome-setup.o
+obj-$(CONFIG_MACH_ICONNECT)		+= iconnect-setup.o
+obj-$(CONFIG_MACH_POGOPLUGV4)		+= pogoplugv4-setup.o
+obj-$(CONFIG_MACH_POGO_E02)		+= pogo_e02-setup.o
+obj-$(CONFIG_MACH_NAS6210)		+= nas6210-setup.o
+obj-$(CONFIG_MACH_TOPKICK)		+= topkick-setup.o
+obj-$(CONFIG_MACH_IONICS_STRATUS)	+= ionics-stratus-setup.o
 obj-$(CONFIG_MACH_TS219)		+= ts219-setup.o tsx1x-common.o
 obj-$(CONFIG_MACH_TS41X)		+= ts41x-setup.o tsx1x-common.o
 obj-$(CONFIG_MACH_OPENRD)		+= openrd-setup.o
@@ -17,6 +26,10 @@
 obj-$(CONFIG_MACH_D2NET_V2)		+= d2net_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_NET2BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
 obj-$(CONFIG_MACH_NET5BIG_V2)		+= netxbig_v2-setup.o lacie_v2-common.o
+obj-$(CONFIG_MACH_BUBBA3)		+= bubba3-setup.o bubba3-gpio.o
 obj-$(CONFIG_MACH_T5325)		+= t5325-setup.o
+obj-$(CONFIG_MACH_NSA310)		+= nsa310-setup.o
+obj-$(CONFIG_MACH_NSA320)		+= nsa320-setup.o
+obj-$(CONFIG_MACH_NSA325)		+= nsa325-setup.o
 
 obj-$(CONFIG_CPU_IDLE)			+= cpuidle.o
diff -ruN a/arch/arm/mach-kirkwood/mpp.h b/arch/arm/mach-kirkwood/mpp.h
--- a/arch/arm/mach-kirkwood/mpp.h	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/mpp.h	2013-09-16 01:27:45.757771220 -0600
@@ -102,6 +102,7 @@
 #define MPP11_SATA0_ACTn	MPP( 11, 0x5, 0, 1, 0,   1,   1,   1,   1 )
 
 #define MPP12_GPO		MPP( 12, 0x0, 0, 1, 1,   1,   1,   1,   1 )
+#define MPP12_GPIO		MPP( 12, 0x0, 1, 1, 1,   1,   1,   1,   1 )
 #define MPP12_SD_CLK		MPP( 12, 0x1, 0, 1, 1,   1,   1,   1,   1 )
 #define MPP12_AU_SPDIF0		MPP( 12, 0xa, 0, 1, 0,   0,   0,   0,   1 )
 #define MPP12_SPI_MOSI		MPP( 12, 0xb, 0, 1, 0,   0,   0,   0,   1 )
diff -ruN a/arch/arm/mach-kirkwood/nas6210-setup.c b/arch/arm/mach-kirkwood/nas6210-setup.c
--- a/arch/arm/mach-kirkwood/nas6210-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/nas6210-setup.c	2013-09-16 01:27:45.767771111 -0600
@@ -0,0 +1,185 @@
+/*
+ * arch/arm/mach-kirkwood/nas6210-setup.c
+ *
+ * Raidsonic ICYBOX NAS6210 Board Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+#define NAS6210_GPIO_POWER_OFF	24
+
+static struct mtd_partition nas6210_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 6*SZ_1M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data nas6210_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(8),
+};
+
+static struct mv_sata_platform_data nas6210_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_led nas6210_led_pins[] = {
+	{
+		.name			= "status:green:power",
+		.default_trigger	= "default-on",
+		.gpio			= 25,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:power",
+		.default_trigger	= "none",
+		.gpio			= 22,
+		.active_low		= 0,
+	},
+	{
+		.name			= "status:red:usb_copy",
+		.default_trigger	= "none",
+		.gpio			= 27,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_led_platform_data nas6210_led_data = {
+	.leds		= nas6210_led_pins,
+	.num_leds	= ARRAY_SIZE(nas6210_led_pins),
+};
+
+static struct platform_device nas6210_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nas6210_led_data,
+	}
+};
+
+static struct gpio_keys_button nas6210_buttons[] = {
+	{
+		.code		= KEY_COPY,
+		.gpio		= 29,
+		.desc		= "USB Copy",
+		.active_low	= 1,
+	},
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 28,
+		.desc		= "Reset",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data nas6210_button_data = {
+	.buttons	= nas6210_buttons,
+	.nbuttons	= ARRAY_SIZE(nas6210_buttons),
+};
+
+static struct platform_device nas6210_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nas6210_button_data,
+	}
+};
+
+static unsigned int nas6210_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+ 	MPP22_GPIO,	/* Power LED red */
+	MPP24_GPIO,	/* Power off device */
+	MPP25_GPIO,	/* Power LED green */
+	MPP27_GPIO,	/* USB transfer LED */
+	MPP28_GPIO,	/* Reset button */
+	MPP29_GPIO,	/* USB Copy button */
+	0
+};
+
+static void nas6210_power_off(void)
+{
+	gpio_set_value(NAS6210_GPIO_POWER_OFF, 1);
+}
+
+static void __init nas6210_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(nas6210_mpp_config);
+
+	kirkwood_nand_init(ARRAY_AND_SIZE(nas6210_nand_parts), 25);
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&nas6210_ge00_data);
+	kirkwood_sata_init(&nas6210_sata_data);
+	kirkwood_uart0_init();
+	platform_device_register(&nas6210_leds);
+	platform_device_register(&nas6210_button_device);
+	if (gpio_request(NAS6210_GPIO_POWER_OFF, "power-off") == 0 &&
+	    gpio_direction_output(NAS6210_GPIO_POWER_OFF, 0) == 0)
+		pm_power_off = nas6210_power_off;
+	else
+		pr_err("nas6210: failed to configure power-off GPIO\n");
+}
+
+static int __init nas6210_pci_init(void)
+{
+	if (machine_is_nas6210()) {
+		u32 dev, rev;
+ 
+		kirkwood_pcie_id(&dev, &rev);
+		if (dev == MV88F6282_DEV_ID)
+			kirkwood_pcie_init(KW_PCIE1 | KW_PCIE0);
+		else
+			kirkwood_pcie_init(KW_PCIE0);
+	}
+
+	return 0;
+}
+subsys_initcall(nas6210_pci_init);
+
+MACHINE_START(NAS6210, "RaidSonic ICY BOX IB-NAS6210")
+	/* Maintainer: <gmbnomis at gmail dot com> */
+	.boot_params	= 0x00000100,
+	.init_machine	= nas6210_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/nsa310-setup.c b/arch/arm/mach-kirkwood/nsa310-setup.c
--- a/arch/arm/mach-kirkwood/nsa310-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/nsa310-setup.c	2013-09-16 01:27:45.767771111 -0600
@@ -0,0 +1,357 @@
+/*
+ * arch/arm/mach-kirkwood/nsa310-setup.c
+ *
+ * Zyxel NSA-310 Setup, by AA666 and Peeter123
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/irq.h>
+#include <linux/mtd/partitions.h>
+#include <mtd/mtd-abi.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/mv643xx_i2c.h>
+#include <linux/ethtool.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+static void nsa310_timerfunc(unsigned long data);
+static DEFINE_TIMER(timer, nsa310_timerfunc, 0, 0);
+
+static struct mtd_partition nsa310_nand_parts[] = {
+  {
+    .name = "uboot",
+    .offset = 0,
+    .size = 0x100000,
+    .mask_flags = MTD_WRITEABLE
+  }, {
+    .name = "uboot_env",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "key_store",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "info",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x80000
+  }, {
+    .name = "etc",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "kernel_1",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "rootfs1",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x2FC0000
+  }, {
+    .name = "kernel_2",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0xA00000
+  }, {
+    .name = "rootfs2",
+    .offset = MTDPART_OFS_NXTBLK,
+    .size = 0x2FC0000
+  },
+};
+
+static struct i2c_board_info __initdata nsa310_i2c_rtc = {
+        I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa310_ge00_data = {
+  .phy_addr  = MV643XX_ETH_PHY_ADDR(0),
+  .speed    = SPEED_1000,
+  .duplex    = DUPLEX_FULL,
+};
+
+static struct mv_sata_platform_data nsa310_sata_data = {
+  .n_ports  = 2,
+};
+
+static unsigned int nsa310_mpp_config[] __initdata = {
+  MPP36_GPIO, // Reset button
+  MPP37_GPIO, // Copy button
+  MPP46_GPIO, // Power button
+
+  MPP48_GPIO, // Power Off
+  MPP21_GPIO, // USB Power Off
+
+  MPP28_GPIO, // Sys LED Green
+  MPP29_GPIO, // Sys LED Yellow
+  MPP41_GPIO, // SATA1 LED Green
+  MPP42_GPIO, // SATA1 LED Red
+  MPP12_GPO, // SATA2 LED Green
+  MPP13_GPIO, // SATA2 LED Red
+  MPP39_GPIO, // Copy LED Green
+  MPP40_GPIO, // Copy LED Red
+  MPP15_GPIO, // USB LED Green
+
+  MPP14_GPIO, // MCU Data
+  MPP16_GPIO, // MCU Clk
+  MPP17_GPIO, // MCU Act
+
+  MPP38_GPIO, // VID B0
+  MPP45_GPIO, // VID B1
+
+  MPP44_GPIO, // Buzzer
+  MPP43_GPIO, // HTP
+
+  MPP47_GPIO, // Power Resume Data
+  MPP49_GPIO, // Power Resume Clock
+
+  0
+};
+
+static struct gpio_led nsa310_gpio_led[] = {
+        {
+            .name    = "nsa310:green:System",
+            .default_trigger  = "timer",
+            .gpio    = 28,
+            .active_low    = 0,
+
+        },
+  {
+            .name    = "nsa310:red:System",
+            .default_trigger  = "none",
+            .gpio    = 29,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:SATA1",
+            .default_trigger  = "none",
+            .gpio    = 41,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:SATA1",
+            .default_trigger  = "sata-disk",
+            .gpio    = 42,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:SATA2",
+            .default_trigger  = "none",
+            .gpio    = 12,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:SATA2",
+            .default_trigger  = "none",
+            .gpio    = 13,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:green:USB",
+            .default_trigger  = "none",
+            .gpio    = 15,
+            .active_low    = 0,
+        },
+        {
+            .name    = "nsa310:green:Copy",
+            .default_trigger  = "none",
+            .gpio    = 39,
+            .active_low    = 0,
+        },
+  {
+            .name    = "nsa310:red:Copy",
+            .default_trigger  = "none",
+            .gpio    = 40,
+            .active_low    = 0,
+        },
+};
+
+
+static int nsa310_gpio_blink_set(unsigned gpio, int state,
+  unsigned long *delay_on, unsigned long *delay_off)
+{
+
+// Use hardware acceleration
+//    if (delay_on && delay_off && !*delay_on && !*delay_off)
+//  *delay_on = *delay_off = 100;
+
+  switch(state) {
+      case GPIO_LED_NO_BLINK_LOW:
+      case GPIO_LED_NO_BLINK_HIGH:
+    orion_gpio_set_blink(gpio, 0);
+    gpio_set_value(gpio, state);
+      break;
+      case GPIO_LED_BLINK:
+    orion_gpio_set_blink(gpio, 1);
+      break;
+  }
+  return 0;
+}
+
+
+static struct gpio_led_platform_data nsa310_led_data = {
+        .leds           = nsa310_gpio_led,
+        .num_leds       = ARRAY_SIZE(nsa310_gpio_led),
+  .gpio_blink_set  = nsa310_gpio_blink_set,
+};
+
+static struct platform_device nsa310_leds = {
+        .name   = "leds-gpio",
+        .id     = -1,
+        .dev    = { .platform_data  = &nsa310_led_data, }
+};
+
+static struct gpio_keys_button nsa310_gpio_keys_button[] = {
+        {
+            .code             = KEY_POWER,
+            .type    = EV_KEY,
+            .gpio             = 46,
+            .desc             = "Power Button",
+            .active_low       = 0,
+            .debounce_interval   = 1000,
+        },
+        {
+            .code             = KEY_COPY,
+            .type    = EV_KEY,
+            .gpio             = 37,
+            .desc             = "USB Copy",
+            .active_low       = 1,
+            .debounce_interval   = 1000,
+        },
+        {
+            .code             = KEY_OPTION,
+            .type    = EV_KEY,
+            .gpio             = 36,
+            .desc             = "Reset",
+            .active_low       = 1,
+            .debounce_interval   = 1000,
+        },
+};
+
+static struct gpio_keys_platform_data nsa310_keys_data = {
+        .buttons        = nsa310_gpio_keys_button,
+        .nbuttons       = ARRAY_SIZE(nsa310_gpio_keys_button),
+};
+
+
+static struct platform_device nsa310_buttons = {
+        .name           = "gpio-keys",
+        .id             = -1,
+        .dev            = { .platform_data  = &nsa310_keys_data, }
+};
+
+static void nsa310_power_off(void)
+{
+//
+//don't work with sysfs
+      printk(KERN_INFO "Activating power off GPIO pin...\n");
+  gpio_set_value(48, 1);
+
+// If machine goes to restart, uncomment next lines for infinite loop
+/*      printk(KERN_INFO "System halted, please turn off power manually\n");
+  gpio_set_value(28, 0);
+  do {
+      mdelay(1000);
+  } while(1);
+*/
+}
+
+static void nsa310_timerfunc(unsigned long data)
+{
+// Activate USB Power
+  if (gpio_request(21, "USB Power") != 0 || gpio_direction_output(21, 1) != 0)
+      printk(KERN_ERR "failed to setup USB power GPIO\n");
+  else
+          printk(KERN_INFO "USB power enabled\n");
+  gpio_free(21);
+}
+
+static void __init nsa310_init(void)
+{
+  u32 dev, rev;
+
+  kirkwood_init();
+
+  kirkwood_mpp_conf(nsa310_mpp_config);
+  kirkwood_nand_init(ARRAY_AND_SIZE(nsa310_nand_parts), 25);
+  kirkwood_ge00_init(&nsa310_ge00_data);
+  kirkwood_pcie_id(&dev, &rev);
+
+  kirkwood_sata_init(&nsa310_sata_data);
+  kirkwood_uart0_init();
+  kirkwood_i2c_init();
+        i2c_register_board_info(0, &nsa310_i2c_rtc, 1);
+
+  platform_device_register(&nsa310_leds);
+  platform_device_register(&nsa310_buttons);
+  
+  kirkwood_ehci_init();
+//  USB Power delay for 20 sec  
+  timer.function = nsa310_timerfunc;
+        timer.data = 0;
+  timer.expires = jiffies + msecs_to_jiffies(20000);
+  add_timer(&timer);
+
+
+/*  Power resume control */
+      gpio_request(49, "Power-clk");
+      gpio_direction_output(49, 1);
+      gpio_request(47, "Power-data");
+// Clear power resume
+//      gpio_direction_output(47, 0);
+// Set power resume
+      gpio_direction_output(47, 1);
+      udelay(1000);
+//      gpio_direction_output(49, 0);
+      gpio_set_value(49, 0);
+// release GPIO?
+//test
+      gpio_free(47);
+      gpio_free(49);
+          printk(KERN_INFO "Power resume enabled\n");
+
+
+// Activate Power-off GPIO
+  if (gpio_request(48, "Power-off") == 0 && gpio_direction_output(48, 0) == 0) {
+//          gpio_free(48);
+            pm_power_off = nsa310_power_off;
+          printk(KERN_INFO "Power-off GPIO enabled\n");
+      } else
+    printk(KERN_ERR "failed to configure Power-off GPIO\n");
+
+};
+
+static int __init nsa310_pci_init(void)
+{
+  if (machine_is_nsa310())
+    kirkwood_pcie_init(KW_PCIE0);
+  return 0;
+}
+
+subsys_initcall(nsa310_pci_init);
+
+MACHINE_START(NSA310, "Zyxel NSA-310")
+  .boot_params  = 0x00000100,
+  .init_machine  = nsa310_init,
+  .map_io    = kirkwood_map_io,
+  .init_early    = kirkwood_init_early,
+  .init_irq    = kirkwood_init_irq,
+  .timer    = &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/nsa320-setup.c b/arch/arm/mach-kirkwood/nsa320-setup.c
--- a/arch/arm/mach-kirkwood/nsa320-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/nsa320-setup.c	2013-09-16 01:27:45.767771111 -0600
@@ -0,0 +1,308 @@
+/*
+ * arch/arm/mach-kirkwood/nsa320-setup.c
+ *
+ * ZyXEL NSA320 2-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa320_nand_parts[] = {
+	{
+		.name = "uboot",
+		.offset = 0,
+		.size = SZ_1M,
+		.mask_flags = MTD_WRITEABLE
+	}, {
+		.name = "uboot_env",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "key_store",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "info",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_512K
+	}, {
+		.name = "etc",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "kernel_1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs1",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	}, {
+		.name = "kernel_2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 10 * SZ_1M
+	}, {
+		.name = "rootfs2",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = 48 * SZ_1M - SZ_256K
+	},
+};
+
+static struct i2c_board_info __initdata nsa320_i2c_rtc = {
+	I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa320_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data nsa320_sata_data = {
+	.n_ports	= 2,
+};
+
+static struct gpio_keys_button nsa320_button_pins[] = {
+	{
+		.code		= KEY_RESTART,
+		.gpio		= 36,
+		.desc		= "Reset",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_COPY,
+		.gpio		= 37,
+		.desc		= "Copy",
+		.active_low	= 1,
+	}, {
+		.code		= KEY_POWER,
+		.gpio		= 46,
+		.desc		= "Power",
+		.active_low	= 0,
+	},
+};
+
+static struct gpio_keys_platform_data nsa320_button_data = {
+	.buttons	= nsa320_button_pins,
+	.nbuttons	= ARRAY_SIZE(nsa320_button_pins),
+};
+
+static struct platform_device nsa320_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_button_data,
+	},
+};
+
+static struct gpio_led nsa320_led_pins[] = {
+	{
+		.name			= "nsa320:green:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 12,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd2",
+		.default_trigger	= "default-off",
+		.gpio			= 13,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:usb",
+		.default_trigger	= "default-off",
+		.gpio			= 15,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:sys",
+		.default_trigger	= "default-off",
+		.gpio			= 28,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:orange:sys",
+		.default_trigger	= "default-on",
+		.gpio			= 29,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 39,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:copy",
+		.default_trigger	= "default-off",
+		.gpio			= 40,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:green:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 41,
+		.active_low		= 0,
+	}, {
+		.name			= "nsa320:red:hdd1",
+		.default_trigger	= "default-off",
+		.gpio			= 42,
+		.active_low		= 0,
+	},
+};
+
+static struct gpio_led_platform_data nsa320_led_data = {
+	.leds		= nsa320_led_pins,
+	.num_leds	= ARRAY_SIZE(nsa320_led_pins),
+};
+
+static struct platform_device nsa320_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &nsa320_led_data,
+	},
+};
+
+static struct nsa3xx_hwmon_platform_data nsa320_hwmon_data = {
+	/* GPIOs connected to Holtek HT46R065 MCU */
+	.act_pin  = 17,
+	.clk_pin  = 16,
+	.data_pin = 14,
+};
+
+static struct platform_device nsa320_hwmon = {
+	.name		= "nsa3xx-hwmon",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &nsa320_hwmon_data,
+	},
+};
+
+static unsigned int nsa320_mpp_config[] __initdata = {
+	MPP0_NF_IO2,
+	MPP1_NF_IO3,
+	MPP2_NF_IO4,
+	MPP3_NF_IO5,
+	MPP4_NF_IO6,
+	MPP5_NF_IO7,
+	MPP6_SYSRST_OUTn,
+	MPP7_GPO,
+	MPP8_TW0_SDA,	/* PCF8563 RTC chip   */
+	MPP9_TW0_SCK,	/* connected to TWSI  */
+	MPP10_UART0_TXD,
+	MPP11_UART0_RXD,
+	MPP12_GPO,	/* HDD2 LED (green)   */
+	MPP13_GPIO,	/* HDD2 LED (red)     */
+	MPP14_GPIO,	/* MCU DATA pin (in)  */
+	MPP15_GPIO,	/* USB LED (green)    */
+	MPP16_GPIO,	/* MCU CLK pin (out)  */
+	MPP17_GPIO,	/* MCU ACT pin (out)  */
+	MPP18_NF_IO0,
+	MPP19_NF_IO1,
+	MPP20_GPIO,
+	MPP21_GPIO,	/* USB power          */
+	MPP22_GPIO,
+	MPP23_GPIO,
+	MPP24_GPIO,
+	MPP25_GPIO,
+	MPP26_GPIO,
+	MPP27_GPIO,
+	MPP28_GPIO,	/* SYS LED (green)    */
+	MPP29_GPIO,	/* SYS LED (orange)   */
+	MPP30_GPIO,
+	MPP31_GPIO,
+	MPP32_GPIO,
+	MPP33_GPO,
+	MPP34_GPIO,
+	MPP35_GPIO,
+	MPP36_GPIO,	/* reset button       */
+	MPP37_GPIO,	/* copy button        */
+	MPP38_GPIO,	/* VID B0             */
+	MPP39_GPIO,	/* COPY LED (green)   */
+	MPP40_GPIO,	/* COPY LED (red)     */
+	MPP41_GPIO,	/* HDD1 LED (green)   */
+	MPP42_GPIO,	/* HDD1 LED (red)     */
+	MPP43_GPIO,	/* HTP pin            */
+	MPP44_GPIO,	/* buzzer             */
+	MPP45_GPIO,	/* VID B1             */
+	MPP46_GPIO,	/* power button       */
+	MPP47_GPIO,	/* power resume data  */
+	MPP48_GPIO,	/* power off          */
+	MPP49_GPIO,	/* power resume clock */
+	0
+};
+
+#define NSA320_GPIO_USB_POWER	21
+#define NSA320_GPIO_POWER_OFF	48
+
+static void nsa320_power_off(void)
+{
+	gpio_set_value(NSA320_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa320_usb_power(char *str)
+{
+	usb_power = strncmp(str, "off", 3) ? 1 : 0;
+	return 1;
+}
+/* Parse boot_command_line string nsa320_usb_power=on|off */
+__setup("nsa320_usb_power=", nsa320_usb_power);
+
+static void __init nsa320_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(nsa320_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(nsa320_nand_parts), 40);
+
+	kirkwood_i2c_init();
+	i2c_register_board_info(0, &nsa320_i2c_rtc, 1);
+
+	if (gpio_request(NSA320_GPIO_USB_POWER, "USB Power Enable") ||
+	    gpio_direction_output(NSA320_GPIO_USB_POWER, usb_power))
+		pr_err("nsa320: failed to configure USB power enable GPIO)\n");
+	gpio_free(NSA320_GPIO_USB_POWER);
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&nsa320_ge00_data);
+	kirkwood_sata_init(&nsa320_sata_data);
+	platform_device_register(&nsa320_leds);
+	platform_device_register(&nsa320_buttons);
+	platform_device_register(&nsa320_hwmon);
+
+	if (gpio_request(NSA320_GPIO_POWER_OFF, "power-off") ||
+	    gpio_direction_output(NSA320_GPIO_POWER_OFF, 0))
+		pr_err("nsa320: failed to configure power-off GPIO\n");
+	else
+		pm_power_off = nsa320_power_off;
+}
+
+MACHINE_START(NSA320, "ZyXEL NSA320 2-Bay Power Media Server")
+	/* Maintainer: Peter Schildmann <linux@schildmann.info> */
+	.boot_params	= 0x00000100,
+	.init_machine	= nsa320_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+//	.restart	= kirkwood_restart,
+MACHINE_END
diff -rupN a/arch/arm/mach-kirkwood/nsa325-setup.c b/arch/arm/mach-kirkwood/nsa325-setup.c
--- a/arch/arm/mach-kirkwood/nsa325-setup.c      1969-12-31 19:00:00.000000000 -0500
+++ b/arch/arm/mach-kirkwood/nsa325-setup.c  2013-10-03 23:36:55.430043273 -0400
@@ -0,0 +1,359 @@
+/*
+ * arch/arm/mach-kirkwood/nsa325-setup.c
+ *
+ * ZyXEL NSA325 2-Bay Power Media Server Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/phy.h>
+#include <linux/marvell_phy.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/pci.h>
+#include <linux/input.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/gpio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition nsa325_nand_parts[] = {
+       {
+               .name = "uboot",
+               .offset = 0,
+               .size = SZ_1M,
+               .mask_flags = MTD_WRITEABLE
+       }, {
+               .name = "uboot_env",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "key_store",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "info",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = SZ_512K
+       }, {
+               .name = "etc",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "kernel_1",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "rootfs1",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 48 * SZ_1M - SZ_256K
+       }, {
+               .name = "kernel_2",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 10 * SZ_1M
+       }, {
+               .name = "rootfs2",
+               .offset = MTDPART_OFS_NXTBLK,
+               .size = 48 * SZ_1M - SZ_256K
+       },
+};
+
+static struct i2c_board_info __initdata nsa325_i2c_rtc = {
+       I2C_BOARD_INFO("pcf8563", 0x51),
+};
+
+static struct mv643xx_eth_platform_data nsa325_ge00_data = {
+       .phy_addr       = MV643XX_ETH_PHY_ADDR(1),
+};
+
+static struct mv_sata_platform_data nsa325_sata_data = {
+       .n_ports        = 2,
+};
+
+static struct gpio_keys_button nsa325_button_pins[] = {
+       {
+               .code           = KEY_RESTART,
+               .gpio           = 36,
+               .desc           = "Reset",
+               .active_low     = 1,
+               .debounce_interval      = 1000,
+       }, {
+               .code           = KEY_COPY,
+               .gpio           = 37,
+               .desc           = "Copy",
+               .active_low     = 1,
+               .debounce_interval      = 1000,
+       }, {
+               .code           = KEY_POWER,
+               .gpio           = 46,
+               .desc           = "Power",
+               .active_low     = 0,
+               .debounce_interval      = 1000,
+       },
+};
+
+static struct gpio_keys_platform_data nsa325_button_data = {
+       .buttons        = nsa325_button_pins,
+       .nbuttons       = ARRAY_SIZE(nsa325_button_pins),
+};
+
+static struct platform_device nsa325_buttons = {
+       .name           = "gpio-keys",
+       .id             = -1,
+       .num_resources  = 0,
+       .dev            = {
+               .platform_data  = &nsa325_button_data,
+       },
+};
+
+static struct gpio_led nsa325_led_pins[] = {
+       {
+               .name                   = "nsa325:green:hdd2",
+               .default_trigger        = "ide-disk",
+               .gpio                   = 12,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:hdd2",
+               .default_trigger        = "default-off",
+               .gpio                   = 13,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:usb",
+               .default_trigger        = "default-off",
+               .gpio                   = 15,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:sys",
+               .default_trigger        = "default-off",
+               .gpio                   = 28,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:orange:sys",
+               .default_trigger        = "default-on",
+               .gpio                   = 29,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:copy",
+               .default_trigger        = "default-off",
+               .gpio                   = 39,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:copy",
+               .default_trigger        = "default-off",
+               .gpio                   = 40,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:green:hdd1",
+               .default_trigger        = "ide-disk",
+               .gpio                   = 41,
+               .active_low             = 0,
+       }, {
+               .name                   = "nsa325:red:hdd1",
+               .default_trigger        = "default-off",
+               .gpio                   = 42,
+               .active_low             = 0,
+       },
+};
+
+static int nsa325_gpio_blink_set(unsigned gpio, int state,
+       unsigned long *delay_on, unsigned long *delay_off)
+{
+       switch(state) {
+               case GPIO_LED_NO_BLINK_LOW:
+               case GPIO_LED_NO_BLINK_HIGH:
+                       orion_gpio_set_blink(gpio, 0);
+                       gpio_set_value(gpio, state);
+               break;
+               case GPIO_LED_BLINK:
+                       orion_gpio_set_blink(gpio, 1);
+               break;
+       }
+       return 0;
+}
+
+static struct gpio_led_platform_data nsa325_led_data = {
+       .leds           = nsa325_led_pins,
+       .num_leds       = ARRAY_SIZE(nsa325_led_pins),
+       .gpio_blink_set = nsa325_gpio_blink_set,
+};
+
+static struct platform_device nsa325_leds = {
+       .name   = "leds-gpio",
+       .id     = -1,
+       .dev    = {
+               .platform_data  = &nsa325_led_data,
+       },
+};
+
+static struct nsa3xx_hwmon_platform_data nsa325_hwmon_data = {
+       /* GPIOs connected to Holtek HT46R065 MCU */
+       .act_pin  = 17,
+       .clk_pin  = 16,
+       .data_pin = 14,
+};
+
+static struct platform_device nsa325_hwmon = {
+       .name           = "nsa3xx-hwmon",
+       .id             = -1,
+       .num_resources  = 0,
+       .dev            = {
+               .platform_data  = &nsa325_hwmon_data,
+       },
+};
+
+static unsigned int nsa325_mpp_config[] __initdata = {
+       MPP8_TW0_SDA,   /* PCF8563 RTC chip   */
+       MPP9_TW0_SCK,   /* connected to TWSI  */
+       MPP12_GPO,      /* HDD2 LED (green)   */
+       MPP13_GPIO,     /* ? HDD2 LED (red) ? */
+       MPP14_GPIO,     /* MCU DATA pin (in)  */
+       MPP15_GPIO,     /* USB LED (green)    */
+       MPP16_GPIO,     /* MCU CLK pin (out)  */
+       MPP17_GPIO,     /* MCU ACT pin (out)  */
+       MPP21_GPIO,     /* USB power          */
+       MPP28_GPIO,     /* SYS LED (green)    */
+       MPP29_GPIO,     /* SYS LED (orange)   */
+       MPP36_GPIO,     /* reset button       */
+       MPP37_GPIO,     /* copy button        */
+       MPP38_GPIO,     /* VID B0             */
+       MPP39_GPIO,     /* COPY LED (green)   */
+       MPP40_GPIO,     /* COPY LED (red)     */
+       MPP41_GPIO,     /* HDD1 LED (green)   */
+       MPP42_GPIO,     /* HDD1 LED (red)     */
+       MPP43_GPIO,     /* HTP pin            */
+       MPP44_GPIO,     /* buzzer             */
+       MPP45_GPIO,     /* VID B1             */
+       MPP46_GPIO,     /* power button       */
+       MPP47_GPIO,     /* HDD2 power         */
+       MPP48_GPIO,     /* power off          */
+       0
+};
+
+#define NSA325_GPIO_WATCHDOG   14
+#define NSA325_GPIO_USB_POWER  21
+#define NSA325_GPIO_HDD2_POWER 47
+#define NSA325_GPIO_POWER_OFF  48
+
+static void nsa325_power_off(void)
+{
+       gpio_set_value(NSA325_GPIO_POWER_OFF, 1);
+}
+
+static int __initdata usb_power = 1; /* default "on" */
+
+static int __init nsa325_usb_power(char *str)
+{
+       usb_power = strncmp(str, "off", 3) ? 1 : 0;
+       return 1;
+}
+/* Parse boot_command_line string nsa325_usb_power=on|off */
+__setup("nsa325_usb_power=", nsa325_usb_power);
+
+/* the nsa325 uses the 88E1310S Alaska, and has an MCU attached to the LED[2] via tristate interrupt */
+static int nsa325_phy_fixup(struct phy_device *phydev)
+{
+       int err;
+       int temp;
+       /* go to page 3 */
+       err = phy_write(phydev, 22, 3);
+       if (err < 0)
+           return err;
+       /* read page 3, register 17 */
+       temp = phy_read(phydev, 17);
+       /* clear bit 4, set bit 5 */
+       temp &= ~(1<<4);
+       temp |= (1<<5);
+       /* write page 3, register 17 */
+       err = phy_write(phydev, 17, temp);
+       if (err < 0)
+           return err;
+       /* go to page 0 */
+       err = phy_write(phydev, 22, 0);
+       if (err < 0)
+           return err;
+
+       return 0;
+}
+
+static void __init nsa325_init(void)
+{
+       /*
+        * Basic setup. Needs to be called early.
+        */
+       kirkwood_init();
+
+       kirkwood_mpp_conf(nsa325_mpp_config);
+
+       /* setup the phy fixup */
+       phy_register_fixup_for_uid(MARVELL_PHY_ID_88E1318S,MARVELL_PHY_ID_MASK,nsa325_phy_fixup);
+       kirkwood_ge00_init(&nsa325_ge00_data);
+
+       kirkwood_uart0_init();
+       kirkwood_nand_init(ARRAY_AND_SIZE(nsa325_nand_parts), 40);
+
+       /* turn off the watchdog */
+       gpio_set_value(NSA325_GPIO_WATCHDOG, 1);
+
+       /* turn on the second drive bay */
+       if (gpio_request(NSA325_GPIO_HDD2_POWER, "HDD2 Power Enable") ||
+           gpio_direction_output(NSA325_GPIO_HDD2_POWER,1))
+               pr_err("nsa325: failed to configure HDD2 power enable GPIO\n");
+       gpio_free(NSA325_GPIO_HDD2_POWER);
+
+       kirkwood_sata_init(&nsa325_sata_data);
+
+       platform_device_register(&nsa325_leds);
+       platform_device_register(&nsa325_buttons);
+       platform_device_register(&nsa325_hwmon);
+
+       kirkwood_i2c_init();
+       i2c_register_board_info(0, &nsa325_i2c_rtc, 1);
+
+       if (gpio_request(NSA325_GPIO_USB_POWER, "USB Power Enable") ||
+           gpio_direction_output(NSA325_GPIO_USB_POWER, usb_power))
+               pr_err("nsa325: failed to configure USB power enable GPIO\n");
+       gpio_free(NSA325_GPIO_USB_POWER);
+
+       kirkwood_ehci_init();
+
+       if (gpio_request(NSA325_GPIO_POWER_OFF, "power-off") ||
+           gpio_direction_output(NSA325_GPIO_POWER_OFF, 0))
+               pr_err("nsa325: failed to configure power-off GPIO\n");
+       else
+               pm_power_off = nsa325_power_off;
+}
+
+static int __init nsa325_pci_init(void)
+{
+        if (machine_is_nsa325())
+                kirkwood_pcie_init(KW_PCIE0);
+
+        return 0;
+}
+subsys_initcall(nsa325_pci_init);
+
+MACHINE_START(NSA325, "ZyXEL NSA325 2-Bay Power Media Server")
+       /* Maintainer: Jason Plum <max@warheads.net> */
+       .atag_offset    = 0x100,
+       .init_machine   = nsa325_init,
+       .map_io         = kirkwood_map_io,
+       .init_early     = kirkwood_init_early,
+       .init_irq       = kirkwood_init_irq,
+       .init_time      = kirkwood_timer_init,
+       .restart        = kirkwood_restart,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/pogo_e02-setup.c b/arch/arm/mach-kirkwood/pogo_e02-setup.c
--- a/arch/arm/mach-kirkwood/pogo_e02-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/pogo_e02-setup.c	2013-09-16 01:27:45.767771111 -0600
@@ -0,0 +1,114 @@
+/*
+ * arch/arm/mach-kirkwood/pogo_e02-setup.c
+ *
+ * CloudEngines Pogoplug E02 support
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition pogo_e02_nand_parts[] = {
+	{
+		.name = "u-boot",
+		.offset = 0,
+		.size = SZ_1M
+	}, {
+		.name = "uImage",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_4M
+	}, {
+		.name = "pogoplug",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = SZ_32M
+	}, {
+		.name = "root",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogo_e02_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct gpio_led pogo_e02_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:fault",
+		.default_trigger	= "none",
+		.gpio			= 49,
+		.active_low		= 1,
+	}
+};
+
+static struct gpio_led_platform_data pogo_e02_led_data = {
+	.leds		= pogo_e02_led_pins,
+	.num_leds	= ARRAY_SIZE(pogo_e02_led_pins),
+};
+
+static struct platform_device pogo_e02_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogo_e02_led_data,
+	}
+};
+
+static unsigned int pogo_e02_mpp_config[] __initdata = {
+	MPP29_GPIO,	/* USB Power Enable */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Orange */
+	0
+};
+
+static void __init pogo_e02_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(pogo_e02_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(pogo_e02_nand_parts), 25);
+
+	if (gpio_request(29, "USB Power Enable") != 0 ||
+	    gpio_direction_output(29, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 29 (USB Power Enable)\n");
+	kirkwood_ehci_init();
+
+	kirkwood_ge00_init(&pogo_e02_ge00_data);
+
+	platform_device_register(&pogo_e02_leds);
+}
+
+MACHINE_START(POGO_E02, "Pogoplug E02")
+	.boot_params	= 0x00000100,
+	.init_machine	= pogo_e02_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/pogoplugv4-setup.c b/arch/arm/mach-kirkwood/pogoplugv4-setup.c
--- a/arch/arm/mach-kirkwood/pogoplugv4-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/pogoplugv4-setup.c	2013-09-16 01:27:45.777770983 -0600
@@ -0,0 +1,194 @@
+/*
+ * arch/arm/mach-kirkwood/pogoplugv4-setup.c
+ *
+ * Pogoplug Series 4 Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/partitions.h>
+#include <linux/ata_platform.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/leds.h>
+#include <linux/pci.h>
+#include <linux/irq.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/orion_spi.h>
+#include <linux/input.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+#define POGOPLUGV4_GPIO_USB_VBUS		10
+
+static struct mtd_partition ppv4_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 2 * SZ_1M
+	}, {
+		.name	= "uImage",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "uImage2",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= 3 * SZ_1M
+	}, {
+		.name	= "failsafe",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= SZ_8M
+	}, {
+		.name	= "root",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data pogoplugv4_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data pogoplugv4_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct gpio_keys_button pogoplugv4_button_pins[] = {
+	{
+		.code		= KEY_EJECTCD,
+		.gpio		= 29,
+		.desc		= "Eject Button",
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_platform_data pogoplugv4_button_data = {
+	.buttons	= pogoplugv4_button_pins,
+	.nbuttons	= ARRAY_SIZE(pogoplugv4_button_pins),
+};
+
+static struct platform_device pogoplugv4_buttons = {
+	.name		= "gpio-keys",
+	.id		= -1,   
+	.num_resources  = 0,
+	.dev		= {
+		.platform_data  = &pogoplugv4_button_data,
+	},
+};
+
+static struct gpio_led pogoplugv4_led_pins[] = {
+	{
+		.name			= "status:green:health",
+		.default_trigger	= "default-on",
+		.gpio			= 22,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 24,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data pogoplugv4_led_data = {
+	.leds		= pogoplugv4_led_pins,
+	.num_leds	= ARRAY_SIZE(pogoplugv4_led_pins),
+};
+
+static struct platform_device pogoplugv4_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &pogoplugv4_led_data,
+	}
+};
+
+static struct mvsdio_platform_data ppv4_mvsdio_data = {
+	.gpio_card_detect = 27,
+};
+
+static unsigned int ppv4_mpp_config[] __initdata = {
+	MPP27_GPIO,	/* SD card detect */
+	MPP29_GPIO,	/* Eject button */
+	MPP22_GPIO,	/* Green LED */
+	MPP24_GPIO,	/* Red LED */
+	MPP12_SD_CLK,
+	MPP13_SD_CMD,
+	MPP14_SD_D0,
+	MPP15_SD_D1,
+	MPP16_SD_D2,
+	MPP17_SD_D3,
+	0
+};
+
+static const struct flash_platform_data pogoplugv4_spi_slave_data = {
+	.type		= "m25p05-nonjedec",
+};
+
+static struct spi_board_info __initdata pogoplugv4_spi_slave_info[] = {
+	{
+		.modalias	= "m25p05-nonjedec",
+		.platform_data	= &pogoplugv4_spi_slave_data,
+		.irq		= -1,
+		.max_speed_hz	= 20000000,
+		.bus_num	= 0,
+		.chip_select	= 0,
+	},
+};
+
+static void __init pogoplugv4_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+	kirkwood_mpp_conf(ppv4_mpp_config);
+
+	orion_gpio_set_valid(POGOPLUGV4_GPIO_USB_VBUS, 1);
+	if (gpio_request(POGOPLUGV4_GPIO_USB_VBUS, "USB VBUS") != 0 ||
+	    gpio_direction_output(POGOPLUGV4_GPIO_USB_VBUS, 1) != 0)
+		pr_err("POGOPLUGV4: failed to setup USB VBUS GPIO\n");
+
+	kirkwood_ehci_init();
+	kirkwood_ge00_init(&pogoplugv4_ge00_data);
+	kirkwood_sata_init(&pogoplugv4_sata_data);
+	spi_register_board_info(pogoplugv4_spi_slave_info,
+				ARRAY_SIZE(pogoplugv4_spi_slave_info));
+	kirkwood_spi_init();
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(ppv4_nand_parts), 25);
+	kirkwood_sdio_init(&ppv4_mvsdio_data);
+	platform_device_register(&pogoplugv4_leds);
+	platform_device_register(&pogoplugv4_buttons);
+}
+
+static int __init pogoplugv4_pci_init(void)
+{
+	if (machine_is_pogoplugv4())
+		kirkwood_pcie_init(KW_PCIE0);
+
+	return 0;
+}
+subsys_initcall(pogoplugv4_pci_init);
+
+MACHINE_START(POGOPLUGV4, "Pogoplug V4")
+	/* Maintainer: Kevin Mihelich <kevin@archlinuxarm.org> */
+	.boot_params	= 0x00000100,
+	.init_machine	= pogoplugv4_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/mach-kirkwood/sheevaplug-setup.c b/arch/arm/mach-kirkwood/sheevaplug-setup.c
--- a/arch/arm/mach-kirkwood/sheevaplug-setup.c	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/mach-kirkwood/sheevaplug-setup.c	2013-09-16 01:27:45.777770983 -0600
@@ -43,7 +43,7 @@
 	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
 };
 
-static struct mv_sata_platform_data sheeva_esata_sata_data = {
+static struct mv_sata_platform_data esata_sheevaplug_sata_data = {
 	.n_ports	= 2,
 };
 
@@ -51,7 +51,7 @@
 	/* unfortunately the CD signal has not been connected */
 };
 
-static struct mvsdio_platform_data sheeva_esata_mvsdio_data = {
+static struct mvsdio_platform_data esata_sheevaplug_mvsdio_data = {
 	.gpio_write_protect = 44, /* MPP44 used as SD write protect */
 	.gpio_card_detect = 47,	  /* MPP47 used as SD card detect */
 };
@@ -64,7 +64,13 @@
 		.active_low		= 1,
 	},
 	{
-		.name			= "plug:green:health",
+		.name           	= "status:green:health",
+		.default_trigger    	= "none",
+		.gpio           	= 48,
+		.active_low     	= 1,
+	},
+	{
+		.name           	= "status:blue:health",
 		.default_trigger	= "default-on",
 		.gpio			= 49,
 		.active_low		= 1,
@@ -87,15 +93,18 @@
 static unsigned int sheevaplug_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
 	MPP46_GPIO,	/* LED Red */
-	MPP49_GPIO,	/* LED */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
 	0
 };
 
-static unsigned int sheeva_esata_mpp_config[] __initdata = {
+static unsigned int esata_sheevaplug_mpp_config[] __initdata = {
 	MPP29_GPIO,	/* USB Power Enable */
 	MPP44_GPIO,	/* SD Write Protect */
 	MPP47_GPIO,	/* SD Card Detect */
-	MPP49_GPIO,	/* LED Green */
+	MPP46_GPIO,	/* LED Red */
+	MPP48_GPIO,	/* LED Green */
+	MPP49_GPIO,	/* LED Blue */
 	0
 };
 
@@ -107,8 +116,8 @@
 	kirkwood_init();
 
 	/* setup gpio pin select */
-	if (machine_is_sheeva_esata())
-		kirkwood_mpp_conf(sheeva_esata_mpp_config);
+	if (machine_is_esata_sheevaplug())
+		kirkwood_mpp_conf(esata_sheevaplug_mpp_config);
 	else
 		kirkwood_mpp_conf(sheevaplug_mpp_config);
 
@@ -123,12 +132,12 @@
 	kirkwood_ge00_init(&sheevaplug_ge00_data);
 
 	/* honor lower power consumption for plugs with out eSATA */
-	if (machine_is_sheeva_esata())
-		kirkwood_sata_init(&sheeva_esata_sata_data);
+	if (machine_is_esata_sheevaplug())
+		kirkwood_sata_init(&esata_sheevaplug_sata_data);
 
 	/* enable sd wp and sd cd on plugs with esata */
-	if (machine_is_sheeva_esata())
-		kirkwood_sdio_init(&sheeva_esata_mvsdio_data);
+	if (machine_is_esata_sheevaplug())
+		kirkwood_sdio_init(&esata_sheevaplug_mvsdio_data);
 	else
 		kirkwood_sdio_init(&sheevaplug_mvsdio_data);
 
diff -ruN a/arch/arm/mach-kirkwood/topkick-setup.c b/arch/arm/mach-kirkwood/topkick-setup.c
--- a/arch/arm/mach-kirkwood/topkick-setup.c	1969-12-31 17:00:00.000000000 -0700
+++ b/arch/arm/mach-kirkwood/topkick-setup.c	2013-09-16 01:27:45.777770983 -0600
@@ -0,0 +1,164 @@
+/*
+ * arch/arm/mach-kirkwood/topkick-setup.c
+ *
+ * USI Topkick Setup
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/mv643xx_eth.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <mach/kirkwood.h>
+#include <plat/mvsdio.h>
+#include "common.h"
+#include "mpp.h"
+
+static struct mtd_partition topkick_nand_parts[] = {
+	{
+		.name	= "u-boot",
+		.offset	= 0,
+		.size	= 0x180000
+	}, {
+		.name	= "u-boot-env",
+		.offset	= 0x180000,
+		.size	= 128 * 1024
+	}, {
+		.name	= "uImage",
+		.offset	= 2 * 1024 * 1024,
+		.size	= 6 * 1024 * 1024
+	}, {
+		.name	= "rootfs",
+		.offset	= MTDPART_OFS_NXTBLK,
+		.size	= MTDPART_SIZ_FULL
+	},
+};
+
+static struct mv643xx_eth_platform_data topkick_ge00_data = {
+	.phy_addr	= MV643XX_ETH_PHY_ADDR(0),
+};
+
+static struct mv_sata_platform_data topkick_sata_data = {
+	.n_ports	= 1,
+};
+
+static struct mvsdio_platform_data topkick_mvsdio_data = {
+	.gpio_card_detect = 47, /* MPP47 used as SD card detect */
+};
+
+
+static struct gpio_led topkick_led_pins[] = {
+	{
+		.name			= "status:blue:disk",
+		.default_trigger	= "none",
+		.gpio			= 21,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:red:fault",
+		.default_trigger	= "none",
+		.gpio			= 37,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:blue:health",
+		.default_trigger	= "default-on",
+		.gpio			= 38,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:green:misc",
+		.default_trigger	= "none",
+		.gpio			= 39,
+		.active_low		= 1,
+	},
+	{
+		.name			= "status:orange:misc",
+		.default_trigger	= "none",
+		.gpio			= 48,
+		.active_low		= 1,
+	},
+};
+
+static struct gpio_led_platform_data topkick_led_data = {
+	.leds		= topkick_led_pins,
+	.num_leds	= ARRAY_SIZE(topkick_led_pins),
+};
+
+static struct platform_device topkick_leds = {
+	.name	= "leds-gpio",
+	.id	= -1,
+	.dev	= {
+		.platform_data	= &topkick_led_data,
+	}
+};
+
+static unsigned int topkick_mpp_config[] __initdata = {
+	MPP12_SD_CLK,	/* SDIO Clock */
+	MPP13_SD_CMD,	/* SDIO Cmd */
+	MPP14_SD_D0,	/* SDIO Data 0 */
+	MPP15_SD_D1,	/* SDIO Data 1 */
+	MPP16_SD_D2,	/* SDIO Data 2 */
+	MPP17_SD_D3,	/* SDIO Data 3 */
+	MPP21_GPIO,	/* LED Blue SATA */
+	MPP35_GPIO,	/* USB Power Enable */
+	MPP36_GPIO,	/* SATA Power Enable */
+	MPP37_GPIO,	/* LED Red  System */
+	MPP38_GPIO,	/* LED Blue System */
+	MPP39_GPIO,	/* LED Green Misc/WiFi */
+	MPP43_GPIO,	/* WOL Eth WOL */
+	MPP44_GPIO,	/* SW GW Mode */
+	MPP45_GPIO,	/* SW AP Mode */
+	MPP46_GPIO,	/* SW Power Off */
+	MPP47_GPIO,	/* SDIO Detect */
+	MPP48_GPIO,	/* LED Orange Misc/WiFi */
+	0
+};
+
+static void __init topkick_init(void)
+{
+	/*
+	 * Basic setup. Needs to be called early.
+	 */
+	kirkwood_init();
+
+	/* setup gpio pin select */
+	kirkwood_mpp_conf(topkick_mpp_config);
+
+	kirkwood_uart0_init();
+	kirkwood_nand_init(ARRAY_AND_SIZE(topkick_nand_parts), 60);
+
+	if (gpio_request(35, "USB Power Enable") != 0 ||
+	    gpio_direction_output(35, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 35 (USB Power Enable)\n");
+	if (gpio_request(36, "SATA Power Enable") != 0 ||
+	    gpio_direction_output(36, 1) != 0)
+		printk(KERN_ERR "can't set up GPIO 36 (SATA Power Enable)\n");
+	kirkwood_ge00_init(&topkick_ge00_data);
+	kirkwood_ehci_init();
+	kirkwood_sata_init(&topkick_sata_data);
+	kirkwood_sdio_init(&topkick_mvsdio_data);
+
+	platform_device_register(&topkick_leds);
+}
+
+MACHINE_START(TOPKICK, "USI Topkick")
+	/* Maintainer: Mike Brown <mbrown@archlinuxarm.org> */
+	.boot_params	= 0x00000100,
+	.init_machine	= topkick_init,
+	.map_io		= kirkwood_map_io,
+	.init_early	= kirkwood_init_early,
+	.init_irq	= kirkwood_init_irq,
+	.timer		= &kirkwood_timer,
+MACHINE_END
diff -ruN a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c
--- a/arch/arm/plat-orion/common.c	2011-10-24 01:10:05.000000000 -0600
+++ b/arch/arm/plat-orion/common.c	2013-09-16 01:27:45.787770841 -0600
@@ -223,7 +223,9 @@
 /*****************************************************************************
  * GE00
  ****************************************************************************/
-struct mv643xx_eth_shared_platform_data orion_ge00_shared_data;
+struct mv643xx_eth_shared_platform_data orion_ge00_shared_data = {
+	.tx_csum_limit	= 1600,
+};
 
 static struct resource orion_ge00_shared_resources[] = {
 	{
diff -ruN a/.config b/.config
--- a/.config	1969-12-31 17:00:00.000000000 -0700
+++ b/.config	2013-09-16 01:27:45.817770421 -0600
@@ -0,0 +1,3901 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.1.10-20 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_SCHED_CLOCK=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_HAVE_IRQ_WORK=y
+CONFIG_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION="-ARCH"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_FHANDLE=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_AUDIT=y
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_CHIP=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=19
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+CONFIG_CGROUP_MEM_RES_CTLR=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP=y
+CONFIG_CGROUP_MEM_RES_CTLR_SWAP_ENABLED=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_MM_OWNER=y
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_PERF_COUNTERS is not set
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+CONFIG_OPROFILE=m
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_BLK_DEV_THROTTLING is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CFQ_GROUP_IOSCHED is not set
+CONFIG_IOSCHED_BFQ=y
+CONFIG_CGROUP_BFQIO=y
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_BFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="bfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_PRIMA2 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+CONFIG_ARCH_KIRKWOOD=y
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_ARCH_ZYNQ is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+
+#
+# Marvell Kirkwood Implementations
+#
+CONFIG_MACH_DB88F6281_BP=y
+CONFIG_MACH_RD88F6192_NAS=y
+CONFIG_MACH_RD88F6281=y
+CONFIG_MACH_MV88F6281GTW_GE=y
+CONFIG_MACH_SHEEVAPLUG=y
+CONFIG_MACH_ESATA_SHEEVAPLUG=y
+CONFIG_MACH_GURUPLUG=y
+CONFIG_MACH_TS219=y
+CONFIG_MACH_TS41X=y
+CONFIG_MACH_DOCKSTAR=y
+CONFIG_MACH_GOFLEXNET=y
+CONFIG_MACH_GOFLEXHOME=y
+CONFIG_MACH_ICONNECT=y
+CONFIG_MACH_POGOPLUGV4=y
+CONFIG_MACH_POGO_E02=y
+CONFIG_MACH_NAS6210=y
+CONFIG_MACH_TOPKICK=y
+CONFIG_MACH_IONICS_STRATUS=y
+CONFIG_MACH_OPENRD=y
+CONFIG_MACH_OPENRD_BASE=y
+CONFIG_MACH_OPENRD_CLIENT=y
+CONFIG_MACH_OPENRD_ULTIMATE=y
+CONFIG_MACH_BUBBA3=y
+CONFIG_MACH_NETSPACE_V2=y
+CONFIG_MACH_INETSPACE_V2=y
+CONFIG_MACH_NETSPACE_MAX_V2=y
+CONFIG_MACH_D2NET_V2=y
+CONFIG_MACH_NET2BIG_V2=y
+CONFIG_MACH_NET5BIG_V2=y
+CONFIG_MACH_T5325=y
+CONFIG_MACH_NSA310=y
+CONFIG_MACH_NSA320=y
+
+#
+# System MMU
+#
+CONFIG_PLAT_ORION=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_FEROCEON=y
+# CONFIG_CPU_FEROCEON_OLD_ID is not set
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5T=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_FEROCEON=y
+CONFIG_CPU_TLB_FEROCEON=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_CACHE_FEROCEON_L2=y
+# CONFIG_CACHE_FEROCEON_L2_WRITETHROUGH is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=32768
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+CONFIG_UACCESS_WITH_MEMCPY=y
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+# CONFIG_USE_OF is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+CONFIG_BINFMT_MISC=y
+
+#
+# Power management options
+#
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=m
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=m
+CONFIG_NET_KEY=m
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_ROUTE_CLASSID=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=m
+CONFIG_NET_IPGRE_DEMUX=y
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_ARPD=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=m
+CONFIG_INET_ESP=m
+CONFIG_INET_IPCOMP=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=m
+CONFIG_INET_XFRM_MODE_TUNNEL=m
+CONFIG_INET_XFRM_MODE_BEET=m
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_IPV6_ROUTER_PREF=y
+# CONFIG_IPV6_ROUTE_INFO is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_NF_CONNTRACK_TIMESTAMP=y
+CONFIG_NF_CT_PROTO_DCCP=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_NF_CT_PROTO_UDPLITE=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_NF_CONNTRACK_BROADCAST=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_NF_CONNTRACK_SANE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NETFILTER_TPROXY=m
+CONFIG_NETFILTER_XTABLES=m
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=m
+CONFIG_NETFILTER_XT_CONNMARK=m
+CONFIG_NETFILTER_XT_SET=m
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_AUDIT=m
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NETFILTER_XT_TARGET_CT=m
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_NETFILTER_XT_TARGET_HL=m
+CONFIG_NETFILTER_XT_TARGET_IDLETIMER=m
+CONFIG_NETFILTER_XT_TARGET_LED=m
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_NETFILTER_XT_TARGET_RATEEST=m
+CONFIG_NETFILTER_XT_TARGET_TEE=m
+CONFIG_NETFILTER_XT_TARGET_TPROXY=m
+CONFIG_NETFILTER_XT_TARGET_TRACE=m
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=m
+CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP=m
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_CLUSTER=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_NETFILTER_XT_MATCH_CONNLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_NETFILTER_XT_MATCH_CPU=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NETFILTER_XT_MATCH_DEVGROUP=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_NETFILTER_XT_MATCH_HL=m
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_OSF=m
+CONFIG_NETFILTER_XT_MATCH_OWNER=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_NETFILTER_XT_MATCH_RATEEST=m
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_NETFILTER_XT_MATCH_RECENT=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_NETFILTER_XT_MATCH_SOCKET=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NETFILTER_XT_MATCH_TIME=m
+CONFIG_NETFILTER_XT_MATCH_U32=m
+CONFIG_IP_SET=m
+CONFIG_IP_SET_MAX=256
+CONFIG_IP_SET_BITMAP_IP=m
+CONFIG_IP_SET_BITMAP_IPMAC=m
+CONFIG_IP_SET_BITMAP_PORT=m
+CONFIG_IP_SET_HASH_IP=m
+CONFIG_IP_SET_HASH_IPPORT=m
+CONFIG_IP_SET_HASH_IPPORTIP=m
+CONFIG_IP_SET_HASH_IPPORTNET=m
+CONFIG_IP_SET_HASH_NET=m
+CONFIG_IP_SET_HASH_NETPORT=m
+CONFIG_IP_SET_HASH_NETIFACE=m
+CONFIG_IP_SET_LIST_SET=m
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+# CONFIG_IP_NF_QUEUE is not set
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_NF_NAT=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_NF_NAT_PROTO_DCCP=m
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NF_NAT_PROTO_UDPLITE=m
+CONFIG_NF_NAT_PROTO_SCTP=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_NF_NAT_H323=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_IP_NF_RAW=m
+# CONFIG_IP_NF_SECURITY is not set
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_IP_NF_ARP_MANGLE=m
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV6=m
+CONFIG_NF_CONNTRACK_IPV6=m
+# CONFIG_IP6_NF_QUEUE is not set
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_MATCH_MH=m
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_IP6_NF_RAW=m
+# CONFIG_IP6_NF_SECURITY is not set
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_BRIDGE_EBT_IP6=m
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_BRIDGE_EBT_NFLOG=m
+# CONFIG_IP_DCCP is not set
+CONFIG_IP_SCTP=m
+CONFIG_NET_SCTPPROBE=m
+# CONFIG_SCTP_DBG_MSG is not set
+# CONFIG_SCTP_DBG_OBJCNT is not set
+# CONFIG_SCTP_HMAC_NONE is not set
+# CONFIG_SCTP_HMAC_SHA1 is not set
+CONFIG_SCTP_HMAC_MD5=y
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+CONFIG_L2TP=m
+# CONFIG_L2TP_DEBUGFS is not set
+# CONFIG_L2TP_V3 is not set
+CONFIG_STP=m
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_NET_DSA=y
+# CONFIG_NET_DSA_TAG_DSA is not set
+CONFIG_NET_DSA_TAG_EDSA=y
+# CONFIG_NET_DSA_TAG_TRAILER is not set
+CONFIG_NET_DSA_MV88E6XXX=y
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+CONFIG_NET_DSA_MV88E6123_61_65=y
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=m
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+CONFIG_ATALK=m
+CONFIG_DEV_APPLETALK=m
+CONFIG_IPDDP=m
+# CONFIG_IPDDP_ENCAP is not set
+# CONFIG_IPDDP_DECAP is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+CONFIG_WAN_ROUTER=m
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=m
+CONFIG_NET_SCH_HTB=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_NET_SCH_MULTIQ=m
+CONFIG_NET_SCH_RED=m
+CONFIG_NET_SCH_SFB=m
+CONFIG_NET_SCH_SFQ=m
+CONFIG_NET_SCH_TEQL=m
+CONFIG_NET_SCH_TBF=m
+CONFIG_NET_SCH_GRED=m
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_NET_SCH_DRR=m
+CONFIG_NET_SCH_MQPRIO=m
+CONFIG_NET_SCH_CHOKE=m
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_INGRESS is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+CONFIG_NET_CLS_BASIC=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_NET_CLS_FW=m
+CONFIG_NET_CLS_U32=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_NET_CLS_FLOW=m
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NET_EMATCH_U32=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_GACT_PROB=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_NET_ACT_IPT=m
+CONFIG_NET_ACT_NAT=m
+CONFIG_NET_ACT_PEDIT=m
+# CONFIG_NET_ACT_SIMP is not set
+CONFIG_NET_ACT_SKBEDIT=m
+CONFIG_NET_ACT_CSUM=m
+# CONFIG_NET_CLS_IND is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=m
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+CONFIG_AX25=m
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NETROM=m
+CONFIG_ROSE=m
+
+#
+# AX.25 network device drivers
+#
+CONFIG_MKISS=m
+CONFIG_6PACK=m
+CONFIG_BPQETHER=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_YAM=m
+# CONFIG_CAN is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+CONFIG_IRDA_ULTRA=y
+
+#
+# IrDA options
+#
+# CONFIG_IRDA_CACHE_LAST_LSAP is not set
+# CONFIG_IRDA_FAST_RR is not set
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+CONFIG_DONGLE=y
+CONFIG_ESI_DONGLE=m
+CONFIG_ACTISYS_DONGLE=m
+CONFIG_TEKRAM_DONGLE=m
+CONFIG_TOIM3232_DONGLE=m
+CONFIG_LITELINK_DONGLE=m
+CONFIG_MA600_DONGLE=m
+CONFIG_GIRBIL_DONGLE=m
+CONFIG_MCP2120_DONGLE=m
+CONFIG_OLD_BELKIN_DONGLE=m
+CONFIG_ACT200L_DONGLE=m
+CONFIG_KINGSUN_DONGLE=m
+CONFIG_KSDAZZLE_DONGLE=m
+CONFIG_KS959_DONGLE=m
+
+#
+# FIR device drivers
+#
+CONFIG_USB_IRDA=m
+CONFIG_SIGMATEL_FIR=m
+# CONFIG_TOSHIBA_FIR is not set
+CONFIG_VLSI_FIR=m
+CONFIG_MCS_FIR=m
+CONFIG_BT=m
+CONFIG_BT_L2CAP=y
+CONFIG_BT_SCO=y
+CONFIG_BT_RFCOMM=m
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=m
+# CONFIG_BT_BNEP_MC_FILTER is not set
+# CONFIG_BT_BNEP_PROTO_FILTER is not set
+CONFIG_BT_HIDP=m
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_HCIBTUSB=m
+CONFIG_BT_HCIBTSDIO=m
+CONFIG_BT_HCIUART=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_BT_HCIUART_ATH3K=y
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIBCM203X=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_BT_HCIBFUSB=m
+CONFIG_BT_HCIVHCI=m
+CONFIG_BT_MRVL=m
+CONFIG_BT_MRVL_SDIO=m
+CONFIG_BT_ATH3K=m
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=m
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=y
+CONFIG_LIB80211_CRYPT_WEP=m
+CONFIG_LIB80211_CRYPT_CCMP=m
+CONFIG_LIB80211_CRYPT_TKIP=m
+# CONFIG_LIB80211_DEBUG is not set
+CONFIG_MAC80211=m
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_WIMAX=m
+CONFIG_WIMAX_DEBUG_LEVEL=8
+CONFIG_RFKILL=m
+CONFIG_RFKILL_LEDS=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+CONFIG_CAIF=m
+# CONFIG_CAIF_DEBUG is not set
+CONFIG_CAIF_NETDEV=m
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=m
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+CONFIG_SM_FTL=m
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+CONFIG_MTD_JEDECPROBE=y
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+CONFIG_MTD_CFI_INTELEXT=y
+# CONFIG_MTD_CFI_AMDSTD is not set
+CONFIG_MTD_CFI_STAA=y
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_IMPA7 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+CONFIG_MTD_NAND_ORION=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_SX8=m
+CONFIG_BLK_DEV_UB=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=8192
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+CONFIG_ATA_OVER_ETH=m
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+CONFIG_AD525X_DPOT=m
+# CONFIG_AD525X_DPOT_I2C is not set
+# CONFIG_AD525X_DPOT_SPI is not set
+CONFIG_PHANTOM=m
+# CONFIG_INTEL_MID_PTI is not set
+CONFIG_SGI_IOC4=m
+CONFIG_TIFM_CORE=m
+CONFIG_TIFM_7XX1=m
+CONFIG_ICS932S401=m
+CONFIG_ENCLOSURE_SERVICES=m
+CONFIG_HP_ILO=m
+# CONFIG_APDS9802ALS is not set
+CONFIG_ISL29003=m
+# CONFIG_ISL29020 is not set
+CONFIG_SENSORS_TSL2550=m
+CONFIG_SENSORS_BH1780=m
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+CONFIG_HMC6352=m
+CONFIG_DS1682=m
+CONFIG_TI_DAC7512=m
+CONFIG_BMP085=m
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+CONFIG_C2PORT=m
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+CONFIG_EEPROM_93CX6=m
+# CONFIG_EEPROM_93XX46 is not set
+CONFIG_CB710_CORE=m
+# CONFIG_CB710_DEBUG is not set
+CONFIG_CB710_DEBUG_ASSUMPTIONS=y
+CONFIG_IWMC3200TOP=m
+# CONFIG_IWMC3200TOP_DEBUG is not set
+# CONFIG_IWMC3200TOP_DEBUGFS is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=m
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_ST=m
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=m
+CONFIG_SCSI_ENCLOSURE=m
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_ISCSI_TCP=m
+CONFIG_ISCSI_BOOT_SYSFS=m
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+# CONFIG_SATA_AHCI is not set
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+# CONFIG_ATA_PIIX is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARASAN_CF is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SCH is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=m
+CONFIG_MD_LINEAR=m
+CONFIG_MD_RAID0=m
+CONFIG_MD_RAID1=m
+CONFIG_MD_RAID10=m
+CONFIG_MD_RAID456=m
+CONFIG_MD_MULTIPATH=m
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=m
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=m
+CONFIG_DM_SNAPSHOT=m
+CONFIG_DM_MIRROR=m
+CONFIG_DM_RAID=m
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_DM_MULTIPATH_QL=m
+CONFIG_DM_MULTIPATH_ST=m
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+CONFIG_TARGET_CORE=m
+CONFIG_TCM_IBLOCK=m
+CONFIG_TCM_FILEIO=m
+CONFIG_TCM_PSCSI=m
+CONFIG_LOOPBACK_TARGET=m
+CONFIG_ISCSI_TARGET=m
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+CONFIG_I2O=m
+CONFIG_I2O_LCT_NOTIFY_ON_CHANGES=y
+CONFIG_I2O_EXT_ADAPTEC=y
+# CONFIG_I2O_CONFIG is not set
+# CONFIG_I2O_BUS is not set
+# CONFIG_I2O_BLOCK is not set
+# CONFIG_I2O_SCSI is not set
+# CONFIG_I2O_PROC is not set
+CONFIG_NETDEVICES=y
+# CONFIG_IFB is not set
+# CONFIG_DUMMY is not set
+CONFIG_BONDING=m
+CONFIG_MACVLAN=m
+CONFIG_MACVTAP=m
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+CONFIG_VETH=m
+# CONFIG_ARCNET is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_MARVELL_PHY=y
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_E1000E is not set
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+CONFIG_MV643XX_ETH=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+# CONFIG_STMMAC_ETH is not set
+CONFIG_PCH_GBE=y
+# CONFIG_FTGMAC100 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_TR is not set
+CONFIG_WLAN=y
+CONFIG_LIBERTAS_THINFIRM=m
+# CONFIG_LIBERTAS_THINFIRM_DEBUG is not set
+CONFIG_LIBERTAS_THINFIRM_USB=m
+CONFIG_LIBERTAS_UAP=m
+# CONFIG_ATMEL is not set
+CONFIG_AT76C50X_USB=m
+# CONFIG_PRISM54 is not set
+CONFIG_USB_ZD1201=m
+CONFIG_USB_NET_RNDIS_WLAN=m
+CONFIG_RTL8180=m
+CONFIG_RTL8187=m
+CONFIG_RTL8187_LEDS=y
+# CONFIG_ADM8211 is not set
+# CONFIG_MAC80211_HWSIM is not set
+CONFIG_MWL8K=m
+CONFIG_ATH_COMMON=m
+# CONFIG_ATH_DEBUG is not set
+CONFIG_ATH5K=m
+# CONFIG_ATH5K_DEBUG is not set
+# CONFIG_ATH5K_TRACER is not set
+CONFIG_ATH5K_PCI=y
+CONFIG_ATH9K_HW=m
+CONFIG_ATH9K_COMMON=m
+CONFIG_ATH9K=m
+CONFIG_ATH9K_PCI=y
+# CONFIG_ATH9K_AHB is not set
+# CONFIG_ATH9K_DEBUGFS is not set
+CONFIG_ATH9K_RATE_CONTROL=y
+CONFIG_ATH9K_HTC=m
+# CONFIG_ATH9K_HTC_DEBUGFS is not set
+CONFIG_CARL9170=m
+CONFIG_CARL9170_LEDS=y
+CONFIG_CARL9170_WPC=y
+CONFIG_B43=m
+CONFIG_B43_SSB=y
+CONFIG_B43_PCI_AUTOSELECT=y
+CONFIG_B43_PCICORE_AUTOSELECT=y
+# CONFIG_B43_SDIO is not set
+CONFIG_B43_PIO=y
+# CONFIG_B43_PHY_N is not set
+CONFIG_B43_PHY_LP=y
+CONFIG_B43_LEDS=y
+# CONFIG_B43_DEBUG is not set
+# CONFIG_B43LEGACY is not set
+CONFIG_HOSTAP=m
+CONFIG_HOSTAP_FIRMWARE=y
+# CONFIG_HOSTAP_FIRMWARE_NVRAM is not set
+# CONFIG_HOSTAP_PLX is not set
+CONFIG_HOSTAP_PCI=m
+CONFIG_IPW2100=m
+# CONFIG_IPW2100_MONITOR is not set
+# CONFIG_IPW2100_DEBUG is not set
+CONFIG_IPW2200=m
+# CONFIG_IPW2200_MONITOR is not set
+CONFIG_IPW2200_QOS=y
+# CONFIG_IPW2200_DEBUG is not set
+CONFIG_LIBIPW=m
+# CONFIG_LIBIPW_DEBUG is not set
+CONFIG_IWLAGN=m
+
+#
+# Debugging Options
+#
+# CONFIG_IWLWIFI_DEBUG is not set
+# CONFIG_IWLWIFI_DEVICE_TRACING is not set
+# CONFIG_IWLWIFI_DEVICE_SVTOOL is not set
+# CONFIG_IWL_P2P is not set
+CONFIG_IWLWIFI_LEGACY=m
+
+#
+# Debugging Options
+#
+# CONFIG_IWLWIFI_LEGACY_DEBUG is not set
+# CONFIG_IWLWIFI_LEGACY_DEVICE_TRACING is not set
+# CONFIG_IWL4965 is not set
+CONFIG_IWL3945=m
+# CONFIG_IWM is not set
+CONFIG_LIBERTAS=m
+CONFIG_LIBERTAS_USB=m
+CONFIG_LIBERTAS_SDIO=m
+CONFIG_LIBERTAS_SPI=m
+# CONFIG_LIBERTAS_DEBUG is not set
+CONFIG_LIBERTAS_MESH=y
+CONFIG_HERMES=m
+CONFIG_HERMES_PRISM=y
+CONFIG_HERMES_CACHE_FW_ON_INIT=y
+CONFIG_PLX_HERMES=m
+CONFIG_TMD_HERMES=m
+CONFIG_NORTEL_HERMES=m
+CONFIG_PCI_HERMES=m
+CONFIG_ORINOCO_USB=m
+CONFIG_P54_COMMON=m
+CONFIG_P54_USB=m
+CONFIG_P54_PCI=m
+CONFIG_P54_SPI=m
+# CONFIG_P54_SPI_DEFAULT_EEPROM is not set
+CONFIG_P54_LEDS=y
+CONFIG_RT2X00=m
+CONFIG_RT2400PCI=m
+CONFIG_RT2500PCI=m
+CONFIG_RT61PCI=m
+CONFIG_RT2800PCI=m
+# CONFIG_RT2800PCI_RT33XX is not set
+CONFIG_RT2800PCI_RT35XX=y
+# CONFIG_RT2800PCI_RT53XX is not set
+CONFIG_RT2500USB=m
+CONFIG_RT73USB=m
+CONFIG_RT2800USB=m
+CONFIG_RT2800USB_RT33XX=y
+CONFIG_RT2800USB_RT35XX=y
+# CONFIG_RT2800USB_RT53XX is not set
+CONFIG_RT2800USB_UNKNOWN=y
+CONFIG_RT2800_LIB=m
+CONFIG_RT2X00_LIB_PCI=m
+CONFIG_RT2X00_LIB_USB=m
+CONFIG_RT2X00_LIB=m
+CONFIG_RT2X00_LIB_FIRMWARE=y
+CONFIG_RT2X00_LIB_CRYPTO=y
+CONFIG_RT2X00_LIB_LEDS=y
+# CONFIG_RT2X00_DEBUG is not set
+CONFIG_RTL8192CE=m
+CONFIG_RTL8192SE=m
+CONFIG_RTL8192DE=m
+CONFIG_RTL8192CU=m
+CONFIG_RTLWIFI=m
+CONFIG_RTL8192C_COMMON=m
+CONFIG_WL1251=m
+CONFIG_WL1251_SPI=m
+CONFIG_WL1251_SDIO=m
+CONFIG_WL12XX_MENU=m
+CONFIG_WL12XX=m
+# CONFIG_WL12XX_HT is not set
+# CONFIG_WL12XX_SPI is not set
+CONFIG_WL12XX_SDIO=m
+# CONFIG_WL12XX_SDIO_TEST is not set
+CONFIG_WL12XX_PLATFORM_DATA=y
+CONFIG_ZD1211RW=m
+# CONFIG_ZD1211RW_DEBUG is not set
+CONFIG_MWIFIEX=m
+CONFIG_MWIFIEX_SDIO=m
+
+#
+# WiMAX Wireless Broadband devices
+#
+CONFIG_WIMAX_I2400M=m
+CONFIG_WIMAX_I2400M_USB=m
+CONFIG_WIMAX_I2400M_SDIO=m
+CONFIG_WIMAX_IWMC3200_SDIO=y
+CONFIG_WIMAX_I2400M_DEBUG_LEVEL=8
+
+#
+# USB Network Adapters
+#
+CONFIG_USB_CATC=m
+CONFIG_USB_KAWETH=m
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_CDCETHER=m
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=m
+CONFIG_USB_NET_DM9601=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_USB_AN2720=y
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+CONFIG_USB_EPSON2888=y
+CONFIG_USB_KC2190=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_USB_NET_CX82310_ETH=m
+CONFIG_USB_NET_KALMIA=m
+CONFIG_USB_HSO=m
+CONFIG_USB_NET_INT51X1=m
+CONFIG_USB_IPHETH=m
+CONFIG_USB_SIERRA_NET=m
+CONFIG_USB_VL600=m
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+CONFIG_CAIF_TTY=m
+CONFIG_CAIF_SPI_SLAVE=m
+# CONFIG_CAIF_SPI_SYNC is not set
+# CONFIG_CAIF_HSI is not set
+CONFIG_FDDI=m
+CONFIG_DEFXX=m
+# CONFIG_DEFXX_MMIO is not set
+# CONFIG_SKFP is not set
+CONFIG_HIPPI=y
+# CONFIG_ROADRUNNER is not set
+CONFIG_PPP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_PPP_BSDCOMP=m
+CONFIG_PPP_MPPE=m
+CONFIG_PPPOE=m
+# CONFIG_PPTP is not set
+CONFIG_PPPOL2TP=m
+# CONFIG_SLIP is not set
+CONFIG_SLHC=m
+# CONFIG_NET_FC is not set
+CONFIG_NETCONSOLE=y
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=m
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=m
+# CONFIG_KEYBOARD_QT1070 is not set
+CONFIG_KEYBOARD_QT2160=m
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_TCA6416=m
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=m
+CONFIG_MOUSE_APPLETOUCH=m
+CONFIG_MOUSE_BCM5974=m
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+CONFIG_MOUSE_SYNAPTICS_I2C=m
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+CONFIG_TABLET_USB_WACOM=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_TOUCHSCREEN_AD7877=m
+CONFIG_TOUCHSCREEN_AD7879=m
+CONFIG_TOUCHSCREEN_AD7879_I2C=m
+CONFIG_TOUCHSCREEN_AD7879_SPI=m
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+CONFIG_TOUCHSCREEN_BU21013=m
+CONFIG_TOUCHSCREEN_CY8CTMG110=m
+CONFIG_TOUCHSCREEN_DYNAPRO=m
+CONFIG_TOUCHSCREEN_HAMPSHIRE=m
+# CONFIG_TOUCHSCREEN_EETI is not set
+CONFIG_TOUCHSCREEN_FUJITSU=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_TOUCHSCREEN_WACOM_W8001=m
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+CONFIG_TOUCHSCREEN_MCS5000=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_TOUCHSCREEN_INEXIO=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=m
+CONFIG_TOUCHSCREEN_USB_EGALAX=y
+CONFIG_TOUCHSCREEN_USB_PANJIT=y
+CONFIG_TOUCHSCREEN_USB_3M=y
+CONFIG_TOUCHSCREEN_USB_ITM=y
+CONFIG_TOUCHSCREEN_USB_ETURBO=y
+CONFIG_TOUCHSCREEN_USB_GUNZE=y
+CONFIG_TOUCHSCREEN_USB_DMC_TSC10=y
+CONFIG_TOUCHSCREEN_USB_IRTOUCH=y
+CONFIG_TOUCHSCREEN_USB_IDEALTEK=y
+CONFIG_TOUCHSCREEN_USB_GENERAL_TOUCH=y
+CONFIG_TOUCHSCREEN_USB_GOTOP=y
+CONFIG_TOUCHSCREEN_USB_JASTEC=y
+CONFIG_TOUCHSCREEN_USB_E2I=y
+CONFIG_TOUCHSCREEN_USB_ZYTRONIC=y
+CONFIG_TOUCHSCREEN_USB_ETT_TC45USB=y
+CONFIG_TOUCHSCREEN_USB_NEXIO=y
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+CONFIG_TOUCHSCREEN_TSC2007=m
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+CONFIG_TOUCHSCREEN_TPS6507X=m
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+CONFIG_INPUT_ATI_REMOTE=m
+CONFIG_INPUT_ATI_REMOTE2=m
+CONFIG_INPUT_KEYSPAN_REMOTE=m
+# CONFIG_INPUT_KXTJ9 is not set
+CONFIG_INPUT_POWERMATE=m
+CONFIG_INPUT_YEALINK=m
+CONFIG_INPUT_CM109=m
+CONFIG_INPUT_UINPUT=m
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=m
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_RAMOOPS=m
+CONFIG_I2C=m
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=m
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=m
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_INTEL_MID is not set
+CONFIG_I2C_MV64XXX=m
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_EG20T is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_ORION=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+
+#
+# Enable Device Drivers -> PPS to see the PTP clock options.
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_VX855 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+CONFIG_W1=m
+
+#
+# 1-wire Bus Masters
+#
+CONFIG_W1_MASTER_MATROX=m
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_W1_MASTER_DS2482=m
+# CONFIG_W1_MASTER_DS1WM is not set
+CONFIG_W1_MASTER_GPIO=m
+
+#
+# 1-wire Slaves
+#
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_W1_SLAVE_SMEM=m
+# CONFIG_W1_SLAVE_DS2408 is not set
+CONFIG_W1_SLAVE_DS2423=m
+CONFIG_W1_SLAVE_DS2431=m
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_W1_SLAVE_DS2433_CRC=y
+CONFIG_W1_SLAVE_DS2760=m
+# CONFIG_W1_SLAVE_DS2780 is not set
+CONFIG_W1_SLAVE_BQ27000=m
+CONFIG_POWER_SUPPLY=m
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ20Z75 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_GPIO is not set
+CONFIG_HWMON=m
+CONFIG_HWMON_VID=m
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+CONFIG_SENSORS_LM63=m
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=m
+CONFIG_SENSORS_LM77=m
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+CONFIG_SENSORS_LM85=m
+# CONFIG_SENSORS_LM87 is not set
+CONFIG_SENSORS_LM90=m
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_SENSORS_NSA3XX=m
+CONFIG_THERMAL=m
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_CORE is not set
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_ORION_WATCHDOG=m
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ALIM7101_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+CONFIG_SSB=m
+CONFIG_SSB_SPROM=y
+CONFIG_SSB_BLOCKIO=y
+CONFIG_SSB_PCIHOST_POSSIBLE=y
+CONFIG_SSB_PCIHOST=y
+CONFIG_SSB_B43_PCI_BRIDGE=y
+CONFIG_SSB_SDIOHOST_POSSIBLE=y
+# CONFIG_SSB_SDIOHOST is not set
+# CONFIG_SSB_DEBUG is not set
+CONFIG_SSB_DRIVER_PCICORE_POSSIBLE=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=m
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CONTROLLER is not set
+CONFIG_VIDEO_DEV=m
+CONFIG_VIDEO_V4L2_COMMON=m
+CONFIG_DVB_CORE=m
+CONFIG_DVB_NET=y
+CONFIG_VIDEO_MEDIA=m
+
+#
+# Multimedia drivers
+#
+CONFIG_RC_CORE=m
+CONFIG_LIRC=m
+CONFIG_RC_MAP=m
+CONFIG_IR_NEC_DECODER=m
+CONFIG_IR_RC5_DECODER=m
+CONFIG_IR_RC6_DECODER=m
+CONFIG_IR_JVC_DECODER=m
+CONFIG_IR_SONY_DECODER=m
+CONFIG_IR_RC5_SZ_DECODER=m
+CONFIG_IR_MCE_KBD_DECODER=m
+CONFIG_IR_LIRC_CODEC=m
+CONFIG_IR_IMON=m
+CONFIG_IR_MCEUSB=m
+CONFIG_IR_REDRAT3=m
+CONFIG_IR_STREAMZAP=m
+CONFIG_RC_LOOPBACK=m
+CONFIG_MEDIA_ATTACH=y
+CONFIG_MEDIA_TUNER=m
+CONFIG_MEDIA_TUNER_CUSTOMISE=y
+
+#
+# Customize TV tuners
+#
+CONFIG_MEDIA_TUNER_SIMPLE=m
+CONFIG_MEDIA_TUNER_TDA8290=m
+CONFIG_MEDIA_TUNER_TDA827X=m
+CONFIG_MEDIA_TUNER_TDA18271=m
+CONFIG_MEDIA_TUNER_TDA9887=m
+CONFIG_MEDIA_TUNER_TEA5761=m
+CONFIG_MEDIA_TUNER_TEA5767=m
+CONFIG_MEDIA_TUNER_MT20XX=m
+CONFIG_MEDIA_TUNER_MT2060=m
+CONFIG_MEDIA_TUNER_MT2266=m
+CONFIG_MEDIA_TUNER_MT2131=m
+CONFIG_MEDIA_TUNER_QT1010=m
+CONFIG_MEDIA_TUNER_XC2028=m
+CONFIG_MEDIA_TUNER_XC5000=m
+CONFIG_MEDIA_TUNER_XC4000=m
+CONFIG_MEDIA_TUNER_MXL5005S=m
+CONFIG_MEDIA_TUNER_MXL5007T=m
+CONFIG_MEDIA_TUNER_MC44S803=m
+CONFIG_MEDIA_TUNER_MAX2165=m
+CONFIG_MEDIA_TUNER_TDA18218=m
+CONFIG_MEDIA_TUNER_TDA18212=m
+CONFIG_VIDEO_V4L2=m
+CONFIG_VIDEOBUF_GEN=m
+CONFIG_VIDEOBUF_VMALLOC=m
+CONFIG_VIDEOBUF_DVB=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_VIDEO_TUNER=m
+CONFIG_VIDEOBUF2_CORE=m
+CONFIG_VIDEOBUF2_MEMOPS=m
+CONFIG_VIDEOBUF2_VMALLOC=m
+CONFIG_VIDEO_CAPTURE_DRIVERS=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEO_HELPER_CHIPS_AUTO=y
+CONFIG_VIDEO_IR_I2C=m
+
+#
+# Audio decoders, processors and mixers
+#
+CONFIG_VIDEO_MSP3400=m
+CONFIG_VIDEO_CS53L32A=m
+CONFIG_VIDEO_WM8775=m
+CONFIG_VIDEO_WM8739=m
+CONFIG_VIDEO_VP27SMPX=m
+
+#
+# RDS decoders
+#
+
+#
+# Video decoders
+#
+CONFIG_VIDEO_SAA711X=m
+CONFIG_VIDEO_TVP5150=m
+
+#
+# Video and audio decoders
+#
+CONFIG_VIDEO_SAA717X=m
+CONFIG_VIDEO_CX25840=m
+
+#
+# MPEG video encoders
+#
+CONFIG_VIDEO_CX2341X=m
+
+#
+# Video encoders
+#
+CONFIG_VIDEO_SAA7127=m
+
+#
+# Camera sensor devices
+#
+CONFIG_VIDEO_MT9V011=m
+
+#
+# Flash devices
+#
+
+#
+# Video improvement chips
+#
+CONFIG_VIDEO_UPD64031A=m
+CONFIG_VIDEO_UPD64083=m
+
+#
+# Miscelaneous helper chips
+#
+CONFIG_VIDEO_M52790=m
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_BT848 is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_ZORAN is not set
+# CONFIG_VIDEO_SAA7134 is not set
+# CONFIG_VIDEO_MXB is not set
+# CONFIG_VIDEO_HEXIUM_ORION is not set
+# CONFIG_VIDEO_HEXIUM_GEMINI is not set
+# CONFIG_VIDEO_TIMBERDALE is not set
+# CONFIG_VIDEO_CX88 is not set
+# CONFIG_VIDEO_CX23885 is not set
+# CONFIG_VIDEO_AU0828 is not set
+CONFIG_VIDEO_IVTV=m
+# CONFIG_VIDEO_FB_IVTV is not set
+# CONFIG_VIDEO_CX18 is not set
+# CONFIG_VIDEO_SAA7164 is not set
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_V4L_USB_DRIVERS=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+CONFIG_USB_GSPCA=m
+CONFIG_USB_M5602=m
+CONFIG_USB_STV06XX=m
+CONFIG_USB_GL860=m
+CONFIG_USB_GSPCA_BENQ=m
+CONFIG_USB_GSPCA_CONEX=m
+CONFIG_USB_GSPCA_CPIA1=m
+CONFIG_USB_GSPCA_ETOMS=m
+CONFIG_USB_GSPCA_FINEPIX=m
+CONFIG_USB_GSPCA_JEILINJ=m
+CONFIG_USB_GSPCA_KINECT=m
+CONFIG_USB_GSPCA_KONICA=m
+CONFIG_USB_GSPCA_MARS=m
+CONFIG_USB_GSPCA_MR97310A=m
+CONFIG_USB_GSPCA_NW80X=m
+CONFIG_USB_GSPCA_OV519=m
+CONFIG_USB_GSPCA_OV534=m
+CONFIG_USB_GSPCA_OV534_9=m
+CONFIG_USB_GSPCA_PAC207=m
+CONFIG_USB_GSPCA_PAC7302=m
+CONFIG_USB_GSPCA_PAC7311=m
+CONFIG_USB_GSPCA_SE401=m
+CONFIG_USB_GSPCA_SN9C2028=m
+CONFIG_USB_GSPCA_SN9C20X=m
+CONFIG_USB_GSPCA_SONIXB=m
+CONFIG_USB_GSPCA_SONIXJ=m
+CONFIG_USB_GSPCA_SPCA500=m
+CONFIG_USB_GSPCA_SPCA501=m
+CONFIG_USB_GSPCA_SPCA505=m
+CONFIG_USB_GSPCA_SPCA506=m
+CONFIG_USB_GSPCA_SPCA508=m
+CONFIG_USB_GSPCA_SPCA561=m
+CONFIG_USB_GSPCA_SPCA1528=m
+CONFIG_USB_GSPCA_SQ905=m
+CONFIG_USB_GSPCA_SQ905C=m
+CONFIG_USB_GSPCA_SQ930X=m
+CONFIG_USB_GSPCA_STK014=m
+CONFIG_USB_GSPCA_STV0680=m
+CONFIG_USB_GSPCA_SUNPLUS=m
+CONFIG_USB_GSPCA_T613=m
+CONFIG_USB_GSPCA_TV8532=m
+CONFIG_USB_GSPCA_VC032X=m
+CONFIG_USB_GSPCA_VICAM=m
+CONFIG_USB_GSPCA_XIRLINK_CIT=m
+CONFIG_USB_GSPCA_ZC3XX=m
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+CONFIG_VIDEO_PVRUSB2_DVB=y
+# CONFIG_VIDEO_PVRUSB2_DEBUGIFC is not set
+CONFIG_VIDEO_HDPVR=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_VIDEO_EM28XX_ALSA=m
+CONFIG_VIDEO_EM28XX_DVB=m
+CONFIG_VIDEO_EM28XX_RC=y
+CONFIG_VIDEO_TLG2300=m
+CONFIG_VIDEO_CX231XX=m
+CONFIG_VIDEO_CX231XX_RC=y
+CONFIG_VIDEO_CX231XX_ALSA=m
+CONFIG_VIDEO_CX231XX_DVB=m
+CONFIG_VIDEO_USBVISION=m
+CONFIG_USB_ET61X251=m
+CONFIG_USB_SN9C102=m
+CONFIG_USB_PWC=m
+# CONFIG_USB_PWC_DEBUG is not set
+CONFIG_USB_PWC_INPUT_EVDEV=y
+CONFIG_USB_ZR364XX=m
+CONFIG_USB_STKWEBCAM=m
+CONFIG_USB_S2255=m
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+CONFIG_RADIO_ADAPTERS=y
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_I2C_SI4713 is not set
+# CONFIG_RADIO_SI4713 is not set
+CONFIG_USB_DSBR=m
+CONFIG_RADIO_SI470X=y
+CONFIG_USB_SI470X=m
+# CONFIG_I2C_SI470X is not set
+CONFIG_USB_MR800=m
+# CONFIG_RADIO_TEA5764 is not set
+# CONFIG_RADIO_SAA7706H is not set
+# CONFIG_RADIO_TEF6862 is not set
+# CONFIG_RADIO_WL1273 is not set
+
+#
+# Texas Instruments WL128x FM driver (ST based)
+#
+# CONFIG_RADIO_WL128X is not set
+CONFIG_DVB_MAX_ADAPTERS=8
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+CONFIG_DVB_CAPTURE_DRIVERS=y
+
+#
+# Supported SAA7146 based PCI Adapters
+#
+# CONFIG_TTPCI_EEPROM is not set
+# CONFIG_DVB_AV7110 is not set
+# CONFIG_DVB_BUDGET_CORE is not set
+
+#
+# Supported USB Adapters
+#
+CONFIG_DVB_USB=m
+# CONFIG_DVB_USB_DEBUG is not set
+CONFIG_DVB_USB_A800=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_DVB_USB_DIBUSB_MB_FAULTY=y
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_DVB_USB_M920X=m
+CONFIG_DVB_USB_GL861=m
+CONFIG_DVB_USB_AU6610=m
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_DVB_USB_OPERA1=m
+CONFIG_DVB_USB_AF9005=m
+CONFIG_DVB_USB_AF9005_REMOTE=m
+CONFIG_DVB_USB_DW2102=m
+CONFIG_DVB_USB_CINERGY_T2=m
+CONFIG_DVB_USB_ANYSEE=m
+CONFIG_DVB_USB_DTV5100=m
+CONFIG_DVB_USB_AF9015=m
+CONFIG_DVB_USB_CE6230=m
+CONFIG_DVB_USB_FRIIO=m
+CONFIG_DVB_USB_EC168=m
+CONFIG_DVB_USB_AZ6027=m
+CONFIG_DVB_USB_LME2510=m
+CONFIG_DVB_USB_TECHNISAT_USB2=m
+CONFIG_DVB_TTUSB_BUDGET=m
+CONFIG_DVB_TTUSB_DEC=m
+CONFIG_SMS_SIANO_MDTV=m
+
+#
+# Siano module components
+#
+CONFIG_SMS_USB_DRV=m
+# CONFIG_SMS_SDIO_DRV is not set
+
+#
+# Supported FlexCopII (B2C2) Adapters
+#
+CONFIG_DVB_B2C2_FLEXCOP=m
+# CONFIG_DVB_B2C2_FLEXCOP_PCI is not set
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+# CONFIG_DVB_B2C2_FLEXCOP_DEBUG is not set
+
+#
+# Supported BT878 Adapters
+#
+
+#
+# Supported Pluto2 Adapters
+#
+# CONFIG_DVB_PLUTO2 is not set
+
+#
+# Supported SDMC DM1105 Adapters
+#
+# CONFIG_DVB_DM1105 is not set
+
+#
+# Supported Earthsoft PT1 Adapters
+#
+# CONFIG_DVB_PT1 is not set
+
+#
+# Supported Mantis Adapters
+#
+# CONFIG_MANTIS_CORE is not set
+
+#
+# Supported nGene Adapters
+#
+# CONFIG_DVB_NGENE is not set
+
+#
+# Supported ddbridge ('Octopus') Adapters
+#
+# CONFIG_DVB_DDBRIDGE is not set
+
+#
+# Supported DVB Frontends
+#
+# CONFIG_DVB_FE_CUSTOMISE is not set
+
+#
+# Multistandard (satellite) frontends
+#
+CONFIG_DVB_STB0899=m
+CONFIG_DVB_STB6100=m
+CONFIG_DVB_STV090x=m
+CONFIG_DVB_STV6110x=m
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+CONFIG_DVB_DRXK=m
+CONFIG_DVB_TDA18271C2DD=m
+
+#
+# DVB-S (satellite) frontends
+#
+CONFIG_DVB_CX24123=m
+CONFIG_DVB_MT312=m
+CONFIG_DVB_ZL10039=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_STV0288=m
+CONFIG_DVB_STB6000=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_STV6110=m
+CONFIG_DVB_STV0900=m
+CONFIG_DVB_TDA8083=m
+CONFIG_DVB_TDA10086=m
+CONFIG_DVB_TUNER_ITD1000=m
+CONFIG_DVB_TUNER_CX24113=m
+CONFIG_DVB_TDA826X=m
+CONFIG_DVB_CX24116=m
+CONFIG_DVB_SI21XX=m
+CONFIG_DVB_DS3000=m
+
+#
+# DVB-T (terrestrial) frontends
+#
+CONFIG_DVB_CX22700=m
+CONFIG_DVB_CX22702=m
+CONFIG_DVB_DRXD=m
+CONFIG_DVB_TDA1004X=m
+CONFIG_DVB_NXT6000=m
+CONFIG_DVB_MT352=m
+CONFIG_DVB_ZL10353=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_DIB7000P=m
+CONFIG_DVB_TDA10048=m
+CONFIG_DVB_AF9013=m
+CONFIG_DVB_EC100=m
+CONFIG_DVB_CXD2820R=m
+
+#
+# DVB-C (cable) frontends
+#
+CONFIG_DVB_VES1820=m
+CONFIG_DVB_TDA10023=m
+CONFIG_DVB_STV0297=m
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+CONFIG_DVB_NXT200X=m
+CONFIG_DVB_BCM3510=m
+CONFIG_DVB_LGDT330X=m
+CONFIG_DVB_LGDT3305=m
+CONFIG_DVB_S5H1409=m
+CONFIG_DVB_S5H1411=m
+
+#
+# ISDB-T (terrestrial) frontends
+#
+CONFIG_DVB_S921=m
+CONFIG_DVB_DIB8000=m
+CONFIG_DVB_MB86A20S=m
+
+#
+# Digital terrestrial only tuners/PLL
+#
+CONFIG_DVB_PLL=m
+CONFIG_DVB_TUNER_DIB0070=m
+CONFIG_DVB_TUNER_DIB0090=m
+
+#
+# SEC control devices for DVB-S
+#
+CONFIG_DVB_LNBP21=m
+CONFIG_DVB_ISL6421=m
+CONFIG_DVB_ISL6423=m
+CONFIG_DVB_LGS8GXX=m
+CONFIG_DVB_ATBM8830=m
+CONFIG_DVB_IX2505V=m
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+# CONFIG_DRM is not set
+# CONFIG_STUB_POULSBO is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=m
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=m
+CONFIG_FB_CFB_COPYAREA=m
+CONFIG_FB_CFB_IMAGEBLIT=m
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=m
+CONFIG_FB_SYS_COPYAREA=m
+CONFIG_FB_SYS_IMAGEBLIT=m
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=m
+# CONFIG_FB_WMT_GE_ROPS is not set
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_UDL=m
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=m
+CONFIG_BACKLIGHT_GENERIC=m
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=m
+
+#
+# Display hardware drivers
+#
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=m
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=m
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=m
+CONFIG_SND_TIMER=m
+CONFIG_SND_PCM=m
+CONFIG_SND_HWDEP=m
+CONFIG_SND_RAWMIDI=m
+CONFIG_SND_SEQUENCER=m
+# CONFIG_SND_SEQ_DUMMY is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_SEQUENCER_OSS is not set
+CONFIG_SND_HRTIMER=m
+CONFIG_SND_SEQ_HRTIMER_DEFAULT=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_RAWMIDI_SEQ=m
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_VIRMIDI is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_PCI is not set
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_SND_USB_UA101=m
+CONFIG_SND_USB_CAIAQ=m
+# CONFIG_SND_USB_CAIAQ_INPUT is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=m
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+# CONFIG_HID_PID is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=m
+CONFIG_HID_ACRUX=m
+CONFIG_HID_ACRUX_FF=y
+CONFIG_HID_APPLE=m
+CONFIG_HID_BELKIN=m
+CONFIG_HID_CHERRY=m
+CONFIG_HID_CHICONY=m
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=m
+CONFIG_HID_DRAGONRISE=m
+# CONFIG_DRAGONRISE_FF is not set
+CONFIG_HID_EMS_FF=m
+CONFIG_HID_ELECOM=m
+CONFIG_HID_EZKEY=m
+CONFIG_HID_HOLTEK=m
+CONFIG_HOLTEK_FF=y
+CONFIG_HID_KEYTOUCH=m
+CONFIG_HID_KYE=m
+CONFIG_HID_UCLOGIC=m
+CONFIG_HID_WALTOP=m
+CONFIG_HID_GYRATION=m
+CONFIG_HID_TWINHAN=m
+CONFIG_HID_KENSINGTON=m
+# CONFIG_HID_LCPOWER is not set
+CONFIG_HID_LOGITECH=m
+CONFIG_LOGITECH_FF=y
+CONFIG_LOGIRUMBLEPAD2_FF=y
+CONFIG_LOGIG940_FF=y
+CONFIG_LOGIWII_FF=y
+CONFIG_HID_MAGICMOUSE=m
+CONFIG_HID_MICROSOFT=m
+CONFIG_HID_MONTEREY=m
+CONFIG_HID_MULTITOUCH=m
+CONFIG_HID_NTRIG=m
+CONFIG_HID_ORTEK=m
+CONFIG_HID_PANTHERLORD=m
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=m
+CONFIG_HID_PICOLCD=m
+CONFIG_HID_PICOLCD_FB=y
+CONFIG_HID_PICOLCD_BACKLIGHT=y
+CONFIG_HID_PICOLCD_LCD=y
+CONFIG_HID_PICOLCD_LEDS=y
+CONFIG_HID_QUANTA=m
+CONFIG_HID_ROCCAT=m
+CONFIG_HID_ROCCAT_COMMON=m
+CONFIG_HID_ROCCAT_ARVO=m
+CONFIG_HID_ROCCAT_KONE=m
+CONFIG_HID_ROCCAT_KONEPLUS=m
+CONFIG_HID_ROCCAT_KOVAPLUS=m
+CONFIG_HID_ROCCAT_PYRA=m
+CONFIG_HID_SAMSUNG=m
+CONFIG_HID_SONY=m
+CONFIG_HID_SPEEDLINK=m
+CONFIG_HID_SUNPLUS=m
+CONFIG_HID_GREENASIA=m
+CONFIG_GREENASIA_FF=y
+CONFIG_HID_SMARTJOYPLUS=m
+CONFIG_SMARTJOYPLUS_FF=y
+CONFIG_HID_TOPSEED=m
+CONFIG_HID_THRUSTMASTER=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_HID_WACOM=m
+CONFIG_HID_WACOM_POWER_SUPPLY=y
+CONFIG_HID_WIIMOTE=m
+CONFIG_HID_ZEROPLUS=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_HID_ZYDACRON=m
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_MON is not set
+CONFIG_USB_WUSB=m
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=m
+CONFIG_USB_PRINTER=m
+CONFIG_USB_WDM=m
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+CONFIG_USB_STORAGE_DATAFAB=m
+CONFIG_USB_STORAGE_FREECOM=m
+CONFIG_USB_STORAGE_ISD200=m
+# CONFIG_USB_STORAGE_USBAT is not set
+CONFIG_USB_STORAGE_SDDR09=m
+CONFIG_USB_STORAGE_SDDR55=m
+CONFIG_USB_STORAGE_JUMPSHOT=m
+# CONFIG_USB_STORAGE_ALAUDA is not set
+CONFIG_USB_STORAGE_ONETOUCH=m
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+CONFIG_USB_UAS=m
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+CONFIG_USB_MDC800=m
+CONFIG_USB_MICROTEK=m
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=m
+CONFIG_USB_EZUSB=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_AIRCABLE=m
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_USB_SERIAL_CH341=m
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_USB_SERIAL_IR=m
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_SERIAL_IUU=m
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+# CONFIG_USB_SERIAL_KEYSPAN_MPR is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XA is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA28XB is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19 is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA18X is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19QW is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA19QI is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49W is not set
+# CONFIG_USB_SERIAL_KEYSPAN_USA49WLC is not set
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_USB_SERIAL_MOTOROLA=m
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_USB_SERIAL_OTI6858=m
+CONFIG_USB_SERIAL_QCAUX=m
+CONFIG_USB_SERIAL_QUALCOMM=m
+CONFIG_USB_SERIAL_SPCP8X5=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_SAFE=m
+# CONFIG_USB_SERIAL_SAFE_PADDED is not set
+CONFIG_USB_SERIAL_SIEMENS_MPI=m
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_USB_SERIAL_SYMBOL=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_USB_SERIAL_WWAN=m
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_USB_SERIAL_OPTICON=m
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+CONFIG_USB_SERIAL_DEBUG=m
+
+#
+# USB Miscellaneous drivers
+#
+CONFIG_USB_EMI62=m
+CONFIG_USB_EMI26=m
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+CONFIG_USB_LCD=m
+CONFIG_USB_LED=m
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_SISUSBVGA_CON=y
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_ISIGHTFW=m
+# CONFIG_USB_YUREX is not set
+CONFIG_USB_ATM=m
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_USB_CXACRU=m
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_XUSBATM=m
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_UWB=m
+# CONFIG_UWB_HWA is not set
+# CONFIG_UWB_WHCI is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+CONFIG_SDIO_UART=y
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MMC_MVSDIO=y
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_NS2=y
+CONFIG_LEDS_NETXBIG=y
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_GPIO=m
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+CONFIG_RTC_DRV_PCF8563=m
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+CONFIG_RTC_DRV_S35390A=m
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_MV=y
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_MV_XOR=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+CONFIG_ASYNC_TX_DMA=y
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+CONFIG_STAGING=y
+CONFIG_ET131X=m
+# CONFIG_ET131X_DEBUG is not set
+# CONFIG_VIDEO_GO7007 is not set
+# CONFIG_VIDEO_CX25821 is not set
+CONFIG_VIDEO_TM6000=m
+CONFIG_VIDEO_TM6000_ALSA=m
+CONFIG_VIDEO_TM6000_DVB=m
+# CONFIG_DVB_CXD2099 is not set
+CONFIG_USBIP_CORE=m
+CONFIG_USBIP_VHCI_HCD=m
+CONFIG_USBIP_HOST=m
+# CONFIG_USBIP_DEBUG is not set
+CONFIG_W35UND=m
+CONFIG_PRISM2_USB=m
+# CONFIG_ECHO is not set
+# CONFIG_BRCMUTIL is not set
+CONFIG_ASUS_OLED=m
+CONFIG_R8187SE=m
+CONFIG_RTL8192U=m
+CONFIG_RTL8192E=m
+CONFIG_R8712U=y
+CONFIG_R8712_AP=y
+# CONFIG_RTS_PSTOR is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_IDE_PHISON is not set
+# CONFIG_LINE6_USB is not set
+CONFIG_USB_SERIAL_QUATECH2=m
+CONFIG_USB_SERIAL_QUATECH_USB2=m
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_DX_SEP is not set
+# CONFIG_IIO is not set
+CONFIG_XVMALLOC=y
+CONFIG_ZRAM=m
+# CONFIG_ZRAM_DEBUG is not set
+# CONFIG_FB_SM7XX is not set
+# CONFIG_VIDEO_DT3155 is not set
+# CONFIG_CRYSTALHD is not set
+CONFIG_FB_XGI=m
+CONFIG_LIRC_STAGING=y
+CONFIG_LIRC_BT829=m
+CONFIG_LIRC_IGORPLUGUSB=m
+CONFIG_LIRC_IMON=m
+CONFIG_LIRC_SASEM=m
+CONFIG_LIRC_SERIAL=m
+CONFIG_LIRC_SERIAL_TRANSMITTER=y
+CONFIG_LIRC_SIR=m
+CONFIG_LIRC_TTUSBIR=m
+CONFIG_LIRC_ZILOG=m
+CONFIG_EASYCAP=m
+# CONFIG_EASYCAP_DEBUG is not set
+# CONFIG_SOLO6X10 is not set
+# CONFIG_ATH6K_LEGACY is not set
+# CONFIG_USB_ENESTORAGE is not set
+# CONFIG_BCM_WIMAX is not set
+# CONFIG_FT1000 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_TOUCHSCREEN_CLEARPAD_TM1217 is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI4 is not set
+# CONFIG_ALTERA_STAPL is not set
+CONFIG_CLKSRC_MMIO=y
+CONFIG_IOMMU_SUPPORT=y
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# File systems
+#
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_USE_FOR_EXT23=y
+CONFIG_EXT4_FS_XATTR=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_JFS_FS=m
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_JFS_SECURITY=y
+# CONFIG_JFS_DEBUG is not set
+# CONFIG_JFS_STATISTICS is not set
+CONFIG_XFS_FS=m
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_BTRFS_FS=m
+CONFIG_BTRFS_FS_POSIX_ACL=y
+CONFIG_NILFS2_FS=m
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+CONFIG_QUOTA_TREE=m
+# CONFIG_QFMT_V1 is not set
+CONFIG_QFMT_V2=m
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=m
+CONFIG_FUSE_FS=m
+CONFIG_CUSE=m
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+CONFIG_FSCACHE=y
+# CONFIG_FSCACHE_STATS is not set
+# CONFIG_FSCACHE_HISTOGRAM is not set
+# CONFIG_FSCACHE_DEBUG is not set
+# CONFIG_FSCACHE_OBJECT_LIST is not set
+CONFIG_CACHEFILES=m
+# CONFIG_CACHEFILES_DEBUG is not set
+# CONFIG_CACHEFILES_HISTOGRAM is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=m
+# CONFIG_NTFS_DEBUG is not set
+# CONFIG_NTFS_RW is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+CONFIG_HFS_FS=m
+CONFIG_HFSPLUS_FS=m
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+# CONFIG_UBIFS_FS_ADVANCED_COMPR is not set
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+CONFIG_SQUASHFS=m
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZO=y
+# CONFIG_SQUASHFS_XZ is not set
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+CONFIG_MINIX_FS=m
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+CONFIG_ROMFS_FS=m
+CONFIG_ROMFS_BACKED_BY_BLOCK=y
+# CONFIG_ROMFS_BACKED_BY_MTD is not set
+# CONFIG_ROMFS_BACKED_BY_BOTH is not set
+CONFIG_ROMFS_ON_BLOCK=y
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_AUFS_FS=y
+CONFIG_AUFS_BRANCH_MAX_127=y
+# CONFIG_AUFS_BRANCH_MAX_511 is not set
+# CONFIG_AUFS_BRANCH_MAX_1023 is not set
+# CONFIG_AUFS_BRANCH_MAX_32767 is not set
+CONFIG_AUFS_SBILIST=y
+CONFIG_AUFS_HNOTIFY=y
+CONFIG_AUFS_HFSNOTIFY=y
+# CONFIG_AUFS_EXPORT is not set
+CONFIG_AUFS_RDU=y
+# CONFIG_AUFS_PROC_MAP is not set
+CONFIG_AUFS_SP_IATTR=y
+CONFIG_AUFS_SHWH=y
+CONFIG_AUFS_BR_RAMFS=y
+CONFIG_AUFS_BR_FUSE=y
+CONFIG_AUFS_POLL=y
+# CONFIG_AUFS_BR_HFSPLUS is not set
+CONFIG_AUFS_BDEV_LOOP=y
+# CONFIG_AUFS_DEBUG is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=m
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_PNFS_FILE_LAYOUT=m
+CONFIG_PNFS_BLOCK=m
+CONFIG_ROOT_NFS=y
+CONFIG_NFS_FSCACHE=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFS_USE_NEW_IDMAPPER is not set
+CONFIG_NFSD=m
+CONFIG_NFSD_V2_ACL=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V3_ACL=y
+CONFIG_NFSD_V4=y
+CONFIG_LOCKD=m
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=m
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=m
+CONFIG_SUNRPC_GSS=m
+CONFIG_RPCSEC_GSS_KRB5=m
+# CONFIG_CEPH_FS is not set
+CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
+CONFIG_CIFS_WEAK_PW_HASH=y
+# CONFIG_CIFS_UPCALL is not set
+CONFIG_CIFS_XATTR=y
+CONFIG_CIFS_POSIX=y
+# CONFIG_CIFS_DEBUG2 is not set
+# CONFIG_CIFS_DFS_UPCALL is not set
+CONFIG_CIFS_FSCACHE=y
+# CONFIG_CIFS_ACL is not set
+# CONFIG_NCP_FS is not set
+CONFIG_CODA_FS=m
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+# CONFIG_MINIX_SUBPARTITION is not set
+CONFIG_SOLARIS_X86_PARTITION=y
+# CONFIG_UNIXWARE_DISKLABEL is not set
+CONFIG_LDM_PARTITION=y
+# CONFIG_LDM_DEBUG is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+CONFIG_NLS_CODEPAGE_855=m
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+CONFIG_NLS_CODEPAGE_866=m
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_ISO8859_2=y
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+CONFIG_NLS_ISO8859_5=m
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=120
+# CONFIG_BOOTPARAM_HUNG_TASK_PANIC is not set
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+CONFIG_RCU_CPU_STALL_VERBOSE=y
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_LKDTM is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_EVENT_POWER_TRACING_DEPRECATED=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_RING_BUFFER_ALLOW_SWAP=y
+CONFIG_TRACING=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_FUNCTION_TRACER is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_PREEMPT_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_STACK_TRACER is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+CONFIG_KPROBE_EVENT=y
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+CONFIG_SECURITY_PATH=y
+# CONFIG_SECURITY_SELINUX is not set
+CONFIG_SECURITY_TOMOYO=y
+CONFIG_SECURITY_TOMOYO_MAX_ACCEPT_ENTRY=2048
+CONFIG_SECURITY_TOMOYO_MAX_AUDIT_LOG=1024
+# CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER is not set
+CONFIG_SECURITY_TOMOYO_POLICY_LOADER="/sbin/tomoyo-init"
+CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER="/sbin/init"
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_APPARMOR_BOOTPARAM_VALUE=1
+# CONFIG_IMA is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+# CONFIG_DEFAULT_SECURITY_APPARMOR is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=m
+CONFIG_ASYNC_CORE=m
+CONFIG_ASYNC_MEMCPY=m
+CONFIG_ASYNC_XOR=m
+CONFIG_ASYNC_PQ=m
+CONFIG_ASYNC_RAID6_RECOV=m
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=m
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_CRYPTO_NULL=m
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CRYPTO_CRYPTD=m
+CONFIG_CRYPTO_AUTHENC=m
+CONFIG_CRYPTO_TEST=m
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=m
+CONFIG_CRYPTO_GCM=m
+CONFIG_CRYPTO_SEQIV=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CTR=m
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=m
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_GHASH=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=m
+CONFIG_CRYPTO_SHA256=m
+CONFIG_CRYPTO_SHA512=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_ZLIB=m
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_MV_CESA=m
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=m
+CONFIG_BITREVERSE=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+CONFIG_CRC7=m
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_AUDIT_GENERIC=y
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
diff -ruN a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
--- a/drivers/hwmon/Kconfig	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/hwmon/Kconfig	2013-09-16 01:27:45.827770295 -0600
@@ -1327,6 +1327,19 @@
         help
           Support for the A/D converter on MC13783 PMIC.
 
+config SENSORS_NSA3XX
+	tristate "ZyXEL NSA3xx fan speed and temperature sensors"
+	depends on (MACH_NSA310 || MACH_NSA320) && GENERIC_GPIO
+	help
+	  If you say yes here you get support for hardware monitoring
+	  for the ZyXEL NSA3xx Media Servers.
+
+	  The sensor data is taken from a Holtek HT46R065 microcontroller
+	  conncted to GPIO lines.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called nsa3xx-hwmon.
+
 if ACPI
 
 comment "ACPI drivers"
diff -ruN a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
--- a/drivers/hwmon/Makefile	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/hwmon/Makefile	2013-09-16 01:27:45.837770178 -0600
@@ -93,6 +93,7 @@
 obj-$(CONFIG_SENSORS_MAX6642)	+= max6642.o
 obj-$(CONFIG_SENSORS_MAX6650)	+= max6650.o
 obj-$(CONFIG_SENSORS_MC13783_ADC)+= mc13783-adc.o
+obj-$(CONFIG_SENSORS_NSA3XX)	+= nsa3xx-hwmon.o
 obj-$(CONFIG_SENSORS_NTC_THERMISTOR)	+= ntc_thermistor.o
 obj-$(CONFIG_SENSORS_PC87360)	+= pc87360.o
 obj-$(CONFIG_SENSORS_PC87427)	+= pc87427.o
diff -ruN a/drivers/hwmon/nsa3xx-hwmon.c b/drivers/hwmon/nsa3xx-hwmon.c
--- a/drivers/hwmon/nsa3xx-hwmon.c	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/hwmon/nsa3xx-hwmon.c	2013-09-16 01:27:45.837770178 -0600
@@ -0,0 +1,251 @@
+/*
+ * drivers/hwmon/nsa3xx-hwmon.c
+ *
+ * ZyXEL NSA3xx Media Servers
+ * hardware monitoring
+ *
+ * Copyright (C) 2012 Peter Schildmann <linux@schildmann.info>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License v2 as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
+ */
+
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/nsa3xx-hwmon.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+#include <asm/delay.h>
+
+#define MAGIC_NUMBER 0x55
+
+struct nsa3xx_hwmon {
+	struct platform_device	*pdev;
+	struct device		*classdev;
+	struct mutex		update_lock;	/* lock GPIO operations */
+	unsigned long		last_updated;	/* jiffies */
+	unsigned long		mcu_data;
+};
+
+enum nsa3xx_inputs {
+	NSA3XX_FAN = 1,
+	NSA3XX_TEMP = 0,
+};
+
+static const char *nsa3xx_input_names[] = {
+	[NSA3XX_FAN] = "Chassis Fan",
+	[NSA3XX_TEMP] = "System Temperature",
+};
+
+static unsigned long nsa3xx_hwmon_update(struct device *dev)
+{
+	int i;
+	unsigned long mcu_data;
+	struct nsa3xx_hwmon *hwmon = dev_get_drvdata(dev);
+	struct nsa3xx_hwmon_platform_data *pdata = hwmon->pdev->dev.platform_data;
+
+	mutex_lock(&hwmon->update_lock);
+
+	mcu_data = hwmon->mcu_data;
+
+	if (time_after(jiffies, hwmon->last_updated + (3 * HZ)) || mcu_data == 0) {
+		dev_dbg(dev, "Reading MCU data\n");
+
+		gpio_set_value(pdata->act_pin, 0);
+		msleep(100);
+
+		for (i = 31; i >= 0; i--) {
+			gpio_set_value(pdata->clk_pin, 0);
+			udelay(100);
+
+			gpio_set_value(pdata->clk_pin, 1);
+			udelay(100);
+
+			mcu_data |= gpio_get_value(pdata->data_pin) ? (1 << i) : 0;
+		}
+
+		gpio_set_value(pdata->act_pin, 1);
+
+		if ((mcu_data & 0xff000000) != (MAGIC_NUMBER << 24)) {
+			dev_err(dev, "Failed to read MCU data\n");
+			mcu_data = 0;
+		}
+
+		hwmon->mcu_data = mcu_data;
+		hwmon->last_updated = jiffies;
+	}
+
+	mutex_unlock(&hwmon->update_lock);
+
+	return mcu_data;
+}
+
+static ssize_t show_name(struct device *dev,
+			 struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "nsa3xx\n");
+}
+
+static ssize_t show_label(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	return sprintf(buf, "%s\n", nsa3xx_input_names[channel]);
+}
+
+static ssize_t show_value(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	int channel = to_sensor_dev_attr(attr)->index;
+	unsigned long mcu_data = nsa3xx_hwmon_update(dev);
+	unsigned long value = 0;
+	switch(channel) {
+	case NSA3XX_TEMP:
+		value = (mcu_data & 0xffff) * 100;
+		break;
+	case NSA3XX_FAN:
+		value = ((mcu_data & 0xff0000) >> 16) * 100;
+		break;
+	}
+	return sprintf(buf, "%lu\n", value);
+}
+
+static DEVICE_ATTR(name, S_IRUGO, show_name, NULL);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_label, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_value, NULL, NSA3XX_TEMP);
+static SENSOR_DEVICE_ATTR(fan1_label, S_IRUGO, show_label, NULL, NSA3XX_FAN);
+static SENSOR_DEVICE_ATTR(fan1_input, S_IRUGO, show_value, NULL, NSA3XX_FAN);
+
+static struct attribute *nsa3xx_attributes[] = {
+	&dev_attr_name.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_fan1_label.dev_attr.attr,
+	&sensor_dev_attr_fan1_input.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group nsa3xx_attr_group = {
+	.attrs	= nsa3xx_attributes,
+};
+
+static int nsa3xx_hwmon_request_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	int ret;
+
+	if ((ret = gpio_request(pdata->act_pin, "act pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->clk_pin, "clk pin")))
+		return ret;
+
+	if ((ret = gpio_request(pdata->data_pin, "data pin")))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->act_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_output(pdata->clk_pin, 1)))
+		return ret;
+
+	if ((ret = gpio_direction_input(pdata->data_pin)))
+		return ret;
+
+	return 0;
+}
+
+static void nsa3xx_hwmon_free_gpios(struct nsa3xx_hwmon_platform_data *pdata)
+{
+	gpio_free(pdata->act_pin);
+	gpio_free(pdata->clk_pin);
+	gpio_free(pdata->data_pin);
+}
+
+static int __devinit nsa3xx_hwmon_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct nsa3xx_hwmon *hwmon;
+	struct nsa3xx_hwmon_platform_data *pdata = pdev->dev.platform_data;
+
+	hwmon = kzalloc(sizeof(struct nsa3xx_hwmon), GFP_KERNEL);
+	if (!hwmon)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, hwmon);
+	hwmon->pdev = pdev;
+	hwmon->mcu_data = 0;
+	mutex_init(&hwmon->update_lock);
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	if (ret)
+		goto err;
+
+	hwmon->classdev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(hwmon->classdev)) {
+		ret = PTR_ERR(hwmon->classdev);
+		goto err_sysfs;
+	}
+
+	ret = nsa3xx_hwmon_request_gpios(pdata);
+	if (ret)
+		goto err_free_gpio;
+
+	dev_info(&pdev->dev, "initialized\n");
+
+	return 0;
+
+err_free_gpio:
+	nsa3xx_hwmon_free_gpios(pdata);
+	hwmon_device_unregister(hwmon->classdev);
+err_sysfs:
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+err:
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+	return ret;
+}
+
+static int __devexit nsa3xx_hwmon_remove(struct platform_device *pdev)
+{
+	struct nsa3xx_hwmon *hwmon = platform_get_drvdata(pdev);
+
+	nsa3xx_hwmon_free_gpios(pdev->dev.platform_data);
+	hwmon_device_unregister(hwmon->classdev);
+	sysfs_remove_group(&pdev->dev.kobj, &nsa3xx_attr_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(hwmon);
+
+	return 0;
+}
+
+static struct platform_driver nsa3xx_hwmon_driver = {
+	.probe = nsa3xx_hwmon_probe,
+	.remove = __devexit_p(nsa3xx_hwmon_remove),
+	.driver = {
+		.name = "nsa3xx-hwmon",
+		.owner = THIS_MODULE,
+	},
+};
+
+module_platform_driver(nsa3xx_hwmon_driver);
+
+MODULE_AUTHOR("Peter Schildmann <linux@schildmann.info>");
+MODULE_DESCRIPTION("NSA3XX Hardware Monitoring");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:nsa3xx-hwmon");
diff -ruN a/drivers/leds/Kconfig b/drivers/leds/Kconfig
--- a/drivers/leds/Kconfig	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/leds/Kconfig	2013-09-16 01:27:45.847770057 -0600
@@ -406,7 +406,6 @@
 
 config LEDS_TRIGGER_IDE_DISK
 	bool "LED IDE Disk Trigger"
-	depends on IDE_GD_ATA
 	depends on LEDS_TRIGGERS
 	help
 	  This allows LEDs to be controlled by IDE disk activity.
diff -ruN a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
--- a/drivers/mmc/core/core.c	2013-09-16 01:25:16.699675815 -0600
+++ b/drivers/mmc/core/core.c	2013-09-16 01:27:45.867769801 -0600
@@ -399,9 +399,9 @@
 			 * The limit is really 250 ms, but that is
 			 * insufficient for some crappy cards.
 			 */
-			limit_us = 300000;
+			limit_us = 500000;
 		else
-			limit_us = 100000;
+			limit_us = 200000;
 
 		/*
 		 * SDHC cards always use these fixed values.
diff -ruN a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c
--- a/drivers/mmc/core/sd.c	2013-09-16 01:25:16.709675688 -0600
+++ b/drivers/mmc/core/sd.c	2013-09-16 01:27:45.867769801 -0600
@@ -388,6 +388,15 @@
 		return -ENOMEM;
 	}
 
+	/*
+	 * Some SDHC cards, notably those with a Sandisk SD controller
+	 * (also found in Kingston products) need a bit of slack
+	 * before successfully handling the SWITCH command.  So far,
+	 * cards identifying themselves as "SD04G" and "SD08G" are
+	 * affected
+	 */
+	udelay(100);
+
 	err = mmc_sd_switch(card, 1, 0, 1, status);
 	if (err)
 		goto out;
diff -ruN a/drivers/mmc/host/mvsdio.c b/drivers/mmc/host/mvsdio.c
--- a/drivers/mmc/host/mvsdio.c	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/mmc/host/mvsdio.c	2013-09-16 01:27:45.867769801 -0600
@@ -21,6 +21,7 @@
 #include <linux/irq.h>
 #include <linux/gpio.h>
 #include <linux/mmc/host.h>
+#include <linux/mmc/sd.h>
 
 #include <asm/sizes.h>
 #include <asm/unaligned.h>
@@ -148,6 +149,7 @@
 
 	dev_dbg(host->dev, "cmd %d (hw state 0x%04x)\n",
 		cmd->opcode, mvsd_read(MVSD_HW_STATE));
+	if (cmd->opcode == SD_SWITCH) mdelay(1); /* Voodoo */
 
 	cmdreg = MVSD_CMD_INDEX(cmd->opcode);
 
diff -ruN a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
--- a/drivers/net/wireless/Kconfig	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/net/wireless/Kconfig	2013-09-16 01:27:45.887769541 -0600
@@ -51,6 +51,12 @@
 	---help---
 	  A driver for Marvell Libertas 8388 USB devices using thinfirm.
 
+config LIBERTAS_UAP
+	tristate "Marvell Libertas 8688 micro-AP support"
+	depends on LIBERTAS && MMC
+	---help---
+	  A driver for Marvell Libertas 8688 SDIO micro-AP support.
+
 config AIRO
 	tristate "Cisco/Aironet 34X/35X/4500/4800 ISA and PCI cards"
 	depends on ISA_DMA_API && (PCI || BROKEN)
diff -ruN a/drivers/net/wireless/libertas/Kconfig b/drivers/net/wireless/libertas/Kconfig
--- a/drivers/net/wireless/libertas/Kconfig	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/net/wireless/libertas/Kconfig	2013-09-16 01:27:45.887769541 -0600
@@ -3,6 +3,7 @@
 	depends on CFG80211
 	select WIRELESS_EXT
 	select WEXT_SPY
+	select WEXT_PRIV
 	select LIB80211
 	select FW_LOADER
 	---help---
diff -ruN a/drivers/net/wireless/libertas_uap/Makefile b/drivers/net/wireless/libertas_uap/Makefile
--- a/drivers/net/wireless/libertas_uap/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/Makefile	2013-09-16 01:27:45.887769541 -0600
@@ -0,0 +1,6 @@
+obj-$(CONFIG_LIBERTAS_UAP) += uap8xxx.o
+
+uap8xxx-y += uap_main.o uap_sdio_mmc.o
+uap8xxx-$(CONFIG_PROC_FS) += uap_proc.o uap_debug.o
+
+EXTRA_CFLAGS += -DFPNUM='"52"' -DPXA3XX_DMA_ALIGN -DDEBUG_LEVEL1
diff -ruN a/drivers/net/wireless/libertas_uap/uap_debug.c b/drivers/net/wireless/libertas_uap/uap_debug.c
--- a/drivers/net/wireless/libertas_uap/uap_debug.c	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_debug.c	2013-09-16 01:27:45.897769412 -0600
@@ -0,0 +1,261 @@
+/** @file uap_debug.c
+  * @brief This file contains functions for debug proc file.
+  *
+  * Copyright (C) 2008-2009, Marvell International Ltd.
+  *
+  * This software file (the "File") is distributed by Marvell International
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+  * (the "License").  You may use, redistribute and/or modify this File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available along with the File in the gpl.txt file or by writing to
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+#ifdef CONFIG_PROC_FS
+#include  "uap_headers.h"
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+#define item_size(n) (sizeof ((uap_adapter *)0)->n)
+#define item_addr(n) ((u32) &((uap_adapter *)0)->n)
+
+#define item_dbg_size(n) (sizeof (((uap_adapter *)0)->dbg.n))
+#define item_dbg_addr(n) ((u32) &(((uap_adapter *)0)->dbg.n))
+
+#define item_dev_size(n) (sizeof ((uap_dev_t *)0)->n)
+#define item_dev_addr(n) ((u32) &((uap_dev_t *)0)->n)
+
+/** MicroAp device offset */
+#define OFFSET_UAP_DEV		0x01
+/** Bluetooth adapter offset */
+#define OFFSET_UAP_ADAPTER	0x02
+
+struct debug_data
+{
+    /** Name */
+    char name[32];
+    /** Size */
+    u32 size;
+    /** Address */
+    u32 addr;
+    /** Offset */
+    u32 offset;
+    /** Flag */
+    u32 flag;
+};
+
+/* To debug any member of uap_adapter, simply add one line here.
+ */
+static struct debug_data items[] = {
+    {"cmd_sent", item_dev_size(cmd_sent), 0, item_dev_addr(cmd_sent),
+     OFFSET_UAP_DEV},
+    {"data_sent", item_dev_size(data_sent), 0, item_dev_addr(data_sent),
+     OFFSET_UAP_DEV},
+    {"IntCounter", item_size(IntCounter), 0, item_addr(IntCounter),
+     OFFSET_UAP_ADAPTER},
+    {"cmd_pending", item_size(cmd_pending), 0, item_addr(cmd_pending),
+     OFFSET_UAP_ADAPTER},
+    {"num_cmd_h2c_fail", item_dbg_size(num_cmd_host_to_card_failure), 0,
+     item_dbg_addr(num_cmd_host_to_card_failure), OFFSET_UAP_ADAPTER},
+    {"num_tx_h2c_fail", item_dbg_size(num_tx_host_to_card_failure), 0,
+     item_dbg_addr(num_tx_host_to_card_failure), OFFSET_UAP_ADAPTER},
+    {"psmode", item_size(psmode), 0, item_addr(psmode), OFFSET_UAP_ADAPTER},
+    {"ps_state", item_size(ps_state), 0, item_addr(ps_state),
+     OFFSET_UAP_ADAPTER},
+#ifdef DEBUG_LEVEL1
+    {"drvdbg", sizeof(drvdbg), (u32) & drvdbg, 0, 0}
+#endif
+};
+
+static int num_of_items = sizeof(items) / sizeof(items[0]);
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+/**
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param s       read data starting position
+ *  @param off     offset
+ *  @param cnt     counter
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+uap_debug_read(char *page, char **s, off_t off, int cnt, int *eof, void *data)
+{
+    int val = 0;
+    char *p = page;
+    int i;
+
+    struct debug_data *d = (struct debug_data *) data;
+
+    if (MODULE_GET == 0)
+        return UAP_STATUS_FAILURE;
+
+    for (i = 0; i < num_of_items; i++) {
+        if (d[i].size == 1)
+            val = *((u8 *) d[i].addr);
+        else if (d[i].size == 2)
+            val = *((u16 *) d[i].addr);
+        else if (d[i].size == 4)
+            val = *((u32 *) d[i].addr);
+
+        p += sprintf(p, "%s=%d\n", d[i].name, val);
+    }
+    MODULE_PUT;
+    return p - page;
+}
+
+/**
+ *  @brief proc write function
+ *
+ *  @param f	   file pointer
+ *  @param buf     pointer to data buffer
+ *  @param cnt     data number to write
+ *  @param data    data to write
+ *  @return 	   number of data
+ */
+static int
+uap_debug_write(struct file *f, const char *buf, unsigned long cnt, void *data)
+{
+    int r, i;
+    char *pdata;
+    char *p;
+    char *p0;
+    char *p1;
+    char *p2;
+    struct debug_data *d = (struct debug_data *) data;
+
+    if (MODULE_GET == 0)
+        return UAP_STATUS_FAILURE;
+
+    pdata = (char *) kmalloc(cnt, GFP_KERNEL);
+    if (pdata == NULL) {
+        MODULE_PUT;
+        return 0;
+    }
+
+    if (copy_from_user(pdata, buf, cnt)) {
+        PRINTM(INFO, "Copy from user failed\n");
+        kfree(pdata);
+        MODULE_PUT;
+        return 0;
+    }
+
+    p0 = pdata;
+    for (i = 0; i < num_of_items; i++) {
+        do {
+            p = strstr(p0, d[i].name);
+            if (p == NULL)
+                break;
+            p1 = strchr(p, '\n');
+            if (p1 == NULL)
+                break;
+            p0 = p1++;
+            p2 = strchr(p, '=');
+            if (!p2)
+                break;
+            p2++;
+            r = string_to_number(p2);
+            if (d[i].size == 1)
+                *((u8 *) d[i].addr) = (u8) r;
+            else if (d[i].size == 2)
+                *((u16 *) d[i].addr) = (u16) r;
+            else if (d[i].size == 4)
+                *((u32 *) d[i].addr) = (u32) r;
+            break;
+        } while (TRUE);
+    }
+    kfree(pdata);
+#ifdef DEBUG_LEVEL1
+    printk(KERN_ALERT "drvdbg = 0x%x\n", drvdbg);
+    printk(KERN_ALERT "INFO  (%08lx) %s\n", DBG_INFO,
+           (drvdbg & DBG_INFO) ? "X" : "");
+    printk(KERN_ALERT "WARN  (%08lx) %s\n", DBG_WARN,
+           (drvdbg & DBG_WARN) ? "X" : "");
+    printk(KERN_ALERT "ENTRY (%08lx) %s\n", DBG_ENTRY,
+           (drvdbg & DBG_ENTRY) ? "X" : "");
+    printk(KERN_ALERT "CMD_D (%08lx) %s\n", DBG_CMD_D,
+           (drvdbg & DBG_CMD_D) ? "X" : "");
+    printk(KERN_ALERT "DAT_D (%08lx) %s\n", DBG_DAT_D,
+           (drvdbg & DBG_DAT_D) ? "X" : "");
+    printk(KERN_ALERT "CMND  (%08lx) %s\n", DBG_CMND,
+           (drvdbg & DBG_CMND) ? "X" : "");
+    printk(KERN_ALERT "DATA  (%08lx) %s\n", DBG_DATA,
+           (drvdbg & DBG_DATA) ? "X" : "");
+    printk(KERN_ALERT "ERROR (%08lx) %s\n", DBG_ERROR,
+           (drvdbg & DBG_ERROR) ? "X" : "");
+    printk(KERN_ALERT "FATAL (%08lx) %s\n", DBG_FATAL,
+           (drvdbg & DBG_FATAL) ? "X" : "");
+    printk(KERN_ALERT "MSG   (%08lx) %s\n", DBG_MSG,
+           (drvdbg & DBG_MSG) ? "X" : "");
+#endif
+    MODULE_PUT;
+    return cnt;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/**
+ *  @brief create debug proc file
+ *
+ *  @param priv	   pointer uap_private
+ *  @param dev     pointer net_device
+ *  @return 	   N/A
+ */
+void
+uap_debug_entry(uap_private * priv, struct net_device *dev)
+{
+    int i;
+    struct proc_dir_entry *r;
+
+    if (priv->proc_entry == NULL)
+        return;
+
+    for (i = 0; i < num_of_items; i++) {
+        if (items[i].flag & OFFSET_UAP_ADAPTER)
+            items[i].addr = items[i].offset + (u32) priv->adapter;
+        if (items[i].flag & OFFSET_UAP_DEV)
+            items[i].addr = items[i].offset + (u32) & priv->uap_dev;
+    }
+    r = create_proc_entry("debug", 0644, priv->proc_entry);
+    if (r == NULL)
+        return;
+
+    r->data = &items[0];
+    r->read_proc = uap_debug_read;
+    r->write_proc = uap_debug_write;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+    r->owner = THIS_MODULE;
+#endif
+}
+
+/**
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer uap_private
+ *  @return 	   N/A
+ */
+void
+uap_debug_remove(uap_private * priv)
+{
+    remove_proc_entry("debug", priv->proc_entry);
+}
+
+#endif
diff -ruN a/drivers/net/wireless/libertas_uap/uap_drv.h b/drivers/net/wireless/libertas_uap/uap_drv.h
--- a/drivers/net/wireless/libertas_uap/uap_drv.h	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_drv.h	2013-09-16 01:27:45.897769412 -0600
@@ -0,0 +1,667 @@
+/** @file uap_drv.h
+  * @brief This file contains Linux OS related definitions and
+  * declarations, uAP driver
+  *
+  * Copyright (C) 2008-2009, Marvell International Ltd.
+  *
+  * This software file (the "File") is distributed by Marvell International
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+  * (the "License").  You may use, redistribute and/or modify this File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available along with the File in the gpl.txt file or by writing to
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+
+#ifndef _UAP_DRV_H
+#define _UAP_DRV_H
+
+/** Driver release version */
+#define DRIVER_VERSION		"26146"
+
+/** True */
+#ifndef	TRUE
+#define TRUE			1
+#endif
+/** False */
+#ifndef	FALSE
+#define	FALSE			0
+#endif
+
+/** Bit definitions */
+#ifndef BIT
+#define BIT(x)	(1UL << (x))
+#endif
+
+/** Dma addresses are 32-bits wide.  */
+#ifndef __ATTRIB_ALIGN__
+#define __ATTRIB_ALIGN__ __attribute__((aligned(4)))
+#endif
+
+/**  attribute pack */
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__ ((packed))
+#endif
+
+/** Debug Macro definition*/
+#ifdef	DEBUG_LEVEL1
+
+extern u32 drvdbg;
+
+/** Debug message control bit definition for drvdbg */
+/** Debug message */
+#define	DBG_MSG		BIT(0)
+/** Debug fatal message */
+#define DBG_FATAL	BIT(1)
+/** Debug error message */
+#define DBG_ERROR	BIT(2)
+/** Debug data message */
+#define DBG_DATA	BIT(3)
+/** Debug command message */
+#define DBG_CMND	BIT(4)
+
+/** Debug data */
+#define DBG_DAT_D	BIT(16)
+/** Debug command */
+#define DBG_CMD_D	BIT(17)
+
+/** Debug entry */
+#define DBG_ENTRY	BIT(28)
+/** Debug warning */
+#define DBG_WARN	BIT(29)
+/** Debug info */
+#define DBG_INFO	BIT(30)
+
+/** Print info */
+#define	PRINTM_INFO(msg...)  {if (drvdbg & DBG_INFO) printk(KERN_DEBUG msg);}
+/** Print warn message */
+#define	PRINTM_WARN(msg...)  {if (drvdbg & DBG_WARN) printk(KERN_DEBUG msg);}
+/** Print entry */
+#define	PRINTM_ENTRY(msg...) {if (drvdbg & DBG_ENTRY) printk(KERN_DEBUG msg);}
+/** Print cmd_d */
+#define	PRINTM_CMD_D(msg...) {if (drvdbg & DBG_CMD_D) printk(KERN_DEBUG msg);}
+/** Print data_d */
+#define	PRINTM_DAT_D(msg...) {if (drvdbg & DBG_DAT_D) printk(KERN_DEBUG msg);}
+/** Print command */
+#define	PRINTM_CMND(msg...)  {if (drvdbg & DBG_CMND) printk(KERN_DEBUG msg);}
+/** Print data */
+#define	PRINTM_DATA(msg...)  {if (drvdbg & DBG_DATA) printk(KERN_DEBUG msg);}
+/** Print error message */
+#define	PRINTM_ERROR(msg...) {if (drvdbg & DBG_ERROR) printk(KERN_DEBUG msg);}
+/** Print fatal message */
+#define	PRINTM_FATAL(msg...) {if (drvdbg & DBG_FATAL) printk(KERN_DEBUG msg);}
+/** Print message */
+#define	PRINTM_MSG(msg...)   {if (drvdbg & DBG_MSG) printk(KERN_ALERT msg);}
+/** Print level */
+#define	PRINTM(level,msg...) PRINTM_##level(msg)
+
+#else
+
+#define	PRINTM(level,msg...) do {} while (0)
+
+#endif /* DEBUG_LEVEL1 */
+
+/** Wait until a condition becomes true */
+#define ASSERT(cond)						\
+do {								\
+	if (!(cond))						\
+		PRINTM(INFO, "ASSERT: %s, %s:%i\n",		\
+		       __FUNCTION__, __FILE__, __LINE__);	\
+} while(0)
+
+/** Log enrty point for debugging */
+#define	ENTER()			PRINTM(ENTRY, "Enter: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+/** Log exit point for debugging */
+#define	LEAVE()			PRINTM(ENTRY, "Leave: %s, %s:%i\n", __FUNCTION__, \
+							__FILE__, __LINE__)
+
+#ifdef	DEBUG_LEVEL1
+/** Dump buffer length */
+#define DBG_DUMP_BUF_LEN    64
+/** Maximum dump per line */
+#define MAX_DUMP_PER_LINE   16
+/** Data dump length */
+#define DATA_DUMP_LEN       32
+
+static inline void
+hexdump(char *prompt, u8 * buf, int len)
+{
+    int i;
+    char dbgdumpbuf[DBG_DUMP_BUF_LEN];
+    char *ptr = dbgdumpbuf;
+
+    printk(KERN_DEBUG "%s:\n", prompt);
+    for (i = 1; i <= len; i++) {
+        ptr += sprintf(ptr, "%02x ", *buf);
+        buf++;
+        if (i % MAX_DUMP_PER_LINE == 0) {
+            *ptr = 0;
+            printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+            ptr = dbgdumpbuf;
+        }
+    }
+    if (len % MAX_DUMP_PER_LINE) {
+        *ptr = 0;
+        printk(KERN_DEBUG "%s\n", dbgdumpbuf);
+    }
+}
+
+/** Debug command */
+#define DBG_HEXDUMP_CMD_D(x,y,z)    {if (drvdbg & DBG_CMD_D) hexdump(x,y,z);}
+/** Debug data */
+#define DBG_HEXDUMP_DAT_D(x,y,z)    {if (drvdbg & DBG_DAT_D) hexdump(x,y,z);}
+/** Debug hexdump */
+#define	DBG_HEXDUMP(level,x,y,z)    DBG_HEXDUMP_##level(x,y,z)
+/** hexdump */
+#define HEXDUMP(x,y,z)              {if (drvdbg & DBG_INFO) hexdump(x,y,z);}
+#else
+/** Do nothing since debugging is not turned on */
+#define DBG_HEXDUMP(level,x,y,z)    do {} while (0)
+/** Do nothing since debugging is not turned on */
+#define HEXDUMP(x,y,z)              do {} while (0)
+#endif
+
+/**
+ * Typedefs
+ */
+/** Unsigned char */
+typedef u8 BOOLEAN;
+
+/*
+ * OS macro definitions
+ */
+/** OS macro to get time */
+#define os_time_get()	jiffies
+
+/** OS macro to update transfer start time */
+#define UpdateTransStart(dev) { \
+	dev->trans_start = jiffies; \
+}
+
+/** Try to get a reference to the module */
+#define MODULE_GET	try_module_get(THIS_MODULE)
+/** Decrease module reference count */
+#define MODULE_PUT	module_put(THIS_MODULE)
+
+/** OS macro to initialize semaphore */
+#define OS_INIT_SEMAPHORE(x)	sema_init(x,1)
+/** OS macro to acquire blocking semaphore */
+#define OS_ACQ_SEMAPHORE_BLOCK(x)	down_interruptible(x)
+/** OS macro to acquire non-blocking semaphore */
+#define OS_ACQ_SEMAPHORE_NOBLOCK(x)	down_trylock(x)
+/** OS macro to release semaphore */
+#define OS_REL_SEMAPHORE(x)		up(x)
+
+static inline void
+os_sched_timeout(u32 millisec)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+    schedule_timeout((millisec * HZ) / 1000);
+}
+
+/** Maximum size of ethernet packet */
+#define MRVDRV_MAXIMUM_ETH_PACKET_SIZE	1514
+
+/** Maximum size of multicast list */
+#define MRVDRV_MAX_MULTICAST_LIST_SIZE	32
+
+/** Find minimum */
+#ifndef MIN
+#define MIN(a,b)		((a) < (b) ? (a) : (b))
+#endif
+
+/** Find maximum */
+#ifndef MAX
+#define MAX(a,b)		((a) > (b) ? (a) : (b))
+#endif
+
+/** Find number of elements */
+#ifndef NELEMENTS
+#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))
+#endif
+
+/** Buffer Constants */
+
+/** Size of command buffer */
+#define MRVDRV_SIZE_OF_CMD_BUFFER       (2 * 1024)
+
+/** Length of device length */
+#define DEV_NAME_LEN			32
+
+/** Length of ethernet address */
+#ifndef	ETH_ALEN
+#define ETH_ALEN			6
+#endif
+
+/** Default watchdog timeout */
+#define MRVDRV_DEFAULT_WATCHDOG_TIMEOUT (2 * HZ)
+
+/** Success */
+#define UAP_STATUS_SUCCESS         (0)
+/** Failure */
+#define UAP_STATUS_FAILURE         (-1)
+/** Not accepted */
+#define UAP_STATUS_NOT_ACCEPTED    (-2)
+
+/** Max loop count (* 100ms) for waiting device ready at init time */
+#define MAX_WAIT_DEVICE_READY_COUNT	50
+
+/** Tx high watermark. Stop Tx queue after this is crossed */
+#define TX_HIGH_WATERMARK   4
+/** Tx low watermark. Restart Tx queue after this is crossed */
+#define TX_LOW_WATERMARK    2
+
+/** Netlink protocol number */
+#define NETLINK_MARVELL     (MAX_LINKS - 1)
+/** Netlink maximum payload size */
+#define NL_MAX_PAYLOAD      1024
+/** Netlink multicast group number */
+#define NL_MULTICAST_GROUP  1
+
+/** 20 seconds */
+#define MRVDRV_TIMER_20S		20000
+
+/** Host Command option for wait till Send */
+#define HostCmd_OPTION_WAITFORSEND            0x0001
+/** Host Command option for wait for RSP */
+#define HostCmd_OPTION_WAITFORRSP             0x0002
+/** Host Command option for wait for RSP or Timeout */
+#define HostCmd_OPTION_WAITFORRSP_TIMEOUT     0x0003
+/** Host Command option for wait for RSP of sleep confirm */
+#define HostCmd_OPTION_WAITFORRSP_SLEEPCONFIRM   0x0004
+
+/** Sleep until a condition gets true or a timeout elapses */
+#define os_wait_interruptible_timeout(waitq, cond, timeout) \
+	wait_event_interruptible_timeout(waitq, cond, ((timeout) * HZ / 1000))
+
+/** Private command ID to Host command */
+#define	UAPHOSTCMD			(SIOCDEVPRIVATE + 1)
+
+/** Private command ID to Power Mode */
+#define	UAP_POWER_MODE			(SIOCDEVPRIVATE + 3)
+/** sleep_param */
+typedef struct _ps_sleep_param
+{
+    /** control bitmap */
+    u32 ctrl_bitmap;
+    /** minimum sleep period (micro second) */
+    u32 min_sleep;
+    /** maximum sleep period (micro second) */
+    u32 max_sleep;
+} ps_sleep_param;
+
+/** inactivity sleep_param */
+typedef struct _inact_sleep_param
+{
+    /** inactivity timeout (micro second) */
+    u32 inactivity_to;
+    /** miniumu awake period (micro second) */
+    u32 min_awake;
+    /** maximum awake period (micro second) */
+    u32 max_awake;
+} inact_sleep_param;
+
+/** flag for ps mode */
+#define PS_FLAG_PS_MODE                 1
+/** flag for sleep param */
+#define PS_FLAG_SLEEP_PARAM             2
+/** flag for inactivity sleep param */
+#define PS_FLAG_INACT_SLEEP_PARAM       4
+
+/** Disable power mode */
+#define PS_MODE_DISABLE                      0
+/** Enable periodic dtim ps */
+#define PS_MODE_PERIODIC_DTIM                1
+/** Enable inactivity ps */
+#define PS_MODE_INACTIVITY                   2
+
+/** sleep parameter */
+#define SLEEP_PARAMETER                     1
+/** inactivity sleep parameter */
+#define INACTIVITY_SLEEP_PARAMETER          2
+/** ps_mgmt */
+typedef struct _ps_mgmt
+{
+    /** flags for valid field */
+    u16 flags;
+    /** power mode */
+    u16 ps_mode;
+    /** sleep param */
+    ps_sleep_param sleep_param;
+    /** inactivity sleep param */
+    inact_sleep_param inact_param;
+} ps_mgmt;
+
+/** Semaphore structure */
+typedef struct semaphore SEMAPHORE;
+
+/** Global Varibale Declaration */
+/** Private data structure of the device */
+typedef struct _uap_private uap_private;
+/** Adapter data structure of the device */
+typedef struct _uap_adapter uap_adapter;
+/** private structure */
+extern uap_private *uappriv;
+
+/** ENUM definition*/
+
+/** Hardware status codes */
+typedef enum _HARDWARE_STATUS
+{
+    HWReady,
+    HWInitializing,
+    HWReset,
+    HWClosing,
+    HWNotReady
+} HARDWARE_STATUS;
+
+/** info for debug purpose */
+typedef struct _uap_dbg
+{
+        /** Number of host to card command failures */
+    u32 num_cmd_host_to_card_failure;
+        /** Number of host to card Tx failures */
+    u32 num_tx_host_to_card_failure;
+} uap_dbg;
+
+/** Set thread state */
+#define OS_SET_THREAD_STATE(x)		set_current_state(x)
+
+typedef struct
+{
+    /** Task */
+    struct task_struct *task;
+    /** Queue */
+    wait_queue_head_t waitQ;
+    /** PID */
+    pid_t pid;
+    /** Private structure */
+    void *priv;
+} uap_thread;
+
+static inline void
+uap_activate_thread(uap_thread * thr)
+{
+        /** Record the thread pid */
+    thr->pid = current->pid;
+
+        /** Initialize the wait queue */
+    init_waitqueue_head(&thr->waitQ);
+}
+
+static inline void
+uap_deactivate_thread(uap_thread * thr)
+{
+    thr->pid = 0;
+    return;
+}
+
+static inline void
+uap_create_thread(int (*uapfunc) (void *), uap_thread * thr, char *name)
+{
+    thr->task = kthread_run(uapfunc, thr, "%s", name);
+}
+
+static inline int
+uap_terminate_thread(uap_thread * thr)
+{
+    /* Check if the thread is active or not */
+    if (!thr->pid)
+        return -1;
+    kthread_stop(thr->task);
+    return 0;
+}
+
+/** Data structure for the Marvell uAP device */
+typedef struct _uap_dev
+{
+        /** device name */
+    char name[DEV_NAME_LEN];
+        /** card pointer */
+    void *card;
+        /** IO port */
+    u32 ioport;
+        /** Rx unit */
+    u8 rx_unit;
+        /** Data sent:
+	    TRUE - Data is sent to fw, no Tx Done received
+	    FALSE - Tx done received for previous Tx */
+    BOOLEAN data_sent;
+        /** CMD sent:
+	    TRUE - CMD is sent to fw, no CMD Done received
+	    FALSE - CMD done received for previous CMD */
+    BOOLEAN cmd_sent;
+        /** netdev pointer */
+    struct net_device *netdev;
+} uap_dev_t, *puap_dev_t;
+
+/** Private structure for the MV device */
+struct _uap_private
+{
+        /** Device open */
+    int open;
+
+        /** Device adapter structure */
+    uap_adapter *adapter;
+        /** Device structure */
+    uap_dev_t uap_dev;
+
+        /** Net device statistics structure */
+    struct net_device_stats stats;
+
+        /** Number of Tx timeouts */
+    u32 num_tx_timeout;
+
+        /** Media connection status */
+    BOOLEAN MediaConnected;
+
+#ifdef CONFIG_PROC_FS
+    struct proc_dir_entry *proc_uap;
+    struct proc_dir_entry *proc_entry;
+#endif                          /* CONFIG_PROC_FS */
+
+        /** Firmware helper */
+    const struct firmware *fw_helper;
+        /** Firmware */
+    const struct firmware *firmware;
+        /** Hotplug device */
+    struct device *hotplug_device;
+        /** thread to service interrupts */
+    uap_thread MainThread;
+        /** Driver lock */
+    spinlock_t driver_lock;
+        /** Driver lock flags */
+    ulong driver_flags;
+
+};
+
+/** PS_CMD_ConfirmSleep */
+typedef struct _PS_CMD_ConfirmSleep
+{
+        /** SDIO Length */
+    u16 SDLen;
+    /** SDIO Type */
+    u16 SDType;
+        /** Command */
+    u16 Command;
+        /** Size */
+    u16 Size;
+        /** Sequence number */
+    u16 SeqNum;
+        /** Result */
+    u16 Result;
+} __ATTRIB_PACK__ PS_CMD_ConfirmSleep, *PPS_CMD_ConfirmSleep;
+
+/** Wlan Adapter data structure*/
+struct _uap_adapter
+{
+        /** Power save confirm sleep command */
+    PS_CMD_ConfirmSleep PSConfirmSleep;
+        /** Device status */
+    HARDWARE_STATUS HardwareStatus;
+        /** Interrupt counter */
+    u32 IntCounter;
+        /** Tx packet queue */
+    struct sk_buff_head tx_queue;
+        /** Cmd packet queue */
+    struct sk_buff_head cmd_queue;
+        /** Command sequence number */
+    u16 SeqNum;
+        /** Command buffer */
+    u8 *CmdBuf;
+        /** cmd pending flag */
+    u8 cmd_pending;
+        /** cmd wait option */
+    u8 cmd_wait_option;
+        /** Command buffer length */
+    u32 CmdSize;
+        /** Command wait queue */
+    wait_queue_head_t cmdwait_q __ATTRIB_ALIGN__;
+        /** Command wait queue state flag */
+    u8 CmdWaitQWoken;
+        /** PnP support */
+    BOOLEAN SurpriseRemoved;
+        /** Debug */
+    uap_dbg dbg;
+        /** Netlink kernel socket */
+    struct sock *nl_sk;
+        /** Semaphore for CMD */
+    SEMAPHORE CmdSem;
+         /** Power Save mode */
+    u8 psmode;
+        /** Power Save state */
+    u8 ps_state;
+        /** Number of wakeup tries */
+    u32 WakeupTries;
+};
+
+static inline int
+os_upload_rx_packet(uap_private * priv, struct sk_buff *skb)
+{
+    skb->dev = priv->uap_dev.netdev;
+    skb->protocol = eth_type_trans(skb, priv->uap_dev.netdev);
+    skb->ip_summed = CHECKSUM_UNNECESSARY;
+    if (in_interrupt())
+        netif_rx(skb);
+    else
+        netif_rx_ni(skb);
+    return 0;
+}
+
+/*
+ *  netif carrier_on/off and start(wake)/stop_queue handling
+ */
+static inline void
+os_carrier_on(uap_private * priv)
+{
+    if (!netif_carrier_ok(priv->uap_dev.netdev) &&
+        (priv->MediaConnected == TRUE)) {
+        netif_carrier_on(priv->uap_dev.netdev);
+    }
+}
+
+static inline void
+os_carrier_off(uap_private * priv)
+{
+    if (netif_carrier_ok(priv->uap_dev.netdev)) {
+        netif_carrier_off(priv->uap_dev.netdev);
+    }
+}
+
+static inline void
+os_start_queue(uap_private * priv)
+{
+    if (netif_queue_stopped(priv->uap_dev.netdev) &&
+        (priv->MediaConnected == TRUE)) {
+        netif_wake_queue(priv->uap_dev.netdev);
+    }
+}
+
+static inline void
+os_stop_queue(uap_private * priv)
+{
+    if (!netif_queue_stopped(priv->uap_dev.netdev)) {
+        netif_stop_queue(priv->uap_dev.netdev);
+    }
+}
+
+/** Interface specific header */
+#define INTF_HEADER_LEN         4
+
+/** headroom alignment for tx packet */
+#define HEADER_ALIGNMENT	8
+
+/** The number of times to try when polling for status bits */
+#define MAX_POLL_TRIES			100
+
+/** Length of SNAP header */
+#define MRVDRV_SNAP_HEADER_LEN          8
+
+/** Extra length of Tx packet buffer */
+#define EXTRA_LEN	36
+
+/** Buffer size for ethernet Tx packets */
+#define MRVDRV_ETH_TX_PACKET_BUFFER_SIZE \
+	(ETH_FRAME_LEN + sizeof(TxPD) + EXTRA_LEN)
+
+/** Buffer size for ethernet Rx packets */
+#define MRVDRV_ETH_RX_PACKET_BUFFER_SIZE \
+	(ETH_FRAME_LEN + sizeof(RxPD) \
+	 + MRVDRV_SNAP_HEADER_LEN + EXTRA_LEN)
+
+/** Packet type: data, command & event */
+typedef enum _mv_type
+{
+    MV_TYPE_DAT = 0,
+    MV_TYPE_CMD = 1,
+    MV_TYPE_EVENT = 3
+} mv_type;
+
+/** Disable interrupt */
+#define OS_INT_DISABLE	spin_lock_irqsave(&priv->driver_lock, priv->driver_flags)
+/** Enable interrupt */
+#define	OS_INT_RESTORE	spin_unlock_irqrestore(&priv->driver_lock, priv->driver_flags)
+
+int uap_process_rx_packet(uap_private * priv, struct sk_buff *skb);
+void uap_interrupt(uap_private * priv);
+uap_private *uap_add_card(void *card);
+int uap_remove_card(void *card);
+int uap_process_event(uap_private * priv, u8 * payload, uint len);
+int uap_soft_reset(uap_private * priv);
+int uap_process_sleep_confirm_resp(uap_private * priv, u8 * resp, int resp_len);
+
+#ifdef CONFIG_PROC_FS
+/** The proc fs interface */
+void uap_proc_entry(uap_private * priv, struct net_device *dev);
+void uap_proc_remove(uap_private * priv);
+int string_to_number(char *s);
+void uap_debug_entry(uap_private * priv, struct net_device *dev);
+void uap_debug_remove(uap_private * priv);
+#endif /* CONFIG_PROC_FS */
+
+int sbi_register(void);
+
+void sbi_unregister(void);
+int sbi_register_dev(uap_private * priv);
+int sbi_unregister_dev(uap_private * priv);
+int sbi_prog_fw_w_helper(uap_private *);
+
+int sbi_host_to_card(uap_private * priv, u8 * payload, u16 nb);
+int sbi_enable_host_int(uap_private * priv);
+int sbi_disable_host_int(uap_private * priv);
+
+int sbi_get_int_status(uap_private * priv, u8 * ireg);
+/** Check firmware status */
+int sbi_check_fw_status(uap_private *, int);
+int sbi_prog_helper(uap_private *);
+
+int sbi_wakeup_firmware(uap_private * priv);
+
+#endif /* _UAP_DRV_H */
diff -ruN a/drivers/net/wireless/libertas_uap/uap_fw.h b/drivers/net/wireless/libertas_uap/uap_fw.h
--- a/drivers/net/wireless/libertas_uap/uap_fw.h	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_fw.h	2013-09-16 01:27:45.907769283 -0600
@@ -0,0 +1,359 @@
+/** @file uap_fw.h
+ *
+ * @brief This file contains firmware specific defines.
+ *
+ * Copyright (C) 2008-2009, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available along with the File in the gpl.txt file or by writing to
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/********************************************************
+Change log:
+	02/26/08: Initial creation
+********************************************************/
+
+#ifndef _UAP_FW_H
+#define _UAP_FW_H
+
+/** uap upload size */
+#define	UAP_UPLD_SIZE			2312
+/** Packet type Micro AP */
+#define PKT_TYPE_MICROAP		1
+/** Packet type client */
+#define PKT_TYPE_CLIENT			0
+
+/** TxPD descriptor */
+typedef struct _TxPD
+{
+        /** Bss Type */
+    u8 BssType;
+        /** Bss num */
+    u8 BssNum;
+        /** Tx packet length */
+    u16 TxPktLength;
+        /** Tx packet offset */
+    u16 TxPktOffset;
+        /** Tx packet type */
+    u16 TxPktType;
+        /** Tx Control */
+    u32 TxControl;
+        /** reserved */
+    u32 reserved[2];
+} __ATTRIB_PACK__ TxPD, *PTxPD;
+
+/** RxPD Descriptor */
+typedef struct _RxPD
+{
+        /** Bss Type */
+    u8 BssType;
+        /** Bss Num */
+    u8 BssNum;
+        /** Tx packet length */
+    u16 RxPktLength;
+        /** Tx packet offset */
+    u16 RxPktOffset;
+} __ATTRIB_PACK__ RxPD, *PRxPD;
+
+#ifdef BIG_ENDIAN
+/** Convert from 16 bit little endian format to CPU format */
+#define uap_le16_to_cpu(x) le16_to_cpu(x)
+/** Convert from 32 bit little endian format to CPU format */
+#define uap_le32_to_cpu(x) le32_to_cpu(x)
+/** Convert from 64 bit little endian format to CPU format */
+#define uap_le64_to_cpu(x) le64_to_cpu(x)
+/** Convert to 16 bit little endian format from CPU format */
+#define uap_cpu_to_le16(x) cpu_to_le16(x)
+/** Convert to 32 bit little endian format from CPU format */
+#define uap_cpu_to_le32(x) cpu_to_le32(x)
+/** Convert to 64 bit little endian format from CPU format */
+#define uap_cpu_to_le64(x) cpu_to_le64(x)
+
+/** Convert TxPD to little endian format from CPU format */
+#define endian_convert_TxPD(x);                                         \
+    {                                                                   \
+        (x)->TxPktLength = uap_cpu_to_le16((x)->TxPktLength);    	\
+        (x)->TxPktOffset = uap_cpu_to_le32((x)->TxPktOffset);		\
+        (x)->TxControl = uap_cpu_to_le32((x)->TxControl);              \
+        (x)->TxPktType = uap_cpu_to_le32((x)->TxPktType);		\
+    }
+
+/** Convert RxPD from little endian format to CPU format */
+#define endian_convert_RxPD(x);                             		\
+    {                                                       		\
+        (x)->RxPktLength = uap_le16_to_cpu((x)->RxPktLength);        	\
+        (x)->RxPktOffset = uap_le32_to_cpu((x)->RxPktOffset);  	\
+    }
+#else /* BIG_ENDIAN */
+/** Do nothing */
+#define uap_le16_to_cpu(x) x
+/** Do nothing */
+#define uap_le32_to_cpu(x) x
+/** Do nothing */
+#define uap_le64_to_cpu(x) x
+/** Do nothing */
+#define uap_cpu_to_le16(x) x
+/** Do nothing */
+#define uap_cpu_to_le32(x) x
+/** Do nothing */
+#define uap_cpu_to_le64(x) x
+
+/** Do nothing */
+#define endian_convert_TxPD(x)
+/** Do nothing */
+#define endian_convert_RxPD(x)
+#endif /* BIG_ENDIAN */
+
+/** Host Command ID : Function initialization */
+#define HostCmd_CMD_FUNC_INIT                 0x00a9
+/** Host Command ID : Function shutdown */
+#define HostCmd_CMD_FUNC_SHUTDOWN             0x00aa
+
+/** Host Command id: SYS_INFO  */
+#define HOST_CMD_APCMD_SYS_INFO               0x00ae
+/** Host Command id: SYS_RESET  */
+#define HOST_CMD_APCMD_SYS_RESET              0x00af
+/** Host Command id: SYS_CONFIGURE  */
+#define HOST_CMD_APCMD_SYS_CONFIGURE          0x00b0
+/** Host Command id: BSS_START  */
+#define HOST_CMD_APCMD_BSS_START              0x00b1
+/** Host Command id: SYS_STOP  */
+#define HOST_CMD_APCMD_BSS_STOP               0x00b2
+/** Host Command id: STA_LIST  */
+#define HOST_CMD_APCMD_STA_LIST               0x00b3
+/** Host Command id: STA_FILTER_TABLE  */
+#define HOST_CMD_APCMD_STA_FILTER_TABLE       0x00b4
+/** Host Command id: STA_DEAUTH  */
+#define HOST_CMD_APCMD_STA_DEAUTH             0x00b5
+/** Host Command id: SOFT_RESET  */
+#define HOST_CMD_APCMD_SOFT_RESET             0x00d5
+/** Host Command id: POWER_MGMT_EXT  */
+#define HOST_CMD_POWER_MGMT_EXT               0x00ef
+/** Host Command id: SLEEP_CONFIRM*/
+#define HOST_CMD_SLEEP_CONFIRM       	      0x00d8
+
+/** TLV type : SSID */
+#define TLV_TYPE_SSID				0x0000
+/** TLV type : Rates */
+#define TLV_TYPE_RATES				0x0001
+/** TLV type : PHY DS */
+#define TLV_TYPE_PHY_DS				0x0003
+
+/** TLV Id : Base id */
+#define PROPRIETARY_TLV_BASE_ID               0x0100
+/** TLV Id : AP_MAC_ADDRESS */
+#define MRVL_AP_MAC_ADDRESS_TLV_ID      (PROPRIETARY_TLV_BASE_ID + 43)
+/** TLV Id : Beacon period */
+#define MRVL_BEACON_PERIOD_TLV_ID       (PROPRIETARY_TLV_BASE_ID + 44)
+/** TLV Id : Dtim period */
+#define MRVL_DTIM_PERIOD_TLV_ID         (PROPRIETARY_TLV_BASE_ID + 45)
+/** TLV Id : Basic rates */
+#define MRVL_BASIC_RATES_TLV_ID         (PROPRIETARY_TLV_BASE_ID + 46)
+/** TLV Id : Tx Power */
+#define MRVL_TX_POWER_TLV_ID            (PROPRIETARY_TLV_BASE_ID + 47)
+/** TLV Id : Broadcast SSID control */
+#define MRVL_BCAST_SSID_CTL_TLV_ID      (PROPRIETARY_TLV_BASE_ID + 48)
+/** TLV Id : Preamble control */
+#define MRVL_PREAMBLE_CTL_TLV_ID        (PROPRIETARY_TLV_BASE_ID + 49)
+/** TLV Id : Antenna control */
+#define MRVL_ANTENNA_CTL_TLV_ID         (PROPRIETARY_TLV_BASE_ID + 50)
+/** TLV Id : RTS threshold */
+#define MRVL_RTS_THRESHOLD_TLV_ID       (PROPRIETARY_TLV_BASE_ID + 51)
+/** TLV Id : Radio control */
+#define MRVL_RADIO_CTL_TLV_ID           (PROPRIETARY_TLV_BASE_ID + 52)
+/** TLV Id : TX data rate */
+#define MRVL_TX_DATA_RATE_TLV_ID        (PROPRIETARY_TLV_BASE_ID + 53)
+/** TLV Id : Packet forward control */
+#define MRVL_PKT_FWD_CTL_TLV_ID         (PROPRIETARY_TLV_BASE_ID + 54)
+/** TLV Id : STA info */
+#define MRVL_STA_INFO_TLV_ID            (PROPRIETARY_TLV_BASE_ID + 55)
+/** TLV Id : STA MAC address filter */
+#define MRVL_STA_MAC_ADDR_FILTER_TLV_ID (PROPRIETARY_TLV_BASE_ID + 56)
+/** TLV Id : STA ageout timer */
+#define MRVL_STA_AGEOUT_TIMER_TLV_ID    (PROPRIETARY_TLV_BASE_ID + 57)
+/** TLV Id : Security config */
+#define MRVL_SECURITY_CFG_TLV_ID        (PROPRIETARY_TLV_BASE_ID + 58)
+/** TLV Id : WEP KEY */
+#define MRVL_WEP_KEY_TLV_ID             (PROPRIETARY_TLV_BASE_ID + 59)
+/** TLV Id : WPA Passphrase */
+#define MRVL_WPA_PASSPHRASE_TLV_ID      (PROPRIETARY_TLV_BASE_ID + 60)
+
+/** Action get */
+#define ACTION_GET	0
+/** Action set */
+#define ACTION_SET 	1
+/** Length of ethernet address */
+#ifndef	ETH_ALEN
+#define ETH_ALEN			6
+#endif
+
+/** HostCmd_DS_GEN */
+typedef struct
+{
+    /** Command */
+    u16 Command;
+    /** Size */
+    u16 Size;
+    /** Sequence number */
+    u16 SeqNum;
+    /** Result */
+    u16 Result;
+} __ATTRIB_PACK__ HostCmd_DS_GEN;
+
+/** Size of HostCmd_DS_GEN */
+#define S_DS_GEN    sizeof(HostCmd_DS_GEN)
+
+/** _HostCmd_HEADER*/
+typedef struct
+{
+    /** Command Header : Command */
+    u16 Command;
+    /** Command Header : Size */
+    u16 Size;
+} __ATTRIB_PACK__ HostCmd_HEADER;
+
+/** HostCmd_SYS_CONFIG */
+typedef struct _HostCmd_SYS_CONFIG
+{
+        /** CMD Action GET/SET*/
+    u16 Action;
+        /** Tlv buffer */
+    u8 TlvBuffer[0];
+} __ATTRIB_PACK__ HostCmd_SYS_CONFIG;
+
+/** HostCmd_DS_POWER_MGMT_EXT */
+typedef struct _HostCmd_DS_POWER_MGMT_EXT
+{
+    /** CMD Action Get/Set*/
+    u16 action;
+    /** power mode */
+    u16 power_mode;
+} __ATTRIB_PACK__ HostCmd_DS_POWER_MGMT_EXT;
+
+/** _HostCmd_DS_COMMAND*/
+typedef struct _HostCmd_DS_COMMAND
+{
+
+        /** Command Header : Command */
+    u16 Command;
+        /** Command Header : Size */
+    u16 Size;
+        /** Command Header : Sequence number */
+    u16 SeqNum;
+        /** Command Header : Result */
+    u16 Result;
+        /** Command Body */
+    union
+    {
+        HostCmd_SYS_CONFIG sys_config;
+        HostCmd_DS_POWER_MGMT_EXT pm_cfg;
+
+    } params;
+} __ATTRIB_PACK__ HostCmd_DS_COMMAND;
+
+/** MrvlIEtypesHeader_*/
+typedef struct _MrvlIEtypesHeader
+{
+    /** Header type */
+    u16 Type;
+    /** Header length */
+    u16 Len;
+} __ATTRIB_PACK__ MrvlIEtypesHeader_t;
+
+/** MrvlIEtypes_Data_t */
+typedef struct _MrvlIEtypes_Data_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** Data */
+    u8 Data[1];
+} __ATTRIB_PACK__ MrvlIEtypes_Data_t;
+
+/** MrvlIEtypes_ChanListParamSet_t */
+typedef struct _MrvlIEtypes_MacAddr_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t Header;
+    /** AP MAC address */
+    u8 ApMacAddr[ETH_ALEN];
+} __ATTRIB_PACK__ MrvlIEtypes_MacAddr_t;
+
+/** Event ID: BSS started */
+#define MICRO_AP_EV_ID_BSS_START    46
+
+/** Event ID: BSS idle event */
+#define MICRO_AP_EV_BSS_IDLE	     67
+
+/** Event ID: BSS active event */
+#define MICRO_AP_EV_BSS_ACTIVE	     68
+
+/** Event ID: PS_AWAKE */
+#define EVENT_PS_AWAKE     0x0a
+
+/** Event ID: PS_SLEEP */
+#define EVENT_PS_SLEEP     0x0b
+
+/** PS_STATE */
+typedef enum _PS_STATE
+{
+    PS_STATE_AWAKE,
+    PS_STATE_PRE_SLEEP,
+    PS_STATE_SLEEP
+} PS_STATE;
+
+/** TLV type: AP Sleep param */
+#define TLV_TYPE_AP_SLEEP_PARAM         (PROPRIETARY_TLV_BASE_ID + 106)
+/** TLV type: AP Inactivity Sleep param */
+#define TLV_TYPE_AP_INACT_SLEEP_PARAM   (PROPRIETARY_TLV_BASE_ID + 107)
+
+/** MrvlIEtypes_sleep_param_t */
+typedef struct _MrvlIEtypes_sleep_param_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t header;
+    /** control bitmap */
+    u32 ctrl_bitmap;
+    /** min_sleep */
+    u32 min_sleep;
+    /** max_sleep */
+    u32 max_sleep;
+} __ATTRIB_PACK__ MrvlIEtypes_sleep_param_t;
+
+/** MrvlIEtypes_inact_sleep_param_t */
+typedef struct _MrvlIEtypes_inact_sleep_param_t
+{
+    /** Header */
+    MrvlIEtypesHeader_t header;
+    /** inactivity timeout */
+    u32 inactivity_to;
+    /** min_awake */
+    u32 min_awake;
+    /** max_awake */
+    u32 max_awake;
+} __ATTRIB_PACK__ MrvlIEtypes_inact_sleep_param_t;
+
+/** AP_Event */
+typedef struct _AP_Event
+{
+    /** Event ID */
+    u32 EventId;
+    /*
+     * Reserved for STA_ASSOCIATED event and contains
+     * status information for the MIC_COUNTERMEASURES event.
+     */
+    /** Reserved/status */
+    u16 status;
+    /** AP MAC address */
+    u8 MacAddr[ETH_ALEN];
+} __ATTRIB_PACK__ AP_Event;
+#endif /* _UAP_FW_H */
diff -ruN a/drivers/net/wireless/libertas_uap/uap_headers.h b/drivers/net/wireless/libertas_uap/uap_headers.h
--- a/drivers/net/wireless/libertas_uap/uap_headers.h	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_headers.h	2013-09-16 01:27:45.907769283 -0600
@@ -0,0 +1,64 @@
+/** @file uap_headers.h
+ *
+ * @brief This file contains all the necessary include file.
+ *
+  * Copyright (C) 2008-2009, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available along with the File in the gpl.txt file or by writing to
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+#ifndef _UAP_HEADERS_H
+#define _UAP_HEADERS_H
+
+/* Linux header files */
+#include    <linux/kernel.h>
+#include    <linux/module.h>
+#include    <linux/init.h>
+#include    <linux/version.h>
+#include    <linux/param.h>
+#include    <linux/types.h>
+#include    <linux/interrupt.h>
+#include    <linux/proc_fs.h>
+#include    <linux/kthread.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+#include    <linux/semaphore.h>
+#else
+#include    <asm/semaphore.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#include    <linux/config.h>
+#endif
+
+/* Net header files */
+#include    <linux/netdevice.h>
+#include    <linux/net.h>
+#include    <linux/skbuff.h>
+#include    <linux/if_ether.h>
+#include    <linux/etherdevice.h>
+#include    <net/sock.h>
+#include    <linux/netlink.h>
+#include    <linux/firmware.h>
+#include    <linux/delay.h>
+
+#include    "uap_drv.h"
+#include    "uap_fw.h"
+
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include "uap_sdio_mmc.h"
+
+#endif /* _UAP_HEADERS_H */
diff -ruN a/drivers/net/wireless/libertas_uap/uap_main.c b/drivers/net/wireless/libertas_uap/uap_main.c
--- a/drivers/net/wireless/libertas_uap/uap_main.c	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_main.c	2013-09-16 01:27:45.917769156 -0600
@@ -0,0 +1,1830 @@
+/** @file uap_main.c
+  * @brief This file contains the major functions in uAP
+  * driver. It includes init, exit etc..
+  * This file also contains the initialization for SW,
+  * FW and HW
+  *
+  * Copyright (C) 2008-2009, Marvell International Ltd.
+  *
+  * This software file (the "File") is distributed by Marvell International
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+  * (the "License").  You may use, redistribute and/or modify this File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available along with the File in the gpl.txt file or by writing to
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+/**
+  * @mainpage uAP Linux Driver
+  *
+  * @section overview_sec Overview
+  *
+  * This is Linux reference driver for Marvell uAP.
+  *
+  * @section copyright_sec Copyright
+  *
+  * Copyright (C) 2008, Marvell International Ltd.
+  *
+  */
+
+#include	"uap_headers.h"
+
+/**
+ * the global variable of a pointer to uap_private
+ * structure variable
+ */
+uap_private *uappriv = NULL;
+#ifdef DEBUG_LEVEL1
+#define DEFAULT_DEBUG_MASK	(DBG_MSG | DBG_FATAL | DBG_ERROR)
+u32 drvdbg = DEFAULT_DEBUG_MASK;
+#endif
+/** Helper name */
+char *helper_name = NULL;
+/** Firmware name */
+char *fw_name = NULL;
+
+/** Semaphore for add/remove card */
+SEMAPHORE AddRemoveCardSem;
+
+/********************************************************
+		Local Functions
+********************************************************/
+/**
+ *  @brief This function send sleep confirm command to firmware
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS for success otherwise UAP_STATUS_FAILURE
+ */
+static int
+uap_dnld_sleep_confirm_cmd(uap_private * priv)
+{
+    uap_adapter *Adapter = priv->adapter;
+    int ret = UAP_STATUS_SUCCESS;
+    ENTER();
+    PRINTM(CMND, "Sleep confirm\n");
+    Adapter->cmd_pending = TRUE;
+    Adapter->cmd_wait_option = HostCmd_OPTION_WAITFORRSP_SLEEPCONFIRM;
+    ret =
+        sbi_host_to_card(priv, (u8 *) & Adapter->PSConfirmSleep,
+                         sizeof(PS_CMD_ConfirmSleep));
+    if (ret != UAP_STATUS_SUCCESS) {
+        Adapter->ps_state = PS_STATE_AWAKE;
+        Adapter->cmd_pending = FALSE;
+        Adapter->cmd_wait_option = FALSE;
+    }
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function process sleep confirm resp from firmware
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @param resp 	A pointer to resp buf
+ *  @param resp_len 	resp buf len
+ *  @return 	   UAP_STATUS_SUCCESS for success otherwise UAP_STATUS_FAILURE
+ */
+int
+uap_process_sleep_confirm_resp(uap_private * priv, u8 * resp, int resp_len)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    HostCmd_DS_COMMAND *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    ENTER();
+    PRINTM(CMND, "Sleep confirm resp\n");
+    if (!resp_len) {
+        PRINTM(ERROR, "Cmd Size is 0\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    cmd = (HostCmd_DS_COMMAND *) resp;
+    cmd->Result = uap_le16_to_cpu(cmd->Result);
+    if (cmd->Result != UAP_STATUS_SUCCESS) {
+        PRINTM(ERROR, "HOST_CMD_APCMD_PS_SLEEP_CONFIRM fail=%x\n", cmd->Result);
+        ret = -EFAULT;
+    }
+  done:
+    if (ret == UAP_STATUS_SUCCESS)
+        Adapter->ps_state = PS_STATE_SLEEP;
+    else
+        Adapter->ps_state = PS_STATE_AWAKE;
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function checks condition and prepares to
+ *  send sleep confirm command to firmware if OK.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @return 	   	n/a
+ */
+static void
+uap_ps_cond_check(uap_private * priv)
+{
+    uap_adapter *Adapter = priv->adapter;
+
+    ENTER();
+    if (!priv->uap_dev.cmd_sent &&
+        !Adapter->cmd_pending && !Adapter->IntCounter) {
+        uap_dnld_sleep_confirm_cmd(priv);
+    } else {
+        PRINTM(INFO, "Delay Sleep Confirm (%s%s%s)\n",
+               (priv->uap_dev.cmd_sent) ? "D" : "",
+               (Adapter->cmd_pending) ? "C" : "",
+               (Adapter->IntCounter) ? "I" : "");
+    }
+    LEAVE();
+}
+
+/**
+ *  @brief This function add cmd to cmdQ and waiting for response
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param skb 	   A pointer to the skb for process
+ *  @param wait_option Wait option
+ *  @return 	   UAP_STATUS_SUCCESS for success otherwise UAP_STATUS_FAILURE
+ */
+static int
+uap_process_cmd(uap_private * priv, struct sk_buff *skb, u8 wait_option)
+{
+    uap_adapter *Adapter = priv->adapter;
+    int ret = UAP_STATUS_SUCCESS;
+    HostCmd_DS_COMMAND *cmd;
+    u8 *headptr;
+    ENTER();
+    if (Adapter->HardwareStatus != HWReady) {
+        PRINTM(ERROR, "Hw not ready, uap_process_cmd\n");
+        kfree(skb);
+        LEAVE();
+        return -EFAULT;
+    }
+    skb->cb[0] = wait_option;
+    headptr = skb->data;
+    *(u16 *) & headptr[0] = uap_cpu_to_le16(skb->len);
+    *(u16 *) & headptr[2] = uap_cpu_to_le16(MV_TYPE_CMD);
+    cmd = (HostCmd_DS_COMMAND *) (skb->data + INTF_HEADER_LEN);
+    Adapter->SeqNum++;
+    cmd->SeqNum = uap_cpu_to_le16(Adapter->SeqNum);
+    PRINTM(CMND, "process_cmd: %x\n", cmd->Command);
+    DBG_HEXDUMP(CMD_D, "process_cmd", (u8 *) cmd, cmd->Size);
+    if (!wait_option) {
+        skb_queue_tail(&priv->adapter->cmd_queue, skb);
+        wake_up_interruptible(&priv->MainThread.waitQ);
+        LEAVE();
+        return ret;
+    }
+    if (OS_ACQ_SEMAPHORE_BLOCK(&Adapter->CmdSem)) {
+        PRINTM(ERROR, "Acquire semaphore error, uap_prepare_cmd\n");
+        kfree(skb);
+        LEAVE();
+        return -EBUSY;
+    }
+    skb_queue_tail(&priv->adapter->cmd_queue, skb);
+    Adapter->CmdWaitQWoken = FALSE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    /* Sleep until response is generated by FW */
+    if (wait_option == HostCmd_OPTION_WAITFORRSP_TIMEOUT) {
+        if (!os_wait_interruptible_timeout
+            (Adapter->cmdwait_q, Adapter->CmdWaitQWoken, MRVDRV_TIMER_20S)) {
+            PRINTM(ERROR, "Cmd timeout\n");
+            Adapter->cmd_pending = FALSE;
+            ret = -EFAULT;
+        }
+    } else
+        wait_event_interruptible(Adapter->cmdwait_q, Adapter->CmdWaitQWoken);
+    OS_REL_SEMAPHORE(&Adapter->CmdSem);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief Inspect the response buffer for pointers to expected TLVs
+ *
+ *
+ *  @param pTlv        Pointer to the start of the TLV buffer to parse
+ *  @param tlvBufSize  Size of the TLV buffer
+ *  @param reqTlvType  request tlv's tlvtype
+ *  @param ppTlv       Output parameter: Pointer to the request TLV if found
+ *
+ *  @return            void
+ */
+static void
+uap_get_tlv_ptrs(MrvlIEtypes_Data_t * pTlv, int tlvBufSize,
+                 u16 reqTlvType, MrvlIEtypes_Data_t ** ppTlv)
+{
+    MrvlIEtypes_Data_t *pCurrentTlv;
+    int tlvBufLeft;
+    u16 tlvType;
+    u16 tlvLen;
+
+    ENTER();
+    pCurrentTlv = pTlv;
+    tlvBufLeft = tlvBufSize;
+    *ppTlv = NULL;
+    PRINTM(INFO, "uap_get_tlv: tlvBufSize = %d, reqTlvType=%x\n", tlvBufSize,
+           reqTlvType);
+    while (tlvBufLeft >= sizeof(MrvlIEtypesHeader_t)) {
+        tlvType = uap_le16_to_cpu(pCurrentTlv->Header.Type);
+        tlvLen = uap_le16_to_cpu(pCurrentTlv->Header.Len);
+        if (reqTlvType == tlvType)
+            *ppTlv = (MrvlIEtypes_Data_t *) pCurrentTlv;
+        if (*ppTlv) {
+            HEXDUMP("TLV Buf", (u8 *) * ppTlv, tlvLen);
+            break;
+        }
+        tlvBufLeft -= (sizeof(pTlv->Header) + tlvLen);
+        pCurrentTlv = (MrvlIEtypes_Data_t *) (pCurrentTlv->Data + tlvLen);
+    }                           /* while */
+    LEAVE();
+}
+
+/**
+ *  @brief This function get mac
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS on success, otherwise failure code
+ */
+static int
+uap_get_mac_address(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u32 CmdSize;
+    HostCmd_DS_COMMAND *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+    MrvlIEtypes_MacAddr_t *pMacAddrTlv;
+    MrvlIEtypes_Data_t *pTlv;
+    u16 tlvBufSize;
+    ENTER();
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+    CmdSize =
+        S_DS_GEN + sizeof(HostCmd_SYS_CONFIG) + sizeof(MrvlIEtypes_MacAddr_t);
+    cmd = (HostCmd_DS_COMMAND *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HOST_CMD_APCMD_SYS_CONFIGURE);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    cmd->params.sys_config.Action = uap_cpu_to_le16(ACTION_GET);
+    pMacAddrTlv =
+        (MrvlIEtypes_MacAddr_t *) (skb->data + INTF_HEADER_LEN + S_DS_GEN +
+                                   sizeof(HostCmd_SYS_CONFIG));
+    pMacAddrTlv->Header.Type = uap_cpu_to_le16(MRVL_AP_MAC_ADDRESS_TLV_ID);
+    pMacAddrTlv->Header.Len = uap_cpu_to_le16(ETH_ALEN);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP_TIMEOUT)) {
+        PRINTM(ERROR, "Fail to process cmd SYS_CONFIGURE Query\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    if (!Adapter->CmdSize) {
+        PRINTM(ERROR, "Cmd Size is 0\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    cmd = (HostCmd_DS_COMMAND *) Adapter->CmdBuf;
+    cmd->Result = uap_le16_to_cpu(cmd->Result);
+    if (cmd->Result != UAP_STATUS_SUCCESS) {
+        PRINTM(ERROR, "uap_get_mac_address fail=%x\n", cmd->Result);
+        ret = -EFAULT;
+        goto done;
+    }
+    pTlv =
+        (MrvlIEtypes_Data_t *) (Adapter->CmdBuf + S_DS_GEN +
+                                sizeof(HostCmd_SYS_CONFIG));
+    tlvBufSize = Adapter->CmdSize - S_DS_GEN - sizeof(HostCmd_SYS_CONFIG);
+    uap_get_tlv_ptrs(pTlv, tlvBufSize, MRVL_AP_MAC_ADDRESS_TLV_ID,
+                     (MrvlIEtypes_Data_t **) & pMacAddrTlv);
+    if (pMacAddrTlv) {
+        memcpy(priv->uap_dev.netdev->dev_addr, pMacAddrTlv->ApMacAddr,
+               ETH_ALEN);
+        HEXDUMP("Original MAC addr", priv->uap_dev.netdev->dev_addr, ETH_ALEN);
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function checks the conditions and sends packet to device
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param skb 	   A pointer to the skb for process
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_process_tx(uap_private * priv, struct sk_buff *skb)
+{
+    uap_adapter *Adapter = priv->adapter;
+    int ret = UAP_STATUS_SUCCESS;
+    TxPD *pLocalTxPD;
+    u8 *headptr;
+    struct sk_buff *newskb;
+    int newheadlen;
+    ENTER();
+    ASSERT(skb);
+    if (!skb) {
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+    if (skb_headroom(skb) < (sizeof(TxPD) + INTF_HEADER_LEN + HEADER_ALIGNMENT)) {
+        newheadlen = sizeof(TxPD) + INTF_HEADER_LEN + HEADER_ALIGNMENT;
+        PRINTM(WARN, "Tx: Insufficient skb headroom %d\n", skb_headroom(skb));
+        /* Insufficient skb headroom - allocate a new skb */
+        newskb = skb_realloc_headroom(skb, newheadlen);
+        if (unlikely(newskb == NULL)) {
+            PRINTM(ERROR, "Tx: Cannot allocate skb\n");
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        kfree_skb(skb);
+        skb = newskb;
+        PRINTM(INFO, "new skb headroom %d\n", skb_headroom(skb));
+    }
+    /* headptr should be aligned */
+    headptr = skb->data - sizeof(TxPD) - INTF_HEADER_LEN;
+    headptr = (u8 *) ((u32) headptr & ~((u32) (HEADER_ALIGNMENT - 1)));
+
+    pLocalTxPD = (TxPD *) (headptr + INTF_HEADER_LEN);
+    memset(pLocalTxPD, 0, sizeof(TxPD));
+    pLocalTxPD->BssType = PKT_TYPE_MICROAP;
+    pLocalTxPD->TxPktLength = skb->len;
+    /* offset of actual data */
+    pLocalTxPD->TxPktOffset = (long) skb->data - (long) pLocalTxPD;
+    endian_convert_TxPD(pLocalTxPD);
+    *(u16 *) & headptr[0] =
+        uap_cpu_to_le16(skb->len + ((long) skb->data - (long) headptr));
+    *(u16 *) & headptr[2] = uap_cpu_to_le16(MV_TYPE_DAT);
+    ret =
+        sbi_host_to_card(priv, headptr,
+                         skb->len + ((long) skb->data - (long) headptr));
+    if (ret) {
+        PRINTM(ERROR, "uap_process_tx Error: sbi_host_to_card failed: 0x%X\n",
+               ret);
+        Adapter->dbg.num_tx_host_to_card_failure++;
+        goto done;
+    }
+    PRINTM(DATA, "Data => FW\n");
+    DBG_HEXDUMP(DAT_D, "Tx", headptr,
+                MIN(skb->len + sizeof(TxPD), DATA_DUMP_LEN));
+  done:
+    /* Freed skb */
+    kfree_skb(skb);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function initializes the adapter structure
+ *  and set default value to the member of adapter.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_init_sw(uap_private * priv)
+{
+    uap_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (!(Adapter->CmdBuf = kmalloc(MRVDRV_SIZE_OF_CMD_BUFFER, GFP_KERNEL))) {
+        PRINTM(INFO, "Failed to allocate command buffer!\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    Adapter->cmd_pending = FALSE;
+    Adapter->CmdWaitQWoken = FALSE;
+    Adapter->ps_state = PS_STATE_AWAKE;
+    Adapter->WakeupTries = 0;
+
+    memset(&Adapter->PSConfirmSleep, 0, sizeof(PS_CMD_ConfirmSleep));
+        /** SDIO header */
+    Adapter->PSConfirmSleep.SDLen =
+        uap_cpu_to_le16(sizeof(PS_CMD_ConfirmSleep));
+    Adapter->PSConfirmSleep.SDType = uap_cpu_to_le16(MV_TYPE_CMD);
+    Adapter->PSConfirmSleep.SeqNum = 0;
+    Adapter->PSConfirmSleep.Command = uap_cpu_to_le16(HOST_CMD_SLEEP_CONFIRM);
+    Adapter->PSConfirmSleep.Size = uap_cpu_to_le16(sizeof(HostCmd_DS_GEN));
+    Adapter->PSConfirmSleep.Result = 0;
+
+    init_waitqueue_head(&Adapter->cmdwait_q);
+    OS_INIT_SEMAPHORE(&Adapter->CmdSem);
+
+    skb_queue_head_init(&Adapter->tx_queue);
+    skb_queue_head_init(&Adapter->cmd_queue);
+
+    /* Status variable */
+    Adapter->HardwareStatus = HWInitializing;
+
+    /* PnP support */
+    Adapter->SurpriseRemoved = FALSE;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+    Adapter->nl_sk = netlink_kernel_create(NETLINK_MARVELL,
+                                           NL_MULTICAST_GROUP, NULL,
+                                           THIS_MODULE);
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+    Adapter->nl_sk = netlink_kernel_create(NETLINK_MARVELL,
+                                           NL_MULTICAST_GROUP, NULL, NULL,
+                                           THIS_MODULE);
+#else
+    Adapter->nl_sk = netlink_kernel_create(&init_net, NETLINK_MARVELL,
+                                           NL_MULTICAST_GROUP, NULL, NULL,
+                                           THIS_MODULE);
+#endif
+#endif
+    if (!Adapter->nl_sk) {
+        PRINTM(ERROR,
+               "Could not initialize netlink event passing mechanism!\n");
+    }
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function sends FUNC_INIT command to firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS on success, otherwise failure code
+ */
+static int
+uap_func_init(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u32 CmdSize;
+    HostCmd_DS_GEN *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+    ENTER();
+    if (Adapter->HardwareStatus != HWReady) {
+        PRINTM(ERROR, "uap_func_init:Hardware is not ready!\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+    CmdSize = sizeof(HostCmd_DS_GEN);
+    cmd = (HostCmd_DS_GEN *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HostCmd_CMD_FUNC_INIT);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    PRINTM(CMND, "HostCmd_CMD_FUNC_INIT\n");
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP_TIMEOUT)) {
+        PRINTM(ERROR, "Fail to process cmd HostCmd_CMD_FUNC_INIT\n");
+        ret = -EFAULT;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function sends FUNC_SHUTDOWN command to firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS on success, otherwise failure code
+ */
+static int __exit
+uap_func_shutdown(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u32 CmdSize;
+    HostCmd_DS_GEN *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+    ENTER();
+    if (Adapter->HardwareStatus != HWReady) {
+        PRINTM(ERROR, "uap_func_shutdown:Hardware is not ready!\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+    CmdSize = sizeof(HostCmd_DS_GEN);
+    cmd = (HostCmd_DS_GEN *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HostCmd_CMD_FUNC_SHUTDOWN);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    PRINTM(CMND, "HostCmd_CMD_FUNC_SHUTDOWN\n");
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP_TIMEOUT)) {
+        PRINTM(ERROR, "Fail to process cmd HostCmd_CMD_FUNC_SHUTDOWN\n");
+        ret = -EFAULT;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function initializes firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_init_fw(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    ENTER();
+    sbi_disable_host_int(priv);
+    /* Check if firmware is already running */
+    if (sbi_check_fw_status(priv, 1) == UAP_STATUS_SUCCESS) {
+        PRINTM(MSG, "UAP FW already running! Skip FW download\n");
+    } else {
+        if ((ret = request_firmware(&priv->fw_helper, helper_name,
+                                    priv->hotplug_device)) < 0) {
+            PRINTM(FATAL,
+                   "request_firmware() failed (helper), error code = %#x\n",
+                   ret);
+            goto done;
+        }
+
+        /* Download the helper */
+        ret = sbi_prog_helper(priv);
+
+        if (ret) {
+            PRINTM(FATAL,
+                   "Bootloader in invalid state! Helper download failed!\n");
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        if ((ret = request_firmware(&priv->firmware, fw_name,
+                                    priv->hotplug_device)) < 0) {
+            PRINTM(FATAL, "request_firmware() failed, error code = %#x\n", ret);
+            goto done;
+        }
+
+        /* Download the main firmware via the helper firmware */
+        if (sbi_prog_fw_w_helper(priv)) {
+            PRINTM(FATAL, "UAP FW download failed!\n");
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        /* Check if the firmware is downloaded successfully or not */
+        if (sbi_check_fw_status(priv, MAX_FIRMWARE_POLL_TRIES) ==
+            UAP_STATUS_FAILURE) {
+            PRINTM(FATAL, "FW failed to be active in time!\n");
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        PRINTM(MSG, "UAP FW is active\n");
+    }
+    sbi_enable_host_int(priv);
+    priv->adapter->HardwareStatus = HWReady;
+    if (uap_func_init(priv) != UAP_STATUS_SUCCESS) {
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+  done:
+    if (priv->fw_helper)
+        release_firmware(priv->fw_helper);
+    if (priv->firmware)
+        release_firmware(priv->firmware);
+    LEAVE();
+    return ret;
+
+}
+
+/**
+ *  @brief This function frees the structure of adapter
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   n/a
+ */
+static void
+uap_free_adapter(uap_private * priv)
+{
+    uap_adapter *Adapter = priv->adapter;
+
+    ENTER();
+
+    if (Adapter) {
+        if ((Adapter->nl_sk) && ((Adapter->nl_sk)->sk_socket)) {
+            sock_release((Adapter->nl_sk)->sk_socket);
+            Adapter->nl_sk = NULL;
+        }
+        if (Adapter->CmdBuf)
+            kfree(Adapter->CmdBuf);
+        skb_queue_purge(&priv->adapter->tx_queue);
+        skb_queue_purge(&priv->adapter->cmd_queue);
+        /* Free the adapter object itself */
+        kfree(Adapter);
+        priv->adapter = NULL;
+    }
+
+    LEAVE();
+}
+
+/**
+ *  @brief This function handles the major job in uap driver.
+ *  it handles the event generated by firmware, rx data received
+ *  from firmware and tx data sent from kernel.
+ *
+ *  @param data    A pointer to uap_thread structure
+ *  @return        BT_STATUS_SUCCESS
+ */
+static int
+uap_service_main_thread(void *data)
+{
+    uap_thread *thread = data;
+    uap_private *priv = thread->priv;
+    uap_adapter *Adapter = priv->adapter;
+    wait_queue_t wait;
+    u8 ireg = 0;
+    struct sk_buff *skb;
+    ENTER();
+    uap_activate_thread(thread);
+    init_waitqueue_entry(&wait, current);
+    current->flags |= PF_NOFREEZE;
+
+    for (;;) {
+        add_wait_queue(&thread->waitQ, &wait);
+        OS_SET_THREAD_STATE(TASK_INTERRUPTIBLE);
+        if ((Adapter->WakeupTries) ||
+            (!Adapter->IntCounter && Adapter->ps_state == PS_STATE_PRE_SLEEP) ||
+            (!priv->adapter->IntCounter
+             && (priv->uap_dev.data_sent ||
+                 skb_queue_empty(&priv->adapter->tx_queue))
+             && (priv->uap_dev.cmd_sent || Adapter->cmd_pending ||
+                 skb_queue_empty(&priv->adapter->cmd_queue))
+            )) {
+            PRINTM(INFO, "Main: Thread sleeping...\n");
+            schedule();
+        }
+        OS_SET_THREAD_STATE(TASK_RUNNING);
+        remove_wait_queue(&thread->waitQ, &wait);
+        if (kthread_should_stop() || Adapter->SurpriseRemoved) {
+            PRINTM(INFO, "main-thread: break from main thread: "
+                   "SurpriseRemoved=0x%x\n", Adapter->SurpriseRemoved);
+            /* Cancel pending command */
+            if (Adapter->cmd_pending == TRUE) {
+                /* Wake up cmd Q */
+                Adapter->CmdWaitQWoken = TRUE;
+                wake_up_interruptible(&Adapter->cmdwait_q);
+            }
+            break;
+        }
+
+        PRINTM(INFO, "Main: Thread waking up...\n");
+        if (priv->adapter->IntCounter) {
+            OS_INT_DISABLE;
+            Adapter->IntCounter = 0;
+            OS_INT_RESTORE;
+            sbi_get_int_status(priv, &ireg);
+        } else if ((priv->adapter->ps_state == PS_STATE_SLEEP) &&
+                   (!skb_queue_empty(&priv->adapter->cmd_queue) ||
+                    !skb_queue_empty(&priv->adapter->tx_queue))) {
+            priv->adapter->WakeupTries++;
+            PRINTM(CMND, "%lu : Wakeup device...\n", os_time_get());
+            sbi_wakeup_firmware(priv);
+            continue;
+        }
+        if (Adapter->ps_state == PS_STATE_PRE_SLEEP)
+            uap_ps_cond_check(priv);
+
+        /* The PS state is changed during processing of Sleep Request event
+           above */
+        if ((Adapter->ps_state == PS_STATE_SLEEP) ||
+            (Adapter->ps_state == PS_STATE_PRE_SLEEP))
+            continue;
+        /* Execute the next command */
+        if (!priv->uap_dev.cmd_sent && !Adapter->cmd_pending &&
+            (Adapter->HardwareStatus == HWReady)) {
+            if (!skb_queue_empty(&priv->adapter->cmd_queue)) {
+                skb = skb_dequeue(&priv->adapter->cmd_queue);
+                if (skb) {
+                    Adapter->CmdSize = 0;
+                    Adapter->cmd_pending = TRUE;
+                    Adapter->cmd_wait_option = skb->cb[0];
+                    if (sbi_host_to_card(priv, skb->data, skb->len)) {
+                        PRINTM(ERROR, "Cmd:sbi_host_to_card failed!\n");
+                        Adapter->cmd_pending = FALSE;
+                        Adapter->dbg.num_cmd_host_to_card_failure++;
+                        /* Wake up cmd Q */
+                        Adapter->CmdWaitQWoken = TRUE;
+                        wake_up_interruptible(&Adapter->cmdwait_q);
+                    } else {
+                        if (Adapter->cmd_wait_option ==
+                            HostCmd_OPTION_WAITFORSEND) {
+                            /* Wake up cmd Q */
+                            Adapter->CmdWaitQWoken = TRUE;
+                            wake_up_interruptible(&Adapter->cmdwait_q);
+                            Adapter->cmd_wait_option = FALSE;
+                        }
+                    }
+                    kfree_skb(skb);
+                }
+            }
+        }
+        if (!priv->uap_dev.data_sent && (Adapter->HardwareStatus == HWReady)) {
+            if (!skb_queue_empty(&priv->adapter->tx_queue)) {
+                skb = skb_dequeue(&priv->adapter->tx_queue);
+                if (skb) {
+                    if (uap_process_tx(priv, skb)) {
+                        priv->stats.tx_dropped++;
+                        priv->stats.tx_errors++;
+                        os_start_queue(priv);
+                    } else {
+                        priv->stats.tx_packets++;
+                        priv->stats.tx_bytes += skb->len;
+                    }
+
+                }
+            }
+        }
+    }
+    uap_deactivate_thread(thread);
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief uap hostcmd ioctl handler
+ *
+ *  @param dev      A pointer to net_device structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         UAP_STATUS_SUCCESS --success, otherwise fail
+ */
+/*********  format of ifr_data *************/
+/*    buf_len + Hostcmd_body 		   */
+/*    buf_len: 4 bytes                     */
+/*             the length of the buf which */
+/*             can be used to return data  */
+/*             to application		   */
+/*    Hostcmd_body       	           */
+/*******************************************/
+static int
+uap_hostcmd_ioctl(struct net_device *dev, struct ifreq *req)
+{
+    u32 buf_len;
+    HostCmd_HEADER head;
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+    uap_adapter *Adapter = priv->adapter;
+    int ret = UAP_STATUS_SUCCESS;
+    struct sk_buff *skb;
+
+    ENTER();
+
+    /* Sanity check */
+    if (req->ifr_data == NULL) {
+        PRINTM(ERROR, "uap_hostcmd_ioctl() corrupt data\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    if (copy_from_user(&buf_len, req->ifr_data, sizeof(buf_len))) {
+        PRINTM(ERROR, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    memset(&head, 0, sizeof(HostCmd_HEADER));
+    /* Get the command size from user space */
+    if (copy_from_user
+        (&head, req->ifr_data + sizeof(buf_len), sizeof(HostCmd_HEADER))) {
+        PRINTM(ERROR, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    head.Size = uap_le16_to_cpu(head.Size);
+    if (head.Size > MRVDRV_SIZE_OF_CMD_BUFFER) {
+        PRINTM(ERROR, "CmdSize too big=%d\n", head.Size);
+        LEAVE();
+        return -EFAULT;
+    }
+    PRINTM(CMND, "ioctl: hostcmd=%x, size=%d,buf_len=%d\n", head.Command,
+           head.Size, buf_len);
+    skb = dev_alloc_skb(head.Size + INTF_HEADER_LEN);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+
+    /* Get the command from user space */
+    if (copy_from_user
+        (skb->data + INTF_HEADER_LEN, req->ifr_data + sizeof(buf_len),
+         head.Size)) {
+        PRINTM(ERROR, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    skb_put(skb, head.Size + INTF_HEADER_LEN);
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP)) {
+        PRINTM(ERROR, "Fail to process cmd\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    if (!Adapter->CmdSize) {
+        PRINTM(ERROR, "Cmd Size is 0\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    if (Adapter->CmdSize > buf_len) {
+        PRINTM(ERROR, "buf_len is too small\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    /* Copy to user */
+    if (copy_to_user
+        (req->ifr_data + sizeof(buf_len), Adapter->CmdBuf, Adapter->CmdSize)) {
+        PRINTM(ERROR, "Copy to user failed!\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief uap power mode ioctl handler
+ *
+ *  @param dev      A pointer to net_device structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         UAP_STATUS_SUCCESS --success, otherwise fail
+ */
+static int
+uap_power_mode_ioctl(struct net_device *dev, struct ifreq *req)
+{
+    ps_mgmt pm_cfg;
+    int ret = UAP_STATUS_SUCCESS;
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb = NULL;
+    HostCmd_DS_COMMAND *cmd;
+    u32 CmdSize;
+    u8 *tlv = NULL;
+    MrvlIEtypes_sleep_param_t *sleep_tlv = NULL;
+    MrvlIEtypes_inact_sleep_param_t *inact_tlv = NULL;
+    u16 tlv_buf_left = 0;
+    MrvlIEtypesHeader_t *tlvbuf = NULL;
+    u16 tlv_type = 0;
+    u16 tlv_len = 0;
+
+    ENTER();
+
+    /* Sanity check */
+    if (req->ifr_data == NULL) {
+        PRINTM(ERROR, "uap_power_mode_ioctl() corrupt data\n");
+        LEAVE();
+        return -EFAULT;
+    }
+
+    memset(&pm_cfg, 0, sizeof(ps_mgmt));
+    if (copy_from_user(&pm_cfg, req->ifr_data, sizeof(ps_mgmt))) {
+        PRINTM(ERROR, "Copy from user failed\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    PRINTM(CMND,
+           "ioctl power: flag=0x%x ps_mode=%d ctrl_bitmap=%d min_sleep=%d max_sleep=%d "
+           "inact_to=%d min_awake=%d max_awake=%d\n", pm_cfg.flags,
+           (int) pm_cfg.ps_mode, (int) pm_cfg.sleep_param.ctrl_bitmap,
+           (int) pm_cfg.sleep_param.min_sleep,
+           (int) pm_cfg.sleep_param.max_sleep,
+           (int) pm_cfg.inact_param.inactivity_to,
+           (int) pm_cfg.inact_param.min_awake,
+           (int) pm_cfg.inact_param.max_awake);
+
+    if (pm_cfg.
+        flags & ~(PS_FLAG_PS_MODE | PS_FLAG_SLEEP_PARAM |
+                  PS_FLAG_INACT_SLEEP_PARAM)) {
+        PRINTM(ERROR, "Invalid parameter: flags = 0x%x\n", pm_cfg.flags);
+        ret = -EINVAL;
+        goto done;
+    }
+    if (pm_cfg.ps_mode > PS_MODE_INACTIVITY) {
+        PRINTM(ERROR, "Invalid parameter: ps_mode = %d\n", (int) pm_cfg.flags);
+        ret = -EINVAL;
+        goto done;
+    }
+
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(INFO, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+
+    CmdSize = S_DS_GEN + sizeof(HostCmd_DS_POWER_MGMT_EXT);
+
+    cmd = (HostCmd_DS_COMMAND *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HOST_CMD_POWER_MGMT_EXT);
+    if (!pm_cfg.flags) {
+        cmd->params.pm_cfg.action = uap_cpu_to_le16(ACTION_GET);
+    } else {
+        cmd->params.pm_cfg.action = uap_cpu_to_le16(ACTION_SET);
+        cmd->params.pm_cfg.power_mode = uap_cpu_to_le16(pm_cfg.ps_mode);
+        tlv = (u8 *) & cmd->params.pm_cfg + sizeof(HostCmd_DS_POWER_MGMT_EXT);
+
+        if ((pm_cfg.ps_mode) && (pm_cfg.flags & PS_FLAG_SLEEP_PARAM)) {
+            sleep_tlv = (MrvlIEtypes_sleep_param_t *) tlv;
+            sleep_tlv->header.Type = uap_cpu_to_le16(TLV_TYPE_AP_SLEEP_PARAM);
+            sleep_tlv->header.Len =
+                uap_cpu_to_le16(sizeof(MrvlIEtypes_sleep_param_t) -
+                                sizeof(MrvlIEtypesHeader_t));
+            sleep_tlv->ctrl_bitmap =
+                uap_cpu_to_le32(pm_cfg.sleep_param.ctrl_bitmap);
+            sleep_tlv->min_sleep =
+                uap_cpu_to_le32(pm_cfg.sleep_param.min_sleep);
+            sleep_tlv->max_sleep =
+                uap_cpu_to_le32(pm_cfg.sleep_param.max_sleep);
+            CmdSize += sizeof(MrvlIEtypes_sleep_param_t);
+            tlv += sizeof(MrvlIEtypes_sleep_param_t);
+        }
+        if ((pm_cfg.ps_mode == PS_MODE_INACTIVITY) &&
+            (pm_cfg.flags & PS_FLAG_INACT_SLEEP_PARAM)) {
+            inact_tlv = (MrvlIEtypes_inact_sleep_param_t *) tlv;
+            inact_tlv->header.Type =
+                uap_cpu_to_le16(TLV_TYPE_AP_INACT_SLEEP_PARAM);
+            inact_tlv->header.Len =
+                uap_cpu_to_le16(sizeof(MrvlIEtypes_inact_sleep_param_t) -
+                                sizeof(MrvlIEtypesHeader_t));
+            inact_tlv->inactivity_to =
+                uap_cpu_to_le32(pm_cfg.inact_param.inactivity_to);
+            inact_tlv->min_awake =
+                uap_cpu_to_le32(pm_cfg.inact_param.min_awake);
+            inact_tlv->max_awake =
+                uap_cpu_to_le32(pm_cfg.inact_param.max_awake);
+            CmdSize += sizeof(MrvlIEtypes_inact_sleep_param_t);
+            tlv += sizeof(MrvlIEtypes_inact_sleep_param_t);
+        }
+    }
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP)) {
+        PRINTM(ERROR, "Fail to process cmd POWER_MODE\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    if (!Adapter->CmdSize) {
+        PRINTM(ERROR, "Cmd Size is 0\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    cmd = (HostCmd_DS_COMMAND *) Adapter->CmdBuf;
+    cmd->Result = uap_le16_to_cpu(cmd->Result);
+    if (cmd->Result != UAP_STATUS_SUCCESS) {
+        PRINTM(ERROR, "HOST_CMD_APCMD_POWER_MODE fail=%x\n", cmd->Result);
+        ret = -EFAULT;
+        goto done;
+    }
+    if (pm_cfg.flags) {
+        Adapter->psmode = uap_le16_to_cpu(cmd->params.pm_cfg.power_mode);
+    } else {
+        pm_cfg.flags = PS_FLAG_PS_MODE;
+        pm_cfg.ps_mode = uap_le16_to_cpu(cmd->params.pm_cfg.power_mode);
+        tlv_buf_left =
+            cmd->Size - (sizeof(HostCmd_DS_POWER_MGMT_EXT) + S_DS_GEN);
+        tlvbuf =
+            (MrvlIEtypesHeader_t *) ((u8 *) & cmd->params.pm_cfg +
+                                     sizeof(HostCmd_DS_POWER_MGMT_EXT));
+        while (tlv_buf_left >= sizeof(MrvlIEtypesHeader_t)) {
+            tlv_type = uap_le16_to_cpu(tlvbuf->Type);
+            tlv_len = uap_le16_to_cpu(tlvbuf->Len);
+            switch (tlv_type) {
+            case TLV_TYPE_AP_SLEEP_PARAM:
+                sleep_tlv = (MrvlIEtypes_sleep_param_t *) tlvbuf;
+                pm_cfg.flags |= PS_FLAG_SLEEP_PARAM;
+                pm_cfg.sleep_param.ctrl_bitmap =
+                    uap_le32_to_cpu(sleep_tlv->ctrl_bitmap);
+                pm_cfg.sleep_param.min_sleep =
+                    uap_le32_to_cpu(sleep_tlv->min_sleep);
+                pm_cfg.sleep_param.max_sleep =
+                    uap_le32_to_cpu(sleep_tlv->max_sleep);
+                break;
+            case TLV_TYPE_AP_INACT_SLEEP_PARAM:
+                inact_tlv = (MrvlIEtypes_inact_sleep_param_t *) tlvbuf;
+                pm_cfg.flags |= PS_FLAG_INACT_SLEEP_PARAM;
+                pm_cfg.inact_param.inactivity_to =
+                    uap_le32_to_cpu(inact_tlv->inactivity_to);
+                pm_cfg.inact_param.min_awake =
+                    uap_le32_to_cpu(inact_tlv->min_awake);
+                pm_cfg.inact_param.max_awake =
+                    uap_le32_to_cpu(inact_tlv->max_awake);
+                break;
+            }
+            tlv_buf_left -= tlv_len + sizeof(MrvlIEtypesHeader_t);
+            tlvbuf =
+                (MrvlIEtypesHeader_t *) ((u8 *) tlvbuf + tlv_len +
+                                         sizeof(MrvlIEtypesHeader_t));
+        }
+        /* Copy to user */
+        if (copy_to_user(req->ifr_data, &pm_cfg, sizeof(ps_mgmt))) {
+            PRINTM(ERROR, "Copy to user failed!\n");
+            LEAVE();
+            return -EFAULT;
+        }
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function send bss_stop command to firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS on success, otherwise failure code
+ */
+static int
+uap_bss_stop(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u32 CmdSize;
+    HostCmd_DS_GEN *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+    ENTER();
+    if (Adapter->HardwareStatus != HWReady) {
+        PRINTM(ERROR, "uap_bss_stop:Hardware is not ready!\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+    CmdSize = sizeof(HostCmd_DS_GEN);
+    cmd = (HostCmd_DS_GEN *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HOST_CMD_APCMD_BSS_STOP);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    PRINTM(CMND, "APCMD_BSS_STOP\n");
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP_TIMEOUT)) {
+        PRINTM(ERROR, "Fail to process cmd BSS_STOP\n");
+        ret = -EFAULT;
+        goto done;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/**
+ *  @brief This function send soft_reset command to firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS on success, otherwise failure code
+ */
+int
+uap_soft_reset(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u32 CmdSize;
+    HostCmd_DS_GEN *cmd;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+    ENTER();
+    ret = uap_bss_stop(priv);
+    if (ret != UAP_STATUS_SUCCESS)
+        goto done;
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        ret = -ENOMEM;
+        goto done;
+    }
+    CmdSize = sizeof(HostCmd_DS_GEN);
+    cmd = (HostCmd_DS_GEN *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HOST_CMD_APCMD_SOFT_RESET);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    PRINTM(CMND, "APCMD_SOFT_RESET\n");
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORSEND)) {
+        PRINTM(ERROR, "Fail to process cmd SOFT_RESET\n");
+        ret = -EFAULT;
+        goto done;
+    }
+    Adapter->SurpriseRemoved = TRUE;
+    /* delay to allow hardware complete reset */
+    os_sched_timeout(5);
+    if (priv->MediaConnected == TRUE) {
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+        priv->MediaConnected = FALSE;
+    }
+    Adapter->CmdSize = 0;
+    Adapter->CmdWaitQWoken = TRUE;
+    wake_up_interruptible(&Adapter->cmdwait_q);
+    skb_queue_purge(&priv->adapter->tx_queue);
+    skb_queue_purge(&priv->adapter->cmd_queue);
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function processes received packet and forwards it
+ *  to kernel/upper layer
+ *
+ *  @param priv    A pointer to uap_private
+ *  @param skb     A pointer to skb which includes the received packet
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+uap_process_rx_packet(uap_private * priv, struct sk_buff *skb)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    RxPD *pRxPD;
+    ENTER();
+    priv->adapter->ps_state = PS_STATE_AWAKE;
+    pRxPD = (RxPD *) skb->data;
+    endian_convert_RxPD(pRxPD);
+    DBG_HEXDUMP(DAT_D, "Rx", skb->data, MIN(skb->len, DATA_DUMP_LEN));
+    skb_pull(skb, pRxPD->RxPktOffset);
+    priv->stats.rx_packets++;
+    priv->stats.rx_bytes += skb->len;
+    os_upload_rx_packet(priv, skb);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function opens the network device
+ *
+ *  @param dev     A pointer to net_device structure
+ *  @return        UAP_STATUS_SUCCESS
+ */
+static int
+uap_open(struct net_device *dev)
+{
+    uap_private *priv = (uap_private *) (uap_private *) netdev_priv(dev);
+    uap_adapter *Adapter = priv->adapter;
+    int i = 0;
+
+    ENTER();
+
+    /* On some systems the device open handler will be called before HW ready. */
+    /* Use the following flag check and wait function to work around the issue. */
+    while ((Adapter->HardwareStatus != HWReady) &&
+           (i < MAX_WAIT_DEVICE_READY_COUNT)) {
+        i++;
+        os_sched_timeout(100);
+    }
+    if (i >= MAX_WAIT_DEVICE_READY_COUNT) {
+        PRINTM(FATAL, "HW not ready, uap_open() return failure\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    if (MODULE_GET == 0)
+        return UAP_STATUS_FAILURE;
+
+    priv->open = TRUE;
+    if (priv->MediaConnected == TRUE) {
+        os_carrier_on(priv);
+        os_start_queue(priv);
+    } else {
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+    }
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function closes the network device
+ *
+ *  @param dev     A pointer to net_device structure
+ *  @return        UAP_STATUS_SUCCESS
+ */
+static int
+uap_close(struct net_device *dev)
+{
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+
+    ENTER();
+    skb_queue_purge(&priv->adapter->tx_queue);
+    os_stop_queue(priv);
+    os_carrier_off(priv);
+
+    MODULE_PUT;
+    priv->open = FALSE;
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function returns the network statistics
+ *
+ *  @param dev     A pointer to uap_private structure
+ *  @return        A pointer to net_device_stats structure
+ */
+static struct net_device_stats *
+uap_get_stats(struct net_device *dev)
+{
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+
+    return &priv->stats;
+}
+
+/**
+ *  @brief This function sets the MAC address to firmware.
+ *
+ *  @param dev     A pointer to uap_private structure
+ *  @param addr    MAC address to set
+ *  @return        UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_set_mac_address(struct net_device *dev, void *addr)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+    struct sockaddr *pHwAddr = (struct sockaddr *) addr;
+    u32 CmdSize;
+    HostCmd_DS_COMMAND *cmd;
+    MrvlIEtypes_MacAddr_t *pMacAddrTlv;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb;
+
+    ENTER();
+
+    /* Dump MAC address */
+    DBG_HEXDUMP(CMD_D, "Original MAC addr", dev->dev_addr, ETH_ALEN);
+    DBG_HEXDUMP(CMD_D, "New MAC addr", pHwAddr->sa_data, ETH_ALEN);
+    if (priv->open && (priv->MediaConnected == TRUE)) {
+        os_carrier_on(priv);
+        os_start_queue(priv);
+    }
+    skb = dev_alloc_skb(MRVDRV_SIZE_OF_CMD_BUFFER);
+    if (!skb) {
+        PRINTM(ERROR, "No free skb\n");
+        LEAVE();
+        return -ENOMEM;
+    }
+    CmdSize =
+        S_DS_GEN + sizeof(HostCmd_SYS_CONFIG) + sizeof(MrvlIEtypes_MacAddr_t);
+    cmd = (HostCmd_DS_COMMAND *) (skb->data + INTF_HEADER_LEN);
+    cmd->Command = uap_cpu_to_le16(HOST_CMD_APCMD_SYS_CONFIGURE);
+    cmd->Size = uap_cpu_to_le16(CmdSize);
+    cmd->params.sys_config.Action = uap_cpu_to_le16(ACTION_SET);
+    pMacAddrTlv =
+        (MrvlIEtypes_MacAddr_t *) ((u8 *) cmd + S_DS_GEN +
+                                   sizeof(HostCmd_SYS_CONFIG));
+    pMacAddrTlv->Header.Type = uap_cpu_to_le16(MRVL_AP_MAC_ADDRESS_TLV_ID);
+    pMacAddrTlv->Header.Len = uap_cpu_to_le16(ETH_ALEN);
+    memcpy(pMacAddrTlv->ApMacAddr, pHwAddr->sa_data, ETH_ALEN);
+    skb_put(skb, CmdSize + INTF_HEADER_LEN);
+    PRINTM(CMND, "set_mac_address\n");
+    if (UAP_STATUS_SUCCESS !=
+        uap_process_cmd(priv, skb, HostCmd_OPTION_WAITFORRSP_TIMEOUT)) {
+        PRINTM(ERROR, "Fail to set mac address\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    if (!Adapter->CmdSize) {
+        PRINTM(ERROR, "Cmd Size is 0\n");
+        LEAVE();
+        return -EFAULT;
+    }
+    cmd = (HostCmd_DS_COMMAND *) Adapter->CmdBuf;
+    cmd->Result = uap_cpu_to_le16(cmd->Result);
+    if (cmd->Result != UAP_STATUS_SUCCESS) {
+        PRINTM(ERROR, "set mac addrress fail,cmd result=%x\n", cmd->Result);
+        ret = -EFAULT;
+    } else
+        memcpy(dev->dev_addr, pHwAddr->sa_data, ETH_ALEN);
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function sets multicast addresses to firmware
+ *
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+uap_set_multicast_list(struct net_device *dev)
+{
+    ENTER();
+#warning uap_set_multicast_list not implemented. Expect problems with IPv6.
+    LEAVE();
+}
+
+/**
+ *  @brief This function handles the timeout of packet
+ *  transmission
+ *
+ *  @param dev     A pointer to net_device structure
+ *  @return        n/a
+ */
+static void
+uap_tx_timeout(struct net_device *dev)
+{
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+
+    ENTER();
+
+    PRINTM(DATA, "Tx timeout\n");
+    UpdateTransStart(dev);
+    priv->num_tx_timeout++;
+    priv->adapter->IntCounter++;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    LEAVE();
+}
+
+/**
+ *  @brief This function handles packet transmission
+ *
+ *  @param skb     A pointer to sk_buff structure
+ *  @param dev     A pointer to net_device structure
+ *  @return        UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+    uap_private *priv = (uap_private *) netdev_priv(dev);
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+    PRINTM(DATA, "Data <= kernel\n");
+    DBG_HEXDUMP(DAT_D, "Tx", skb->data, MIN(skb->len, DATA_DUMP_LEN));
+    /* skb sanity check */
+    if (!skb->len || (skb->len > MRVDRV_MAXIMUM_ETH_PACKET_SIZE)) {
+        PRINTM(ERROR, "Tx Error: Bad skb length %d : %d\n", skb->len,
+               MRVDRV_MAXIMUM_ETH_PACKET_SIZE);
+        priv->stats.tx_dropped++;
+        kfree(skb);
+        goto done;
+    }
+    skb_queue_tail(&priv->adapter->tx_queue, skb);
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    if (skb_queue_len(&priv->adapter->tx_queue) > TX_HIGH_WATERMARK) {
+        UpdateTransStart(dev);
+        os_stop_queue(priv);
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief ioctl function - entry point
+ *
+ *  @param dev      A pointer to net_device structure
+ *  @param req      A pointer to ifreq structure
+ *  @param cmd      command
+ *  @return         UAP_STATUS_SUCCESS--success, otherwise fail
+ */
+static int
+uap_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+{
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+
+    PRINTM(CMND, "uap_do_ioctl: ioctl cmd = 0x%x\n", cmd);
+
+    switch (cmd) {
+    case UAPHOSTCMD:
+        ret = uap_hostcmd_ioctl(dev, req);
+        break;
+    case UAP_POWER_MODE:
+        ret = uap_power_mode_ioctl(dev, req);
+        break;
+    default:
+        ret = -EINVAL;
+        break;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles events generated by firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param payload A pointer to payload buffer
+ *  @param len	   Length of the payload
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+uap_process_event(uap_private * priv, u8 * payload, uint len)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    uap_adapter *Adapter = priv->adapter;
+    struct sk_buff *skb = NULL;
+    struct nlmsghdr *nlh = NULL;
+    struct sock *sk = Adapter->nl_sk;
+    AP_Event *pEvent;
+
+    ENTER();
+    Adapter->ps_state = PS_STATE_AWAKE;
+    if (len > NL_MAX_PAYLOAD) {
+        PRINTM(ERROR, "event size is too big!!! len=%d\n", len);
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+    pEvent = (AP_Event *) payload;
+    PRINTM(CMND, "Event: %d\n", pEvent->EventId);
+    switch (pEvent->EventId) {
+    case MICRO_AP_EV_ID_BSS_START:
+        memcpy(priv->uap_dev.netdev->dev_addr, pEvent->MacAddr, ETH_ALEN);
+        DBG_HEXDUMP(CMD_D, "BSS MAC addr", priv->uap_dev.netdev->dev_addr,
+                    ETH_ALEN);
+        break;
+    case MICRO_AP_EV_BSS_ACTIVE:
+        // carrier on
+        priv->MediaConnected = TRUE;
+        os_carrier_on(priv);
+        os_start_queue(priv);
+        break;
+    case MICRO_AP_EV_BSS_IDLE:
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+        priv->MediaConnected = FALSE;
+        break;
+    case EVENT_PS_AWAKE:
+        PRINTM(CMND, "UAP: PS_AWAKE\n");
+        Adapter->ps_state = PS_STATE_AWAKE;
+        Adapter->WakeupTries = 0;
+        break;
+    case EVENT_PS_SLEEP:
+        PRINTM(CMND, "UAP: PS_SLEEP\n");
+        Adapter->ps_state = PS_STATE_PRE_SLEEP;
+        break;
+    default:
+        break;
+    }
+    if ((pEvent->EventId == EVENT_PS_AWAKE) ||
+        (pEvent->EventId == EVENT_PS_SLEEP))
+        goto done;
+    if (sk) {
+        /* Allocate skb */
+        if (!(skb = alloc_skb(NLMSG_SPACE(NL_MAX_PAYLOAD), GFP_ATOMIC))) {
+            PRINTM(ERROR, "Could not allocate skb for netlink.\n");
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        nlh = (struct nlmsghdr *) skb->data;
+        nlh->nlmsg_len = NLMSG_SPACE(len);
+
+        /* From kernel */
+        nlh->nlmsg_pid = 0;
+        nlh->nlmsg_flags = 0;
+
+        /* Data */
+        skb_put(skb, nlh->nlmsg_len);
+        memcpy(NLMSG_DATA(nlh), payload, len);
+
+        /* From Kernel */
+        NETLINK_CB(skb).pid = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        /* Multicast message */
+        NETLINK_CB(skb).dst_pid = 0;
+#endif
+
+        /* Multicast group number */
+        NETLINK_CB(skb).dst_group = NL_MULTICAST_GROUP;
+
+        /* Send message */
+        netlink_broadcast(sk, skb, 0, NL_MULTICAST_GROUP, GFP_KERNEL);
+
+        ret = UAP_STATUS_SUCCESS;
+    } else {
+        PRINTM(ERROR, "Could not send event through NETLINK. Link down.\n");
+        ret = UAP_STATUS_FAILURE;
+    }
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function handles the interrupt. it will change PS
+ *  state if applicable. it will wake up main_thread to handle
+ *  the interrupt event as well.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return        n/a
+ */
+void
+uap_interrupt(uap_private * priv)
+{
+    ENTER();
+    priv->adapter->IntCounter++;
+    priv->adapter->WakeupTries = 0;
+    PRINTM(INFO, "*\n");
+    wake_up_interruptible(&priv->MainThread.waitQ);
+
+    LEAVE();
+
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+/** Network device handlers */
+static const struct net_device_ops uap_netdev_ops = {
+    .ndo_open = uap_open,
+    .ndo_start_xmit = uap_hard_start_xmit,
+    .ndo_stop = uap_close,
+    .ndo_do_ioctl = uap_do_ioctl,
+    .ndo_set_mac_address = uap_set_mac_address,
+    .ndo_tx_timeout = uap_tx_timeout,
+    .ndo_get_stats = uap_get_stats,
+    .ndo_set_multicast_list = uap_set_multicast_list,
+};
+#endif
+
+/**
+ * @brief This function adds the card. it will probe the
+ * card, allocate the uap_priv and initialize the device.
+ *
+ *  @param card    A pointer to card
+ *  @return        A pointer to uap_private structure
+ */
+uap_private *
+uap_add_card(void *card)
+{
+    struct net_device *dev = NULL;
+    uap_private *priv = NULL;
+
+    ENTER();
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&AddRemoveCardSem))
+        goto exit_sem_err;
+
+    /* Allocate an Ethernet device */
+    if (!(dev = alloc_etherdev(sizeof(uap_private)))) {
+        PRINTM(FATAL, "Init ethernet device failed!\n");
+        goto error;
+    }
+    priv = (uap_private *) netdev_priv(dev);
+
+    /* Allocate name */
+    if (dev_alloc_name(dev, "uap%d") < 0) {
+        PRINTM(ERROR, "Could not allocate device name!\n");
+        goto error;
+    }
+
+    /* Allocate buffer for uap_adapter */
+    if (!(priv->adapter = kmalloc(sizeof(uap_adapter), GFP_KERNEL))) {
+        PRINTM(FATAL, "Allocate buffer for uap_adapter failed!\n");
+        goto error;
+    }
+    memset(priv->adapter, 0, sizeof(uap_adapter));
+
+    priv->uap_dev.netdev = dev;
+    priv->uap_dev.card = card;
+    priv->MediaConnected = FALSE;
+    uappriv = priv;
+    ((struct sdio_mmc_card *) card)->priv = priv;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+    SET_MODULE_OWNER(dev);
+#endif
+
+    /* Setup the OS Interface to our functions */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+    dev->open = uap_open;
+    dev->stop = uap_close;
+    dev->hard_start_xmit = uap_hard_start_xmit;
+    dev->tx_timeout = uap_tx_timeout;
+    dev->get_stats = uap_get_stats;
+    dev->do_ioctl = uap_do_ioctl;
+    dev->set_mac_address = uap_set_mac_address;
+    dev->set_multicast_list = uap_set_multicast_list;
+#else
+    dev->netdev_ops = &uap_netdev_ops;
+#endif
+    dev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+    dev->hard_header_len += sizeof(TxPD) + INTF_HEADER_LEN;
+    dev->hard_header_len += HEADER_ALIGNMENT;
+#define NETIF_F_DYNALLOC 16
+    dev->features |= NETIF_F_DYNALLOC;
+    dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+
+    /* Init SW */
+    if (uap_init_sw(priv)) {
+        PRINTM(FATAL, "Software Init Failed\n");
+        goto error;
+    }
+
+    PRINTM(INFO, "Starting kthread...\n");
+    priv->MainThread.priv = priv;
+    spin_lock_init(&priv->driver_lock);
+    uap_create_thread(uap_service_main_thread, &priv->MainThread,
+                      "uap_main_service");
+    while (priv->MainThread.pid == 0) {
+        os_sched_timeout(2);
+    }
+
+    /* Register the device */
+    if (sbi_register_dev(priv) < 0) {
+        PRINTM(FATAL, "Failed to register uap device!\n");
+        goto err_registerdev;
+    }
+#ifdef FW_DNLD_NEEDED
+    SET_NETDEV_DEV(dev, priv->hotplug_device);
+#endif
+
+    /* Init FW and HW */
+    if (uap_init_fw(priv)) {
+        PRINTM(FATAL, "Firmware Init Failed\n");
+        goto err_init_fw;
+    }
+
+    priv->uap_dev.cmd_sent = FALSE;
+    priv->uap_dev.data_sent = FALSE;
+
+    /* Get mac address from firmware */
+    if (uap_get_mac_address(priv)) {
+        PRINTM(FATAL, "Fail to get mac address\n");
+        goto err_init_fw;
+    }
+    /* Register network device */
+    if (register_netdev(dev)) {
+        printk(KERN_ERR "Cannot register network device!\n");
+        goto err_init_fw;
+    }
+#ifdef CONFIG_PROC_FS
+    uap_proc_entry(priv, dev);
+    uap_debug_entry(priv, dev);
+#endif /* CPNFIG_PROC_FS */
+    OS_REL_SEMAPHORE(&AddRemoveCardSem);
+
+    LEAVE();
+    return priv;
+  err_init_fw:
+    sbi_unregister_dev(priv);
+  err_registerdev:
+    ((struct sdio_mmc_card *) card)->priv = NULL;
+    /* Stop the thread servicing the interrupts */
+    priv->adapter->SurpriseRemoved = TRUE;
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+  error:
+    if (dev) {
+        if (dev->reg_state == NETREG_REGISTERED)
+            unregister_netdev(dev);
+        if (priv->adapter)
+            uap_free_adapter(priv);
+        free_netdev(dev);
+        uappriv = NULL;
+    }
+    OS_REL_SEMAPHORE(&AddRemoveCardSem);
+  exit_sem_err:
+    LEAVE();
+    return NULL;
+}
+
+/**
+ *  @brief This function removes the card.
+ *
+ *  @param card    A pointer to card
+ *  @return        UAP_STATUS_SUCCESS
+ */
+int
+uap_remove_card(void *card)
+{
+    uap_private *priv = uappriv;
+    uap_adapter *Adapter;
+    struct net_device *dev;
+
+    ENTER();
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&AddRemoveCardSem))
+        goto exit_sem_err;
+
+    if (!priv || !(Adapter = priv->adapter)) {
+        goto exit_remove;
+    }
+    Adapter->SurpriseRemoved = TRUE;
+    if (Adapter->cmd_pending == TRUE) {
+        /* Wake up cmd Q */
+        Adapter->CmdWaitQWoken = TRUE;
+        wake_up_interruptible(&Adapter->cmdwait_q);
+    }
+    dev = priv->uap_dev.netdev;
+    if (priv->MediaConnected == TRUE) {
+        os_stop_queue(priv);
+        os_carrier_off(priv);
+        priv->MediaConnected = FALSE;
+    }
+    Adapter->CmdSize = 0;
+    Adapter->CmdWaitQWoken = TRUE;
+    wake_up_interruptible(&Adapter->cmdwait_q);
+    skb_queue_purge(&priv->adapter->tx_queue);
+    skb_queue_purge(&priv->adapter->cmd_queue);
+
+    /* Disable interrupts on the card */
+    sbi_disable_host_int(priv);
+    PRINTM(INFO, "netdev_finish_unregister: %s%s.\n", dev->name,
+           (dev->features & NETIF_F_DYNALLOC) ? "" : ", old style");
+    unregister_netdev(dev);
+    PRINTM(INFO, "Unregister finish\n");
+    wake_up_interruptible(&priv->MainThread.waitQ);
+    while (priv->MainThread.pid) {
+        os_sched_timeout(1);
+    }
+
+    if ((Adapter->nl_sk) && ((Adapter->nl_sk)->sk_socket)) {
+        sock_release((Adapter->nl_sk)->sk_socket);
+        Adapter->nl_sk = NULL;
+    }
+#ifdef CONFIG_PROC_FS
+    uap_debug_remove(priv);
+    uap_proc_remove(priv);
+#endif
+    sbi_unregister_dev(priv);
+    PRINTM(INFO, "Free Adapter\n");
+    uap_free_adapter(priv);
+    priv->uap_dev.netdev = NULL;
+    free_netdev(dev);
+    uappriv = NULL;
+
+  exit_remove:
+    OS_REL_SEMAPHORE(&AddRemoveCardSem);
+  exit_sem_err:
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function initializes module.
+ *
+ *  @return    UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int __init
+uap_init_module(void)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    ENTER();
+
+    OS_INIT_SEMAPHORE(&AddRemoveCardSem);
+    ret = sbi_register();
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function cleans module
+ *
+ *  @return        n/a
+ */
+static void __exit
+uap_cleanup_module(void)
+{
+    ENTER();
+
+    if (OS_ACQ_SEMAPHORE_BLOCK(&AddRemoveCardSem))
+        goto exit_sem_err;
+
+    if ((uappriv) && (uappriv->adapter)) {
+        uap_func_shutdown(uappriv);
+    }
+    OS_REL_SEMAPHORE(&AddRemoveCardSem);
+  exit_sem_err:
+    sbi_unregister();
+    LEAVE();
+}
+
+module_init(uap_init_module);
+module_exit(uap_cleanup_module);
+module_param(helper_name, charp, 0);
+MODULE_PARM_DESC(helper_name, "Helper name");
+module_param(fw_name, charp, 0);
+MODULE_PARM_DESC(fw_name, "Firmware name");
+
+MODULE_DESCRIPTION("M-UAP Driver");
+MODULE_AUTHOR("Marvell International Ltd.");
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
diff -ruN a/drivers/net/wireless/libertas_uap/uap_proc.c b/drivers/net/wireless/libertas_uap/uap_proc.c
--- a/drivers/net/wireless/libertas_uap/uap_proc.c	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_proc.c	2013-09-16 01:27:45.927769030 -0600
@@ -0,0 +1,296 @@
+/** @file uap_proc.c
+  * @brief This file contains functions for proc file.
+  *
+  * Copyright (C) 2008-2009, Marvell International Ltd.
+  *
+  * This software file (the "File") is distributed by Marvell International
+  * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+  * (the "License").  You may use, redistribute and/or modify this File in
+  * accordance with the terms and conditions of the License, a copy of which
+  * is available along with the File in the gpl.txt file or by writing to
+  * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+  * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+  *
+  * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+  * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+  * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+  * this warranty disclaimer.
+  *
+  */
+#ifdef CONFIG_PROC_FS
+#include "uap_headers.h"
+
+/** /proc directory root */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define PROC_DIR NULL
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+#define PROC_DIR &proc_root
+#else
+#define PROC_DIR proc_net
+#endif
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/********************************************************
+		Global Variables
+********************************************************/
+
+/********************************************************
+		Local Functions
+********************************************************/
+
+/**
+ *  @brief proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param start   read data starting position
+ *  @param offset  offset
+ *  @param count   counter
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return 	   number of output data
+ */
+static int
+uap_proc_read(char *page, char **start, off_t offset,
+              int count, int *eof, void *data)
+{
+    int i;
+    char *p = page;
+    struct net_device *netdev = data;
+    struct netdev_hw_addr *ha;
+    char fmt[64];
+    uap_private *priv = (uap_private *) netdev_priv(netdev);
+
+    if (offset != 0) {
+        *eof = 1;
+        goto exit;
+    }
+
+    strcpy(fmt, DRIVER_VERSION);
+
+    p += sprintf(p, "driver_name = " "\"uap\"\n");
+    p += sprintf(p, "driver_version = %s-(FP%s)", fmt, FPNUM);
+    p += sprintf(p, "\nInterfaceName=\"%s\"\n", netdev->name);
+    p += sprintf(p, "State=\"%s\"\n",
+                 ((priv->MediaConnected ==
+                   FALSE) ? "Disconnected" : "Connected"));
+    p += sprintf(p, "MACAddress=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                 netdev->dev_addr[0], netdev->dev_addr[1], netdev->dev_addr[2],
+                 netdev->dev_addr[3], netdev->dev_addr[4], netdev->dev_addr[5]);
+    i = 0;
+    netdev_for_each_mc_addr(ha, netdev) {
+        ++i;
+    }
+    p += sprintf(p, "MCCount=\"%d\"\n", i);
+
+    /*
+     * Put out the multicast list
+     */
+    i = 0;
+    netdev_for_each_mc_addr(ha, netdev) {
+        p += sprintf(p,
+                     "MCAddr[%d]=\"%02x:%02x:%02x:%02x:%02x:%02x\"\n",
+                     i++,
+                     ha->addr[0], ha->addr[1],
+                     ha->addr[2], ha->addr[3],
+                     ha->addr[4], ha->addr[5]);
+    }
+
+    p += sprintf(p, "num_tx_bytes = %lu\n", priv->stats.tx_bytes);
+    p += sprintf(p, "num_rx_bytes = %lu\n", priv->stats.rx_bytes);
+    p += sprintf(p, "num_tx_pkts = %lu\n", priv->stats.tx_packets);
+    p += sprintf(p, "num_rx_pkts = %lu\n", priv->stats.rx_packets);
+    p += sprintf(p, "num_tx_pkts_dropped = %lu\n", priv->stats.tx_dropped);
+    p += sprintf(p, "num_rx_pkts_dropped = %lu\n", priv->stats.rx_dropped);
+    p += sprintf(p, "num_tx_pkts_err = %lu\n", priv->stats.tx_errors);
+    p += sprintf(p, "num_rx_pkts_err = %lu\n", priv->stats.rx_errors);
+    p += sprintf(p, "num_tx_timeout = %u\n", priv->num_tx_timeout);
+    p += sprintf(p, "carrier %s\n",
+                 ((netif_carrier_ok(priv->uap_dev.netdev)) ? "on" : "off"));
+    p += sprintf(p, "tx queue %s\n",
+                 ((netif_queue_stopped(priv->uap_dev.netdev)) ? "stopped" :
+                  "started"));
+
+  exit:
+    return (p - page);
+}
+
+/**
+ *  @brief hwstatus proc write function
+ *
+ *  @param f	   file pointer
+ *  @param buf     pointer to data buffer
+ *  @param cnt     data number to write
+ *  @param data    data to write
+ *  @return	   number of data
+ */
+static int
+uap_hwstatus_write(struct file *f, const char *buf, unsigned long cnt,
+                   void *data)
+{
+    struct net_device *netdev = data;
+    uap_private *priv = (uap_private *) netdev_priv(netdev);
+    char databuf[10];
+    int hwstatus;
+    MODULE_GET;
+    if (cnt > 10) {
+        MODULE_PUT;
+        return cnt;
+    }
+    if (copy_from_user(databuf, buf, cnt)) {
+        MODULE_PUT;
+        return 0;
+    }
+    hwstatus = string_to_number(databuf);
+    switch (hwstatus) {
+    case HWReset:
+        PRINTM(MSG, "reset hw\n");
+        uap_soft_reset(priv);
+        priv->adapter->HardwareStatus = HWReset;
+        break;
+    default:
+        break;
+    }
+    MODULE_PUT;
+    return cnt;
+}
+
+/**
+ *  @brief hwstatus proc read function
+ *
+ *  @param page	   pointer to buffer
+ *  @param s       read data starting position
+ *  @param off     offset
+ *  @param cnt     counter
+ *  @param eof     end of file flag
+ *  @param data    data to output
+ *  @return	   number of output data
+ */
+static int
+uap_hwstatus_read(char *page, char **s, off_t off, int cnt, int *eof,
+                  void *data)
+{
+    char *p = page;
+    struct net_device *netdev = data;
+    uap_private *priv = (uap_private *) netdev_priv(netdev);
+    MODULE_GET;
+    p += sprintf(p, "%d\n", priv->adapter->HardwareStatus);
+    MODULE_PUT;
+    return p - page;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+/**
+ *  @brief create uap proc file
+ *
+ *  @param priv	   pointer uap_private
+ *  @param dev     pointer net_device
+ *  @return	   N/A
+ */
+void
+uap_proc_entry(uap_private * priv, struct net_device *dev)
+{
+    struct proc_dir_entry *r = PROC_DIR;
+
+    PRINTM(INFO, "Creating Proc Interface\n");
+    /* Check if uap directory already exists */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+    for (r = r->subdir; r; r = r->next) {
+        if (r->namelen && !strcmp("uap", r->name)) {
+            /* Directory exists */
+            PRINTM(WARN, "proc directory already exists!\n");
+            priv->proc_uap = r;
+            break;
+        }
+    }
+#endif
+    if (!priv->proc_uap) {
+        priv->proc_uap = proc_mkdir("uap", PROC_DIR);
+        if (!priv->proc_uap)
+            return;
+        else
+            atomic_set(&priv->proc_uap->count, 1);
+    } else {
+        atomic_inc(&priv->proc_uap->count);
+    }
+    priv->proc_entry = proc_mkdir(dev->name, priv->proc_uap);
+
+    if (priv->proc_entry) {
+        r = create_proc_read_entry("info", 0, priv->proc_entry, uap_proc_read,
+                                   dev);
+        r = create_proc_entry("hwstatus", 0644, priv->proc_entry);
+        if (r) {
+            r->data = dev;
+            r->read_proc = uap_hwstatus_read;
+            r->write_proc = uap_hwstatus_write;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
+            r->owner = THIS_MODULE;
+#endif
+        } else
+            PRINTM(MSG, "Fail to create proc hwstatus\n");
+    }
+}
+
+/**
+ *  @brief remove proc file
+ *
+ *  @param priv	   pointer uap_private
+ *  @return	   N/A
+ */
+void
+uap_proc_remove(uap_private * priv)
+{
+    if (priv->proc_uap) {
+        if (priv->proc_entry) {
+            remove_proc_entry("info", priv->proc_entry);
+            remove_proc_entry("hwstatus", priv->proc_entry);
+        }
+        remove_proc_entry(priv->uap_dev.netdev->name, priv->proc_uap);
+        atomic_dec(&priv->proc_uap->count);
+        if (atomic_read(&(priv->proc_uap->count)) == 0)
+            remove_proc_entry("uap", PROC_DIR);
+    }
+}
+
+/**
+ *  @brief convert string to number
+ *
+ *  @param s	   pointer to numbered string
+ *  @return	   converted number from string s
+ */
+int
+string_to_number(char *s)
+{
+    int r = 0;
+    int base = 0;
+    int pn = 1;
+
+    if (strncmp(s, "-", 1) == 0) {
+        pn = -1;
+        s++;
+    }
+    if ((strncmp(s, "0x", 2) == 0) || (strncmp(s, "0X", 2) == 0)) {
+        base = 16;
+        s += 2;
+    } else
+        base = 10;
+
+    for (s = s; *s != 0; s++) {
+        if ((*s >= '0') && (*s <= '9'))
+            r = (r * base) + (*s - '0');
+        else if ((*s >= 'A') && (*s <= 'F'))
+            r = (r * base) + (*s - 'A' + 10);
+        else if ((*s >= 'a') && (*s <= 'f'))
+            r = (r * base) + (*s - 'a' + 10);
+        else
+            break;
+    }
+
+    return (r * pn);
+}
+
+#endif
diff -ruN a/drivers/net/wireless/libertas_uap/uap_sdio_mmc.c b/drivers/net/wireless/libertas_uap/uap_sdio_mmc.c
--- a/drivers/net/wireless/libertas_uap/uap_sdio_mmc.c	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_sdio_mmc.c	2013-09-16 01:27:45.937768903 -0600
@@ -0,0 +1,1428 @@
+/** @file uap_sdio_mmc.c
+ *  @brief This file contains SDIO IF (interface) module
+ *  related functions.
+ *
+ * Copyright (C) 2007-2009, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available along with the File in the gpl.txt file or by writing to
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+****************************************************/
+
+#include	"uap_sdio_mmc.h"
+
+#include <linux/firmware.h>
+
+/** define SDIO block size */
+/* We support up to 480-byte block size due to FW buffer limitation. */
+#define SD_BLOCK_SIZE		256
+
+/** define allocated buffer size */
+#define ALLOC_BUF_SIZE		(((MAX(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, \
+					MRVDRV_SIZE_OF_CMD_BUFFER) + INTF_HEADER_LEN \
+					+ SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE) * SD_BLOCK_SIZE)
+
+/** Max retry number of CMD53 write */
+#define MAX_WRITE_IOMEM_RETRY	2
+
+/********************************************************
+		Local Variables
+********************************************************/
+
+/** SDIO Rx unit */
+static u8 sdio_rx_unit = 0;
+
+/**Interrupt status */
+static u8 sd_ireg = 0;
+/********************************************************
+		Global Variables
+********************************************************/
+extern u8 *helper_name;
+extern u8 *fw_name;
+/** Default helper name */
+#define DEFAULT_HELPER_NAME "mrvl/helper_sd.bin"
+/** Default firmware name */
+#define DEFAULT_FW_NAME "mrvl/sd8688_ap.bin"
+
+/********************************************************
+		Local Functions
+********************************************************/
+/**
+ *  @brief This function reads the IO register.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param reg	   register to be read
+ *  @param dat	   A pointer to variable that keeps returned value
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sbi_read_ioreg(uap_private * priv, u32 reg, u8 * dat)
+{
+    struct sdio_mmc_card *card;
+    int ret = UAP_STATUS_FAILURE;
+
+    ENTER();
+
+    card = priv->uap_dev.card;
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_read_ioreg(): card or function is NULL!\n");
+        goto done;
+    }
+
+    *dat = sdio_readb(card->func, reg, &ret);
+    if (ret) {
+        PRINTM(ERROR, "sbi_read_ioreg(): sdio_readb failed! ret=%d\n", ret);
+        goto done;
+    }
+
+    PRINTM(INFO, "sbi_read_ioreg() priv=%p func=%d reg=%#x dat=%#x\n", priv,
+           card->func->num, reg, *dat);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function writes the IO register.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param reg	   register to be written
+ *  @param dat	   the value to be written
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sbi_write_ioreg(uap_private * priv, u32 reg, u8 dat)
+{
+    struct sdio_mmc_card *card;
+    int ret = UAP_STATUS_FAILURE;
+
+    ENTER();
+
+    card = priv->uap_dev.card;
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_write_ioreg(): card or function is NULL!\n");
+        goto done;
+    }
+
+    PRINTM(INFO, "sbi_write_ioreg() priv=%p func=%d reg=%#x dat=%#x\n", priv,
+           card->func->num, reg, dat);
+
+    sdio_writeb(card->func, dat, reg, &ret);
+    if (ret) {
+        PRINTM(ERROR, "sbi_write_ioreg(): sdio_readb failed! ret=%d\n", ret);
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function get rx_unit value
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sd_get_rx_unit(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u8 reg;
+
+    ENTER();
+
+    ret = sbi_read_ioreg(priv, CARD_RX_UNIT_REG, &reg);
+    if (ret == UAP_STATUS_SUCCESS)
+        sdio_rx_unit = reg;
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function reads rx length
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sd_read_rx_len(uap_private * priv, u16 * dat)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u8 reg;
+
+    ENTER();
+
+    ret = sbi_read_ioreg(priv, CARD_RX_LEN_REG, &reg);
+    if (ret == UAP_STATUS_SUCCESS)
+        *dat = (u16) reg << sdio_rx_unit;
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function reads fw status registers
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param dat	   A pointer to keep returned data
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sd_read_firmware_status(uap_private * priv, u16 * dat)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u8 fws0;
+    u8 fws1;
+
+    ENTER();
+
+    ret = sbi_read_ioreg(priv, CARD_FW_STATUS0_REG, &fws0);
+    if (ret < 0) {
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    ret = sbi_read_ioreg(priv, CARD_FW_STATUS1_REG, &fws1);
+    if (ret < 0) {
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    *dat = (((u16) fws1) << 8) | fws0;
+
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function polls the card status register.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @param bits    	the bit mask
+ *  @return 	   	UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+mv_sdio_poll_card_status(uap_private * priv, u8 bits)
+{
+    int tries;
+    u8 cs;
+
+    ENTER();
+
+    for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+        if (sbi_read_ioreg(priv, CARD_STATUS_REG, &cs) < 0)
+            break;
+        else if ((cs & bits) == bits) {
+            LEAVE();
+            return UAP_STATUS_SUCCESS;
+        }
+        udelay(10);
+    }
+
+    PRINTM(WARN, "mv_sdio_poll_card_status failed, tries = %d\n", tries);
+
+    LEAVE();
+    return UAP_STATUS_FAILURE;
+}
+
+/**
+ *  @brief This function set the sdio bus width.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @param mode    	1--1 bit mode, 4--4 bit mode
+ *  @return 	   	UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+#if 0
+static int
+sdio_set_bus_width(uap_private * priv, u8 mode)
+{
+    ENTER();
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+#endif
+
+/**
+ *  @brief This function reads data from the card.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @return 	   	UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+sd_card_to_host(uap_private * priv)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u16 buf_len = 0;
+    int buf_block_len;
+    int blksz;
+    struct sk_buff *skb = NULL;
+    u16 type;
+    u8 *payload = NULL;
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        ret = UAP_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Read the length of data to be transferred */
+    ret = sd_read_rx_len(priv, &buf_len);
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read scratch reg failed\n");
+        ret = UAP_STATUS_FAILURE;
+        goto exit;
+    }
+
+    /* Allocate buffer */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (buf_len + blksz - 1) / blksz;
+    if (buf_len <= INTF_HEADER_LEN || (buf_block_len * blksz) > ALLOC_BUF_SIZE) {
+        PRINTM(ERROR, "card_to_host, invalid packet length: %d\n", buf_len);
+        ret = UAP_STATUS_FAILURE;
+        goto exit;
+    }
+#ifdef PXA3XX_DMA_ALIGN
+    skb = dev_alloc_skb(buf_block_len * blksz + PXA3XX_DMA_ALIGNMENT);
+#else
+    skb = dev_alloc_skb(buf_block_len * blksz);
+#endif
+    if (skb == NULL) {
+        PRINTM(WARN, "No free skb\n");
+        goto exit;
+    }
+#ifdef PXA3XX_DMA_ALIGN
+    if ((u32) skb->data & (PXA3XX_DMA_ALIGNMENT - 1)) {
+        skb_put(skb, (u32) skb->data & (PXA3XX_DMA_ALIGNMENT - 1));
+        skb_pull(skb, (u32) skb->data & (PXA3XX_DMA_ALIGNMENT - 1));
+    }
+#endif /* PXA3XX_DMA_ALIGN */
+
+    payload = skb->tail;
+    ret = sdio_readsb(card->func, payload, priv->uap_dev.ioport,
+                      buf_block_len * blksz);
+    if (ret < 0) {
+        PRINTM(ERROR, "card_to_host, read iomem failed: %d\n", ret);
+        ret = UAP_STATUS_FAILURE;
+        goto exit;
+    }
+    HEXDUMP("SDIO Blk Rd", payload, blksz * buf_block_len);
+    /*
+     * This is SDIO specific header
+     *  u16 length,
+     *  u16 type (MV_TYPE_DAT = 0, MV_TYPE_CMD = 1, MV_TYPE_EVENT = 3)
+     */
+    buf_len = uap_le16_to_cpu(*(u16 *) & payload[0]);
+    type = uap_le16_to_cpu(*(u16 *) & payload[2]);
+    switch (type) {
+    case MV_TYPE_EVENT:
+        skb_put(skb, buf_len);
+        skb_pull(skb, INTF_HEADER_LEN);
+        uap_process_event(priv, skb->data, skb->len);
+        kfree_skb(skb);
+        skb = NULL;
+        break;
+    case MV_TYPE_CMD:
+        skb_put(skb, buf_len);
+        skb_pull(skb, INTF_HEADER_LEN);
+        priv->adapter->cmd_pending = FALSE;
+        if (priv->adapter->cmd_wait_option ==
+            HostCmd_OPTION_WAITFORRSP_SLEEPCONFIRM) {
+            priv->adapter->cmd_wait_option = FALSE;
+            uap_process_sleep_confirm_resp(priv, skb->data, skb->len);
+        } else if (priv->adapter->cmd_wait_option) {
+            memcpy(priv->adapter->CmdBuf, skb->data, skb->len);
+            priv->adapter->CmdSize = skb->len;
+            priv->adapter->cmd_wait_option = FALSE;
+            priv->adapter->CmdWaitQWoken = TRUE;
+            wake_up_interruptible(&priv->adapter->cmdwait_q);
+        }
+        kfree_skb(skb);
+        skb = NULL;
+        break;
+    case MV_TYPE_DAT:
+        skb_put(skb, buf_len);
+        skb_pull(skb, INTF_HEADER_LEN);
+        uap_process_rx_packet(priv, skb);
+        break;
+    default:
+        priv->stats.rx_errors++;
+        priv->stats.rx_dropped++;
+        /* Driver specified event and command resp should be handle here */
+        PRINTM(INFO, "Unknown PKT type:%d\n", type);
+        kfree_skb(skb);
+        skb = NULL;
+        break;
+    }
+  exit:
+    if (ret) {
+        if (skb)
+            kfree_skb(skb);
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function enables the host interrupts mask
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   UAP_STATUS_SUCCESS
+ */
+static int
+enable_host_int_mask(uap_private * priv, u8 mask)
+{
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+
+    /* Simply write the mask to the register */
+    ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, mask);
+
+    if (ret) {
+        PRINTM(WARN, "Unable to enable the host interrupt!\n");
+        ret = UAP_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**  @brief This function disables the host interrupts mask.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param mask	   the interrupt mask
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+disable_host_int_mask(uap_private * priv, u8 mask)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u8 host_int_mask;
+
+    ENTER();
+
+    /* Read back the host_int_mask register */
+    ret = sbi_read_ioreg(priv, HOST_INT_MASK_REG, &host_int_mask);
+    if (ret) {
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+
+    /* Update with the mask and write back to the register */
+    host_int_mask &= ~mask;
+    ret = sbi_write_ioreg(priv, HOST_INT_MASK_REG, host_int_mask);
+    if (ret < 0) {
+        PRINTM(WARN, "Unable to diable the host interrupt!\n");
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/********************************************************
+		Global Functions
+********************************************************/
+
+/**
+ *  @brief This function handles the interrupt.
+ *
+ *  @param func	   A pointer to sdio_func structure.
+ *  @return 	   n/a
+ */
+static void
+sbi_interrupt(struct sdio_func *func)
+{
+    struct sdio_mmc_card *card;
+    uap_private *priv;
+    u8 ireg = 0;
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+
+    card = sdio_get_drvdata(func);
+    if (!card || !card->priv) {
+        PRINTM(MSG, "%s: sbi_interrupt(%p) card or priv is NULL, card=%p\n",
+               __FUNCTION__, func, card);
+        LEAVE();
+        return;
+    }
+    priv = card->priv;
+#ifdef FW_WAKEUP_TIME
+    if ((priv->adapter->wt_pwrup_sending != 0L) &&
+        (priv->adapter->wt_int == 0L))
+        priv->adapter->wt_int = get_utimeofday();
+#endif
+
+    ireg = sdio_readb(card->func, HOST_INTSTATUS_REG, &ret);
+    if (ret) {
+        PRINTM(WARN, "sdio_read_ioreg: read int status register failed\n");
+        goto done;
+    }
+    if (ireg != 0) {
+        /*
+         * DN_LD_HOST_INT_STATUS and/or UP_LD_HOST_INT_STATUS
+         * Clear the interrupt status register and re-enable the interrupt
+         */
+        PRINTM(INFO, "sdio_ireg = 0x%x\n", ireg);
+        sdio_writeb(card->func,
+                    ~(ireg) & (DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS),
+                    HOST_INTSTATUS_REG, &ret);
+        if (ret) {
+            PRINTM(WARN,
+                   "sdio_write_ioreg: clear int status register failed\n");
+            goto done;
+        }
+    }
+    OS_INT_DISABLE;
+    sd_ireg |= ireg;
+    OS_INT_RESTORE;
+
+    uap_interrupt(priv);
+  done:
+    LEAVE();
+}
+
+/**
+ *  @brief This function probe the card
+ *
+ *  @param func    A pointer to sdio_func structure
+ *  @param id	   A pointer to structure sd_device_id
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+static int
+uap_probe(struct sdio_func *func, const struct sdio_device_id *id)
+{
+    int ret = UAP_STATUS_FAILURE;
+    struct sdio_mmc_card *card = NULL;
+
+    ENTER();
+
+    PRINTM(MSG, "%s: vendor=0x%4.04X device=0x%4.04X class=%d function=%d\n",
+           __FUNCTION__, func->vendor, func->device, func->class, func->num);
+
+    card = kzalloc(sizeof(struct sdio_mmc_card), GFP_KERNEL);
+    if (!card) {
+        ret = -ENOMEM;
+        goto done;
+    }
+
+    card->func = func;
+
+    if (!uap_add_card(card)) {
+        PRINTM(ERROR, "%s: uap_add_callback failed\n", __FUNCTION__);
+        kfree(card);
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+
+    ret = UAP_STATUS_SUCCESS;
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function removes the card
+ *
+ *  @param func    A pointer to sdio_func structure
+ *  @return        N/A
+ */
+static void
+uap_remove(struct sdio_func *func)
+{
+    struct sdio_mmc_card *card;
+
+    ENTER();
+
+    if (func) {
+        card = sdio_get_drvdata(func);
+        if (card) {
+            uap_remove_card(card);
+            kfree(card);
+        }
+    }
+
+    LEAVE();
+}
+
+#ifdef CONFIG_PM
+/**
+ *  @brief This function handles client driver suspend
+ *
+ *  @param func    A pointer to sdio_func structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+uap_suspend(struct sdio_func *func)
+{
+    ENTER();
+    LEAVE();
+    return 0;
+}
+
+/**
+ *  @brief This function handles client driver resume
+ *
+ *  @param func    A pointer to sdio_func structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+uap_resume(struct sdio_func *func)
+{
+    ENTER();
+    LEAVE();
+    return 0;
+}
+#endif
+
+/** Device ID for SD8688 */
+#define  SD_DEVICE_ID_8688_UAP 0x9104
+/** UAP IDs */
+static const struct sdio_device_id uap_ids[] = {
+    {SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SD_DEVICE_ID_8688_UAP)},
+    {},
+};
+
+MODULE_DEVICE_TABLE(sdio, uap_ids);
+
+static struct sdio_driver uap_sdio = {
+    .name = "uap_sdio",
+    .id_table = uap_ids,
+    .probe = uap_probe,
+    .remove = uap_remove,
+#ifdef CONFIG_PM
+/*    .suspend	= uap_suspend, */
+/*    .resume	= uap_resume, */
+#endif
+
+};
+
+/**
+ *  @brief This function registers the IF module in bus driver.
+ *
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int __init
+sbi_register()
+{
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+
+    /* SDIO Driver Registration */
+    if (sdio_register_driver(&uap_sdio) != 0) {
+        PRINTM(FATAL, "SDIO Driver Registration Failed \n");
+        ret = UAP_STATUS_FAILURE;
+    }
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function de-registers the IF module in bus driver.
+ *
+ *  @return 	   n/a
+ */
+void __exit
+sbi_unregister(void)
+{
+    ENTER();
+
+    /* SDIO Driver Unregistration */
+    sdio_unregister_driver(&uap_sdio);
+
+    LEAVE();
+}
+
+/**
+ *  @brief This function checks the interrupt status and handle it accordingly.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param ireg    A pointer to variable that keeps returned value
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_get_int_status(uap_private * priv, u8 * ireg)
+{
+    int ret = UAP_STATUS_SUCCESS;
+    u8 sdio_ireg = 0;
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+
+    ENTER();
+
+    *ireg = 0;
+    OS_INT_DISABLE;
+    sdio_ireg = sd_ireg;
+    sd_ireg = 0;
+    OS_INT_RESTORE;
+
+    sdio_claim_host(card->func);
+
+    if (sdio_ireg & DN_LD_HOST_INT_STATUS) {    /* tx_done INT */
+        if (!priv->uap_dev.cmd_sent) {  /* tx_done already received */
+            PRINTM(INFO,
+                   "warning: tx_done already received: tx_dnld_rdy=0x%x int status=0x%x\n",
+                   priv->uap_dev.cmd_sent, sdio_ireg);
+        } else {
+            priv->uap_dev.cmd_sent = FALSE;
+            priv->uap_dev.data_sent = FALSE;
+            if ( (priv->uap_dev.netdev->reg_state == NETREG_REGISTERED) && (skb_queue_len(&priv->adapter->tx_queue) < TX_LOW_WATERMARK)) {
+                os_start_queue(priv);
+	    }
+        }
+    }
+    if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
+        sd_card_to_host(priv);
+    }
+
+    *ireg = sdio_ireg;
+    ret = UAP_STATUS_SUCCESS;
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function disables the host interrupts.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_disable_host_int(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    int ret;
+
+    ENTER();
+
+    sdio_claim_host(card->func);
+    ret = disable_host_int_mask(priv, HIM_DISABLE);
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function enables the host interrupts.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS
+ */
+int
+sbi_enable_host_int(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    int ret;
+
+    ENTER();
+
+    sdio_claim_host(card->func);
+    ret = enable_host_int_mask(priv, HIM_ENABLE);
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function de-registers the device.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS
+ */
+int
+sbi_unregister_dev(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "Error: card or function is NULL!\n");
+        goto done;
+    }
+
+    sdio_claim_host(card->func);
+    sdio_release_irq(card->func);
+    sdio_disable_func(card->func);
+    sdio_release_host(card->func);
+
+    sdio_set_drvdata(card->func, NULL);
+
+  done:
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function registers the device.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_register_dev(uap_private * priv)
+{
+    int ret = UAP_STATUS_FAILURE;
+    u8 reg;
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    struct sdio_func *func;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "Error: card or function is NULL!\n");
+        goto done;
+    }
+
+    func = card->func;
+
+    /* Initialize the private structure */
+    priv->uap_dev.ioport = 0;
+
+    sdio_claim_host(func);
+
+    ret = sdio_enable_func(func);
+    if (ret) {
+        PRINTM(FATAL, "sdio_enable_func() failed: ret=%d\n", ret);
+        goto release_host;
+    }
+
+    ret = sdio_claim_irq(func, sbi_interrupt);
+    if (ret) {
+        PRINTM(FATAL, "sdio_claim_irq failed: ret=%d\n", ret);
+        goto disable_func;
+    }
+
+    /* Read the IO port */
+    ret = sbi_read_ioreg(priv, IO_PORT_0_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->uap_dev.ioport |= reg;
+
+    ret = sbi_read_ioreg(priv, IO_PORT_1_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->uap_dev.ioport |= (reg << 8);
+
+    ret = sbi_read_ioreg(priv, IO_PORT_2_REG, &reg);
+    if (ret)
+        goto release_irq;
+    else
+        priv->uap_dev.ioport |= (reg << 16);
+
+    PRINTM(INFO, "SDIO FUNC #%d IO port: 0x%x\n", func->num,
+           priv->uap_dev.ioport);
+
+    ret = sdio_set_block_size(card->func, SD_BLOCK_SIZE);
+    if (ret) {
+        PRINTM(ERROR, "%s: cannot set SDIO block size\n", __FUNCTION__);
+        ret = UAP_STATUS_FAILURE;
+        goto release_irq;
+    }
+    priv->hotplug_device = &func->dev;
+
+    if (helper_name == NULL) {
+        helper_name = DEFAULT_HELPER_NAME;
+    }
+    if (fw_name == NULL) {
+        fw_name = DEFAULT_FW_NAME;
+    }
+    sdio_release_host(func);
+
+    sdio_set_drvdata(func, card);
+
+    ret = UAP_STATUS_SUCCESS;
+    goto done;
+
+  release_irq:
+    sdio_release_irq(func);
+  disable_func:
+    sdio_disable_func(func);
+  release_host:
+    sdio_release_host(func);
+
+  done:
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function sends data to the card.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param payload A pointer to the data/cmd buffer
+ *  @param nb	   the length of data/cmd
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_host_to_card(uap_private * priv, u8 * payload, u16 nb)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    int ret = UAP_STATUS_SUCCESS;
+    int buf_block_len;
+    int blksz;
+    int i = 0;
+    u8 *buf = NULL;
+#ifdef PXA3XX_DMA_ALIGN
+    void *tmpbuf = NULL;
+    int tmpbufsz;
+#endif
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+    buf = payload;
+#ifdef PXA3XX_DMA_ALIGN
+    if ((u32) payload & (PXA3XX_DMA_ALIGNMENT - 1)) {
+        tmpbufsz = ALIGN_SZ(nb, PXA3XX_DMA_ALIGNMENT);
+        tmpbuf = kmalloc(tmpbufsz, GFP_KERNEL);
+        memset(tmpbuf, 0, tmpbufsz);
+        /* Ensure 8-byte aligned CMD buffer */
+        buf = (u8 *) ALIGN_ADDR(tmpbuf, PXA3XX_DMA_ALIGNMENT);
+        memcpy(buf, payload, nb);
+    }
+#endif
+    /* Allocate buffer and copy payload */
+    blksz = SD_BLOCK_SIZE;
+    buf_block_len = (nb + blksz - 1) / blksz;
+    sdio_claim_host(card->func);
+#define MAX_WRITE_IOMEM_RETRY	2
+    priv->uap_dev.cmd_sent = TRUE;
+    priv->uap_dev.data_sent = TRUE;
+    do {
+        /* Transfer data to card */
+        ret = sdio_writesb(card->func, priv->uap_dev.ioport, buf,
+                           buf_block_len * blksz);
+        if (ret < 0) {
+            i++;
+            PRINTM(ERROR, "host_to_card, write iomem (%d) failed: %d\n", i,
+                   ret);
+            ret = UAP_STATUS_FAILURE;
+            if (i > MAX_WRITE_IOMEM_RETRY)
+                goto exit;
+        } else {
+            HEXDUMP("SDIO Blk Wr", payload, nb);
+        }
+    } while (ret == UAP_STATUS_FAILURE);
+  exit:
+    sdio_release_host(card->func);
+#ifdef PXA3XX_DMA_ALIGN
+    if (tmpbuf)
+        kfree(tmpbuf);
+#endif
+    if (ret == UAP_STATUS_FAILURE) {
+        priv->uap_dev.cmd_sent = FALSE;
+        priv->uap_dev.data_sent = FALSE;
+    }
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function reads CIS information.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param cisinfo A pointer to CIS information output buffer
+ *  @param cislen  A pointer to length of CIS info output buffer
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+#if 0
+static int
+sbi_get_cis_info(uap_private * priv, void *cisinfo, int *cislen)
+{
+#define CIS_PTR (0x8000)
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    unsigned int i, cis_ptr = CIS_PTR;
+    int ret = UAP_STATUS_FAILURE;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_get_cis_info(): card or function is NULL!\n");
+        goto exit;
+    }
+#define MAX_SDIO_CIS_INFO_LEN (256)
+    if (!cisinfo || (*cislen < MAX_SDIO_CIS_INFO_LEN)) {
+        PRINTM(WARN, "ERROR! get_cis_info: insufficient buffer passed\n");
+        goto exit;
+    }
+
+    *cislen = MAX_SDIO_CIS_INFO_LEN;
+
+    sdio_claim_host(card->func);
+
+    PRINTM(INFO, "cis_ptr=%#x\n", cis_ptr);
+
+    /* Read the Tuple Data */
+    for (i = 0; i < *cislen; i++) {
+        ((unsigned char *) cisinfo)[i] =
+            sdio_readb(card->func, cis_ptr + i, &ret);
+        if (ret) {
+            PRINTM(WARN, "get_cis_info error: ret=%d\n", ret);
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+        PRINTM(INFO, "cisinfo[%d]=%#x\n", i, ((unsigned char *) cisinfo)[i]);
+    }
+
+  done:
+    sdio_release_host(card->func);
+  exit:
+    LEAVE();
+    return ret;
+}
+#endif
+/**
+ *  @brief This function downloads helper image to the card.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @return 	   	UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_prog_helper(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    u8 *helper = NULL;
+    int helperlen;
+    int ret = UAP_STATUS_SUCCESS;
+    void *tmphlprbuf = NULL;
+    int tmphlprbufsz;
+    u8 *hlprbuf;
+    int hlprblknow;
+    u32 tx_len;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_prog_helper(): card or function is NULL!\n");
+        goto done;
+    }
+
+    if (priv->fw_helper) {
+        helper = (u8 *) priv->fw_helper->data;
+        helperlen = priv->fw_helper->size;
+    } else {
+        PRINTM(MSG, "No helper image found! Terminating download.\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "Downloading helper image (%d bytes), block size %d bytes\n",
+           helperlen, SD_BLOCK_SIZE);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+#ifdef PXA3XX_DMA_ALIGN
+    tmphlprbufsz = ALIGN_SZ(UAP_UPLD_SIZE, PXA3XX_DMA_ALIGNMENT);
+#else /* !PXA3XX_DMA_ALIGN */
+    tmphlprbufsz = UAP_UPLD_SIZE;
+#endif /* !PXA3XX_DMA_ALIGN */
+    tmphlprbuf = kmalloc(tmphlprbufsz, GFP_KERNEL);
+    if (!tmphlprbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for helper. Terminating download\n");
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmphlprbuf, 0, tmphlprbufsz);
+#ifdef PXA3XX_DMA_ALIGN
+    hlprbuf = (u8 *) ALIGN_ADDR(tmphlprbuf, PXA3XX_DMA_ALIGNMENT);
+#else /* !PXA3XX_DMA_ALIGN */
+    hlprbuf = (u8 *) tmphlprbuf;
+#endif /* !PXA3XX_DMA_ALIGN */
+
+    sdio_claim_host(card->func);
+
+    /* Perform helper data transfer */
+    tx_len = (FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE) - INTF_HEADER_LEN;
+    hlprblknow = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL, "Helper download poll status timeout @ %d\n",
+                   hlprblknow);
+            goto done;
+        }
+
+        /* More data? */
+        if (hlprblknow >= helperlen)
+            break;
+
+        /* Set blocksize to transfer - checking for last block */
+        if (helperlen - hlprblknow < tx_len)
+            tx_len = helperlen - hlprblknow;
+
+        /* Set length to the 4-byte header */
+        *(u32 *) hlprbuf = uap_cpu_to_le32(tx_len);
+
+        /* Copy payload to buffer */
+        memcpy(&hlprbuf[INTF_HEADER_LEN], &helper[hlprblknow], tx_len);
+
+        PRINTM(INFO, ".");
+
+        /* Send data */
+        ret = sdio_writesb(card->func, priv->uap_dev.ioport,
+                           hlprbuf, FIRMWARE_TRANSFER_NBLOCK * SD_BLOCK_SIZE);
+
+        if (ret < 0) {
+            PRINTM(FATAL, "IO error during helper download @ %d\n", hlprblknow);
+            goto done;
+        }
+
+        hlprblknow += tx_len;
+    } while (TRUE);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "helper: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000, (tv2 % 1000000) / 1000,
+           tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000, (tv2 % 1000000) / 1000,
+           tv2 % 1000);
+#endif
+
+    /* Write last EOF data */
+    PRINTM(INFO, "\nTransferring helper image EOF block\n");
+    memset(hlprbuf, 0x0, SD_BLOCK_SIZE);
+    ret = sdio_writesb(card->func, priv->uap_dev.ioport,
+                       hlprbuf, SD_BLOCK_SIZE);
+
+    if (ret < 0) {
+        PRINTM(FATAL, "IO error in writing helper image EOF block\n");
+        goto done;
+    }
+
+    ret = UAP_STATUS_SUCCESS;
+
+  done:
+    sdio_release_host(card->func);
+    if (tmphlprbuf)
+        kfree(tmphlprbuf);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function downloads firmware image to the card.
+ *
+ *  @param priv    	A pointer to uap_private structure
+ *  @return 	   	UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_prog_fw_w_helper(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    u8 *firmware = NULL;
+    int firmwarelen;
+    u8 base0;
+    u8 base1;
+    int ret = UAP_STATUS_SUCCESS;
+    int offset;
+    void *tmpfwbuf = NULL;
+    int tmpfwbufsz;
+    u8 *fwbuf;
+    u16 len;
+    int txlen = 0;
+    int tx_blocks = 0;
+    int i = 0;
+    int tries = 0;
+#ifdef FW_DOWNLOAD_SPEED
+    u32 tv1, tv2;
+#endif
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "sbi_prog_fw_w_helper(): card or function is NULL!\n");
+        goto done;
+    }
+
+    if (priv->firmware) {
+        firmware = (u8 *) priv->firmware->data;
+        firmwarelen = priv->firmware->size;
+    } else {
+        PRINTM(MSG, "No firmware image found! Terminating download.\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+
+    PRINTM(INFO, "Downloading FW image (%d bytes)\n", firmwarelen);
+
+#ifdef FW_DOWNLOAD_SPEED
+    tv1 = get_utimeofday();
+#endif
+
+#ifdef PXA3XX_DMA_ALIGN
+    tmpfwbufsz = ALIGN_SZ(UAP_UPLD_SIZE, PXA3XX_DMA_ALIGNMENT);
+#else /* PXA3XX_DMA_ALIGN */
+    tmpfwbufsz = UAP_UPLD_SIZE;
+#endif /* PXA3XX_DMA_ALIGN */
+    tmpfwbuf = kmalloc(tmpfwbufsz, GFP_KERNEL);
+    if (!tmpfwbuf) {
+        PRINTM(ERROR,
+               "Unable to allocate buffer for firmware. Terminating download.\n");
+        ret = UAP_STATUS_FAILURE;
+        goto done;
+    }
+    memset(tmpfwbuf, 0, tmpfwbufsz);
+#ifdef PXA3XX_DMA_ALIGN
+    /* Ensure 8-byte aligned firmware buffer */
+    fwbuf = (u8 *) ALIGN_ADDR(tmpfwbuf, PXA3XX_DMA_ALIGNMENT);
+#else /* PXA3XX_DMA_ALIGN */
+    fwbuf = (u8 *) tmpfwbuf;
+#endif /* PXA3XX_DMA_ALIGN */
+
+    sdio_claim_host(card->func);
+
+    /* Perform firmware data transfer */
+    offset = 0;
+    do {
+        /* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits */
+        ret = mv_sdio_poll_card_status(priv, CARD_IO_READY | DN_LD_CARD_RDY);
+        if (ret < 0) {
+            PRINTM(FATAL, "FW download with helper poll status timeout @ %d\n",
+                   offset);
+            goto done;
+        }
+
+        /* More data? */
+        if (offset >= firmwarelen)
+            break;
+
+        for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+            if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_0, &base0)) < 0) {
+                PRINTM(WARN, "Dev BASE0 register read failed:"
+                       " base0=0x%04X(%d). Terminating download.\n", base0,
+                       base0);
+                ret = UAP_STATUS_FAILURE;
+                goto done;
+            }
+            if ((ret = sbi_read_ioreg(priv, HOST_F1_RD_BASE_1, &base1)) < 0) {
+                PRINTM(WARN, "Dev BASE1 register read failed:"
+                       " base1=0x%04X(%d). Terminating download.\n", base1,
+                       base1);
+                ret = UAP_STATUS_FAILURE;
+                goto done;
+            }
+            len = (((u16) base1) << 8) | base0;
+
+            /* For SD8688 wait until the length is not 0, 1 or 2 before
+               downloading the first FW block, since BOOT code writes the
+               register to indicate the helper/FW download winner, the value
+               could be 1 or 2 (Func1 or Func2). */
+            if ((len && offset) || (len > 2))
+                break;
+            udelay(10);
+        }
+
+        if (len == 0)
+            break;
+        else if (len > UAP_UPLD_SIZE) {
+            PRINTM(FATAL, "FW download failure @ %d, invalid length %d\n",
+                   offset, len);
+            ret = UAP_STATUS_FAILURE;
+            goto done;
+        }
+
+        txlen = len;
+
+        if (len & BIT(0)) {
+            i++;
+            if (i > MAX_WRITE_IOMEM_RETRY) {
+                PRINTM(FATAL,
+                       "FW download failure @ %d, over max retry count\n",
+                       offset);
+                ret = UAP_STATUS_FAILURE;
+                goto done;
+            }
+            PRINTM(ERROR, "FW CRC error indicated by the helper:"
+                   " len = 0x%04X, txlen = %d\n", len, txlen);
+            len &= ~BIT(0);
+            /* Setting this to 0 to resend from same offset */
+            txlen = 0;
+        } else {
+            i = 0;
+
+            /* Set blocksize to transfer - checking for last block */
+            if (firmwarelen - offset < txlen) {
+                txlen = firmwarelen - offset;
+            }
+            PRINTM(INFO, ".");
+
+            tx_blocks = (txlen + SD_BLOCK_SIZE - 1) / SD_BLOCK_SIZE;
+
+            /* Copy payload to buffer */
+            memcpy(fwbuf, &firmware[offset], txlen);
+        }
+
+        /* Send data */
+        ret = sdio_writesb(card->func, priv->uap_dev.ioport,
+                           fwbuf, tx_blocks * SD_BLOCK_SIZE);
+
+        if (ret < 0) {
+            PRINTM(ERROR, "FW download, write iomem (%d) failed @ %d\n", i,
+                   offset);
+            if (sbi_write_ioreg(priv, CONFIGURATION_REG, 0x04) < 0) {
+                PRINTM(ERROR, "write ioreg failed (CFG)\n");
+            }
+        }
+
+        offset += txlen;
+    } while (TRUE);
+
+    PRINTM(INFO, "\nFW download over, size %d bytes\n", offset);
+
+    ret = UAP_STATUS_SUCCESS;
+  done:
+#ifdef FW_DOWNLOAD_SPEED
+    tv2 = get_utimeofday();
+    PRINTM(INFO, "FW: %ld.%03ld.%03ld ", tv1 / 1000000,
+           (tv1 % 1000000) / 1000, tv1 % 1000);
+    PRINTM(INFO, " -> %ld.%03ld.%03ld ", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+    tv2 -= tv1;
+    PRINTM(INFO, " == %ld.%03ld.%03ld\n", tv2 / 1000000,
+           (tv2 % 1000000) / 1000, tv2 % 1000);
+#endif
+    sdio_release_host(card->func);
+    if (tmpfwbuf)
+        kfree(tmpfwbuf);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function checks if the firmware is ready to accept
+ *  command or not.
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param pollnum Poll number
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_check_fw_status(uap_private * priv, int pollnum)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    int ret = UAP_STATUS_SUCCESS;
+    u16 firmwarestat;
+    int tries;
+
+    ENTER();
+
+    sdio_claim_host(card->func);
+
+    /* Wait for firmware initialization event */
+    for (tries = 0; tries < pollnum; tries++) {
+        if ((ret = sd_read_firmware_status(priv, &firmwarestat)) < 0)
+            continue;
+        if (firmwarestat == FIRMWARE_READY) {
+            ret = UAP_STATUS_SUCCESS;
+            break;
+        } else {
+            mdelay(10);
+            ret = UAP_STATUS_FAILURE;
+        }
+    }
+
+    if (ret < 0)
+        goto done;
+
+    ret = UAP_STATUS_SUCCESS;
+    sd_get_rx_unit(priv);
+
+  done:
+    sdio_release_host(card->func);
+
+    LEAVE();
+    return ret;
+}
+
+/**
+ *  @brief This function set bus clock on/off
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @param option    TRUE--on , FALSE--off
+ *  @return 	   UAP_STATUS_SUCCESS
+ */
+#if 0
+static int
+sbi_set_bus_clock(uap_private * priv, u8 option)
+{
+    ENTER();
+    LEAVE();
+    return UAP_STATUS_SUCCESS;
+}
+#endif
+
+/**
+ *  @brief This function wakeup firmware
+ *
+ *  @param priv    A pointer to uap_private structure
+ *  @return 	   UAP_STATUS_SUCCESS or UAP_STATUS_FAILURE
+ */
+int
+sbi_wakeup_firmware(uap_private * priv)
+{
+    struct sdio_mmc_card *card = priv->uap_dev.card;
+    int ret = UAP_STATUS_SUCCESS;
+
+    ENTER();
+
+    if (!card || !card->func) {
+        PRINTM(ERROR, "card or function is NULL!\n");
+        LEAVE();
+        return UAP_STATUS_FAILURE;
+    }
+    sdio_claim_host(card->func);
+    sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
+    sdio_release_host(card->func);
+    LEAVE();
+    return ret;
+}
diff -ruN a/drivers/net/wireless/libertas_uap/uap_sdio_mmc.h b/drivers/net/wireless/libertas_uap/uap_sdio_mmc.h
--- a/drivers/net/wireless/libertas_uap/uap_sdio_mmc.h	1969-12-31 17:00:00.000000000 -0700
+++ b/drivers/net/wireless/libertas_uap/uap_sdio_mmc.h	2013-09-16 01:27:45.937768903 -0600
@@ -0,0 +1,136 @@
+/** @file uap_sdio_mmc.h
+ *  @brief This file contains SDIO IF (interface) module
+ *  related macros, enum, and structure.
+ *
+ * Copyright (C) 2007-2009, Marvell International Ltd.
+ *
+ * This software file (the "File") is distributed by Marvell International
+ * Ltd. under the terms of the GNU General Public License Version 2, June 1991
+ * (the "License").  You may use, redistribute and/or modify this File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available along with the File in the gpl.txt file or by writing to
+ * the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ * 02111-1307 or on the worldwide web at http://www.gnu.org/licenses/gpl.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/****************************************************
+Change log:
+	10/10/07: initial version
+****************************************************/
+
+#ifndef	_UAP_SDIO_MMC_H
+#define	_UAP_SDIO_MMC_H
+
+#include	<linux/mmc/sdio.h>
+#include	<linux/mmc/sdio_ids.h>
+#include	<linux/mmc/sdio_func.h>
+#include	<linux/mmc/card.h>
+
+#include	"uap_headers.h"
+
+/** The number of times to try when waiting for downloaded firmware to
+     become active. (polling the scratch register). */
+#define MAX_FIRMWARE_POLL_TRIES		100
+
+/** Firmware ready */
+#define FIRMWARE_READY			0xfedc
+
+/** Number of firmware blocks to transfer */
+#define FIRMWARE_TRANSFER_NBLOCK	2
+
+/* Host Control Registers */
+/** Host Control Registers : I/O port 0 */
+#define IO_PORT_0_REG			0x00
+/** Host Control Registers : I/O port 1 */
+#define IO_PORT_1_REG			0x01
+/** Host Control Registers : I/O port 2 */
+#define IO_PORT_2_REG			0x02
+
+/** Host Control Registers : Configuration */
+#define CONFIGURATION_REG		0x03
+/** Host Control Registers : Host without Command 53 finish host */
+#define HOST_WO_CMD53_FINISH_HOST	(0x1U << 2)
+/** Host Control Registers : Host power up */
+#define HOST_POWER_UP			(0x1U << 1)
+/** Host Control Registers : Host power down */
+#define HOST_POWER_DOWN			(0x1U << 0)
+
+/** Host Control Registers : Host interrupt mask */
+#define HOST_INT_MASK_REG		0x04
+/** Host Control Registers : Upload host interrupt mask */
+#define UP_LD_HOST_INT_MASK		(0x1U)
+/** Host Control Registers : Download host interrupt mask */
+#define DN_LD_HOST_INT_MASK		(0x2U)
+/** Enable Host interrupt mask */
+#define HIM_ENABLE			(UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK)
+/** Disable Host interrupt mask */
+#define	HIM_DISABLE			0xff
+
+/** Host Control Registers : Host interrupt status */
+#define HOST_INTSTATUS_REG		0x05
+/** Host Control Registers : Upload host interrupt status */
+#define UP_LD_HOST_INT_STATUS		(0x1U)
+/** Host Control Registers : Download host interrupt status */
+#define DN_LD_HOST_INT_STATUS		(0x2U)
+
+/** Host F1 read base 0 */
+#define HOST_F1_RD_BASE_0		0x10
+/** Host F1 read base 1 */
+#define HOST_F1_RD_BASE_1		0x11
+
+/** Card Control Registers : Card status register */
+#define CARD_STATUS_REG              	0x20
+/** Card Control Registers : Card I/O ready */
+#define CARD_IO_READY              	(0x1U << 3)
+/** Card Control Registers : CIS card ready */
+#define CIS_CARD_RDY                 	(0x1U << 2)
+/** Card Control Registers : Upload card ready */
+#define UP_LD_CARD_RDY               	(0x1U << 1)
+/** Card Control Registers : Download card ready */
+#define DN_LD_CARD_RDY               	(0x1U << 0)
+
+/** Card Control Registers : Card OCR 0 register */
+#define CARD_OCR_0_REG               	0x34
+/** Card Control Registers : Card OCR 1 register */
+#define CARD_OCR_1_REG               	0x35
+
+/** Firmware status 0 register */
+#define CARD_FW_STATUS0_REG		0x40
+/** Firmware status 1 register */
+#define CARD_FW_STATUS1_REG		0x41
+/** Rx length register */
+#define CARD_RX_LEN_REG			0x42
+/** Rx unit register */
+#define CARD_RX_UNIT_REG		0x43
+
+/** Chip Id Register 0 */
+#define CARD_CHIP_ID_0_REG		0x801c
+/** Chip Id Register 1 */
+#define CARD_CHIP_ID_1_REG		0x801d
+
+#ifdef PXA3XX_DMA_ALIGN
+/** DMA alignment value for PXA3XX platforms */
+#define PXA3XX_DMA_ALIGNMENT    8
+/** Macros for Data Alignment : size */
+#define ALIGN_SZ(p, a)  \
+    (((p) + ((a) - 1)) & ~((a) - 1))
+
+/** Macros for Data Alignment : address */
+#define ALIGN_ADDR(p, a)    \
+    ((((u32)(p)) + (((u32)(a)) - 1)) & ~(((u32)(a)) - 1))
+#endif /* PXA3XX_DMA_ALIGN */
+
+struct sdio_mmc_card
+{
+        /** sdio_func structure pointer */
+    struct sdio_func *func;
+        /** uap_private structure pointer */
+    uap_private *priv;
+};
+
+#endif /* _UAP_SDIO_MMC_H */
diff -ruN a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
--- a/drivers/net/wireless/Makefile	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/net/wireless/Makefile	2013-09-16 01:27:45.967768519 -0600
@@ -37,6 +37,8 @@
 
 obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
 
+obj-$(CONFIG_LIBERTAS_UAP)	+= libertas_uap/
+
 obj-$(CONFIG_ADM8211)	+= adm8211.o
 
 obj-$(CONFIG_MWL8K)	+= mwl8k.o
diff -ruN a/drivers/net/wireless/mwifiex/sdio.c b/drivers/net/wireless/mwifiex/sdio.c
--- a/drivers/net/wireless/mwifiex/sdio.c	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/net/wireless/mwifiex/sdio.c	2013-09-16 01:27:45.977768390 -0600
@@ -253,11 +253,14 @@
 	return 0;
 }
 
+/* Device ID for SD8786 */
+#define SDIO_DEVICE_ID_MARVELL_8786   (0x9116)
 /* Device ID for SD8787 */
 #define SDIO_DEVICE_ID_MARVELL_8787   (0x9119)
 
 /* WLAN IDs */
 static const struct sdio_device_id mwifiex_ids[] = {
+	{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8786)},
 	{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787)},
 	{},
 };
@@ -1570,7 +1573,15 @@
 	sdio_set_drvdata(func, card);
 
 	adapter->dev = &func->dev;
-	strcpy(adapter->fw_name, SD8787_DEFAULT_FW_NAME);
+	switch (func->device) {
+	case SDIO_DEVICE_ID_MARVELL_8786:
+		strcpy(adapter->fw_name, SD8786_DEFAULT_FW_NAME);
+		break;
+	case SDIO_DEVICE_ID_MARVELL_8787:
+	default:
+		strcpy(adapter->fw_name, SD8787_DEFAULT_FW_NAME);
+		break;
+	}
 
 	return 0;
 
@@ -1769,4 +1780,5 @@
 MODULE_DESCRIPTION("Marvell WiFi-Ex SDIO Driver version " SDIO_VERSION);
 MODULE_VERSION(SDIO_VERSION);
 MODULE_LICENSE("GPL v2");
-MODULE_FIRMWARE("mrvl/sd8787_uapsta.bin");
+MODULE_FIRMWARE(SD8786_DEFAULT_FW_NAME);
+MODULE_FIRMWARE(SD8787_DEFAULT_FW_NAME);
diff -ruN a/drivers/net/wireless/mwifiex/sdio.h b/drivers/net/wireless/mwifiex/sdio.h
--- a/drivers/net/wireless/mwifiex/sdio.h	2011-10-24 01:10:05.000000000 -0600
+++ b/drivers/net/wireless/mwifiex/sdio.h	2013-09-16 01:27:45.977768390 -0600
@@ -28,6 +28,7 @@
 
 #include "main.h"
 
+#define SD8786_DEFAULT_FW_NAME "mrvl/sd8786_uapsta.bin"
 #define SD8787_DEFAULT_FW_NAME "mrvl/sd8787_uapsta.bin"
 
 #define BLOCK_MODE	1
diff -ruN a/include/linux/bubba3.h b/include/linux/bubba3.h
--- a/include/linux/bubba3.h	1969-12-31 17:00:00.000000000 -0700
+++ b/include/linux/bubba3.h	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,41 @@
+/*
+ * (C) Copyright 2010
+ * Excito elektronik i Sk√É¬•ne AB <www.excito.com>
+ * by: Tor Krill <tor@excito.com>
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA 02110-1301 USA
+ */
+
+#ifndef __BUBBA3_H
+#define __BUBBA3_H
+
+/*
+ * GPIO definitions
+ */
+#define B3_LED_INTERVAL		(37)
+#define B3_FRONT_LED_GREEN	(38)
+#define B3_POWER_BUTTON		(39)
+#define B3_BUZZER_ENABLE	(40)
+#define B3_FRONT_LED_RED	(41)
+#define B3_FRONT_LED_BLUE	(42)
+#define B3_HW_ID0		(43)
+#define B3_HW_ID1		(44)
+#define B3_HW_ID2		(45)
+#define B3_BUZ_4KHZ		(46)
+
+#endif
diff -ruN a/include/linux/nsa3xx-hwmon.h b/include/linux/nsa3xx-hwmon.h
--- a/include/linux/nsa3xx-hwmon.h	1969-12-31 17:00:00.000000000 -0700
+++ b/include/linux/nsa3xx-hwmon.h	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,21 @@
+/*
+ * include/linux/nsa3xx.hwmon.h
+ *
+ * Platform data structure for ZyXEL NSA3xx hwmon driver
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __LINUX_NSA3XX_HWMON_H
+#define __LINUX_NSA3XX_HWMON_H
+
+struct nsa3xx_hwmon_platform_data {
+	/* GPIO pins */
+	unsigned act_pin;
+	unsigned clk_pin;
+	unsigned data_pin;
+};
+
+#endif /* __LINUX_NSA3XX_HWMON_H */
diff -ruN a/scripts/basic/.fixdep.cmd b/scripts/basic/.fixdep.cmd
--- a/scripts/basic/.fixdep.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/basic/.fixdep.cmd	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,88 @@
+cmd_scripts/basic/fixdep := gcc -Wp,-MD,scripts/basic/.fixdep.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer     -o scripts/basic/fixdep scripts/basic/fixdep.c  
+
+source_scripts/basic/fixdep := scripts/basic/fixdep.c
+
+deps_scripts/basic/fixdep := \
+    $(wildcard include/config/his/driver.h) \
+    $(wildcard include/config/my/option.h) \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/foo.h) \
+    $(wildcard include/config/boom.h) \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/sys/mman.h \
+  /usr/include/bits/mman.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/string.h \
+  /usr/include/xlocale.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/limits.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/include/ctype.h \
+  /usr/include/arpa/inet.h \
+  /usr/include/netinet/in.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdint.h \
+  /usr/include/stdint.h \
+  /usr/include/bits/wchar.h \
+  /usr/include/sys/socket.h \
+  /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h \
+  /usr/include/bits/socket.h \
+  /usr/include/bits/socket_type.h \
+  /usr/include/bits/sockaddr.h \
+  /usr/include/asm/socket.h \
+  /usr/include/asm-generic/socket.h \
+  /usr/include/asm/sockios.h \
+  /usr/include/asm-generic/sockios.h \
+  /usr/include/bits/in.h \
+
+scripts/basic/fixdep: $(deps_scripts/basic/fixdep)
+
+$(deps_scripts/basic/fixdep):
diff -ruN a/scripts/kconfig/.conf.o.cmd b/scripts/kconfig/.conf.o.cmd
--- a/scripts/kconfig/.conf.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/.conf.o.cmd	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,67 @@
+cmd_scripts/kconfig/conf.o := gcc -Wp,-MD,scripts/kconfig/.conf.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/conf.o scripts/kconfig/conf.c
+
+source_scripts/kconfig/conf.o := scripts/kconfig/conf.c
+
+deps_scripts/kconfig/conf.o := \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/allconfig.h) \
+    $(wildcard include/config/nosilentupdate.h) \
+  /usr/include/locale.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/bits/locale.h \
+  /usr/include/xlocale.h \
+  /usr/include/ctype.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/sys/types.h \
+  /usr/include/time.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/sys/time.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/list.h) \
+  scripts/kconfig/expr.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  scripts/kconfig/lkc_proto.h \
+
+scripts/kconfig/conf.o: $(deps_scripts/kconfig/conf.o)
+
+$(deps_scripts/kconfig/conf.o):
diff -ruN a/scripts/kconfig/lxdialog/.checklist.o.cmd b/scripts/kconfig/lxdialog/.checklist.o.cmd
--- a/scripts/kconfig/lxdialog/.checklist.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.checklist.o.cmd	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,66 @@
+cmd_scripts/kconfig/lxdialog/checklist.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.checklist.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/checklist.o scripts/kconfig/lxdialog/checklist.c
+
+source_scripts/kconfig/lxdialog/checklist.o := scripts/kconfig/lxdialog/checklist.c
+
+deps_scripts/kconfig/lxdialog/checklist.o := \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/checklist.o: $(deps_scripts/kconfig/lxdialog/checklist.o)
+
+$(deps_scripts/kconfig/lxdialog/checklist.o):
diff -ruN a/scripts/kconfig/lxdialog/.inputbox.o.cmd b/scripts/kconfig/lxdialog/.inputbox.o.cmd
--- a/scripts/kconfig/lxdialog/.inputbox.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.inputbox.o.cmd	2013-09-16 01:27:45.987768263 -0600
@@ -0,0 +1,66 @@
+cmd_scripts/kconfig/lxdialog/inputbox.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.inputbox.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/inputbox.o scripts/kconfig/lxdialog/inputbox.c
+
+source_scripts/kconfig/lxdialog/inputbox.o := scripts/kconfig/lxdialog/inputbox.c
+
+deps_scripts/kconfig/lxdialog/inputbox.o := \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/inputbox.o: $(deps_scripts/kconfig/lxdialog/inputbox.o)
+
+$(deps_scripts/kconfig/lxdialog/inputbox.o):
diff -ruN a/scripts/kconfig/lxdialog/.menubox.o.cmd b/scripts/kconfig/lxdialog/.menubox.o.cmd
--- a/scripts/kconfig/lxdialog/.menubox.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.menubox.o.cmd	2013-09-16 01:27:45.997768135 -0600
@@ -0,0 +1,66 @@
+cmd_scripts/kconfig/lxdialog/menubox.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.menubox.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/menubox.o scripts/kconfig/lxdialog/menubox.c
+
+source_scripts/kconfig/lxdialog/menubox.o := scripts/kconfig/lxdialog/menubox.c
+
+deps_scripts/kconfig/lxdialog/menubox.o := \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/menubox.o: $(deps_scripts/kconfig/lxdialog/menubox.o)
+
+$(deps_scripts/kconfig/lxdialog/menubox.o):
diff -ruN a/scripts/kconfig/lxdialog/.textbox.o.cmd b/scripts/kconfig/lxdialog/.textbox.o.cmd
--- a/scripts/kconfig/lxdialog/.textbox.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.textbox.o.cmd	2013-09-16 01:27:45.997768135 -0600
@@ -0,0 +1,66 @@
+cmd_scripts/kconfig/lxdialog/textbox.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.textbox.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/textbox.o scripts/kconfig/lxdialog/textbox.c
+
+source_scripts/kconfig/lxdialog/textbox.o := scripts/kconfig/lxdialog/textbox.c
+
+deps_scripts/kconfig/lxdialog/textbox.o := \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/textbox.o: $(deps_scripts/kconfig/lxdialog/textbox.o)
+
+$(deps_scripts/kconfig/lxdialog/textbox.o):
diff -ruN a/scripts/kconfig/lxdialog/.util.o.cmd b/scripts/kconfig/lxdialog/.util.o.cmd
--- a/scripts/kconfig/lxdialog/.util.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.util.o.cmd	2013-09-16 01:27:45.997768135 -0600
@@ -0,0 +1,67 @@
+cmd_scripts/kconfig/lxdialog/util.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.util.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/util.o scripts/kconfig/lxdialog/util.c
+
+source_scripts/kconfig/lxdialog/util.o := scripts/kconfig/lxdialog/util.c
+
+deps_scripts/kconfig/lxdialog/util.o := \
+    $(wildcard include/config/color.h) \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/util.o: $(deps_scripts/kconfig/lxdialog/util.o)
+
+$(deps_scripts/kconfig/lxdialog/util.o):
diff -ruN a/scripts/kconfig/lxdialog/.yesno.o.cmd b/scripts/kconfig/lxdialog/.yesno.o.cmd
--- a/scripts/kconfig/lxdialog/.yesno.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/lxdialog/.yesno.o.cmd	2013-09-16 01:27:45.997768135 -0600
@@ -0,0 +1,66 @@
+cmd_scripts/kconfig/lxdialog/yesno.o := gcc -Wp,-MD,scripts/kconfig/lxdialog/.yesno.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/lxdialog/yesno.o scripts/kconfig/lxdialog/yesno.c
+
+source_scripts/kconfig/lxdialog/yesno.o := scripts/kconfig/lxdialog/yesno.c
+
+deps_scripts/kconfig/lxdialog/yesno.o := \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/sys/types.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/time.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/bits/stat.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/ctype.h \
+  /usr/include/xlocale.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/lxdialog/yesno.o: $(deps_scripts/kconfig/lxdialog/yesno.o)
+
+$(deps_scripts/kconfig/lxdialog/yesno.o):
diff -ruN a/scripts/kconfig/.mconf.cmd b/scripts/kconfig/.mconf.cmd
--- a/scripts/kconfig/.mconf.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/.mconf.cmd	2013-09-16 01:27:45.997768135 -0600
@@ -0,0 +1 @@
+cmd_scripts/kconfig/mconf := gcc  -o scripts/kconfig/mconf scripts/kconfig/mconf.o scripts/kconfig/zconf.tab.o scripts/kconfig/lxdialog/checklist.o scripts/kconfig/lxdialog/util.o scripts/kconfig/lxdialog/inputbox.o scripts/kconfig/lxdialog/textbox.o scripts/kconfig/lxdialog/yesno.o scripts/kconfig/lxdialog/menubox.o  -lncursesw
diff -ruN a/scripts/kconfig/.mconf.o.cmd b/scripts/kconfig/.mconf.o.cmd
--- a/scripts/kconfig/.mconf.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/.mconf.o.cmd	2013-09-16 01:27:46.007768007 -0600
@@ -0,0 +1,86 @@
+cmd_scripts/kconfig/mconf.o := gcc -Wp,-MD,scripts/kconfig/.mconf.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE   -c -o scripts/kconfig/mconf.o scripts/kconfig/mconf.c
+
+source_scripts/kconfig/mconf.o := scripts/kconfig/mconf.c
+
+deps_scripts/kconfig/mconf.o := \
+    $(wildcard include/config/mode.h) \
+    $(wildcard include/config/color.h) \
+    $(wildcard include/config/.h) \
+  /usr/include/ctype.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/xlocale.h \
+  /usr/include/errno.h \
+  /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h \
+  /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h \
+  /usr/include/asm-generic/errno-base.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  /usr/include/time.h \
+  /usr/include/bits/stat.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/limits.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/stdlib.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/sys/types.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/list.h) \
+  scripts/kconfig/expr.h \
+  /usr/include/stdio.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  /usr/include/libintl.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/lxdialog/dialog.h \
+  /usr/include/ncurses.h \
+  /usr/include/ncurses_dll.h \
+  /usr/include/unctrl.h \
+  /usr/include/curses.h \
+
+scripts/kconfig/mconf.o: $(deps_scripts/kconfig/mconf.o)
+
+$(deps_scripts/kconfig/mconf.o):
diff -ruN a/scripts/kconfig/zconf.hash.c b/scripts/kconfig/zconf.hash.c
--- a/scripts/kconfig/zconf.hash.c	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/zconf.hash.c	2013-09-16 01:27:46.007768007 -0600
@@ -0,0 +1,286 @@
+/* ANSI-C code produced by gperf version 3.0.4 */
+/* Command-line: gperf -t --output-file scripts/kconfig/zconf.hash.c_shipped -a -C -E -g -k '1,3,$' -p -t scripts/kconfig/zconf.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 10 "scripts/kconfig/zconf.gperf"
+struct kconf_id;
+
+static const struct kconf_id *kconf_id_lookup(register const char *str, register unsigned int len);
+/* maximum key range = 71, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 25, 25,
+       0,  0,  0,  5,  0,  0, 73, 73,  5,  0,
+      10,  5, 45, 73, 20, 20,  0, 15, 15, 73,
+      20, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
+      73, 73, 73, 73, 73, 73
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("if")];
+    char kconf_id_strings_str3[sizeof("int")];
+    char kconf_id_strings_str5[sizeof("endif")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("tristate")];
+    char kconf_id_strings_str9[sizeof("endchoice")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("def_bool")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str17[sizeof("on")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str21[sizeof("option")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("mainmenu")];
+    char kconf_id_strings_str25[sizeof("menuconfig")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("select")];
+    char kconf_id_strings_str32[sizeof("comment")];
+    char kconf_id_strings_str33[sizeof("env")];
+    char kconf_id_strings_str35[sizeof("range")];
+    char kconf_id_strings_str36[sizeof("choice")];
+    char kconf_id_strings_str39[sizeof("bool")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("visible")];
+    char kconf_id_strings_str43[sizeof("hex")];
+    char kconf_id_strings_str46[sizeof("config")];
+    char kconf_id_strings_str47[sizeof("boolean")];
+    char kconf_id_strings_str51[sizeof("string")];
+    char kconf_id_strings_str54[sizeof("help")];
+    char kconf_id_strings_str56[sizeof("prompt")];
+    char kconf_id_strings_str72[sizeof("depends")];
+  };
+static const struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "if",
+    "int",
+    "endif",
+    "default",
+    "tristate",
+    "endchoice",
+    "def_tristate",
+    "def_bool",
+    "defconfig_list",
+    "on",
+    "optional",
+    "option",
+    "endmenu",
+    "mainmenu",
+    "menuconfig",
+    "modules",
+    "menu",
+    "select",
+    "comment",
+    "env",
+    "range",
+    "choice",
+    "bool",
+    "source",
+    "visible",
+    "hex",
+    "config",
+    "boolean",
+    "string",
+    "help",
+    "prompt",
+    "depends"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 32,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 72
+    };
+
+  static const struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+#line 25 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_IF,		TF_COMMAND|TF_PARAM},
+#line 36 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str3,		T_TYPE,		TF_COMMAND, S_INT},
+      {-1},
+#line 26 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str5,		T_ENDIF,	TF_COMMAND},
+      {-1},
+#line 29 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+#line 31 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+#line 20 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str9,	T_ENDCHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 32 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+#line 35 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+#line 45 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1}, {-1},
+#line 43 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_ON,		TF_PARAM},
+#line 28 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1}, {-1},
+#line 42 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_OPTION,	TF_COMMAND},
+#line 17 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+#line 15 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_MAINMENU,	TF_COMMAND},
+      {-1},
+#line 23 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str25,	T_MENUCONFIG,	TF_COMMAND},
+      {-1},
+#line 44 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {-1},
+#line 16 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+#line 39 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_SELECT,	TF_COMMAND},
+#line 21 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_COMMENT,	TF_COMMAND},
+#line 46 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,		T_OPT_ENV,	TF_OPTION},
+      {-1},
+#line 40 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,		T_RANGE,	TF_COMMAND},
+#line 19 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_CHOICE,	TF_COMMAND},
+      {-1}, {-1},
+#line 33 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+#line 18 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+#line 41 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_VISIBLE,	TF_COMMAND},
+#line 37 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,		T_TYPE,		TF_COMMAND, S_HEX},
+      {-1}, {-1},
+#line 22 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_CONFIG,	TF_COMMAND},
+#line 34 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str47,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1}, {-1}, {-1},
+#line 38 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str51,		T_TYPE,		TF_COMMAND, S_STRING},
+      {-1}, {-1},
+#line 24 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str54,		T_HELP,		TF_COMMAND},
+      {-1},
+#line 30 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str56,		T_PROMPT,	TF_COMMAND},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+      {-1}, {-1}, {-1}, {-1}, {-1}, {-1},
+#line 27 "scripts/kconfig/zconf.gperf"
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str72,	T_DEPENDS,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+#line 47 "scripts/kconfig/zconf.gperf"
+
diff -ruN a/scripts/kconfig/zconf.lex.c b/scripts/kconfig/zconf.lex.c
--- a/scripts/kconfig/zconf.lex.c	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/zconf.lex.c	2013-09-16 01:27:46.027767752 -0600
@@ -0,0 +1,2420 @@
+
+#line 3 "scripts/kconfig/zconf.lex.c_shipped"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define yy_create_buffer zconf_create_buffer
+#define yy_delete_buffer zconf_delete_buffer
+#define yy_flex_debug zconf_flex_debug
+#define yy_init_buffer zconf_init_buffer
+#define yy_flush_buffer zconf_flush_buffer
+#define yy_load_buffer_state zconf_load_buffer_state
+#define yy_switch_to_buffer zconf_switch_to_buffer
+#define yyin zconfin
+#define yyleng zconfleng
+#define yylex zconflex
+#define yylineno zconflineno
+#define yyout zconfout
+#define yyrestart zconfrestart
+#define yytext zconftext
+#define yywrap zconfwrap
+#define yyalloc zconfalloc
+#define yyrealloc zconfrealloc
+#define yyfree zconffree
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap(n) 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+#define YY_NO_INPUT 1
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+static void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+static void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+static void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int zconflex_destroy (void );
+
+int zconfget_debug (void );
+
+void zconfset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE zconfget_extra (void );
+
+void zconfset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *zconfget_in (void );
+
+void zconfset_in  (FILE * in_str  );
+
+FILE *zconfget_out (void );
+
+void zconfset_out  (FILE * out_str  );
+
+int zconfget_leng (void );
+
+char *zconfget_text (void );
+
+int zconfget_lineno (void );
+
+void zconfset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( zconftext, zconfleng, 1, zconfout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		const struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		while (zconfleng) {
+			if ((zconftext[zconfleng-1] != ' ') && (zconftext[zconfleng-1] != '\t'))
+				break;
+			zconfleng--;
+		}
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) zconfrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in zconfensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name != NULL && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *iter;
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(file->name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n",
+		    zconf_curname(), zconf_lineno(), file->name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	for (iter = current_file->parent; iter; iter = iter->parent ) {
+		if (!strcmp(current_file->name,iter->name) ) {
+			printf("%s:%d: recursive inclusion detected. "
+			       "Inclusion path:\n  current file : '%s'\n",
+			       zconf_curname(), zconf_lineno(),
+			       zconf_curname());
+			iter = current_file->parent;
+			while (iter && \
+			       strcmp(iter->name,current_file->name)) {
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno-1);
+				iter = iter->parent;
+			}
+			if (iter)
+				printf("  included from: '%s:%d'\n",
+				       iter->name, iter->lineno+1);
+			exit(1);
+		}
+	}
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+const char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
diff -ruN a/scripts/kconfig/zconf.tab.c b/scripts/kconfig/zconf.tab.c
--- a/scripts/kconfig/zconf.tab.c	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/zconf.tab.c	2013-09-16 01:27:46.047767496 -0600
@@ -0,0 +1,2504 @@
+/* A Bison parser, made by GNU Bison 2.4.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
+   2009, 2010 Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.4.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse         zconfparse
+#define yylex           zconflex
+#define yyerror         zconferror
+#define yylval          zconflval
+#define yychar          zconfchar
+#define yydebug         zconfdebug
+#define yynerrs         zconfnerrs
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#include "lkc.h"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[SYMBOL_HASHSIZE];
+
+static struct menu *current_menu, *current_entry;
+
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 1
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_OPTIONAL = 272,
+     T_PROMPT = 273,
+     T_TYPE = 274,
+     T_DEFAULT = 275,
+     T_SELECT = 276,
+     T_RANGE = 277,
+     T_VISIBLE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	const struct kconf_id *id;
+
+
+
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Include zconf.hash.c here so it can see the token constants. */
+#include "zconf.hash.c"
+
+
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int yyi)
+#else
+static int
+YYID (yyi)
+    int yyi;
+#endif
+{
+  return yyi;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss_alloc;
+  YYSTYPE yyvs_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
+	Stack = &yyptr->Stack_alloc;					\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  11
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   290
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  50
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  118
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  191
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     6,     8,    11,    13,    14,    17,    20,
+      23,    26,    31,    36,    40,    42,    44,    46,    48,    50,
+      52,    54,    56,    58,    60,    62,    64,    66,    68,    72,
+      75,    79,    82,    86,    89,    90,    93,    96,    99,   102,
+     105,   108,   112,   117,   122,   127,   133,   137,   138,   142,
+     143,   146,   150,   153,   155,   159,   160,   163,   166,   169,
+     172,   175,   180,   184,   187,   192,   193,   196,   200,   202,
+     206,   207,   210,   213,   216,   220,   224,   228,   230,   234,
+     235,   238,   241,   244,   248,   252,   255,   258,   261,   262,
+     265,   268,   271,   276,   277,   280,   283,   286,   287,   290,
+     292,   294,   297,   300,   303,   305,   308,   309,   312,   314,
+     318,   322,   326,   329,   333,   337,   339,   341,   342
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
+{
+      37,     0,    -1,    81,    38,    -1,    38,    -1,    63,    39,
+      -1,    39,    -1,    -1,    39,    41,    -1,    39,    55,    -1,
+      39,    67,    -1,    39,    80,    -1,    39,    26,     1,    31,
+      -1,    39,    40,     1,    31,    -1,    39,     1,    31,    -1,
+      16,    -1,    18,    -1,    19,    -1,    21,    -1,    17,    -1,
+      22,    -1,    20,    -1,    23,    -1,    31,    -1,    61,    -1,
+      71,    -1,    44,    -1,    46,    -1,    69,    -1,    26,     1,
+      31,    -1,     1,    31,    -1,    10,    26,    31,    -1,    43,
+      47,    -1,    11,    26,    31,    -1,    45,    47,    -1,    -1,
+      47,    48,    -1,    47,    49,    -1,    47,    75,    -1,    47,
+      73,    -1,    47,    42,    -1,    47,    31,    -1,    19,    78,
+      31,    -1,    18,    79,    82,    31,    -1,    20,    83,    82,
+      31,    -1,    21,    26,    82,    31,    -1,    22,    84,    84,
+      82,    31,    -1,    24,    50,    31,    -1,    -1,    50,    26,
+      51,    -1,    -1,    34,    79,    -1,     7,    85,    31,    -1,
+      52,    56,    -1,    80,    -1,    53,    58,    54,    -1,    -1,
+      56,    57,    -1,    56,    75,    -1,    56,    73,    -1,    56,
+      31,    -1,    56,    42,    -1,    18,    79,    82,    31,    -1,
+      19,    78,    31,    -1,    17,    31,    -1,    20,    26,    82,
+      31,    -1,    -1,    58,    41,    -1,    14,    83,    81,    -1,
+      80,    -1,    59,    62,    60,    -1,    -1,    62,    41,    -1,
+      62,    67,    -1,    62,    55,    -1,     3,    79,    81,    -1,
+       4,    79,    31,    -1,    64,    76,    74,    -1,    80,    -1,
+      65,    68,    66,    -1,    -1,    68,    41,    -1,    68,    67,
+      -1,    68,    55,    -1,     6,    79,    31,    -1,     9,    79,
+      31,    -1,    70,    74,    -1,    12,    31,    -1,    72,    13,
+      -1,    -1,    74,    75,    -1,    74,    31,    -1,    74,    42,
+      -1,    16,    25,    83,    31,    -1,    -1,    76,    77,    -1,
+      76,    31,    -1,    23,    82,    -1,    -1,    79,    82,    -1,
+      26,    -1,    27,    -1,     5,    31,    -1,     8,    31,    -1,
+      15,    31,    -1,    31,    -1,    81,    31,    -1,    -1,    14,
+      83,    -1,    84,    -1,    84,    34,    84,    -1,    84,    28,
+      84,    -1,    30,    83,    29,    -1,    35,    83,    -1,    83,
+      32,    83,    -1,    83,    33,    83,    -1,    26,    -1,    27,
+      -1,    -1,    26,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,   104,   104,   104,   106,   106,   108,   110,   111,   112,
+     113,   114,   115,   119,   123,   123,   123,   123,   123,   123,
+     123,   123,   127,   128,   129,   130,   131,   132,   136,   137,
+     143,   151,   157,   165,   175,   177,   178,   179,   180,   181,
+     182,   185,   193,   199,   209,   215,   221,   224,   226,   237,
+     238,   243,   252,   257,   265,   268,   270,   271,   272,   273,
+     274,   277,   283,   294,   300,   310,   312,   317,   325,   333,
+     336,   338,   339,   340,   345,   352,   359,   364,   372,   375,
+     377,   378,   379,   382,   390,   397,   404,   410,   417,   419,
+     420,   421,   424,   432,   434,   435,   438,   445,   447,   452,
+     453,   456,   457,   458,   462,   463,   466,   467,   470,   471,
+     472,   473,   474,   475,   476,   479,   480,   483,   484
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT", "T_SELECT", "T_RANGE",
+  "T_VISIBLE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE", "T_UNEQUAL",
+  "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND", "T_EQUAL",
+  "T_NOT", "$accept", "input", "start", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "mainmenu_stmt", "menu",
+  "menu_entry", "menu_end", "menu_stmt", "menu_block", "source_stmt",
+  "comment", "comment_stmt", "help_start", "help", "depends_list",
+  "depends", "visibility_list", "visible", "prompt_stmt_opt", "prompt",
+  "end", "nl", "if_expr", "expr", "symbol", "word_opt", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint8 yyr1[] =
+{
+       0,    36,    37,    37,    38,    38,    39,    39,    39,    39,
+      39,    39,    39,    39,    40,    40,    40,    40,    40,    40,
+      40,    40,    41,    41,    41,    41,    41,    41,    42,    42,
+      43,    44,    45,    46,    47,    47,    47,    47,    47,    47,
+      47,    48,    48,    48,    48,    48,    49,    50,    50,    51,
+      51,    52,    53,    54,    55,    56,    56,    56,    56,    56,
+      56,    57,    57,    57,    57,    58,    58,    59,    60,    61,
+      62,    62,    62,    62,    63,    64,    65,    66,    67,    68,
+      68,    68,    68,    69,    70,    71,    72,    73,    74,    74,
+      74,    74,    75,    76,    76,    76,    77,    78,    78,    79,
+      79,    80,    80,    80,    81,    81,    82,    82,    83,    83,
+      83,    83,    83,    83,    83,    84,    84,    85,    85
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     2,     1,     2,     1,     0,     2,     2,     2,
+       2,     4,     4,     3,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     2,
+       3,     2,     3,     2,     0,     2,     2,     2,     2,     2,
+       2,     3,     4,     4,     4,     5,     3,     0,     3,     0,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     2,
+       2,     4,     3,     2,     4,     0,     2,     3,     1,     3,
+       0,     2,     2,     2,     3,     3,     3,     1,     3,     0,
+       2,     2,     2,     3,     3,     2,     2,     2,     0,     2,
+       2,     2,     4,     0,     2,     2,     2,     0,     2,     1,
+       1,     2,     2,     2,     1,     2,     0,     2,     1,     3,
+       3,     3,     2,     3,     3,     1,     1,     0,     1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint8 yydefact[] =
+{
+       6,     0,   104,     0,     3,     0,     6,     6,    99,   100,
+       0,     1,     0,     0,     0,     0,   117,     0,     0,     0,
+       0,     0,     0,    14,    18,    15,    16,    20,    17,    19,
+      21,     0,    22,     0,     7,    34,    25,    34,    26,    55,
+      65,     8,    70,    23,    93,    79,     9,    27,    88,    24,
+      10,     0,   105,     2,    74,    13,     0,   101,     0,   118,
+       0,   102,     0,     0,     0,   115,   116,     0,     0,     0,
+     108,   103,     0,     0,     0,     0,     0,     0,     0,    88,
+       0,     0,    75,    83,    51,    84,    30,    32,     0,   112,
+       0,     0,    67,     0,     0,    11,    12,     0,     0,     0,
+       0,    97,     0,     0,     0,    47,     0,    40,    39,    35,
+      36,     0,    38,    37,     0,     0,    97,     0,    59,    60,
+      56,    58,    57,    66,    54,    53,    71,    73,    69,    72,
+      68,   106,    95,     0,    94,    80,    82,    78,    81,    77,
+      90,    91,    89,   111,   113,   114,   110,   109,    29,    86,
+       0,   106,     0,   106,   106,   106,     0,     0,     0,    87,
+      63,   106,     0,   106,     0,    96,     0,     0,    41,    98,
+       0,     0,   106,    49,    46,    28,     0,    62,     0,   107,
+      92,    42,    43,    44,     0,     0,    48,    61,    64,    45,
+      50
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     3,     4,     5,    33,    34,   108,    35,    36,    37,
+      38,    74,   109,   110,   157,   186,    39,    40,   124,    41,
+      76,   120,    77,    42,   128,    43,    78,     6,    44,    45,
+     137,    46,    80,    47,    48,    49,   111,   112,    81,   113,
+      79,   134,   152,   153,    50,     7,   165,    69,    70,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -90
+static const yytype_int16 yypact[] =
+{
+       4,    42,   -90,    96,   -90,   111,   -90,    15,   -90,   -90,
+      75,   -90,    82,    42,   104,    42,   110,   107,    42,   115,
+     125,    -4,   121,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   162,   -90,   163,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   139,   -90,   -90,   138,   -90,   142,   -90,   143,   -90,
+     152,   -90,   164,   167,   168,   -90,   -90,    -4,    -4,    77,
+     -18,   -90,   177,   185,    33,    71,   195,   247,   236,    -2,
+     236,   171,   -90,   -90,   -90,   -90,   -90,   -90,    41,   -90,
+      -4,    -4,   138,    97,    97,   -90,   -90,   186,   187,   194,
+      42,    42,    -4,   196,    97,   -90,   219,   -90,   -90,   -90,
+     -90,   210,   -90,   -90,   204,    42,    42,   199,   -90,   -90,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   222,   -90,   223,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -90,   -90,   -90,   215,   -90,   -90,   -90,   -90,   -90,
+      -4,   222,   228,   222,    -5,   222,    97,    35,   229,   -90,
+     -90,   222,   232,   222,    -4,   -90,   135,   233,   -90,   -90,
+     234,   235,   222,   240,   -90,   -90,   237,   -90,   239,   -13,
+     -90,   -90,   -90,   -90,   244,    42,   -90,   -90,   -90,   -90,
+     -90
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+     -90,   -90,   269,   271,   -90,    23,   -70,   -90,   -90,   -90,
+     -90,   243,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -48,
+     -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,   -90,
+     -90,   -20,   -90,   -90,   -90,   -90,   -90,   206,   205,   -68,
+     -90,   -90,   169,    -1,    27,    -7,   118,   -66,   -89,   -90
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -86
+static const yytype_int16 yytable[] =
+{
+      10,    88,    89,    54,   146,   147,   119,     1,   122,   164,
+      93,   141,    56,   142,    58,   156,    94,    62,     1,    90,
+      91,   131,    65,    66,   144,   145,    67,    90,    91,   132,
+     127,    68,   136,   -31,    97,     2,   154,   -31,   -31,   -31,
+     -31,   -31,   -31,   -31,   -31,    98,    52,   -31,   -31,    99,
+     -31,   100,   101,   102,   103,   104,   -31,   105,   129,   106,
+     138,   173,    92,   141,   107,   142,   174,   172,     8,     9,
+     143,   -33,    97,    90,    91,   -33,   -33,   -33,   -33,   -33,
+     -33,   -33,   -33,    98,   166,   -33,   -33,    99,   -33,   100,
+     101,   102,   103,   104,   -33,   105,    11,   106,   179,   151,
+     123,   126,   107,   135,   125,   130,     2,   139,     2,    90,
+      91,    -5,    12,    55,   161,    13,    14,    15,    16,    17,
+      18,    19,    20,    65,    66,    21,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    57,    59,    31,    61,    -4,
+      12,    63,    32,    13,    14,    15,    16,    17,    18,    19,
+      20,    64,    71,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    72,    73,    31,   180,    90,    91,    52,
+      32,   -85,    97,    82,    83,   -85,   -85,   -85,   -85,   -85,
+     -85,   -85,   -85,    84,   190,   -85,   -85,    99,   -85,   -85,
+     -85,   -85,   -85,   -85,   -85,    85,    97,   106,    86,    87,
+     -52,   -52,   140,   -52,   -52,   -52,   -52,    98,    95,   -52,
+     -52,    99,   114,   115,   116,   117,    96,   148,   149,   150,
+     158,   106,   155,   159,    97,   163,   118,   -76,   -76,   -76,
+     -76,   -76,   -76,   -76,   -76,   160,   164,   -76,   -76,    99,
+      13,    14,    15,    16,    17,    18,    19,    20,    91,   106,
+      21,    22,    14,    15,   140,    17,    18,    19,    20,   168,
+     175,    21,    22,   177,   181,   182,   183,    32,   187,   167,
+     188,   169,   170,   171,   185,   189,    53,    51,    32,   176,
+      75,   178,   121,     0,   133,   162,     0,     0,     0,     0,
+     184
+};
+
+static const yytype_int16 yycheck[] =
+{
+       1,    67,    68,    10,    93,    94,    76,     3,    76,    14,
+      28,    81,    13,    81,    15,   104,    34,    18,     3,    32,
+      33,    23,    26,    27,    90,    91,    30,    32,    33,    31,
+      78,    35,    80,     0,     1,    31,   102,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    78,    26,
+      80,    26,    69,   133,    31,   133,    31,   156,    26,    27,
+      29,     0,     1,    32,    33,     4,     5,     6,     7,     8,
+       9,    10,    11,    12,   150,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    24,     0,    26,   164,   100,
+      77,    78,    31,    80,    77,    78,    31,    80,    31,    32,
+      33,     0,     1,    31,   115,     4,     5,     6,     7,     8,
+       9,    10,    11,    26,    27,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,    26,    26,    31,     0,
+       1,    26,    31,     4,     5,     6,     7,     8,     9,    10,
+      11,    26,    31,    14,    15,    16,    17,    18,    19,    20,
+      21,    22,    23,     1,     1,    26,    31,    32,    33,    31,
+      31,     0,     1,    31,    31,     4,     5,     6,     7,     8,
+       9,    10,    11,    31,   185,    14,    15,    16,    17,    18,
+      19,    20,    21,    22,    23,    31,     1,    26,    31,    31,
+       5,     6,    31,     8,     9,    10,    11,    12,    31,    14,
+      15,    16,    17,    18,    19,    20,    31,    31,    31,    25,
+       1,    26,    26,    13,     1,    26,    31,     4,     5,     6,
+       7,     8,     9,    10,    11,    31,    14,    14,    15,    16,
+       4,     5,     6,     7,     8,     9,    10,    11,    33,    26,
+      14,    15,     5,     6,    31,     8,     9,    10,    11,    31,
+      31,    14,    15,    31,    31,    31,    31,    31,    31,   151,
+      31,   153,   154,   155,    34,    31,     7,     6,    31,   161,
+      37,   163,    76,    -1,    79,   116,    -1,    -1,    -1,    -1,
+     172
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint8 yystos[] =
+{
+       0,     3,    31,    37,    38,    39,    63,    81,    26,    27,
+      79,     0,     1,     4,     5,     6,     7,     8,     9,    10,
+      11,    14,    15,    16,    17,    18,    19,    20,    21,    22,
+      23,    26,    31,    40,    41,    43,    44,    45,    46,    52,
+      53,    55,    59,    61,    64,    65,    67,    69,    70,    71,
+      80,    39,    31,    38,    81,    31,    79,    31,    79,    26,
+      85,    31,    79,    26,    26,    26,    27,    30,    35,    83,
+      84,    31,     1,     1,    47,    47,    56,    58,    62,    76,
+      68,    74,    31,    31,    31,    31,    31,    31,    83,    83,
+      32,    33,    81,    28,    34,    31,    31,     1,    12,    16,
+      18,    19,    20,    21,    22,    24,    26,    31,    42,    48,
+      49,    72,    73,    75,    17,    18,    19,    20,    31,    42,
+      57,    73,    75,    41,    54,    80,    41,    55,    60,    67,
+      80,    23,    31,    74,    77,    41,    55,    66,    67,    80,
+      31,    42,    75,    29,    83,    83,    84,    84,    31,    31,
+      25,    79,    78,    79,    83,    26,    84,    50,     1,    13,
+      31,    79,    78,    26,    14,    82,    83,    82,    31,    82,
+      82,    82,    84,    26,    31,    31,    82,    31,    82,    83,
+      31,    31,    31,    31,    82,    34,    51,    31,    31,    31,
+      79
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  However,
+   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
+   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
+   discussed.  */
+
+#define YYFAIL		goto yyerrlab
+#if defined YYFAIL
+  /* This is here to suppress warnings from the GCC cpp's
+     -Wunused-macros.  Normally we don't worry about that warning, but
+     some users do, and we want to make it easy for users to remove
+     YYFAIL uses, which will produce warnings from Bison 2.5.  */
+#endif
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK (1);						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (YYID (0))
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (YYID (N))                                                    \
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
+#else
+static void
+yy_stack_print (yybottom, yytop)
+    yytype_int16 *yybottom;
+    yytype_int16 *yytop;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       		       );
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 53: /* "choice_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 59: /* "if_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+      case 65: /* "menu_entry" */
+
+	{
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+	break;
+
+      default:
+	break;
+    }
+}
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+/* The lookahead symbol.  */
+int yychar;
+
+/* The semantic value of the lookahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*-------------------------.
+| yyparse or yypush_parse.  |
+`-------------------------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+
+    int yystate;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus;
+
+    /* The stacks and their tools:
+       `yyss': related to states.
+       `yyvs': related to semantic values.
+
+       Refer to the stacks thru separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* The state stack.  */
+    yytype_int16 yyssa[YYINITDEPTH];
+    yytype_int16 *yyss;
+    yytype_int16 *yyssp;
+
+    /* The semantic value stack.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs;
+    YYSTYPE *yyvsp;
+
+    YYSIZE_T yystacksize;
+
+  int yyn;
+  int yyresult;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yytoken;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  yytoken = 0;
+  yyss = yyssa;
+  yyvs = yyvsa;
+  yystacksize = YYINITDEPTH;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack.  Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	yytype_int16 *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	yytype_int16 *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss_alloc, yyss);
+	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 10:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 11:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[(2) - (4)].string)); ;}
+    break;
+
+  case 12:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[(2) - (4)].id)->name);
+;}
+    break;
+
+  case 13:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 28:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[(1) - (3)].string)); ;}
+    break;
+
+  case 29:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 30:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 31:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 32:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 33:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_set_type((yyvsp[(1) - (3)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (3)].id)->stype);
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 43:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[(2) - (4)].expr), (yyvsp[(3) - (4)].expr));
+	if ((yyvsp[(1) - (4)].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[(1) - (4)].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[(1) - (4)].id)->stype);
+;}
+    break;
+
+  case 44:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[(2) - (5)].symbol), (yyvsp[(3) - (5)].symbol)), (yyvsp[(4) - (5)].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 48:
+
+    {
+	const struct kconf_id *id = kconf_id_lookup((yyvsp[(2) - (3)].string), strlen((yyvsp[(2) - (3)].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[(3) - (3)].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[(2) - (3)].string));
+	free((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 49:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 50:
+
+    { (yyval.string) = (yyvsp[(2) - (2)].string); ;}
+    break;
+
+  case 51:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[(2) - (3)].string), SYMBOL_CHOICE);
+	sym->flags |= SYMBOL_AUTO;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 52:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 53:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 61:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(2) - (4)].string), (yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 62:
+
+    {
+	if ((yyvsp[(1) - (3)].id)->stype == S_BOOLEAN || (yyvsp[(1) - (3)].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[(1) - (3)].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[(1) - (3)].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 63:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 64:
+
+    {
+	if ((yyvsp[(1) - (4)].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[(2) - (4)].string), 0), (yyvsp[(3) - (4)].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 67:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[(2) - (3)].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 68:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 74:
+
+    {
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+;}
+    break;
+
+  case 75:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 76:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 77:
+
+    {
+	if (zconf_endtoken((yyvsp[(1) - (1)].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 83:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[(2) - (3)].string));
+	zconf_nextfile((yyvsp[(2) - (3)].string));
+;}
+    break;
+
+  case 84:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[(2) - (3)].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 85:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 86:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 87:
+
+    {
+	current_entry->help = (yyvsp[(2) - (2)].string);
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_dep((yyvsp[(3) - (4)].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 96:
+
+    {
+	menu_add_visibility((yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 98:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].expr));
+;}
+    break;
+
+  case 101:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 102:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 103:
+
+    { (yyval.id) = (yyvsp[(1) - (2)].id); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = (yyvsp[(2) - (2)].expr); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[(1) - (1)].symbol)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[(1) - (3)].symbol), (yyvsp[(3) - (3)].symbol)); ;}
+    break;
+
+  case 111:
+
+    { (yyval.expr) = (yyvsp[(2) - (3)].expr); ;}
+    break;
+
+  case 112:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[(2) - (2)].expr)); ;}
+    break;
+
+  case 113:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 114:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[(1) - (3)].expr), (yyvsp[(3) - (3)].expr)); ;}
+    break;
+
+  case 115:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), 0); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 116:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[(1) - (1)].string), SYMBOL_CONST); free((yyvsp[(1) - (1)].string)); ;}
+    break;
+
+  case 117:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+
+
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
+	      {
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
+	      }
+	  }
+
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (yymsg);
+	  }
+	else
+	  {
+	    yyerror (YY_("syntax error"));
+	    if (yysize != 0)
+	      goto yyexhaustedlab;
+	  }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+	{
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+	}
+      else
+	{
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#if !defined(yyoverflow) || YYERROR_VERBOSE
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	_menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+
+	rootmenu.prompt->text = _(rootmenu.prompt->text);
+	rootmenu.prompt->text = sym_expand_string_value(rootmenu.prompt->text);
+
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		if (sym_check_deps(sym))
+			zconfnerrs++;
+        }
+	if (zconfnerrs)
+		exit(1);
+	sym_set_change_count(1);
+}
+
+static const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	case T_VISIBLE:		return "visible";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(const struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+}
+
+static void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+static void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "\nchoice\n");
+	else
+		fprintf(out, "\nconfig %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		case P_SELECT:
+			fputs( "  select ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_RANGE:
+			fputs( "  range ", out);
+			expr_fprint(prop->expr, out);
+			fputc('\n', out);
+			break;
+		case P_MENU:
+			fputs( "  menu ", out);
+			print_quoted_string(out, prop->text);
+			fputc('\n', out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (menu->help) {
+		int len = strlen(menu->help);
+		while (menu->help[--len] == '\n')
+			menu->help[len] = 0;
+		fprintf(out, "  help\n%s\n", menu->help);
+	}
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "zconf.lex.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
diff -ruN a/scripts/kconfig/.zconf.tab.o.cmd b/scripts/kconfig/.zconf.tab.o.cmd
--- a/scripts/kconfig/.zconf.tab.o.cmd	1969-12-31 17:00:00.000000000 -0700
+++ b/scripts/kconfig/.zconf.tab.o.cmd	2013-09-16 01:27:46.047767496 -0600
@@ -0,0 +1,95 @@
+cmd_scripts/kconfig/zconf.tab.o := gcc -Wp,-MD,scripts/kconfig/.zconf.tab.o.d -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer   -DCURSES_LOC="<ncurses.h>" -DLOCALE  -Iscripts/kconfig -c -o scripts/kconfig/zconf.tab.o scripts/kconfig/zconf.tab.c
+
+source_scripts/kconfig/zconf.tab.o := scripts/kconfig/zconf.tab.c
+
+deps_scripts/kconfig/zconf.tab.o := \
+  /usr/include/ctype.h \
+  /usr/include/features.h \
+  /usr/include/stdc-predef.h \
+  /usr/include/sys/cdefs.h \
+  /usr/include/bits/wordsize.h \
+  /usr/include/gnu/stubs.h \
+  /usr/include/gnu/stubs-soft.h \
+  /usr/include/bits/types.h \
+  /usr/include/bits/typesizes.h \
+  /usr/include/endian.h \
+  /usr/include/bits/endian.h \
+  /usr/include/bits/byteswap.h \
+  /usr/include/bits/byteswap-16.h \
+  /usr/include/xlocale.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdarg.h \
+  /usr/include/stdio.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stddef.h \
+  /usr/include/libio.h \
+  /usr/include/_G_config.h \
+  /usr/include/wchar.h \
+  /usr/include/bits/stdio_lim.h \
+  /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h \
+  /usr/include/stdlib.h \
+  /usr/include/bits/waitflags.h \
+  /usr/include/bits/waitstatus.h \
+  /usr/include/sys/types.h \
+  /usr/include/time.h \
+  /usr/include/sys/select.h \
+  /usr/include/bits/select.h \
+  /usr/include/bits/sigset.h \
+  /usr/include/bits/time.h \
+  /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h \
+  /usr/include/alloca.h \
+  /usr/include/bits/stdlib-float.h \
+  /usr/include/string.h \
+  /usr/include/bits/string.h \
+  /usr/include/bits/string2.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include/stdbool.h \
+  scripts/kconfig/lkc.h \
+    $(wildcard include/config/.h) \
+    $(wildcard include/config/list.h) \
+  scripts/kconfig/expr.h \
+  /usr/include/libintl.h \
+  /usr/include/locale.h \
+  /usr/include/bits/locale.h \
+  scripts/kconfig/lkc_proto.h \
+  scripts/kconfig/zconf.hash.c \
+  scripts/kconfig/zconf.lex.c \
+  /usr/include/errno.h \
+  /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h \
+  /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h \
+  /usr/include/asm-generic/errno-base.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/limits.h \
+  /usr/lib/gcc/armv5tel-unknown-linux-gnueabi/4.7.2/include-fixed/syslimits.h \
+  /usr/include/limits.h \
+  /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h \
+  /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/include/unistd.h \
+  /usr/include/bits/posix_opt.h \
+  /usr/include/bits/environments.h \
+  /usr/include/bits/confname.h \
+  /usr/include/getopt.h \
+  scripts/kconfig/util.c \
+  scripts/kconfig/confdata.c \
+    $(wildcard include/config/config.h) \
+    $(wildcard include/config/autoconfig.h) \
+    $(wildcard include/config/overwriteconfig.h) \
+    $(wildcard include/config/autoheader.h) \
+    $(wildcard include/config/tristate.h) \
+  /usr/include/sys/stat.h \
+  /usr/include/bits/stat.h \
+  /usr/include/fcntl.h \
+  /usr/include/bits/fcntl.h \
+  /usr/include/bits/fcntl-linux.h \
+  scripts/kconfig/expr.c \
+  scripts/kconfig/symbol.c \
+  /usr/include/regex.h \
+  /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h \
+  scripts/kconfig/menu.c \
+
+scripts/kconfig/zconf.tab.o: $(deps_scripts/kconfig/zconf.tab.o)
+
+$(deps_scripts/kconfig/zconf.tab.o):
