/* -*- Mode: C -*-  */

autogen definitions fixincl;

/* Define all the fixes we know about for repairing damaged headers.
   Please see the README before adding or changing entries in this file.

   This is the sort command:

   blocksort output=inclhack.sorted \
          pattern='^/\*$' \
          trailer='^/\*EOF\*[/]' \
          input=inclhack.def \
          key='hackname[ 	]*=[ 	]*(.*);'

   Set up a debug test so we can make the templates emit special
   code while debugging these fixes:  */

#ifdef DEBUG
FIXINC_DEBUG = yes;
#endif

/* On AIX when _LARGE_FILES is defined stdio.h defines fopen to
 * fopen64 etc. and this causes problems when building with g++
 * because cstdio udefs everything from stdio.h, leaving us with
 * ::fopen has not been declared errors. This fixes stdio.h to
 * undef those defines and use __asm__ to alias the symbols if
 * building with g++ and -D_LARGE_FILES
 */
fix = {
    hackname  = AAB_aix_stdio;
    files     = stdio.h;
    select    = "define fopen fopen64";
    mach      = "*-*-aix*";
    test-text = ''; /* no way to test */

    c_fix     = wrap;

    c_fix_arg = "";

    c_fix_arg = <<- _EOArg_

	#if defined __GNUG__ && defined _LARGE_FILES && defined __cplusplus
	#define __need__aix_stdio_h_fix
	#ifdef __need__aix_stdio_h_fix
	#undef fseeko
	#undef ftello
	#undef fgetpos
	#undef fsetpos
	#undef fopen
	#undef freopen
	/* Alias the symbols using asm */
	extern "C" {
	extern int fgetpos(FILE *, fpos64_t *) __asm__("fgetpos64");
	extern FILE *fopen(const char *, const char *) __asm__("fopen64");
	extern FILE *freopen(const char *, const char *, FILE *) __asm__("freopen64");
	extern int fseeko(FILE *, off64_t, int) __asm__("fseeko64");
	extern int fsetpos(FILE *, const fpos64_t *) __asm__("fsetpos64");
	extern off64_t ftello(FILE *) __asm__("ftello64");
	}
	#endif
	#endif

	_EOArg_;
};


/*
 *  On Mac OS 10.3.9, the 'long double' functions are available in
 *  libSystem, but are not prototyped in math.h.
 */
fix = {
  hackname  = AAB_darwin7_9_long_double_funcs;
  mach      = "*-*-darwin7.9*";
  files     = architecture/ppc/math.h;
  bypass    = "powl";
  replace = <<- _EndOfHeader_
	/* This file prototypes the long double functions available on Mac OS
	   10.3.9.  */
	#ifndef __MATH__
	# undef __APPLE_CC__
	# define __APPLE_CC__  1345
	# include_next <architecture/ppc/math.h>
	# undef __APPLE_CC__
	# define __APPLE_CC__ 1
	# ifndef __LIBMLDBL_COMPAT
	#  ifdef __LONG_DOUBLE_128__
	#   define __LIBMLDBL_COMPAT(sym) __asm("_" #sym "$LDBL128")
	#  else
	#   define __LIBMLDBL_COMPAT(sym)
	#  endif /* __LONG_DOUBLE_128__ */
	# endif /* __LIBMLDBL_COMPAT */
	# ifdef __cplusplus
	   extern "C" {
	# endif
	  extern long double acosl( long double ) __LIBMLDBL_COMPAT(acosl);
	  extern long double asinl( long double ) __LIBMLDBL_COMPAT(asinl);
	  extern long double atanl( long double ) __LIBMLDBL_COMPAT(atanl);
	  extern long double atan2l( long double, long double ) __LIBMLDBL_COMPAT(atan2l);
	  extern long double cosl( long double ) __LIBMLDBL_COMPAT(cosl);
	  extern long double sinl( long double ) __LIBMLDBL_COMPAT(sinl);
	  extern long double tanl( long double ) __LIBMLDBL_COMPAT(tanl);
	  extern long double acoshl( long double ) __LIBMLDBL_COMPAT(acoshl);
	  extern long double asinhl( long double ) __LIBMLDBL_COMPAT(asinhl);
	  extern long double atanhl( long double ) __LIBMLDBL_COMPAT(atanhl);
	  extern long double coshl( long double ) __LIBMLDBL_COMPAT(coshl);
	  extern long double sinhl( long double ) __LIBMLDBL_COMPAT(sinhl);
	  extern long double tanhl( long double ) __LIBMLDBL_COMPAT(tanhl);
	  extern long double expl( long double ) __LIBMLDBL_COMPAT(expl);
	  extern long double exp2l( long double ) __LIBMLDBL_COMPAT(exp2l);
	  extern long double expm1l( long double ) __LIBMLDBL_COMPAT(expm1l);
	  extern long double logl( long double ) __LIBMLDBL_COMPAT(logl);
	  extern long double log10l( long double ) __LIBMLDBL_COMPAT(log10l);
	  extern long double log2l( long double ) __LIBMLDBL_COMPAT(log2l);
	  extern long double log1pl( long double ) __LIBMLDBL_COMPAT(log1pl);
	  extern long double logbl( long double ) __LIBMLDBL_COMPAT(logbl);
	  extern long double modfl( long double, long double * ) __LIBMLDBL_COMPAT(modfl);
	  extern long double ldexpl( long double, int ) __LIBMLDBL_COMPAT(ldexpl);
	  extern long double frexpl( long double, int * ) __LIBMLDBL_COMPAT(frexpl);
	  extern int ilogbl( long double ) __LIBMLDBL_COMPAT(ilogbl);
	  extern long double scalbnl( long double, int ) __LIBMLDBL_COMPAT(scalbnl);
	  extern long double scalblnl( long double, long int ) __LIBMLDBL_COMPAT(scalblnl);
	  extern long double fabsl( long double ) __LIBMLDBL_COMPAT(fabsl);
	  extern long double cbrtl( long double ) __LIBMLDBL_COMPAT(cbrtl);
	  extern long double hypotl( long double, long double ) __LIBMLDBL_COMPAT(hypotl);
	  extern long double powl( long double, long double ) __LIBMLDBL_COMPAT(powl);
	  extern long double sqrtl( long double ) __LIBMLDBL_COMPAT(sqrtl);
	  extern long double erfl( long double ) __LIBMLDBL_COMPAT(erfl);
	  extern long double erfcl( long double ) __LIBMLDBL_COMPAT(erfcl);
	  extern long double lgammal( long double ) __LIBMLDBL_COMPAT(lgammal);
	  extern long double tgammal( long double ) __LIBMLDBL_COMPAT(tgammal);
	  extern long double ceill( long double ) __LIBMLDBL_COMPAT(ceill);
	  extern long double floorl( long double ) __LIBMLDBL_COMPAT(floorl);
	  extern long double nearbyintl( long double ) __LIBMLDBL_COMPAT(nearbyintl);
	  extern long double rintl( long double ) __LIBMLDBL_COMPAT(rintl);
	  extern long int lrintl( long double ) __LIBMLDBL_COMPAT(lrintl);
	  extern long long int llrintl( long double ) __LIBMLDBL_COMPAT(llrintl);
	  extern long double roundl( long double ) __LIBMLDBL_COMPAT(roundl);
	  extern long int lroundl( long double ) __LIBMLDBL_COMPAT(lroundl);
	  extern long long int llroundl( long double ) __LIBMLDBL_COMPAT(llroundl);
	  extern long double truncl( long double ) __LIBMLDBL_COMPAT(truncl);
	  extern long double fmodl( long double, long double) __LIBMLDBL_COMPAT(fmodl);
	  extern long double remainderl( long double, long double ) __LIBMLDBL_COMPAT(remainderl);
	  extern long double remquol( long double, long double, int * ) __LIBMLDBL_COMPAT(remquol);
	  extern long double copysignl( long double, long double ) __LIBMLDBL_COMPAT(copysignl);
	  extern long double nanl( const char * ) __LIBMLDBL_COMPAT(nanl);
	  extern long double nextafterl( long double, long double ) __LIBMLDBL_COMPAT(nextafterl);
	  extern long double nexttowardl( long double, long double ) __LIBMLDBL_COMPAT(nexttowardl);
	  extern long double fdiml( long double, long double ) __LIBMLDBL_COMPAT(fdiml);
	  extern long double fmaxl( long double, long double ) __LIBMLDBL_COMPAT(fmaxl);
	  extern long double fminl( long double, long double ) __LIBMLDBL_COMPAT(fminl);
	  extern long double fmal( long double, long double, long double ) __LIBMLDBL_COMPAT(fmal);
	# ifdef __cplusplus
	   }
	# endif
	#endif /* __MATH__ */
	_EndOfHeader_;
};


/*
 *  ... and for the previous fix to be useful, you have to not use ""
 *  includes.
 */
fix = {
  hackname  = AAB_darwin7_9_long_double_funcs_2;
  mach      = "*-*-darwin7.9*";
  files     = math.h;
  select    = '#include[ \t]+\"';
  c_fix     = format;
  c_fix_arg = "%1<%2.h>";
  
  c_fix_arg = '([ \t]*#[ \t]*include[ \t]+)"([a-z0-9/]+)\.h"';
  
  test_text = '#include "architecture/ppc/math.h"';
};


/*
 *  This fixes __FD_ZERO bug for linux 2.x.y (x <= 2 && y <= some n)
 */
fix = {
    hackname = AAB_fd_zero_asm_posix_types_h;
    files    = asm/posix_types.h;
    mach     = 'i[34567]86-*-linux*';
    bypass   = '} while';
    bypass   = 'x86_64';
    bypass   = 'posix_types_64';

    /*
     * Define _POSIX_TYPES_H_WRAPPER at the end of the wrapper, not
     * the start, so that if #include_next gets another instance of
     * the wrapper, this will follow the #include_next chain until
     * we arrive at the real <asm/posix_types.h>.
     */
    replace  = <<-  _EndOfHeader_
	/* This file fixes a bug in the __FD_ZERO macro
	   for older versions of the Linux kernel. */
	#ifndef _POSIX_TYPES_H_WRAPPER
	#include <features.h>
	 #include_next <asm/posix_types.h>
	
	#if defined(__FD_ZERO) && !defined(__GLIBC__)
	#undef __FD_ZERO
	#define __FD_ZERO(fdsetp) \
	  do { \
	    int __d0, __d1; \
		__asm__ __volatile__("cld ; rep ; stosl" \
			: "=&c" (__d0), "=&D" (__d1) \
			: "a" (0), "0" (__FDSET_LONGS), \
			  "1" ((__kernel_fd_set *) (fdsetp)) :"memory"); \
	  } while (0)
	#endif
	
	#define _POSIX_TYPES_H_WRAPPER
	#endif /* _POSIX_TYPES_H_WRAPPER */
	_EndOfHeader_;
};


/*
 *  This fixes __FD_ZERO bug for glibc-1.x
 */
fix = {
    hackname = AAB_fd_zero_gnu_types_h;
    files    = gnu/types.h;
    mach     = 'i[34567]86-*-linux*';

    /*
     * Define _TYPES_H_WRAPPER at the end of the wrapper, not
     * the start, so that if #include_next gets another instance of
     * the wrapper, this will follow the #include_next chain until
     * we arrive at the real <gnu/types.h>.
     */
    replace  = <<-  _EndOfHeader_
	/* This file fixes a bug in the __FD_ZERO macro present in glibc 1.x. */
	#ifndef _TYPES_H_WRAPPER
	#include <features.h>
	#include_next <gnu/types.h>

	#if defined(__FD_ZERO) && !defined(__GLIBC__)
	#undef __FD_ZERO
	# define __FD_ZERO(fdsetp) \
	  do { \
	    int __d0, __d1; \
	        __asm__ __volatile__("cld ; rep ; stosl" \
	        : "=&c" (__d0), "=&D" (__d1) \
	        : "a" (0), "0" (__FDSET_LONGS), \
	          "1" ((__fd_set *) (fdsetp)) :"memory"); \
	  } while (0)
	#endif

	#define _TYPES_H_WRAPPER
	#endif /* _TYPES_H_WRAPPER */
	_EndOfHeader_;
};


/*
 *  This fixes __FD_ZERO bug for glibc-2.0.x
 */
fix = {
    hackname = AAB_fd_zero_selectbits_h;
    files    = selectbits.h;
    mach     = 'i[34567]86-*-linux*';

    /*
     * Define _SELECTBITS_H_WRAPPER at the end of the wrapper, not
     * the start, so that if #include_next gets another instance of
     * the wrapper, this will follow the #include_next chain until
     * we arrive at the real <selectbits.h>.
     */
    replace  = <<-  _EndOfHeader_
	/* This file fixes a bug in the __FD_ZERO macro present in glibc 2.0.x. */
	#ifndef _SELECTBITS_H_WRAPPER
	  #include <features.h>
	  #include_next <selectbits.h>

	  #if defined(__FD_ZERO) && defined(__GLIBC__) \\
	  && defined(__GLIBC_MINOR__) && __GLIBC__ == 2 \\
	  && __GLIBC_MINOR__ == 0
	     #undef __FD_ZERO
	     #define __FD_ZERO(fdsetp) \\
	     do { \\
	        int __d0, __d1; \\
	      __asm__ __volatile__ ("cld; rep; stosl" \\
                        : "=&c" (__d0), "=&D" (__d1) \\
                        : "a" (0), "0" (sizeof (__fd_set) \\
                                        / sizeof (__fd_mask)), \\
                          "1" ((__fd_mask *) (fdsetp)) \\
                        : "memory"); \\
	      } while (0)
	  #endif

	  #define _SELECTBITS_H_WRAPPER
	#endif /* _SELECTBITS_H_WRAPPER */
	_EndOfHeader_;
};


/*
 * Solaris <sys/varargs.h> is a DDK (aka kernel-land) header providing
 * the same interface as <stdarg.h>.  No idea why they couldn't have just
 * used the standard header.
 */
fix = {
    hackname = AAB_solaris_sys_varargs_h;
    files    = "sys/varargs.h";
    mach     = '*-*-solaris*';
    replace  = <<-  _EndOfHeader_
	#ifdef __STDC__
	  #include <stdarg.h>
	#else
	  #include <varargs.h>
	#endif
	_EndOfHeader_;
};


/*
 *  Fix non-ANSI memcpy declaration that conflicts with gcc's builtin
 *  declaration on Sun OS 4.x.  We must only fix this on Sun OS 4.x, because
 *  many other systems have similar text but correct versions of the file.
 *  To ensure only Sun's is fixed, we grep for a likely unique string.
 *  Fix also on sysV68 R3V7.1 (head/memory.h\t50.1\t )
 */
fix = {
    hackname = AAB_sun_memcpy;
    files    = memory.h;
    select   = "/\\*\t@\\(#\\)"
             "(head/memory.h\t50.1\t "
             "|memory\\.h 1\\.[2-4] 8./../.. SMI; from S5R2 1\\.2\t)\\*/";

    replace = <<-  _EndOfHeader_
	/* This file was generated by fixincludes */
	#ifndef __memory_h__
	  #define __memory_h__

	  #ifdef __STDC__
	    extern void *memccpy();
	    extern void *memchr();
	    extern void *memcpy();
	    extern void *memset();
	  #else
	    extern char *memccpy();
	    extern char *memchr();
	    extern char *memcpy();
	    extern char *memset();
	  #endif /* __STDC__ */

	  extern int memcmp();

	#endif /* __memory_h__ */
	_EndOfHeader_;
};


/*
 *  pthread.h on AIX 4.3.3 tries to define a macro without whitspace
 *  which violates a requirement of ISO C.
 */
fix = {
    hackname  = aix_pthread;
    files     = "pthread.h";
    select    = "(#define [A-Za-z_0-9]+)(\\\\\n[^A-Za-z_0-9 \t\n(])";
    c_fix     = format;
    c_fix_arg = "%1 %2";
    test_text = "#define PTHREAD_MUTEX_INITIALIZER\\\\\n"
                "{...init stuff...}";
};


/*
 *  sys/machine.h on AIX 4.3.3 puts whitespace between a \ and a newline
 *  in an otherwise harmless (and #ifed out) macro definition
 */
fix = {
    hackname  = aix_sysmachine;
    files     = sys/machine.h;
    select    = "\\\\ +\n";
    c_fix     = format;
    c_fix_arg = "\\\n";
    test_text = "#define FOO \\\n"
    " bar \\ \n baz \\ \n bat";
};


/*
 *  sys/wait.h on AIX 3.2.5 puts the declaration of wait3 before the
 *  definition of struct rusage, so the prototype added by fixproto fails.
 */
fix = {
    hackname  = aix_syswait;
    files     = sys/wait.h;
    select    = "^extern pid_t wait3\\(\\);\n";
    select    = "bos325,";
    c_fix     = format;
    c_fix_arg = "struct rusage;\n%0";
    test_text = "/* bos325, */\n"
    "extern pid_t wait3();\n"
    "\t/* pid_t wait3(int *, int, struct rusage *); */";
};


/*
 *  sys/wait.h on AIX 5.2 defines macros that have both signed and
 *  unsigned types in conditional expressions.
 */
fix = {
    hackname  = aix_syswait_2;
    files     = sys/wait.h;
    select    = '\? (\(\(\(\(unsigned[^)]*\)[^)]*\) >> [^)]*\) \& 0xff\) : -1)';
    c_fix     = format;
    c_fix_arg = "? (int)%1";
    test_text = "#define WSTOPSIG(__x)    (int)(WIFSTOPPED(__x) ? ((((unsigned int)__x) >> 8) & 0xff) : -1)";
};


/*
 *  sys/signal.h on some versions of AIX uses volatile in the typedef of
 *  sig_atomic_t, which causes gcc to generate a warning about duplicate
 *  volatile when a sig_atomic_t variable is declared volatile, as
 *  required by ANSI C.
 */
fix = {
    hackname  = aix_volatile;
    files     = sys/signal.h;
    select    = "typedef volatile int sig_atomic_t";
    c_fix     = format;
    c_fix_arg = "typedef int sig_atomic_t";
    test_text = "typedef volatile int sig_atomic_t;";
};


/*
 *  Fix __assert declaration in assert.h on Alpha OSF/1.
 */
fix = {
    hackname  = alpha___assert;
    files     = "assert.h";
    select    = '__assert\(char \*, char \*, int\)';
    c_fix     = format;
    c_fix_arg = "__assert(const char *, const char *, int)";
    test_text = 'extern void __assert(char *, char *, int);';
};


/*
 *  Obey __PRAGMA_EXTERN_PREFIX for Tru64 UNIX V4/5 headers.
 */
fix = {
    hackname  = alpha___extern_prefix;
    select    = "(.*)(defined\\(__DECC\\)|def[ \t]*__DECC)[ \t]*\n"
                "(#[ \t]*pragma[ \t]*extern_prefix.*)";

    mach      = "alpha*-dec-osf*";
    c_fix     = format;
    c_fix_arg = "%1 (defined(__DECC) || defined(__PRAGMA_EXTERN_PREFIX))\n%3";

    test_text = "#ifdef  __DECC\n"
		"#pragma extern_prefix \"_P\"\n"
		"#   if defined(__DECC)\n"
		"#     pragma extern_prefix \"_E\"\n"
		"# if !defined(_LIBC_POLLUTION_H_) && defined(__DECC)\n"
		"#  pragma extern_prefix \"\"";
};


/*
 *  Obey __PRAGMA_EXTERN_PREFIX for Tru64 UNIX V4/5 <standards.h>.
 */
fix = {
    hackname  = alpha___extern_prefix_standards;
    files     = standards.h;
    select    = ".*!defined\\(_LIBC_POLLUTION_H_\\) && !defined\\(__DECC\\)";

    mach      = "alpha*-dec-osf*";
    c_fix     = format;
    c_fix_arg = "%0 && !defined(__PRAGMA_EXTERN_PREFIX)";

    test_text = "#if (_ISO_C_SOURCE>=19990L) "
                "&& !defined(_LIBC_POLLUTION_H_) && !defined(__DECC)";
};


/*
 *  Obey __PRAGMA_EXTERN_PREFIX for Tru64 UNIX V5 <sys/mount.h> and
 *  <sys/stat.h>.  The tests for __DECC are special in various ways, so
 *  alpha__extern_prefix cannot be used.
 */
fix = {
    hackname  = alpha___extern_prefix_sys_stat;
    files     = sys/stat.h;
    files     = sys/mount.h;
    select    = "#[ \t]*if[ \t]*defined\\(__DECC\\)";

    mach      = "alpha*-dec-osf5*";
    c_fix     = format;
    c_fix_arg = "%0 || defined(__PRAGMA_EXTERN_PREFIX)";

    test_text = "#   if defined(__DECC)";
};


/*
 *  Fix assert macro in assert.h on Alpha OSF/1.
 *  The superfluous int cast breaks C++.
 */
fix = {
    hackname  = alpha_assert;
    files     = "assert.h";
    select    = '(#define assert\(EX\).*)\(\(int\) \(EX\)\)';
    c_fix     = format;
    c_fix_arg = "%1(EX)";
    test_text = '#define assert(EX) (((int) (EX)) ? (void)0 '
                ': __assert(#EX, __FILE__, __LINE__))';
};


/*
 *  Fix #defines under Alpha OSF/1:
 *  The following files contain '#pragma extern_prefix "_FOO"' followed by
 *  a '#define something(x,y,z) _FOOsomething(x,y,z)'.  The intent of these
 *  statements is to reduce namespace pollution.  While these macros work
 *  properly in most cases, they don't allow you to take a pointer to the
 *  "something" being modified.  To get around this limitation, change these
 *  statements to be of the form '#define something _FOOsomething'.
 *
 *  sed ain't egrep, lesson 2463:  sed can use self-referential
 *  regular expressions.  In the substitute expression below,
 *  "\\1" and "\\2" refer to subexpressions found earlier in the
 *  same match.  So, we continue to use sed.  "extern_prefix" will
 *  be a rare match anyway...
 */
fix = {
    hackname = alpha_bad_lval;

    select   = "^[ \t]*#[ \t]*pragma[ \t]+extern_prefix";
    mach      = "alpha*-dec-osf*";

    sed      =
        "s/^[ \t]*#[ \t]*define[ \t][ \t]*\\([^(]*\\)\\(([^)]*)\\)[ \t]*"
               "\\(_.*\\)\\1\\2[ \t]*$/#define \\1 \\3\\1/";

    test_text = '#pragma extern_prefix "_FOO"'"\n"
                "#define something(x,y,z) _FOOsomething(x,y,z)\n"
                "#define mumble _FOOmumble";
};


/*
 *  Fix getopt declarations in stdio.h and stdlib.h on Alpha OSF/1 and AIX.
 */
fix = {
    hackname  = alpha_getopt;
    files     = "stdio.h";
    files     = "stdlib.h";
    select    = 'getopt\(int, char \*\[\], *char \*\)';
    c_fix     = format;
    c_fix_arg = "getopt(int, char *const[], const char *)";
    test_text = 'extern int getopt(int, char *[], char *);';
};


/*
 *  Fix missing semicolon on Alpha OSF/4 in <net/if.h>
 */
fix = {
    hackname  = alpha_if_semicolon;
    files     = net/if.h;
    select    = "struct[ \t]+sockaddr[ \t]+vmif_paddr[ \t]+/\\*";
    c_fix     = format;
    c_fix_arg = "struct sockaddr vmif_paddr;\t/*";
    test_text = '     struct  sockaddr vmif_paddr     /* protocol address */';
};


/*
 * Remove erroneous parentheses in sym.h on Alpha OSF/1.
 */
fix = {
    hackname  = alpha_parens;
    files     = sym.h;
    select    = '#ifndef\(__mips64\)';
    c_fix     = format;
    c_fix_arg = "#ifndef __mips64";
    test_text = "#ifndef(__mips64) /* bogus */\nextern int foo;\n#endif";
};


/*
 *  Obey __PRAGMA_EXTERN_PREFIX for Tru64 UNIX <pthread.h>.
 */
fix = {
    hackname  = alpha_pthread;
    files     = pthread.h;
    select    = "((#[ \t]*if)([ \t]*defined[ \t]*\\(_PTHREAD_ENV_DECC\\)"
                "|def _PTHREAD_ENV_DECC)(.*))\n"
		"(#[ \t]*define _PTHREAD_USE_PTDNAM_)";

    mach      = "alpha*-dec-osf*";
    c_fix     = format;
    c_fix_arg = "%2 defined (_PTHREAD_ENV_DECC)%4 "
                "|| defined (__PRAGMA_EXTERN_PREFIX)\n%5";

    test_text = "#  if defined (_PTHREAD_ENV_DECC) "
                      "|| defined (_PTHREAD_ENV_EPCC)\n"
		"#   define _PTHREAD_USE_PTDNAM_\n"
		"#  endif\n"
		"#  ifdef _PTHREAD_ENV_DECC\n"
		"#   define _PTHREAD_USE_PTDNAM_\n"
		"#  endif";
};


/*
 *  Recognize GCC in Tru64 UNIX V5.1B <pthread.h>.
 */
fix = {
    hackname  = alpha_pthread_gcc;
    files     = pthread.h;
    select    = "#else\n# error <pthread.h>: unrecognized compiler.";

    mach      = "alpha*-dec-osf*";
    c_fix     = format;
    c_fix_arg = "#elif defined (__GNUC__)\n"
		"# define _PTHREAD_ENV_GCC\n"
    		"%0";

    test_text = "# define _PTHREAD_ENV_INTELC\n"
		"#else\n"
		"# error <pthread.h>: unrecognized compiler.\n"
		"#endif";
};


/*
 * Compaq Tru64 v5.1 defines all of its PTHREAD_*_INITIALIZER macros
 * incorrectly, specifying less fields in the initializers than are
 * defined in the corresponding structure types.  Use of these macros
 * in user code results in spurious warnings.
 */
fix = {
    hackname  = alpha_pthread_init;
    files     = pthread.h;
    select    = ' \* @\(#\).RCSfile: pthread\.h,v \$'
                ' .Revision: 1\.1\.33\.21 \$ \(DEC\)'
                ' .Date: 2000/08/15 15:30:13 \$';
    mach      = "alpha*-dec-osf*";
    sed       = "s@MVALID\\(.*\\)A}@MVALID\\1A, 0, 0, 0, 0, 0, 0 }@\n"
                "s@MVALID\\(.*\\)_}@MVALID\\1_, 0, 0, 0, 0 }@\n"
                "s@CVALID\\(.*\\)A}@CVALID\\1A, 0, 0, 0, 0 }@\n"
                "s@CVALID\\(.*\\)_}@CVALID\\1_, 0, 0 }@\n"
                "s@WVALID\\(.*\\)A}@WVALID\\1A, 0, 0, 0, 0, 0, 0, 0, 0, 0 }@\n"
                "s@WVALID\\(.*\\)_}@WVALID\\1_, 0, 0, 0, 0, 0, 0, 0 }@\n";
    test_text = <<- _EOText_
	/*
	 * @(#)_RCSfile: pthread.h,v $ _Revision: 1.1.33.21 $ (DEC) _Date: 2000/08/15 15:30:13 $
	 */
	#ifndef _PTHREAD_NOMETER_STATIC
	# define PTHREAD_MUTEX_INITIALIZER \
	    {_PTHREAD_MSTATE_CONFIG, _PTHREAD_MVALID | _PTHREAD_MVF_STA}
	# define PTHREAD_COND_INITIALIZER \
	    {_PTHREAD_CSTATE_SLOW, _PTHREAD_CVALID | _PTHREAD_CVF_STA}
	# define PTHREAD_MUTEX_INITWITHNAME_NP(_n_,_a_) \
	    {_PTHREAD_MSTATE_CONFIG, _PTHREAD_MVALID | _PTHREAD_MVF_STA, _n_, _a_}
	# define PTHREAD_COND_INITWITHNAME_NP(_n_,_a_) \
	    {_PTHREAD_CSTATE_SLOW, _PTHREAD_CVALID | _PTHREAD_CVF_STA, _n_, _a_}
	#else
	# define PTHREAD_MUTEX_INITIALIZER {0, _PTHREAD_MVALID | _PTHREAD_MVF_STA}
	# define PTHREAD_MUTEX_INITWITHNAME_NP(_n_,_a_) \
	    {0, _PTHREAD_MVALID | _PTHREAD_MVF_STA, _n_, _a_}
	# define PTHREAD_COND_INITWITHNAME_NP(_n_,_a_) \
	    {0, _PTHREAD_CVALID | _PTHREAD_CVF_STA, _n_, _a_}
	#endif

	#define PTHREAD_RWLOCK_INITIALIZER {_PTHREAD_RWVALID | _PTHREAD_RWVF_STA}
	#define PTHREAD_RWLOCK_INITWITHNAME_NP(_n_,_a_) \
	        {_PTHREAD_RWVALID | _PTHREAD_RWVF_STA, _n_, _a_}
	_EOText_;
};


/*
 *  Fix return value of sbrk in unistd.h on Alpha OSF/1 V2.0
 *  And OpenBSD.
 */
fix = {
    hackname = alpha_sbrk;
    files    = unistd.h;
    select   = "char[ \t]*\\*[\t ]*sbrk[ \t]*\\(";
    c_fix     = format;
    c_fix_arg = "void *sbrk(";
    test_text = "extern char* sbrk(ptrdiff_t increment);";
};


/*
 *  Change external names of wcstok/wcsftime via asm instead of macros on
 *  Tru64 UNIX V4.0.
 */
fix = {
    hackname = alpha_wchar;
    files    = wchar.h;

    mach     = "alpha*-dec-osf4*";
    select   = "#define wcstok wcstok_r";
    sed      = "s@#define wcstok wcstok_r@"
                "extern wchar_t *wcstok __((wchar_t *, const wchar_t *, "
                          "wchar_t **)) __asm__(\"wcstok_r\");@";
    sed      = "s@#define wcsftime __wcsftime_isoc@"
                "extern size_t   wcsftime __((wchar_t *, size_t, const wchar_t *"
                          ", const struct tm *)) __asm__(\"__wcsftime_isoc\");@";
    test_text = "#define wcstok wcstok_r\n"
		"#define wcsftime __wcsftime_isoc";
};


/*
 *  For C++, avoid any typedef or macro definition of bool,
 *  and use the built in type instead.
 *  HP/UX 10.20 also has it in curses_colr/curses.h.
 */
fix = {
    hackname  = avoid_bool_define;
    files     = curses.h;
    files     = curses_colr/curses.h;
    files     = term.h;
    files     = tinfo.h;

    select    = "#[ \t]*define[ \t]+bool[ \t]";
    bypass    = "__cplusplus";

    c_fix     = format;
    c_fix_arg = "#ifndef __cplusplus\n%0\n#endif";
    c_fix_arg = "^[ \t]*#[ \t]*define[ \t]+bool[ \t].*";

    test_text = "# define bool\t char \n";
};


fix = {
    hackname = avoid_bool_type;
    files    = curses.h;
    files    = curses_colr/curses.h;
    files    = term.h;
    files    = tinfo.h;

    select    = "^[ \t]*typedef[ \t].*[ \t]bool[ \t]*;";
    bypass    = "__cplusplus";

    c_fix     = format;
    c_fix_arg = "#ifndef __cplusplus\n%0\n#endif";

    test_text = "typedef unsigned int\tbool \t; /* bool\n type */";
};


/*
 *  For C++, avoid any typedef definition of wchar_t,
 *  and use the built in type instead.
 *  Don't do this for headers that are smart enough to do the right
 *  thing (recent [n]curses.h and Xlib.h).
 *  Don't do it for <linux/nls.h> which is never used from C++ anyway,
 *  and will be broken by the edit.
 */

fix = {
    hackname = avoid_wchar_t_type;

    select    = "^[ \t]*typedef[ \t].*[ \t]wchar_t[ \t]*;";
    bypass    = "__cplusplus";
    bypass    = "_LINUX_NLS_H";
    bypass    = "XFree86: xc/lib/X11/Xlib\\.h";

    c_fix     = format;
    c_fix_arg = "#ifndef __cplusplus\n%0\n#endif";

    test_text = "typedef unsigned short\twchar_t \t; /* wchar_t\n type */";
};


/*
 *  Fix `typedef struct term;' on hppa1.1-hp-hpux9.
 */
fix = {
    hackname  = bad_struct_term;
    files     = curses.h;
    select    = "^[ \t]*typedef[ \t]+struct[ \t]+term[ \t]*;";
    c_fix     = format;
    c_fix_arg = "struct term;";

    test_text = 'typedef struct term;';
};


/*
 *  Fix one other error in this file:
 *  a mismatched quote not inside a C comment.
 */
fix = {
    hackname  = badquote;
    files     = sundev/vuid_event.h;
    select    = "doesn't";
    c_fix     = format;
    c_fix_arg = "does not";

    test_text = "/* doesn't have matched single quotes */";
};


/*
 *  check for broken assert.h that needs stdio.h
 */
fix = {
    hackname  = broken_assert_stdio;
    files     = assert.h;
    select    = stderr;
    bypass    = "include.*stdio\\.h";
    c_fix     = wrap;
    c_fix_arg = "#include <stdio.h>\n";
    test_text = "extern FILE* stderr;";
};


/*
 *  check for broken assert.h that needs stdlib.h
 */
fix = {
    hackname  = broken_assert_stdlib;
    files     = assert.h;
    select    = 'exit *\(|abort *\(';
    bypass    = "include.*stdlib\\.h";
    c_fix     = wrap;
    c_fix_arg = "#ifdef __cplusplus\n"
                "#include <stdlib.h>\n"
                "#endif\n";
    test_text = "extern void exit ( int );";
};


/*
 *  Remove `extern double cabs' declarations from math.h.
 *  This conflicts with C99.  Discovered on AIX.
 *  IRIX 5 and IRIX 6 before 6.5.18 (where C99 support was introduced)
 *  declares cabs() to take a struct __cabs_s argument.
 *  SunOS4 has its cabs() declaration followed by a comment which
 *  terminates on the following line.
 *  Darwin hides its broken cabs in architecture-specific subdirs.
 */
fix = {
    hackname = broken_cabs;
    files    = math.h, "architecture/*/math.h";
    select   = "^extern[ \t]+double[ \t]+cabs";

    sed       = "s/^extern[ \t]*double[ \t]*cabs[ \t]*\([^\\\)]*\);//";
    sed       = "s/^extern[ \t]*long[ \t]*double[ \t]*cabsl[ \t]*\([^\\\)]*\);//";

    test_text = "#ifdef __STDC__\n"
                "extern     double   cabs(struct dbl_hypot);\n"
                "#else\n"
                "extern     double   cabs();\n"
                "#endif\n"
                "extern double cabs ( _Complex z );\n"
                "extern double cabs(); /* This is a comment\n"
                "                         and it ends here. */\n"
                "extern double	cabs(struct __cabs_s);\n"
                "extern long double cabsl( struct __cabsl_s );";
};


/*
 * Fixup Darwin's broken check for __builtin_nanf.
 */    
fix = {
    hackname  = broken_nan;
    /*
     *  It is tempting to omit the first "files" entry.  Do not.
     *  The testing machinery will take the first "files" entry as the name
     *  of a test file to play with.  It would be a nuisance to have a directory
     *  with the name "*".
     */
    files     = "architecture/ppc/math.h";
    files     = "architecture/*/math.h";
    select    = "#if defined(__APPLE_CC__) && (__APPLE_CC__ >= 1345)";
    bypass    = "powl";
    c_fix     = format; 
    c_fix_arg = "#if 1";
    test_text = "#if defined(__APPLE_CC__) && (__APPLE_CC__ >= 1345)";
};


/*
 *  Various systems derived from BSD4.4 contain a macro definition
 *  for vfscanf that interacts badly with requirements of builtin-attrs.def.
 *  Known to be fixed in FreeBSD 5 system headers.
 */
fix = {
    hackname  = bsd_stdio_attrs_conflict;
    mach      = "*-*-*bsd*";
    mach      = "*-*-*darwin*";
    files     = stdio.h;
    select    = "^#define[ \t]*vfscanf[ \t]*__svfscanf[ \t]*$";
    c_fix     = format;
    c_fix_arg = '#define _BSD_STRING(_BSD_X) _BSD_STRINGX(_BSD_X)' "\n"
		'#define _BSD_STRINGX(_BSD_X) #_BSD_X' "\n"
		'int vfscanf(FILE *, const char *, __builtin_va_list) '
		'__asm__ (_BSD_STRING(__USER_LABEL_PREFIX__) "__svfscanf");';
    test_text = '#define  vfscanf	__svfscanf';
};


/*
 *  Fix various macros used to define ioctl numbers.
 *  The traditional syntax was:
 *
 *    #define _CTRL(n, x) (('n'<<8)+x)
 *    #define TCTRLCFOO _CTRL(T, 1)
 *
 *  but this does not work with the C standard, which disallows macro
 *  expansion inside strings.  We have to rewrite it thus:
 *
 *    #define _CTRL(n, x) ((n<<8)+x)
 *    #define TCTRLCFOO  _CTRL('T', 1)
 *
 *  The select expressions match too much, but the c_fix code is cautious.
 *
 *  CTRL might be: CTRL _CTRL ISCTRL BSD43_CTRL ...
 */
fix = {
    hackname  = ctrl_quotes_def;
    select    = "define[ \t]+[A-Z0-9_]+CTRL\\([a-zA-Z][,)]";
    c_fix     = char_macro_def;
    c_fix_arg = "CTRL";

    /*
     *  This is two tests in order to ensure that the "CTRL(c)" can
     *  be selected in isolation from the multi-arg format
     */
    test_text = "#define BSD43_CTRL(n, x) (('n'<<8)+x)\n";
    test_text = "#define _CTRL(c) ('c'&037)";
};

fix = {
    hackname  = ctrl_quotes_use;
    select    = "define[ \t]+[A-Z0-9_]+[ \t]+[A-Z0-9_]+CTRL[ \t]*\\( *[^,']";
    c_fix     = char_macro_use;
    c_fix_arg = "CTRL";
    test_text = "#define TCTRLFOO BSD43_CTRL(T, 1)";
};


/*
 *  sys/mman.h on HP/UX is not C++ ready,
 *  even though NO_IMPLICIT_EXTERN_C is defined on HP/UX.
 *
 *  rpc/types.h on OSF1/2.0 is not C++ ready,
 *  even though NO_IMPLICIT_EXTERN_C is defined for the alpha.
 *
 *  The problem is the declaration of malloc.
 */
fix = {
    hackname = cxx_unready;
    files    = sys/mman.h;
    files    = rpc/types.h;
    select   = '[^#]+malloc.*;';  /* Catch any form of declaration
				     not within a macro.  */
    bypass   = '"C"|__BEGIN_DECLS';

    c_fix     = wrap;
    c_fix_arg = "#ifdef __cplusplus\n"
                "extern \"C\" {\n"
                "#endif\n";
    c_fix_arg = "#ifdef __cplusplus\n"
                "}\n"
                "#endif\n";
    test_text = "extern void* malloc( size_t );";
};


/*
 *  On darwin8 and earlier, mach-o/swap.h isn't properly guarded
 *  by 'extern "C"'.  On darwin7 some mach/ headers aren't properly guarded.
 */
fix = {
  hackname  = darwin_externc;
  mach      = "*-*-darwin*";
  files     = mach-o/swap.h;
  files     = mach/mach_time.h;
  files     = mach/mach_traps.h;
  files     = mach/message.h;
  files     = mach/mig.h;
  files     = mach/semaphore.h;
  bypass    = "extern \"C\"";
  bypass    = "__BEGIN_DECLS";
  c_fix     = wrap;
  c_fix_arg = "#ifdef __cplusplus\n"
              "extern \"C\" {\n"
              "#endif\n";
  c_fix_arg = "#ifdef __cplusplus\n"
              "}\n"
              "#endif\n";
  test_text = "extern void swap_fat_header();\n";
};


/*
 * AvailabilityMacros.h on Darwin breaks with GCC 4.0, because of
 * bad __GNUC__ tests.
 */

fix = {
  hackname  = darwin_gcc4_breakage;
  mach      = "*-*-darwin*";
  files     = AvailabilityMacros.h;
  select    = "\\(__GNUC__ >= 3\\) && \\(__GNUC_MINOR__ >= 1\\)";
  c_fix     = format;
  c_fix_arg = "((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))";
  test_text = "#if defined(__GNUC__) && (__GNUC__ >= 3) && "
  	      "(__GNUC_MINOR__ >= 1)\n";
};


/*
 *  __private_extern__ doesn't exist in FSF GCC.  Even if it did,
 *  why would you ever put it in a system header file?
 */
fix = {
  hackname  = darwin_private_extern;
  mach      = "*-*-darwin*";
  files     = mach-o/dyld.h;
  select    = "__private_extern__ [a-z_]+ _dyld_";
  c_fix     = format;
  c_fix_arg = "extern";
  c_fix_arg = "__private_extern__";
  test_text = "__private_extern__ int _dyld_func_lookup(\n"
	      "const char *dyld_func_name,\n"
	      "unsigned long *address);\n";
};


/*
 *  Fix <c_asm.h> on Digital UNIX V4.0:
 *  It contains a prototype for a DEC C internal asm() function,
 *  clashing with gcc's asm keyword.  So protect this with __DECC.
 */
fix = {
    hackname = dec_intern_asm;
    files    = c_asm.h;
    sed = "/^[ \t]*float[ \t]*fasm/i\\\n#ifdef __DECC\n";
    sed = "/^[ \t]*#[ \t]*pragma[ \t]*intrinsic([ \t]*dasm/a\\\n"
          "#endif\n";
    test_text =
    "float fasm {\n"
    "    ... asm stuff ...\n"
    "};\n#pragma intrinsic( dasm )\n/* END ASM TEST*/";
};


/*
 * Fix typo in <wchar.h> on DJGPP 2.03.
 */
fix = {
    hackname  = djgpp_wchar_h;
    file      = wchar.h;
    select    = "__DJ_wint_t";
    bypass    = "sys/djtypes.h";
    c_fix     = format;
    c_fix_arg = "%0\n#include <sys/djtypes.h>";
    c_fix_arg = "#include <stddef.h>";
    test_text = "#include <stddef.h>\n"
                "extern __DJ_wint_t x;\n";
};


/*
 * Fix these Sun OS files to avoid an invalid identifier in an #ifdef.
 */
fix = {
    hackname  = ecd_cursor;
    files     = "sunwindow/win_lock.h";
    files     = "sunwindow/win_cursor.h";
    select    = 'ecd\.cursor';
    c_fix     = format;
    c_fix_arg = 'ecd_cursor';

    test_text = "#ifdef ecd.cursor\n#error bogus\n#endif /* ecd+cursor */";
};


/*
 *  math.h on SunOS 4 puts the declaration of matherr before the definition
 *  of struct exception, so the prototype (added by fixproto) causes havoc.
 *  This must appear before the math_exception fix.
 */
fix = {
    hackname  = exception_structure;
    files     = math.h;

    /*  If matherr has a prototype already, the header needs no fix.  */
    bypass    = 'matherr.*(struct exception|__MATH_EXCEPTION|[ \t]*__FP_EXCEPTION[ \t]*\*[ \t]*)';
    select    = matherr;

    c_fix     = wrap;
    c_fix_arg = "struct exception;\n";

    test_text = "extern int matherr();";
};


/*
 *  Between 8/24/1998 and 2/17/2001, FreeBSD system headers presume
 *  neither the existence of GCC 3 nor its exact feature set yet break
 *  (by design?) when __GNUC__ is set beyond 2.
 */
fix = {
    hackname  = freebsd_gcc3_breakage;
    mach      = "*-*-freebsd*";
    files     = sys/cdefs.h;
    select    = '^#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7$';
    bypass    = '__GNUC__[ \t]*([>=]=[ \t]*[3-9]|>[ \t]*2)';
    c_fix     = format;
    c_fix_arg = '%0 || __GNUC__ >= 3';
    test_text = '#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7';
};


/*
 *  Some releases of FreeBSD 4 and FreeBSD 5.0 and 5.1 system headers presume
 *  neither the existence of GCC 4 nor its exact feature set yet break
 *  (by design?) when __GNUC__ is set beyond 3.
 */
fix = {
    hackname  = freebsd_gcc4_breakage;
    mach      = "*-*-freebsd*"; 
    files     = sys/cdefs.h;
    select    = '^#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7 \|\| __GNUC__ == 3$';
    c_fix     = format;
    c_fix_arg = '#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7 || __GNUC__ >= 3';
    test_text = '#if __GNUC__ == 2 && __GNUC_MINOR__ >= 7 || __GNUC__ == 3';
};


/*
 *  Some versions of glibc don't expect the C99 inline semantics.
 */
fix = {
    hackname  = glibc_c99_inline_1;
    files     = features.h, '*/features.h';
    select    = "^ *&& !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__$";
    c_fix     = format;
    c_fix_arg = "%0 && (defined __extern_inline || defined __GNUC_GNU_INLINE__)";
    test_text = <<-EOT
	#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ \
	    && !defined __OPTIMIZE_SIZE__ && !defined __NO_INLINE__
	# define __USE_EXTERN_INLINES	1
	#endif
	EOT;
};


/*
 *  Similar, but a version that didn't have __NO_INLINE__
 */
fix = {
    hackname  = glibc_c99_inline_1a;
    files     = features.h, '*/features.h';
    select    = "(\\) && defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__)\n"
		"(#[ \t]*define[ \t]*__USE_EXTERN_INLINES[ \t]*1)";
    c_fix     = format;
    c_fix_arg = "%1 && (defined __extern_inline || defined __GNUC_GNU_INLINE__)\n%2";
    test_text = <<-EOT
	#if __GNUC_PREREQ (2, 7) && defined __OPTIMIZE__ && !defined __OPTIMIZE_SIZE__
	# define __USE_EXTERN_INLINES	1
	#endif
	EOT;
};


/*
 * The glibc_c99_inline_1 fix should have fixed everything.  Unfortunately
 * there are many glibc headers which do not respect __USE_EXTERN_INLINES.
 * The remaining glibc_c99_inline_* fixes deal with some of those headers.
 */
fix = {
    hackname  = glibc_c99_inline_2;
    files     = sys/stat.h, '*/sys/stat.h';
    select    = "extern __inline__ int";
    sed     = "s/extern int \\(stat\\|lstat\\|fstat\\|mknod\\)/"
              "#ifdef __GNUC_GNU_INLINE__\\\nextern\\\n#endif\\\n"
              "__inline__ int \\1/";
    sed     = "s/extern int __REDIRECT\\(_NTH\\|\\) (\\(stat\\|lstat\\|fstat\\)/"
              "#ifdef __GNUC_GNU_INLINE__\\\nextern\\\n#endif\\\n"
              "__inline__ int __REDIRECT\\1 (\\2/";
    sed     = "s/^extern __inline__ int/"
              "#ifdef __GNUC_GNU_INLINE__\\\nextern\\\n#endif\\\n"
              "__inline__ int/";
    test_text = <<-EOT
	extern int fstat64 (int __fd, struct stat64 *__buf) __THROW __nonnull ((2));
	extern __inline__ int
	__NTH (fstat64 (int __fd, struct stat64 *__statbuf))
	{}
	EOT;
};


fix = {
    hackname  = glibc_c99_inline_3;
    files     = bits/string2.h, '*/bits/string2.h';
    select    = "extern __inline";
    bypass    = "__extern_inline|__GNU_STDC_INLINE__";
    c_fix     = format;
    c_fix_arg = "# if defined(__cplusplus) || defined(__GNUC_STDC_INLINE__)";
    c_fix_arg = "^# ifdef __cplusplus$";
    test_text = <<-EOT
	# ifdef __cplusplus
	#  define __STRING_INLINE inline
	# else
	#  define __STRING_INLINE extern __inline
	# endif
	EOT;
};


fix = {
    hackname  = glibc_c99_inline_4;
    files     = sys/sysmacros.h, '*/sys/sysmacros.h', wchar.h, '*/wchar.h';
    bypass    = "__extern_inline|__gnu_inline__";
    select    = "(^| )extern __inline";
    c_fix     = format;
    c_fix_arg = "%0 __attribute__ ((__gnu_inline__))";
    test_text = <<-EOT
	__extension__ extern __inline unsigned int
	extern __inline unsigned int
	EOT;
};


/*  glibc-2.3.5 defines pthread mutex initializers incorrectly,
 *  so we replace them with versions that correspond to the
 *  definition.
 */
fix = {
    hackname = glibc_mutex_init;
    files    = pthread.h;
    select   = '\{ *\{ *0, *\} *\}';
    sed      = "/define[ \t]\\+PTHREAD_MUTEX_INITIALIZER[ \t]*\\\\/{\n"
               "N\ns/{ { 0, } }/{ { 0, 0, 0, 0, 0, 0 } }/\n}";
    sed      = "s/{ \\(0, 0, 0, 0, PTHREAD_MUTEX_"
               "\\(RECURSIVE\\|ERRORCHECK\\|ADAPTIVE\\)_NP\\) }/{ \\1, 0 }/";
    sed      = "s/{ \\(0, 0, 0, PTHREAD_MUTEX_"
               "\\(RECURSIVE\\|ERRORCHECK\\|ADAPTIVE\\)_NP\\) }/{ \\1, 0, 0 }/";
    sed      = "/define[ \t]\\+PTHREAD_RWLOCK_INITIALIZER[ \t]*\\\\/"
               "N;s/^[ \t]*#[ \t]*"
               "\\(define[ \t]\\+PTHREAD_RWLOCK_INITIALIZER[ \t]*\\\\\\)\\n"
               "[ \t]*{ { 0, } }/# if __WORDSIZE == 64\\n"
               "#  \\1\\n"
               "  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\\n"
               "# else\\n"
               "#  \\1\\n"
               "  { { 0, 0, 0, 0, 0, 0, 0, 0 } }\\n"
               "# endif/";
    sed      = "s/{ \\(0, 0, 0, 0, 0, 0, "
               "PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP\\) }/{ \\1, 0 }/";
    sed      = "/define[ \t]\\+PTHREAD_COND_INITIALIZER/"
               "s/{ { 0, } }/{ { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }/";

    test_text = <<- _EOText_
	#define PTHREAD_MUTEX_INITIALIZER \\
	  { { 0, } }
	#ifdef __USE_GNU
	# if __WORDSIZE == 64
	#  define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP } }
	#  define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP } }
	#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP } }
	# else
	#  define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, PTHREAD_MUTEX_RECURSIVE_NP } }
	#  define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP } }
	#  define PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP \\
	  { { 0, 0, 0, PTHREAD_MUTEX_ADAPTIVE_NP } }
	# endif
	#endif
	# define PTHREAD_RWLOCK_INITIALIZER \\
	  { { 0, } }
	# ifdef __USE_GNU
	#  if __WORDSIZE == 64
	#   define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \\
	  { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,			      \\
	      PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
	#  else
	#   define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \\
	  { { 0, 0, 0, 0, 0, 0, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
	#  endif
	# endif
	#define PTHREAD_COND_INITIALIZER { { 0, } }
	_EOText_;
};


/*
 * Fix these files to use the types we think they should for
 * ptrdiff_t, size_t, and wchar_t.
 *
 * This defines the types in terms of macros predefined by our 'cpp'.
 * This is supposedly necessary for glibc's handling of these types.
 * It's probably not necessary for anyone else, but it doesn't hurt.
 */
fix = {
    hackname  = gnu_types;
    files  = "sys/types.h";
    files  = "stdlib.h";
    files  = "sys/stdtypes.h";
    files  = "stddef.h";
    files  = "memory.h";
    files  = "unistd.h";
    bypass    = '_GCC_(PTRDIFF|SIZE|WCHAR)_T';
    select    = "^[ \t]*typedef[ \t]+.*[ \t](ptrdiff|size|wchar)_t;";
    c_fix     = gnu_type;
    /* The Solaris 10 headers already define these types correctly.  */
    mach   = '*-*-solaris2.1[0-9]*';
    not_machine = true;

    test_text = "typedef long int ptrdiff_t; /* long int */\n"
                "typedef uint_t size_t; /* uint_t */\n"
                "typedef ushort_t wchar_t; /* ushort_t */";
};


/*
 *  Fix HP & Sony's use of "../machine/xxx.h"
 *  to refer to:  <machine/xxx.h>
 */
fix = {
    hackname  = hp_inline;
    files     = sys/spinlock.h;
    files     = machine/machparam.h;
    select    = "[ \t]*#[ \t]*include[ \t]+"  '"\.\./machine/';

    c_fix     = format;
    c_fix_arg = "%1<machine/%2.h>";

    c_fix_arg = "([ \t]*#[ \t]*include[ \t]+)"  '"\.\./machine/'
                '([a-z]+)\.h"';

    test_text = ' # include "../machine/mumble.h"';
};


/*
 *  Check for (...) in C++ code in HP/UX sys/file.h.
 */
fix = {
    hackname  = hp_sysfile;
    files     = sys/file.h;
    select    = "HPUX_SOURCE";

    c_fix     = format;
    c_fix_arg = "(struct file *, ...)";
    c_fix_arg = '\(\.\.\.\)';

    test_text = "extern void foo(...); /* HPUX_SOURCE - bad varargs */";
};


/*
 *  Un-Hide a series of five FP defines from post-1999 compliance GCC:
 *  FP_NORMAL, FP_ZERO, FP_INFINITE, FP_SUBNORMAL and FP_NAN
 */
fix = {
     hackname  = hppa_hpux_fp_macros;
     mach      = "hppa*-hp-hpux11*";
     files     = math.h;
     select    = "#[ \t]*define[ \t]*FP_NORMAL.*\n"
		 "#[ \t]*define[ \t]*FP_ZERO.*\n"
		 "#[ \t]*define[ \t]*FP_INFINITE.*\n"
		 "#[ \t]*define[ \t]*FP_SUBNORMAL.*\n"
		 "#[ \t]*define[ \t]*FP_NAN.*\n";
     c_fix     = format;
     c_fix_arg = <<- _EOFix_
	#endif /* _INCLUDE_HPUX_SOURCE */

	#if defined(_INCLUDE_HPUX_SOURCE) || \
	   (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))
	%0#endif

	#ifdef _INCLUDE_HPUX_SOURCE

	_EOFix_;

     test_text =
            "#  define FP_NORMAL     0\n"
            "#  define FP_ZERO       1\n"
            "#  define FP_INFINITE   2\n"
            "#  define FP_SUBNORMAL  3\n"
            "#  define FP_NAN        4\n";
};


/*
 * Delete C++ double pow (double, int) inline function from HP-UX 10 & 11
 * math.h to prevent clash with define in c_std/bits/std_cmath.h.
 */
fix = {
    hackname  = hpux10_cpp_pow_inline;
    files     = fixinc-test-limits.h, math.h;
    select    = <<-	END_POW_INLINE
	^# +ifdef +__cplusplus
	 +\}
	 +inline +double +pow\(double +__d,int +__expon\) +\{
	[ 	]+return +pow\(__d,\(double\)__expon\);
	 +\}
	 +extern +"C" +\{
	#else
	# +endif
	END_POW_INLINE;
 
    c_fix     = format;
    c_fix_arg = "";

    test_text =
	"#    ifdef __cplusplus\n"
	"     }\n"
	"     inline double pow(double __d,int __expon) {\n"
	"\t return pow(__d,(double)__expon);\n"
	"     }\n"
	'     extern "C"' " {\n"
	"#else\n"
	"#    endif";
};

fix = {
     hackname  = hpux11_cpp_pow_inline;
     files     = math.h;
     select    = " +inline double pow\\(double d,int expon\\) \\{\n"
                 " +return pow\\(d, \\(double\\)expon\\);\n"
                 " +\\}\n";
     c_fix     = format;
     c_fix_arg = "";

     test_text =
            "   inline double pow(double d,int expon) {\n"
            "     return pow(d, (double)expon);\n"
            "   }\n";
};


/*
 *  Fix hpux 10.X missing ctype declarations 1
 */
fix = {
    hackname = hpux10_ctype_declarations1;
    files    = ctype.h;
    select   = "^#[ \t]*define _toupper\\(__c\\)[ \t]*__toupper\\(__c\\)";
    bypass   = "^[ \t]*extern[ \t]*int[ \t]*__tolower[ \t]*\\(";
    c_fix     = format;
    c_fix_arg = "#ifdef _PROTOTYPES\n"
		"extern int __tolower(int);\n"
		"extern int __toupper(int);\n"
		"#else /* NOT _PROTOTYPES */\n"
		"extern int __tolower();\n"
		"extern int __toupper();\n"
		"#endif /* _PROTOTYPES */\n\n"
		"%0\n";

    test_text = "#  define _toupper(__c)         __toupper(__c)\n";
};


/*
 *  Fix hpux 10.X missing ctype declarations 2
 */
fix = {
    hackname = hpux10_ctype_declarations2;
    files    = ctype.h;
    select   = "^#  if defined\\(_SB_CTYPE_MACROS\\) && \\!defined\\(__lint\\)";
    bypass   = "^[ \t]*extern[ \t]*int[ \t]*_isalnum[ \t]*\\(";
    c_fix     = format;
    c_fix_arg = "%0\n\n"
		"#ifdef _PROTOTYPES\n"
		"     extern int _isalnum(int);\n"
		"     extern int _isalpha(int);\n"
		"     extern int _iscntrl(int);\n"
		"     extern int _isdigit(int);\n"
		"     extern int _isgraph(int);\n"
		"     extern int _islower(int);\n"
		"     extern int _isprint(int);\n"
		"     extern int _ispunct(int);\n"
		"     extern int _isspace(int);\n"
		"     extern int _isupper(int);\n"
		"     extern int _isxdigit(int);\n"
		"#  else /* not _PROTOTYPES */\n"
		"     extern int _isalnum();\n"
		"     extern int _isalpha();\n"
		"     extern int _iscntrl();\n"
		"     extern int _isdigit();\n"
		"     extern int _isgraph();\n"
		"     extern int _islower();\n"
		"     extern int _isprint();\n"
		"     extern int _ispunct();\n"
		"     extern int _isspace();\n"
		"     extern int _isupper();\n"
		"     extern int _isxdigit();\n"
		"#endif /* _PROTOTYPES */\n";

    test_text = "#  if defined(_SB_CTYPE_MACROS) && !defined(__lint)\n"
		"     extern unsigned int *__SB_masks;\n";
};


/*
 *  Fix hpux 10.X missing stdio declarations
 */
fix = {
    hackname = hpux10_stdio_declarations;
    files    = stdio.h;
    select   = "^#[ \t]*define _iob[ \t]*__iob";
    bypass   = "^[ \t]*extern[ \t]*int[ \t]*vsnprintf[ \t]*\\(";
    c_fix     = format;
    c_fix_arg = "%0\n\n"
	"#  if defined(__STDC__) || defined(__cplusplus)\n"
	"     extern int snprintf(char *, size_t, const char *, ...);\n"
	"     extern int vsnprintf(char *, size_t, const char *, __va_list);\n"
	"#  else /* not __STDC__) || __cplusplus */\n"
	"     extern int snprintf();\n"
	"     extern int vsnprintf();\n"
	"#  endif /* __STDC__) || __cplusplus */\n";

    test_text = "#  define _iob __iob\n";
};


/*
 *  Make sure hpux defines abs in header.
 */
fix = {
    hackname  = hpux11_abs;
    mach      = "ia64-hp-hpux11*";
    files     = stdlib.h;
    select    = "ifndef _MATH_INCLUDED";
    c_fix     = format;
    c_fix_arg = "if !defined(_MATH_INCLUDED) || defined(__GNUG__)";
    test_text = "#ifndef _MATH_INCLUDED";
};


/*
 *  Keep HP-UX 11 from stomping on C++ math namespace
 *  with defines for fabsf.
 */
fix = {
    hackname  = hpux11_fabsf;
    files     = math.h;
    select    = "^[ \t]*#[ \t]*define[ \t]+fabsf\\(.*";
    bypass    = "__cplusplus";

    c_fix     = format;
    c_fix_arg = "#ifndef __cplusplus\n%0\n#endif";

    test_text =
    "#ifdef _PA_RISC\n"
    "#  define fabsf(x) ((float)fabs((double)(float)(x)))\n"
    "#endif";
};


/*
 *  Fix C99 constant in __POINTER_SET define.
 */
fix = {
    hackname  = hpux11_pthread_const;
    mach      = "*-hp-hpux11.[0-3]*";
    files     = sys/pthread.h;
    select    = "^#define[ \t]*__POINTER_SET[ \t]*\\(\\(void \\*\\) 1LL\\)";

    c_fix     = format;
    c_fix_arg = "#define __POINTER_SET\t\t((void *) 1L)";
    test_text = "#define __POINTER_SET\t\t((void *) 1LL)";
};


/*
 * Prevent HP-UX 11 from defining __size_t and preventing size_t from
 * being defined by having it define _hpux_size_t instead.
 */
fix = {
    hackname  = hpux11_size_t;
    mach      = "*-hp-hpux11*";
    select    = "__size_t";

    c_fix     = format;
    c_fix_arg = "_hpux_size_t";

    test_text =
    "#define __size_t size_t\n"
    "       extern int getpwuid_r( char *, __size_t, struct passwd **);\n";
};


/*
 *  Fix hpux 11.00 broken snprintf declaration
 *  (third argument is char *, needs to be const char * to prevent
 *  spurious warnings with -Wwrite-strings or in C++).
 */
fix = {
    hackname = hpux11_snprintf;
    files    = stdio.h;
    select   = '(extern int snprintf *\(char *\*, *(|__|_hpux_)size_t,)'
                                    ' *(char *\*, *\.\.\.\);)';
    c_fix     = format;
    c_fix_arg = '%1 const %3';

    test_text = "extern int snprintf(char *, size_t, char *, ...);\n"
                "extern int snprintf(char *, __size_t, char *, ...);\n"
                "extern int snprintf(char *, _hpux_size_t, char *, ...);";
};


/*
 * In inttypes.h on HPUX 11, the use of __CONCAT__ in the definition
 * of UINT32_C has undefined behavior according to ISO/ANSI:
 * the arguments to __CONCAT__ are not macro expanded before the
 * concatination happens so the trailing ')' in the first argument
 * is concatinated with the 'l' in the second argument creating an
 * invalid pp token.  The behavior of invalid pp tokens is undefined.
 * GCC does not handle these invalid tokens the way the HP compiler does.
 * This problem will potentially occur anytime macros are used in the
 * arguments to __CONCAT__.  A general solution to this problem would be to
 * insert another layer of macro between __CONCAT__ and its use
 * in UINT32_C.  An example of this solution can be found in the C standard.
 * A more specific solution, the one used here, is to change the UINT32_C
 * macro to not used macros in the arguments to __CONCAT__.
 */
fix = {
    hackname = hpux11_uint32_c;
    files    = inttypes.h;
    select   = "^#define UINT32_C\\(__c\\)[ \t]*"
                         "__CONCAT__\\(__CONCAT_U__\\(__c\\),l\\)";
    c_fix    = format;
    c_fix_arg = '#define UINT32_C(__c) __CONCAT__(__c,ul)';
    test_text =
    "#define CONCAT_U__(__c)\t__CONCAT__(__c,u)\n"
    "#define UINT32_C(__c)\t__CONCAT__(__CONCAT_U__(__c),l)";
};


/*
 *  Fix hpux 11.00 broken vsnprintf declaration
 */
fix = {
    hackname = hpux11_vsnprintf;
    files    = stdio.h;
    select   = '(extern int vsnprintf\(char \*, _[hpux]*_size_t, '
                                     'const char \*,) __va__list\);';
    c_fix     = format;
    c_fix_arg = "%1 __va_list);";

    test_text = 'extern int vsnprintf(char *, _hpux_size_t, const char *,'
                                     ' __va__list);';
};


/*
 *  get rid of bogus inline definitions in HP-UX 8.0
 */
fix = {
    hackname = hpux8_bogus_inlines;
    files    = math.h;
    select   = inline;
    bypass   = "__GNUG__";
    sed = "s@inline int abs(int [a-z][a-z]*) {.*}"
           "@extern \"C\" int abs(int);@";
    sed = "s@inline double abs(double [a-z][a-z]*) {.*}@@";
    sed = "s@inline int sqr(int [a-z][a-z]*) {.*}@@";
    sed = "s@inline double sqr(double [a-z][a-z]*) {.*}@@";
    test_text = "inline int abs(int v) { return (v>=0)?v:-v; }\n"
                "inline double sqr(double v) { return v**0.5; }";
};


/*
 *  Fix hpux broken ctype macros
 */
fix = {
    hackname = hpux_ctype_macros;
    files    = ctype.h;
    select   = '((: |\()__SB_masks \? )'
	       '(__SB_masks\[__(alnum|c)\] & _IS)';
    c_fix     = format;
    c_fix_arg = "%1(int)%3";

    test_text = ": __SB_masks ? __SB_masks[__alnum] & _ISCNTRL\n"
		"# define isalpha(__c) (__SB_masks ? __SB_masks[__c] & _IS\n";
};


/*
 *  Fix hpux broken #ifndef _XOPEN_SOURCE_EXTENDED conditional on htonl etc.
 */
fix = {
    hackname = hpux_htonl;
    files    = netinet/in.h;
    select   = "#ifndef _XOPEN_SOURCE_EXTENDED\n"
               "(/\\*\n"
               " \\* Macros for number representation conversion\\.\n"
               " \\*/\n"
               "#ifndef ntohl)";
    c_fix     = format;
    c_fix_arg = "#if 1\n%1";

    test_text = "#ifndef _XOPEN_SOURCE_EXTENDED\n"
                "/*\n"
                " * Macros for number representation conversion.\n"
                " */\n"
                "#ifndef ntohl\n"
                "#define ntohl(x)        (x)\n"
                "#define ntohs(x)        (x)\n"
                "#define htonl(x)        (x)\n"
                "#define htons(x)        (x)\n"
                "#endif\n"
                "#endif  /* ! _XOPEN_SOURCE_EXTENDED */";
};


/*
 * HP-UX long_double
 */
fix = {
    hackname  = hpux_long_double;
    files     = stdlib.h;
    select    = "extern[ \t]long_double[ \t]strtold";
    bypass    = "long_double_t";
    sed       = "/^#[ \t]*ifndef _LONG_DOUBLE/,/\\/\\* _LONG_DOUBLE \\*\\//D";
    sed       = "s/long_double/long double/g";

    test_text = "#  ifndef _LONG_DOUBLE\n"
		"#    define _LONG_DOUBLE\n"
		"     typedef struct {\n"
		"       unsigned int word1, word2, word3, word4;\n"
		"     } long_double;\n"
		"#  endif /* _LONG_DOUBLE */\n"
		"extern long_double strtold(const char *, char **);\n";
};


/*
 *  Fix hpux10.20 <sys/time.h> to avoid invalid forward decl
 */
fix = {
    hackname = hpux_systime;
    files    = sys/time.h;
    select   = "^extern struct sigevent;";

    c_fix     = format;
    c_fix_arg = "struct sigevent;";

    test_text = 'extern struct sigevent;';
};


/*
 *  Wrap spu_info in ifdef _KERNEL.  GCC cannot handle an array of unknown
 *  type and mpinfou is only defined when _KERNEL is set.
 */
fix = {
    hackname = hpux_spu_info;
    mach     = "*-hp-hpux*";
    /*
     *  It is tempting to omit the first "files" entry.  Do not.
     *  The testing machinery will take the first "files" entry as the name
     *  of a test file to play with.  It would be a nuisance to have a directory
     *  with the name "*".
     */
    files    = "ia64/sys/getppdp.h";
    files    = "*/sys/getppdp.h";
    select   = "^.*extern.*spu_info.*";

    c_fix     = format;
    c_fix_arg = "#ifdef _KERNEL\n%0\n#endif";

    test_text = "extern union mpinfou spu_info[];";
};

fix = {
    hackname  = hpux11_extern_sendfile;
    mach      = "*-hp-hpux11.[12]*";
    files     = sys/socket.h;
    select    = "^[ \t]*extern sbsize_t sendfile.*\n.*, int\\)\\);\n";
    c_fix     = format;
    c_fix_arg = "#ifndef _APP32_64BIT_OFF_T\n%0#endif\n";
    test_text = "   extern sbsize_t sendfile __((int, int, off_t, bsize_t,\n                               const struct iovec *, int));\n";
};

fix = {
    hackname  = hpux11_extern_sendpath;
    mach      = "*-hp-hpux11.[12]*";
    files     = sys/socket.h;
    select    = "^[ \t]*extern sbsize_t sendpath.*\n.*, int\\)\\);\n";
    c_fix     = format;
    c_fix_arg = "#ifndef _APP32_64BIT_OFF_T\n%0#endif\n";
    test_text = "   extern sbsize_t sendpath __((int, int, off_t, bsize_t,\n                               const struct iovec *, int));\n";
};

fix = {
    hackname  = hpux_extern_errno;
    mach      = "*-hp-hpux10.*";
    mach      = "*-hp-hpux11.[0-2]*";
    files     = errno.h;
    select    = "^[ \t]*extern int errno;$";
    c_fix     = format;
    c_fix_arg = "#ifdef __cplusplus\nextern \"C\" {\n#endif\n%0\n#ifdef __cplusplus\n}\n#endif";
    test_text = "   extern int errno;\n";
};


/*
 *  Add missing braces to pthread initializer defines.
 */
fix = {
    hackname  = hpux_pthread_initializers;
    mach      = "*-hp-hpux11.[0-3]*";
    files     = sys/pthread.h;
    sed       = "s@^[ \t]*1, 1, 1, 1,[ \t]*\\\\"
		 "@\t{ 1, 1, 1, 1 },\t\t\t\t\t\t\t\\\\@";
    sed       = "s@^[ \t]*1,[ \t]*\\\\"
		 "@\t{ 1, 0 }@";
    sed       = "/^[ \t]*0$/d";
    sed       = "s@__PTHREAD_MUTEX_VALID, 0"
		 "@{ __PTHREAD_MUTEX_VALID, 0 }@";
    sed       = "s@^[ \t]*0, 0, -1, 0,[ \t]*\\\\"
		 "@\t{ 0, 0, -1, 0 },\t\t\t\t\t\t\\\\@";
    sed       = "s@0, __LWP_MTX_VALID, 0, 1, 1, 1, 1,[ \t]*\\\\"
		 "@{ 0, __LWP_MTX_VALID }, { 0, 1, 1, 1, 1 },\t\t\t\\\\@";
    sed       = "s@^[ \t]*__LWP_MTX_VALID, 0, 1, 1, 1, 1,[ \t]*\\\\"
		 "@\t{ 0, __LWP_MTX_VALID }, { 0, 1, 1, 1, 1 },\t\t\t\\\\@";
    sed       = "s@^[ \t]*0, 0[ \t]*\\\\"
		 "@\t{ 0, 0 }\t\t\t\t\t\t\t\\\\@";
    sed       = "s@__PTHREAD_COND_VALID, 0"
		 "@{ __PTHREAD_COND_VALID, 0 }@";
    sed       = "s@__LWP_COND_VALID, 0,[ \t]*\\\\"
		 "@{ __LWP_COND_VALID, 0 },\t\t\t\t\t\\\\@";
    sed       = "s@__PTHREAD_RWLOCK_VALID, 0"
		 "@{ __PTHREAD_RWLOCK_VALID, 0 }@";
    sed       = "s@__LWP_RWLOCK_VALID, 0,[ \t]*\\\\"
		 "@{ __LWP_RWLOCK_VALID, 0 },\t\t\t\t\t\\\\@";
    sed       = "s@^[ \t]*0, 0, 0, 0, 0, 0, 0[ \t]*\\\\"
		 "@\t{ 0, 0, 0, 0, 0 }, { 0, 0}\t\t\t\t\t\\\\@";
    test_text = "#define PTHREAD_MUTEX_INITIALIZER  {\t\t\t\t\t\\\\\n"
		"\t__PTHREAD_MUTEX_VALID, 0,\t\t\t\t\t\\\\\n"
		"\t(PTHREAD_MUTEX_DEFAULT | PTHREAD_PROCESS_PRIVATE),\t\t\\\\\n"
		"\t__SPNLCK_INITIALIZER,\t\t\t\t\t\t\\\\\n"
		"\t0, 0, -1, 0,\t\t\t\t\t\t\t\\\\\n"
		"\t0, __LWP_MTX_VALID, 0, 1, 1, 1, 1,\t\t\t\t\\\\\n"
		"\t0, 0\t\t\t\t\t\t\t\t\\\\\n"
		"}\n";
};

/*
 *  Fix glibc definition of HUGE_VAL in terms of hex floating point constant
 */
fix = {
    hackname  = huge_val_hex;
    files     = bits/huge_val.h;
    select    = "^#[ \t]*define[ \t]*HUGE_VAL[ \t].*0x1\\.0p.*";
    bypass    = "__builtin_huge_val";

    c_fix     = format;
    c_fix_arg = "#define HUGE_VAL (__builtin_huge_val())\n";

    test_text = "# define HUGE_VAL\t(__extension__ 0x1.0p2047)";
};


/*
 *  Fix glibc definition of HUGE_VALF in terms of hex floating point constant
 */
fix = {
    hackname  = huge_valf_hex;
    files     = bits/huge_val.h;
    select    = "^#[ \t]*define[ \t]*HUGE_VALF[ \t].*0x1\\.0p.*";
    bypass    = "__builtin_huge_valf";

    c_fix     = format;
    c_fix_arg = "#define HUGE_VALF (__builtin_huge_valf())\n";

    test_text = "#  define HUGE_VALF (__extension__ 0x1.0p255f)";
};


/*
 *  Fix glibc definition of HUGE_VALL in terms of hex floating point constant
 */
fix = {
    hackname  = huge_vall_hex;
    files     = bits/huge_val.h;
    select    = "^#[ \t]*define[ \t]*HUGE_VALL[ \t].*0x1\\.0p.*";
    bypass    = "__builtin_huge_vall";

    c_fix     = format;
    c_fix_arg = "#define HUGE_VALL (__builtin_huge_vall())\n";

    test_text = "#  define HUGE_VALL (__extension__ 0x1.0p32767L)";
};


/*
 *  Fix return type of abort and free
 */
fix = {
    hackname  = int_abort_free_and_exit;
    files     = stdlib.h;
    select    = "int[ \t]+(abort|free|exit)[ \t]*\\(";
    bypass    = "_CLASSIC_ANSI_TYPES";

    c_fix     = format;
    c_fix_arg = "void\t%1(";

    test_text = "extern int abort(int);\n"
                "extern int free(void*);\n"
                "extern int exit(void*);";
};


/*
 *  Fix various macros used to define ioctl numbers.
 *  The traditional syntax was:
 *
 *    #define _IO(n, x) (('n'<<8)+x)
 *    #define TIOCFOO _IO(T, 1)
 *
 *  but this does not work with the C standard, which disallows macro
 *  expansion inside strings.  We have to rewrite it thus:
 *
 *    #define _IO(n, x) ((n<<8)+x)
 *    #define TIOCFOO  _IO('T', 1)
 *
 *  The select expressions match too much, but the c_fix code is cautious.
 *
 *  _IO might be: _IO DESIO BSD43__IO with W, R, WR, C, ... suffixes.
 */
fix = {
    hackname  = io_quotes_def;
    select    = "define[ \t]+[A-Z0-9_]+IO[A-Z]*\\([a-zA-Z][,)]";
    c_fix     = char_macro_def;
    c_fix_arg = "IO";
    test_text =
    "#define BSD43__IOWR(n, x) (('n'<<8)+x)\n"
    "#define _IOWN(x,y,t)  (_IOC_IN|(((t)&_IOCPARM_MASK)<<16)|('x'<<8)|y)\n"
    "#define _IO(x,y)      ('x'<<8|y)";
    test_text =
    "#define XX_IO(x)        ('x'<<8|256)";
};

fix = {
    hackname  = io_quotes_use;
    select    = "define[ \t]+[A-Z0-9_]+[ \t]+[A-Z0-9_]+IO[A-Z]*[ \t]*"
                "\\( *[^,']";
    c_fix     = char_macro_use;
    c_fix_arg = "IO";
    test_text = "#define TIOCFOO BSD43__IOWR(T, 1)\n"
                "#define TIOCFOO \\\\\n"
                "BSD43__IOWR(T, 1) /* Some are multi-line */";
};


/*
 *  Check for missing ';' in struct
 */
fix = {
    hackname = ip_missing_semi;
    files    = netinet/ip.h;
    select   = "}$";
    sed      = "/^struct/,/^};/s/}$/};/";
    test_text=
    "struct mumble {\n"
    "  union {\n"
    "    int x;\n"
    "  }\n"
    "}; /* mumbled struct */\n";
};


/*
 *  IRIX 6.5.1[89] <internal/sgimacros.h> unconditionally defines
 *  __restrict as restrict iff __c99.  This is wrong for C++, which
 *  needs many C99 features, but only supports __restrict.
 */
fix = {
    hackname  = irix___restrict;
    files     = internal/sgimacros.h;
    select    = "(#ifdef __c99\n)(#[ \t]*define __restrict restrict)";

    mach      = "mips-sgi-irix6.5";
    c_fix     = format;
    c_fix_arg = "%1"
		"#  ifndef __cplusplus\n%2\n#  endif";

    test_text = "#ifdef __c99\n#  define __restrict restrict";
};

/*
 * IRIX 6.5.22 <internal/math_core.h> uses the SGI c99 __generic() intrinsic
 * to define the fpclasify, isfinite, isinf, isnan, isnormal and signbit 
 * functions.
 *
 * This was probably introduced around IRIX 6.5.18
 */
fix = {
    hackname  = irix___generic1;
    files     = internal/math_core.h;
    mach      = "mips-sgi-irix6.5";
    select    = "#define ([a-z]+)\\(x\\) *__generic.*";

    c_fix     = format;
    c_fix_arg = "extern int %1(double);\n"
		"extern int %1f(float);\n"
		"extern int %1l(long double);\n"
		"#define %1(x) (sizeof(x) == sizeof(double) ? _%1(x) \\\n"
		"               : sizeof(x) == sizeof(float) ? _%1f(x) \\\n"
		"               : _%1l(x))\n";

    test_text = 
      "#define isnan(x) __generic(x,,, _isnan, _isnanf, _isnanl,,,)(x)\n";
};


/* Likewise <internal/math_core.h> on IRIX 6.5.19 and later uses the SGI
   compiler's __generic intrinsic to define isgreater, isgreaterequal,
   isless, islessequal, islessgreater and isunordered functions.  */
fix = {
    hackname  = irix___generic2;
    files     = internal/math_core.h;
    mach      = "mips-sgi-irix6.5";
    select    = "#define ([a-z]+)\\(x,y\\) *__generic.*";

    c_fix     = format;
    c_fix_arg = "#define %1(x,y) \\\n"
		"  ((sizeof(x)<=4 && sizeof(y)<=4) ? _%1f(x,y) \\\n"
		"   : (sizeof(x)<=8 && sizeof(y)<=8) ? _%1(x,y) \\\n"
		"   : _%1l(x,y))\n";

    test_text = 
      "#define isless(x,y)         __generic(x,y,, _isless, _islessf, _islessl,,,)(x,y)";
};


/*
 *  IRIX 5.2's <sys/asm.h> contains an asm comment with a contraction
 *  that causes the assembly preprocessor to complain about an
 *  unterminated character constant.
 */
fix = {
    hackname  = irix_asm_apostrophe;
    files     = sys/asm.h;

    select    = "^[ \t]*#.*[Ww]e're";
    c_fix     = format;
    c_fix_arg = "%1 are";
    c_fix_arg = "^([ \t]*#.*[Ww]e)'re";
    test_text = "\t# and we're on vacation";
};


/*
 *  Non-traditional "const" declaration in Irix's limits.h.
 */
fix = {
    hackname    = irix_limits_const;
    files       = fixinc-test-limits.h, limits.h;
    select      = "^extern const ";
    c_fix       = format;
    c_fix_arg   = "extern __const ";
    test_text   = "extern const char limit; /* test limits */";
};


/*
 *  IRIX 6.5.1[78] <sys/socket.h> has a broken definition of socklen_t.
 *  Various socket function prototypes use different types instead,
 *  depending on the API in use (BSD, XPG4/5), but the socklen_t
 *  definition doesn't reflect this (SGI Bug Id 864477, fixed in
 *  IRIX 6.5.19).
 */
fix = {
    hackname  = irix_socklen_t;
    files     = sys/socket.h;
    select    = "(#define _SOCKLEN_T\n)(typedef u_int32_t socklen_t;)";

    mach      = "mips-sgi-irix6.5";
    c_fix     = format;
    c_fix_arg = "%1"
    		"#if _NO_XOPEN4 && _NO_XOPEN5\n"
    		"typedef int socklen_t;\n"
		"#else\n"
    		"%2\n"
    		"#endif /* _NO_XOPEN4 && _NO_XOPEN5 */";

    test_text = "#define _SOCKLEN_T\ntypedef u_int32_t socklen_t;";
};

/*
 *  IRIX 6.5 <stdint.h> only works with ISO C99 and errors out
 *  otherwise.
 */
fix = {
    hackname  = irix_stdint_c99;
    files     = stdint.h;
    select = "(#ifndef __c99\n)(#error This header file is to be used only for c99 mode compilations)";

    mach      = "mips-sgi-irix6.5";
    c_fix  = format;
    c_fix_arg = "#if 0\n"
	        "%2";
    test_text =
    "#ifndef __c99\n#error This header file is to be used only for c99 mode compilations\n#else";
};


/*
 *  IRIX 5.x's stdio.h and IRIX 6.5's internal/stdio_core.h declare
 *  some functions that take a va_list as
 *  taking char *.  However, GCC uses void * for va_list, so
 *  calling vfprintf with a va_list fails in C++.  */
fix = {
    hackname  = irix_stdio_va_list;
    files     = stdio.h;
    files     = internal/stdio_core.h;

    select = '/\* va_list \*/ char \*';
    c_fix  = format;
    c_fix_arg = "__gnuc_va_list";
    test_text =
    "extern int printf( const char *, /* va_list */ char * );";
};


/*
 *  IRIX 6.5.19 <internal/wchar_core.h> provides the XPG4 variant of
 *  wcsftime by default.  ISO C99 requires the XPG5 variant instead.
 */
fix = {
    hackname  = irix_wcsftime;
    files     = internal/wchar_core.h;
    select    = "#if _NO_XOPEN5\n(extern size_t[ \t]+wcsftime.*const char \*.*)";

    mach      = "mips-sgi-irix6.5";
    c_fix     = format;
    c_fix_arg = "#if _NO_XOPEN5 && !defined(__c99)\n%1";

    test_text = "#if _NO_XOPEN5\n"
		"extern size_t wcsftime(wchar_t *, "
		"__SGI_LIBC_NAMESPACE_QUALIFIER size_t, const char *, "
		"const struct tm *);";
};

/*
 * Fixing ISC fmod declaration
 */
fix = {
    hackname  = isc_fmod;
    files     = math.h;
    select    = 'fmod\(double\)';
    c_fix     = format;
    c_fix_arg = "fmod(double, double)";
    test_text = "extern double	fmod(double);";
};


/*
 *  On Interactive Unix 2.2, certain traditional Unix definitions
 *  (notably getc and putc in stdio.h) are omitted if __STDC__ is
 *  defined, not just if _POSIX_SOURCE is defined.  This makes it
 *  impossible to compile any nontrivial program except with -posix.
 */
fix = {
    hackname = isc_omits_with_stdc;

    files     = "stdio.h";
    files     = "math.h";
    files     = "ctype.h";
    files     = "sys/limits.h";
    files     = "sys/fcntl.h";
    files     = "sys/dirent.h";

    select    = '!defined\(__STDC__\) && !defined\(_POSIX_SOURCE\)';
    c_fix     = format;
    c_fix_arg = '!defined(_POSIX_SOURCE)';
    test_text = "#if !defined(__STDC__) && !defined(_POSIX_SOURCE) /* ? ! */"
                "\nint foo;\n#endif";
};


/*
 * These files in Sun OS 4.x and ARM/RISCiX and BSD4.3
 * use / * * / to concatenate tokens.
 */
fix = {
    hackname = kandr_concat;
    files  = "sparc/asm_linkage.h";
    files  = "sun*/asm_linkage.h";
    files  = "arm/as_support.h";
    files  = "arm/mc_type.h";
    files  = "arm/xcb.h";
    files  = "dev/chardefmac.h";
    files  = "dev/ps_irq.h";
    files  = "dev/screen.h";
    files  = "dev/scsi.h";
    files  = "sys/tty.h";
    files  = "Xm.acorn/XmP.h";
    files  = bsd43/bsd43_.h;
    select = '/\*\*/';
    c_fix     = format;
    c_fix_arg = '##';
    test_text = "#define __CONCAT__(a,b) a/**/b";
};


/* The /usr/include/sys/ucontext.h on ia64-*linux-gnu systems defines
 * an _SC_GR0_OFFSET macro using an idiom that isn't a compile time
 * constant on recent versions of g++.
 */
fix = {
    hackname = linux_ia64_ucontext;
    files = "sys/ucontext.h";
    mach = "ia64-*-linux*";
    select = '\(\(\(char \*\) &\(\(struct sigcontext \*\) 0\)'
             '->sc_gr\[0\]\) - \(char \*\) 0\)';
    c_fix = format;
    c_fix_arg = "__builtin_offsetof \(struct sigcontext, sc_gr[0]\)";
    test_text = "# define _SC_GR0_OFFSET\t\\\\\n"
	"\t(((char *) &((struct sigcontext *) 0)->sc_gr[0]) - (char *) 0)\n";
};


/* 
 *  Remove header file warning from sys/time.h.  Autoconf's
 *  AC_HEADER_TIME recommends to include both sys/time.h and time.h
 *  which causes warning on LynxOS.  Remove the warning.
 */
fix = {
    hackname  = lynxos_no_warning_in_sys_time_h;
    files     = sys/time.h;
    select    = "#warning[ \t]+Using <time.h> instead of <sys/time.h>";
    c_fix     = format;
    c_fix_arg = "";
    test_text = "#warning Using <time.h> instead of <sys/time.h>";
};


/* 
 *  Add missing declaration for putenv.
 */
fix = {
    hackname  = lynxos_missing_putenv;
    mach      = '*-*-lynxos*';
    files     = stdlib.h;
    bypass    = 'putenv[ \t]*\\(';
    select    = "extern char \\*getenv[ \t]*_AP\\(\\(const char \\*\\)\\);";
    c_fix     = format;
    c_fix_arg = "%0\n"
        "extern int putenv				_AP((char *));";
    c_fix_arg = "extern char \\*getenv[ \t]*_AP\\(\\(const char \\*\\)\\);";
    test_text = "extern char *getenv	_AP((const char *));";
};


/*
 * Fix BSD machine/ansi.h to use __builtin_va_list to define _BSD_VA_LIST_.
 *
 * On NetBSD, machine is a symbolic link to an architecture specific
 * directory name, so we can't match a specific file name here.
 */
fix = {
    hackname = machine_ansi_h_va_list;
    select   = "define[ \t]+_BSD_VA_LIST_[ \t]";
    bypass   = '__builtin_va_list';

    c_fix     = format;
    c_fix_arg = "%1__builtin_va_list";
    c_fix_arg = "(define[ \t]+_BSD_VA_LIST_[ \t]+).*";

    test_text = " # define _BSD_VA_LIST_\tchar**";
};


/*
 *  Fix non-ansi machine name defines
 */
fix = {
    hackname  = machine_name;
    c_test    = machine_name;
    c_fix     = machine_name;

    test_text = "/* MACH_DIFF: */\n"
    "#if defined( i386 ) || defined( sparc ) || defined( vax )"
    "\n/* no uniform test, so be careful  :-) */";
};


/*
 *  Some math.h files define struct exception (it's in the System V
 *  Interface Definition), which conflicts with the class exception defined
 *  in the C++ file std/stdexcept.h.  We redefine it to __math_exception.
 *  This is not a great fix, but I haven't been able to think of anything
 *  better.  Note that we have to put the #ifdef/#endif blocks at beginning
 *  and end of file, because fixproto runs after us and may insert
 *  additional references to struct exception.
 */
fix = {
    hackname  = math_exception;
    files     = math.h;
    select    = "struct exception";
    /*
     * This should be bypassed on __cplusplus, but some supposedly C++ C++
     * aware headers, such as Solaris 8 and 9, don't wrap their struct
     * exception either.  So currently we bypass only for glibc, based on a
     * comment in the fixed glibc header.  Ick.
     */
    bypass    = 'We have a problem when using C\+\+|for C\+\+, '
		'_[a-z0-9A-Z_]+_exception; for C, exception';
    c_fix     = wrap;

    c_fix_arg = "#ifdef __cplusplus\n"
                "#define exception __math_exception\n"
                "#endif\n";

    c_fix_arg = "#ifdef __cplusplus\n"
                "#undef exception\n"
                "#endif\n";

    test_text = "typedef struct exception t_math_exception;";
};


/*
 *  This looks pretty broken to me.  ``dbl_max_def'' will contain
 *  "define DBL_MAX " at the start, when what we really want is just
 *  the value portion.  Can't figure out how to write a test case
 *  for this either  :-(
 */
fix = {
    hackname = math_huge_val_from_dbl_max;
    files    = math.h;

    /*
     * IF HUGE_VAL is defined to be DBL_MAX *and* DBL_MAX is _not_ defined
     * in math.h, this fix applies.
     */
    select   = "define[ \t]+HUGE_VAL[ \t]+DBL_MAX";
    bypass   = "define[ \t]+DBL_MAX";

    shell    =
    /*
     *  See if we have a definition for DBL_MAX in float.h.
     *  If we do, we will replace the one in math.h with that one.
     */

    "\tdbl_max_def=`egrep 'define[ \t]+DBL_MAX[ \t]+.*' float.h "
                   "| sed 's/.*DBL_MAX[ \t]*//' 2>/dev/null`\n\n"

    "\tif ( test -n \"${dbl_max_def}\" ) > /dev/null 2>&1\n"
    "\tthen sed -e '/define[ \t]*HUGE_VAL[ \t]*DBL_MAX/"
			"s@DBL_MAX@'\"$dbl_max_def@\"\n"
    "\telse cat\n"
    "\tfi";

    test_text =
    "`echo '#define DBL_MAX\t3.1415e+9 /* really big */' >> float.h`\n"
    "#define HUGE_VAL DBL_MAX";
};


/*
 *  nested comment
 */
fix = {
    hackname  = nested_auth_des;
    files     = rpc/rpc.h;
    select    = '(/\*.*rpc/auth_des\.h>.*)/\*';
    c_fix     = format;
    c_fix_arg = "%1*/ /*";
    test_text = "/*#include <rpc/auth_des.h> /* skip this */";
};


/*
 * Fixing nested comments in ISC <sys/limits.h>
 */
fix = {
    hackname = nested_sys_limits;
    files  = sys/limits.h;
    select = CHILD_MAX;
    sed    = "/CHILD_MAX/s,/\\* Max, Max,";
    sed    = "/OPEN_MAX/s,/\\* Max, Max,";
    test_text = "/*\n#define CHILD_MAX 20 /* Max, Max, ... */ /*\n"
                "#define OPEN_MAX  20 /* Max, Max, ... */\n";
};


/*
 *  Some versions of NetBSD don't expect the C99 inline semantics.
 */
fix = {
    hackname  = netbsd_c99_inline_1;
    mach      = "*-*-netbsd*";
    files     = signal.h;
    select    = "extern __inline int";

    c_fix     = format;
    c_fix_arg = "extern\n"
		"#ifdef __GNUC_STDC_INLINE__\n"
		"__attribute__((__gnu_inline__))\n"
		"#endif\n"
		"__inline int";

    test_text = "extern __inline int\nsigaddset(sigset_t *set, int signo)\n{}";
};


fix = {
    hackname  = netbsd_c99_inline_2;
    mach      = "*-*-netbsd*";
    files     = signal.h;
    select    = "#define _SIGINLINE extern __inline";

    c_fix     = format;
    c_fix_arg = <<- _EOArg_
	#ifdef __GNUC_STDC_INLINE__
	#define _SIGINLINE extern __attribute__((__gnu_inline__)) __inline
	#else
	%0
	#endif
	_EOArg_;

    test_text = "#define _SIGINLINE extern __inline";
};


/*
 * NetBSD has a semicolon after the ending '}' for some extern "C".
 */
fix = {
    hackname  = netbsd_extra_semicolon;
    mach      = "*-*-netbsd*";
    files     = sys/cdefs.h;
    select    = "#define[ \t]*__END_DECLS[ \t]*};";

    c_fix     = format;
    c_fix_arg = "#define __END_DECLS }";

    test_text = "#define __END_DECLS };";
};


/*
 *  NeXT 3.2 adds const prefix to some math functions.
 *  These conflict with the built-in functions.
 */
fix = {
    hackname  = next_math_prefix;
    files     = ansi/math.h;
    select    = "^extern[ \t]+double[ \t]+__const__[ \t]";

    c_fix     = format;
    c_fix_arg = "extern double %1(";
    c_fix_arg = "^extern[ \t]+double[ \t]+__const__[ \t]+([a-z]+)\\(";

    test_text = "extern\tdouble\t__const__\tmumble();";
};


/*
 *  NeXT 3.2 uses the word "template" as a parameter for some
 *  functions. GCC reports an invalid use of a reserved key word
 *  with the built-in functions.
 */
fix = {
    hackname = next_template;
    files    = bsd/libc.h;
    select   = "[ \t]template\\)";

    c_fix     = format;
    c_fix_arg = "(%1)";
    c_fix_arg = "\\(([^)]*)[ \t]template\\)";
    test_text = "extern mumble( char * template); /* fix */";
};


/*
 *  NeXT 3.2 includes the keyword volatile in the abort() and  exit()
 *  function prototypes. That conflicts with the  built-in functions.
 */
fix = {
    hackname = next_volitile;
    files    = ansi/stdlib.h;
    select   = "^extern[ \t]+volatile[ \t]+void[ \t]";

    c_fix     = format;
    c_fix_arg = "extern void %1(";
    c_fix_arg = "^extern[ \t]+volatile[ \t]+void[ \t]+(exit|abort)\\(";

    test_text = "extern\tvolatile\tvoid\tabort();";
};


/*
 *  NeXT 2.0 defines 'int wait(union wait*)', which conflicts with Posix.1.
 *  Note that version 3 of the NeXT system has wait.h in a different directory,
 *  so that this code won't do anything.  But wait.h in version 3 has a
 *  conditional, so it doesn't need this fix.  So everything is okay.
 */
fix = {
    hackname  = next_wait_union;
    files     = sys/wait.h;

    select    = 'wait\(union wait';
    c_fix     = format;
    c_fix_arg = "wait(void";
    test_text = "extern pid_d wait(union wait*);";
};


/*
 *  a missing semi-colon at the end of the nodeent structure definition.
 */
fix = {
    hackname  = nodeent_syntax;
    files     = netdnet/dnetdb.h;
    select    = "char[ \t]*\\*na_addr[ \t]*$";
    c_fix     = format;
    c_fix_arg = "%0;";
    test_text = "char *na_addr\t";
};

/* 
 * Fix OpenBSD's NULL definition.
 */
fix = {
  hackname  = openbsd_null_definition;
  mach      = "*-*-openbsd*";
  files     = locale.h, stddef.h, stdio.h, string.h,
  time.h, unistd.h, wchar.h, sys/param.h;
  select    = "__GNUG__";
  c_fix = format;
  c_fix_arg = "#ifndef NULL\n"
	      "#ifdef __cplusplus\n"
	      "#ifdef __GNUG__\n"
	      "#define NULL\t__null\n"
	      "#else\t /* ! __GNUG__  */\n"
	      "#define NULL\t0L\n"
              "#endif\t /* __GNUG__  */\n"
	      "#else\t /* ! __cplusplus  */\n"
	      "#define NULL\t((void *)0)\n"
              "#endif\t /* __cplusplus  */\n"
              "#endif\t /* !NULL  */";

  c_fix_arg = "^#ifndef[ \t]*NULL\n"
	      "^#ifdef[ \t]*__GNUG__\n"
  	      "^#define[ \t]*NULL[ \t]*__null\n"
  	      "^#else\n"
              "^#define[ \t]*NULL[ \t]*0L\n"
              "^#endif\n"
              "^#endif";
  test_text = 
	"#ifndef NULL\n"
	"#ifdef  __GNUG__\n"
	"#define NULL    __null\n"
	"#else\n"
	"#define NULL    0L\n"
	"#endif\n"
	"#endif\n";
};

/*
 *  obstack.h used casts as lvalues.
 *
 *  We need to change postincrements of casted pointers (which are
 *  then dereferenced and assigned into) of the form
 *
 *    *((TYPE*)PTRVAR)++ = (VALUE)
 *
 *  into expressions like
 *
 *    ((*((TYPE*)PTRVAR) = (VALUE)), (PTRVAR += sizeof (TYPE)))
 *
 *  which is correct for the cases used in obstack.h since PTRVAR is
 *  of type char * and the value of the expression is not used.
 */
fix = {
    hackname  = obstack_lvalue_cast;
    files     = obstack.h;
    select    = '\*\(\(([^()]*)\*\)(.*)\)\+\+ = \(([^()]*)\)';
    c_fix     = format;
    c_fix_arg = "((*((%1*)%2) = (%3)), (%2 += sizeof (%1)))";
    test_text = "*((void **) (h)->next_free)++ = (aptr)";
};

/* 
 * Fix OpenBSD's va_start define.
 */
fix = {
  hackname  = openbsd_va_start;
  mach      = "*-*-openbsd*";
  files     = stdarg.h;
  select    = '__builtin_stdarg_start';
  c_fix     = format;
  c_fix_arg = __builtin_va_start;

  test_text = "#define va_start(v,l)   __builtin_stdarg_start((v),l)";
};

/*
 *  sys/lc_core.h on some versions of OSF1/4.x pollutes the namespace by
 *  defining regex.h related types.  This causes libg++ build and usage
 *  failures.  Fixing this correctly requires checking and modifying 3 files.
 */
fix = {
    hackname = osf_namespace_a;
    files    = reg_types.h;
    files    = sys/lc_core.h;
    test     = " -r reg_types.h";
    test     = " -r sys/lc_core.h";
    test     = " -n \"`grep '} regex_t;' reg_types.h`\"";
    test     = " -z \"`grep __regex_t regex.h`\"";

    c_fix     = format;
    c_fix_arg = "__%0";
    c_fix_arg = "reg(ex|off|match)_t";

    test_text = "`touch sys/lc_core.h`"
    "typedef struct {\n  int stuff, mo_suff;\n} regex_t;\n"
    "extern regex_t    re;\n"
    "extern regoff_t   ro;\n"
    "extern regmatch_t rm;\n";
};

fix = {
    hackname = osf_namespace_c;
    files    = regex.h;
    test     = " -r reg_types.h";
    test     = " -r sys/lc_core.h";
    test     = " -n \"`grep '} regex_t;' reg_types.h`\"";
    test     = " -z \"`grep __regex_t regex.h`\"";

    select    = "#include <reg_types\.h>.*";
    c_fix     = format;
    c_fix_arg = "%0\n"
                "typedef __regex_t\tregex_t;\n"
                "typedef __regoff_t\tregoff_t;\n"
                "typedef __regmatch_t\tregmatch_t;";

    test_text = "#include <reg_types.h>";
};


/*
 *  Fix __page_size* declarations in pthread.h AIX 4.1.[34].
 *  The original ones fail if uninitialized externs are not common.
 *  This is the default for all ANSI standard C++ compilers.
 */
fix = {
    hackname  = pthread_page_size;
    files     = pthread.h;
    select    = "^int __page_size";
    c_fix     = format;
    c_fix_arg = "extern %0";
    test_text = "int __page_size;";
};

/*
 * On broken glibc-2.3.3 systems an array of incomplete structures is
 * passed to __sigsetjmp.  Fix that to take a pointer instead.
 */
fix = {
    hackname  = pthread_incomplete_struct_argument;
    files     = pthread.h;
    select    = "struct __jmp_buf_tag";
    c_fix     = format;
    c_fix_arg = "%1 *%2%3";
    c_fix_arg = "^(extern int __sigsetjmp \\(struct __jmp_buf_tag) (__env)\\[1\\](.*)$";
    test_text = "extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask);";
};

/*
 *  Fix return type of fread and fwrite on sysV68
 */
fix = {
    hackname = read_ret_type;
    files    = stdio.h;
    select   = "extern int\t.*, fread\\(\\), fwrite\\(\\)";
    c_fix     = format;
    c_fix_arg = "extern unsigned int fread(), fwrite();\n%1%2";
    c_fix_arg = "(extern int\t.*), fread\\(\\), fwrite\\(\\)(.*)";

    test_text = "extern int\tfclose(), fflush(), fread(), fwrite(), foo();";
};


/*
 *  Fix casts as lvalues in glibc's <rpc/xdr.h>.
 */
fix = {
    hackname  = rpc_xdr_lvalue_cast_a;
    files     = rpc/xdr.h;
    select    = "#define[ \t]*IXDR_GET_LONG.*\\\\\n.*__extension__.*";
    c_fix     = format;
    c_fix_arg = "#define IXDR_GET_LONG(buf) ((long)IXDR_GET_U_INT32(buf))";
    test_text = "#define IXDR_GET_LONG(buf) \\\\\n"
                "\t((long)ntohl((u_long)*__extension__((u_int32_t*)(buf))++))";
};


fix = {
    hackname  = rpc_xdr_lvalue_cast_b;
    files     = rpc/xdr.h;
    select    = "#define[ \t]*IXDR_PUT_LONG.*\\\\\n.*__extension__.*";
    c_fix     = format;
    c_fix_arg = "#define IXDR_PUT_LONG(buf, v) ((long)IXDR_PUT_INT32(buf, (long)(v)))";
    test_text = "#define IXDR_PUT_LONG(buf, v) \\\\\n"
                "\t(*__extension__((u_int32_t*)(buf))++ = (long)htonl((u_long)(v)))";
};


/*
 *  function class(double x) conflicts with C++ keyword on rs/6000
 */
fix = {
    hackname  = rs6000_double;
    files     = math.h;
    select    = '[^a-zA-Z_]class\(';

    c_fix     = format;
    c_fix_arg = "#ifndef __cplusplus\n%0\n#endif";
    c_fix_arg = '^.*[^a-zA-Z_]class\(.*';

    test_text = "extern int class();";
};


/*
 *  Wrong fchmod prototype on RS/6000.
 */
fix = {
    hackname  = rs6000_fchmod;
    files     = sys/stat.h;
    select    = 'fchmod\(char \*';
    c_fix     = format;
    c_fix_arg = "fchmod(int";
    test_text = "extern int fchmod(char *, mode_t);";
};


/*
 *  parameters conflict with C++ new on rs/6000
 */
fix = {
    hackname  = rs6000_param;
    files     = "stdio.h";
    files     = "unistd.h";

    select    = 'rename\(const char \*old, const char \*new\)';
    c_fix     = format;
    c_fix_arg = 'rename(const char *_old, const char *_new)';

    test_text = 'extern int rename(const char *old, const char *new);';
};


/*
 *  On OpenServer and on UnixWare 7, <math.h> uses the native compiler
 *  __builtin_generic. We fix that usage to use the GCC equivalent.
 * It also has a plethora of inline functions that conflict with libstdc++.
 */
fix = {
    hackname = sco_math;
    files    = math.h, '*/math.h';
    select   = "inline double abs";
    bypass   = "__GNUG__";
    sed      = "/#define.*__fp_class(a) \\\\/i\\\n"
	       "#ifndef __GNUC__\n";
    sed      =
"/.*__builtin_generic/a\\\n"
"#else\\\n"
"#define __fp_class(a) \\\\\\\n"
"  __builtin_choose_expr(__builtin_types_compatible_p(typeof(a),long double),\\\\\\\n"
"   __fpclassifyl(a), \\\\\\\n"
"    __builtin_choose_expr(__builtin_types_compatible_p(typeof(a), float), \\\\\\\n"
"      __fpclassifyf(a),__fpclassify(a)))\\\n"
"#endif";

    sed      = "/extern \"C\\+\\+\"/N;"
	       "/inline double abs/i\\\n"
               "#ifndef __GNUC__\n";
    sed      = "/inline long double trunc/N;"
	       "/inline long double trunc.*}.*extern \"C\\+\\+\"/a\\\n"
	       "#endif /* ! __GNUC__ */";

    test_text =
    "#define __fp_class(a) \\\\\n"
    " __builtin_generic(a,\"ld:__fplcassifyl;f:__fpclassifyf;:__fpclassify\")\n";

};


/*
 * Sun Solaris 10 defines several C99 math macros in terms of
 * builtins specific to the Studio compiler, in particular not
 * compatible with the GNU compiler.
 */
fix = {
    hackname = solaris_math_1;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\tHUGE_VA%1\t(__builtin_huge_va%2())";
    c_fix_arg = "^#define[ \t]+HUGE_VA([LF]+)[ \t]+__builtin_huge_va([lf]+)";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	HUGE_VAL\n"
    "#define	HUGE_VAL	__builtin_huge_val\n"
    "#undef	HUGE_VALF\n"
    "#define	HUGE_VALF	__builtin_huge_valf\n"
    "#undef	HUGE_VALL\n"
    "#define	HUGE_VALL	__builtin_huge_vall";
};

fix = {
    hackname = solaris_math_2;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\tINFINITY\t(__builtin_inff())";
    c_fix_arg = "^#define[ \t]+INFINITY[ \t]+__builtin_infinity";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	INFINITY\n"
    "#define	INFINITY	__builtin_infinity";
};

fix = {
    hackname = solaris_math_3;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\tNAN\t\t(__builtin_nanf(\"\"))";
    c_fix_arg = "^#define[ \t]+NAN[ \t]+__builtin_nan";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	NAN\n"
    "#define	NAN	__builtin_nan";
};

fix = {
    hackname = solaris_math_4;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\tfpclassify(x) \\\n"
                "  __builtin_fpclassify(FP_NAN, FP_INFINITE, FP_NORMAL, FP_SUBNORMAL, FP_ZERO, (x))";
    c_fix_arg = "^#define[ \t]+fpclassify\\(x\\)[ \t]+__builtin_fpclassify\\(x\\)";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	fpclassify\n"
    "#define	fpclassify(x)	__builtin_fpclassify(x)";
};

fix = {
    hackname = solaris_math_8;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\tsignbit(x)\t(sizeof(x) == sizeof(float) \\\n"
                "\t\t\t   ? __builtin_signbitf(x) \\\n"
                "\t\t\t   : sizeof(x) == sizeof(long double) \\\n"
                "\t\t\t     ? __builtin_signbitl(x) \\\n"
                "\t\t\t     : __builtin_signbit(x))";
    c_fix_arg = "^#define[ \t]+signbit\\(x\\)[ \t]+__builtin_signbit\\(x\\)";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	signbit\n"
    "#define	signbit(x)	__builtin_signbit(x)";
};

fix = {
    hackname = solaris_math_9;
    select = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    bypass = "__GNUC__";
    files = iso/math_c99.h;
    c_fix = format;
    c_fix_arg = "#define\t%1(x, y)%2__builtin_%1(x, y)";
    c_fix_arg = "^#define[ \t]+([a-z]+)\\(x, y\\)([ \t]+)\\(\\(x\\) __builtin_[a-z]+\\(y\\)\\)";
    test_text =
    '#ident	"@(#)math_c99.h	1.9	04/11/01 SMI"'"\n"
    "#undef	isgreater\n"
    "#define	isgreater(x, y)		((x) __builtin_isgreater(y))\n"
    "#undef	isgreaterequal\n"
    "#define	isgreaterequal(x, y)	((x) __builtin_isgreaterequal(y))\n"
    "#undef	isless\n"
    "#define	isless(x, y)		((x) __builtin_isless(y))\n"
    "#undef	islessequal\n"
    "#define	islessequal(x, y)	((x) __builtin_islessequal(y))\n"
    "#undef	islessgreater\n"
    "#define	islessgreater(x, y)	((x) __builtin_islessgreater(y))\n"
    "#undef	isunordered\n"
    "#define	isunordered(x, y)	((x) __builtin_isunordered(y))";
};

/*
 * On Solaris 11, if you do isinf(NaN) you'll get a floating point
 * exception.  Provide an alternative using GCC's builtin.
 */

fix = {
    hackname  = solaris_math_10;
    select    = '@\(#\)math_c99.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    files     = iso/math_c99.h;
    c_fix     = format;
    c_fix_arg = "#define\tisinf(x) __builtin_isinf(x)";
    c_fix_arg = "^#define[ \t]+isinf\\(x\\)[ \t]+__extension__\\([ \t]*\\\\\n"
                "[ \t]*\\{[ \t]*__typeof\\(x\\)[ \t]*__x_i[ \t]*=[ \t]*\\(x\\);[ \t]*\\\\\n"
                "[ \t]*__x_i[ \t]*==[ \t]*\\(__typeof\\(__x_i\\)\\)[ \t]*INFINITY[ \t]*\\|\\|[ \t]*\\\\\n"
                "[ \t]*__x_i[ \t]*==[ \t]*\\(__typeof\\(__x_i\\)\\)[ \t]*\\(-INFINITY\\);[ \t]*\\}\\)";
    test_text =
    '#pragma ident	"@(#)math_c99.h	1.12	07/01/21 SMI"'"\n"
    "#undef	isinf\n"
    "#define	isinf(x)	__extension__( \\\\\n"
    "			{ __typeof(x) __x_i = (x); \\\\\n"
    "			__x_i == (__typeof(__x_i)) INFINITY || \\\\\n"
    "			__x_i == (__typeof(__x_i)) (-INFINITY); })";
};

/*
 * Sun Solaris defines PTHREAD_MUTEX_INITIALIZER with a trailing
 * "0" for the last field of the pthread_mutex_t structure, which is
 * of type upad64_t, which itself is typedef'd to int64_t, but with
 * __STDC__ defined (e.g. by -ansi) it is a union. So change the
 * initializer to "{0}" instead
 */
fix = {
    hackname = solaris_mutex_init_2;
    select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    files = pthread.h;
    /*
     * On Solaris 10, this fix is unnecessary because upad64_t is
     * always defined correctly regardless of the definition of the
     * __STDC__ macro.  The first "mach" pattern matches up to
     * solaris9.  The second "mach" pattern will not match any two (or
     * more) digit solaris version, but it will match e.g. 2.5.1.
     */
    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
    c_fix = format;
    c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                "%0\n"
                "#else\n"
                "%1, {0}}%4\n"
                "#endif";
    c_fix_arg = "(^#define[ \t]+PTHREAD_(MUTEX|COND)_INITIALIZER[ \t]+"
                "(|/\*.*\*/[ \t]*\\\\\n[ \t]*)\\{.*)"
                ",[ \t]*0\\}" "(|[ \t].*)$";
    test_text =
    '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
    "#define PTHREAD_MUTEX_INITIALIZER\t{{{0},0}, {{{0}}}, 0}\n"
    "#define PTHREAD_COND_INITIALIZER\t{{{0}, 0}, 0}\t/* DEFAULTCV */\n"
    "#define	PTHREAD_MUTEX_INITIALIZER		/* = DEFAULTMUTEX */	\\\\\n"
    "	{{0, 0, 0, DEFAULT_TYPE, _MUTEX_MAGIC}, {{{0}}}, 0}\n"
    "#define	PTHREAD_COND_INITIALIZER		/* = DEFAULTCV */	\\\\\n"
    "	{{{0, 0, 0, 0}, DEFAULT_TYPE, _COND_MAGIC}, 0}";
};


/*
 * Sun Solaris defines PTHREAD_RWLOCK_INITIALIZER with a "0" for some
 *  fields of the pthread_rwlock_t structure, which are of type
 *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
 *  defined (e.g. by -ansi) it is a union. So change the initializer
 *  to "{0}" instead.
 */
fix = {
    hackname = solaris_rwlock_init_1;
    select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    files = pthread.h;
    mach = '*-*-solaris*';
    c_fix = format;
    c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                "%0\n"
                "#else\n"
                "%1{0, 0, 0, {{0}, {0}, {0}}, {{0}, {0}}, {{0}, {0}}}\n"
                "#endif";
    c_fix_arg = "(^#define[ \t]+PTHREAD_RWLOCK_INITIALIZER[ \t]+)"
                "\\{0, 0, 0, \\{0, 0, 0\\}, \\{0, 0\\}, \\{0, 0\\}\\}[ \t]*$";

    test_text =
    '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
    "#define PTHREAD_RWLOCK_INITIALIZER\t{0, 0, 0, {0, 0, 0}, {0, 0}, {0, 0}}";
};


/*
 * Sun Solaris defines PTHREAD_ONCE_INIT as an array containing a
 * structure.  As such, it need two levels of brackets, but only
 * contains one.  Wrap the macro definition in an extra layer.
 */
fix = {
    hackname = solaris_once_init_1;
    select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    files = pthread.h;
    mach = '*-*-solaris*';
    c_fix = format;
    c_fix_arg = "%1{%2}%3";
    c_fix_arg = "(^#define[ \t]+PTHREAD_ONCE_INIT[ \t]+\\{)([^}]+)(\\})[ \t]*$";
    test_text =
    '#pragma ident	"@(#)pthread.h	1.37	04/09/28 SMI"'"\n"
    "#define PTHREAD_ONCE_INIT\t{0, 0, 0, PTHREAD_ONCE_NOTDONE}";
};


/*
 * Sun Solaris defines PTHREAD_ONCE_INIT with a "0" for some
 *  fields of the pthread_once_t structure, which are of type
 *  upad64_t, which itself is typedef'd to int64_t, but with __STDC__
 *  defined (e.g. by -ansi) it is a union. So change the initializer
 *  to "{0}" instead.  This test relies on solaris_once_init_1.
 */
fix = {
    hackname = solaris_once_init_2;
    select = '@\(#\)pthread.h' "[ \t]+1.[0-9]+[ \t]+[0-9/]+ SMI";
    files = pthread.h;
    /*
     * On Solaris 10, this fix is unnecessary because upad64_t is
     * always defined correctly regardless of the definition of the
     * __STDC__ macro.  The first "mach" pattern matches up to
     * solaris9.  The second "mach" pattern will not match any two (or
     * more) digit solaris version, but it will match e.g. 2.5.1.
     */
    mach = '*-*-solaris2.[0-9]', '*-*-solaris2.[0-9][!0-9]*';
    c_fix = format;
    c_fix_arg = "#if __STDC__ - 0 == 0 && !defined(_NO_LONGLONG)\n"
                "%0\n"
                "#else\n"
                "%1{0}, {0}, {0}, {%3}%4\n"
                "#endif";
    c_fix_arg = "(^#define[ \t]+PTHREAD_ONCE_INIT[ \t]+\\{\\{)"
                "(0, 0, 0, )(PTHREAD_[A-Z_]+)(\\}\\})[ \t]*$";
    test_text =
    '#ident "@(#)pthread.h  1.26  98/04/12 SMI"'"\n"
    "#define PTHREAD_ONCE_INIT\t{{0, 0, 0, PTHREAD_ONCE_NOTDONE}}\n";
};


/*
 * Solaris 2.8 has what appears to be some gross workaround for 
 * some old version of their c++ compiler.  G++ doesn't want it
 * either, but doesn't want to be tied to SunPRO version numbers.
 */
fix = {
    hackname = solaris_stdio_tag;
    files    = stdio_tag.h;

    select   = '__cplusplus < 54321L';
    /* In Solaris 10, the code in stdio_tag.h is conditionalized on 
       "!defined(__GNUC__)" so we no longer need to fix it.  */
    bypass   = '__GNUC__';
    sed      = 's/defined(__cplusplus) && (__cplusplus < 54321L)/0/';

    test_text = "#if\tdefined(__cplusplus) && (__cplusplus < 54321L)";
};


/*
 *  a missing semi-colon at the end of the statsswtch structure definition.
 */
fix = {
    hackname  = statsswtch;
    files     = rpcsvc/rstat.h;
    select    = "boottime$";
    c_fix     = format;
    c_fix_arg = "boottime;";
    test_text = "struct statswtch {\n  int boottime\n};";
};


/*
 *  Arrange for stdio.h to use stdarg.h to define __gnuc_va_list.
 *  On 4BSD-derived systems, stdio.h defers to machine/ansi.h; that's
 *  OK too.
 */
fix = {
    hackname = stdio_stdarg_h;
    files    = stdio.h;
    bypass   = "include.*(stdarg\.h|machine/ansi\.h)";
    /*
     * On Solaris 10, this fix is unncessary; <stdio.h> includes
     * <iso/stdio_iso.h>, which includes <sys/va_list.h>.
      */
    mach     = '*-*-solaris2.1[0-9]*';
    not_machine = true;

    c_fix     = wrap;

    c_fix_arg = "#define __need___va_list\n#include <stdarg.h>\n";

    test_text = "";
};


/*
 *  Don't use or define the name va_list in stdio.h.  This is for
 *  ANSI.  Note _BSD_VA_LIST_ is dealt with elsewhere.  The presence
 *  of __gnuc_va_list, __DJ_va_list, or _G_va_list is taken to
 *  indicate that the header knows what it's doing -- under SUSv2,
 *  stdio.h is required to define va_list, and we shouldn't break
 *  that.  On IRIX 6.5, internal/wchar_core.h used to get its
 *  definition of va_list from stdio.h.  Since this doesn't happen any
 *  longer, use __gnuc_va_list there, too.
 */
fix = {
    hackname = stdio_va_list;
    files    = stdio.h;
    files    = internal/stdio_core.h;
    files    = internal/wchar_core.h;
    bypass   = '__gnuc_va_list|_BSD_VA_LIST_|__DJ_va_list|_G_va_list';
    /* 
     * On Solaris 10, the definition in 
     * <stdio.h> is guarded appropriately by the _XPG4 feature macro; 
     * there is therefore no need for this fix there.
     */
    mach = '*-*-solaris2.1[0-9]*';
    not_machine = true;

    /*
     * Use __gnuc_va_list in arg types in place of va_list.
     * On 386BSD use __gnuc_va_list instead of _VA_LIST_.  On Tru64 UNIX V5.1A
     * use __gnuc_va_list instead of __VA_LIST__.  We're hoping the
     * trailing parentheses and semicolon save all other systems from this.
     * Define __not_va_list__ (something harmless and unused)
     * instead of va_list.
     * Don't claim to have defined va_list.
     */
    sed = "s@[ \t]va_list\\([ \t)]\\)@ __gnuc_va_list\\1@\n"
	  "s@(va_list)&@(__gnuc_va_list)\\&@\n"
          "s@ _VA_LIST_));@ __gnuc_va_list));@\n"
          "s@ __VA_LIST__));@ __gnuc_va_list));@\n"
          "s@ va_list@ __not_va_list__@\n"
          "s@\\*va_list@*__not_va_list__@\n"
          "s@ __va_list)@ __gnuc_va_list)@\n"
          "s@typedef[ \t]\\(.*\\)[ \t]va_list[ \t]*;"
           "@typedef \\1 __not_va_list__;@\n"
	  "s@typedef[ \t]*__va_list__@typedef __gnuc_va_list@\n"
          "s@GNUC_VA_LIST@GNUC_Va_LIST@\n"
          "s@_VA_LIST_DEFINED@_Va_LIST_DEFINED@\n"
          "s@_NEED___VA_LIST@_NEED___Va_LIST@\n"
          "s@VA_LIST@DUMMY_VA_LIST@\n"
          "s@_Va_LIST@_VA_LIST@";
    test_text = "extern void mumble( va_list);";
};


/*
 *  Fix headers that use va_list from stdio.h to use the updated
 *  va_list from the stdio_va_list change.  Note _BSD_VA_LIST_ is
 *  dealt with elsewhere.  The presence of __gnuc_va_list,
 *  __DJ_va_list, or _G_va_list is taken to indicate that the header
 *  knows what it's doing.
 */
fix = {
    hackname = stdio_va_list_clients;
    files    = com_err.h;
    files    = cps.h;
    files    = curses.h;
    files    = krb5.h;
    files    = lc_core.h;
    files    = pfmt.h;
    files    = wchar.h;
    files    = curses_colr/curses.h;
    bypass   = '__gnuc_va_list|_BSD_VA_LIST_|__DJ_va_list|_G_va_list';
    /* Don't fix, if we use va_list from stdarg.h, or if the use is
       otherwise protected.  */
    bypass   = 'include <stdarg\.h>|#ifdef va_start';

    /*
     * Use __gnuc_va_list in arg types in place of va_list.
     * On 386BSD use __gnuc_va_list instead of _VA_LIST_.  On Tru64 UNIX V5.1A
     * use __gnuc_va_list instead of __VA_LIST__.  We're hoping the
     * trailing parentheses and semicolon save all other systems from this.
     * Define __not_va_list__ (something harmless and unused)
     * instead of va_list.
     * Don't claim to have defined va_list.
     */
    sed = "s@[ \t]va_list\\([ \t)]\\)@ __gnuc_va_list\\1@\n"
	  "s@(va_list)&@(__gnuc_va_list)\\&@\n"
          "s@ _VA_LIST_));@ __gnuc_va_list));@\n"
          "s@ __VA_LIST__));@ __gnuc_va_list));@\n"
          "s@ va_list@ __not_va_list__@\n"
          "s@\\*va_list@*__not_va_list__@\n"
          "s@ __va_list)@ __gnuc_va_list)@\n"
          "s@typedef[ \t]\\(.*\\)[ \t]va_list[ \t]*;"
           "@typedef \\1 __not_va_list__;@\n"
	  "s@typedef[ \t]*__va_list__@typedef __gnuc_va_list@\n"
          "s@GNUC_VA_LIST@GNUC_Va_LIST@\n"
          "s@_VA_LIST_DEFINED@_Va_LIST_DEFINED@\n"
          "s@_NEED___VA_LIST@_NEED___Va_LIST@\n"
          "s@VA_LIST@DUMMY_VA_LIST@\n"
          "s@_Va_LIST@_VA_LIST@";
    test_text = "extern void mumble( va_list);";
};


/*
 *  "!__STDC__" or "__STDC__==0" or "__STDC__!=1" or "__STDC__-0==0"
 *  is "!defined( __STRICT_ANSI__ )"
 */
fix = {
    hackname = strict_ansi_not;
    select   = "^([ \t]*#[ \t]*if.*)"
               "(!__STDC__"
               "|__STDC__[ \t]*==[ \t]*0"
               "|__STDC__[ \t]*!=[ \t]*1"
               "|__STDC__[ \t]*-[ \t]*0[ \t]*==[ \t]*0)";
    /* Tru64 UNIX V4.0F/V5.1 <standards.h> supports GCC usage of __STDC__. */
    bypass = 'GNU and MIPS C compilers define __STDC__ differently';
    /* GNU gmp.h uses "__STDC__ != 1" only if __SCO_VERSION__, which
       is not defined by GCC, so it is safe.  */
    bypass = '__SCO_VERSION__.*__STDC__ != 1';
    c_test   = stdc_0_in_system_headers;

    c_fix     = format;
    c_fix_arg = "%1 !defined(__STRICT_ANSI__)";

    test_text = "#if !__STDC__ \n"
                "#if __STDC__ == 0\n"
                "#if __STDC__ != 1\n"
                "#if __STDC__ - 0 == 0"
               "/* not std C */\nint foo;\n"
               "\n#end-end-end-end-if :-)";
};

/*
 *  "__STDC__-0==0"
 *  is "!defined( __STRICT_ANSI__ )" on continued #if-s
 */
fix = {
    hackname = strict_ansi_not_ctd;
    files    = math.h, limits.h, stdio.h, signal.h,
               stdlib.h, sys/signal.h, time.h;
    /*
     * Starting at the beginning of a line, skip white space and
     * a leading "(" or "&&" or "||".  One of those must be found.
     * Then, zero, one or more copies of a "defined(_FOO_BAR_) &&"
     * expression.  If these are nested, then they must accumulate
     * because we won't match any closing parentheses.  Finally,
     * after skipping over all that, we must then match our suspect
     * phrase:  "__STDC__-0==0" with or without white space.
     */
    select   = "^([ \t]*" '(\(|&&|\|\|)'
               "([ \t(]*!*[ \t]*defined\\([a-zA-Z_0-9]+\\)[ \t]*[|&][|&])*"
               "[ \t(]*)"
               "(__STDC__[ \t]*(|-[ \t]*0[ \t]*)==[ \t]*0)";
    c_test   = stdc_0_in_system_headers;

    c_fix     = format;
    c_fix_arg = "%1 !defined(__STRICT_ANSI__)";

    test_text = "#if 1 && \\\\\n"
               "&& defined(mumbling) |& (__STDC__ - 0 == 0) \\\\\n"
               "( __STDC__ == 0 && !defined(_XOPEN_SOURCE) \\\\\n"
               "|| __STDC__ - 0 == 0 ) /* not std C */\n"
               "int foo;\n#endif";
};


/*
 *  "__STDC__!=0" or "__STDC__==1" or "__STDC__-0==1"
 *  is "defined( __STRICT_ANSI__ )"
 */
fix = {
    hackname = strict_ansi_only;
    select   = "^([ \t]*#[ \t]*if.*)"
               "(__STDC__[ \t]*!=[ \t]*0"
               "|__STDC__[ \t]*==[ \t]*1"
               "|__STDC__[ \t]*-[ \t]*0[ \t]*==[ \t]*1"
               "|__STDC__[ \t]*-[ \t]*0[ \t]*!=[ \t]*0)";
    c_test   = stdc_0_in_system_headers;

    c_fix     = format;
    c_fix_arg = "%1 defined(__STRICT_ANSI__)";

    test_text = "#if __STDC__ == 1 /* is std C\n */\nint foo;\n#endif";
};


/*
 *  IRIX 4.0.5 <rpc/xdr.h> uses struct __file_s
 *  in prototype without previous definition.
 */
fix = {
    hackname  = struct_file;
    files     = rpc/xdr.h;
    select    = '^.*xdrstdio_create.*struct __file_s';
    c_fix     = format;
    c_fix_arg = "struct __file_s;\n%0";
    test_text = "extern void xdrstdio_create( struct __file_s* );";
};


/*
 *  IRIX 4.0.5 <rpc/auth.h> uses struct sockaddr
 *  in prototype without previous definition.
 *
 *  Don't fix OpenBSD, which uses struct sockaddr_in prototyping the same
 *  function, and does define it.
 */
fix = {
    hackname  = struct_sockaddr;
    files     = rpc/auth.h;
    select    = "^.*authdes_create.*struct sockaddr[^_]";
    bypass    = "<sys/socket\.h>";
    bypass    = "struct sockaddr;\n";
    c_fix     = format;
    c_fix_arg = "struct sockaddr;\n%0";
    test_text = "extern AUTH* authdes_create( struct sockaddr* );";
};


/*
 *  Apply fix this to all OSs since this problem seems to effect
 *  more than just SunOS.
 */
fix = {
    hackname = sun_auth_proto;
    files    = rpc/auth.h;
    files    = rpc/clnt.h;
    files    = rpc/svc.h;
    files    = rpc/xdr.h;
    bypass   = "__cplusplus";
    /*
     *  Select those files containing '(*name)()'.
     */
    select    = '\(\*[a-z][a-z_]*\)\(\)';

    c_fix     = format;
    c_fix_arg = "#ifdef __cplusplus\n%1(...);%2\n"
                "#else\n%1();%2\n#endif";
    c_fix_arg = '(.*\(\*[a-z][a-z_]*\))\(\);(.*)';

    test_text =
    "struct auth_t {\n"
    "    int (*name)(); /* C++ bad */\n"
    "};";
};


/*
 *  Fix bogus #ifdef on SunOS 4.1.
 */
fix = {
    hackname  = sun_bogus_ifdef;
    files     = "hsfs/hsfs_spec.h";
    files     = "hsfs/iso_spec.h";
    select    = '#ifdef(.*\|\|.*)';
    c_fix     = format;
    c_fix_arg = "#if%1";

    test_text = "#ifdef  __i386__ || __vax__ || __sun4c__";
};


/*
 *  Fix the CAT macro in SunOS memvar.h.
 */
fix = {
    hackname  = sun_catmacro;
    files     = pixrect/memvar.h;
    select    = "^#define[ \t]+CAT\\(a,b\\).*";
    c_fix     = format;

    c_fix_arg =
    "#ifdef __STDC__\n"
    "#  define CAT(a,b) a##b\n"
    "#else\n%0\n#endif";

    test_text =
    "#define CAT(a,b)\ta/**/b";
};


/*
 *  Fix return type of free and {c,m,re}alloc in <malloc.h> on SunOS 4.1.
 *  Also fix return type of {m,re}alloc in <malloc.h> on sysV68
 */
fix = {
    hackname = sun_malloc;
    files    = malloc.h;
    bypass   = "_CLASSIC_ANSI_TYPES";

    sed   = "s/typedef[ \t]char \\*\tmalloc_t/typedef void \\*\tmalloc_t/g";
    sed   = "s/int[ \t][ \t]*free/void\tfree/g";
    sed   = "s/char\\([ \t]*\\*[ \t]*malloc\\)/void\\1/g";
    sed   = "s/char\\([ \t]*\\*[ \t]*realloc\\)/void\\1/g";
    sed   = "s/char\\([ \t]*\\*[ \t]*calloc\\)/void\\1/g";

    test_text =
    "typedef char *\tmalloc_t;\n"
    "int \tfree();\n"
    "char*\tmalloc();\n"
    "char*\tcalloc();\n"
    "char*\trealloc();";
};


/*
 *  Check for yet more missing ';' in struct (in SunOS 4.0.x)
 */
fix = {
    hackname = sun_rusers_semi;
    files    = rpcsvc/rusers.h;
    select   = "_cnt$";
    sed      = "/^struct/,/^};/s/_cnt$/_cnt;/";
    test_text = "struct mumble\n  int _cnt\n};";
};


/*
 *  signal.h on SunOS defines signal using (),
 *  which causes trouble when compiling with g++ -pedantic.
 */
fix = {
    hackname = sun_signal;
    files    = sys/signal.h;
    files    = signal.h;
    select   = "^void\t" '\(\*signal\(\)\)\(\);.*';

    c_fix     = format;
    c_fix_arg =
          "#ifdef __cplusplus\n"
          "void\t(*signal(...))(...);\n"
          "#else\n%0\n#endif";

    test_text = "void\t(*signal())();";
};


/*
 *  Correct the return type for strlen in strings.h in SunOS 4.
 */
fix = {
    hackname = sunos_strlen;
    files    = strings.h;
    select   = "int[ \t]*strlen\\(\\);(.*)";
    c_fix     = format;
    c_fix_arg = "__SIZE_TYPE__ strlen();%1";
    test_text = " int\tstrlen(); /* string length */";
};


/*
 *  Disable apparent native compiler optimization cruft in SVR4.2 <string.h>
 *  that is visible to any ANSI compiler using this include.  Simply
 *  delete the lines that #define some string functions to internal forms.
 */
fix = {
    hackname = svr4_disable_opt;
    files    = string.h;
    select   = '#define.*__std_hdr_';
    sed      = '/#define.*__std_hdr_/d';
    test_text = "#define strlen __std_hdr_strlen\n";
};


/*
 *   Fix broken decl of getcwd present on some svr4 systems.
 */
fix = {
    hackname = svr4_getcwd;
    files    = stdlib.h;
    files    = unistd.h;
    files    = prototypes.h;
    select   = 'getcwd\(char \*, int\)';

    c_fix     = format;
    c_fix_arg = "getcwd(char *, size_t)";

    test_text = "extern char* getcwd(char *, int);";
};


/*
 *   Fix broken decl of profil present on some svr4 systems.
 */
fix = {
    hackname = svr4_profil;
    files    = stdlib.h;
    files    = unistd.h;

    select    =
    'profil\(unsigned short \*, unsigned int, unsigned int, unsigned int\)';
    /* The fix is wrong on IRIX 5/6 and creates a conflict with another
       prototype in <sys/profil.h>.  */
    bypass    = 'Silicon Graphics';
    c_fix     = format;
    c_fix_arg = 'profil(unsigned short *, size_t, int, unsigned int)';

    test_text =
    'profil(unsigned short *, unsigned int, unsigned int, unsigned int);';
};


/*
 * Correct types for signal handler constants like SIG_DFL; they might be
 * void (*) (), and should be void (*) (int).  C++ doesn't like the
 * old style.
 */
fix = {
    hackname = svr4_sighandler_type;
    files = sys/signal.h;
    select = 'void *\(\*\)\(\)';
    c_fix = format;
    c_fix_arg = "void (*)(int)";
    test_text = "#define SIG_DFL (void(*)())0\n"
                "#define SIG_IGN (void (*)())0\n";
};


/*
 *  Some SysV r4 systems, including Sequent's DYNIX/ptx, use the local
 *  function 'getrnge' in <regexp.h> before they declare it.  For these
 *  systems add a 'static int' declaration of 'getrnge' into <regexp.h>
 *  early on.
 *
 *  'getrnge' traditionally manipulates a file-scope global called 'size',
 *  so put the declaration right after the declaration of 'size'.
 *
 *  Don't do this if there is already a `static void getrnge' declaration
 *  present, since this would cause a redeclaration error.  Solaris 2.x has
 *  such a declaration.
 */
fix = {
    hackname  = svr4_undeclared_getrnge;
    files     = regexp.h;
    select    = "getrnge";
    bypass    = "static void getrnge";
    c_fix     = format;
    c_fix_arg = "%0\n"
                "static int getrnge ();";
    c_fix_arg = "^static int[ \t]+size;";
    test_text = "static int size;\n"
                "/* stuff which calls getrnge() */\n"
                "static getrnge()\n"
                "{}";
};


/*
 *  Fix return value of mem{ccpy,chr,cpy,set} and str{len,spn,cspn}
 *  in string.h on sysV68
 *  Correct the return type for strlen in string.h on Lynx.
 *  Correct the argument type for ffs in string.h on Alpha OSF/1 V2.0.
 *  Add missing const for strdup on OSF/1 V3.0.
 *  On sysV88 layout is slightly different.
 */
fix = {
    hackname = sysv68_string;
    files    = testing.h;
    files    = string.h;
    bypass   = "_CLASSIC_ANSI_TYPES";

    sed = "s/extern[ \t]*int[ \t]*strlen();/extern unsigned int strlen();/";
    sed = "s/extern[ \t]*int[ \t]*ffs[ \t]*(long);/extern int ffs(int);/";
    sed = "s/strdup(char \\*s1);/strdup(const char *s1);/";

    sed = "/^extern char$/N";
    sed = "s/^extern char\\(\\n\t\\*memccpy(),\\)$/extern void\\1/";

    sed = "/^extern int$/N";
    sed = "s/^extern int\\(\\n\tstrlen(),\\)/extern size_t\\1/";

    sed = "/^\tstrncmp(),$/N";
    sed = 's/^\(' "\t" 'strncmp()\),\n\(' "\t" 'strlen(),\)$/'
            '\1;' "\\\nextern unsigned int\\\n\\2/";

    test_text =
    "extern int strlen();\n"

    "extern int ffs(long);\n"

    "extern char\n"
    "\t*memccpy(),\n"
    "\tmemcpy();\n"

    "extern int\n"
    "\tstrcmp(),\n"
    "\tstrncmp(),\n"
    "\tstrlen(),\n"
    "\tstrspn();\n"

    "extern int\n"
    "\tstrlen(), strspn();";
};


/*
 *  Fix return type of calloc, malloc, realloc, bsearch and exit
 */
fix = {
    hackname = sysz_stdlib_for_sun;
    files    = stdlib.h;
    bypass   = "_CLASSIC_ANSI_TYPES";

    select    = "char[ \t]*\\*[ \t]*(calloc|malloc|realloc|bsearch)[ \t]*\\(";
    c_fix     = format;
    c_fix_arg = "void *\t%1(";

    test_text =
    "extern char*\tcalloc(size_t);\n"
    "extern char*\tmalloc(size_t);\n"
    "extern char*\trealloc(void*,size_t);\n"
    "extern char*\tbsearch(void*,size_t,size_t);\n";
};


/*
 * __thread is now a keyword.
 */
fix = {
    hackname  = thread_keyword;
    files     = "pthread.h";
    files     = "bits/sigthread.h";
    select    = "([* ])__thread([,)])";
    c_fix     = format;
    c_fix_arg = "%1__thr%2";

    test_text =
	"extern int pthread_create (pthread_t *__restrict __thread,\n"
	"extern int pthread_kill (pthread_t __thread, int __signo);\n"
	"extern int pthread_cancel (pthread_t __thread);";
};

/*
 *  if the #if says _cplusplus, not the double underscore __cplusplus
 *  that it should be
 */
fix = {
    hackname = tinfo_cplusplus;
    files    = tinfo.h;
    select   = "[ \t]_cplusplus";

    c_fix     = format;
    c_fix_arg = " __cplusplus";
    test_text = "#ifdef _cplusplus\nint bogus;\n#endif";
};


/*
 *  parameters not const on DECstation Ultrix V4.0 and OSF/1.
 */
fix = {
    hackname  = ultrix_const;
    files     = stdio.h;
    select    = 'perror\( char \*';

    c_fix     = format;
    c_fix_arg = "%1 const %3 *__";
    c_fix_arg = "([ \t*](perror|fputs|fwrite|scanf|fscanf)\\(.*)"
                "[ \t]+(char|void) \\*__";

    test_text =
    "extern void perror( char *__s );\n"
    "extern int fputs( char *__s, FILE *);\n"
    "extern size_t fwrite( void *__ptr, size_t, size_t, FILE *);\n"
    "extern int fscanf( FILE *__stream, char *__format, ...);\n"
    "extern int scanf( char *__format, ...);\n";
};


/*
 *  parameters not const on DECstation Ultrix V4.0 and OSF/1.
 */
fix = {
    hackname  = ultrix_const2;
    files     = stdio.h;

    select    = '\*fopen\( char \*';
    c_fix     = format;
    c_fix_arg = "%1( const char *%3, const char *";
    c_fix_arg = "([ \t*](fopen|sscanf|popen|tempnam))\\("
               "[ \t]*char[ \t]*\\*([^,]*),"
               "[ \t]*char[ \t]*\\*[ \t]*";

    test_text =
    "extern FILE *fopen( char *__filename, char *__type );\n"
    "extern int sscanf( char *__s, char *__format, ...);\n"
    "extern FILE *popen(char *, char *);\n"
    "extern char *tempnam(char*,char*);\n";
};


/*
 *  Fix definitions of macros used by va-i960.h in VxWorks header file.
 */
fix = {
    hackname  = va_i960_macro;
    files     = arch/i960/archI960.h;
    select    = "__(vsiz|vali|vpad|alignof__)";

    c_fix     = format;
    c_fix_arg = "__vx%1";

    test_text =
    "extern int __vsiz vsiz;\n"
    "extern int __vali vali;\n"
    "extern int __vpad vpad;\n"
    "#define __alignof__(x) ...";
};


/*
 *  AIX and Interix headers define NULL to be cast to a void pointer,
 *  which is illegal in ANSI C++.
 */
fix = {
    hackname  = void_null;
    files     = curses.h;
    files     = dbm.h;
    files     = locale.h;
    files     = stdio.h;
    files     = stdlib.h;
    files     = string.h;
    files     = time.h;
    files     = unistd.h;
    files     = sys/dir.h;
    files     = sys/param.h;
    files     = sys/types.h;
    /* avoid changing C++ friendly NULL */
    bypass    = __cplusplus;
    select    = "^#[ \t]*define[ \t]+NULL[ \t]+\\(\\(void[ \t]*\\*\\)0\\)";
    c_fix     = format;
    c_fix_arg = "#define NULL 0";
    test_text = "# define\tNULL \t((void *)0)  /* typed NULL */";
};


/*
 *  Make VxWorks header which is almost gcc ready fully gcc ready.
 */
fix = {
    hackname = vxworks_gcc_problem;
    files    = types/vxTypesBase.h;
    select   = "__GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__";

    sed = "s/#ifdef __GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__/"
          "#if 1/";

    sed = "/[ \t]size_t/i\\\n"
        "#ifndef _GCC_SIZE_T\\\n"
        "#define _GCC_SIZE_T\n";

    sed = "/[ \t]size_t/a\\\n"
        "#endif\n";

    sed = "/[ \t]ptrdiff_t/i\\\n"
        "#ifndef _GCC_PTRDIFF_T\\\n"
        "#define _GCC_PTRDIFF_T\n";

    sed = "/[ \t]ptrdiff_t/a\\\n"
        "#endif\n";

    sed = "/[ \t]wchar_t/i\\\n"
        "#ifndef _GCC_WCHAR_T\\\n"
        "#define _GCC_WCHAR_T\n";

    sed = "/[ \t]wchar_t/a\\\n"
        "#endif\n";

    test_text =
    "#ifdef __GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__\n"
    "typedef unsigned int size_t;\n"
    "typedef long ptrdiff_t;\n"
    "typedef unsigned short wchar_t;\n"
    "#endif /* __GNUC_TYPEOF_FEATURE_BROKEN_USE_DEFAULT_UNTIL_FIXED__ */\n";
};


/*
 *  Fix VxWorks <time.h> to not require including <vxTypes.h>.
 */
fix = {
    hackname  = vxworks_needs_vxtypes;
    files     = time.h;
    select    = "uint_t([ \t]+_clocks_per_sec)";
    c_fix     = format;
    c_fix_arg = "unsigned int%1";
    test_text = "uint_t\t_clocks_per_sec;";
};


/*
 *  Fix VxWorks <sys/stat.h> to not require including <vxWorks.h>.
 */
fix = {
    hackname = vxworks_needs_vxworks;
    files    = sys/stat.h;
    test     = " -r types/vxTypesOld.h";
    test     = " -n \"`egrep '#include' $file`\"";
    test     = " -n \"`egrep ULONG $file`\"";
    select   = "#[ \t]define[ \t]+__INCstath";

    sed = "/#[ \t]define[ \t][ \t]*__INCstath/a\\\n"
          "#include <types/vxTypesOld.h>\n";

    test_text = "`touch types/vxTypesOld.h`"
    "#include </dev/null> /* ULONG */\n"
    "# define\t__INCstath <sys/stat.h>";
};


/*
 *  Another bad dependency in VxWorks 5.2 <time.h>.
 */
fix = {
    hackname = vxworks_time;
    files    = time.h;
    test     = " -r vxWorks.h";

    select    = "#[ \t]*define[ \t]+VOIDFUNCPTR[ \t].*";
    c_fix     = format;

    c_fix_arg =
    "#ifndef __gcc_VOIDFUNCPTR_defined\n"
    "#ifdef __cplusplus\n"
    "typedef void (*__gcc_VOIDFUNCPTR) (...);\n"
    "#else\n"
    "typedef void (*__gcc_VOIDFUNCPTR) ();\n"
    "#endif\n"
    "#define __gcc_VOIDFUNCPTR_defined\n"
    "#endif\n"
    "#define VOIDFUNCPTR __gcc_VOIDFUNCPTR";

    test_text = "`touch vxWorks.h`"
                "#define VOIDFUNCPTR (void(*)())";
};


/*
 *  There are several name conflicts with C++ reserved words in X11 header
 *  files.  These are fixed in some versions, so don't do the fixes if
 *  we find __cplusplus in the file.  These were found on the RS/6000.
 */
fix = {
    hackname  = x11_class;
    files     = X11/ShellP.h;
    bypass    = __cplusplus;
    select    = "^([ \t]*char \\*)class;(.*)";
    c_fix     = format;
    c_fix_arg = "#ifdef __cplusplus\n%1c_class;%2\n"
                "#else\n%1class;%2\n#endif";
    test_text =
    "struct {\n"
    "   char *class;\n"
    "} mumble;\n";
};


/*
 *  class in Xm/BaseClassI.h
 */
fix = {
    hackname = x11_class_usage;
    files    = Xm/BaseClassI.h;
    bypass   = "__cplusplus";

    select    = " class\\)";
    c_fix     = format;
    c_fix_arg = " c_class)";

    test_text = "extern mumble (int  class);\n";
};


/*
 *  new in Xm/Traversal.h
 */
fix = {
    hackname = x11_new;
    files    = Xm/Traversal.h;
    bypass   = __cplusplus;

    sed      = "/Widget\told, new;/i\\\n"
                   "#ifdef __cplusplus\\\n"
                   "\tWidget\told, c_new;\\\n"
                   "#else\n";

    sed      = "/Widget\told, new;/a\\\n"
                   "#endif\n";

    sed      = "s/Widget new,/Widget c_new,/g";
    test_text =
    "struct wedge {\n"
    "   Widget\told, new; /* fixinc check FAILS ON BSD */\n"
    "};\nextern Wedged( Widget new, Widget old );";
};


/*
 *  Incorrect sprintf declaration in X11/Xmu.h
 */
fix = {
    hackname = x11_sprintf;
    files    = X11/Xmu.h;
    files    = X11/Xmu/Xmu.h;
    select   = "^extern char \\*\tsprintf\\(\\);$";

    c_fix     = format;
    c_fix_arg = "#ifndef __STDC__\n%0\n#endif /* !defined __STDC__ */";

    test_text = "extern char *\tsprintf();";
};

/*EOF*/
