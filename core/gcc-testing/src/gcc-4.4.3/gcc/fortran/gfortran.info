This is doc/gfortran.info, produced by makeinfo version 4.13 from
/d/gcc-4.4.3/gcc-4.4.3/gcc/fortran/gfortran.texi.

Copyright (C) 1999-2008 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a) (see below), and with the Back-Cover Texts being (b) (see
below).  A copy of the license is included in the section entitled "GNU
Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* gfortran: (gfortran).                  The GNU Fortran Compiler.
END-INFO-DIR-ENTRY
   This file documents the use and the internals of the GNU Fortran
compiler, (`gfortran').

   Published by the Free Software Foundation 51 Franklin Street, Fifth
Floor Boston, MA 02110-1301 USA

   Copyright (C) 1999-2008 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "Funding Free Software", the Front-Cover Texts
being (a) (see below), and with the Back-Cover Texts being (b) (see
below).  A copy of the license is included in the section entitled "GNU
Free Documentation License".

   (a) The FSF's Front-Cover Text is:

   A GNU Manual

   (b) The FSF's Back-Cover Text is:

   You have freedom to copy and modify this GNU Manual, like GNU
software.  Copies published by the Free Software Foundation raise
funds for GNU development.


File: gfortran.info,  Node: Top,  Next: Introduction,  Up: (dir)

Introduction
************

This manual documents the use of `gfortran', the GNU Fortran compiler.
You can find in this manual how to invoke `gfortran', as well as its
features and incompatibilities.

* Menu:

* Introduction::

Part I: Invoking GNU Fortran
* Invoking GNU Fortran:: Command options supported by `gfortran'.
* Runtime::              Influencing runtime behavior with environment variables.

Part II: Language Reference
* Fortran 2003 and 2008 status::  Fortran 2003 and 2008 features supported by GNU Fortran.
* Compiler Characteristics::      KIND type parameters supported.
* Extensions::           Language extensions implemented by GNU Fortran.
* Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.
* Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.

* Contributing::         How you can help.
* Copying::              GNU General Public License says
                         how you can copy and share GNU Fortran.
* GNU Free Documentation License::
                         How you can copy and share this manual.
* Funding::              How to help assure continued work for free software.
* Option Index::         Index of command line options
* Keyword Index::        Index of concepts


File: gfortran.info,  Node: Introduction,  Next: Invoking GNU Fortran,  Prev: Top,  Up: Top

1 Introduction
**************

The GNU Fortran compiler front end was designed initially as a free
replacement for, or alternative to, the unix `f95' command; `gfortran'
is the command you'll use to invoke the compiler.

* Menu:

* About GNU Fortran::    What you should know about the GNU Fortran compiler.
* GNU Fortran and GCC::  You can compile Fortran, C, or other programs.
* Preprocessing and conditional compilation:: The Fortran preprocessor
* GNU Fortran and G77::  Why we chose to start from scratch.
* Project Status::       Status of GNU Fortran, roadmap, proposed extensions.
* Standards::            Standards supported by GNU Fortran.


File: gfortran.info,  Node: About GNU Fortran,  Next: GNU Fortran and GCC,  Up: Introduction

1.1 About GNU Fortran
=====================

The GNU Fortran compiler is still in an early state of development.  It
can generate code for most constructs and expressions, but much work
remains to be done.

   When the GNU Fortran compiler is finished, it will do everything you
expect from any decent compiler:

   * Read a user's program, stored in a file and containing
     instructions written in Fortran 77, Fortran 90, Fortran 95,
     Fortran 2003 or Fortran 2008.  This file contains "source code".

   * Translate the user's program into instructions a computer can
     carry out more quickly than it takes to translate the instructions
     in the first place.  The result after compilation of a program is
     "machine code", code designed to be efficiently translated and
     processed by a machine such as your computer.  Humans usually
     aren't as good writing machine code as they are at writing Fortran
     (or C++, Ada, or Java), because it is easy to make tiny mistakes
     writing machine code.

   * Provide the user with information about the reasons why the
     compiler is unable to create a binary from the source code.
     Usually this will be the case if the source code is flawed.  The
     Fortran 90 standard requires that the compiler can point out
     mistakes to the user.  An incorrect usage of the language causes
     an "error message".

     The compiler will also attempt to diagnose cases where the user's
     program contains a correct usage of the language, but instructs
     the computer to do something questionable.  This kind of
     diagnostics message is called a "warning message".

   * Provide optional information about the translation passes from the
     source code to machine code.  This can help a user of the compiler
     to find the cause of certain bugs which may not be obvious in the
     source code, but may be more easily found at a lower level
     compiler output.  It also helps developers to find bugs in the
     compiler itself.

   * Provide information in the generated machine code that can make it
     easier to find bugs in the program (using a debugging tool, called
     a "debugger", such as the GNU Debugger `gdb').

   * Locate and gather machine code already generated to perform
     actions requested by statements in the user's program.  This
     machine code is organized into "modules" and is located and
     "linked" to the user program.

   The GNU Fortran compiler consists of several components:

   * A version of the `gcc' command (which also might be installed as
     the system's `cc' command) that also understands and accepts
     Fortran source code.  The `gcc' command is the "driver" program for
     all the languages in the GNU Compiler Collection (GCC); With `gcc',
     you can compile the source code of any language for which a front
     end is available in GCC.

   * The `gfortran' command itself, which also might be installed as the
     system's `f95' command.  `gfortran' is just another driver program,
     but specifically for the Fortran compiler only.  The difference
     with `gcc' is that `gfortran' will automatically link the correct
     libraries to your program.

   * A collection of run-time libraries.  These libraries contain the
     machine code needed to support capabilities of the Fortran
     language that are not directly provided by the machine code
     generated by the `gfortran' compilation phase, such as intrinsic
     functions and subroutines, and routines for interaction with files
     and the operating system.

   * The Fortran compiler itself, (`f951').  This is the GNU Fortran
     parser and code generator, linked to and interfaced with the GCC
     backend library.  `f951' "translates" the source code to assembler
     code.  You would typically not use this program directly; instead,
     the `gcc' or `gfortran' driver programs will call it for you.


File: gfortran.info,  Node: GNU Fortran and GCC,  Next: Preprocessing and conditional compilation,  Prev: About GNU Fortran,  Up: Introduction

1.2 GNU Fortran and GCC
=======================

GNU Fortran is a part of GCC, the "GNU Compiler Collection".  GCC
consists of a collection of front ends for various languages, which
translate the source code into a language-independent form called
"GENERIC".  This is then processed by a common middle end which
provides optimization, and then passed to one of a collection of back
ends which generate code for different computer architectures and
operating systems.

   Functionally, this is implemented with a driver program (`gcc')
which provides the command-line interface for the compiler.  It calls
the relevant compiler front-end program (e.g., `f951' for Fortran) for
each file in the source code, and then calls the assembler and linker
as appropriate to produce the compiled output. In a copy of GCC which
has been compiled with Fortran language support enabled, `gcc' will
recognize files with `.f', `.for', `.ftn', `.f90', `.f95', `.f03' and
`.f08' extensions as Fortran source code, and compile it accordingly. A
`gfortran' driver program is also provided, which is identical to `gcc'
except that it automatically links the Fortran runtime libraries into
the compiled program.

   Source files with `.f', `.for', `.fpp', `.ftn', `.F', `.FOR',
`.FPP', and `.FTN' extensions are treated as fixed form.  Source files
with `.f90', `.f95', `.f03', `.f08', `.F90', `.F95', `.F03' and `.F08'
extensions are treated as free form.  The capitalized versions of
either form are run through preprocessing. Source files with the lower
case `.fpp' extension are also run through preprocessing.

   This manual specifically documents the Fortran front end, which
handles the programming language's syntax and semantics.  The aspects
of GCC which relate to the optimization passes and the back-end code
generation are documented in the GCC manual; see *note Introduction:
(gcc)Top.  The two manuals together provide a complete reference for
the GNU Fortran compiler.


File: gfortran.info,  Node: Preprocessing and conditional compilation,  Next: GNU Fortran and G77,  Prev: GNU Fortran and GCC,  Up: Introduction

1.3 Preprocessing and conditional compilation
=============================================

Many Fortran compilers including GNU Fortran allow passing the source
code through a C preprocessor (CPP; sometimes also called the Fortran
preprocessor, FPP) to allow for conditional compilation. In the case of
GNU Fortran, this is the GNU C Preprocessor in the traditional mode. On
systems with case-preserving file names, the preprocessor is
automatically invoked if the filename extension is `.F', `.FOR',
`.FTN', `.fpp', `.FPP', `.F90', `.F95', `.F03' or `.F08'. To manually
invoke the preprocessor on any file, use `-cpp', to disable
preprocessing on files where the preprocessor is run automatically, use
`-nocpp'.

   If a preprocessed file includes another file with the Fortran
`INCLUDE' statement, the included file is not preprocessed. To
preprocess included files, use the equivalent preprocessor statement
`#include'.

   If GNU Fortran invokes the preprocessor, `__GFORTRAN__' is defined
and `__GNUC__', `__GNUC_MINOR__' and `__GNUC_PATCHLEVEL__' can be used
to determine the version of the compiler. See *note Overview: (cpp)Top.
for details.

   While CPP is the de-facto standard for preprocessing Fortran code,
Part 3 of the Fortran 95 standard (ISO/IEC 1539-3:1998) defines
Conditional Compilation, which is not widely used and not directly
supported by the GNU Fortran compiler. You can use the program coco to
preprocess such files (`http://users.erols.com/dnagle/coco.html').


File: gfortran.info,  Node: GNU Fortran and G77,  Next: Project Status,  Prev: Preprocessing and conditional compilation,  Up: Introduction

1.4 GNU Fortran and G77
=======================

The GNU Fortran compiler is the successor to `g77', the Fortran 77
front end included in GCC prior to version 4.  It is an entirely new
program that has been designed to provide Fortran 95 support and
extensibility for future Fortran language standards, as well as
providing backwards compatibility for Fortran 77 and nearly all of the
GNU language extensions supported by `g77'.


File: gfortran.info,  Node: Project Status,  Next: Standards,  Prev: GNU Fortran and G77,  Up: Introduction

1.5 Project Status
==================

     As soon as `gfortran' can parse all of the statements correctly,
     it will be in the "larva" state.  When we generate code, the
     "puppa" state.  When `gfortran' is done, we'll see if it will be a
     beautiful butterfly, or just a big bug....

     -Andy Vaught, April 2000

   The start of the GNU Fortran 95 project was announced on the GCC
homepage in March 18, 2000 (even though Andy had already been working
on it for a while, of course).

   The GNU Fortran compiler is able to compile nearly all
standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
including a number of standard and non-standard extensions, and can be
used on real-world programs.  In particular, the supported extensions
include OpenMP, Cray-style pointers, and several Fortran 2003 and
Fortran 2008 features such as enumeration, stream I/O, and some of the
enhancements to allocatable array support from TR 15581.  However, it is
still under development and has a few remaining rough edges.

   At present, the GNU Fortran compiler passes the NIST Fortran 77 Test
Suite (http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html), and
produces acceptable results on the LAPACK Test Suite
(http://www.netlib.org/lapack/faq.html#1.21).  It also provides
respectable performance on the Polyhedron Fortran compiler benchmarks
(http://www.polyhedron.com/pb05.html) and the Livermore Fortran Kernels
test
(http://www.llnl.gov/asci_benchmarks/asci/limited/lfk/README.html).  It
has been used to compile a number of large real-world programs,
including the HIRLAM weather-forecasting code
(http://mysite.verizon.net/serveall/moene.pdf) and the Tonto quantum
chemistry package (http://www.theochem.uwa.edu.au/tonto/); see
`http://gcc.gnu.org/wiki/GfortranApps' for an extended list.

   Among other things, the GNU Fortran compiler is intended as a
replacement for G77.  At this point, nearly all programs that could be
compiled with G77 can be compiled with GNU Fortran, although there are
a few minor known regressions.

   The primary work remaining to be done on GNU Fortran falls into three
categories: bug fixing (primarily regarding the treatment of invalid
code and providing useful error messages), improving the compiler
optimizations and the performance of compiled code, and extending the
compiler to support future standards--in particular, Fortran 2003.


File: gfortran.info,  Node: Standards,  Prev: Project Status,  Up: Introduction

1.6 Standards
=============

The GNU Fortran compiler implements ISO/IEC 1539:1997 (Fortran 95).  As
such, it can also compile essentially all standard-compliant Fortran 90
and Fortran 77 programs.   It also supports the ISO/IEC TR-15581
enhancements to allocatable arrays, and the OpenMP Application Program
Interface v2.5 (http://www.openmp.org/drupal/mp-documents/spec25.pdf)
specification.

   In the future, the GNU Fortran compiler will also support ISO/IEC
1539-1:2004 (Fortran 2003) and future Fortran standards. Partial support
of that standard is already provided; the current status of Fortran 2003
support is reported in the *note Fortran 2003 status:: section of the
documentation.

   The next version of the Fortran standard after Fortran 2003 is
currently being developed and the GNU Fortran compiler supports some of
its new features. This support is based on the latest draft of the
standard (available from `http://www.nag.co.uk/sc22wg5/') and no
guarantee of future compatibility is made, as the final standard might
differ from the draft. For more information, see the *note Fortran 2008
status:: section.


File: gfortran.info,  Node: Invoking GNU Fortran,  Next: Runtime,  Prev: Introduction,  Up: Top

2 GNU Fortran Command Options
*****************************

The `gfortran' command supports all the options supported by the `gcc'
command.  Only options specific to GNU Fortran are documented here.

   *Note GCC Command Options: (gcc)Invoking GCC, for information on the
non-Fortran-specific aspects of the `gcc' command (and, therefore, the
`gfortran' command).

   All GCC and GNU Fortran options are accepted both by `gfortran' and
by `gcc' (as well as any other drivers built at the same time, such as
`g++'), since adding GNU Fortran to the GCC distribution enables
acceptance of GNU Fortran options by all of the relevant drivers.

   In some cases, options have positive and negative forms; the
negative form of `-ffoo' would be `-fno-foo'.  This manual documents
only one of these two forms, whichever one is not the default.

* Menu:

* Option Summary::      Brief list of all `gfortran' options,
                        without explanations.
* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Preprocessing Options::  Enable and customize preprocessing.
* Error and Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Link Options ::       Influencing the linking step
* Runtime Options::     Influencing runtime behavior
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.
* Environment Variables:: Environment variables that affect `gfortran'.


File: gfortran.info,  Node: Option Summary,  Next: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.1 Option summary
==================

Here is a summary of all the options specific to GNU Fortran, grouped
by type.  Explanations are in the following sections.

_Fortran Language Options_
     *Note Options controlling Fortran dialect: Fortran Dialect Options.
          -fall-intrinsics  -ffree-form  -fno-fixed-form
          -fdollar-ok  -fimplicit-none  -fmax-identifier-length
          -std=STD -fd-lines-as-code  -fd-lines-as-comments
          -ffixed-line-length-N  -ffixed-line-length-none
          -ffree-line-length-N  -ffree-line-length-none
          -fdefault-double-8  -fdefault-integer-8  -fdefault-real-8
          -fcray-pointer  -fopenmp  -fno-range-check -fbackslash -fmodule-private

_Preprocessing Options_
     *Note Enable and customize preprocessing: Preprocessing Options.
          -cpp -dD -dI -dM -dN -dU -fworking-directory
          -imultilib DIR -iprefix FILE -isysroot DIR
          -iquote -isystem DIR -nocpp -nostdinc -undef
          -AQUESTION=ANSWER -A-QUESTION[=ANSWER]
          -C -CC -DMACRO[=DEFN] -UMACRO -H -P

_Error and Warning Options_
     *Note Options to request or suppress errors and warnings: Error
     and Warning Options.
          -fmax-errors=N
          -fsyntax-only  -pedantic  -pedantic-errors
          -Wall  -Waliasing  -Wampersand  -Warray-bounds -Wcharacter-truncation
          -Wconversion -Wimplicit-interface  -Wline-truncation  -Wintrinsics-std
          -Wsurprising -Wno-tabs  -Wunderflow -Wunused-parameter -Wintrinsics-shadow
          -Wno-align-commons

_Debugging Options_
     *Note Options for debugging your program or GNU Fortran: Debugging
     Options.
          -fdump-parse-tree  -ffpe-trap=LIST
          -fdump-core -fbacktrace

_Directory Options_
     *Note Options for directory search: Directory Options.
          -IDIR  -JDIR  -MDIR
          -fintrinsic-modules-path DIR

_Link Options_
     *Note Options for influencing the linking step: Link Options.
          -static-libgfortran

_Runtime Options_
     *Note Options for influencing runtime behavior: Runtime Options.
          -fconvert=CONVERSION  -fno-range-check
          -frecord-marker=LENGTH   -fmax-subrecord-length=LENGTH
          -fsign-zero

_Code Generation Options_
     *Note Options for code generation conventions: Code Gen Options.
          -fno-automatic  -ff2c  -fno-underscoring
          -fsecond-underscore
          -fbounds-check -fcheck-array-temporaries  -fmax-array-constructor =N
          -fmax-stack-var-size=N
          -fpack-derived  -frepack-arrays  -fshort-enums  -fexternal-blas
          -fblas-matmul-limit=N -frecursive -finit-local-zero
          -finit-integer=N -finit-real=<ZERO|INF|-INF|NAN>
          -finit-logical=<TRUE|FALSE> -finit-character=N -fno-align-commons


* Menu:

* Fortran Dialect Options::  Controlling the variant of Fortran language
                             compiled.
* Preprocessing Options::  Enable and customize preprocessing.
* Error and Warning Options::     How picky should the compiler be?
* Debugging Options::   Symbol tables, measurements, and debugging dumps.
* Directory Options::   Where to find module files
* Link Options ::       Influencing the linking step
* Runtime Options::     Influencing runtime behavior
* Code Gen Options::    Specifying conventions for function calls, data layout
                        and register usage.


File: gfortran.info,  Node: Fortran Dialect Options,  Next: Preprocessing Options,  Prev: Option Summary,  Up: Invoking GNU Fortran

2.2 Options controlling Fortran dialect
=======================================

The following options control the details of the Fortran dialect
accepted by the compiler:

`-ffree-form'

`-ffixed-form'
     Specify the layout used by the source file.  The free form layout
     was introduced in Fortran 90.  Fixed form was traditionally used in
     older Fortran programs.  When neither option is specified, the
     source form is determined by the file extension.

`-fall-intrinsics'
     This option causes all intrinsic procedures (including the
     GNU-specific extensions) to be accepted.  This can be useful with
     `-std=f95' to force standard-compliance but get access to the full
     range of intrinsics available with `gfortran'.  As a consequence,
     `-Wintrinsics-std' will be ignored and no user-defined procedure
     with the same name as any intrinsic will be called except when it
     is explicitly declared `EXTERNAL'.

`-fd-lines-as-code'

`-fd-lines-as-comments'
     Enable special treatment for lines beginning with `d' or `D' in
     fixed form sources.  If the `-fd-lines-as-code' option is given
     they are treated as if the first column contained a blank.  If the
     `-fd-lines-as-comments' option is given, they are treated as
     comment lines.

`-fdefault-double-8'
     Set the `DOUBLE PRECISION' type to an 8 byte wide type.  If
     `-fdefault-real-8' is given, `DOUBLE PRECISION' would instead be
     promoted to 16 bytes if possible, and `-fdefault-double-8' can be
     used to prevent this.  The kind of real constants like `1.d0' will
     not be changed by `-fdefault-real-8' though, so also
     `-fdefault-double-8' does not affect it.

`-fdefault-integer-8'
     Set the default integer and logical types to an 8 byte wide type.
     Do nothing if this is already the default.  This option also
     affects the kind of integer constants like `42'.

`-fdefault-real-8'
     Set the default real type to an 8 byte wide type.  Do nothing if
     this is already the default.  This option also affects the kind of
     non-double real constants like `1.0', and does promote the default
     width of `DOUBLE PRECISION' to 16 bytes if possible, unless
     `-fdefault-double-8' is given, too.

`-fdollar-ok'
     Allow `$' as a valid character in a symbol name.

`-fbackslash'
     Change the interpretation of backslashes in string literals from a
     single backslash character to "C-style" escape characters. The
     following combinations are expanded `\a', `\b', `\f', `\n', `\r',
     `\t', `\v', `\\', and `\0' to the ASCII characters alert,
     backspace, form feed, newline, carriage return, horizontal tab,
     vertical tab, backslash, and NUL, respectively.  Additionally,
     `\x'NN, `\u'NNNN and `\U'NNNNNNNN (where each N is a hexadecimal
     digit) are translated into the Unicode characters corresponding to
     the specified code points. All other combinations of a character
     preceded by \ are unexpanded.

`-fmodule-private'
     Set the default accessibility of module entities to `PRIVATE'.
     Use-associated entities will not be accessible unless they are
     explicitly declared as `PUBLIC'.

`-ffixed-line-length-N'
     Set column after which characters are ignored in typical fixed-form
     lines in the source file, and through which spaces are assumed (as
     if padded to that length) after the ends of short fixed-form lines.

     Popular values for N include 72 (the standard and the default), 80
     (card image), and 132 (corresponding to "extended-source" options
     in some popular compilers).  N may also be `none', meaning that
     the entire line is meaningful and that continued character
     constants never have implicit spaces appended to them to fill out
     the line.  `-ffixed-line-length-0' means the same thing as
     `-ffixed-line-length-none'.

`-ffree-line-length-N'
     Set column after which characters are ignored in typical free-form
     lines in the source file. The default value is 132.  N may be
     `none', meaning that the entire line is meaningful.
     `-ffree-line-length-0' means the same thing as
     `-ffree-line-length-none'.

`-fmax-identifier-length=N'
     Specify the maximum allowed identifier length. Typical values are
     31 (Fortran 95) and 63 (Fortran 2003 and Fortran 2008).

`-fimplicit-none'
     Specify that no implicit typing is allowed, unless overridden by
     explicit `IMPLICIT' statements.  This is the equivalent of adding
     `implicit none' to the start of every procedure.

`-fcray-pointer'
     Enable the Cray pointer extension, which provides C-like pointer
     functionality.

`-fopenmp'
     Enable the OpenMP extensions.  This includes OpenMP `!$omp'
     directives in free form and `c$omp', `*$omp' and `!$omp'
     directives in fixed form, `!$' conditional compilation sentinels
     in free form and `c$', `*$' and `!$' sentinels in fixed form, and
     when linking arranges for the OpenMP runtime library to be linked
     in.  The option `-fopenmp' implies `-frecursive'.

`-fno-range-check'
     Disable range checking on results of simplification of constant
     expressions during compilation.  For example, GNU Fortran will give
     an error at compile time when simplifying `a = 1. / 0'.  With this
     option, no error will be given and `a' will be assigned the value
     `+Infinity'.  If an expression evaluates to a value outside of the
     relevant range of [`-HUGE()':`HUGE()'], then the expression will
     be replaced by `-Inf' or `+Inf' as appropriate.  Similarly, `DATA
     i/Z'FFFFFFFF'/' will result in an integer overflow on most
     systems, but with `-fno-range-check' the value will "wrap around"
     and `i' will be initialized to -1 instead.

`-std=STD'
     Specify the standard to which the program is expected to conform,
     which may be one of `f95', `f2003', `f2008', `gnu', or `legacy'.
     The default value for STD is `gnu', which specifies a superset of
     the Fortran 95 standard that includes all of the extensions
     supported by GNU Fortran, although warnings will be given for
     obsolete extensions not recommended for use in new code.  The
     `legacy' value is equivalent but without the warnings for obsolete
     extensions, and may be useful for old non-standard programs.  The
     `f95', `f2003' and `f2008' values specify strict conformance to
     the Fortran 95, Fortran 2003 and Fortran 2008 standards,
     respectively; errors are given for all extensions beyond the
     relevant language standard, and warnings are given for the Fortran
     77 features that are permitted but obsolescent in later standards.



File: gfortran.info,  Node: Preprocessing Options,  Next: Error and Warning Options,  Prev: Fortran Dialect Options,  Up: Invoking GNU Fortran

2.3 Enable and customize preprocessing
======================================

Preprocessor related options. See section *note Preprocessing and
conditional compilation:: for more detailed information on
preprocessing in `gfortran'.

`-cpp'

`-nocpp'
     Enable preprocessing. The preprocessor is automatically invoked if
     the file extension is `.fpp', `.FPP',  `.F', `.FOR', `.FTN',
     `.F90', `.F95', `.F03' or `.F08'. Use this option to manually
     enable preprocessing of any kind of Fortran file.

     To disable preprocessing of files with any of the above listed
     extensions, use the negative form: `-nocpp'.

     The preprocessor is run in traditional mode, be aware that any
     restrictions of the file-format, e.g. fixed-form line width, apply
     for preprocessed output as well.

`-dM'
     Instead of the normal output, generate a list of `'#define''
     directives for all the macros defined during the execution of the
     preprocessor, including predefined macros. This gives you a way of
     finding out what is predefined in your version of the preprocessor.
     Assuming you have no file `foo.f90', the command
            touch foo.f90; gfortran -cpp -dM foo.f90
     will show all the predefined macros.

`-dD'
     Like `-dM' except in two respects: it does not include the
     predefined macros, and it outputs both the `#define' directives
     and the result of preprocessing. Both kinds of output go to the
     standard output file.

`-dN'
     Like `-dD', but emit only the macro names, not their expansions.

`-dU'
     Like `dD' except that only macros that are expanded, or whose
     definedness is tested in preprocessor directives, are output; the
     output is delayed until the use or test of the macro; and
     `'#undef'' directives are also output for macros tested but
     undefined at the time.

`-dI'
     Output `'#include'' directives in addition to the result of
     preprocessing.

`-fworking-directory'
     Enable generation of linemarkers in the preprocessor output that
     will let the compiler know the current working directory at the
     time of preprocessing. When this option is enabled, the
     preprocessor will emit, after the initial linemarker, a second
     linemarker with the current working directory followed by two
     slashes. GCC will use this directory, when it's present in the
     preprocessed input, as the directory emitted as the current
     working directory in some debugging information formats.  This
     option is implicitly enabled if debugging information is enabled,
     but this can be inhibited with the negated form
     `-fno-working-directory'. If the `-P' flag is present in the
     command line, this option has no effect, since no `#line'
     directives are emitted whatsoever.

`-idirafter DIR'
     Search DIR for include files, but do it after all directories
     specified with `-I' and the standard system directories have been
     exhausted. DIR is treated as a system include directory.  If dir
     begins with `=', then the `=' will be replaced by the sysroot
     prefix; see `--sysroot' and `-isysroot'.

`-imultilib DIR'
     Use DIR as a subdirectory of the directory containing
     target-specific C++ headers.

`-iprefix PREFIX'
     Specify PREFIX as the prefix for subsequent `-iwithprefix'
     options. If the PREFIX represents a directory, you should include
     the final `'/''.

`-isysroot DIR'
     This option is like the `--sysroot' option, but applies only to
     header files. See the `--sysroot' option for more information.

`-iquote DIR'
     Search DIR only for header files requested with `#include "file"';
     they are not searched for `#include <file>', before all directories
     specified by `-I' and before the standard system directories. If
     DIR begins with `=', then the `=' will be replaced by the sysroot
     prefix; see `--sysroot' and `-isysroot'.

`-isystem DIR'
     Search DIR for header files, after all directories specified by
     `-I' but before the standard system directories. Mark it as a
     system directory, so that it gets the same special treatment as is
     applied to the standard system directories. If DIR begins with
     `=', then the `=' will be replaced by the sysroot prefix; see
     `--sysroot' and `-isysroot'.

`-nostdinc'
     Do not search the standard system directories for header files.
     Only the directories you have specified with `-I' options (and the
     directory of the current file, if appropriate) are searched.

`-undef'
     Do not predefine any system-specific or GCC-specific macros.  The
     standard predefined macros remain defined.

`-APREDICATE=ANSWER'
     Make an assertion with the predicate PREDICATE and answer ANSWER.
     This form is preferred to the older form -A predicate(answer),
     which is still supported, because it does not use shell special
     characters.

`-A-PREDICATE=ANSWER'
     Cancel an assertion with the predicate PREDICATE and answer ANSWER.

`-C'
     Do not discard comments. All comments are passed through to the
     output file, except for comments in processed directives, which
     are deleted along with the directive.

     You should be prepared for side effects when using `-C'; it causes
     the preprocessor to treat comments as tokens in their own right.
     For example, comments appearing at the start of what would be a
     directive line have the effect of turning that line into an
     ordinary source line, since the first token on the line is no
     longer a `'#''.

     Warning: this currently handles C-Style comments only. The
     preprocessor does not yet recognize Fortran-style comments.

`-CC'
     Do not discard comments, including during macro expansion. This is
     like `-C', except that comments contained within macros are also
     passed through to the output file where the macro is expanded.

     In addition to the side-effects of the `-C' option, the `-CC'
     option causes all C++-style comments inside a macro to be
     converted to C-style comments. This is to prevent later use of
     that macro from inadvertently commenting out the remainder of the
     source line. The `-CC' option is generally used to support lint
     comments.

     Warning: this currently handles C- and C++-Style comments only. The
     preprocessor does not yet recognize Fortran-style comments.

`-DNAME'
     Predefine name as a macro, with definition `1'.

`-DNAME=DEFINITION'
     The contents of DEFINITION are tokenized and processed as if they
     appeared during translation phase three in a `'#define'' directive.
     In particular, the definition will be truncated by embedded newline
     characters.

     If you are invoking the preprocessor from a shell or shell-like
     program you may need to use the shell's quoting syntax to protect
     characters such as spaces that have a meaning in the shell syntax.

     If you wish to define a function-like macro on the command line,
     write its argument list with surrounding parentheses before the
     equals sign (if any). Parentheses are meaningful to most shells,
     so you will need to quote the option. With sh and csh,
     `-D'name(args...)=definition'' works.

     `-D' and `-U' options are processed in the order they are given on
     the command line. All -imacros file and -include file options are
     processed after all -D and -U options.

`-H'
     Print the name of each header file used, in addition to other
     normal activities. Each name is indented to show how deep in the
     `'#include'' stack it is.

`-P'
     Inhibit generation of linemarkers in the output from the
     preprocessor.  This might be useful when running the preprocessor
     on something that is not C code, and will be sent to a program
     which might be confused by the linemarkers.

`-UNAME'
     Cancel any previous definition of NAME, either built in or provided
     with a `-D' option.


File: gfortran.info,  Node: Error and Warning Options,  Next: Debugging Options,  Prev: Preprocessing Options,  Up: Invoking GNU Fortran

2.4 Options to request or suppress errors and warnings
======================================================

Errors are diagnostic messages that report that the GNU Fortran compiler
cannot compile the relevant piece of source code.  The compiler will
continue to process the program in an attempt to report further errors
to aid in debugging, but will not produce any compiled output.

   Warnings are diagnostic messages that report constructions which are
not inherently erroneous but which are risky or suggest there is likely
to be a bug in the program.  Unless `-Werror' is specified, they do not
prevent compilation of the program.

   You can request many specific warnings with options beginning `-W',
for example `-Wimplicit' to request warnings on implicit declarations.
Each of these specific warning options also has a negative form
beginning `-Wno-' to turn off warnings; for example, `-Wno-implicit'.
This manual lists only one of the two forms, whichever is not the
default.

   These options control the amount and kinds of errors and warnings
produced by GNU Fortran:

`-fmax-errors=N'
     Limits the maximum number of error messages to N, at which point
     GNU Fortran bails out rather than attempting to continue
     processing the source code.  If N is 0, there is no limit on the
     number of error messages produced.

`-fsyntax-only'
     Check the code for syntax errors, but don't actually compile it.
     This will generate module files for each module present in the
     code, but no other output file.

`-pedantic'
     Issue warnings for uses of extensions to Fortran 95.  `-pedantic'
     also applies to C-language constructs where they occur in GNU
     Fortran source files, such as use of `\e' in a character constant
     within a directive like `#include'.

     Valid Fortran 95 programs should compile properly with or without
     this option.  However, without this option, certain GNU extensions
     and traditional Fortran features are supported as well.  With this
     option, many of them are rejected.

     Some users try to use `-pedantic' to check programs for
     conformance.  They soon find that it does not do quite what they
     want--it finds some nonstandard practices, but not all.  However,
     improvements to GNU Fortran in this area are welcome.

     This should be used in conjunction with `-std=f95', `-std=f2003'
     or `-std=f2008'.

`-pedantic-errors'
     Like `-pedantic', except that errors are produced rather than
     warnings.

`-Wall'
     Enables commonly used warning options pertaining to usage that we
     recommend avoiding and that we believe are easy to avoid.  This
     currently includes `-Waliasing', `-Wampersand', `-Wsurprising',
     `-Wintrinsics-std', `-Wno-tabs', `-Wintrinsic-shadow' and
     `-Wline-truncation'.

`-Waliasing'
     Warn about possible aliasing of dummy arguments. Specifically, it
     warns if the same actual argument is associated with a dummy
     argument with `INTENT(IN)' and a dummy argument with `INTENT(OUT)'
     in a call with an explicit interface.

     The following example will trigger the warning.
            interface
              subroutine bar(a,b)
                integer, intent(in) :: a
                integer, intent(out) :: b
              end subroutine
            end interface
            integer :: a

            call bar(a,a)

`-Wampersand'
     Warn about missing ampersand in continued character constants. The
     warning is given with `-Wampersand', `-pedantic', `-std=f95',
     `-std=f2003' and `-std=f2008'. Note: With no ampersand given in a
     continued character constant, GNU Fortran assumes continuation at
     the first non-comment, non-whitespace character after the ampersand
     that initiated the continuation.

`-Warray-temporaries'
     Warn about array temporaries generated by the compiler.  The
     information generated by this warning is sometimes useful in
     optimization, in order to avoid such temporaries.

`-Wcharacter-truncation'
     Warn when a character assignment will truncate the assigned string.

`-Wline-truncation'
     Warn when a source code line will be truncated.

`-Wconversion'
     Warn about implicit conversions between different types.

`-Wimplicit-interface'
     Warn if a procedure is called without an explicit interface.  Note
     this only checks that an explicit interface is present.  It does
     not check that the declared interfaces are consistent across
     program units.

`-Wintrinsics-std'
     Warn if `gfortran' finds a procedure named like an intrinsic not
     available in the currently selected standard (with `-std') and
     treats it as `EXTERNAL' procedure because of this.
     `-fall-intrinsics' can be used to never trigger this behaviour and
     always link to the intrinsic regardless of the selected standard.

`-Wsurprising'
     Produce a warning when "suspicious" code constructs are
     encountered.  While technically legal these usually indicate that
     an error has been made.

     This currently produces a warning under the following
     circumstances:

        * An INTEGER SELECT construct has a CASE that can never be
          matched as its lower value is greater than its upper value.

        * A LOGICAL SELECT construct has three CASE statements.

        * A TRANSFER specifies a source that is shorter than the
          destination.

        * The type of a function result is declared more than once with
          the same type.  If `-pedantic' or standard-conforming mode is
          enabled, this is an error.

`-Wtabs'
     By default, tabs are accepted as whitespace, but tabs are not
     members of the Fortran Character Set.  For continuation lines, a
     tab followed by a digit between 1 and 9 is supported.  `-Wno-tabs'
     will cause a warning to be issued if a tab is encountered. Note,
     `-Wno-tabs' is active for `-pedantic', `-std=f95', `-std=f2003',
     `-std=f2008' and `-Wall'.

`-Wunderflow'
     Produce a warning when numerical constant expressions are
     encountered, which yield an UNDERFLOW during compilation.

`-Wintrinsic-shadow'
     Warn if a user-defined procedure or module procedure has the same
     name as an intrinsic; in this case, an explicit interface or
     `EXTERNAL' or `INTRINSIC' declaration might be needed to get calls
     later resolved to the desired intrinsic/procedure.

`-Wunused-parameter'
     Contrary to `gcc''s meaning of `-Wunused-parameter', `gfortran''s
     implementation of this option does not warn about unused dummy
     arguments, but about unused `PARAMETER' values.
     `-Wunused-parameter' is not included in `-Wall' but is implied by
     `-Wall -Wextra'.

`-Walign-commons'
     By default, `gfortran' warns about any occasion of variables being
     padded for proper alignment inside a COMMON block. This warning
     can be turned off via `-Wno-align-commons'. See also
     `-falign-commons'.

`-Werror'
     Turns all warnings into errors.

   *Note Options to Request or Suppress Errors and Warnings: (gcc)Error
and Warning Options, for information on more options offered by the GBE
shared by `gfortran', `gcc' and other GNU compilers.

   Some of these have no effect when compiling programs written in
Fortran.


File: gfortran.info,  Node: Debugging Options,  Next: Directory Options,  Prev: Error and Warning Options,  Up: Invoking GNU Fortran

2.5 Options for debugging your program or GNU Fortran
=====================================================

GNU Fortran has various special options that are used for debugging
either your program or the GNU Fortran compiler.

`-fdump-parse-tree'
     Output the internal parse tree before starting code generation.
     Only really useful for debugging the GNU Fortran compiler itself.

`-ffpe-trap=LIST'
     Specify a list of IEEE exceptions when a Floating Point Exception
     (FPE) should be raised.  On most systems, this will result in a
     SIGFPE signal being sent and the program being interrupted,
     producing a core file useful for debugging.  LIST is a (possibly
     empty) comma-separated list of the following IEEE exceptions:
     `invalid' (invalid floating point operation, such as
     `SQRT(-1.0)'), `zero' (division by zero), `overflow' (overflow in
     a floating point operation), `underflow' (underflow in a floating
     point operation), `precision' (loss of precision during operation)
     and `denormal' (operation produced a denormal value).

     Some of the routines in the Fortran runtime library, like
     `CPU_TIME', are likely to trigger floating point exceptions when
     `ffpe-trap=precision' is used. For this reason, the use of
     `ffpe-trap=precision' is not recommended.

`-fbacktrace'
     Specify that, when a runtime error is encountered or a deadly
     signal is emitted (segmentation fault, illegal instruction, bus
     error or floating-point exception), the Fortran runtime library
     should output a backtrace of the error.  This option only has
     influence for compilation of the Fortran main program.

`-fdump-core'
     Request that a core-dump file is written to disk when a runtime
     error is encountered on systems that support core dumps. This
     option is only effective for the compilation of the Fortran main
     program.

   *Note Options for Debugging Your Program or GCC: (gcc)Debugging
Options, for more information on debugging options.


File: gfortran.info,  Node: Directory Options,  Next: Link Options,  Prev: Debugging Options,  Up: Invoking GNU Fortran

2.6 Options for directory search
================================

These options affect how GNU Fortran searches for files specified by
the `INCLUDE' directive and where it searches for previously compiled
modules.

   It also affects the search paths used by `cpp' when used to
preprocess Fortran source.

`-IDIR'
     These affect interpretation of the `INCLUDE' directive (as well as
     of the `#include' directive of the `cpp' preprocessor).

     Also note that the general behavior of `-I' and `INCLUDE' is
     pretty much the same as of `-I' with `#include' in the `cpp'
     preprocessor, with regard to looking for `header.gcc' files and
     other such things.

     This path is also used to search for `.mod' files when previously
     compiled modules are required by a `USE' statement.

     *Note Options for Directory Search: (gcc)Directory Options, for
     information on the `-I' option.

`-JDIR'

`-MDIR'
     This option specifies where to put `.mod' files for compiled
     modules.  It is also added to the list of directories to searched
     by an `USE' statement.

     The default is the current directory.

     `-M' is deprecated to avoid conflicts with existing GCC options.

`-fintrinsic-modules-path DIR'
     This option specifies the location of pre-compiled intrinsic
     modules, if they are not in the default location expected by the
     compiler.


File: gfortran.info,  Node: Link Options,  Next: Runtime Options,  Prev: Directory Options,  Up: Invoking GNU Fortran

2.7 Influencing the linking step
================================

These options come into play when the compiler links object files into
an executable output file. They are meaningless if the compiler is not
doing a link step.

`-static-libgfortran'
     On systems that provide `libgfortran' as a shared and a static
     library, this option forces the use of the static version. If no
     shared version of `libgfortran' was built when the compiler was
     configured, this option has no effect.


File: gfortran.info,  Node: Runtime Options,  Next: Code Gen Options,  Prev: Link Options,  Up: Invoking GNU Fortran

2.8 Influencing runtime behavior
================================

These options affect the runtime behavior of programs compiled with GNU
Fortran.
`-fconvert=CONVERSION'
     Specify the representation of data for unformatted files.  Valid
     values for conversion are: `native', the default; `swap', swap
     between big- and little-endian; `big-endian', use big-endian
     representation for unformatted files; `little-endian', use
     little-endian representation for unformatted files.

     _This option has an effect only when used in the main program.
     The `CONVERT' specifier and the GFORTRAN_CONVERT_UNIT environment
     variable override the default specified by `-fconvert'._

`-fno-range-check'
     Disable range checking of input values during integer `READ'
     operations.  For example, GNU Fortran will give an error if an
     input value is outside of the relevant range of
     [`-HUGE()':`HUGE()']. In other words, with `INTEGER (kind=4) :: i'
     , attempting to read -2147483648 will give an error unless
     `-fno-range-check' is given.

`-frecord-marker=LENGTH'
     Specify the length of record markers for unformatted files.  Valid
     values for LENGTH are 4 and 8.  Default is 4.  _This is different
     from previous versions of `gfortran'_, which specified a default
     record marker length of 8 on most systems.  If you want to read or
     write files compatible with earlier versions of `gfortran', use
     `-frecord-marker=8'.

`-fmax-subrecord-length=LENGTH'
     Specify the maximum length for a subrecord.  The maximum permitted
     value for length is 2147483639, which is also the default.  Only
     really useful for use by the gfortran testsuite.

`-fsign-zero'
     When writing zero values, show the negative sign if the sign bit
     is set.  `fno-sign-zero' does not print the negative sign of zero
     values for compatibility with F77.  Default behavior is to show
     the negative sign.


File: gfortran.info,  Node: Code Gen Options,  Next: Environment Variables,  Prev: Runtime Options,  Up: Invoking GNU Fortran

2.9 Options for code generation conventions
===========================================

These machine-independent options control the interface conventions
used in code generation.

   Most of them have both positive and negative forms; the negative form
of `-ffoo' would be `-fno-foo'.  In the table below, only one of the
forms is listed--the one which is not the default.  You can figure out
the other form by either removing `no-' or adding it.

`-fno-automatic'
     Treat each program unit (except those marked as RECURSIVE) as if
     the `SAVE' statement were specified for every local variable and
     array referenced in it. Does not affect common blocks. (Some
     Fortran compilers provide this option under the name `-static' or
     `-save'.)  The default, which is `-fautomatic', uses the stack for
     local variables smaller than the value given by
     `-fmax-stack-var-size'.  Use the option `-frecursive' to use no
     static memory.

`-ff2c'
     Generate code designed to be compatible with code generated by
     `g77' and `f2c'.

     The calling conventions used by `g77' (originally implemented in
     `f2c') require functions that return type default `REAL' to
     actually return the C type `double', and functions that return
     type `COMPLEX' to return the values via an extra argument in the
     calling sequence that points to where to store the return value.
     Under the default GNU calling conventions, such functions simply
     return their results as they would in GNU C--default `REAL'
     functions return the C type `float', and `COMPLEX' functions
     return the GNU C type `complex'.  Additionally, this option
     implies the `-fsecond-underscore' option, unless
     `-fno-second-underscore' is explicitly requested.

     This does not affect the generation of code that interfaces with
     the `libgfortran' library.

     _Caution:_ It is not a good idea to mix Fortran code compiled with
     `-ff2c' with code compiled with the default `-fno-f2c' calling
     conventions as, calling `COMPLEX' or default `REAL' functions
     between program parts which were compiled with different calling
     conventions will break at execution time.

     _Caution:_ This will break code which passes intrinsic functions
     of type default `REAL' or `COMPLEX' as actual arguments, as the
     library implementations use the `-fno-f2c' calling conventions.

`-fno-underscoring'
     Do not transform names of entities specified in the Fortran source
     file by appending underscores to them.

     With `-funderscoring' in effect, GNU Fortran appends one
     underscore to external names with no underscores.  This is done to
     ensure compatibility with code produced by many UNIX Fortran
     compilers.

     _Caution_: The default behavior of GNU Fortran is incompatible
     with `f2c' and `g77', please use the `-ff2c' option if you want
     object files compiled with GNU Fortran to be compatible with
     object code created with these tools.

     Use of `-fno-underscoring' is not recommended unless you are
     experimenting with issues such as integration of GNU Fortran into
     existing system environments (vis-a`-vis existing libraries, tools,
     and so on).

     For example, with `-funderscoring', and assuming other defaults
     like `-fcase-lower' and that `j()' and `max_count()' are external
     functions while `my_var' and `lvar' are local variables, a
     statement like
          I = J() + MAX_COUNT (MY_VAR, LVAR)
     is implemented as something akin to:
          i = j_() + max_count__(&my_var__, &lvar);

     With `-fno-underscoring', the same statement is implemented as:

          i = j() + max_count(&my_var, &lvar);

     Use of `-fno-underscoring' allows direct specification of
     user-defined names while debugging and when interfacing GNU Fortran
     code with other languages.

     Note that just because the names match does _not_ mean that the
     interface implemented by GNU Fortran for an external name matches
     the interface implemented by some other language for that same
     name.  That is, getting code produced by GNU Fortran to link to
     code produced by some other compiler using this or any other
     method can be only a small part of the overall solution--getting
     the code generated by both compilers to agree on issues other than
     naming can require significant effort, and, unlike naming
     disagreements, linkers normally cannot detect disagreements in
     these other areas.

     Also, note that with `-fno-underscoring', the lack of appended
     underscores introduces the very real possibility that a
     user-defined external name will conflict with a name in a system
     library, which could make finding unresolved-reference bugs quite
     difficult in some cases--they might occur at program run time, and
     show up only as buggy behavior at run time.

     In future versions of GNU Fortran we hope to improve naming and
     linking issues so that debugging always involves using the names
     as they appear in the source, even if the names as seen by the
     linker are mangled to prevent accidental linking between
     procedures with incompatible interfaces.

`-fsecond-underscore'
     By default, GNU Fortran appends an underscore to external names.
     If this option is used GNU Fortran appends two underscores to
     names with underscores and one underscore to external names with
     no underscores.  GNU Fortran also appends two underscores to
     internal names with underscores to avoid naming collisions with
     external names.

     This option has no effect if `-fno-underscoring' is in effect.  It
     is implied by the `-ff2c' option.

     Otherwise, with this option, an external name such as `MAX_COUNT'
     is implemented as a reference to the link-time external symbol
     `max_count__', instead of `max_count_'.  This is required for
     compatibility with `g77' and `f2c', and is implied by use of the
     `-ff2c' option.

`-fbounds-check'
     Enable generation of run-time checks for array subscripts and
     against the declared minimum and maximum values.  It also checks
     array indices for assumed and deferred shape arrays against the
     actual allocated bounds and ensures that all string lengths are
     equal for character array constructors without an explicit
     typespec.

     Some checks require that `-fbounds-check' is set for the
     compilation of the main program.

     Note: In the future this may also include other forms of checking,
     e.g., checking substring references.

`fcheck-array-temporaries'
     Warns at run time when for passing an actual argument a temporary
     array had to be generated. The information generated by this
     warning is sometimes useful in optimization, in order to avoid
     such temporaries.

     Note: The warning is only printed once per location.

`-fmax-array-constructor=N'
     This option can be used to increase the upper limit permitted in
     array constructors.  The code below requires this option to expand
     the array at compile time.

          `program test'
          `implicit none'
          `integer j'
          `integer, parameter :: n = 100000'
          `integer, parameter :: i(n) = (/ (2*j, j = 1, n) /)'
          `print '(10(I0,1X))', i'
          `end program test'

     _Caution:  This option can lead to long compile times and
     excessively large object files._

     The default value for N is 65535.

`-fmax-stack-var-size=N'
     This option specifies the size in bytes of the largest array that
     will be put on the stack; if the size is exceeded static memory is
     used (except in procedures marked as RECURSIVE). Use the option
     `-frecursive' to allow for recursive procedures which do not have
     a RECURSIVE attribute or for parallel programs. Use
     `-fno-automatic' to never use the stack.

     This option currently only affects local arrays declared with
     constant bounds, and may not apply to all character variables.
     Future versions of GNU Fortran may improve this behavior.

     The default value for N is 32768.

`-fpack-derived'
     This option tells GNU Fortran to pack derived type members as
     closely as possible.  Code compiled with this option is likely to
     be incompatible with code compiled without this option, and may
     execute slower.

`-frepack-arrays'
     In some circumstances GNU Fortran may pass assumed shape array
     sections via a descriptor describing a noncontiguous area of
     memory.  This option adds code to the function prologue to repack
     the data into a contiguous block at runtime.

     This should result in faster accesses to the array.  However it
     can introduce significant overhead to the function call,
     especially  when the passed data is noncontiguous.

`-fshort-enums'
     This option is provided for interoperability with C code that was
     compiled with the `-fshort-enums' option.  It will make GNU
     Fortran choose the smallest `INTEGER' kind a given enumerator set
     will fit in, and give all its enumerators this kind.

`-fexternal-blas'
     This option will make `gfortran' generate calls to BLAS functions
     for some matrix operations like `MATMUL', instead of using our own
     algorithms, if the size of the matrices involved is larger than a
     given limit (see `-fblas-matmul-limit').  This may be profitable
     if an optimized vendor BLAS library is available.  The BLAS
     library will have to be specified at link time.

`-fblas-matmul-limit=N'
     Only significant when `-fexternal-blas' is in effect.  Matrix
     multiplication of matrices with size larger than (or equal to) N
     will be performed by calls to BLAS functions, while others will be
     handled by `gfortran' internal algorithms. If the matrices
     involved are not square, the size comparison is performed using the
     geometric mean of the dimensions of the argument and result
     matrices.

     The default value for N is 30.

`-frecursive'
     Allow indirect recursion by forcing all local arrays to be
     allocated on the stack. This flag cannot be used together with
     `-fmax-stack-var-size=' or `-fno-automatic'.

`-finit-local-zero'

`-finit-integer=N'

`-finit-real=<ZERO|INF|-INF|NAN>'

`-finit-logical=<TRUE|FALSE>'

`-finit-character=N'
     The `-finit-local-zero' option instructs the compiler to
     initialize local `INTEGER', `REAL', and `COMPLEX' variables to
     zero, `LOGICAL' variables to false, and `CHARACTER' variables to a
     string of null bytes.  Finer-grained initialization options are
     provided by the `-finit-integer=N',
     `-finit-real=<ZERO|INF|-INF|NAN>' (which also initializes the real
     and imaginary parts of local `COMPLEX' variables),
     `-finit-logical=<TRUE|FALSE>', and `-finit-character=N' (where N
     is an ASCII character value) options.  These options do not
     initialize components of derived type variables, nor do they
     initialize variables that appear in an `EQUIVALENCE' statement.
     (This limitation may be removed in future releases).

     Note that the `-finit-real=nan' option initializes `REAL' and
     `COMPLEX' variables with a quiet NaN.

`-falign-commons'
     By default, `gfortran' enforces proper alignment of all variables
     in a COMMON block by padding them as needed. On certain platforms
     this is mandatory, on others it increases performance. If a COMMON
     block is not declared with consistent data types everywhere, this
     padding can cause trouble, and `-fno-align-commons ' can be used
     to disable automatic alignment. The same form of this option
     should be used for all files that share a COMMON block.  To avoid
     potential alignment issues in COMMON blocks, it is recommended to
     order objects from largests to smallest.

   *Note Options for Code Generation Conventions: (gcc)Code Gen
Options, for information on more options offered by the GBE shared by
`gfortran', `gcc', and other GNU compilers.


File: gfortran.info,  Node: Environment Variables,  Prev: Code Gen Options,  Up: Invoking GNU Fortran

2.10 Environment variables affecting `gfortran'
===============================================

The `gfortran' compiler currently does not make use of any environment
variables to control its operation above and beyond those that affect
the operation of `gcc'.

   *Note Environment Variables Affecting GCC: (gcc)Environment
Variables, for information on environment variables.

   *Note Runtime::, for environment variables that affect the run-time
behavior of programs compiled with GNU Fortran.


File: gfortran.info,  Node: Runtime,  Next: Fortran 2003 and 2008 status,  Prev: Invoking GNU Fortran,  Up: Top

3 Runtime:  Influencing runtime behavior with environment variables
*******************************************************************

The behavior of the `gfortran' can be influenced by environment
variables.

   Malformed environment variables are silently ignored.

* Menu:

* GFORTRAN_STDIN_UNIT:: Unit number for standard input
* GFORTRAN_STDOUT_UNIT:: Unit number for standard output
* GFORTRAN_STDERR_UNIT:: Unit number for standard error
* GFORTRAN_USE_STDERR:: Send library output to standard error
* GFORTRAN_TMPDIR:: Directory for scratch files
* GFORTRAN_UNBUFFERED_ALL:: Don't buffer I/O for all units.
* GFORTRAN_UNBUFFERED_PRECONNECTED:: Don't buffer I/O for preconnected units.
* GFORTRAN_SHOW_LOCUS::  Show location for runtime errors
* GFORTRAN_OPTIONAL_PLUS:: Print leading + where permitted
* GFORTRAN_DEFAULT_RECL:: Default record length for new files
* GFORTRAN_LIST_SEPARATOR::  Separator for list output
* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O
* GFORTRAN_ERROR_DUMPCORE:: Dump core on run-time errors
* GFORTRAN_ERROR_BACKTRACE:: Show backtrace on run-time errors


File: gfortran.info,  Node: GFORTRAN_STDIN_UNIT,  Next: GFORTRAN_STDOUT_UNIT,  Up: Runtime

3.1 `GFORTRAN_STDIN_UNIT'--Unit number for standard input
=========================================================

This environment variable can be used to select the unit number
preconnected to standard input.  This must be a positive integer.  The
default value is 5.


File: gfortran.info,  Node: GFORTRAN_STDOUT_UNIT,  Next: GFORTRAN_STDERR_UNIT,  Prev: GFORTRAN_STDIN_UNIT,  Up: Runtime

3.2 `GFORTRAN_STDOUT_UNIT'--Unit number for standard output
===========================================================

This environment variable can be used to select the unit number
preconnected to standard output.  This must be a positive integer.  The
default value is 6.


File: gfortran.info,  Node: GFORTRAN_STDERR_UNIT,  Next: GFORTRAN_USE_STDERR,  Prev: GFORTRAN_STDOUT_UNIT,  Up: Runtime

3.3 `GFORTRAN_STDERR_UNIT'--Unit number for standard error
==========================================================

This environment variable can be used to select the unit number
preconnected to standard error.  This must be a positive integer.  The
default value is 0.


File: gfortran.info,  Node: GFORTRAN_USE_STDERR,  Next: GFORTRAN_TMPDIR,  Prev: GFORTRAN_STDERR_UNIT,  Up: Runtime

3.4 `GFORTRAN_USE_STDERR'--Send library output to standard error
================================================================

This environment variable controls where library output is sent.  If
the first letter is `y', `Y' or `1', standard error is used. If the
first letter is `n', `N' or `0', standard output is used.


File: gfortran.info,  Node: GFORTRAN_TMPDIR,  Next: GFORTRAN_UNBUFFERED_ALL,  Prev: GFORTRAN_USE_STDERR,  Up: Runtime

3.5 `GFORTRAN_TMPDIR'--Directory for scratch files
==================================================

This environment variable controls where scratch files are created.  If
this environment variable is missing, GNU Fortran searches for the
environment variable `TMP'.  If this is also missing, the default is
`/tmp'.


File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_ALL,  Next: GFORTRAN_UNBUFFERED_PRECONNECTED,  Prev: GFORTRAN_TMPDIR,  Up: Runtime

3.6 `GFORTRAN_UNBUFFERED_ALL'--Don't buffer I/O on all units
============================================================

This environment variable controls whether all I/O is unbuffered.  If
the first letter is `y', `Y' or `1', all I/O is unbuffered. This will
slow down small sequential reads and writes.  If the first letter is
`n', `N' or `0', I/O is buffered.  This is the default.


File: gfortran.info,  Node: GFORTRAN_UNBUFFERED_PRECONNECTED,  Next: GFORTRAN_SHOW_LOCUS,  Prev: GFORTRAN_UNBUFFERED_ALL,  Up: Runtime

3.7 `GFORTRAN_UNBUFFERED_PRECONNECTED'--Don't buffer I/O on preconnected units
==============================================================================

The environment variable named `GFORTRAN_UNBUFFERED_PRECONNECTED'
controls whether I/O on a preconnected unit (i.e. STDOUT or STDERR) is
unbuffered.  If the first letter is `y', `Y' or `1', I/O is unbuffered.
This will slow down small sequential reads and writes.  If the first
letter is `n', `N' or `0', I/O is buffered.  This is the default.


File: gfortran.info,  Node: GFORTRAN_SHOW_LOCUS,  Next: GFORTRAN_OPTIONAL_PLUS,  Prev: GFORTRAN_UNBUFFERED_PRECONNECTED,  Up: Runtime

3.8 `GFORTRAN_SHOW_LOCUS'--Show location for runtime errors
===========================================================

If the first letter is `y', `Y' or `1', filename and line numbers for
runtime errors are printed.  If the first letter is `n', `N' or `0',
don't print filename and line numbers for runtime errors. The default
is to print the location.


File: gfortran.info,  Node: GFORTRAN_OPTIONAL_PLUS,  Next: GFORTRAN_DEFAULT_RECL,  Prev: GFORTRAN_SHOW_LOCUS,  Up: Runtime

3.9 `GFORTRAN_OPTIONAL_PLUS'--Print leading + where permitted
=============================================================

If the first letter is `y', `Y' or `1', a plus sign is printed where
permitted by the Fortran standard.  If the first letter is `n', `N' or
`0', a plus sign is not printed in most cases. Default is not to print
plus signs.


File: gfortran.info,  Node: GFORTRAN_DEFAULT_RECL,  Next: GFORTRAN_LIST_SEPARATOR,  Prev: GFORTRAN_OPTIONAL_PLUS,  Up: Runtime

3.10 `GFORTRAN_DEFAULT_RECL'--Default record length for new files
=================================================================

This environment variable specifies the default record length, in
bytes, for files which are opened without a `RECL' tag in the `OPEN'
statement.  This must be a positive integer.  The default value is
1073741824 bytes (1 GB).


File: gfortran.info,  Node: GFORTRAN_LIST_SEPARATOR,  Next: GFORTRAN_CONVERT_UNIT,  Prev: GFORTRAN_DEFAULT_RECL,  Up: Runtime

3.11 `GFORTRAN_LIST_SEPARATOR'--Separator for list output
=========================================================

This environment variable specifies the separator when writing
list-directed output.  It may contain any number of spaces and at most
one comma.  If you specify this on the command line, be sure to quote
spaces, as in
     $ GFORTRAN_LIST_SEPARATOR='  ,  ' ./a.out
   when `a.out' is the compiled Fortran program that you want to run.
Default is a single space.


File: gfortran.info,  Node: GFORTRAN_CONVERT_UNIT,  Next: GFORTRAN_ERROR_DUMPCORE,  Prev: GFORTRAN_LIST_SEPARATOR,  Up: Runtime

3.12 `GFORTRAN_CONVERT_UNIT'--Set endianness for unformatted I/O
================================================================

By setting the `GFORTRAN_CONVERT_UNIT' variable, it is possible to
change the representation of data for unformatted files.  The syntax
for the `GFORTRAN_CONVERT_UNIT' variable is:
     GFORTRAN_CONVERT_UNIT: mode | mode ';' exception | exception ;
     mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;
     exception: mode ':' unit_list | unit_list ;
     unit_list: unit_spec | unit_list unit_spec ;
     unit_spec: INTEGER | INTEGER '-' INTEGER ;
   The variable consists of an optional default mode, followed by a
list of optional exceptions, which are separated by semicolons from the
preceding default and each other.  Each exception consists of a format
and a comma-separated list of units.  Valid values for the modes are
the same as for the `CONVERT' specifier:

     `NATIVE' Use the native format.  This is the default.

     `SWAP' Swap between little- and big-endian.

     `LITTLE_ENDIAN' Use the little-endian format for unformatted files.

     `BIG_ENDIAN' Use the big-endian format for unformatted files.
   A missing mode for an exception is taken to mean `BIG_ENDIAN'.
Examples of values for `GFORTRAN_CONVERT_UNIT' are:
     `'big_endian''  Do all unformatted I/O in big_endian mode.

     `'little_endian;native:10-20,25''  Do all unformatted I/O in
     little_endian mode, except for units 10 to 20 and 25, which are in
     native format.

     `'10-20''  Units 10 to 20 are big-endian, the rest is native.

   Setting the environment variables should be done on the command line
or via the `export' command for `sh'-compatible shells and via `setenv'
for `csh'-compatible shells.

   Example for `sh':
     $ gfortran foo.f90
     $ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out

   Example code for `csh':
     % gfortran foo.f90
     % setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'
     % ./a.out

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.

   *Note CONVERT specifier::, for an alternative way to specify the
data representation for unformatted files.  *Note Runtime Options::, for
setting a default data representation for the whole program.  The
`CONVERT' specifier overrides the `-fconvert' compile options.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.


File: gfortran.info,  Node: GFORTRAN_ERROR_DUMPCORE,  Next: GFORTRAN_ERROR_BACKTRACE,  Prev: GFORTRAN_CONVERT_UNIT,  Up: Runtime

3.13 `GFORTRAN_ERROR_DUMPCORE'--Dump core on run-time errors
============================================================

If the `GFORTRAN_ERROR_DUMPCORE' variable is set to `y', `Y' or `1'
(only the first letter is relevant) then library run-time errors cause
core dumps. To disable the core dumps, set the variable to `n', `N',
`0'. Default is not to core dump unless the `-fdump-core' compile option
was used.


File: gfortran.info,  Node: GFORTRAN_ERROR_BACKTRACE,  Prev: GFORTRAN_ERROR_DUMPCORE,  Up: Runtime

3.14 `GFORTRAN_ERROR_BACKTRACE'--Show backtrace on run-time errors
==================================================================

If the `GFORTRAN_ERROR_BACKTRACE' variable is set to `y', `Y' or `1'
(only the first letter is relevant) then a backtrace is printed when a
run-time error occurs.  To disable the backtracing, set the variable to
`n', `N', `0'. Default is not to print a backtrace unless the
`-fbacktrace' compile option was used.


File: gfortran.info,  Node: Fortran 2003 and 2008 status,  Next: Compiler Characteristics,  Prev: Runtime,  Up: Top

4 Fortran 2003 and 2008 Status
******************************

* Menu:

* Fortran 2003 status::
* Fortran 2008 status::


File: gfortran.info,  Node: Fortran 2003 status,  Next: Fortran 2008 status,  Up: Fortran 2003 and 2008 status

4.1 Fortran 2003 status
=======================

Although GNU Fortran focuses on implementing the Fortran 95 standard
for the time being, a few Fortran 2003 features are currently available.

   * Intrinsics `command_argument_count', `get_command',
     `get_command_argument', `get_environment_variable', and
     `move_alloc'.

   * Array constructors using square brackets. That is, `[...]' rather
     than `(/.../)'.

   * `FLUSH' statement.

   * `IOMSG=' specifier for I/O statements.

   * Support for the declaration of enumeration constants via the
     `ENUM' and `ENUMERATOR' statements.  Interoperability with `gcc'
     is guaranteed also for the case where the `-fshort-enums' command
     line option is given.

   * TR 15581:
        * `ALLOCATABLE' dummy arguments.

        * `ALLOCATABLE' function results

        * `ALLOCATABLE' components of derived types

   * The `OPEN' statement supports the `ACCESS='STREAM'' specifier,
     allowing I/O without any record structure.

   * Namelist input/output for internal files.

   * The `PROTECTED' statement and attribute.

   * The `VALUE' statement and attribute.

   * The `VOLATILE' statement and attribute.

   * The `IMPORT' statement, allowing to import host-associated derived
     types.

   * `USE' statement with `INTRINSIC' and `NON_INTRINSIC' attribute;
     supported intrinsic modules: `ISO_FORTRAN_ENV', `OMP_LIB' and
     `OMP_LIB_KINDS'.

   * Renaming of operators in the `USE' statement.

   * Interoperability with C (ISO C Bindings)

   * BOZ as argument of INT, REAL, DBLE and CMPLX.



File: gfortran.info,  Node: Fortran 2008 status,  Prev: Fortran 2003 status,  Up: Fortran 2003 and 2008 status

4.2 Fortran 2008 status
=======================

The next version of the Fortran standard after Fortran 2003 is currently
being worked on by the Working Group 5 of Sub-Committee 22 of the Joint
Technical Committee 1 of the International Organization for
Standardization (ISO) and the International Electrotechnical Commission
(IEC). This group is known at WG5 (http://www.nag.co.uk/sc22wg5/).  The
next revision of the Fortran standard is informally referred to as
Fortran 2008, reflecting its planned release year. The GNU Fortran
compiler has support for some of the new features in Fortran 2008. This
support is based on the latest draft, available from
`http://www.nag.co.uk/sc22wg5/'. However, as the final standard may
differ from the drafts, no guarantee of backward compatibility can be
made and you should only use it for experimental purposes.


File: gfortran.info,  Node: Compiler Characteristics,  Next: Extensions,  Prev: Fortran 2003 and 2008 status,  Up: Top

5 Compiler Characteristics
**************************

This chapter describes certain characteristics of the GNU Fortran
compiler, namely the KIND type parameter values supported.

* Menu:

* KIND Type Parameters::


File: gfortran.info,  Node: KIND Type Parameters,  Up: Compiler Characteristics

5.1 KIND Type Parameters
========================

The `KIND' type parameters supported by GNU Fortran for the primitive
data types are:

`INTEGER'
     1, 2, 4, 8*, 16*, default: 4 (1)

`LOGICAL'
     1, 2, 4, 8*, 16*, default: 4 (1)

`REAL'
     4, 8, 10**, 16**, default: 4 (2)

`COMPLEX'
     4, 8, 10**, 16**, default: 4 (2)

`CHARACTER'
     1, 4, default: 1


* = not available on all systems
** = not available on all systems; additionally 10 and 16 are never
available at the same time
(1) Unless -fdefault-integer-8 is used
(2) Unless -fdefault-real-8 is used

The `KIND' value matches the storage size in bytes, except for
`COMPLEX' where the storage size is twice as much (or both real and
imaginary part are a real value of the given size).  It is recommended
to use the `SELECT_*_KIND' intrinsics instead of the concrete values.


File: gfortran.info,  Node: Extensions,  Next: Intrinsic Procedures,  Prev: Compiler Characteristics,  Up: Top

6 Extensions
************

The two sections below detail the extensions to standard Fortran that
are implemented in GNU Fortran, as well as some of the popular or
historically important extensions that are not (or not yet) implemented.
For the latter case, we explain the alternatives available to GNU
Fortran users, including replacement by standard-conforming code or GNU
extensions.

* Menu:

* Extensions implemented in GNU Fortran::
* Extensions not implemented in GNU Fortran::


File: gfortran.info,  Node: Extensions implemented in GNU Fortran,  Next: Extensions not implemented in GNU Fortran,  Up: Extensions

6.1 Extensions implemented in GNU Fortran
=========================================

GNU Fortran implements a number of extensions over standard Fortran.
This chapter contains information on their syntax and meaning.  There
are currently two categories of GNU Fortran extensions, those that
provide functionality beyond that provided by any standard, and those
that are supported by GNU Fortran purely for backward compatibility
with legacy compilers.  By default, `-std=gnu' allows the compiler to
accept both types of extensions, but to warn about the use of the
latter.  Specifying either `-std=f95', `-std=f2003' or `-std=f2008'
disables both types of extensions, and `-std=legacy' allows both
without warning.

* Menu:

* Old-style kind specifications::
* Old-style variable initialization::
* Extensions to namelist::
* X format descriptor without count field::
* Commas in FORMAT specifications::
* Missing period in FORMAT specifications::
* I/O item lists::
* BOZ literal constants::
* Real array indices::
* Unary operators::
* Implicitly convert LOGICAL and INTEGER values::
* Hollerith constants support::
* Cray pointers::
* CONVERT specifier::
* OpenMP::
* Argument list functions::


File: gfortran.info,  Node: Old-style kind specifications,  Next: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran

6.1.1 Old-style kind specifications
-----------------------------------

GNU Fortran allows old-style kind specifications in declarations. These
look like:
           TYPESPEC*size x,y,z
   where `TYPESPEC' is a basic type (`INTEGER', `REAL', etc.), and
where `size' is a byte count corresponding to the storage size of a
valid kind for that type.  (For `COMPLEX' variables, `size' is the
total size of the real and imaginary parts.)  The statement then
declares `x', `y' and `z' to be of type `TYPESPEC' with the appropriate
kind.  This is equivalent to the standard-conforming declaration
           TYPESPEC(k) x,y,z
   where `k' is the kind parameter suitable for the intended precision.
As kind parameters are implementation-dependent, use the `KIND',
`SELECTED_INT_KIND' and `SELECTED_REAL_KIND' intrinsics to retrieve the
correct value, for instance `REAL*8 x' can be replaced by:
     INTEGER, PARAMETER :: dbl = KIND(1.0d0)
     REAL(KIND=dbl) :: x


File: gfortran.info,  Node: Old-style variable initialization,  Next: Extensions to namelist,  Prev: Old-style kind specifications,  Up: Extensions implemented in GNU Fortran

6.1.2 Old-style variable initialization
---------------------------------------

GNU Fortran allows old-style initialization of variables of the form:
           INTEGER i/1/,j/2/
           REAL x(2,2) /3*0.,1./
   The syntax for the initializers is as for the `DATA' statement, but
unlike in a `DATA' statement, an initializer only applies to the
variable immediately preceding the initialization.  In other words,
something like `INTEGER I,J/2,3/' is not valid.  This style of
initialization is only allowed in declarations without double colons
(`::'); the double colons were introduced in Fortran 90, which also
introduced a standard syntax for initializing variables in type
declarations.

   Examples of standard-conforming code equivalent to the above example
are:
     ! Fortran 90
           INTEGER :: i = 1, j = 2
           REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
     ! Fortran 77
           INTEGER i, j
           REAL x(2,2)
           DATA i/1/, j/2/, x/3*0.,1./

   Note that variables which are explicitly initialized in declarations
or in `DATA' statements automatically acquire the `SAVE' attribute.


File: gfortran.info,  Node: Extensions to namelist,  Next: X format descriptor without count field,  Prev: Old-style variable initialization,  Up: Extensions implemented in GNU Fortran

6.1.3 Extensions to namelist
----------------------------

GNU Fortran fully supports the Fortran 95 standard for namelist I/O
including array qualifiers, substrings and fully qualified derived
types.  The output from a namelist write is compatible with namelist
read.  The output has all names in upper case and indentation to column
1 after the namelist name.  Two extensions are permitted:

   Old-style use of `$' instead of `&'
     $MYNML
      X(:)%Y(2) = 1.0 2.0 3.0
      CH(1:4) = "abcd"
     $END

   It should be noted that the default terminator is `/' rather than
`&END'.

   Querying of the namelist when inputting from stdin. After at least
one space, entering `?' sends to stdout the namelist name and the names
of the variables in the namelist:
      ?

     &mynml
      x
      x%y
      ch
     &end

   Entering `=?' outputs the namelist to stdout, as if `WRITE(*,NML =
mynml)' had been called:
     =?

     &MYNML
      X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
      X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
      X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
      CH=abcd,  /

   To aid this dialog, when input is from stdin, errors send their
messages to stderr and execution continues, even if `IOSTAT' is set.

   `PRINT' namelist is permitted.  This causes an error if `-std=f95'
is used.
     PROGRAM test_print
       REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
       NAMELIST /mynml/ x
       PRINT mynml
     END PROGRAM test_print

   Expanded namelist reads are permitted.  This causes an error if
`-std=f95' is used.  In the following example, the first element of the
array will be given the value 0.00 and the two succeeding elements will
be given the values 1.00 and 2.00.
     &MYNML
       X(1,1) = 0.00 , 1.00 , 2.00
     /


File: gfortran.info,  Node: X format descriptor without count field,  Next: Commas in FORMAT specifications,  Prev: Extensions to namelist,  Up: Extensions implemented in GNU Fortran

6.1.4 `X' format descriptor without count field
-----------------------------------------------

To support legacy codes, GNU Fortran permits the count field of the `X'
edit descriptor in `FORMAT' statements to be omitted.  When omitted,
the count is implicitly assumed to be one.

            PRINT 10, 2, 3
     10     FORMAT (I1, X, I1)


File: gfortran.info,  Node: Commas in FORMAT specifications,  Next: Missing period in FORMAT specifications,  Prev: X format descriptor without count field,  Up: Extensions implemented in GNU Fortran

6.1.5 Commas in `FORMAT' specifications
---------------------------------------

To support legacy codes, GNU Fortran allows the comma separator to be
omitted immediately before and after character string edit descriptors
in `FORMAT' statements.

            PRINT 10, 2, 3
     10     FORMAT ('FOO='I1' BAR='I2)


File: gfortran.info,  Node: Missing period in FORMAT specifications,  Next: I/O item lists,  Prev: Commas in FORMAT specifications,  Up: Extensions implemented in GNU Fortran

6.1.6 Missing period in `FORMAT' specifications
-----------------------------------------------

To support legacy codes, GNU Fortran allows missing periods in format
specifications if and only if `-std=legacy' is given on the command
line.  This is considered non-conforming code and is discouraged.

            REAL :: value
            READ(*,10) value
     10     FORMAT ('F4')


File: gfortran.info,  Node: I/O item lists,  Next: BOZ literal constants,  Prev: Missing period in FORMAT specifications,  Up: Extensions implemented in GNU Fortran

6.1.7 I/O item lists
--------------------

To support legacy codes, GNU Fortran allows the input item list of the
`READ' statement, and the output item lists of the `WRITE' and `PRINT'
statements, to start with a comma.


File: gfortran.info,  Node: BOZ literal constants,  Next: Real array indices,  Prev: I/O item lists,  Up: Extensions implemented in GNU Fortran

6.1.8 BOZ literal constants
---------------------------

Besides decimal constants, Fortran also supports binary (`b'), octal
(`o') and hexadecimal (`z') integer constants. The syntax is: `prefix
quote digits quote', were the prefix is either `b', `o' or `z', quote
is either `'' or `"' and the digits are for binary `0' or `1', for
octal between `0' and `7', and for hexadecimal between `0' and `F'.
(Example: `b'01011101''.)

   Up to Fortran 95, BOZ literals were only allowed to initialize
integer variables in DATA statements. Since Fortran 2003 BOZ literals
are also allowed as argument of `REAL', `DBLE', `INT' and `CMPLX'; the
result is the same as if the integer BOZ literal had been converted by
`TRANSFER' to, respectively, `real', `double precision', `integer' or
`complex'.  As GNU Fortran extension the intrinsic procedures `FLOAT',
`DFLOAT', `COMPLEX' and `DCMPLX' are treated alike.

   As an extension, GNU Fortran allows hexadecimal BOZ literal
constants to be specified using the `X' prefix, in addition to the
standard `Z' prefix. The BOZ literal can also be specified by adding a
suffix to the string, for example, `Z'ABC'' and `'ABC'Z' are equivalent.

   Furthermore, GNU Fortran allows using BOZ literal constants outside
DATA statements and the four intrinsic functions allowed by Fortran
2003.  In DATA statements, in direct assignments, where the right-hand
side only contains a BOZ literal constant, and for old-style
initializers of the form `integer i /o'0173'/', the constant is
transferred as if `TRANSFER' had been used; for `COMPLEX' numbers, only
the real part is initialized unless `CMPLX' is used. In all other
cases, the BOZ literal constant is converted to an `INTEGER' value with
the largest decimal representation.  This value is then converted
numerically to the type and kind of the variable in question.  (For
instance `real :: r = b'0000001' + 1' initializes `r' with `2.0'.) As
different compilers implement the extension differently, one should be
careful when doing bitwise initialization of non-integer variables.

   Note that initializing an `INTEGER' variable with a statement such
as `DATA i/Z'FFFFFFFF'/' will give an integer overflow error rather
than the desired result of -1 when `i' is a 32-bit integer on a system
that supports 64-bit integers.  The `-fno-range-check' option can be
used as a workaround for legacy code that initializes integers in this
manner.


File: gfortran.info,  Node: Real array indices,  Next: Unary operators,  Prev: BOZ literal constants,  Up: Extensions implemented in GNU Fortran

6.1.9 Real array indices
------------------------

As an extension, GNU Fortran allows the use of `REAL' expressions or
variables as array indices.


File: gfortran.info,  Node: Unary operators,  Next: Implicitly convert LOGICAL and INTEGER values,  Prev: Real array indices,  Up: Extensions implemented in GNU Fortran

6.1.10 Unary operators
----------------------

As an extension, GNU Fortran allows unary plus and unary minus operators
to appear as the second operand of binary arithmetic operators without
the need for parenthesis.

            X = Y * -Z


File: gfortran.info,  Node: Implicitly convert LOGICAL and INTEGER values,  Next: Hollerith constants support,  Prev: Unary operators,  Up: Extensions implemented in GNU Fortran

6.1.11 Implicitly convert `LOGICAL' and `INTEGER' values
--------------------------------------------------------

As an extension for backwards compatibility with other compilers, GNU
Fortran allows the implicit conversion of `LOGICAL' values to `INTEGER'
values and vice versa.  When converting from a `LOGICAL' to an
`INTEGER', `.FALSE.' is interpreted as zero, and `.TRUE.' is
interpreted as one.  When converting from `INTEGER' to `LOGICAL', the
value zero is interpreted as `.FALSE.' and any nonzero value is
interpreted as `.TRUE.'.

             LOGICAL :: l
             l = 1

             INTEGER :: i
             i = .TRUE.

   However, there is no implicit conversion of `INTEGER' values in
`if'-statements, nor of `LOGICAL' or `INTEGER' values in I/O operations.


File: gfortran.info,  Node: Hollerith constants support,  Next: Cray pointers,  Prev: Implicitly convert LOGICAL and INTEGER values,  Up: Extensions implemented in GNU Fortran

6.1.12 Hollerith constants support
----------------------------------

GNU Fortran supports Hollerith constants in assignments, function
arguments, and `DATA' and `ASSIGN' statements.  A Hollerith constant is
written as a string of characters preceded by an integer constant
indicating the character count, and the letter `H' or `h', and stored
in bytewise fashion in a numeric (`INTEGER', `REAL', or `complex') or
`LOGICAL' variable.  The constant will be padded or truncated to fit
the size of the variable in which it is stored.

   Examples of valid uses of Hollerith constants:
           complex*16 x(2)
           data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
           x(1) = 16HABCDEFGHIJKLMNOP
           call foo (4h abc)

   Invalid Hollerith constants examples:
           integer*4 a
           a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.
           a = 0H         ! At least one character is needed.

   In general, Hollerith constants were used to provide a rudimentary
facility for handling character strings in early Fortran compilers,
prior to the introduction of `CHARACTER' variables in Fortran 77; in
those cases, the standard-compliant equivalent is to convert the
program to use proper character strings.  On occasion, there may be a
case where the intent is specifically to initialize a numeric variable
with a given byte sequence.  In these cases, the same result can be
obtained by using the `TRANSFER' statement, as in this example.
           INTEGER(KIND=4) :: a
           a = TRANSFER ("abcd", a)     ! equivalent to: a = 4Habcd


File: gfortran.info,  Node: Cray pointers,  Next: CONVERT specifier,  Prev: Hollerith constants support,  Up: Extensions implemented in GNU Fortran

6.1.13 Cray pointers
--------------------

Cray pointers are part of a non-standard extension that provides a
C-like pointer in Fortran.  This is accomplished through a pair of
variables: an integer "pointer" that holds a memory address, and a
"pointee" that is used to dereference the pointer.

   Pointer/pointee pairs are declared in statements of the form:
             pointer ( <pointer> , <pointee> )
   or,
             pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...
   The pointer is an integer that is intended to hold a memory address.
The pointee may be an array or scalar.  A pointee can be an assumed
size array--that is, the last dimension may be left unspecified by
using a `*' in place of a value--but a pointee cannot be an assumed
shape array.  No space is allocated for the pointee.

   The pointee may have its type declared before or after the pointer
statement, and its array specification (if any) may be declared before,
during, or after the pointer statement.  The pointer may be declared as
an integer prior to the pointer statement.  However, some machines have
default integer sizes that are different than the size of a pointer,
and so the following code is not portable:
             integer ipt
             pointer (ipt, iarr)
   If a pointer is declared with a kind that is too small, the compiler
will issue a warning; the resulting binary will probably not work
correctly, because the memory addresses stored in the pointers may be
truncated.  It is safer to omit the first line of the above example; if
explicit declaration of ipt's type is omitted, then the compiler will
ensure that ipt is an integer variable large enough to hold a pointer.

   Pointer arithmetic is valid with Cray pointers, but it is not the
same as C pointer arithmetic.  Cray pointers are just ordinary
integers, so the user is responsible for determining how many bytes to
add to a pointer in order to increment it.  Consider the following
example:
             real target(10)
             real pointee(10)
             pointer (ipt, pointee)
             ipt = loc (target)
             ipt = ipt + 1
   The last statement does not set `ipt' to the address of `target(1)',
as it would in C pointer arithmetic.  Adding `1' to `ipt' just adds one
byte to the address stored in `ipt'.

   Any expression involving the pointee will be translated to use the
value stored in the pointer as the base address.

   To get the address of elements, this extension provides an intrinsic
function `LOC()'.  The `LOC()' function is equivalent to the `&'
operator in C, except the address is cast to an integer type:
             real ar(10)
             pointer(ipt, arpte(10))
             real arpte
             ipt = loc(ar)  ! Makes arpte is an alias for ar
             arpte(1) = 1.0 ! Sets ar(1) to 1.0
   The pointer can also be set by a call to the `MALLOC' intrinsic (see
*note MALLOC::).

   Cray pointees often are used to alias an existing variable.  For
example:
             integer target(10)
             integer iarr(10)
             pointer (ipt, iarr)
             ipt = loc(target)
   As long as `ipt' remains unchanged, `iarr' is now an alias for
`target'. The optimizer, however, will not detect this aliasing, so it
is unsafe to use `iarr' and `target' simultaneously.  Using a pointee
in any way that violates the Fortran aliasing rules or assumptions is
illegal. It is the user's responsibility to avoid doing this; the
compiler works under the assumption that no such aliasing occurs.

   Cray pointers will work correctly when there is no aliasing (i.e.,
when they are used to access a dynamically allocated block of memory),
and also in any routine where a pointee is used, but any variable with
which it shares storage is not used.  Code that violates these rules
may not run as the user intends.  This is not a bug in the optimizer;
any code that violates the aliasing rules is illegal.  (Note that this
is not unique to GNU Fortran; any Fortran compiler that supports Cray
pointers will "incorrectly" optimize code with illegal aliasing.)

   There are a number of restrictions on the attributes that can be
applied to Cray pointers and pointees.  Pointees may not have the
`ALLOCATABLE', `INTENT', `OPTIONAL', `DUMMY', `TARGET', `INTRINSIC', or
`POINTER' attributes. Pointers may not have the `DIMENSION', `POINTER',
`TARGET', `ALLOCATABLE', `EXTERNAL', or `INTRINSIC' attributes.
Pointees may not occur in more than one pointer statement.  A pointee
cannot be a pointer.  Pointees cannot occur in equivalence, common, or
data statements.

   A Cray pointer may also point to a function or a subroutine.  For
example, the following excerpt is valid:
       implicit none
       external sub
       pointer (subptr,subpte)
       external subpte
       subptr = loc(sub)
       call subpte()
       [...]
       subroutine sub
       [...]
       end subroutine sub

   A pointer may be modified during the course of a program, and this
will change the location to which the pointee refers.  However, when
pointees are passed as arguments, they are treated as ordinary
variables in the invoked function.  Subsequent changes to the pointer
will not change the base address of the array that was passed.


File: gfortran.info,  Node: CONVERT specifier,  Next: OpenMP,  Prev: Cray pointers,  Up: Extensions implemented in GNU Fortran

6.1.14 `CONVERT' specifier
--------------------------

GNU Fortran allows the conversion of unformatted data between little-
and big-endian representation to facilitate moving of data between
different systems.  The conversion can be indicated with the `CONVERT'
specifier on the `OPEN' statement.  *Note GFORTRAN_CONVERT_UNIT::, for
an alternative way of specifying the data format via an environment
variable.

   Valid values for `CONVERT' are:
     `CONVERT='NATIVE'' Use the native format.  This is the default.

     `CONVERT='SWAP'' Swap between little- and big-endian.

     `CONVERT='LITTLE_ENDIAN'' Use the little-endian representation for
     unformatted files.

     `CONVERT='BIG_ENDIAN'' Use the big-endian representation for
     unformatted files.

   Using the option could look like this:
       open(file='big.dat',form='unformatted',access='sequential', &
            convert='big_endian')

   The value of the conversion can be queried by using
`INQUIRE(CONVERT=ch)'.  The values returned are `'BIG_ENDIAN'' and
`'LITTLE_ENDIAN''.

   `CONVERT' works between big- and little-endian for `INTEGER' values
of all supported kinds and for `REAL' on IEEE systems of kinds 4 and 8.
Conversion between different "extended double" types on different
architectures such as m68k and x86_64, which GNU Fortran supports as
`REAL(KIND=10)' and `REAL(KIND=16)', will probably not work.

   _Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the open
statement_.  This is to give control over data formats to users who do
not have the source code of their program available.

   Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters to
you, it is best if you use this only for data that needs to be portable.


File: gfortran.info,  Node: OpenMP,  Next: Argument list functions,  Prev: CONVERT specifier,  Up: Extensions implemented in GNU Fortran

6.1.15 OpenMP
-------------

OpenMP (Open Multi-Processing) is an application programming interface
(API) that supports multi-platform shared memory multiprocessing
programming in C/C++ and Fortran on many architectures, including Unix
and Microsoft Windows platforms.  It consists of a set of compiler
directives, library routines, and environment variables that influence
run-time behavior.

   GNU Fortran strives to be compatible to the OpenMP Application
Program Interface v2.5
(http://www.openmp.org/drupal/mp-documents/spec25.pdf).

   To enable the processing of the OpenMP directive `!$omp' in
free-form source code; the `c$omp', `*$omp' and `!$omp' directives in
fixed form; the `!$' conditional compilation sentinels in free form;
and the `c$', `*$' and `!$' sentinels in fixed form, `gfortran' needs
to be invoked with the `-fopenmp'. This also arranges for automatic
linking of the GNU OpenMP runtime library *note libgomp: (libgomp)Top.

   The OpenMP Fortran runtime library routines are provided both in a
form of a Fortran 90 module named `omp_lib' and in a form of a Fortran
`include' file named `omp_lib.h'.

   An example of a parallelized loop taken from Appendix A.1 of the
OpenMP Application Program Interface v2.5:
     SUBROUTINE A1(N, A, B)
       INTEGER I, N
       REAL B(N), A(N)
     !$OMP PARALLEL DO !I is private by default
       DO I=2,N
         B(I) = (A(I) + A(I-1)) / 2.0
       ENDDO
     !$OMP END PARALLEL DO
     END SUBROUTINE A1

   Please note:
   * `-fopenmp' implies `-frecursive', i.e., all local arrays will be
     allocated on the stack. When porting existing code to OpenMP, this
     may lead to surprising results, especially to segmentation faults
     if the stacksize is limited.

   * On glibc-based systems, OpenMP enabled applications can not be
     statically linked due to limitations of the underlying
     pthreads-implementation. It might be possible to get a working
     solution if `-Wl,--whole-archive -lpthread -Wl,--no-whole-archive'
     is added to the command line. However, this is not supported by
     `gcc' and thus not recommended.


File: gfortran.info,  Node: Argument list functions,  Prev: OpenMP,  Up: Extensions implemented in GNU Fortran

6.1.16 Argument list functions `%VAL', `%REF' and `%LOC'
--------------------------------------------------------

GNU Fortran supports argument list functions `%VAL', `%REF' and `%LOC'
statements, for backward compatibility with g77.  It is recommended
that these should be used only for code that is accessing facilities
outside of GNU Fortran, such as operating system or windowing
facilities. It is best to constrain such uses to isolated portions of a
program-portions that deal specifically and exclusively with low-level,
system-dependent facilities. Such portions might well provide a
portable interface for use by the program as a whole, but are
themselves not portable, and should be thoroughly tested each time they
are rebuilt using a new compiler or version of a compiler.

   `%VAL' passes a scalar argument by value, `%REF' passes it by
reference and `%LOC' passes its memory location.  Since gfortran
already passes scalar arguments by reference, `%REF' is in effect a
do-nothing.  `%LOC' has the same effect as a fortran pointer.

   An example of passing an argument by value to a C subroutine foo.:
     C
     C prototype      void foo_ (float x);
     C
           external foo
           real*4 x
           x = 3.14159
           call foo (%VAL (x))
           end

   For details refer to the g77 manual
`http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top'.

   Also, the gfortran testsuite c_by_val.f and its partner c_by_val.c
are worth a look.


File: gfortran.info,  Node: Extensions not implemented in GNU Fortran,  Prev: Extensions implemented in GNU Fortran,  Up: Extensions

6.2 Extensions not implemented in GNU Fortran
=============================================

The long history of the Fortran language, its wide use and broad
userbase, the large number of different compiler vendors and the lack of
some features crucial to users in the first standards have lead to the
existence of a number of important extensions to the language.  While
some of the most useful or popular extensions are supported by the GNU
Fortran compiler, not all existing extensions are supported.  This
section aims at listing these extensions and offering advice on how
best make code that uses them running with the GNU Fortran compiler.

* Menu:

* STRUCTURE and RECORD::
* ENCODE and DECODE statements::


File: gfortran.info,  Node: STRUCTURE and RECORD,  Next: ENCODE and DECODE statements,  Up: Extensions not implemented in GNU Fortran

6.2.1 `STRUCTURE' and `RECORD'
------------------------------

Structures are user-defined aggregate data types; this functionality was
standardized in Fortran 90 with an different syntax, under the name of
"derived types". Here is an example of code using the non portable
structure syntax:

     ! Declaring a structure named ``item'' and containing three fields:
     ! an integer ID, an description string and a floating-point price.
     STRUCTURE /item/
       INTEGER id
       CHARACTER(LEN=200) description
       REAL price
     END STRUCTURE

     ! Define two variables, an single record of type ``item''
     ! named ``pear'', and an array of items named ``store_catalog''
     RECORD /item/ pear, store_catalog(100)

     ! We can directly access the fields of both variables
     pear.id = 92316
     pear.description = "juicy D'Anjou pear"
     pear.price = 0.15
     store_catalog(7).id = 7831
     store_catalog(7).description = "milk bottle"
     store_catalog(7).price = 1.2

     ! We can also manipulate the whole structure
     store_catalog(12) = pear
     print *, store_catalog(12)

This code can easily be rewritten in the Fortran 90 syntax as following:

     ! ``STRUCTURE /name/ ... END STRUCTURE'' becomes
     ! ``TYPE name ... END TYPE''
     TYPE item
       INTEGER id
       CHARACTER(LEN=200) description
       REAL price
     END TYPE

     ! ``RECORD /name/ variable'' becomes ``TYPE(name) variable''
     TYPE(item) pear, store_catalog(100)

     ! Instead of using a dot (.) to access fields of a record, the
     ! standard syntax uses a percent sign (%)
     pear%id = 92316
     pear%description = "juicy D'Anjou pear"
     pear%price = 0.15
     store_catalog(7)%id = 7831
     store_catalog(7)%description = "milk bottle"
     store_catalog(7)%price = 1.2

     ! Assignments of a whole variable don't change
     store_catalog(12) = pear
     print *, store_catalog(12)


File: gfortran.info,  Node: ENCODE and DECODE statements,  Prev: STRUCTURE and RECORD,  Up: Extensions not implemented in GNU Fortran

6.2.2 `ENCODE' and `DECODE' statements
--------------------------------------

GNU Fortran doesn't support the `ENCODE' and `DECODE' statements.
These statements are best replaced by `READ' and `WRITE' statements
involving internal files (`CHARACTER' variables and arrays), which have
been part of the Fortran standard since Fortran 77. For example,
replace a code fragment like

           INTEGER*1 LINE(80)
           REAL A, B, C
     c     ... Code that sets LINE
           DECODE (80, 9000, LINE) A, B, C
      9000 FORMAT (1X, 3(F10.5))

with the following:

           CHARACTER(LEN=80) LINE
           REAL A, B, C
     c     ... Code that sets LINE
           READ (UNIT=LINE, FMT=9000) A, B, C
      9000 FORMAT (1X, 3(F10.5))

   Similarly, replace a code fragment like

           INTEGER*1 LINE(80)
           REAL A, B, C
     c     ... Code that sets A, B and C
           ENCODE (80, 9000, LINE) A, B, C
      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))

with the following:

           INTEGER*1 LINE(80)
           REAL A, B, C
     c     ... Code that sets A, B and C
           WRITE (UNIT=LINE, FMT=9000) A, B, C
      9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))


File: gfortran.info,  Node: Intrinsic Procedures,  Next: Intrinsic Modules,  Prev: Extensions,  Up: Top

7 Intrinsic Procedures
**********************

* Menu:

* Introduction:         Introduction to Intrinsics
* `ABORT':         ABORT,     Abort the program
* `ABS':           ABS,       Absolute value
* `ACCESS':        ACCESS,    Checks file access modes
* `ACHAR':         ACHAR,     Character in ASCII collating sequence
* `ACOS':          ACOS,      Arccosine function
* `ACOSH':         ACOSH,     Hyperbolic arccosine function
* `ADJUSTL':       ADJUSTL,   Left adjust a string
* `ADJUSTR':       ADJUSTR,   Right adjust a string
* `AIMAG':         AIMAG,     Imaginary part of complex number
* `AINT':          AINT,      Truncate to a whole number
* `ALARM':         ALARM,     Set an alarm clock
* `ALL':           ALL,       Determine if all values are true
* `ALLOCATED':     ALLOCATED, Status of allocatable entity
* `AND':           AND,       Bitwise logical AND
* `ANINT':         ANINT,     Nearest whole number
* `ANY':           ANY,       Determine if any values are true
* `ASIN':          ASIN,      Arcsine function
* `ASINH':         ASINH,     Hyperbolic arcsine function
* `ASSOCIATED':    ASSOCIATED, Status of a pointer or pointer/target pair
* `ATAN':          ATAN,      Arctangent function
* `ATAN2':         ATAN2,     Arctangent function
* `ATANH':         ATANH,     Hyperbolic arctangent function
* `BESSEL_J0':     BESSEL_J0, Bessel function of the first kind of order 0
* `BESSEL_J1':     BESSEL_J1, Bessel function of the first kind of order 1
* `BESSEL_JN':     BESSEL_JN, Bessel function of the first kind
* `BESSEL_Y0':     BESSEL_Y0, Bessel function of the second kind of order 0
* `BESSEL_Y1':     BESSEL_Y1, Bessel function of the second kind of order 1
* `BESSEL_YN':     BESSEL_YN, Bessel function of the second kind
* `BIT_SIZE':      BIT_SIZE,  Bit size inquiry function
* `BTEST':         BTEST,     Bit test function
* `C_ASSOCIATED':  C_ASSOCIATED, Status of a C pointer
* `C_F_POINTER':   C_F_POINTER, Convert C into Fortran pointer
* `C_F_PROCPOINTER': C_F_PROCPOINTER, Convert C into Fortran procedure pointer
* `C_FUNLOC':      C_FUNLOC,  Obtain the C address of a procedure
* `C_LOC':         C_LOC,     Obtain the C address of an object
* `C_SIZEOF':      C_SIZEOF,  Size in bytes of an expression
* `CEILING':       CEILING,   Integer ceiling function
* `CHAR':          CHAR,      Integer-to-character conversion function
* `CHDIR':         CHDIR,     Change working directory
* `CHMOD':         CHMOD,     Change access permissions of files
* `CMPLX':         CMPLX,     Complex conversion function
* `COMMAND_ARGUMENT_COUNT': COMMAND_ARGUMENT_COUNT, Get number of command line arguments
* `COMPLEX':       COMPLEX,   Complex conversion function
* `CONJG':         CONJG,     Complex conjugate function
* `COS':           COS,       Cosine function
* `COSH':          COSH,      Hyperbolic cosine function
* `COUNT':         COUNT,     Count occurrences of TRUE in an array
* `CPU_TIME':      CPU_TIME,  CPU time subroutine
* `CSHIFT':        CSHIFT,    Circular shift elements of an array
* `CTIME':         CTIME,     Subroutine (or function) to convert a time into a string
* `DATE_AND_TIME': DATE_AND_TIME, Date and time subroutine
* `DBLE':          DBLE,      Double precision conversion function
* `DCMPLX':        DCMPLX,    Double complex conversion function
* `DFLOAT':        DFLOAT,    Double precision conversion function
* `DIGITS':        DIGITS,    Significant digits function
* `DIM':           DIM,       Positive difference
* `DOT_PRODUCT':   DOT_PRODUCT, Dot product function
* `DPROD':         DPROD,     Double product function
* `DREAL':         DREAL,     Double real part function
* `DTIME':         DTIME,     Execution time subroutine (or function)
* `EOSHIFT':       EOSHIFT,   End-off shift elements of an array
* `EPSILON':       EPSILON,   Epsilon function
* `ERF':           ERF,       Error function
* `ERFC':          ERFC,      Complementary error function
* `ERFC_SCALED':   ERFC_SCALED, Exponentially-scaled complementary error function
* `ETIME':         ETIME,     Execution time subroutine (or function)
* `EXIT':          EXIT,      Exit the program with status.
* `EXP':           EXP,       Exponential function
* `EXPONENT':      EXPONENT,  Exponent function
* `FDATE':         FDATE,     Subroutine (or function) to get the current time as a string
* `FGET':          FGET,      Read a single character in stream mode from stdin
* `FGETC':         FGETC,     Read a single character in stream mode
* `FLOAT':         FLOAT,     Convert integer to default real
* `FLOOR':         FLOOR,     Integer floor function
* `FLUSH':         FLUSH,     Flush I/O unit(s)
* `FNUM':          FNUM,      File number function
* `FPUT':          FPUT,      Write a single character in stream mode to stdout
* `FPUTC':         FPUTC,     Write a single character in stream mode
* `FRACTION':      FRACTION,  Fractional part of the model representation
* `FREE':          FREE,      Memory de-allocation subroutine
* `FSEEK':         FSEEK,     Low level file positioning subroutine
* `FSTAT':         FSTAT,     Get file status
* `FTELL':         FTELL,     Current stream position
* `GAMMA':         GAMMA,     Gamma function
* `GERROR':        GERROR,    Get last system error message
* `GETARG':        GETARG,    Get command line arguments
* `GET_COMMAND':   GET_COMMAND, Get the entire command line
* `GET_COMMAND_ARGUMENT': GET_COMMAND_ARGUMENT, Get command line arguments
* `GETCWD':        GETCWD,    Get current working directory
* `GETENV':        GETENV,    Get an environmental variable
* `GET_ENVIRONMENT_VARIABLE': GET_ENVIRONMENT_VARIABLE, Get an environmental variable
* `GETGID':        GETGID,    Group ID function
* `GETLOG':        GETLOG,    Get login name
* `GETPID':        GETPID,    Process ID function
* `GETUID':        GETUID,    User ID function
* `GMTIME':        GMTIME,    Convert time to GMT info
* `HOSTNM':        HOSTNM,    Get system host name
* `HUGE':          HUGE,      Largest number of a kind
* `HYPOT':         HYPOT,     Euclidian distance function
* `IACHAR':        IACHAR,    Code in ASCII collating sequence
* `IAND':          IAND,      Bitwise logical and
* `IARGC':         IARGC,     Get the number of command line arguments
* `IBCLR':         IBCLR,     Clear bit
* `IBITS':         IBITS,     Bit extraction
* `IBSET':         IBSET,     Set bit
* `ICHAR':         ICHAR,     Character-to-integer conversion function
* `IDATE':         IDATE,     Current local time (day/month/year)
* `IEOR':          IEOR,      Bitwise logical exclusive or
* `IERRNO':        IERRNO,    Function to get the last system error number
* `INDEX':         INDEX intrinsic, Position of a substring within a string
* `INT':           INT,       Convert to integer type
* `INT2':          INT2,      Convert to 16-bit integer type
* `INT8':          INT8,      Convert to 64-bit integer type
* `IOR':           IOR,       Bitwise logical or
* `IRAND':         IRAND,     Integer pseudo-random number
* `IS_IOSTAT_END':  IS_IOSTAT_END, Test for end-of-file value
* `IS_IOSTAT_EOR':  IS_IOSTAT_EOR, Test for end-of-record value
* `ISATTY':        ISATTY,    Whether a unit is a terminal device
* `ISHFT':         ISHFT,     Shift bits
* `ISHFTC':        ISHFTC,    Shift bits circularly
* `ISNAN':         ISNAN,     Tests for a NaN
* `ITIME':         ITIME,     Current local time (hour/minutes/seconds)
* `KILL':          KILL,      Send a signal to a process
* `KIND':          KIND,      Kind of an entity
* `LBOUND':        LBOUND,    Lower dimension bounds of an array
* `LEADZ':         LEADZ,     Number of leading zero bits of an integer
* `LEN':           LEN,       Length of a character entity
* `LEN_TRIM':      LEN_TRIM,  Length of a character entity without trailing blank characters
* `LOG_GAMMA':     LOG_GAMMA, Logarithm of the Gamma function
* `LGE':           LGE,       Lexical greater than or equal
* `LGT':           LGT,       Lexical greater than
* `LINK':          LINK,      Create a hard link
* `LLE':           LLE,       Lexical less than or equal
* `LLT':           LLT,       Lexical less than
* `LNBLNK':        LNBLNK,    Index of the last non-blank character in a string
* `LOC':           LOC,       Returns the address of a variable
* `LOG':           LOG,       Logarithm function
* `LOG10':         LOG10,     Base 10 logarithm function
* `LOGICAL':       LOGICAL,   Convert to logical type
* `LONG':          LONG,      Convert to integer type
* `LSHIFT':        LSHIFT,    Left shift bits
* `LSTAT':         LSTAT,     Get file status
* `LTIME':         LTIME,     Convert time to local time info
* `MALLOC':        MALLOC,    Dynamic memory allocation function
* `MATMUL':        MATMUL,    matrix multiplication
* `MAX':           MAX,       Maximum value of an argument list
* `MAXEXPONENT':   MAXEXPONENT, Maximum exponent of a real kind
* `MAXLOC':        MAXLOC,    Location of the maximum value within an array
* `MAXVAL':        MAXVAL,    Maximum value of an array
* `MCLOCK':        MCLOCK,    Time function
* `MCLOCK8':       MCLOCK8,   Time function (64-bit)
* `MERGE':         MERGE,     Merge arrays
* `MIN':           MIN,       Minimum value of an argument list
* `MINEXPONENT':   MINEXPONENT, Minimum exponent of a real kind
* `MINLOC':        MINLOC,    Location of the minimum value within an array
* `MINVAL':        MINVAL,    Minimum value of an array
* `MOD':           MOD,       Remainder function
* `MODULO':        MODULO,    Modulo function
* `MOVE_ALLOC':    MOVE_ALLOC, Move allocation from one object to another
* `MVBITS':        MVBITS,    Move bits from one integer to another
* `NEAREST':       NEAREST,   Nearest representable number
* `NEW_LINE':      NEW_LINE,  New line character
* `NINT':          NINT,      Nearest whole number
* `NOT':           NOT,       Logical negation
* `NULL':          NULL,      Function that returns an disassociated pointer
* `OR':            OR,        Bitwise logical OR
* `PACK':          PACK,      Pack an array into an array of rank one
* `PERROR':        PERROR,    Print system error message
* `PRECISION':     PRECISION, Decimal precision of a real kind
* `PRESENT':       PRESENT,   Determine whether an optional dummy argument is specified
* `PRODUCT':       PRODUCT,   Product of array elements
* `RADIX':         RADIX,     Base of a data model
* `RANDOM_NUMBER': RANDOM_NUMBER, Pseudo-random number
* `RANDOM_SEED':   RANDOM_SEED, Initialize a pseudo-random number sequence
* `RAND':          RAND,      Real pseudo-random number
* `RANGE':         RANGE,     Decimal exponent range
* `RAN':           RAN,       Real pseudo-random number
* `REAL':          REAL,      Convert to real type
* `RENAME':        RENAME,    Rename a file
* `REPEAT':        REPEAT,    Repeated string concatenation
* `RESHAPE':       RESHAPE,   Function to reshape an array
* `RRSPACING':     RRSPACING, Reciprocal of the relative spacing
* `RSHIFT':        RSHIFT,    Right shift bits
* `SCALE':         SCALE,     Scale a real value
* `SCAN':          SCAN,      Scan a string for the presence of a set of characters
* `SECNDS':        SECNDS,    Time function
* `SECOND':        SECOND,    CPU time function
* `SELECTED_CHAR_KIND': SELECTED_CHAR_KIND,  Choose character kind
* `SELECTED_INT_KIND': SELECTED_INT_KIND,  Choose integer kind
* `SELECTED_REAL_KIND': SELECTED_REAL_KIND,  Choose real kind
* `SET_EXPONENT':  SET_EXPONENT, Set the exponent of the model
* `SHAPE':         SHAPE,     Determine the shape of an array
* `SIGN':          SIGN,      Sign copying function
* `SIGNAL':        SIGNAL,    Signal handling subroutine (or function)
* `SIN':           SIN,       Sine function
* `SINH':          SINH,      Hyperbolic sine function
* `SIZE':          SIZE,      Function to determine the size of an array
* `SIZEOF':        SIZEOF,    Determine the size in bytes of an expression
* `SLEEP':         SLEEP,     Sleep for the specified number of seconds
* `SNGL':          SNGL,      Convert double precision real to default real
* `SPACING':       SPACING,   Smallest distance between two numbers of a given type
* `SPREAD':        SPREAD,    Add a dimension to an array
* `SQRT':          SQRT,      Square-root function
* `SRAND':         SRAND,     Reinitialize the random number generator
* `STAT':          STAT,      Get file status
* `SUM':           SUM,       Sum of array elements
* `SYMLNK':        SYMLNK,    Create a symbolic link
* `SYSTEM':        SYSTEM,    Execute a shell command
* `SYSTEM_CLOCK':  SYSTEM_CLOCK, Time function
* `TAN':           TAN,       Tangent function
* `TANH':          TANH,      Hyperbolic tangent function
* `TIME':          TIME,      Time function
* `TIME8':         TIME8,     Time function (64-bit)
* `TINY':          TINY,      Smallest positive number of a real kind
* `TRAILZ':        TRAILZ,    Number of trailing zero bits of an integer
* `TRANSFER':      TRANSFER,  Transfer bit patterns
* `TRANSPOSE':     TRANSPOSE, Transpose an array of rank two
* `TRIM':          TRIM,      Remove trailing blank characters of a string
* `TTYNAM':        TTYNAM,    Get the name of a terminal device.
* `UBOUND':        UBOUND,    Upper dimension bounds of an array
* `UMASK':         UMASK,     Set the file creation mask
* `UNLINK':        UNLINK,    Remove a file from the file system
* `UNPACK':        UNPACK,    Unpack an array of rank one into an array
* `VERIFY':        VERIFY,    Scan a string for the absence of a set of characters
* `XOR':           XOR,       Bitwise logical exclusive or


File: gfortran.info,  Node: Introduction to Intrinsics,  Next: ABORT,  Up: Intrinsic Procedures

7.1 Introduction to intrinsic procedures
========================================

The intrinsic procedures provided by GNU Fortran include all of the
intrinsic procedures required by the Fortran 95 standard, a set of
intrinsic procedures for backwards compatibility with G77, and a
selection of intrinsic procedures from the Fortran 2003 and Fortran 2008
standards.  Any conflict between a description here and a description in
either the Fortran 95 standard, the Fortran 2003 standard or the Fortran
2008 standard is unintentional, and the standard(s) should be considered
authoritative.

   The enumeration of the `KIND' type parameter is processor defined in
the Fortran 95 standard.  GNU Fortran defines the default integer type
and default real type by `INTEGER(KIND=4)' and `REAL(KIND=4)',
respectively.  The standard mandates that both data types shall have
another kind, which have more precision.  On typical target
architectures supported by `gfortran', this kind type parameter is
`KIND=8'.  Hence, `REAL(KIND=8)' and `DOUBLE PRECISION' are equivalent.
In the description of generic intrinsic procedures, the kind type
parameter will be specified by `KIND=*', and in the description of
specific names for an intrinsic procedure the kind type parameter will
be explicitly given (e.g., `REAL(KIND=4)' or `REAL(KIND=8)').  Finally,
for brevity the optional `KIND=' syntax will be omitted.

   Many of the intrinsic procedures take one or more optional arguments.
This document follows the convention used in the Fortran 95 standard,
and denotes such arguments by square brackets.

   GNU Fortran offers the `-std=f95' and `-std=gnu' options, which can
be used to restrict the set of intrinsic procedures to a given
standard.  By default, `gfortran' sets the `-std=gnu' option, and so
all intrinsic procedures described here are accepted.  There is one
caveat.  For a select group of intrinsic procedures, `g77' implemented
both a function and a subroutine.  Both classes have been implemented
in `gfortran' for backwards compatibility with `g77'.  It is noted here
that these functions and subroutines cannot be intermixed in a given
subprogram.  In the descriptions that follow, the applicable standard
for each intrinsic procedure is noted.


File: gfortran.info,  Node: ABORT,  Next: ABS,  Prev: Introduction to Intrinsics,  Up: Intrinsic Procedures

7.2 `ABORT' -- Abort the program
================================

_Description_:
     `ABORT' causes immediate termination of the program.  On operating
     systems that support a core dump, `ABORT' will produce a core dump
     even if the option `-fno-dump-core' is in effect, which is
     suitable for debugging purposes.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ABORT'

_Return value_:
     Does not return.

_Example_:
          program test_abort
            integer :: i = 1, j = 2
            if (i /= j) call abort
          end program test_abort

_See also_:
     *note EXIT::, *note KILL::



File: gfortran.info,  Node: ABS,  Next: ACCESS,  Prev: ABORT,  Up: Intrinsic Procedures

7.3 `ABS' -- Absolute value
===========================

_Description_:
     `ABS(A)' computes the absolute value of `A'.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ABS(A)'

_Arguments_:
     A          The type of the argument shall be an `INTEGER',
                `REAL', or `COMPLEX'.

_Return value_:
     The return value is of the same type and kind as the argument
     except the return value is `REAL' for a `COMPLEX' argument.

_Example_:
          program test_abs
            integer :: i = -1
            real :: x = -1.e0
            complex :: z = (-1.e0,0.e0)
            i = abs(i)
            x = abs(x)
            x = abs(z)
          end program test_abs

_Specific names_:
     Name          Argument      Return type   Standard
     `CABS(A)'     `COMPLEX(4)   `REAL(4)'     Fortran 77 and
                   Z'                          later
     `DABS(A)'     `REAL(8)      `REAL(8)'     Fortran 77 and
                   X'                          later
     `IABS(A)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
                   I'                          later
     `ZABS(A)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          
     `CDABS(A)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          


File: gfortran.info,  Node: ACCESS,  Next: ACHAR,  Prev: ABS,  Up: Intrinsic Procedures

7.4 `ACCESS' -- Checks file access modes
========================================

_Description_:
     `ACCESS(NAME, MODE)' checks whether the file NAME exists, is
     readable, writable or executable. Except for the executable check,
     `ACCESS' can be replaced by Fortran 95's `INQUIRE'.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ACCESS(NAME, MODE)'

_Arguments_:
     NAME       Scalar `CHARACTER' of default kind with the
                file name. Tailing blank are ignored unless
                the character `achar(0)' is present, then all
                characters up to and excluding `achar(0)' are
                used as file name.
     MODE       Scalar `CHARACTER' of default kind with the
                file access mode, may be any concatenation of
                `"r"' (readable), `"w"' (writable) and `"x"'
                (executable), or `" "' to check for existence.

_Return value_:
     Returns a scalar `INTEGER', which is `0' if the file is accessible
     in the given mode; otherwise or if an invalid argument has been
     given for `MODE' the value `1' is returned.

_Example_:
          program access_test
            implicit none
            character(len=*), parameter :: file  = 'test.dat'
            character(len=*), parameter :: file2 = 'test.dat  '//achar(0)
            if(access(file,' ') == 0) print *, trim(file),' is exists'
            if(access(file,'r') == 0) print *, trim(file),' is readable'
            if(access(file,'w') == 0) print *, trim(file),' is writable'
            if(access(file,'x') == 0) print *, trim(file),' is executable'
            if(access(file2,'rwx') == 0) &
              print *, trim(file2),' is readable, writable and executable'
          end program access_test

_Specific names_:

_See also_:


File: gfortran.info,  Node: ACHAR,  Next: ACOS,  Prev: ACCESS,  Up: Intrinsic Procedures

7.5 `ACHAR' -- Character in ASCII collating sequence
====================================================

_Description_:
     `ACHAR(I)' returns the character located at position `I' in the
     ASCII collating sequence.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACHAR(I [, KIND])'

_Arguments_:
     I          The type shall be `INTEGER'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `CHARACTER' with a length of one.  If
     the KIND argument is present, the return value is of the specified
     kind and of the default kind otherwise.

_Example_:
          program test_achar
            character c
            c = achar(32)
          end program test_achar

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note CHAR::, *note IACHAR::, *note ICHAR::



File: gfortran.info,  Node: ACOS,  Next: ACOSH,  Prev: ACHAR,  Up: Intrinsic Procedures

7.6 `ACOS' -- Arccosine function
================================

_Description_:
     `ACOS(X)' computes the arccosine of X (inverse of `COS(X)').

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACOS(X)'

_Arguments_:
     X          The type shall be `REAL' with a magnitude that
                is less than or equal to one.

_Return value_:
     The return value is of type `REAL' and it lies in the range  0
     \leq \acos(x) \leq \pi. The return value if of the same kind as X.

_Example_:
          program test_acos
            real(8) :: x = 0.866_8
            x = acos(x)
          end program test_acos

_Specific names_:
     Name          Argument      Return type   Standard
     `DACOS(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later

_See also_:
     Inverse function: *note COS::



File: gfortran.info,  Node: ACOSH,  Next: ADJUSTL,  Prev: ACOS,  Up: Intrinsic Procedures

7.7 `ACOSH' -- Hyperbolic arccosine function
============================================

_Description_:
     `ACOSH(X)' computes the hyperbolic arccosine of X (inverse of
     `COSH(X)').

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ACOSH(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value has the same type and kind as X

_Example_:
          PROGRAM test_acosh
            REAL(8), DIMENSION(3) :: x = (/ 1.0, 2.0, 3.0 /)
            WRITE (*,*) ACOSH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DACOSH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension

_See also_:
     Inverse function: *note COSH::


File: gfortran.info,  Node: ADJUSTL,  Next: ADJUSTR,  Prev: ACOSH,  Up: Intrinsic Procedures

7.8 `ADJUSTL' -- Left adjust a string
=====================================

_Description_:
     `ADJUSTL(STRING)' will left adjust a string by removing leading
     spaces.  Spaces are inserted at the end of the string as needed.

_Standard_:
     Fortran 90 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ADJUSTL(STRING)'

_Arguments_:
     STRING     The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' and of the same kind as
     STRING where leading spaces are removed and the same number of
     spaces are inserted on the end of STRING.

_Example_:
          program test_adjustl
            character(len=20) :: str = '   gfortran'
            str = adjustl(str)
            print *, str
          end program test_adjustl

_See also_:
     *note ADJUSTR::, *note TRIM::


File: gfortran.info,  Node: ADJUSTR,  Next: AIMAG,  Prev: ADJUSTL,  Up: Intrinsic Procedures

7.9 `ADJUSTR' -- Right adjust a string
======================================

_Description_:
     `ADJUSTR(STRING)' will right adjust a string by removing trailing
     spaces.  Spaces are inserted at the start of the string as needed.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ADJUSTR(STRING)'

_Arguments_:
     STR        The type shall be `CHARACTER'.

_Return value_:
     The return value is of type `CHARACTER' and of the same kind as
     STRING where trailing spaces are removed and the same number of
     spaces are inserted at the start of STRING.

_Example_:
          program test_adjustr
            character(len=20) :: str = 'gfortran'
            str = adjustr(str)
            print *, str
          end program test_adjustr

_See also_:
     *note ADJUSTL::, *note TRIM::


File: gfortran.info,  Node: AIMAG,  Next: AINT,  Prev: ADJUSTR,  Up: Intrinsic Procedures

7.10 `AIMAG' -- Imaginary part of complex number
================================================

_Description_:
     `AIMAG(Z)' yields the imaginary part of complex argument `Z'.  The
     `IMAG(Z)' and `IMAGPART(Z)' intrinsic functions are provided for
     compatibility with `g77', and their use in new code is strongly
     discouraged.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = AIMAG(Z)'

_Arguments_:
     Z          The type of the argument shall be `COMPLEX'.

_Return value_:
     The return value is of type `REAL' with the kind type parameter of
     the argument.

_Example_:
          program test_aimag
            complex(4) z4
            complex(8) z8
            z4 = cmplx(1.e0_4, 0.e0_4)
            z8 = cmplx(0.e0_8, 1.e0_8)
            print *, aimag(z4), dimag(z8)
          end program test_aimag

_Specific names_:
     Name          Argument      Return type   Standard
     `DIMAG(Z)'    `COMPLEX(8)   `REAL(8)'     GNU extension
                   Z'                          
     `IMAG(Z)'     `COMPLEX Z'   `REAL'        GNU extension
     `IMAGPART(Z)' `COMPLEX Z'   `REAL'        GNU extension


File: gfortran.info,  Node: AINT,  Next: ALARM,  Prev: AIMAG,  Up: Intrinsic Procedures

7.11 `AINT' -- Truncate to a whole number
=========================================

_Description_:
     `AINT(A [, KIND])' truncates its argument to a whole number.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = AINT(A [, KIND])'

_Arguments_:
     A          The type of the argument shall be `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `REAL' with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If the magnitude of X is
     less than one, `AINT(X)' returns zero.  If the magnitude is equal
     to or greater than one then it returns the largest whole number
     that does not exceed its magnitude.  The sign is the same as the
     sign of X.

_Example_:
          program test_aint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, aint(x4), dint(x8)
            x8 = aint(x4,8)
          end program test_aint

_Specific names_:
     Name          Argument      Return type   Standard
     `DINT(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later


File: gfortran.info,  Node: ALARM,  Next: ALL,  Prev: AINT,  Up: Intrinsic Procedures

7.12 `ALARM' -- Execute a routine after a given delay
=====================================================

_Description_:
     `ALARM(SECONDS, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed after a delay of SECONDS by using
     `alarm(2)' to set up a signal and `signal(2)' to catch it. If
     STATUS is supplied, it will be returned with the number of seconds
     remaining until any previously scheduled alarm was due to be
     delivered, or zero if there was no previously scheduled alarm.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ALARM(SECONDS, HANDLER [, STATUS])'

_Arguments_:
     SECONDS    The type of the argument shall be a scalar
                `INTEGER'. It is `INTENT(IN)'.
     HANDLER    Signal handler (`INTEGER FUNCTION' or
                `SUBROUTINE') or dummy/global `INTEGER'
                scalar. The scalar values may be either
                `SIG_IGN=1' to ignore the alarm generated or
                `SIG_DFL=0' to set the default action. It is
                `INTENT(IN)'.
     STATUS     (Optional) STATUS shall be a scalar variable
                of the default `INTEGER' kind. It is
                `INTENT(OUT)'.

_Example_:
          program test_alarm
            external handler_print
            integer i
            call alarm (3, handler_print, i)
            print *, i
            call sleep(10)
          end program test_alarm
     This will cause the external routine HANDLER_PRINT to be called
     after 3 seconds.


File: gfortran.info,  Node: ALL,  Next: ALLOCATED,  Prev: ALARM,  Up: Intrinsic Procedures

7.13 `ALL' -- All values in MASK along DIM are true
===================================================

_Description_:
     `ALL(MASK [, DIM])' determines if all the values are true in MASK
     in the array along dimension DIM.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = ALL(MASK [, DIM])'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL' and
                it shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with
                a value that lies between one and the rank of
                MASK.

_Return value_:
     `ALL(MASK)' returns a scalar value of type `LOGICAL' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ALL(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ALL(MASK)' is true if all elements of MASK are true.  It
          also is true if MASK has zero size; otherwise, it is false.

    (B)
          If the rank of MASK is one, then `ALL(MASK,DIM)' is equivalent
          to `ALL(MASK)'.  If the rank is greater than one, then
          `ALL(MASK,DIM)' is determined by applying `ALL' to the array
          sections.

_Example_:
          program test_all
            logical l
            l = all((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, all(a .eq. b, 1)
                print *, all(a .eq. b, 2)
              end subroutine section
          end program test_all


File: gfortran.info,  Node: ALLOCATED,  Next: AND,  Prev: ALL,  Up: Intrinsic Procedures

7.14 `ALLOCATED' -- Status of an allocatable entity
===================================================

_Description_:
     `ALLOCATED(ARRAY)' checks the status of whether X is allocated.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ALLOCATED(ARRAY)'

_Arguments_:
     ARRAY      The argument shall be an `ALLOCATABLE' array.

_Return value_:
     The return value is a scalar `LOGICAL' with the default logical
     kind type parameter.  If ARRAY is allocated, `ALLOCATED(ARRAY)' is
     `.TRUE.'; otherwise, it returns `.FALSE.'

_Example_:
          program test_allocated
            integer :: i = 4
            real(4), allocatable :: x(:)
            if (.not. allocated(x)) allocate(x(i))
          end program test_allocated


File: gfortran.info,  Node: AND,  Next: ANINT,  Prev: ALLOCATED,  Up: Intrinsic Procedures

7.15 `AND' -- Bitwise logical AND
=================================

_Description_:
     Bitwise logical `AND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IAND:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = AND(I, J)'

_Arguments_:
     I          The type shall be either a scalar `INTEGER'
                type or a scalar `LOGICAL' type.
     J          The type shall be the same as the type of I.

_Return value_:
     The return type is either a scalar `INTEGER' or a scalar
     `LOGICAL'.  If the kind type parameters differ, then the smaller
     kind type is implicitly converted to larger kind, and the return
     has the larger kind.

_Example_:
          PROGRAM test_and
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) AND(T, T), AND(T, F), AND(F, T), AND(F, F)
            WRITE (*,*) AND(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IAND::


File: gfortran.info,  Node: ANINT,  Next: ANY,  Prev: AND,  Up: Intrinsic Procedures

7.16 `ANINT' -- Nearest whole number
====================================

_Description_:
     `ANINT(A [, KIND])' rounds its argument to the nearest whole
     number.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ANINT(A [, KIND])'

_Arguments_:
     A          The type of the argument shall be `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type real with the kind type parameter of
     the argument if the optional KIND is absent; otherwise, the kind
     type parameter will be given by KIND.  If A is greater than zero,
     `ANINT(A)' returns `AINT(X+0.5)'.  If A is less than or equal to
     zero then it returns `AINT(X-0.5)'.

_Example_:
          program test_anint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, anint(x4), dnint(x8)
            x8 = anint(x4,8)
          end program test_anint

_Specific names_:
     Name          Argument      Return type   Standard
     `DNINT(A)'    `REAL(8) A'   `REAL(8)'     Fortran 77 and
                                               later


File: gfortran.info,  Node: ANY,  Next: ASIN,  Prev: ANINT,  Up: Intrinsic Procedures

7.17 `ANY' -- Any value in MASK along DIM is true
=================================================

_Description_:
     `ANY(MASK [, DIM])' determines if any of the values in the logical
     array MASK along dimension DIM are `.TRUE.'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = ANY(MASK [, DIM])'

_Arguments_:
     MASK       The type of the argument shall be `LOGICAL' and
                it shall not be scalar.
     DIM        (Optional) DIM shall be a scalar integer with
                a value that lies between one and the rank of
                MASK.

_Return value_:
     `ANY(MASK)' returns a scalar value of type `LOGICAL' where the
     kind type parameter is the same as the kind type parameter of
     MASK.  If DIM is present, then `ANY(MASK, DIM)' returns an array
     with the rank of MASK minus 1.  The shape is determined from the
     shape of MASK where the DIM dimension is elided.

    (A)
          `ANY(MASK)' is true if any element of MASK is true;
          otherwise, it is false.  It also is false if MASK has zero
          size.

    (B)
          If the rank of MASK is one, then `ANY(MASK,DIM)' is equivalent
          to `ANY(MASK)'.  If the rank is greater than one, then
          `ANY(MASK,DIM)' is determined by applying `ANY' to the array
          sections.

_Example_:
          program test_any
            logical l
            l = any((/.true., .true., .true./))
            print *, l
            call section
            contains
              subroutine section
                integer a(2,3), b(2,3)
                a = 1
                b = 1
                b(2,2) = 2
                print *, any(a .eq. b, 1)
                print *, any(a .eq. b, 2)
              end subroutine section
          end program test_any


File: gfortran.info,  Node: ASIN,  Next: ASINH,  Prev: ANY,  Up: Intrinsic Procedures

7.18 `ASIN' -- Arcsine function
===============================

_Description_:
     `ASIN(X)' computes the arcsine of its X (inverse of `SIN(X)').

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ASIN(X)'

_Arguments_:
     X          The type shall be `REAL', and a magnitude that
                is less than or equal to one.

_Return value_:
     The return value is of type `REAL' and it lies in the range -\pi /
     2 \leq \asin (x) \leq \pi / 2.  The kind type parameter is the
     same as X.

_Example_:
          program test_asin
            real(8) :: x = 0.866_8
            x = asin(x)
          end program test_asin

_Specific names_:
     Name          Argument      Return type   Standard
     `DASIN(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later

_See also_:
     Inverse function: *note SIN::



File: gfortran.info,  Node: ASINH,  Next: ASSOCIATED,  Prev: ASIN,  Up: Intrinsic Procedures

7.19 `ASINH' -- Hyperbolic arcsine function
===========================================

_Description_:
     `ASINH(X)' computes the hyperbolic arcsine of X (inverse of
     `SINH(X)').

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ASINH(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value is of the same type and kind as  X.

_Example_:
          PROGRAM test_asinh
            REAL(8), DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ASINH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DASINH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension.

_See also_:
     Inverse function: *note SINH::


File: gfortran.info,  Node: ASSOCIATED,  Next: ATAN,  Prev: ASINH,  Up: Intrinsic Procedures

7.20 `ASSOCIATED' -- Status of a pointer or pointer/target pair
===============================================================

_Description_:
     `ASSOCIATED(POINTER [, TARGET])' determines the status of the
     pointer POINTER or if POINTER is associated with the target TARGET.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = ASSOCIATED(POINTER [, TARGET])'

_Arguments_:
     POINTER    POINTER shall have the `POINTER' attribute and
                it can be of any type.
     TARGET     (Optional) TARGET shall be a pointer or a
                target.  It must have the same type, kind type
                parameter, and array rank as POINTER.
     The association status of neither POINTER nor TARGET shall be
     undefined.

_Return value_:
     `ASSOCIATED(POINTER)' returns a scalar value of type `LOGICAL(4)'.
     There are several cases:
    (A) When the optional TARGET is not present then
          `ASSOCIATED(POINTER)' is true if POINTER is associated with a
          target; otherwise, it returns false.

    (B) If TARGET is present and a scalar target, the result is true if
          TARGET is not a zero-sized storage sequence and the target
          associated with POINTER occupies the same storage units.  If
          POINTER is disassociated, the result is false.

    (C) If TARGET is present and an array target, the result is true if
          TARGET and POINTER have the same shape, are not zero-sized
          arrays, are arrays whose elements are not zero-sized storage
          sequences, and TARGET and POINTER occupy the same storage
          units in array element order.  As in case(B), the result is
          false, if POINTER is disassociated.

    (D) If TARGET is present and an scalar pointer, the result is true
          if TARGET is associated with POINTER, the target associated
          with TARGET are not zero-sized storage sequences and occupy
          the same storage units.  The result is false, if either
          TARGET or POINTER is disassociated.

    (E) If TARGET is present and an array pointer, the result is true if
          target associated with POINTER and the target associated with
          TARGET have the same shape, are not zero-sized arrays, are
          arrays whose elements are not zero-sized storage sequences,
          and TARGET and POINTER occupy the same storage units in array
          element order.  The result is false, if either TARGET or
          POINTER is disassociated.

_Example_:
          program test_associated
             implicit none
             real, target  :: tgt(2) = (/1., 2./)
             real, pointer :: ptr(:)
             ptr => tgt
             if (associated(ptr)     .eqv. .false.) call abort
             if (associated(ptr,tgt) .eqv. .false.) call abort
          end program test_associated

_See also_:
     *note NULL::


File: gfortran.info,  Node: ATAN,  Next: ATAN2,  Prev: ASSOCIATED,  Up: Intrinsic Procedures

7.21 `ATAN' -- Arctangent function
==================================

_Description_:
     `ATAN(X)' computes the arctangent of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATAN(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' and it lies in the range  - \pi
     / 2 \leq \atan (x) \leq \pi / 2.

_Example_:
          program test_atan
            real(8) :: x = 2.866_8
            x = atan(x)
          end program test_atan

_Specific names_:
     Name          Argument      Return type   Standard
     `DATAN(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later

_See also_:
     Inverse function: *note TAN::



File: gfortran.info,  Node: ATAN2,  Next: ATANH,  Prev: ATAN,  Up: Intrinsic Procedures

7.22 `ATAN2' -- Arctangent function
===================================

_Description_:
     `ATAN2(Y, X)' computes the arctangent of the complex number X + i
     Y.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATAN2(Y, X)'

_Arguments_:
     Y          The type shall be `REAL'.
     X          The type and kind type parameter shall be the
                same as Y.  If Y is zero, then X must be
                nonzero.

_Return value_:
     The return value has the same type and kind type parameter as Y.
     It is the principal value of the complex number X + i Y.  If X is
     nonzero, then it lies in the range -\pi \le \atan (x) \leq \pi.
     The sign is positive if Y is positive.  If Y is zero, then the
     return value is zero if X is positive and \pi if X is negative.
     Finally, if X is zero, then the magnitude of the result is \pi/2.

_Example_:
          program test_atan2
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = atan2(y,x)
          end program test_atan2

_Specific names_:
     Name          Argument      Return type   Standard
     `DATAN2(X)'   `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later


File: gfortran.info,  Node: ATANH,  Next: BESSEL_J0,  Prev: ATAN2,  Up: Intrinsic Procedures

7.23 `ATANH' -- Hyperbolic arctangent function
==============================================

_Description_:
     `ATANH(X)' computes the hyperbolic arctangent of X (inverse of
     `TANH(X)').

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ATANH(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          PROGRAM test_atanh
            REAL, DIMENSION(3) :: x = (/ -1.0, 0.0, 1.0 /)
            WRITE (*,*) ATANH(x)
          END PROGRAM

_Specific names_:
     Name          Argument      Return type   Standard
     `DATANH(X)'   `REAL(8) X'   `REAL(8)'     GNU extension

_See also_:
     Inverse function: *note TANH::


File: gfortran.info,  Node: BESSEL_J0,  Next: BESSEL_J1,  Prev: ATANH,  Up: Intrinsic Procedures

7.24 `BESSEL_J0' -- Bessel function of the first kind of order 0
================================================================

_Description_:
     `BESSEL_J0(X)' computes the Bessel function of the first kind of
     order 0 of X. This function is available under the name `BESJ0' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_J0(X)'

_Arguments_:
     X          The type shall be `REAL', and it shall be
                scalar.

_Return value_:
     The return value is of type `REAL' and lies in the range  -
     0.4027... \leq Bessel (0,x) \leq 1. It has the same kind as X.

_Example_:
          program test_besj0
            real(8) :: x = 0.0_8
            x = bessel_j0(x)
          end program test_besj0

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJ0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESSEL_J1,  Next: BESSEL_JN,  Prev: BESSEL_J0,  Up: Intrinsic Procedures

7.25 `BESSEL_J1' -- Bessel function of the first kind of order 1
================================================================

_Description_:
     `BESSEL_J1(X)' computes the Bessel function of the first kind of
     order 1 of X. This function is available under the name `BESJ1' as
     a GNU extension.

_Standard_:
     Fortran 2008

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_J1(X)'

_Arguments_:
     X          The type shall be `REAL', and it shall be
                scalar.

_Return value_:
     The return value is of type `REAL' and it lies in the range  -
     0.5818... \leq Bessel (0,x) \leq 0.5818 . It has the same kind as
     X.

_Example_:
          program test_besj1
            real(8) :: x = 1.0_8
            x = bessel_j1(x)
          end program test_besj1

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJ1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESSEL_JN,  Next: BESSEL_Y0,  Prev: BESSEL_J1,  Up: Intrinsic Procedures

7.26 `BESSEL_JN' -- Bessel function of the first kind
=====================================================

_Description_:
     `BESSEL_JN(N, X)' computes the Bessel function of the first kind of
     order N of X. This function is available under the name `BESJN' as
     a GNU extension.

     If both arguments are arrays, their ranks and shapes shall conform.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_JN(N, X)'

_Arguments_:
     N          Shall be a scalar or an array of type
                `INTEGER'.
     X          Shall be a scalar or an array of type  `REAL'.

_Return value_:
     The return value is a scalar of type `REAL'. It has the same kind
     as X.

_Example_:
          program test_besjn
            real(8) :: x = 1.0_8
            x = bessel_jn(5,x)
          end program test_besjn

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESJN(X)'   `INTEGER N'   `REAL(8)'     GNU extension
                   `REAL(8) X'                 


File: gfortran.info,  Node: BESSEL_Y0,  Next: BESSEL_Y1,  Prev: BESSEL_JN,  Up: Intrinsic Procedures

7.27 `BESSEL_Y0' -- Bessel function of the second kind of order 0
=================================================================

_Description_:
     `BESSEL_Y0(X)' computes the Bessel function of the second kind of
     order 0 of X. This function is available under the name `BESY0' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_Y0(X)'

_Arguments_:
     X          The type shall be `REAL', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL'. It has the same kind
     as X.

_Example_:
          program test_besy0
            real(8) :: x = 0.0_8
            x = bessel_y0(x)
          end program test_besy0

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESY0(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESSEL_Y1,  Next: BESSEL_YN,  Prev: BESSEL_Y0,  Up: Intrinsic Procedures

7.28 `BESSEL_Y1' -- Bessel function of the second kind of order 1
=================================================================

_Description_:
     `BESSEL_Y1(X)' computes the Bessel function of the second kind of
     order 1 of X. This function is available under the name `BESY1' as
     a GNU extension.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_Y1(X)'

_Arguments_:
     X          The type shall be `REAL', and it shall be
                scalar.

_Return value_:
     The return value is a scalar of type `REAL'. It has the same kind
     as X.

_Example_:
          program test_besy1
            real(8) :: x = 1.0_8
            x = bessel_y1(x)
          end program test_besy1

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESY1(X)'   `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: BESSEL_YN,  Next: BIT_SIZE,  Prev: BESSEL_Y1,  Up: Intrinsic Procedures

7.29 `BESSEL_YN' -- Bessel function of the second kind
======================================================

_Description_:
     `BESSEL_YN(N, X)' computes the Bessel function of the second kind
     of order N of X. This function is available under the name `BESYN'
     as a GNU extension.

     If both arguments are arrays, their ranks and shapes shall conform.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BESSEL_YN(N, X)'

_Arguments_:
     N          Shall be a scalar or an array of type
                `INTEGER'.
     X          Shall be a scalar or an array of type  `REAL'.

_Return value_:
     The return value is a scalar of type `REAL'. It has the same kind
     as X.

_Example_:
          program test_besyn
            real(8) :: x = 1.0_8
            x = bessel_yn(5,x)
          end program test_besyn

_Specific names_:
     Name          Argument      Return type   Standard
     `DBESYN(N,X)' `INTEGER N'   `REAL(8)'     GNU extension
                   `REAL(8)                    
                   X'                          


File: gfortran.info,  Node: BIT_SIZE,  Next: BTEST,  Prev: BESSEL_YN,  Up: Intrinsic Procedures

7.30 `BIT_SIZE' -- Bit size inquiry function
============================================

_Description_:
     `BIT_SIZE(I)' returns the number of bits (integer precision plus
     sign bit) represented by the type of I.  The result of
     `BIT_SIZE(I)' is independent of the actual value of I.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = BIT_SIZE(I)'

_Arguments_:
     I          The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER'

_Example_:
          program test_bit_size
              integer :: i = 123
              integer :: size
              size = bit_size(i)
              print *, size
          end program test_bit_size


File: gfortran.info,  Node: BTEST,  Next: C_ASSOCIATED,  Prev: BIT_SIZE,  Up: Intrinsic Procedures

7.31 `BTEST' -- Bit test function
=================================

_Description_:
     `BTEST(I,POS)' returns logical `.TRUE.' if the bit at POS in I is
     set.  The counting of the bits starts at 0.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = BTEST(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER'.
     POS        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `LOGICAL'

_Example_:
          program test_btest
              integer :: i = 32768 + 1024 + 64
              integer :: pos
              logical :: bool
              do pos=0,16
                  bool = btest(i, pos)
                  print *, pos, bool
              end do
          end program test_btest


File: gfortran.info,  Node: C_ASSOCIATED,  Next: C_F_POINTER,  Prev: BTEST,  Up: Intrinsic Procedures

7.32 `C_ASSOCIATED' -- Status of a C pointer
============================================

_Description_:
     `C_ASSOCIATED(c_prt_1[, c_ptr_2])' determines the status of the C
     pointer C_PTR_1 or if C_PTR_1 is associated with the target
     C_PTR_2.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = C_ASSOCIATED(c_prt_1[, c_ptr_2])'

_Arguments_:
     C_PTR_1    Scalar of the type `C_PTR' or `C_FUNPTR'.
     C_PTR_2    (Optional) Scalar of the same type as C_PTR_1.

_Return value_:
     The return value is of type `LOGICAL'; it is `.false.' if either
     C_PTR_1 is a C NULL pointer or if C_PTR1 and C_PTR_2 point to
     different addresses.

_Example_:
          subroutine association_test(a,b)
            use iso_c_binding, only: c_associated, c_loc, c_ptr
            implicit none
            real, pointer :: a
            type(c_ptr) :: b
            if(c_associated(b, c_loc(a))) &
               stop 'b and a do not point to same target'
          end subroutine association_test

_See also_:
     *note C_LOC::, *note C_FUNLOC::


File: gfortran.info,  Node: C_FUNLOC,  Next: C_LOC,  Prev: C_F_PROCPOINTER,  Up: Intrinsic Procedures

7.33 `C_FUNLOC' -- Obtain the C address of a procedure
======================================================

_Description_:
     `C_FUNLOC(x)' determines the C address of the argument.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = C_FUNLOC(x)'

_Arguments_:
     X          Interoperable function or pointer to such
                function.

_Return value_:
     The return value is of type `C_FUNPTR' and contains the C address
     of the argument.

_Example_:
          module x
            use iso_c_binding
            implicit none
          contains
            subroutine sub(a) bind(c)
              real(c_float) :: a
              a = sqrt(a)+5.0
            end subroutine sub
          end module x
          program main
            use iso_c_binding
            use x
            implicit none
            interface
              subroutine my_routine(p) bind(c,name='myC_func')
                import :: c_funptr
                type(c_funptr), intent(in) :: p
              end subroutine
            end interface
            call my_routine(c_funloc(sub))
          end program main

_See also_:
     *note C_ASSOCIATED::, *note C_LOC::, *note C_F_POINTER::, *note
     C_F_PROCPOINTER::


File: gfortran.info,  Node: C_F_PROCPOINTER,  Next: C_FUNLOC,  Prev: C_F_POINTER,  Up: Intrinsic Procedures

7.34 `C_F_PROCPOINTER' -- Convert C into Fortran procedure pointer
==================================================================

_Description_:
     `C_F_PROCPOINTER(CPTR, FPTR)' Assign the target of the C function
     pointer CPTR to the Fortran procedure pointer FPTR.

     Note: Due to the currently lacking support of procedure pointers
     in GNU Fortran this function is not fully operable.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL C_F_PROCPOINTER(cptr, fptr)'

_Arguments_:
     CPTR       scalar of the type `C_FUNPTR'. It is
                `INTENT(IN)'.
     FPTR       procedure pointer interoperable with CPTR. It
                is `INTENT(OUT)'.

_Example_:
          program main
            use iso_c_binding
            implicit none
            abstract interface
              function func(a)
                import :: c_float
                real(c_float), intent(in) :: a
                real(c_float) :: func
              end function
            end interface
            interface
               function getIterFunc() bind(c,name="getIterFunc")
                 import :: c_funptr
                 type(c_funptr) :: getIterFunc
               end function
            end interface
            type(c_funptr) :: cfunptr
            procedure(func), pointer :: myFunc
            cfunptr = getIterFunc()
            call c_f_procpointer(cfunptr, myFunc)
          end program main

_See also_:
     *note C_LOC::, *note C_F_POINTER::


File: gfortran.info,  Node: C_F_POINTER,  Next: C_F_PROCPOINTER,  Prev: C_ASSOCIATED,  Up: Intrinsic Procedures

7.35 `C_F_POINTER' -- Convert C into Fortran pointer
====================================================

_Description_:
     `C_F_POINTER(CPTR, FPTR[, SHAPE])' Assign the target the C pointer
     CPTR to the Fortran pointer FPTR and specify its shape.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL C_F_POINTER(CPTR, FPTR[, SHAPE])'

_Arguments_:
     CPTR       scalar of the type `C_PTR'. It is `INTENT(IN)'.
     FPTR       pointer interoperable with CPTR. It is
                `INTENT(OUT)'.
     SHAPE      (Optional) Rank-one array of type `INTEGER'
                with `INTENT(IN)'. It shall be present if and
                only if FPTR is an array. The size must be
                equal to the rank of FPTR.

_Example_:
          program main
            use iso_c_binding
            implicit none
            interface
              subroutine my_routine(p) bind(c,name='myC_func')
                import :: c_ptr
                type(c_ptr), intent(out) :: p
              end subroutine
            end interface
            type(c_ptr) :: cptr
            real,pointer :: a(:)
            call my_routine(cptr)
            call c_f_pointer(cptr, a, [12])
          end program main

_See also_:
     *note C_LOC::, *note C_F_PROCPOINTER::


File: gfortran.info,  Node: C_LOC,  Next: C_SIZEOF,  Prev: C_FUNLOC,  Up: Intrinsic Procedures

7.36 `C_LOC' -- Obtain the C address of an object
=================================================

_Description_:
     `C_LOC(X)' determines the C address of the argument.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = C_LOC(X)'

_Arguments_:
     X          Associated scalar pointer or interoperable
                scalar or allocated allocatable variable with
                `TARGET' attribute.

_Return value_:
     The return value is of type `C_PTR' and contains the C address of
     the argument.

_Example_:
          subroutine association_test(a,b)
            use iso_c_binding, only: c_associated, c_loc, c_ptr
            implicit none
            real, pointer :: a
            type(c_ptr) :: b
            if(c_associated(b, c_loc(a))) &
               stop 'b and a do not point to same target'
          end subroutine association_test

_See also_:
     *note C_ASSOCIATED::, *note C_FUNLOC::, *note C_F_POINTER::, *note
     C_F_PROCPOINTER::


File: gfortran.info,  Node: C_SIZEOF,  Next: CEILING,  Prev: C_LOC,  Up: Intrinsic Procedures

7.37 `C_SIZEOF' -- Size in bytes of an expression
=================================================

_Description_:
     `C_SIZEOF(X)' calculates the number of bytes of storage the
     expression `X' occupies.

_Standard_:
     Fortran 2008

_Class_:
     Intrinsic function

_Syntax_:
     `N = C_SIZEOF(X)'

_Arguments_:
     X          The argument shall be of any type, rank or
                shape.

_Return value_:
     The return value is of type integer and of the system-dependent
     kind C_SIZE_T (from the ISO_C_BINDING module). Its value is the
     number of bytes occupied by the argument.  If the argument has the
     `POINTER' attribute, the number of bytes of the storage area
     pointed to is returned.  If the argument is of a derived type with
     `POINTER' or `ALLOCATABLE' components, the return value doesn't
     account for the sizes of the data pointed to by these components.

_Example_:
             use iso_c_binding
             integer(c_int) :: i
             real(c_float) :: r, s(5)
             print *, (c_sizeof(s)/c_sizeof(r) == 5)
             end
     The example will print `.TRUE.' unless you are using a platform
     where default `REAL' variables are unusually padded.

_See also_:
     *note SIZEOF::


File: gfortran.info,  Node: CEILING,  Next: CHAR,  Prev: C_SIZEOF,  Up: Intrinsic Procedures

7.38 `CEILING' -- Integer ceiling function
==========================================

_Description_:
     `CEILING(A)' returns the least integer greater than or equal to A.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CEILING(A [, KIND])'

_Arguments_:
     A          The type shall be `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER(KIND)' if KIND is present and
     a default-kind `INTEGER' otherwise.

_Example_:
          program test_ceiling
              real :: x = 63.29
              real :: y = -63.59
              print *, ceiling(x) ! returns 64
              print *, ceiling(y) ! returns -63
          end program test_ceiling

_See also_:
     *note FLOOR::, *note NINT::



File: gfortran.info,  Node: CHAR,  Next: CHDIR,  Prev: CEILING,  Up: Intrinsic Procedures

7.39 `CHAR' -- Character conversion function
============================================

_Description_:
     `CHAR(I [, KIND])' returns the character represented by the
     integer I.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CHAR(I [, KIND])'

_Arguments_:
     I          The type shall be `INTEGER'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `CHARACTER(1)'

_Example_:
          program test_char
              integer :: i = 74
              character(1) :: c
              c = char(i)
              print *, i, c ! returns 'J'
          end program test_char

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note ACHAR::, *note IACHAR::, *note ICHAR::



File: gfortran.info,  Node: CHDIR,  Next: CHMOD,  Prev: CHAR,  Up: Intrinsic Procedures

7.40 `CHDIR' -- Change working directory
========================================

_Description_:
     Change current working directory to a specified path.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL CHDIR(NAME [, STATUS])'
     `STATUS = CHDIR(NAME)'

_Arguments_:
     NAME       The type shall be `CHARACTER' of default kind
                and shall specify a valid path within the file
                system.
     STATUS     (Optional) `INTEGER' status flag of the default
                kind.  Returns 0 on success, and a system
                specific and nonzero error code otherwise.

_Example_:
          PROGRAM test_chdir
            CHARACTER(len=255) :: path
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
            CALL chdir("/tmp")
            CALL getcwd(path)
            WRITE(*,*) TRIM(path)
          END PROGRAM

_See also_:
     *note GETCWD::


File: gfortran.info,  Node: CHMOD,  Next: CMPLX,  Prev: CHDIR,  Up: Intrinsic Procedures

7.41 `CHMOD' -- Change access permissions of files
==================================================

_Description_:
     `CHMOD' changes the permissions of a file. This function invokes
     `/bin/chmod' and might therefore not work on all platforms.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL CHMOD(NAME, MODE[, STATUS])'
     `STATUS = CHMOD(NAME, MODE)'

_Arguments_:
     NAME       Scalar `CHARACTER' of default kind with the
                file name. Trailing blanks are ignored unless
                the character `achar(0)' is present, then all
                characters up to and excluding `achar(0)' are
                used as the file name.
     MODE       Scalar `CHARACTER' of default kind giving the
                file permission. MODE uses the same syntax as
                the MODE argument of `/bin/chmod'.
     STATUS     (optional) scalar `INTEGER', which is `0' on
                success and nonzero otherwise.

_Return value_:
     In either syntax, STATUS is set to `0' on success and nonzero
     otherwise.

_Example_:
     `CHMOD' as subroutine
          program chmod_test
            implicit none
            integer :: status
            call chmod('test.dat','u+x',status)
            print *, 'Status: ', status
          end program chmod_test
     `CHMOD' as function:
          program chmod_test
            implicit none
            integer :: status
            status = chmod('test.dat','u+x')
            print *, 'Status: ', status
          end program chmod_test



File: gfortran.info,  Node: CMPLX,  Next: COMMAND_ARGUMENT_COUNT,  Prev: CHMOD,  Up: Intrinsic Procedures

7.42 `CMPLX' -- Complex conversion function
===========================================

_Description_:
     `CMPLX(X [, Y [, KIND]])' returns a complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the
     imaginary component is set to 0.0.  If X is complex then Y must
     not be present.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = CMPLX(X [, Y [, KIND]])'

_Arguments_:
     X          The type may be `INTEGER', `REAL', or
                `COMPLEX'.
     Y          (Optional; only allowed if X is not
                `COMPLEX'.)  May be `INTEGER' or `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of `COMPLEX' type, with a kind equal to KIND
     if it is specified.  If KIND is not specified, the result is of
     the default `COMPLEX' kind, regardless of the kinds of X and Y.

_Example_:
          program test_cmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, z, cmplx(x)
          end program test_cmplx

_See also_:
     *note COMPLEX::


File: gfortran.info,  Node: COMMAND_ARGUMENT_COUNT,  Next: COMPLEX,  Prev: CMPLX,  Up: Intrinsic Procedures

7.43 `COMMAND_ARGUMENT_COUNT' -- Get number of command line arguments
=====================================================================

_Description_:
     `COMMAND_ARGUMENT_COUNT()' returns the number of arguments passed
     on the command line when the containing program was invoked.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = COMMAND_ARGUMENT_COUNT()'

_Arguments_:
     None       

_Return value_:
     The return value is of type `INTEGER(4)'

_Example_:
          program test_command_argument_count
              integer :: count
              count = command_argument_count()
              print *, count
          end program test_command_argument_count

_See also_:
     *note GET_COMMAND::, *note GET_COMMAND_ARGUMENT::


File: gfortran.info,  Node: COMPLEX,  Next: CONJG,  Prev: COMMAND_ARGUMENT_COUNT,  Up: Intrinsic Procedures

7.44 `COMPLEX' -- Complex conversion function
=============================================

_Description_:
     `COMPLEX(X, Y)' returns a complex number where X is converted to
     the real component and Y is converted to the imaginary component.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = COMPLEX(X, Y)'

_Arguments_:
     X          The type may be `INTEGER' or `REAL'.
     Y          The type may be `INTEGER' or `REAL'.

_Return value_:
     If X and Y are both of `INTEGER' type, then the return value is of
     default `COMPLEX' type.

     If X and Y are of `REAL' type, or one is of `REAL' type and one is
     of `INTEGER' type, then the return value is of `COMPLEX' type with
     a kind equal to that of the `REAL' argument with the highest
     precision.

_Example_:
          program test_complex
              integer :: i = 42
              real :: x = 3.14
              print *, complex(i, x)
          end program test_complex

_See also_:
     *note CMPLX::


File: gfortran.info,  Node: CONJG,  Next: COS,  Prev: COMPLEX,  Up: Intrinsic Procedures

7.45 `CONJG' -- Complex conjugate function
==========================================

_Description_:
     `CONJG(Z)' returns the conjugate of Z.  If Z is `(x, y)' then the
     result is `(x, -y)'

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `Z = CONJG(Z)'

_Arguments_:
     Z          The type shall be `COMPLEX'.

_Return value_:
     The return value is of type `COMPLEX'.

_Example_:
          program test_conjg
              complex :: z = (2.0, 3.0)
              complex(8) :: dz = (2.71_8, -3.14_8)
              z= conjg(z)
              print *, z
              dz = dconjg(dz)
              print *, dz
          end program test_conjg

_Specific names_:
     Name          Argument      Return type   Standard
     `DCONJG(Z)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   Z'                          


File: gfortran.info,  Node: COS,  Next: COSH,  Prev: CONJG,  Up: Intrinsic Procedures

7.46 `COS' -- Cosine function
=============================

_Description_:
     `COS(X)' computes the cosine of X.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = COS(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `REAL' and it lies in the range  -1
     \leq \cos (x) \leq 1.  The kind type parameter is the same as X.

_Example_:
          program test_cos
            real :: x = 0.0
            x = cos(x)
          end program test_cos

_Specific names_:
     Name          Argument      Return type   Standard
     `DCOS(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later
     `CCOS(X)'     `COMPLEX(4)   `COMPLEX(4)'  Fortran 77 and
                   X'                          later
     `ZCOS(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDCOS(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          

_See also_:
     Inverse function: *note ACOS::



File: gfortran.info,  Node: COSH,  Next: COUNT,  Prev: COS,  Up: Intrinsic Procedures

7.47 `COSH' -- Hyperbolic cosine function
=========================================

_Description_:
     `COSH(X)' computes the hyperbolic cosine of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `X = COSH(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' and it is positive ( \cosh (x)
     \geq 0 ).  For a `REAL' argument X,  \cosh (x) \geq 1 .  The
     return value is of the same kind as X.

_Example_:
          program test_cosh
            real(8) :: x = 1.0_8
            x = cosh(x)
          end program test_cosh

_Specific names_:
     Name          Argument      Return type   Standard
     `DCOSH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later

_See also_:
     Inverse function: *note ACOSH::



File: gfortran.info,  Node: COUNT,  Next: CPU_TIME,  Prev: COSH,  Up: Intrinsic Procedures

7.48 `COUNT' -- Count function
==============================

_Description_:
     `COUNT(MASK [, DIM [, KIND]])' counts the number of `.TRUE.'
     elements of MASK along the dimension of DIM.  If DIM is omitted it
     is taken to be `1'.  DIM is a scalar of type `INTEGER' in the
     range of 1 /leq DIM /leq n) where n is the rank of MASK.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = COUNT(MASK [, DIM [, KIND]])'

_Arguments_:
     MASK       The type shall be `LOGICAL'.
     DIM        (Optional) The type shall be `INTEGER'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.  The result
     has a rank equal to that of MASK.

_Example_:
          program test_count
              integer, dimension(2,3) :: a, b
              logical, dimension(2,3) :: mask
              a = reshape( (/ 1, 2, 3, 4, 5, 6 /), (/ 2, 3 /))
              b = reshape( (/ 0, 7, 3, 4, 5, 8 /), (/ 2, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print *
              print '(3i3)', b(1,:)
              print '(3i3)', b(2,:)
              print *
              mask = a.ne.b
              print '(3l3)', mask(1,:)
              print '(3l3)', mask(2,:)
              print *
              print '(3i3)', count(mask)
              print *
              print '(3i3)', count(mask, 1)
              print *
              print '(3i3)', count(mask, 2)
          end program test_count


File: gfortran.info,  Node: CPU_TIME,  Next: CSHIFT,  Prev: COUNT,  Up: Intrinsic Procedures

7.49 `CPU_TIME' -- CPU elapsed time in seconds
==============================================

_Description_:
     Returns a `REAL' value representing the elapsed CPU time in
     seconds.  This is useful for testing segments of code to determine
     execution time.

     If a time source is available, time will be reported with
     microsecond resolution. If no time source is available, TIME is
     set to `-1.0'.

     Note that TIME may contain a, system dependent, arbitrary offset
     and may not start with `0.0'. For `CPU_TIME', the absolute value
     is meaningless, only differences between subsequent calls to this
     subroutine, as shown in the example below, should be used.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL CPU_TIME(TIME)'

_Arguments_:
     TIME       The type shall be `REAL' with `INTENT(OUT)'.

_Return value_:
     None

_Example_:
          program test_cpu_time
              real :: start, finish
              call cpu_time(start)
                  ! put code to test here
              call cpu_time(finish)
              print '("Time = ",f6.3," seconds.")',finish-start
          end program test_cpu_time

_See also_:
     *note SYSTEM_CLOCK::, *note DATE_AND_TIME::


File: gfortran.info,  Node: CSHIFT,  Next: CTIME,  Prev: CPU_TIME,  Up: Intrinsic Procedures

7.50 `CSHIFT' -- Circular shift elements of an array
====================================================

_Description_:
     `CSHIFT(ARRAY, SHIFT [, DIM])' performs a circular shift on
     elements of ARRAY along the dimension of DIM.  If DIM is omitted
     it is taken to be `1'.  DIM is a scalar of type `INTEGER' in the
     range of 1 /leq DIM /leq n) where n is the rank of ARRAY.  If the
     rank of ARRAY is one, then all elements of ARRAY are shifted by
     SHIFT places.  If rank is greater than one, then all complete rank
     one sections of ARRAY along the given dimension are shifted.
     Elements shifted out one end of each rank one section are shifted
     back in the other end.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = CSHIFT(ARRAY, SHIFT [, DIM])'

_Arguments_:
     ARRAY      Shall be an array of any type.
     SHIFT      The type shall be `INTEGER'.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_cshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = cshift(a, SHIFT=(/1, 2, -1/), DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_cshift


File: gfortran.info,  Node: CTIME,  Next: DATE_AND_TIME,  Prev: CSHIFT,  Up: Intrinsic Procedures

7.51 `CTIME' -- Convert a time into a string
============================================

_Description_:
     `CTIME' converts a system time value, such as returned by
     `TIME8()', to a string of the form `Sat Aug 19 18:13:14 1995'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL CTIME(TIME, RESULT)'.
     `RESULT = CTIME(TIME)', (not recommended).

_Arguments_:
     TIME       The type shall be of type `INTEGER(KIND=8)'.
     RESULT     The type shall be of type `CHARACTER' and of
                default kind.

_Return value_:
     The converted date and time as a string.

_Example_:
          program test_ctime
              integer(8) :: i
              character(len=30) :: date
              i = time8()

              ! Do something, main part of the program

              call ctime(i,date)
              print *, 'Program was started on ', date
          end program test_ctime

_See Also_:
     *note GMTIME::, *note LTIME::, *note TIME::, *note TIME8::


File: gfortran.info,  Node: DATE_AND_TIME,  Next: DBLE,  Prev: CTIME,  Up: Intrinsic Procedures

7.52 `DATE_AND_TIME' -- Date and time subroutine
================================================

_Description_:
     `DATE_AND_TIME(DATE, TIME, ZONE, VALUES)' gets the corresponding
     date and time information from the real-time system clock.  DATE is
     `INTENT(OUT)' and has form ccyymmdd.  TIME is `INTENT(OUT)' and
     has form hhmmss.sss.  ZONE is `INTENT(OUT)' and has form (+-)hhmm,
     representing the difference with respect to Coordinated Universal
     Time (UTC).  Unavailable time and date parameters return blanks.

     VALUES is `INTENT(OUT)' and provides the following:

                `VALUE(1)':          The year
                `VALUE(2)':          The month
                `VALUE(3)':          The day of the month
                `VALUE(4)':          Time difference with UTC
                                     in minutes
                `VALUE(5)':          The hour of the day
                `VALUE(6)':          The minutes of the hour
                `VALUE(7)':          The seconds of the minute
                `VALUE(8)':          The milliseconds of the
                                     second

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL DATE_AND_TIME([DATE, TIME, ZONE, VALUES])'

_Arguments_:
     DATE       (Optional) The type shall be `CHARACTER(LEN=8)'
                or larger, and of default kind.
     TIME       (Optional) The type shall be
                `CHARACTER(LEN=10)' or larger, and of default
                kind.
     ZONE       (Optional) The type shall be `CHARACTER(LEN=5)'
                or larger, and of default kind.
     VALUES     (Optional) The type shall be `INTEGER(8)'.

_Return value_:
     None

_Example_:
          program test_time_and_date
              character(8)  :: date
              character(10) :: time
              character(5)  :: zone
              integer,dimension(8) :: values
              ! using keyword arguments
              call date_and_time(date,time,zone,values)
              call date_and_time(DATE=date,ZONE=zone)
              call date_and_time(TIME=time)
              call date_and_time(VALUES=values)
              print '(a,2x,a,2x,a)', date, time, zone
              print '(8i5))', values
          end program test_time_and_date

_See also_:
     *note CPU_TIME::, *note SYSTEM_CLOCK::


File: gfortran.info,  Node: DBLE,  Next: DCMPLX,  Prev: DATE_AND_TIME,  Up: Intrinsic Procedures

7.53 `DBLE' -- Double conversion function
=========================================

_Description_:
     `DBLE(A)' Converts A to double precision real type.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DBLE(A)'

_Arguments_:
     A          The type shall be `INTEGER', `REAL', or
                `COMPLEX'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dble
              real    :: x = 2.18
              integer :: i = 5
              complex :: z = (2.3,1.14)
              print *, dble(x), dble(i), dble(z)
          end program test_dble

_See also_:
     *note DFLOAT::, *note FLOAT::, *note REAL::


File: gfortran.info,  Node: DCMPLX,  Next: DFLOAT,  Prev: DBLE,  Up: Intrinsic Procedures

7.54 `DCMPLX' -- Double complex conversion function
===================================================

_Description_:
     `DCMPLX(X [,Y])' returns a double complex number where X is
     converted to the real component.  If Y is present it is converted
     to the imaginary component.  If Y is not present then the
     imaginary component is set to 0.0.  If X is complex then Y must
     not be present.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DCMPLX(X [, Y])'

_Arguments_:
     X          The type may be `INTEGER', `REAL', or
                `COMPLEX'.
     Y          (Optional if X is not `COMPLEX'.) May be
                `INTEGER' or `REAL'.

_Return value_:
     The return value is of type `COMPLEX(8)'

_Example_:
          program test_dcmplx
              integer :: i = 42
              real :: x = 3.14
              complex :: z
              z = cmplx(i, x)
              print *, dcmplx(i)
              print *, dcmplx(x)
              print *, dcmplx(z)
              print *, dcmplx(x,i)
          end program test_dcmplx


File: gfortran.info,  Node: DFLOAT,  Next: DIGITS,  Prev: DCMPLX,  Up: Intrinsic Procedures

7.55 `DFLOAT' -- Double conversion function
===========================================

_Description_:
     `DFLOAT(A)' Converts A to double precision real type.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DFLOAT(A)'

_Arguments_:
     A          The type shall be `INTEGER'.

_Return value_:
     The return value is of type double precision real.

_Example_:
          program test_dfloat
              integer :: i = 5
              print *, dfloat(i)
          end program test_dfloat

_See also_:
     *note DBLE::, *note FLOAT::, *note REAL::


File: gfortran.info,  Node: DIGITS,  Next: DIM,  Prev: DFLOAT,  Up: Intrinsic Procedures

7.56 `DIGITS' -- Significant binary digits function
===================================================

_Description_:
     `DIGITS(X)' returns the number of significant binary digits of the
     internal model representation of X.  For example, on a system
     using a 32-bit floating point representation, a default real
     number would likely return 24.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = DIGITS(X)'

_Arguments_:
     X          The type may be `INTEGER' or `REAL'.

_Return value_:
     The return value is of type `INTEGER'.

_Example_:
          program test_digits
              integer :: i = 12345
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, digits(i)
              print *, digits(x)
              print *, digits(y)
          end program test_digits


File: gfortran.info,  Node: DIM,  Next: DOT_PRODUCT,  Prev: DIGITS,  Up: Intrinsic Procedures

7.57 `DIM' -- Positive difference
=================================

_Description_:
     `DIM(X,Y)' returns the difference `X-Y' if the result is positive;
     otherwise returns zero.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DIM(X, Y)'

_Arguments_:
     X          The type shall be `INTEGER' or `REAL'
     Y          The type shall be the same type and kind as X.

_Return value_:
     The return value is of type `INTEGER' or `REAL'.

_Example_:
          program test_dim
              integer :: i
              real(8) :: x
              i = dim(4, 15)
              x = dim(4.345_8, 2.111_8)
              print *, i
              print *, x
          end program test_dim

_Specific names_:
     Name          Argument      Return type   Standard
     `IDIM(X,Y)'   `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
                   X,Y'                        later
     `DDIM(X,Y)'   `REAL(8)      `REAL(8)'     Fortran 77 and
                   X,Y'                        later


File: gfortran.info,  Node: DOT_PRODUCT,  Next: DPROD,  Prev: DIM,  Up: Intrinsic Procedures

7.58 `DOT_PRODUCT' -- Dot product function
==========================================

_Description_:
     `DOT_PRODUCT(VECTOR_A, VECTOR_B)' computes the dot product
     multiplication of two vectors VECTOR_A and VECTOR_B.  The two
     vectors may be either numeric or logical and must be arrays of
     rank one and of equal size. If the vectors are `INTEGER' or
     `REAL', the result is `SUM(VECTOR_A*VECTOR_B)'. If the vectors are
     `COMPLEX', the result is `SUM(CONJG(VECTOR_A)*VECTOR_B)'. If the
     vectors are `LOGICAL', the result is `ANY(VECTOR_A .AND.
     VECTOR_B)'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = DOT_PRODUCT(VECTOR_A, VECTOR_B)'

_Arguments_:
     VECTOR_A   The type shall be numeric or `LOGICAL', rank 1.
     VECTOR_B   The type shall be numeric if VECTOR_A is of
                numeric type or `LOGICAL' if VECTOR_A is of
                type `LOGICAL'. VECTOR_B shall be a rank-one
                array.

_Return value_:
     If the arguments are numeric, the return value is a scalar of
     numeric type, `INTEGER', `REAL', or `COMPLEX'.  If the arguments
     are `LOGICAL', the return value is `.TRUE.' or `.FALSE.'.

_Example_:
          program test_dot_prod
              integer, dimension(3) :: a, b
              a = (/ 1, 2, 3 /)
              b = (/ 4, 5, 6 /)
              print '(3i3)', a
              print *
              print '(3i3)', b
              print *
              print *, dot_product(a,b)
          end program test_dot_prod


File: gfortran.info,  Node: DPROD,  Next: DREAL,  Prev: DOT_PRODUCT,  Up: Intrinsic Procedures

7.59 `DPROD' -- Double product function
=======================================

_Description_:
     `DPROD(X,Y)' returns the product `X*Y'.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DPROD(X, Y)'

_Arguments_:
     X          The type shall be `REAL'.
     Y          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dprod
              real :: x = 5.2
              real :: y = 2.3
              real(8) :: d
              d = dprod(x,y)
              print *, d
          end program test_dprod


File: gfortran.info,  Node: DREAL,  Next: DTIME,  Prev: DPROD,  Up: Intrinsic Procedures

7.60 `DREAL' -- Double real part function
=========================================

_Description_:
     `DREAL(Z)' returns the real part of complex variable Z.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = DREAL(A)'

_Arguments_:
     A          The type shall be `COMPLEX(8)'.

_Return value_:
     The return value is of type `REAL(8)'.

_Example_:
          program test_dreal
              complex(8) :: z = (1.3_8,7.2_8)
              print *, dreal(z)
          end program test_dreal

_See also_:
     *note AIMAG::



File: gfortran.info,  Node: DTIME,  Next: EOSHIFT,  Prev: DREAL,  Up: Intrinsic Procedures

7.61 `DTIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `DTIME(TARRAY, RESULT)' initially returns the number of seconds of
     runtime since the start of the process's execution in RESULT.
     TARRAY returns the user and system components of this time in
     `TARRAY(1)' and `TARRAY(2)' respectively. RESULT is equal to
     `TARRAY(1) + TARRAY(2)'.

     Subsequent invocations of `DTIME' return values accumulated since
     the previous invocation.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wrap around)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     Please note, that this implementation is thread safe if used
     within OpenMP directives, i.e., its state will be consistent while
     called from multiple threads. However, if `DTIME' is called from
     multiple threads, the result is still the time since the last
     invocation. This may not give the intended results. If possible,
     use `CPU_TIME' instead.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in
                                     seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL DTIME(TARRAY, RESULT)'.
     `RESULT = DTIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the last invocation or since the
     start of program execution if not called before.

_Example_:
          program test_dtime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call dtime(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_dtime

_See also_:
     *note CPU_TIME::



File: gfortran.info,  Node: EOSHIFT,  Next: EPSILON,  Prev: DTIME,  Up: Intrinsic Procedures

7.62 `EOSHIFT' -- End-off shift elements of an array
====================================================

_Description_:
     `EOSHIFT(ARRAY, SHIFT[, BOUNDARY, DIM])' performs an end-off shift
     on elements of ARRAY along the dimension of DIM.  If DIM is
     omitted it is taken to be `1'.  DIM is a scalar of type `INTEGER'
     in the range of 1 /leq DIM /leq n) where n is the rank of ARRAY.
     If the rank of ARRAY is one, then all elements of ARRAY are
     shifted by SHIFT places.  If rank is greater than one, then all
     complete rank one sections of ARRAY along the given dimension are
     shifted.  Elements shifted out one end of each rank one section
     are dropped.  If BOUNDARY is present then the corresponding value
     of from BOUNDARY is copied back in the other end.  If BOUNDARY is
     not present then the following are copied in depending on the type
     of ARRAY.

     _Array     _Boundary Value_
     Type_      
     Numeric    0 of the type and kind of ARRAY.
     Logical    `.FALSE.'.
     Character(LEN)LEN blanks.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = EOSHIFT(ARRAY, SHIFT [, BOUNDARY, DIM])'

_Arguments_:
     ARRAY      May be any type, not scalar.
     SHIFT      The type shall be `INTEGER'.
     BOUNDARY   Same type as ARRAY.
     DIM        The type shall be `INTEGER'.

_Return value_:
     Returns an array of same type and rank as the ARRAY argument.

_Example_:
          program test_eoshift
              integer, dimension(3,3) :: a
              a = reshape( (/ 1, 2, 3, 4, 5, 6, 7, 8, 9 /), (/ 3, 3 /))
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
              a = EOSHIFT(a, SHIFT=(/1, 2, 1/), BOUNDARY=-5, DIM=2)
              print *
              print '(3i3)', a(1,:)
              print '(3i3)', a(2,:)
              print '(3i3)', a(3,:)
          end program test_eoshift


File: gfortran.info,  Node: EPSILON,  Next: ERF,  Prev: EOSHIFT,  Up: Intrinsic Procedures

7.63 `EPSILON' -- Epsilon function
==================================

_Description_:
     `EPSILON(X)' returns the smallest number E of the same kind as X
     such that 1 + E > 1.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = EPSILON(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of same type as the argument.

_Example_:
          program test_epsilon
              real :: x = 3.143
              real(8) :: y = 2.33
              print *, EPSILON(x)
              print *, EPSILON(y)
          end program test_epsilon


File: gfortran.info,  Node: ERF,  Next: ERFC,  Prev: EPSILON,  Up: Intrinsic Procedures

7.64 `ERF' -- Error function
============================

_Description_:
     `ERF(X)' computes the error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ERF(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL', of the same kind as X and lies
     in the range -1 \leq erf (x) \leq 1 .

_Example_:
          program test_erf
            real(8) :: x = 0.17_8
            x = erf(x)
          end program test_erf

_Specific names_:
     Name          Argument      Return type   Standard
     `DERF(X)'     `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: ERFC,  Next: ERFC_SCALED,  Prev: ERF,  Up: Intrinsic Procedures

7.65 `ERFC' -- Error function
=============================

_Description_:
     `ERFC(X)' computes the complementary error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ERFC(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' and of the same kind as X.  It
     lies in the range  0 \leq erfc (x) \leq 2 .

_Example_:
          program test_erfc
            real(8) :: x = 0.17_8
            x = erfc(x)
          end program test_erfc

_Specific names_:
     Name          Argument      Return type   Standard
     `DERFC(X)'    `REAL(8) X'   `REAL(8)'     GNU extension


File: gfortran.info,  Node: ERFC_SCALED,  Next: ETIME,  Prev: ERFC,  Up: Intrinsic Procedures

7.66 `ERFC_SCALED' -- Error function
====================================

_Description_:
     `ERFC_SCALED(X)' computes the exponentially-scaled complementary
     error function of X.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ERFC_SCALED(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' and of the same kind as X.

_Example_:
          program test_erfc_scaled
            real(8) :: x = 0.17_8
            x = erfc_scaled(x)
          end program test_erfc_scaled


File: gfortran.info,  Node: ETIME,  Next: EXIT,  Prev: ERFC_SCALED,  Up: Intrinsic Procedures

7.67 `ETIME' -- Execution time subroutine (or function)
=======================================================

_Description_:
     `ETIME(TARRAY, RESULT)' returns the number of seconds of runtime
     since the start of the process's execution in RESULT.  TARRAY
     returns the user and system components of this time in `TARRAY(1)'
     and `TARRAY(2)' respectively. RESULT is equal to `TARRAY(1) +
     TARRAY(2)'.

     On some systems, the underlying timings are represented using
     types with sufficiently small limits that overflows (wrap around)
     are possible, such as 32-bit types. Therefore, the values returned
     by this intrinsic might be, or become, negative, or numerically
     less than previous values, during a single run of the compiled
     program.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     TARRAY and RESULT are `INTENT(OUT)' and provide the following:

                `TARRAY(1)':         User time in seconds.
                `TARRAY(2)':         System time in seconds.
                `RESULT':            Run time since start in seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL ETIME(TARRAY, RESULT)'.
     `RESULT = ETIME(TARRAY)', (not recommended).

_Arguments_:
     TARRAY     The type shall be `REAL, DIMENSION(2)'.
     RESULT     The type shall be `REAL'.

_Return value_:
     Elapsed time in seconds since the start of program execution.

_Example_:
          program test_etime
              integer(8) :: i, j
              real, dimension(2) :: tarray
              real :: result
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
              do i=1,100000000    ! Just a delay
                  j = i * i - i
              end do
              call ETIME(tarray, result)
              print *, result
              print *, tarray(1)
              print *, tarray(2)
          end program test_etime

_See also_:
     *note CPU_TIME::



File: gfortran.info,  Node: EXIT,  Next: EXP,  Prev: ETIME,  Up: Intrinsic Procedures

7.68 `EXIT' -- Exit the program with status.
============================================

_Description_:
     `EXIT' causes immediate termination of the program with status.
     If status is omitted it returns the canonical _success_ for the
     system.  All Fortran I/O units are closed.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL EXIT([STATUS])'

_Arguments_:
     STATUS     Shall be an `INTEGER' of the default kind.

_Return value_:
     `STATUS' is passed to the parent process on exit.

_Example_:
          program test_exit
            integer :: STATUS = 0
            print *, 'This program is going to exit.'
            call EXIT(STATUS)
          end program test_exit

_See also_:
     *note ABORT::, *note KILL::


File: gfortran.info,  Node: EXP,  Next: EXPONENT,  Prev: EXIT,  Up: Intrinsic Procedures

7.69 `EXP' -- Exponential function
==================================

_Description_:
     `EXP(X)' computes the base e exponential of X.

_Standard_:
     Fortran 77 and later, has overloads that are GNU extensions

_Class_:
     Elemental function

_Syntax_:
     `RESULT = EXP(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_exp
            real :: x = 1.0
            x = exp(x)
          end program test_exp

_Specific names_:
     Name          Argument      Return type   Standard
     `DEXP(X)'     `REAL(8) X'   `REAL(8)'     Fortran 77 and
                                               later
     `CEXP(X)'     `COMPLEX(4)   `COMPLEX(4)'  Fortran 77 and
                   X'                          later
     `ZEXP(X)'     `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDEXP(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          


File: gfortran.info,  Node: EXPONENT,  Next: FDATE,  Prev: EXP,  Up: Intrinsic Procedures

7.70 `EXPONENT' -- Exponent function
====================================

_Description_:
     `EXPONENT(X)' returns the value of the exponent part of X. If X is
     zero the value returned is zero.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = EXPONENT(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type default `INTEGER'.

_Example_:
          program test_exponent
            real :: x = 1.0
            integer :: i
            i = exponent(x)
            print *, i
            print *, exponent(0.0)
          end program test_exponent


File: gfortran.info,  Node: FDATE,  Next: FGET,  Prev: EXPONENT,  Up: Intrinsic Procedures

7.71 `FDATE' -- Get the current time as a string
================================================

_Description_:
     `FDATE(DATE)' returns the current date (using the same format as
     `CTIME') in DATE. It is equivalent to `CALL CTIME(DATE, TIME())'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     DATE is an `INTENT(OUT)' `CHARACTER' variable of the default kind.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FDATE(DATE)'.
     `DATE = FDATE()', (not recommended).

_Arguments_:
     DATE       The type shall be of type `CHARACTER' of the
                default kind

_Return value_:
     The current date as a string.

_Example_:
          program test_fdate
              integer(8) :: i, j
              character(len=30) :: date
              call fdate(date)
              print *, 'Program started on ', date
              do i = 1, 100000000 ! Just a delay
                  j = i * i - i
              end do
              call fdate(date)
              print *, 'Program ended on ', date
          end program test_fdate


File: gfortran.info,  Node: FLOAT,  Next: FLOOR,  Prev: FGETC,  Up: Intrinsic Procedures

7.72 `FLOAT' -- Convert integer to default real
===============================================

_Description_:
     `FLOAT(A)' converts the integer A to a default real value.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = FLOAT(A)'

_Arguments_:
     A          The type shall be `INTEGER'.

_Return value_:
     The return value is of type default `REAL'.

_Example_:
          program test_float
              integer :: i = 1
              if (float(i) /= 1.) call abort
          end program test_float

_See also_:
     *note DBLE::, *note DFLOAT::, *note REAL::


File: gfortran.info,  Node: FGET,  Next: FGETC,  Prev: FDATE,  Up: Intrinsic Procedures

7.73 `FGET' -- Read a single character in stream mode from stdin
================================================================

_Description_:
     Read a single character in stream mode from stdin by bypassing
     normal formatted output. Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the `FGET' intrinsic is provided for backwards
     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new
     stream IO feature in new code for future portability. See also
     *note Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FGET(C [, STATUS])'

_Arguments_:
     C          The type shall be `CHARACTER' and of default
                kind.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success, -1 on end-of-file, and a
                system specific positive error code otherwise.

_Example_:
          PROGRAM test_fget
            INTEGER, PARAMETER :: strlen = 100
            INTEGER :: status, i = 1
            CHARACTER(len=strlen) :: str = ""

            WRITE (*,*) 'Enter text:'
            DO
              CALL fget(str(i:i), status)
              if (status /= 0 .OR. i > strlen) exit
              i = i + 1
            END DO
            WRITE (*,*) TRIM(str)
          END PROGRAM

_See also_:
     *note FGETC::, *note FPUT::, *note FPUTC::


File: gfortran.info,  Node: FGETC,  Next: FLOAT,  Prev: FGET,  Up: Intrinsic Procedures

7.74 `FGETC' -- Read a single character in stream mode
======================================================

_Description_:
     Read a single character in stream mode by bypassing normal
     formatted output.  Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the `FGET' intrinsic is provided for backwards
     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new
     stream IO feature in new code for future portability. See also
     *note Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FGETC(UNIT, C [, STATUS])'

_Arguments_:
     UNIT       The type shall be `INTEGER'.
     C          The type shall be `CHARACTER' and of default
                kind.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success, -1 on end-of-file and a
                system specific positive error code otherwise.

_Example_:
          PROGRAM test_fgetc
            INTEGER :: fd = 42, status
            CHARACTER :: c

            OPEN(UNIT=fd, FILE="/etc/passwd", ACTION="READ", STATUS = "OLD")
            DO
              CALL fgetc(fd, c, status)
              IF (status /= 0) EXIT
              call fput(c)
            END DO
            CLOSE(UNIT=fd)
          END PROGRAM

_See also_:
     *note FGET::, *note FPUT::, *note FPUTC::


File: gfortran.info,  Node: FLOOR,  Next: FLUSH,  Prev: FLOAT,  Up: Intrinsic Procedures

7.75 `FLOOR' -- Integer floor function
======================================

_Description_:
     `FLOOR(A)' returns the greatest integer less than or equal to X.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = FLOOR(A [, KIND])'

_Arguments_:
     A          The type shall be `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER(KIND)' if KIND is present and
     of default-kind `INTEGER' otherwise.

_Example_:
          program test_floor
              real :: x = 63.29
              real :: y = -63.59
              print *, floor(x) ! returns 63
              print *, floor(y) ! returns -64
          end program test_floor

_See also_:
     *note CEILING::, *note NINT::



File: gfortran.info,  Node: FLUSH,  Next: FNUM,  Prev: FLOOR,  Up: Intrinsic Procedures

7.76 `FLUSH' -- Flush I/O unit(s)
=================================

_Description_:
     Flushes Fortran unit(s) currently open for output. Without the
     optional argument, all units are flushed, otherwise just the unit
     specified.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL FLUSH(UNIT)'

_Arguments_:
     UNIT       (Optional) The type shall be `INTEGER'.

_Note_:
     Beginning with the Fortran 2003 standard, there is a `FLUSH'
     statement that should be preferred over the `FLUSH' intrinsic.



File: gfortran.info,  Node: FNUM,  Next: FPUT,  Prev: FLUSH,  Up: Intrinsic Procedures

7.77 `FNUM' -- File number function
===================================

_Description_:
     `FNUM(UNIT)' returns the POSIX file descriptor number
     corresponding to the open Fortran I/O unit `UNIT'.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = FNUM(UNIT)'

_Arguments_:
     UNIT       The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER'

_Example_:
          program test_fnum
            integer :: i
            open (unit=10, status = "scratch")
            i = fnum(10)
            print *, i
            close (10)
          end program test_fnum


File: gfortran.info,  Node: FPUT,  Next: FPUTC,  Prev: FNUM,  Up: Intrinsic Procedures

7.78 `FPUT' -- Write a single character in stream mode to stdout
================================================================

_Description_:
     Write a single character in stream mode to stdout by bypassing
     normal formatted output. Stream I/O should not be mixed with
     normal record-oriented (formatted or unformatted) I/O on the same
     unit; the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the `FGET' intrinsic is provided for backwards
     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new
     stream IO feature in new code for future portability. See also
     *note Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FPUT(C [, STATUS])'

_Arguments_:
     C          The type shall be `CHARACTER' and of default
                kind.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success, -1 on end-of-file and a
                system specific positive error code otherwise.

_Example_:
          PROGRAM test_fput
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: i
            DO i = 1, len_trim(str)
              CALL fput(str(i:i))
            END DO
          END PROGRAM

_See also_:
     *note FPUTC::, *note FGET::, *note FGETC::


File: gfortran.info,  Node: FPUTC,  Next: FRACTION,  Prev: FPUT,  Up: Intrinsic Procedures

7.79 `FPUTC' -- Write a single character in stream mode
=======================================================

_Description_:
     Write a single character in stream mode by bypassing normal
     formatted output. Stream I/O should not be mixed with normal
     record-oriented (formatted or unformatted) I/O on the same unit;
     the results are unpredictable.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

     Note that the `FGET' intrinsic is provided for backwards
     compatibility with `g77'.  GNU Fortran provides the Fortran 2003
     Stream facility.  Programmers should consider the use of new
     stream IO feature in new code for future portability. See also
     *note Fortran 2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FPUTC(UNIT, C [, STATUS])'

_Arguments_:
     UNIT       The type shall be `INTEGER'.
     C          The type shall be `CHARACTER' and of default
                kind.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success, -1 on end-of-file and a
                system specific positive error code otherwise.

_Example_:
          PROGRAM test_fputc
            CHARACTER(len=10) :: str = "gfortran"
            INTEGER :: fd = 42, i

            OPEN(UNIT = fd, FILE = "out", ACTION = "WRITE", STATUS="NEW")
            DO i = 1, len_trim(str)
              CALL fputc(fd, str(i:i))
            END DO
            CLOSE(fd)
          END PROGRAM

_See also_:
     *note FPUT::, *note FGET::, *note FGETC::


File: gfortran.info,  Node: FRACTION,  Next: FREE,  Prev: FPUTC,  Up: Intrinsic Procedures

7.80 `FRACTION' -- Fractional part of the model representation
==============================================================

_Description_:
     `FRACTION(X)' returns the fractional part of the model
     representation of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `Y = FRACTION(X)'

_Arguments_:
     X          The type of the argument shall be a `REAL'.

_Return value_:
     The return value is of the same type and kind as the argument.
     The fractional part of the model representation of `X' is returned;
     it is `X * RADIX(X)**(-EXPONENT(X))'.

_Example_:
          program test_fraction
            real :: x
            x = 178.1387e-4
            print *, fraction(x), x * radix(x)**(-exponent(x))
          end program test_fraction



File: gfortran.info,  Node: FREE,  Next: FSEEK,  Prev: FRACTION,  Up: Intrinsic Procedures

7.81 `FREE' -- Frees memory
===========================

_Description_:
     Frees memory previously allocated by `MALLOC()'. The `FREE'
     intrinsic is an extension intended to be used with Cray pointers,
     and is provided in GNU Fortran to allow user to compile legacy
     code. For new code using Fortran 95 pointers, the memory
     de-allocation intrinsic is `DEALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL FREE(PTR)'

_Arguments_:
     PTR        The type shall be `INTEGER'. It represents the
                location of the memory that should be
                de-allocated.

_Return value_:
     None

_Example_:
     See `MALLOC' for an example.

_See also_:
     *note MALLOC::


File: gfortran.info,  Node: FSEEK,  Next: FSTAT,  Prev: FREE,  Up: Intrinsic Procedures

7.82 `FSEEK' -- Low level file positioning subroutine
=====================================================

_Description_:
     Moves UNIT to the specified OFFSET. If WHENCE is set to 0, the
     OFFSET is taken as an absolute value `SEEK_SET', if set to 1,
     OFFSET is taken to be relative to the current position `SEEK_CUR',
     and if set to 2 relative to the end of the file `SEEK_END'.  On
     error, STATUS is set to a nonzero value. If STATUS the seek fails
     silently.

     This intrinsic routine is not fully backwards compatible with
     `g77'.  In `g77', the `FSEEK' takes a statement label instead of a
     STATUS variable. If FSEEK is used in old code, change
            CALL FSEEK(UNIT, OFFSET, WHENCE, *label)
     to
            INTEGER :: status
            CALL FSEEK(UNIT, OFFSET, WHENCE, status)
            IF (status /= 0) GOTO label

     Please note that GNU Fortran provides the Fortran 2003 Stream
     facility.  Programmers should consider the use of new stream IO
     feature in new code for future portability. See also *note Fortran
     2003 status::.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL FSEEK(UNIT, OFFSET, WHENCE[, STATUS])'

_Arguments_:
     UNIT       Shall be a scalar of type `INTEGER'.
     OFFSET     Shall be a scalar of type `INTEGER'.
     WHENCE     Shall be a scalar of type `INTEGER'.  Its
                value shall be either 0, 1 or 2.
     STATUS     (Optional) shall be a scalar of type
                `INTEGER(4)'.

_Example_:
          PROGRAM test_fseek
            INTEGER, PARAMETER :: SEEK_SET = 0, SEEK_CUR = 1, SEEK_END = 2
            INTEGER :: fd, offset, ierr

            ierr   = 0
            offset = 5
            fd     = 10

            OPEN(UNIT=fd, FILE="fseek.test")
            CALL FSEEK(fd, offset, SEEK_SET, ierr)  ! move to OFFSET
            print *, FTELL(fd), ierr

            CALL FSEEK(fd, 0, SEEK_END, ierr)       ! move to end
            print *, FTELL(fd), ierr

            CALL FSEEK(fd, 0, SEEK_SET, ierr)       ! move to beginning
            print *, FTELL(fd), ierr

            CLOSE(UNIT=fd)
          END PROGRAM

_See also_:
     *note FTELL::


File: gfortran.info,  Node: FSTAT,  Next: FTELL,  Prev: FSEEK,  Up: Intrinsic Procedures

7.83 `FSTAT' -- Get file status
===============================

_Description_:
     `FSTAT' is identical to *note STAT::, except that information
     about an already opened file is obtained.

     The elements in `BUFF' are the same as described by *note STAT::.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FSTAT(UNIT, BUFF [, STATUS])'

_Arguments_:
     UNIT       An open I/O unit number of type `INTEGER'.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0 on success and a system specific
                error code otherwise.

_Example_:
     See *note STAT:: for an example.

_See also_:
     To stat a link: *note LSTAT::, to stat a file: *note STAT::


File: gfortran.info,  Node: FTELL,  Next: GAMMA,  Prev: FSTAT,  Up: Intrinsic Procedures

7.84 `FTELL' -- Current stream position
=======================================

_Description_:
     Retrieves the current position within an open file.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL FTELL(UNIT, OFFSET)'
     `OFFSET = FTELL(UNIT)'

_Arguments_:
     OFFSET     Shall of type `INTEGER'.
     UNIT       Shall of type `INTEGER'.

_Return value_:
     In either syntax, OFFSET is set to the current offset of unit
     number UNIT, or to -1 if the unit is not currently open.

_Example_:
          PROGRAM test_ftell
            INTEGER :: i
            OPEN(10, FILE="temp.dat")
            CALL ftell(10,i)
            WRITE(*,*) i
          END PROGRAM

_See also_:
     *note FSEEK::


File: gfortran.info,  Node: GAMMA,  Next: GERROR,  Prev: FTELL,  Up: Intrinsic Procedures

7.85 `GAMMA' -- Gamma function
==============================

_Description_:
     `GAMMA(X)' computes Gamma (\Gamma) of X. For positive, integer
     values of X the Gamma function simplifies to the factorial
     function \Gamma(x)=(x-1)!.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `X = GAMMA(X)'

_Arguments_:
     X          Shall be of type `REAL' and neither zero nor a
                negative integer.

_Return value_:
     The return value is of type `REAL' of the same kind as X.

_Example_:
          program test_gamma
            real :: x = 1.0
            x = gamma(x) ! returns 1.0
          end program test_gamma

_Specific names_:
     Name          Argument      Return type   Standard
     `GAMMA(X)'    `REAL(4) X'   `REAL(4)'     GNU Extension
     `DGAMMA(X)'   `REAL(8) X'   `REAL(8)'     GNU Extension

_See also_:
     Logarithm of the Gamma function: *note LOG_GAMMA::



File: gfortran.info,  Node: GERROR,  Next: GETARG,  Prev: GAMMA,  Up: Intrinsic Procedures

7.86 `GERROR' -- Get last system error message
==============================================

_Description_:
     Returns the system error message corresponding to the last system
     error.  This resembles the functionality of `strerror(3)' in C.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GERROR(RESULT)'

_Arguments_:
     RESULT     Shall of type `CHARACTER' and of default

_Example_:
          PROGRAM test_gerror
            CHARACTER(len=100) :: msg
            CALL gerror(msg)
            WRITE(*,*) msg
          END PROGRAM

_See also_:
     *note IERRNO::, *note PERROR::


File: gfortran.info,  Node: GETARG,  Next: GET_COMMAND,  Prev: GERROR,  Up: Intrinsic Procedures

7.87 `GETARG' -- Get command line arguments
===========================================

_Description_:
     Retrieve the POS-th argument that was passed on the command line
     when the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note GET_COMMAND_ARGUMENT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETARG(POS, VALUE)'

_Arguments_:
     POS        Shall be of type `INTEGER' and not wider than
                the default integer kind; POS \geq 0
     VALUE      Shall be of type `CHARACTER' and of default
                kind.
     VALUE      Shall be of type `CHARACTER'.

_Return value_:
     After `GETARG' returns, the VALUE argument holds the POSth command
     line argument. If VALUE can not hold the argument, it is truncated
     to fit the length of VALUE. If there are less than POS arguments
     specified at the command line, VALUE will be filled with blanks.
     If POS = 0, VALUE is set to the name of the program (on systems
     that support this feature).

_Example_:
          PROGRAM test_getarg
            INTEGER :: i
            CHARACTER(len=32) :: arg

            DO i = 1, iargc()
              CALL getarg(i, arg)
              WRITE (*,*) arg
            END DO
          END PROGRAM

_See also_:
     GNU Fortran 77 compatibility function: *note IARGC::

     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND,  Next: GET_COMMAND_ARGUMENT,  Prev: GETARG,  Up: Intrinsic Procedures

7.88 `GET_COMMAND' -- Get the entire command line
=================================================

_Description_:
     Retrieve the entire command line that was used to invoke the
     program.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_COMMAND(COMMAND)'

_Arguments_:
     COMMAND    Shall be of type `CHARACTER' and of default
                kind.

_Return value_:
     Stores the entire command line that was used to invoke the program
     in COMMAND. If COMMAND is not large enough, the command will be
     truncated.

_Example_:
          PROGRAM test_get_command
            CHARACTER(len=255) :: cmd
            CALL get_command(cmd)
            WRITE (*,*) TRIM(cmd)
          END PROGRAM

_See also_:
     *note GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GET_COMMAND_ARGUMENT,  Next: GETCWD,  Prev: GET_COMMAND,  Up: Intrinsic Procedures

7.89 `GET_COMMAND_ARGUMENT' -- Get command line arguments
=========================================================

_Description_:
     Retrieve the NUMBER-th argument that was passed on the command
     line when the containing program was invoked.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_COMMAND_ARGUMENT(NUMBER [, VALUE, LENGTH, STATUS])'

_Arguments_:
     NUMBER     Shall be a scalar of type `INTEGER(4)', NUMBER
                \geq 0
     VALUE      Shall be a scalar of type `CHARACTER' and of
                default kind.
     LENGTH     (Option) Shall be a scalar of type
                `INTEGER(4)'.
     STATUS     (Option) Shall be a scalar of type
                `INTEGER(4)'.

_Return value_:
     After `GET_COMMAND_ARGUMENT' returns, the VALUE argument holds the
     NUMBER-th command line argument. If VALUE can not hold the
     argument, it is truncated to fit the length of VALUE. If there are
     less than NUMBER arguments specified at the command line, VALUE
     will be filled with blanks.  If NUMBER = 0, VALUE is set to the
     name of the program (on systems that support this feature). The
     LENGTH argument contains the length of the NUMBER-th command line
     argument. If the argument retrieval fails, STATUS is a positive
     number; if VALUE contains a truncated command line argument,
     STATUS is -1; and otherwise the STATUS is zero.

_Example_:
          PROGRAM test_get_command_argument
            INTEGER :: i
            CHARACTER(len=32) :: arg

            i = 0
            DO
              CALL get_command_argument(i, arg)
              IF (LEN_TRIM(arg) == 0) EXIT

              WRITE (*,*) TRIM(arg)
              i = i+1
            END DO
          END PROGRAM

_See also_:
     *note GET_COMMAND::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: GETCWD,  Next: GETENV,  Prev: GET_COMMAND_ARGUMENT,  Up: Intrinsic Procedures

7.90 `GETCWD' -- Get current working directory
==============================================

_Description_:
     Get current working directory.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL GETCWD(C [, STATUS])'

_Arguments_:
     C          The type shall be `CHARACTER' and of default
                kind.
     STATUS     (Optional) status flag. Returns 0 on success,
                a system specific and nonzero error code
                otherwise.

_Example_:
          PROGRAM test_getcwd
            CHARACTER(len=255) :: cwd
            CALL getcwd(cwd)
            WRITE(*,*) TRIM(cwd)
          END PROGRAM

_See also_:
     *note CHDIR::


File: gfortran.info,  Node: GETENV,  Next: GET_ENVIRONMENT_VARIABLE,  Prev: GETCWD,  Up: Intrinsic Procedures

7.91 `GETENV' -- Get an environmental variable
==============================================

_Description_:
     Get the VALUE of the environmental variable NAME.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note GET_ENVIRONMENT_VARIABLE:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETENV(NAME, VALUE)'

_Arguments_:
     NAME       Shall be of type `CHARACTER' and of default
                kind.
     VALUE      Shall be of type `CHARACTER' and of default
                kind.

_Return value_:
     Stores the value of NAME in VALUE. If VALUE is not large enough to
     hold the data, it is truncated. If NAME is not set, VALUE will be
     filled with blanks.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL getenv("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM

_See also_:
     *note GET_ENVIRONMENT_VARIABLE::


File: gfortran.info,  Node: GET_ENVIRONMENT_VARIABLE,  Next: GETGID,  Prev: GETENV,  Up: Intrinsic Procedures

7.92 `GET_ENVIRONMENT_VARIABLE' -- Get an environmental variable
================================================================

_Description_:
     Get the VALUE of the environmental variable NAME.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL GET_ENVIRONMENT_VARIABLE(NAME[, VALUE, LENGTH, STATUS,
     TRIM_NAME)'

_Arguments_:
     NAME       Shall be a scalar of type `CHARACTER(1)'.
     VALUE      Shall be a scalar of type `CHARACTER(1)'.
     LENGTH     Shall be a scalar of type `INTEGER(4)'.
     STATUS     Shall be a scalar of type `INTEGER(4)'.
     TRIM_NAME  Shall be a scalar of type `LOGICAL(4)'.

_Return value_:
     Stores the value of NAME in VALUE. If VALUE is not large enough to
     hold the data, it is truncated. If NAME is not set, VALUE will be
     filled with blanks. Argument LENGTH contains the length needed for
     storing the environment variable NAME or zero if it is not
     present. STATUS is -1 if VALUE is present but too short for the
     environment variable; it is 1 if the environment variable does not
     exist and 2 if the processor does not support environment
     variables; in all other cases STATUS is zero. If TRIM_NAME is
     present with the value `.FALSE.', the trailing blanks in NAME are
     significant; otherwise they are not part of the environment
     variable name.

_Example_:
          PROGRAM test_getenv
            CHARACTER(len=255) :: homedir
            CALL get_environment_variable("HOME", homedir)
            WRITE (*,*) TRIM(homedir)
          END PROGRAM


File: gfortran.info,  Node: GETGID,  Next: GETLOG,  Prev: GET_ENVIRONMENT_VARIABLE,  Up: Intrinsic Procedures

7.93 `GETGID' -- Group ID function
==================================

_Description_:
     Returns the numerical group ID of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = GETGID()'

_Return value_:
     The return value of `GETGID' is an `INTEGER' of the default kind.

_Example_:
     See `GETPID' for an example.

_See also_:
     *note GETPID::, *note GETUID::


File: gfortran.info,  Node: GETLOG,  Next: GETPID,  Prev: GETGID,  Up: Intrinsic Procedures

7.94 `GETLOG' -- Get login name
===============================

_Description_:
     Gets the username under which the program is running.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GETLOG(C)'

_Arguments_:
     C          Shall be of type `CHARACTER' and of default
                kind.

_Return value_:
     Stores the current user name in LOGIN.  (On systems where POSIX
     functions `geteuid' and `getpwuid' are not available, and the
     `getlogin' function is not implemented either, this will return a
     blank string.)

_Example_:
          PROGRAM TEST_GETLOG
            CHARACTER(32) :: login
            CALL GETLOG(login)
            WRITE(*,*) login
          END PROGRAM

_See also_:
     *note GETUID::


File: gfortran.info,  Node: GETPID,  Next: GETUID,  Prev: GETLOG,  Up: Intrinsic Procedures

7.95 `GETPID' -- Process ID function
====================================

_Description_:
     Returns the numerical process identifier of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = GETPID()'

_Return value_:
     The return value of `GETPID' is an `INTEGER' of the default kind.

_Example_:
          program info
            print *, "The current process ID is ", getpid()
            print *, "Your numerical user ID is ", getuid()
            print *, "Your numerical group ID is ", getgid()
          end program info

_See also_:
     *note GETGID::, *note GETUID::


File: gfortran.info,  Node: GETUID,  Next: GMTIME,  Prev: GETPID,  Up: Intrinsic Procedures

7.96 `GETUID' -- User ID function
=================================

_Description_:
     Returns the numerical user ID of the current process.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = GETUID()'

_Return value_:
     The return value of `GETUID' is an `INTEGER' of the default kind.

_Example_:
     See `GETPID' for an example.

_See also_:
     *note GETPID::, *note GETLOG::


File: gfortran.info,  Node: GMTIME,  Next: HOSTNM,  Prev: GETUID,  Up: Intrinsic Procedures

7.97 `GMTIME' -- Convert time to GMT info
=========================================

_Description_:
     Given a system time value TIME (as provided by the `TIME8()'
     intrinsic), fills VALUES with values extracted from it appropriate
     to the UTC time zone (Universal Coordinated Time, also known in
     some countries as GMT, Greenwich Mean Time), using `gmtime(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL GMTIME(TIME, VALUES)'

_Arguments_:
     TIME       An `INTEGER' scalar expression corresponding
                to a system time, with `INTENT(IN)'.
     VALUES     A default `INTEGER' array with 9 elements,
                with `INTENT(OUT)'.

_Return value_:
     The elements of VALUES are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
          seconds

       2. Minutes after the hour, range 0-59

       3. Hours past midnight, range 0-23

       4. Day of month, range 0-31

       5. Number of months since January, range 0-12

       6. Years since 1900

       7. Number of days since Sunday, range 0-6

       8. Days since January 1

       9. Daylight savings indicator: positive if daylight savings is in
          effect, zero if not, and negative if the information is not
          available.

_See also_:
     *note CTIME::, *note LTIME::, *note TIME::, *note TIME8::



File: gfortran.info,  Node: HOSTNM,  Next: HUGE,  Prev: GMTIME,  Up: Intrinsic Procedures

7.98 `HOSTNM' -- Get system host name
=====================================

_Description_:
     Retrieves the host name of the system on which the program is
     running.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL HOSTNM(C [, STATUS])'
     `STATUS = HOSTNM(NAME)'

_Arguments_:
     C          Shall of type `CHARACTER' and of default kind.
     STATUS     (Optional) status flag of type `INTEGER'.
                Returns 0 on success, or a system specific
                error code otherwise.

_Return value_:
     In either syntax, NAME is set to the current hostname if it can be
     obtained, or to a blank string otherwise.



File: gfortran.info,  Node: HUGE,  Next: HYPOT,  Prev: HOSTNM,  Up: Intrinsic Procedures

7.99 `HUGE' -- Largest number of a kind
=======================================

_Description_:
     `HUGE(X)' returns the largest number that is not an infinity in
     the model of the type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = HUGE(X)'

_Arguments_:
     X          Shall be of type `REAL' or `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
          program test_huge_tiny
            print *, huge(0), huge(0.0), huge(0.0d0)
            print *, tiny(0.0), tiny(0.0d0)
          end program test_huge_tiny


File: gfortran.info,  Node: HYPOT,  Next: IACHAR,  Prev: HUGE,  Up: Intrinsic Procedures

7.100 `HYPOT' -- Euclidean distance function
============================================

_Description_:
     `HYPOT(X,Y)' is the Euclidean distance function. It is equal to
     \sqrtX^2 + Y^2, without undue underflow or overflow.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = HYPOT(X, Y)'

_Arguments_:
     X          The type shall be `REAL'.
     Y          The type and kind type parameter shall be the
                same as X.

_Return value_:
     The return value has the same type and kind type parameter as X.

_Example_:
          program test_hypot
            real(4) :: x = 1.e0_4, y = 0.5e0_4
            x = hypot(x,y)
          end program test_hypot


File: gfortran.info,  Node: IACHAR,  Next: IAND,  Prev: HYPOT,  Up: Intrinsic Procedures

7.101 `IACHAR' -- Code in ASCII collating sequence
==================================================

_Description_:
     `IACHAR(C)' returns the code for the ASCII character in the first
     character position of `C'.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IACHAR(C [, KIND])'

_Arguments_:
     C          Shall be a scalar `CHARACTER', with
                `INTENT(IN)'
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_Example_:
          program test_iachar
            integer i
            i = iachar(' ')
          end program test_iachar

_Note_:
     See *note ICHAR:: for a discussion of converting between numerical
     values and formatted string representations.

_See also_:
     *note ACHAR::, *note CHAR::, *note ICHAR::



File: gfortran.info,  Node: IAND,  Next: IARGC,  Prev: IACHAR,  Up: Intrinsic Procedures

7.102 `IAND' -- Bitwise logical and
===================================

_Description_:
     Bitwise logical `AND'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IAND(I, J)'

_Arguments_:
     I          The type shall be `INTEGER'.
     J          The type shall be `INTEGER', of the same kind
                as I.  (As a GNU extension, different kinds
                are also permitted.)

_Return value_:
     The return type is `INTEGER', of the same kind as the arguments.
     (If the argument kinds differ, it is of the same kind as the
     larger argument.)

_Example_:
          PROGRAM test_iand
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /
            WRITE (*,*) IAND(a, b)
          END PROGRAM

_See also_:
     *note IOR::, *note IEOR::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::



File: gfortran.info,  Node: IARGC,  Next: IBCLR,  Prev: IAND,  Up: Intrinsic Procedures

7.103 `IARGC' -- Get the number of command line arguments
=========================================================

_Description_:
     `IARGC()' returns the number of arguments passed on the command
     line when the containing program was invoked.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  In new code, programmers should consider the use
     of the *note COMMAND_ARGUMENT_COUNT:: intrinsic defined by the
     Fortran 2003 standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = IARGC()'

_Arguments_:
     None.

_Return value_:
     The number of command line arguments, type `INTEGER(4)'.

_Example_:
     See *note GETARG::

_See also_:
     GNU Fortran 77 compatibility subroutine: *note GETARG::

     Fortran 2003 functions and subroutines: *note GET_COMMAND::, *note
     GET_COMMAND_ARGUMENT::, *note COMMAND_ARGUMENT_COUNT::


File: gfortran.info,  Node: IBCLR,  Next: IBITS,  Prev: IARGC,  Up: Intrinsic Procedures

7.104 `IBCLR' -- Clear bit
==========================

_Description_:
     `IBCLR' returns the value of I with the bit at position POS set to
     zero.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBCLR(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER'.
     POS        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note IBITS::, *note IBSET::, *note IAND::, *note IOR::, *note
     IEOR::, *note MVBITS::



File: gfortran.info,  Node: IBITS,  Next: IBSET,  Prev: IBCLR,  Up: Intrinsic Procedures

7.105 `IBITS' -- Bit extraction
===============================

_Description_:
     `IBITS' extracts a field of length LEN from I, starting from bit
     position POS and extending left for LEN bits.  The result is
     right-justified and the remaining bits are zeroed.  The value of
     `POS+LEN' must be less than or equal to the value `BIT_SIZE(I)'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBITS(I, POS, LEN)'

_Arguments_:
     I          The type shall be `INTEGER'.
     POS        The type shall be `INTEGER'.
     LEN        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note BIT_SIZE::, *note IBCLR::, *note IBSET::, *note IAND::,
     *note IOR::, *note IEOR::


File: gfortran.info,  Node: IBSET,  Next: ICHAR,  Prev: IBITS,  Up: Intrinsic Procedures

7.106 `IBSET' -- Set bit
========================

_Description_:
     `IBSET' returns the value of I with the bit at position POS set to
     one.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IBSET(I, POS)'

_Arguments_:
     I          The type shall be `INTEGER'.
     POS        The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note IBCLR::, *note IBITS::, *note IAND::, *note IOR::, *note
     IEOR::, *note MVBITS::



File: gfortran.info,  Node: ICHAR,  Next: IDATE,  Prev: IBSET,  Up: Intrinsic Procedures

7.107 `ICHAR' -- Character-to-integer conversion function
=========================================================

_Description_:
     `ICHAR(C)' returns the code for the character in the first
     character position of `C' in the system's native character set.
     The correspondence between characters and their codes is not
     necessarily the same across different GNU Fortran implementations.

_Standard_:
     Fortan 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ICHAR(C [, KIND])'

_Arguments_:
     C          Shall be a scalar `CHARACTER', with
                `INTENT(IN)'
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_Example_:
          program test_ichar
            integer i
            i = ichar(' ')
          end program test_ichar

_Note_:
     No intrinsic exists to convert between a numeric value and a
     formatted character string representation - for instance, given the
     `CHARACTER' value `'154'', obtaining an `INTEGER' or `REAL' value
     with the value 154, or vice versa. Instead, this functionality is
     provided by internal-file I/O, as in the following example:
          program read_val
            integer value
            character(len=10) string, string2
            string = '154'

            ! Convert a string to a numeric value
            read (string,'(I10)') value
            print *, value

            ! Convert a value to a formatted string
            write (string2,'(I10)') value
            print *, string2
          end program read_val

_See also_:
     *note ACHAR::, *note CHAR::, *note IACHAR::



File: gfortran.info,  Node: IDATE,  Next: IEOR,  Prev: ICHAR,  Up: Intrinsic Procedures

7.108 `IDATE' -- Get current local time subroutine (day/month/year)
===================================================================

_Description_:
     `IDATE(TARRAY)' Fills TARRAY with the numerical values at the
     current local time. The day (in the range 1-31), month (in the
     range 1-12), and year appear in elements 1, 2, and 3 of TARRAY,
     respectively.  The year has four significant digits.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL IDATE(VALUES)'

_Arguments_:
     VALUES     The type shall be `INTEGER, DIMENSION(3)' and
                the kind shall be the default integer kind.

_Return value_:
     Does not return anything.

_Example_:
          program test_idate
            integer, dimension(3) :: tarray
            call idate(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_idate


File: gfortran.info,  Node: IEOR,  Next: IERRNO,  Prev: IDATE,  Up: Intrinsic Procedures

7.109 `IEOR' -- Bitwise logical exclusive or
============================================

_Description_:
     `IEOR' returns the bitwise boolean exclusive-OR of I and J.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IEOR(I, J)'

_Arguments_:
     I          The type shall be `INTEGER'.
     J          The type shall be `INTEGER', of the same kind
                as I.  (As a GNU extension, different kinds
                are also permitted.)

_Return value_:
     The return type is `INTEGER', of the same kind as the arguments.
     (If the argument kinds differ, it is of the same kind as the
     larger argument.)

_See also_:
     *note IOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::


File: gfortran.info,  Node: IERRNO,  Next: INDEX intrinsic,  Prev: IEOR,  Up: Intrinsic Procedures

7.110 `IERRNO' -- Get the last system error number
==================================================

_Description_:
     Returns the last system error number, as given by the C `errno()'
     function.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = IERRNO()'

_Arguments_:
     None.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_See also_:
     *note PERROR::


File: gfortran.info,  Node: INDEX intrinsic,  Next: INT,  Prev: IERRNO,  Up: Intrinsic Procedures

7.111 `INDEX' -- Position of a substring within a string
========================================================

_Description_:
     Returns the position of the start of the first occurrence of string
     SUBSTRING as a substring in STRING, counting from one.  If
     SUBSTRING is not present in STRING, zero is returned.  If the BACK
     argument is present and true, the return value is the start of the
     last occurrence rather than the first.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INDEX(STRING, SUBSTRING [, BACK [, KIND]])'

_Arguments_:
     STRING     Shall be a scalar `CHARACTER', with
                `INTENT(IN)'
     SUBSTRING  Shall be a scalar `CHARACTER', with
                `INTENT(IN)'
     BACK       (Optional) Shall be a scalar `LOGICAL', with
                `INTENT(IN)'
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_See also_:
     *note SCAN::, *note VERIFY::


File: gfortran.info,  Node: INT,  Next: INT2,  Prev: INDEX intrinsic,  Up: Intrinsic Procedures

7.112 `INT' -- Convert to integer type
======================================

_Description_:
     Convert to integer type

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT(A [, KIND))'

_Arguments_:
     A          Shall be of type `INTEGER', `REAL', or
                `COMPLEX'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     These functions return a `INTEGER' variable or array under the
     following rules:

    (A)
          If A is of type `INTEGER', `INT(A) = A'

    (B)
          If A is of type `REAL' and |A| < 1, `INT(A)' equals `0'.  If
          |A| \geq 1, then `INT(A)' equals the largest integer that
          does not exceed the range of A and whose sign is the same as
          the sign of A.

    (C)
          If A is of type `COMPLEX', rule B is applied to the real part
          of A.

_Example_:
          program test_int
            integer :: i = 42
            complex :: z = (-3.7, 1.0)
            print *, int(i)
            print *, int(z), int(z,8)
          end program

_Specific names_:
     Name          Argument      Return type   Standard
     `IFIX(A)'     `REAL(4) A'   `INTEGER'     Fortran 77 and
                                               later
     `IDINT(A)'    `REAL(8) A'   `INTEGER'     Fortran 77 and
                                               later



File: gfortran.info,  Node: INT2,  Next: INT8,  Prev: INT,  Up: Intrinsic Procedures

7.113 `INT2' -- Convert to 16-bit integer type
==============================================

_Description_:
     Convert to a `KIND=2' integer type. This is equivalent to the
     standard `INT' intrinsic with an optional argument of `KIND=2',
     and is only included for backwards compatibility.

     The `SHORT' intrinsic is equivalent to `INT2'.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT2(A)'

_Arguments_:
     A          Shall be of type `INTEGER', `REAL', or
                `COMPLEX'.

_Return value_:
     The return value is a `INTEGER(2)' variable.

_See also_:
     *note INT::, *note INT8::, *note LONG::


File: gfortran.info,  Node: INT8,  Next: IOR,  Prev: INT2,  Up: Intrinsic Procedures

7.114 `INT8' -- Convert to 64-bit integer type
==============================================

_Description_:
     Convert to a `KIND=8' integer type. This is equivalent to the
     standard `INT' intrinsic with an optional argument of `KIND=8',
     and is only included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = INT8(A)'

_Arguments_:
     A          Shall be of type `INTEGER', `REAL', or
                `COMPLEX'.

_Return value_:
     The return value is a `INTEGER(8)' variable.

_See also_:
     *note INT::, *note INT2::, *note LONG::


File: gfortran.info,  Node: IOR,  Next: IRAND,  Prev: INT8,  Up: Intrinsic Procedures

7.115 `IOR' -- Bitwise logical or
=================================

_Description_:
     `IOR' returns the bitwise boolean inclusive-OR of I and J.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IOR(I, J)'

_Arguments_:
     I          The type shall be `INTEGER'.
     J          The type shall be `INTEGER', of the same kind
                as I.  (As a GNU extension, different kinds
                are also permitted.)

_Return value_:
     The return type is `INTEGER', of the same kind as the arguments.
     (If the argument kinds differ, it is of the same kind as the
     larger argument.)

_See also_:
     *note IEOR::, *note IAND::, *note IBITS::, *note IBSET::, *note
     IBCLR::, *note NOT::


File: gfortran.info,  Node: IRAND,  Next: IS_IOSTAT_END,  Prev: IOR,  Up: Intrinsic Procedures

7.116 `IRAND' -- Integer pseudo-random number
=============================================

_Description_:
     `IRAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and a system-dependent limit (which is in
     most cases 2147483647). If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with `SRAND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77. It implements a simple modulo generator as provided
     by `g77'. For new code, one should consider the use of *note
     RANDOM_NUMBER:: as it implements a superior algorithm.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = IRAND(I)'

_Arguments_:
     I          Shall be a scalar `INTEGER' of kind 4.

_Return value_:
     The return value is of `INTEGER(kind=4)' type.

_Example_:
          program test_irand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, irand(), irand(), irand(), irand()
            print *, irand(seed), irand(), irand(), irand()
          end program test_irand



File: gfortran.info,  Node: IS_IOSTAT_END,  Next: IS_IOSTAT_EOR,  Prev: IRAND,  Up: Intrinsic Procedures

7.117 `IS_IOSTAT_END' -- Test for end-of-file value
===================================================

_Description_:
     `IS_IOSTAT_END' tests whether an variable has the value of the I/O
     status "end of file". The function is equivalent to comparing the
     variable with the `IOSTAT_END' parameter of the intrinsic module
     `ISO_FORTRAN_ENV'.

_Standard_:
     Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IS_IOSTAT_END(I)'

_Arguments_:
     I          Shall be of the type `INTEGER'.

_Return value_:
     Returns a `LOGICAL' of the default kind, which `.TRUE.' if I has
     the value which indicates an end of file condition for IOSTAT=
     specifiers, and is `.FALSE.' otherwise.

_Example_:
          PROGRAM iostat
            IMPLICIT NONE
            INTEGER :: stat, i
            OPEN(88, FILE='test.dat')
            READ(88, *, IOSTAT=stat) i
            IF(IS_IOSTAT_END(stat)) STOP 'END OF FILE'
          END PROGRAM


File: gfortran.info,  Node: IS_IOSTAT_EOR,  Next: ISATTY,  Prev: IS_IOSTAT_END,  Up: Intrinsic Procedures

7.118 `IS_IOSTAT_EOR' -- Test for end-of-record value
=====================================================

_Description_:
     `IS_IOSTAT_EOR' tests whether an variable has the value of the I/O
     status "end of record". The function is equivalent to comparing the
     variable with the `IOSTAT_EOR' parameter of the intrinsic module
     `ISO_FORTRAN_ENV'.

_Standard_:
     Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = IS_IOSTAT_EOR(I)'

_Arguments_:
     I          Shall be of the type `INTEGER'.

_Return value_:
     Returns a `LOGICAL' of the default kind, which `.TRUE.' if I has
     the value which indicates an end of file condition for IOSTAT=
     specifiers, and is `.FALSE.' otherwise.

_Example_:
          PROGRAM iostat
            IMPLICIT NONE
            INTEGER :: stat, i(50)
            OPEN(88, FILE='test.dat', FORM='UNFORMATTED')
            READ(88, IOSTAT=stat) i
            IF(IS_IOSTAT_EOR(stat)) STOP 'END OF RECORD'
          END PROGRAM


File: gfortran.info,  Node: ISATTY,  Next: ISHFT,  Prev: IS_IOSTAT_EOR,  Up: Intrinsic Procedures

7.119 `ISATTY' -- Whether a unit is a terminal device.
======================================================

_Description_:
     Determine whether a unit is connected to a terminal device.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = ISATTY(UNIT)'

_Arguments_:
     UNIT       Shall be a scalar `INTEGER'.

_Return value_:
     Returns `.TRUE.' if the UNIT is connected to a terminal device,
     `.FALSE.' otherwise.

_Example_:
          PROGRAM test_isatty
            INTEGER(kind=1) :: unit
            DO unit = 1, 10
              write(*,*) isatty(unit=unit)
            END DO
          END PROGRAM

_See also_:
     *note TTYNAM::


File: gfortran.info,  Node: ISHFT,  Next: ISHFTC,  Prev: ISATTY,  Up: Intrinsic Procedures

7.120 `ISHFT' -- Shift bits
===========================

_Description_:
     `ISHFT' returns a value corresponding to I with all of the bits
     shifted SHIFT places.  A value of SHIFT greater than zero
     corresponds to a left shift, a value of zero corresponds to no
     shift, and a value less than zero corresponds to a right shift.
     If the absolute value of SHIFT is greater than `BIT_SIZE(I)', the
     value is undefined.  Bits shifted out from the left end or right
     end are lost; zeros are shifted in from the opposite end.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ISHFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER'.
     SHIFT      The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note ISHFTC::


File: gfortran.info,  Node: ISHFTC,  Next: ISNAN,  Prev: ISHFT,  Up: Intrinsic Procedures

7.121 `ISHFTC' -- Shift bits circularly
=======================================

_Description_:
     `ISHFTC' returns a value corresponding to I with the rightmost
     SIZE bits shifted circularly SHIFT places; that is, bits shifted
     out one end are shifted into the opposite end.  A value of SHIFT
     greater than zero corresponds to a left shift, a value of zero
     corresponds to no shift, and a value less than zero corresponds to
     a right shift.  The absolute value of SHIFT must be less than
     SIZE.  If the SIZE argument is omitted, it is taken to be
     equivalent to `BIT_SIZE(I)'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = ISHFTC(I, SHIFT [, SIZE])'

_Arguments_:
     I          The type shall be `INTEGER'.
     SHIFT      The type shall be `INTEGER'.
     SIZE       (Optional) The type shall be `INTEGER'; the
                value must be greater than zero and less than
                or equal to `BIT_SIZE(I)'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note ISHFT::


File: gfortran.info,  Node: ISNAN,  Next: ITIME,  Prev: ISHFTC,  Up: Intrinsic Procedures

7.122 `ISNAN' -- Test for a NaN
===============================

_Description_:
     `ISNAN' tests whether a floating-point value is an IEEE
     Not-a-Number (NaN).

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `ISNAN(X)'

_Arguments_:
     X          Variable of the type `REAL'.

_Return value_:
     Returns a default-kind `LOGICAL'. The returned value is `TRUE' if
     X is a NaN and `FALSE' otherwise.

_Example_:
          program test_nan
            implicit none
            real :: x
            x = -1.0
            x = sqrt(x)
            if (isnan(x)) stop '"x" is a NaN'
          end program test_nan


File: gfortran.info,  Node: ITIME,  Next: KILL,  Prev: ISNAN,  Up: Intrinsic Procedures

7.123 `ITIME' -- Get current local time subroutine (hour/minutes/seconds)
=========================================================================

_Description_:
     `IDATE(VALUES)' Fills VALUES with the numerical values at the
     current local time. The hour (in the range 1-24), minute (in the
     range 1-60), and seconds (in the range 1-60) appear in elements 1,
     2, and 3 of VALUES, respectively.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL ITIME(VALUES)'

_Arguments_:
     VALUES     The type shall be `INTEGER, DIMENSION(3)' and
                the kind shall be the default integer kind.

_Return value_:
     Does not return anything.

_Example_:
          program test_itime
            integer, dimension(3) :: tarray
            call itime(tarray)
            print *, tarray(1)
            print *, tarray(2)
            print *, tarray(3)
          end program test_itime


File: gfortran.info,  Node: KILL,  Next: KIND,  Prev: ITIME,  Up: Intrinsic Procedures

7.124 `KILL' -- Send a signal to a process
==========================================

_Description_:

_Standard_:
     Sends the signal specified by SIGNAL to the process PID.  See
     `kill(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Class_:
     Subroutine, function

_Syntax_:
     `CALL KILL(C, VALUE [, STATUS])'

_Arguments_:
     C          Shall be a scalar `INTEGER', with `INTENT(IN)'
     VALUE      Shall be a scalar `INTEGER', with `INTENT(IN)'
     STATUS     (Optional) status flag of type `INTEGER(4)' or
                `INTEGER(8)'. Returns 0 on success, or a
                system-specific error code otherwise.

_See also_:
     *note ABORT::, *note EXIT::


File: gfortran.info,  Node: KIND,  Next: LBOUND,  Prev: KILL,  Up: Intrinsic Procedures

7.125 `KIND' -- Kind of an entity
=================================

_Description_:
     `KIND(X)' returns the kind value of the entity X.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `K = KIND(X)'

_Arguments_:
     X          Shall be of type `LOGICAL', `INTEGER', `REAL',
                `COMPLEX' or `CHARACTER'.

_Return value_:
     The return value is a scalar of type `INTEGER' and of the default
     integer kind.

_Example_:
          program test_kind
            integer,parameter :: kc = kind(' ')
            integer,parameter :: kl = kind(.true.)

            print *, "The default character kind is ", kc
            print *, "The default logical kind is ", kl
          end program test_kind



File: gfortran.info,  Node: LBOUND,  Next: LEADZ,  Prev: KIND,  Up: Intrinsic Procedures

7.126 `LBOUND' -- Lower dimension bounds of an array
====================================================

_Description_:
     Returns the lower bounds of an array, or a single lower bound
     along the DIM dimension.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = LBOUND(ARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY      Shall be an array, of any type.
     DIM        (Optional) Shall be a scalar `INTEGER'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the lower bounds of ARRAY.  If
     DIM is present, the result is a scalar corresponding to the lower
     bound of the array along that dimension.  If ARRAY is an
     expression rather than a whole array or array structure component,
     or if it has a zero extent along the relevant dimension, the lower
     bound is taken to be 1.

_See also_:
     *note UBOUND::


File: gfortran.info,  Node: LEADZ,  Next: LEN,  Prev: LBOUND,  Up: Intrinsic Procedures

7.127 `LEADZ' -- Number of leading zero bits of an integer
==========================================================

_Description_:
     `LEADZ' returns the number of leading zero bits of an integer.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LEADZ(I)'

_Arguments_:
     I          Shall be of type `INTEGER'.

_Return value_:
     The type of the return value is the default `INTEGER'.  If all the
     bits of `I' are zero, the result value is `BIT_SIZE(I)'.

_Example_:
          PROGRAM test_leadz
            WRITE (*,*) LEADZ(1)  ! prints 8 if BITSIZE(I) has the value 32
          END PROGRAM

_See also_:
     *note BIT_SIZE::, *note TRAILZ::


File: gfortran.info,  Node: LEN,  Next: LEN_TRIM,  Prev: LEADZ,  Up: Intrinsic Procedures

7.128 `LEN' -- Length of a character entity
===========================================

_Description_:
     Returns the length of a character string.  If STRING is an array,
     the length of an element of STRING is returned.  Note that STRING
     need not be defined when this intrinsic is invoked, since only the
     length, not the content, of STRING is needed.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `L = LEN(STRING [, KIND])'

_Arguments_:
     STRING     Shall be a scalar or array of type
                `CHARACTER', with `INTENT(IN)'
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_See also_:
     *note LEN_TRIM::, *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: LEN_TRIM,  Next: LOG_GAMMA,  Prev: LEN,  Up: Intrinsic Procedures

7.129 `LEN_TRIM' -- Length of a character entity without trailing blank characters
==================================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LEN_TRIM(STRING [, KIND])'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER', with
                `INTENT(IN)'
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_See also_:
     *note LEN::, *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: LGE,  Next: LGT,  Prev: LOG_GAMMA,  Up: Intrinsic Procedures

7.130 `LGE' -- Lexical greater than or equal
============================================

_Description_:
     Determines whether one string is lexically greater than or equal to
     another string, where the two strings are interpreted as containing
     ASCII character codes.  If the String A and String B are not the
     same length, the shorter is compared as if spaces were appended to
     it to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LGE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A >= STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *note LGT::, *note LLE::, *note LLT::


File: gfortran.info,  Node: LGT,  Next: LINK,  Prev: LGE,  Up: Intrinsic Procedures

7.131 `LGT' -- Lexical greater than
===================================

_Description_:
     Determines whether one string is lexically greater than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it
     to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LGT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A > STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *note LGE::, *note LLE::, *note LLT::


File: gfortran.info,  Node: LINK,  Next: LLE,  Prev: LGT,  Up: Intrinsic Procedures

7.132 `LINK' -- Create a hard link
==================================

_Description_:
     Makes a (hard) link from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `link(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL LINK(PATH1, PATH2 [, STATUS])'
     `STATUS = LINK(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *note SYMLNK::, *note UNLINK::


File: gfortran.info,  Node: LLE,  Next: LLT,  Prev: LINK,  Up: Intrinsic Procedures

7.133 `LLE' -- Lexical less than or equal
=========================================

_Description_:
     Determines whether one string is lexically less than or equal to
     another string, where the two strings are interpreted as
     containing ASCII character codes.  If the String A and String B
     are not the same length, the shorter is compared as if spaces were
     appended to it to form a value that has the same length as the
     longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LLE(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A <= STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *note LGE::, *note LGT::, *note LLT::


File: gfortran.info,  Node: LLT,  Next: LNBLNK,  Prev: LLE,  Up: Intrinsic Procedures

7.134 `LLT' -- Lexical less than
================================

_Description_:
     Determines whether one string is lexically less than another
     string, where the two strings are interpreted as containing ASCII
     character codes.  If the String A and String B are not the same
     length, the shorter is compared as if spaces were appended to it
     to form a value that has the same length as the longer.

     In general, the lexical comparison intrinsics `LGE', `LGT', `LLE',
     and `LLT' differ from the corresponding intrinsic operators
     `.GE.', `.GT.', `.LE.', and `.LT.', in that the latter use the
     processor's character ordering (which is not ASCII on some
     targets), whereas the former always use the ASCII ordering.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LLT(STRING_A, STRING_B)'

_Arguments_:
     STRING_A   Shall be of default `CHARACTER' type.
     STRING_B   Shall be of default `CHARACTER' type.

_Return value_:
     Returns `.TRUE.' if `STRING_A < STRING_B', and `.FALSE.'
     otherwise, based on the ASCII ordering.

_See also_:
     *note LGE::, *note LGT::, *note LLE::


File: gfortran.info,  Node: LNBLNK,  Next: LOC,  Prev: LLT,  Up: Intrinsic Procedures

7.135 `LNBLNK' -- Index of the last non-blank character in a string
===================================================================

_Description_:
     Returns the length of a character string, ignoring any trailing
     blanks.  This is identical to the standard `LEN_TRIM' intrinsic,
     and is only included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LNBLNK(STRING)'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER', with
                `INTENT(IN)'

_Return value_:
     The return value is of `INTEGER(kind=4)' type.

_See also_:
     *note INDEX intrinsic::, *note LEN_TRIM::


File: gfortran.info,  Node: LOC,  Next: LOG,  Prev: LNBLNK,  Up: Intrinsic Procedures

7.136 `LOC' -- Returns the address of a variable
================================================

_Description_:
     `LOC(X)' returns the address of X as an integer.

_Standard_:
     GNU extension

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = LOC(X)'

_Arguments_:
     X          Variable of any type.

_Return value_:
     The return value is of type `INTEGER', with a `KIND' corresponding
     to the size (in bytes) of a memory address on the target machine.

_Example_:
          program test_loc
            integer :: i
            real :: r
            i = loc(r)
            print *, i
          end program test_loc


File: gfortran.info,  Node: LOG,  Next: LOG10,  Prev: LOC,  Up: Intrinsic Procedures

7.137 `LOG' -- Logarithm function
=================================

_Description_:
     `LOG(X)' computes the logarithm of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOG(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `REAL' or `COMPLEX'.  The kind type
     parameter is the same as X.  If X is `COMPLEX', the imaginary part
     \omega is in the range -\pi \leq \omega \leq \pi.

_Example_:
          program test_log
            real(8) :: x = 1.0_8
            complex :: z = (1.0, 2.0)
            x = log(x)
            z = log(z)
          end program test_log

_Specific names_:
     Name          Argument      Return type   Standard
     `ALOG(X)'     `REAL(4) X'   `REAL(4)'     f95, gnu
     `DLOG(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
     `CLOG(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
                   X'                          
     `ZLOG(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          
     `CDLOG(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          


File: gfortran.info,  Node: LOG10,  Next: LOGICAL,  Prev: LOG,  Up: Intrinsic Procedures

7.138 `LOG10' -- Base 10 logarithm function
===========================================

_Description_:
     `LOG10(X)' computes the base 10 logarithm of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOG10(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' or `COMPLEX'.  The kind type
     parameter is the same as X.

_Example_:
          program test_log10
            real(8) :: x = 10.0_8
            x = log10(x)
          end program test_log10

_Specific names_:
     Name          Argument      Return type   Standard
     `ALOG10(X)'   `REAL(4) X'   `REAL(4)'     Fortran 95 and
                                               later
     `DLOG10(X)'   `REAL(8) X'   `REAL(8)'     Fortran 95 and
                                               later


File: gfortran.info,  Node: LOG_GAMMA,  Next: LGE,  Prev: LEN_TRIM,  Up: Intrinsic Procedures

7.139 `LOG_GAMMA' -- Logarithm of the Gamma function
====================================================

_Description_:
     `LOG_GAMMA(X)' computes the natural logarithm of the absolute value
     of the Gamma (\Gamma) function.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `X = LOG_GAMMA(X)'

_Arguments_:
     X          Shall be of type `REAL' and neither zero nor a
                negative integer.

_Return value_:
     The return value is of type `REAL' of the same kind as X.

_Example_:
          program test_log_gamma
            real :: x = 1.0
            x = lgamma(x) ! returns 0.0
          end program test_log_gamma

_Specific names_:
     Name          Argument      Return type   Standard
     `LGAMMA(X)'   `REAL(4) X'   `REAL(4)'     GNU Extension
     `ALGAMA(X)'   `REAL(4) X'   `REAL(4)'     GNU Extension
     `DLGAMA(X)'   `REAL(8) X'   `REAL(8)'     GNU Extension

_See also_:
     Gamma function: *note GAMMA::



File: gfortran.info,  Node: LOGICAL,  Next: LONG,  Prev: LOG10,  Up: Intrinsic Procedures

7.140 `LOGICAL' -- Convert to logical type
==========================================

_Description_:
     Converts one kind of `LOGICAL' variable to another.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LOGICAL(L [, KIND])'

_Arguments_:
     L          The type shall be `LOGICAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is a `LOGICAL' value equal to L, with a kind
     corresponding to KIND, or of the default logical kind if KIND is
     not given.

_See also_:
     *note INT::, *note REAL::, *note CMPLX::


File: gfortran.info,  Node: LONG,  Next: LSHIFT,  Prev: LOGICAL,  Up: Intrinsic Procedures

7.141 `LONG' -- Convert to integer type
=======================================

_Description_:
     Convert to a `KIND=4' integer type, which is the same size as a C
     `long' integer.  This is equivalent to the standard `INT'
     intrinsic with an optional argument of `KIND=4', and is only
     included for backwards compatibility.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LONG(A)'

_Arguments_:
     A          Shall be of type `INTEGER', `REAL', or
                `COMPLEX'.

_Return value_:
     The return value is a `INTEGER(4)' variable.

_See also_:
     *note INT::, *note INT2::, *note INT8::


File: gfortran.info,  Node: LSHIFT,  Next: LSTAT,  Prev: LONG,  Up: Intrinsic Procedures

7.142 `LSHIFT' -- Left shift bits
=================================

_Description_:
     `LSHIFT' returns a value corresponding to I with all of the bits
     shifted left by SHIFT places.  If the absolute value of SHIFT is
     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
     out from the left end are lost; zeros are shifted in from the
     opposite end.

     This function has been superseded by the `ISHFT' intrinsic, which
     is standard in Fortran 95 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = LSHIFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER'.
     SHIFT      The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note ISHFT::, *note ISHFTC::, *note RSHIFT::



File: gfortran.info,  Node: LSTAT,  Next: LTIME,  Prev: LSHIFT,  Up: Intrinsic Procedures

7.143 `LSTAT' -- Get file status
================================

_Description_:
     `LSTAT' is identical to *note STAT::, except that if path is a
     symbolic link, then the link itself is statted, not the file that
     it refers to.

     The elements in `BUFF' are the same as described by *note STAT::.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL LSTAT(FILE, BUFF [, STATUS])'

_Arguments_:
     FILE       The type shall be `CHARACTER' of the default
                kind, a valid path within the file system.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0 on success and a system specific
                error code otherwise.

_Example_:
     See *note STAT:: for an example.

_See also_:
     To stat an open file: *note FSTAT::, to stat a file: *note STAT::


File: gfortran.info,  Node: LTIME,  Next: MALLOC,  Prev: LSTAT,  Up: Intrinsic Procedures

7.144 `LTIME' -- Convert time to local time info
================================================

_Description_:
     Given a system time value STIME (as provided by the `TIME8()'
     intrinsic), fills TARRAY with values extracted from it appropriate
     to the local time zone using `localtime(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL LTIME(STIME, TARRAY)'

_Arguments_:
     STIME      An `INTEGER' scalar expression corresponding
                to a system time, with `INTENT(IN)'.
     TARRAY     A default `INTEGER' array with 9 elements,
                with `INTENT(OUT)'.

_Return value_:
     The elements of TARRAY are assigned as follows:
       1. Seconds after the minute, range 0-59 or 0-61 to allow for leap
          seconds

       2. Minutes after the hour, range 0-59

       3. Hours past midnight, range 0-23

       4. Day of month, range 0-31

       5. Number of months since January, range 0-12

       6. Years since 1900

       7. Number of days since Sunday, range 0-6

       8. Days since January 1

       9. Daylight savings indicator: positive if daylight savings is in
          effect, zero if not, and negative if the information is not
          available.

_See also_:
     *note CTIME::, *note GMTIME::, *note TIME::, *note TIME8::



File: gfortran.info,  Node: MALLOC,  Next: MATMUL,  Prev: LTIME,  Up: Intrinsic Procedures

7.145 `MALLOC' -- Allocate dynamic memory
=========================================

_Description_:
     `MALLOC(SIZE)' allocates SIZE bytes of dynamic memory and returns
     the address of the allocated memory. The `MALLOC' intrinsic is an
     extension intended to be used with Cray pointers, and is provided
     in GNU Fortran to allow the user to compile legacy code. For new
     code using Fortran 95 pointers, the memory allocation intrinsic is
     `ALLOCATE'.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `PTR = MALLOC(SIZE)'

_Arguments_:
     SIZE       The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER(K)', with K such that
     variables of type `INTEGER(K)' have the same size as C pointers
     (`sizeof(void *)').

_Example_:
     The following example demonstrates the use of `MALLOC' and `FREE'
     with Cray pointers.

          program test_malloc
            implicit none
            integer i
            real*8 x(*), z
            pointer(ptr_x,x)

            ptr_x = malloc(20*8)
            do i = 1, 20
              x(i) = sqrt(1.0d0 / i)
            end do
            z = 0
            do i = 1, 20
              z = z + x(i)
              print *, z
            end do
            call free(ptr_x)
          end program test_malloc

_See also_:
     *note FREE::


File: gfortran.info,  Node: MATMUL,  Next: MAX,  Prev: MALLOC,  Up: Intrinsic Procedures

7.146 `MATMUL' -- matrix multiplication
=======================================

_Description_:
     Performs a matrix multiplication on numeric or logical arguments.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MATMUL(MATRIX_A, MATRIX_B)'

_Arguments_:
     MATRIX_A   An array of `INTEGER', `REAL', `COMPLEX', or
                `LOGICAL' type, with a rank of one or two.
     MATRIX_B   An array of `INTEGER', `REAL', or `COMPLEX'
                type if MATRIX_A is of a numeric type;
                otherwise, an array of `LOGICAL' type. The
                rank shall be one or two, and the first (or
                only) dimension of MATRIX_B shall be equal to
                the last (or only) dimension of MATRIX_A.

_Return value_:
     The matrix product of MATRIX_A and MATRIX_B.  The type and kind of
     the result follow the usual type and kind promotion rules, as for
     the `*' or `.AND.' operators.

_See also_:


File: gfortran.info,  Node: MAX,  Next: MAXEXPONENT,  Prev: MATMUL,  Up: Intrinsic Procedures

7.147 `MAX' -- Maximum value of an argument list
================================================

_Description_:
     Returns the argument with the largest (most positive) value.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MAX(A1, A2 [, A3 [, ...]])'

_Arguments_:
     A1         The type shall be `INTEGER' or `REAL'.
     A2, A3,    An expression of the same type and kind as A1.
     ...        (As a GNU extension, arguments of different
                kinds are permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name          Argument      Return type   Standard
     `MAX0(I)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
                   I'                          later
     `AMAX0(I)'    `INTEGER(4)   `REAL(MAX(X))'Fortran 77 and
                   I'                          later
     `MAX1(X)'     `REAL X'      `INT(MAX(X))' Fortran 77 and
                                               later
     `AMAX1(X)'    `REAL(4)      `REAL(4)'     Fortran 77 and
                   X'                          later
     `DMAX1(X)'    `REAL(8)      `REAL(8)'     Fortran 77 and
                   X'                          later

_See also_:
     *note MAXLOC:: *note MAXVAL::, *note MIN::



File: gfortran.info,  Node: MAXEXPONENT,  Next: MAXLOC,  Prev: MAX,  Up: Intrinsic Procedures

7.148 `MAXEXPONENT' -- Maximum exponent of a real kind
======================================================

_Description_:
     `MAXEXPONENT(X)' returns the maximum exponent in the model of the
     type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = MAXEXPONENT(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program exponents
            real(kind=4) :: x
            real(kind=8) :: y

            print *, minexponent(x), maxexponent(x)
            print *, minexponent(y), maxexponent(y)
          end program exponents


File: gfortran.info,  Node: MAXLOC,  Next: MAXVAL,  Prev: MAXEXPONENT,  Up: Intrinsic Procedures

7.149 `MAXLOC' -- Location of the maximum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     maximum value, or, if the DIM argument is supplied, determines the
     locations of the maximum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is `.TRUE.' are considered.  If more than one element in the
     array has the maximum value, the location returned is that of the
     first such element in array element order.  If the array has zero
     size, or all of the elements of MASK are `.FALSE.', then the
     result is an array of zeroes.  Similarly, if DIM is supplied and
     all of the elements of MASK along a given row are zero, the result
     value for that row is zero.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MAXLOC(ARRAY, DIM [, MASK])'
     `RESULT = MAXLOC(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL',
                or `CHARACTER'.
     DIM        (Optional) Shall be a scalar of type
                `INTEGER', with a value between one and the
                rank of ARRAY, inclusive.  It may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL', and
                conformable with ARRAY.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  In all cases, the result is of default `INTEGER' type.

_See also_:
     *note MAX::, *note MAXVAL::



File: gfortran.info,  Node: MAXVAL,  Next: MCLOCK,  Prev: MAXLOC,  Up: Intrinsic Procedures

7.150 `MAXVAL' -- Maximum value of an array
===========================================

_Description_:
     Determines the maximum value of the elements in an array value,
     or, if the DIM argument is supplied, determines the maximum value
     along each row of the array in the DIM direction.  If MASK is
     present, only the elements for which MASK is `.TRUE.' are
     considered.  If the array has zero size, or all of the elements of
     MASK are `.FALSE.', then the result is `-HUGE(ARRAY)' if ARRAY is
     numeric, or a string of nulls if ARRAY is of character type.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MAXVAL(ARRAY, DIM [, MASK])'
     `RESULT = MAXVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL',
                or `CHARACTER'.
     DIM        (Optional) Shall be a scalar of type
                `INTEGER', with a value between one and the
                rank of ARRAY, inclusive.  It may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL', and
                conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *note MAX::, *note MAXLOC::


File: gfortran.info,  Node: MCLOCK,  Next: MCLOCK8,  Prev: MAXVAL,  Up: Intrinsic Procedures

7.151 `MCLOCK' -- Time function
===============================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the UNIX function `clock(3)'.

     This intrinsic is not fully portable, such as to systems with
     32-bit `INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = MCLOCK()'

_Return value_:
     The return value is a scalar of type `INTEGER(4)', equal to the
     number of clock ticks since the start of the process, or `-1' if
     the system does not support `clock(3)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
     *note TIME::



File: gfortran.info,  Node: MCLOCK8,  Next: MERGE,  Prev: MCLOCK,  Up: Intrinsic Procedures

7.152 `MCLOCK8' -- Time function (64-bit)
=========================================

_Description_:
     Returns the number of clock ticks since the start of the process,
     based on the UNIX function `clock(3)'.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by `clock(3)'. On a system with a 32-bit
     `clock(3)', `MCLOCK8()' will return a 32-bit value, even though it
     is converted to a 64-bit `INTEGER(8)' value. That means overflows
     of the 32-bit value can still occur. Therefore, the values
     returned by this intrinsic might be or become negative or
     numerically less than previous values during a single run of the
     compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = MCLOCK8()'

_Return value_:
     The return value is a scalar of type `INTEGER(8)', equal to the
     number of clock ticks since the start of the process, or `-1' if
     the system does not support `clock(3)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
     *note TIME8::



File: gfortran.info,  Node: MERGE,  Next: MIN,  Prev: MCLOCK8,  Up: Intrinsic Procedures

7.153 `MERGE' -- Merge variables
================================

_Description_:
     Select values from two arrays according to a logical mask.  The
     result is equal to TSOURCE if MASK is `.TRUE.', or equal to
     FSOURCE if it is `.FALSE.'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MERGE(TSOURCE, FSOURCE, MASK)'

_Arguments_:
     TSOURCE    May be of any type.
     FSOURCE    Shall be of the same type and type parameters
                as TSOURCE.
     MASK       Shall be of type `LOGICAL'.

_Return value_:
     The result is of the same type and type parameters as TSOURCE.



File: gfortran.info,  Node: MIN,  Next: MINEXPONENT,  Prev: MERGE,  Up: Intrinsic Procedures

7.154 `MIN' -- Minimum value of an argument list
================================================

_Description_:
     Returns the argument with the smallest (most negative) value.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MIN(A1, A2 [, A3, ...])'

_Arguments_:
     A1         The type shall be `INTEGER' or `REAL'.
     A2, A3,    An expression of the same type and kind as A1.
     ...        (As a GNU extension, arguments of different
                kinds are permitted.)

_Return value_:
     The return value corresponds to the maximum value among the
     arguments, and has the same type and kind as the first argument.

_Specific names_:
     Name          Argument      Return type   Standard
     `MIN0(I)'     `INTEGER(4)   `INTEGER(4)'  Fortran 77 and
                   I'                          later
     `AMIN0(I)'    `INTEGER(4)   `REAL(MIN(X))'Fortran 77 and
                   I'                          later
     `MIN1(X)'     `REAL X'      `INT(MIN(X))' Fortran 77 and
                                               later
     `AMIN1(X)'    `REAL(4)      `REAL(4)'     Fortran 77 and
                   X'                          later
     `DMIN1(X)'    `REAL(8)      `REAL(8)'     Fortran 77 and
                   X'                          later

_See also_:
     *note MAX::, *note MINLOC::, *note MINVAL::


File: gfortran.info,  Node: MINEXPONENT,  Next: MINLOC,  Prev: MIN,  Up: Intrinsic Procedures

7.155 `MINEXPONENT' -- Minimum exponent of a real kind
======================================================

_Description_:
     `MINEXPONENT(X)' returns the minimum exponent in the model of the
     type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = MINEXPONENT(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
     See `MAXEXPONENT' for an example.


File: gfortran.info,  Node: MINLOC,  Next: MINVAL,  Prev: MINEXPONENT,  Up: Intrinsic Procedures

7.156 `MINLOC' -- Location of the minimum value within an array
===============================================================

_Description_:
     Determines the location of the element in the array with the
     minimum value, or, if the DIM argument is supplied, determines the
     locations of the minimum element along each row of the array in the
     DIM direction.  If MASK is present, only the elements for which
     MASK is `.TRUE.' are considered.  If more than one element in the
     array has the minimum value, the location returned is that of the
     first such element in array element order.  If the array has zero
     size, or all of the elements of MASK are `.FALSE.', then the
     result is an array of zeroes.  Similarly, if DIM is supplied and
     all of the elements of MASK along a given row are zero, the result
     value for that row is zero.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MINLOC(ARRAY, DIM [, MASK])'
     `RESULT = MINLOC(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL',
                or `CHARACTER'.
     DIM        (Optional) Shall be a scalar of type
                `INTEGER', with a value between one and the
                rank of ARRAY, inclusive.  It may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL', and
                conformable with ARRAY.

_Return value_:
     If DIM is absent, the result is a rank-one array with a length
     equal to the rank of ARRAY.  If DIM is present, the result is an
     array with a rank one less than the rank of ARRAY, and a size
     corresponding to the size of ARRAY with the DIM dimension removed.
     If DIM is present and ARRAY has a rank of one, the result is a
     scalar.  In all cases, the result is of default `INTEGER' type.

_See also_:
     *note MIN::, *note MINVAL::



File: gfortran.info,  Node: MINVAL,  Next: MOD,  Prev: MINLOC,  Up: Intrinsic Procedures

7.157 `MINVAL' -- Minimum value of an array
===========================================

_Description_:
     Determines the minimum value of the elements in an array value,
     or, if the DIM argument is supplied, determines the minimum value
     along each row of the array in the DIM direction.  If MASK is
     present, only the elements for which MASK is `.TRUE.' are
     considered.  If the array has zero size, or all of the elements of
     MASK are `.FALSE.', then the result is `HUGE(ARRAY)' if ARRAY is
     numeric, or a string of `CHAR(255)' characters if ARRAY is of
     character type.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = MINVAL(ARRAY, DIM [, MASK])'
     `RESULT = MINVAL(ARRAY [, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL',
                or `CHARACTER'.
     DIM        (Optional) Shall be a scalar of type
                `INTEGER', with a value between one and the
                rank of ARRAY, inclusive.  It may not be an
                optional dummy argument.
     MASK       Shall be an array of type `LOGICAL', and
                conformable with ARRAY.

_Return value_:
     If DIM is absent, or if ARRAY has a rank of one, the result is a
     scalar.  If DIM is present, the result is an array with a rank one
     less than the rank of ARRAY, and a size corresponding to the size
     of ARRAY with the DIM dimension removed.  In all cases, the result
     is of the same type and kind as ARRAY.

_See also_:
     *note MIN::, *note MINLOC::



File: gfortran.info,  Node: MOD,  Next: MODULO,  Prev: MINVAL,  Up: Intrinsic Procedures

7.158 `MOD' -- Remainder function
=================================

_Description_:
     `MOD(A,P)' computes the remainder of the division of A by P. It is
     calculated as `A - (INT(A/P) * P)'.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MOD(A, P)'

_Arguments_:
     A          Shall be a scalar of type `INTEGER' or `REAL'
     P          Shall be a scalar of the same type as A and not
                equal to zero

_Return value_:
     The kind of the return value is the result of cross-promoting the
     kinds of the arguments.

_Example_:
          program test_mod
            print *, mod(17,3)
            print *, mod(17.5,5.5)
            print *, mod(17.5d0,5.5)
            print *, mod(17.5,5.5d0)

            print *, mod(-17,3)
            print *, mod(-17.5,5.5)
            print *, mod(-17.5d0,5.5)
            print *, mod(-17.5,5.5d0)

            print *, mod(17,-3)
            print *, mod(17.5,-5.5)
            print *, mod(17.5d0,-5.5)
            print *, mod(17.5,-5.5d0)
          end program test_mod

_Specific names_:
     Name          Arguments     Return type   Standard
     `AMOD(A,P)'   `REAL(4)'     `REAL(4)'     Fortran 95 and
                                               later
     `DMOD(A,P)'   `REAL(8)'     `REAL(8)'     Fortran 95 and
                                               later


File: gfortran.info,  Node: MODULO,  Next: MOVE_ALLOC,  Prev: MOD,  Up: Intrinsic Procedures

7.159 `MODULO' -- Modulo function
=================================

_Description_:
     `MODULO(A,P)' computes the A modulo P.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = MODULO(A, P)'

_Arguments_:
     A          Shall be a scalar of type `INTEGER' or `REAL'
     P          Shall be a scalar of the same type and kind as
                A

_Return value_:
     The type and kind of the result are those of the arguments.
    If A and P are of type `INTEGER':
          `MODULO(A,P)' has the value R such that `A=Q*P+R', where Q is
          an integer and R is between 0 (inclusive) and P (exclusive).

    If A and P are of type `REAL':
          `MODULO(A,P)' has the value of `A - FLOOR (A / P) * P'.
     In all cases, if P is zero the result is processor-dependent.

_Example_:
          program test_modulo
            print *, modulo(17,3)
            print *, modulo(17.5,5.5)

            print *, modulo(-17,3)
            print *, modulo(-17.5,5.5)

            print *, modulo(17,-3)
            print *, modulo(17.5,-5.5)
          end program



File: gfortran.info,  Node: MOVE_ALLOC,  Next: MVBITS,  Prev: MODULO,  Up: Intrinsic Procedures

7.160 `MOVE_ALLOC' -- Move allocation from one object to another
================================================================

_Description_:
     `MOVE_ALLOC(SRC, DEST)' moves the allocation from SRC to DEST.
     SRC will become deallocated in the process.

_Standard_:
     Fortran 2003 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL MOVE_ALLOC(SRC, DEST)'

_Arguments_:
     SRC        `ALLOCATABLE', `INTENT(INOUT)', may be of any
                type and kind.
     DEST       `ALLOCATABLE', `INTENT(OUT)', shall be of the
                same type, kind and rank as SRC.

_Return value_:
     None

_Example_:
          program test_move_alloc
              integer, allocatable :: a(:), b(:)

              allocate(a(3))
              a = [ 1, 2, 3 ]
              call move_alloc(a, b)
              print *, allocated(a), allocated(b)
              print *, b
          end program test_move_alloc


File: gfortran.info,  Node: MVBITS,  Next: NEAREST,  Prev: MOVE_ALLOC,  Up: Intrinsic Procedures

7.161 `MVBITS' -- Move bits from one integer to another
=======================================================

_Description_:
     Moves LEN bits from positions FROMPOS through `FROMPOS+LEN-1' of
     FROM to positions TOPOS through `TOPOS+LEN-1' of TO. The portion
     of argument TO not affected by the movement of bits is unchanged.
     The values of `FROMPOS+LEN-1' and `TOPOS+LEN-1' must be less than
     `BIT_SIZE(FROM)'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental subroutine

_Syntax_:
     `CALL MVBITS(FROM, FROMPOS, LEN, TO, TOPOS)'

_Arguments_:
     FROM       The type shall be `INTEGER'.
     FROMPOS    The type shall be `INTEGER'.
     LEN        The type shall be `INTEGER'.
     TO         The type shall be `INTEGER', of the same kind
                as FROM.
     TOPOS      The type shall be `INTEGER'.

_See also_:
     *note IBCLR::, *note IBSET::, *note IBITS::, *note IAND::, *note
     IOR::, *note IEOR::


File: gfortran.info,  Node: NEAREST,  Next: NEW_LINE,  Prev: MVBITS,  Up: Intrinsic Procedures

7.162 `NEAREST' -- Nearest representable number
===============================================

_Description_:
     `NEAREST(X, S)' returns the processor-representable number nearest
     to `X' in the direction indicated by the sign of `S'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NEAREST(X, S)'

_Arguments_:
     X          Shall be of type `REAL'.
     S          (Optional) shall be of type `REAL' and not
                equal to zero.

_Return value_:
     The return value is of the same type as `X'. If `S' is positive,
     `NEAREST' returns the processor-representable number greater than
     `X' and nearest to it. If `S' is negative, `NEAREST' returns the
     processor-representable number smaller than `X' and nearest to it.

_Example_:
          program test_nearest
            real :: x, y
            x = nearest(42.0, 1.0)
            y = nearest(42.0, -1.0)
            write (*,"(3(G20.15))") x, y, x - y
          end program test_nearest


File: gfortran.info,  Node: NEW_LINE,  Next: NINT,  Prev: NEAREST,  Up: Intrinsic Procedures

7.163 `NEW_LINE' -- New line character
======================================

_Description_:
     `NEW_LINE(C)' returns the new-line character.

_Standard_:
     Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = NEW_LINE(C)'

_Arguments_:
     C          The argument shall be a scalar or array of the
                type `CHARACTER'.

_Return value_:
     Returns a CHARACTER scalar of length one with the new-line
     character of the same kind as parameter C.

_Example_:
          program newline
            implicit none
            write(*,'(A)') 'This is record 1.'//NEW_LINE('A')//'This is record 2.'
          end program newline


File: gfortran.info,  Node: NINT,  Next: NOT,  Prev: NEW_LINE,  Up: Intrinsic Procedures

7.164 `NINT' -- Nearest whole number
====================================

_Description_:
     `NINT(X)' rounds its argument to the nearest whole number.

_Standard_:
     Fortran 77 and later, with KIND argument Fortran 90 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NINT(X [, KIND])'

_Arguments_:
     X          The type of the argument shall be `REAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     Returns A with the fractional portion of its magnitude eliminated
     by rounding to the nearest whole number and with its sign
     preserved, converted to an `INTEGER' of the default kind.

_Example_:
          program test_nint
            real(4) x4
            real(8) x8
            x4 = 1.234E0_4
            x8 = 4.321_8
            print *, nint(x4), idnint(x8)
          end program test_nint

_Specific names_:
     Name              Argument          Standard
     `IDNINT(X)'       `REAL(8)'         Fortran 95 and
                                         later

_See also_:
     *note CEILING::, *note FLOOR::



File: gfortran.info,  Node: NOT,  Next: NULL,  Prev: NINT,  Up: Intrinsic Procedures

7.165 `NOT' -- Logical negation
===============================

_Description_:
     `NOT' returns the bitwise boolean inverse of I.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = NOT(I)'

_Arguments_:
     I          The type shall be `INTEGER'.

_Return value_:
     The return type is `INTEGER', of the same kind as the argument.

_See also_:
     *note IAND::, *note IEOR::, *note IOR::, *note IBITS::, *note
     IBSET::, *note IBCLR::



File: gfortran.info,  Node: NULL,  Next: OR,  Prev: NOT,  Up: Intrinsic Procedures

7.166 `NULL' -- Function that returns an disassociated pointer
==============================================================

_Description_:
     Returns a disassociated pointer.

     If MOLD is present, a dissassociated pointer of the same type is
     returned, otherwise the type is determined by context.

     In Fortran 95, MOLD is optional. Please note that Fortran 2003
     includes cases where it is required.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `PTR => NULL([MOLD])'

_Arguments_:
     MOLD       (Optional) shall be a pointer of any
                association status and of any type.

_Return value_:
     A disassociated pointer.

_Example_:
          REAL, POINTER, DIMENSION(:) :: VEC => NULL ()

_See also_:
     *note ASSOCIATED::


File: gfortran.info,  Node: OR,  Next: PACK,  Prev: NULL,  Up: Intrinsic Procedures

7.167 `OR' -- Bitwise logical OR
================================

_Description_:
     Bitwise logical `OR'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IOR:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = OR(X, Y)'

_Arguments_:
     X          The type shall be either a scalar `INTEGER'
                type or a scalar `LOGICAL' type.
     Y          The type shall be the same as the type of X.

_Return value_:
     The return type is either a scalar `INTEGER' or a scalar
     `LOGICAL'.  If the kind type parameters differ, then the smaller
     kind type is implicitly converted to larger kind, and the return
     has the larger kind.

_Example_:
          PROGRAM test_or
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) OR(T, T), OR(T, F), OR(F, T), OR(F, F)
            WRITE (*,*) OR(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IOR::


File: gfortran.info,  Node: PACK,  Next: PERROR,  Prev: OR,  Up: Intrinsic Procedures

7.168 `PACK' -- Pack an array into an array of rank one
=======================================================

_Description_:
     Stores the elements of ARRAY in an array of rank one.

     The beginning of the resulting array is made up of elements whose
     MASK equals `TRUE'. Afterwards, positions are filled with elements
     taken from VECTOR.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = PACK(ARRAY, MASK[,VECTOR]'

_Arguments_:
     ARRAY      Shall be an array of any type.
     MASK       Shall be an array of type `LOGICAL' and of the
                same size as ARRAY. Alternatively, it may be a
                `LOGICAL' scalar.
     VECTOR     (Optional) shall be an array of the same type
                as ARRAY and of rank one. If present, the
                number of elements in VECTOR shall be equal to
                or greater than the number of true elements in
                MASK. If MASK is scalar, the number of
                elements in VECTOR shall be equal to or
                greater than the number of elements in ARRAY.

_Return value_:
     The result is an array of rank one and the same type as that of
     ARRAY.  If VECTOR is present, the result size is that of VECTOR,
     the number of `TRUE' values in MASK otherwise.

_Example_:
     Gathering nonzero elements from an array:
          PROGRAM test_pack_1
            INTEGER :: m(6)
            m = (/ 1, 0, 0, 0, 5, 0 /)
            WRITE(*, FMT="(6(I0, ' '))") pack(m, m /= 0)  ! "1 5"
          END PROGRAM

     Gathering nonzero elements from an array and appending elements
     from VECTOR:
          PROGRAM test_pack_2
            INTEGER :: m(4)
            m = (/ 1, 0, 0, 2 /)
            WRITE(*, FMT="(4(I0, ' '))") pack(m, m /= 0, (/ 0, 0, 3, 4 /))  ! "1 2 3 4"
          END PROGRAM

_See also_:
     *note UNPACK::


File: gfortran.info,  Node: PERROR,  Next: PRECISION,  Prev: PACK,  Up: Intrinsic Procedures

7.169 `PERROR' -- Print system error message
============================================

_Description_:
     Prints (on the C `stderr' stream) a newline-terminated error
     message corresponding to the last system error. This is prefixed by
     STRING, a colon and a space. See `perror(3)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL PERROR(STRING)'

_Arguments_:
     STRING     A scalar of type `CHARACTER' and of the
                default kind.

_See also_:
     *note IERRNO::


File: gfortran.info,  Node: PRECISION,  Next: PRESENT,  Prev: PERROR,  Up: Intrinsic Procedures

7.170 `PRECISION' -- Decimal precision of a real kind
=====================================================

_Description_:
     `PRECISION(X)' returns the decimal precision in the model of the
     type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = PRECISION(X)'

_Arguments_:
     X          Shall be of type `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
          program prec_and_range
            real(kind=4) :: x(2)
            complex(kind=8) :: y

            print *, precision(x), range(x)
            print *, precision(y), range(y)
          end program prec_and_range


File: gfortran.info,  Node: PRESENT,  Next: PRODUCT,  Prev: PRECISION,  Up: Intrinsic Procedures

7.171 `PRESENT' -- Determine whether an optional dummy argument is specified
============================================================================

_Description_:
     Determines whether an optional dummy argument is present.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = PRESENT(A)'

_Arguments_:
     A          May be of any type and may be a pointer,
                scalar or array value, or a dummy procedure.
                It shall be the name of an optional dummy
                argument accessible within the current
                subroutine or function.

_Return value_:
     Returns either `TRUE' if the optional argument A is present, or
     `FALSE' otherwise.

_Example_:
          PROGRAM test_present
            WRITE(*,*) f(), f(42)      ! "F T"
          CONTAINS
            LOGICAL FUNCTION f(x)
              INTEGER, INTENT(IN), OPTIONAL :: x
              f = PRESENT(x)
            END FUNCTION
          END PROGRAM


File: gfortran.info,  Node: PRODUCT,  Next: RADIX,  Prev: PRESENT,  Up: Intrinsic Procedures

7.172 `PRODUCT' -- Product of array elements
============================================

_Description_:
     Multiplies the elements of ARRAY along dimension DIM if the
     corresponding element in MASK is `TRUE'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = PRODUCT(ARRAY[, MASK])' `RESULT = PRODUCT(ARRAY, DIM[,
     MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL' or
                `COMPLEX'.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                with a value in the range from 1 to n, where n
                equals the rank of ARRAY.
     MASK       (Optional) shall be of type `LOGICAL' and
                either be a scalar or an array of the same
                shape as ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the product of all elements in
     ARRAY is returned. Otherwise, an array of rank n-1, where n equals
     the rank of ARRAY, and a shape similar to that of ARRAY with
     dimension DIM dropped is returned.

_Example_:
          PROGRAM test_product
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, PRODUCT(x)                    ! all elements, product = 120
            print *, PRODUCT(x, MASK=MOD(x, 2)==1) ! odd elements, product = 15
          END PROGRAM

_See also_:
     *note SUM::


File: gfortran.info,  Node: RADIX,  Next: RANDOM_NUMBER,  Prev: PRODUCT,  Up: Intrinsic Procedures

7.173 `RADIX' -- Base of a model number
=======================================

_Description_:
     `RADIX(X)' returns the base of the model representing the entity X.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = RADIX(X)'

_Arguments_:
     X          Shall be of type `INTEGER' or `REAL'

_Return value_:
     The return value is a scalar of type `INTEGER' and of the default
     integer kind.

_Example_:
          program test_radix
            print *, "The radix for the default integer kind is", radix(0)
            print *, "The radix for the default real kind is", radix(0.0)
          end program test_radix



File: gfortran.info,  Node: RAN,  Next: REAL,  Prev: RANGE,  Up: Intrinsic Procedures

7.174 `RAN' -- Real pseudo-random number
========================================

_Description_:
     For compatibility with HP FORTRAN 77/iX, the `RAN' intrinsic is
     provided as an alias for `RAND'.  See *note RAND:: for complete
     documentation.

_Standard_:
     GNU extension

_Class_:
     Function

_See also_:
     *note RAND::, *note RANDOM_NUMBER::


File: gfortran.info,  Node: RAND,  Next: RANGE,  Prev: RANDOM_SEED,  Up: Intrinsic Procedures

7.175 `RAND' -- Real pseudo-random number
=========================================

_Description_:
     `RAND(FLAG)' returns a pseudo-random number from a uniform
     distribution between 0 and 1. If FLAG is 0, the next number in the
     current sequence is returned; if FLAG is 1, the generator is
     restarted by `CALL SRAND(0)'; if FLAG has any other value, it is
     used as a new seed with `SRAND'.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77. It implements a simple modulo generator as provided
     by `g77'. For new code, one should consider the use of *note
     RANDOM_NUMBER:: as it implements a superior algorithm.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = RAND(FLAG)'

_Arguments_:
     FLAG       Shall be a scalar `INTEGER' of kind 4.

_Return value_:
     The return value is of `REAL' type and the default kind.

_Example_:
          program test_rand
            integer,parameter :: seed = 86456

            call srand(seed)
            print *, rand(), rand(), rand(), rand()
            print *, rand(seed), rand(), rand(), rand()
          end program test_rand

_See also_:
     *note SRAND::, *note RANDOM_NUMBER::



File: gfortran.info,  Node: RANDOM_NUMBER,  Next: RANDOM_SEED,  Prev: RADIX,  Up: Intrinsic Procedures

7.176 `RANDOM_NUMBER' -- Pseudo-random number
=============================================

_Description_:
     Returns a single pseudorandom number or an array of pseudorandom
     numbers from the uniform distribution over the range  0 \leq x < 1.

     The runtime-library implements George Marsaglia's KISS (Keep It
     Simple Stupid) random number generator (RNG). This RNG combines:
       1. The congruential generator x(n) = 69069 \cdot x(n-1) +
          1327217885 with a period of 2^32,

       2. A 3-shift shift-register generator with a period of 2^32 - 1,

       3. Two 16-bit multiply-with-carry generators with a period of
          597273182964842497 > 2^59.
          The overall period exceeds 2^123.

     Please note, this RNG is thread safe if used within OpenMP
     directives, i.e., its state will be consistent while called from
     multiple threads.  However, the KISS generator does not create
     random numbers in parallel from multiple sources, but in sequence
     from a single source. If an OpenMP-enabled application heavily
     relies on random numbers, one should consider employing a
     dedicated parallel random number generator instead.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     `RANDOM_NUMBER(HARVEST)'

_Arguments_:
     HARVEST    Shall be a scalar or an array of type `REAL'.

_Example_:
          program test_random_number
            REAL :: r(5,5)
            CALL init_random_seed()         ! see example of RANDOM_SEED
            CALL RANDOM_NUMBER(r)
          end program

_See also_:
     *note RANDOM_SEED::


File: gfortran.info,  Node: RANDOM_SEED,  Next: RAND,  Prev: RANDOM_NUMBER,  Up: Intrinsic Procedures

7.177 `RANDOM_SEED' -- Initialize a pseudo-random number sequence
=================================================================

_Description_:
     Restarts or queries the state of the pseudorandom number generator
     used by `RANDOM_NUMBER'.

     If `RANDOM_SEED' is called without arguments, it is initialized to
     a default state. The example below shows how to initialize the
     random seed based on the system's time.

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL RANDOM_SEED(SIZE, PUT, GET)'

_Arguments_:
     SIZE       (Optional) Shall be a scalar and of type
                default `INTEGER', with `INTENT(OUT)'. It
                specifies the minimum size of the arrays used
                with the PUT and GET arguments.
     PUT        (Optional) Shall be an array of type default
                `INTEGER' and rank one. It is `INTENT(IN)' and
                the size of the array must be larger than or
                equal to the number returned by the SIZE
                argument.
     GET        (Optional) Shall be an array of type default
                `INTEGER' and rank one. It is `INTENT(OUT)'
                and the size of the array must be larger than
                or equal to the number returned by the SIZE
                argument.

_Example_:
          SUBROUTINE init_random_seed()
            INTEGER :: i, n, clock
            INTEGER, DIMENSION(:), ALLOCATABLE :: seed

            CALL RANDOM_SEED(size = n)
            ALLOCATE(seed(n))

            CALL SYSTEM_CLOCK(COUNT=clock)

            seed = clock + 37 * (/ (i - 1, i = 1, n) /)
            CALL RANDOM_SEED(PUT = seed)

            DEALLOCATE(seed)
          END SUBROUTINE

_See also_:
     *note RANDOM_NUMBER::


File: gfortran.info,  Node: RANGE,  Next: RAN,  Prev: RAND,  Up: Intrinsic Procedures

7.178 `RANGE' -- Decimal exponent range
=======================================

_Description_:
     `RANGE(X)' returns the decimal exponent range in the model of the
     type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = RANGE(X)'

_Arguments_:
     X          Shall be of type `INTEGER', `REAL' or
                `COMPLEX'.

_Return value_:
     The return value is of type `INTEGER' and of the default integer
     kind.

_Example_:
     See `PRECISION' for an example.


File: gfortran.info,  Node: REAL,  Next: RENAME,  Prev: RAN,  Up: Intrinsic Procedures

7.179 `REAL' -- Convert to real type
====================================

_Description_:
     `REAL(X [, KIND])' converts its argument X to a real type.  The
     `REALPART(X)' function is provided for compatibility with `g77',
     and its use is strongly discouraged.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = REAL(X [, KIND])'
     `RESULT = REALPART(Z)'

_Arguments_:
     X          Shall be `INTEGER', `REAL', or `COMPLEX'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     These functions return a `REAL' variable or array under the
     following rules:

    (A)
          `REAL(X)' is converted to a default real type if X is an
          integer or real variable.

    (B)
          `REAL(X)' is converted to a real type with the kind type
          parameter of X if X is a complex variable.

    (C)
          `REAL(X, KIND)' is converted to a real type with kind type
          parameter KIND if X is a complex, integer, or real variable.

_Example_:
          program test_real
            complex :: x = (1.0, 2.0)
            print *, real(x), real(x,8), realpart(x)
          end program test_real

_See also_:
     *note DBLE::, *note DFLOAT::, *note FLOAT::



File: gfortran.info,  Node: RENAME,  Next: REPEAT,  Prev: REAL,  Up: Intrinsic Procedures

7.180 `RENAME' -- Rename a file
===============================

_Description_:
     Renames a file from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `rename(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL RENAME(PATH1, PATH2 [, STATUS])'
     `STATUS = RENAME(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *note LINK::



File: gfortran.info,  Node: REPEAT,  Next: RESHAPE,  Prev: RENAME,  Up: Intrinsic Procedures

7.181 `REPEAT' -- Repeated string concatenation
===============================================

_Description_:
     Concatenates NCOPIES copies of a string.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = REPEAT(STRING, NCOPIES)'

_Arguments_:
     STRING     Shall be scalar and of type `CHARACTER'.
     NCOPIES    Shall be scalar and of type `INTEGER'.

_Return value_:
     A new scalar of type `CHARACTER' built up from NCOPIES copies of
     STRING.

_Example_:
          program test_repeat
            write(*,*) repeat("x", 5)   ! "xxxxx"
          end program


File: gfortran.info,  Node: RESHAPE,  Next: RRSPACING,  Prev: REPEAT,  Up: Intrinsic Procedures

7.182 `RESHAPE' -- Function to reshape an array
===============================================

_Description_:
     Reshapes SOURCE to correspond to SHAPE. If necessary, the new
     array may be padded with elements from PAD or permuted as defined
     by ORDER.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = RESHAPE(SOURCE, SHAPE[, PAD, ORDER])'

_Arguments_:
     SOURCE     Shall be an array of any type.
     SHAPE      Shall be of type `INTEGER' and an array of
                rank one. Its values must be positive or zero.
     PAD        (Optional) shall be an array of the same type
                as SOURCE.
     ORDER      (Optional) shall be of type `INTEGER' and an
                array of the same shape as SHAPE. Its values
                shall be a permutation of the numbers from 1
                to n, where n is the size of SHAPE. If ORDER
                is absent, the natural ordering shall be
                assumed.

_Return value_:
     The result is an array of shape SHAPE with the same type as SOURCE.

_Example_:
          PROGRAM test_reshape
            INTEGER, DIMENSION(4) :: x
            WRITE(*,*) SHAPE(x)                       ! prints "4"
            WRITE(*,*) SHAPE(RESHAPE(x, (/2, 2/)))    ! prints "2 2"
          END PROGRAM

_See also_:
     *note SHAPE::


File: gfortran.info,  Node: RRSPACING,  Next: RSHIFT,  Prev: RESHAPE,  Up: Intrinsic Procedures

7.183 `RRSPACING' -- Reciprocal of the relative spacing
=======================================================

_Description_:
     `RRSPACING(X)' returns the  reciprocal of the relative spacing of
     model numbers near X.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = RRSPACING(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of the same type and kind as X.  The value
     returned is equal to `ABS(FRACTION(X)) *
     FLOAT(RADIX(X))**DIGITS(X)'.

_See also_:
     *note SPACING::


File: gfortran.info,  Node: RSHIFT,  Next: SCALE,  Prev: RRSPACING,  Up: Intrinsic Procedures

7.184 `RSHIFT' -- Right shift bits
==================================

_Description_:
     `RSHIFT' returns a value corresponding to I with all of the bits
     shifted right by SHIFT places.  If the absolute value of SHIFT is
     greater than `BIT_SIZE(I)', the value is undefined.  Bits shifted
     out from the left end are lost; zeros are shifted in from the
     opposite end.

     This function has been superseded by the `ISHFT' intrinsic, which
     is standard in Fortran 95 and later.

_Standard_:
     GNU extension

_Class_:
     Elemental function

_Syntax_:
     `RESULT = RSHIFT(I, SHIFT)'

_Arguments_:
     I          The type shall be `INTEGER'.
     SHIFT      The type shall be `INTEGER'.

_Return value_:
     The return value is of type `INTEGER' and of the same kind as I.

_See also_:
     *note ISHFT::, *note ISHFTC::, *note LSHIFT::



File: gfortran.info,  Node: SCALE,  Next: SCAN,  Prev: RSHIFT,  Up: Intrinsic Procedures

7.185 `SCALE' -- Scale a real value
===================================

_Description_:
     `SCALE(X,I)' returns `X * RADIX(X)**I'.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SCALE(X, I)'

_Arguments_:
     X          The type of the argument shall be a `REAL'.
     I          The type of the argument shall be a `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  Its value is
     `X * RADIX(X)**I'.

_Example_:
          program test_scale
            real :: x = 178.1387e-4
            integer :: i = 5
            print *, scale(x,i), x*radix(x)**i
          end program test_scale



File: gfortran.info,  Node: SCAN,  Next: SECNDS,  Prev: SCALE,  Up: Intrinsic Procedures

7.186 `SCAN' -- Scan a string for the presence of a set of characters
=====================================================================

_Description_:
     Scans a STRING for any of the characters in a SET of characters.

     If BACK is either absent or equals `FALSE', this function returns
     the position of the leftmost character of STRING that is in SET.
     If BACK equals `TRUE', the rightmost position is returned. If no
     character of SET is found in STRING, the result is zero.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SCAN(STRING, SET[, BACK [, KIND]])'

_Arguments_:
     STRING     Shall be of type `CHARACTER'.
     SET        Shall be of type `CHARACTER'.
     BACK       (Optional) shall be of type `LOGICAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_scan
            WRITE(*,*) SCAN("FORTRAN", "AO")          ! 2, found 'O'
            WRITE(*,*) SCAN("FORTRAN", "AO", .TRUE.)  ! 6, found 'A'
            WRITE(*,*) SCAN("FORTRAN", "C++")         ! 0, found none
          END PROGRAM

_See also_:
     *note INDEX intrinsic::, *note VERIFY::


File: gfortran.info,  Node: SECNDS,  Next: SECOND,  Prev: SCAN,  Up: Intrinsic Procedures

7.187 `SECNDS' -- Time function
===============================

_Description_:
     `SECNDS(X)' gets the time in seconds from the real-time system
     clock.  X is a reference time, also in seconds. If this is zero,
     the time in seconds from midnight is returned. This function is
     non-standard and its use is discouraged.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = SECNDS (X)'

_Arguments_:
     T          Shall be of type `REAL(4)'.
     X          Shall be of type `REAL(4)'.

_Return value_:
     None

_Example_:
          program test_secnds
              integer :: i
              real(4) :: t1, t2
              print *, secnds (0.0)   ! seconds since midnight
              t1 = secnds (0.0)       ! reference time
              do i = 1, 10000000      ! do something
              end do
              t2 = secnds (t1)        ! elapsed time
              print *, "Something took ", t2, " seconds."
          end program test_secnds


File: gfortran.info,  Node: SECOND,  Next: SELECTED_CHAR_KIND,  Prev: SECNDS,  Up: Intrinsic Procedures

7.188 `SECOND' -- CPU time function
===================================

_Description_:
     Returns a `REAL(4)' value representing the elapsed CPU time in
     seconds.  This provides the same functionality as the standard
     `CPU_TIME' intrinsic, and is only included for backwards
     compatibility.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL SECOND(TIME)'
     `TIME = SECOND()'

_Arguments_:
     TIME       Shall be of type `REAL(4)'.

_Return value_:
     In either syntax, TIME is set to the process's current runtime in
     seconds.

_See also_:
     *note CPU_TIME::



File: gfortran.info,  Node: SELECTED_CHAR_KIND,  Next: SELECTED_INT_KIND,  Prev: SECOND,  Up: Intrinsic Procedures

7.189 `SELECTED_CHAR_KIND' -- Choose character kind
===================================================

_Description_:
     `SELECTED_CHAR_KIND(NAME)' returns the kind value for the character
     set named NAME, if a character set with such a name is supported,
     or -1 otherwise. Currently, supported character sets include
     "ASCII" and "DEFAULT", which are equivalent.

_Standard_:
     Fortran 2003 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SELECTED_CHAR_KIND(NAME)'

_Arguments_:
     NAME       Shall be a scalar and of the default character
                type.

_Example_:
          program ascii_kind
            integer,parameter :: ascii = selected_char_kind("ascii")
            character(kind=ascii, len=26) :: s

            s = ascii_"abcdefghijklmnopqrstuvwxyz"
            print *, s
          end program ascii_kind


File: gfortran.info,  Node: SELECTED_INT_KIND,  Next: SELECTED_REAL_KIND,  Prev: SELECTED_CHAR_KIND,  Up: Intrinsic Procedures

7.190 `SELECTED_INT_KIND' -- Choose integer kind
================================================

_Description_:
     `SELECTED_INT_KIND(I)' return the kind value of the smallest
     integer type that can represent all values ranging from -10^I
     (exclusive) to 10^I (exclusive). If there is no integer kind that
     accommodates this range, `SELECTED_INT_KIND' returns -1.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SELECTED_INT_KIND(I)'

_Arguments_:
     I          Shall be a scalar and of type `INTEGER'.

_Example_:
          program large_integers
            integer,parameter :: k5 = selected_int_kind(5)
            integer,parameter :: k15 = selected_int_kind(15)
            integer(kind=k5) :: i5
            integer(kind=k15) :: i15

            print *, huge(i5), huge(i15)

            ! The following inequalities are always true
            print *, huge(i5) >= 10_k5**5-1
            print *, huge(i15) >= 10_k15**15-1
          end program large_integers


File: gfortran.info,  Node: SELECTED_REAL_KIND,  Next: SET_EXPONENT,  Prev: SELECTED_INT_KIND,  Up: Intrinsic Procedures

7.191 `SELECTED_REAL_KIND' -- Choose real kind
==============================================

_Description_:
     `SELECTED_REAL_KIND(P,R)' returns the kind value of a real data
     type with decimal precision of at least `P' digits and exponent
     range greater at least `R'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SELECTED_REAL_KIND(P, R)'

_Arguments_:
     P          (Optional) shall be a scalar and of type
                `INTEGER'.
     R          (Optional) shall be a scalar and of type
                `INTEGER'.
     At least one argument shall be present.

_Return value_:
     `SELECTED_REAL_KIND' returns the value of the kind type parameter
     of a real data type with decimal precision of at least `P' digits
     and a decimal exponent range of at least `R'. If more than one
     real data type meet the criteria, the kind of the data type with
     the smallest decimal precision is returned. If no real data type
     matches the criteria, the result is
    -1 if the processor does not support a real data type with a
          precision greater than or equal to `P'

    -2 if the processor does not support a real type with an exponent
          range greater than or equal to `R'

    -3 if neither is supported.

_Example_:
          program real_kinds
            integer,parameter :: p6 = selected_real_kind(6)
            integer,parameter :: p10r100 = selected_real_kind(10,100)
            integer,parameter :: r400 = selected_real_kind(r=400)
            real(kind=p6) :: x
            real(kind=p10r100) :: y
            real(kind=r400) :: z

            print *, precision(x), range(x)
            print *, precision(y), range(y)
            print *, precision(z), range(z)
          end program real_kinds


File: gfortran.info,  Node: SET_EXPONENT,  Next: SHAPE,  Prev: SELECTED_REAL_KIND,  Up: Intrinsic Procedures

7.192 `SET_EXPONENT' -- Set the exponent of the model
=====================================================

_Description_:
     `SET_EXPONENT(X, I)' returns the real number whose fractional part
     is that that of X and whose exponent part is I.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SET_EXPONENT(X, I)'

_Arguments_:
     X          Shall be of type `REAL'.
     I          Shall be of type `INTEGER'.

_Return value_:
     The return value is of the same type and kind as X.  The real
     number whose fractional part is that that of X and whose exponent
     part if I is returned; it is `FRACTION(X) * RADIX(X)**I'.

_Example_:
          PROGRAM test_setexp
            REAL :: x = 178.1387e-4
            INTEGER :: i = 17
            PRINT *, SET_EXPONENT(x, i), FRACTION(x) * RADIX(x)**i
          END PROGRAM



File: gfortran.info,  Node: SHAPE,  Next: SIGN,  Prev: SET_EXPONENT,  Up: Intrinsic Procedures

7.193 `SHAPE' -- Determine the shape of an array
================================================

_Description_:
     Determines the shape of an array.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = SHAPE(SOURCE)'

_Arguments_:
     SOURCE     Shall be an array or scalar of any type.  If
                SOURCE is a pointer it must be associated and
                allocatable arrays must be allocated.

_Return value_:
     An `INTEGER' array of rank one with as many elements as SOURCE has
     dimensions. The elements of the resulting array correspond to the
     extend of SOURCE along the respective dimensions. If SOURCE is a
     scalar, the result is the rank one array of size zero.

_Example_:
          PROGRAM test_shape
            INTEGER, DIMENSION(-1:1, -1:2) :: A
            WRITE(*,*) SHAPE(A)             ! (/ 3, 4 /)
            WRITE(*,*) SIZE(SHAPE(42))      ! (/ /)
          END PROGRAM

_See also_:
     *note RESHAPE::, *note SIZE::


File: gfortran.info,  Node: SIGN,  Next: SIGNAL,  Prev: SHAPE,  Up: Intrinsic Procedures

7.194 `SIGN' -- Sign copying function
=====================================

_Description_:
     `SIGN(A,B)' returns the value of A with the sign of B.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SIGN(A, B)'

_Arguments_:
     A          Shall be of type `INTEGER' or `REAL'
     B          Shall be of the same type and kind as A

_Return value_:
     The kind of the return value is that of A and B.  If B\ge 0 then
     the result is `ABS(A)', else it is `-ABS(A)'.

_Example_:
          program test_sign
            print *, sign(-12,1)
            print *, sign(-12,0)
            print *, sign(-12,-1)

            print *, sign(-12.,1.)
            print *, sign(-12.,0.)
            print *, sign(-12.,-1.)
          end program test_sign

_Specific names_:
     Name          Arguments     Return type   Standard
     `ISIGN(A,P)'  `INTEGER(4)'  `INTEGER(4)'  f95, gnu
     `DSIGN(A,P)'  `REAL(8)'     `REAL(8)'     f95, gnu


File: gfortran.info,  Node: SIGNAL,  Next: SIN,  Prev: SIGN,  Up: Intrinsic Procedures

7.195 `SIGNAL' -- Signal handling subroutine (or function)
==========================================================

_Description_:
     `SIGNAL(NUMBER, HANDLER [, STATUS])' causes external subroutine
     HANDLER to be executed with a single integer argument when signal
     NUMBER occurs.  If HANDLER is an integer, it can be used to turn
     off handling of signal NUMBER or revert to its default action.
     See `signal(2)'.

     If `SIGNAL' is called as a subroutine and the STATUS argument is
     supplied, it is set to the value returned by `signal(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL SIGNAL(NUMBER, HANDLER [, STATUS])'
     `STATUS = SIGNAL(NUMBER, HANDLER)'

_Arguments_:
     NUMBER     Shall be a scalar integer, with `INTENT(IN)'
     HANDLER    Signal handler (`INTEGER FUNCTION' or
                `SUBROUTINE') or dummy/global `INTEGER' scalar.
                `INTEGER'. It is `INTENT(IN)'.
     STATUS     (Optional) STATUS shall be a scalar integer.
                It has `INTENT(OUT)'.

_Return value_:
     The `SIGNAL' function returns the value returned by `signal(2)'.

_Example_:
          program test_signal
            intrinsic signal
            external handler_print

            call signal (12, handler_print)
            call signal (10, 1)

            call sleep (30)
          end program test_signal


File: gfortran.info,  Node: SIN,  Next: SINH,  Prev: SIGNAL,  Up: Intrinsic Procedures

7.196 `SIN' -- Sine function
============================

_Description_:
     `SIN(X)' computes the sine of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SIN(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value has same type and kind as X.

_Example_:
          program test_sin
            real :: x = 0.0
            x = sin(x)
          end program test_sin

_Specific names_:
     Name          Argument      Return type   Standard
     `DSIN(X)'     `REAL(8) X'   `REAL(8)'     f95, gnu
     `CSIN(X)'     `COMPLEX(4)   `COMPLEX(4)'  f95, gnu
                   X'                          
     `ZSIN(X)'     `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          
     `CDSIN(X)'    `COMPLEX(8)   `COMPLEX(8)'  f95, gnu
                   X'                          

_See also_:
     *note ASIN::


File: gfortran.info,  Node: SINH,  Next: SIZE,  Prev: SIN,  Up: Intrinsic Procedures

7.197 `SINH' -- Hyperbolic sine function
========================================

_Description_:
     `SINH(X)' computes the hyperbolic sine of X.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SINH(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL'.

_Example_:
          program test_sinh
            real(8) :: x = - 1.0_8
            x = sinh(x)
          end program test_sinh

_Specific names_:
     Name          Argument      Return type   Standard
     `DSINH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
                                               later

_See also_:
     *note ASINH::


File: gfortran.info,  Node: SIZE,  Next: SIZEOF,  Prev: SINH,  Up: Intrinsic Procedures

7.198 `SIZE' -- Determine the size of an array
==============================================

_Description_:
     Determine the extent of ARRAY along a specified dimension DIM, or
     the total number of elements in ARRAY if DIM is absent.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = SIZE(ARRAY[, DIM [, KIND]])'

_Arguments_:
     ARRAY      Shall be an array of any type. If ARRAY is a
                pointer it must be associated and allocatable
                arrays must be allocated.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                and its value shall be in the range from 1 to
                n, where n equals the rank of ARRAY.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_size
            WRITE(*,*) SIZE((/ 1, 2 /))    ! 2
          END PROGRAM

_See also_:
     *note SHAPE::, *note RESHAPE::


File: gfortran.info,  Node: SIZEOF,  Next: SLEEP,  Prev: SIZE,  Up: Intrinsic Procedures

7.199 `SIZEOF' -- Size in bytes of an expression
================================================

_Description_:
     `SIZEOF(X)' calculates the number of bytes of storage the
     expression `X' occupies.

_Standard_:
     GNU extension

_Class_:
     Intrinsic function

_Syntax_:
     `N = SIZEOF(X)'

_Arguments_:
     X          The argument shall be of any type, rank or
                shape.

_Return value_:
     The return value is of type integer and of the system-dependent
     kind C_SIZE_T (from the ISO_C_BINDING module). Its value is the
     number of bytes occupied by the argument.  If the argument has the
     `POINTER' attribute, the number of bytes of the storage area
     pointed to is returned.  If the argument is of a derived type with
     `POINTER' or `ALLOCATABLE' components, the return value doesn't
     account for the sizes of the data pointed to by these components.

_Example_:
             integer :: i
             real :: r, s(5)
             print *, (sizeof(s)/sizeof(r) == 5)
             end
     The example will print `.TRUE.' unless you are using a platform
     where default `REAL' variables are unusually padded.

_See also_:
     *note C_SIZEOF::


File: gfortran.info,  Node: SLEEP,  Next: SNGL,  Prev: SIZEOF,  Up: Intrinsic Procedures

7.200 `SLEEP' -- Sleep for the specified number of seconds
==========================================================

_Description_:
     Calling this subroutine causes the process to pause for SECONDS
     seconds.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL SLEEP(SECONDS)'

_Arguments_:
     SECONDS    The type shall be of default `INTEGER'.

_Example_:
          program test_sleep
            call sleep(5)
          end


File: gfortran.info,  Node: SNGL,  Next: SPACING,  Prev: SLEEP,  Up: Intrinsic Procedures

7.201 `SNGL' -- Convert double precision real to default real
=============================================================

_Description_:
     `SNGL(A)' converts the double precision real A to a default real
     value. This is an archaic form of `REAL' that is specific to one
     type for A.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SNGL(A)'

_Arguments_:
     A          The type shall be a double precision `REAL'.

_Return value_:
     The return value is of type default `REAL'.

_See also_:
     *note DBLE::


File: gfortran.info,  Node: SPACING,  Next: SPREAD,  Prev: SNGL,  Up: Intrinsic Procedures

7.202 `SPACING' -- Smallest distance between two numbers of a given type
========================================================================

_Description_:
     Determines the distance between the argument X and the nearest
     adjacent number of the same type.

_Standard_:
     Fortran 95 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SPACING(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The result is of the same type as the input argument X.

_Example_:
          PROGRAM test_spacing
            INTEGER, PARAMETER :: SGL = SELECTED_REAL_KIND(p=6, r=37)
            INTEGER, PARAMETER :: DBL = SELECTED_REAL_KIND(p=13, r=200)

            WRITE(*,*) spacing(1.0_SGL)      ! "1.1920929E-07"          on i686
            WRITE(*,*) spacing(1.0_DBL)      ! "2.220446049250313E-016" on i686
          END PROGRAM

_See also_:
     *note RRSPACING::


File: gfortran.info,  Node: SPREAD,  Next: SQRT,  Prev: SPACING,  Up: Intrinsic Procedures

7.203 `SPREAD' -- Add a dimension to an array
=============================================

_Description_:
     Replicates a SOURCE array NCOPIES times along a specified
     dimension DIM.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SPREAD(SOURCE, DIM, NCOPIES)'

_Arguments_:
     SOURCE     Shall be a scalar or an array of any type and
                a rank less than seven.
     DIM        Shall be a scalar of type `INTEGER' with a
                value in the range from 1 to n+1, where n
                equals the rank of SOURCE.
     NCOPIES    Shall be a scalar of type `INTEGER'.

_Return value_:
     The result is an array of the same type as SOURCE and has rank n+1
     where n equals the rank of SOURCE.

_Example_:
          PROGRAM test_spread
            INTEGER :: a = 1, b(2) = (/ 1, 2 /)
            WRITE(*,*) SPREAD(A, 1, 2)            ! "1 1"
            WRITE(*,*) SPREAD(B, 1, 2)            ! "1 1 2 2"
          END PROGRAM

_See also_:
     *note UNPACK::


File: gfortran.info,  Node: SQRT,  Next: SRAND,  Prev: SPREAD,  Up: Intrinsic Procedures

7.204 `SQRT' -- Square-root function
====================================

_Description_:
     `SQRT(X)' computes the square root of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = SQRT(X)'

_Arguments_:
     X          The type shall be `REAL' or `COMPLEX'.

_Return value_:
     The return value is of type `REAL' or `COMPLEX'.  The kind type
     parameter is the same as X.

_Example_:
          program test_sqrt
            real(8) :: x = 2.0_8
            complex :: z = (1.0, 2.0)
            x = sqrt(x)
            z = sqrt(z)
          end program test_sqrt

_Specific names_:
     Name          Argument      Return type   Standard
     `DSQRT(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
                                               later
     `CSQRT(X)'    `COMPLEX(4)   `COMPLEX(4)'  Fortran 95 and
                   X'                          later
     `ZSQRT(X)'    `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          
     `CDSQRT(X)'   `COMPLEX(8)   `COMPLEX(8)'  GNU extension
                   X'                          


File: gfortran.info,  Node: SRAND,  Next: STAT,  Prev: SQRT,  Up: Intrinsic Procedures

7.205 `SRAND' -- Reinitialize the random number generator
=========================================================

_Description_:
     `SRAND' reinitializes the pseudo-random number generator called by
     `RAND' and `IRAND'. The new seed used by the generator is
     specified by the required argument SEED.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL SRAND(SEED)'

_Arguments_:
     SEED       Shall be a scalar `INTEGER(kind=4)'.

_Return value_:
     Does not return anything.

_Example_:
     See `RAND' and `IRAND' for examples.

_Notes_:
     The Fortran 2003 standard specifies the intrinsic `RANDOM_SEED' to
     initialize the pseudo-random numbers generator and `RANDOM_NUMBER'
     to generate pseudo-random numbers. Please note that in GNU
     Fortran, these two sets of intrinsics (`RAND', `IRAND' and `SRAND'
     on the one hand, `RANDOM_NUMBER' and `RANDOM_SEED' on the other
     hand) access two independent pseudo-random number generators.

_See also_:
     *note RAND::, *note RANDOM_SEED::, *note RANDOM_NUMBER::



File: gfortran.info,  Node: STAT,  Next: SUM,  Prev: SRAND,  Up: Intrinsic Procedures

7.206 `STAT' -- Get file status
===============================

_Description_:
     This function returns information about a file. No permissions are
     required on the file itself, but execute (search) permission is
     required on all of the directories in path that lead to the file.

     The elements that are obtained and stored in the array `BUFF':
     `buff(1)'  Device ID
     `buff(2)'  Inode number
     `buff(3)'  File mode
     `buff(4)'  Number of links
     `buff(5)'  Owner's uid
     `buff(6)'  Owner's gid
     `buff(7)'  ID of device containing directory entry for
                file (0 if not available)
     `buff(8)'  File size (bytes)
     `buff(9)'  Last access time
     `buff(10)' Last modification time
     `buff(11)' Last file status change time
     `buff(12)' Preferred I/O block size (-1 if not available)
     `buff(13)' Number of blocks allocated (-1 if not
                available)

     Not all these elements are relevant on all systems.  If an element
     is not relevant, it is returned as 0.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL STAT(FILE,BUFF[,STATUS])'

_Arguments_:
     FILE       The type shall be `CHARACTER', of the default
                kind and a valid path within the file system.
     BUFF       The type shall be `INTEGER(4), DIMENSION(13)'.
     STATUS     (Optional) status flag of type `INTEGER(4)'.
                Returns 0 on success and a system specific
                error code otherwise.

_Example_:
          PROGRAM test_stat
            INTEGER, DIMENSION(13) :: buff
            INTEGER :: status

            CALL STAT("/etc/passwd", buff, status)

            IF (status == 0) THEN
              WRITE (*, FMT="('Device ID:',               T30, I19)") buff(1)
              WRITE (*, FMT="('Inode number:',            T30, I19)") buff(2)
              WRITE (*, FMT="('File mode (octal):',       T30, O19)") buff(3)
              WRITE (*, FMT="('Number of links:',         T30, I19)") buff(4)
              WRITE (*, FMT="('Owner''s uid:',            T30, I19)") buff(5)
              WRITE (*, FMT="('Owner''s gid:',            T30, I19)") buff(6)
              WRITE (*, FMT="('Device where located:',    T30, I19)") buff(7)
              WRITE (*, FMT="('File size:',               T30, I19)") buff(8)
              WRITE (*, FMT="('Last access time:',        T30, A19)") CTIME(buff(9))
              WRITE (*, FMT="('Last modification time',   T30, A19)") CTIME(buff(10))
              WRITE (*, FMT="('Last status change time:', T30, A19)") CTIME(buff(11))
              WRITE (*, FMT="('Preferred block size:',    T30, I19)") buff(12)
              WRITE (*, FMT="('No. of blocks allocated:', T30, I19)") buff(13)
            END IF
          END PROGRAM

_See also_:
     To stat an open file: *note FSTAT::, to stat a link: *note LSTAT::


File: gfortran.info,  Node: SUM,  Next: SYMLNK,  Prev: STAT,  Up: Intrinsic Procedures

7.207 `SUM' -- Sum of array elements
====================================

_Description_:
     Adds the elements of ARRAY along dimension DIM if the
     corresponding element in MASK is `TRUE'.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = SUM(ARRAY[, MASK])' `RESULT = SUM(ARRAY, DIM[, MASK])'

_Arguments_:
     ARRAY      Shall be an array of type `INTEGER', `REAL' or
                `COMPLEX'.
     DIM        (Optional) shall be a scalar of type `INTEGER'
                with a value in the range from 1 to n, where n
                equals the rank of ARRAY.
     MASK       (Optional) shall be of type `LOGICAL' and
                either be a scalar or an array of the same
                shape as ARRAY.

_Return value_:
     The result is of the same type as ARRAY.

     If DIM is absent, a scalar with the sum of all elements in ARRAY
     is returned. Otherwise, an array of rank n-1, where n equals the
     rank of ARRAY,and a shape similar to that of ARRAY with dimension
     DIM dropped is returned.

_Example_:
          PROGRAM test_sum
            INTEGER :: x(5) = (/ 1, 2, 3, 4 ,5 /)
            print *, SUM(x)                        ! all elements, sum = 15
            print *, SUM(x, MASK=MOD(x, 2)==1)     ! odd elements, sum = 9
          END PROGRAM

_See also_:
     *note PRODUCT::


File: gfortran.info,  Node: SYMLNK,  Next: SYSTEM,  Prev: SUM,  Up: Intrinsic Procedures

7.208 `SYMLNK' -- Create a symbolic link
========================================

_Description_:
     Makes a symbolic link from file PATH1 to PATH2. A null character
     (`CHAR(0)') can be used to mark the end of the names in PATH1 and
     PATH2; otherwise, trailing blanks in the file names are ignored.
     If the STATUS argument is supplied, it contains 0 on success or a
     nonzero error code upon return; see `symlink(2)'.  If the system
     does not supply `symlink(2)', `ENOSYS' is returned.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL SYMLNK(PATH1, PATH2 [, STATUS])'
     `STATUS = SYMLNK(PATH1, PATH2)'

_Arguments_:
     PATH1      Shall be of default `CHARACTER' type.
     PATH2      Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *note LINK::, *note UNLINK::



File: gfortran.info,  Node: SYSTEM,  Next: SYSTEM_CLOCK,  Prev: SYMLNK,  Up: Intrinsic Procedures

7.209 `SYSTEM' -- Execute a shell command
=========================================

_Description_:
     Passes the command COMMAND to a shell (see `system(3)'). If
     argument STATUS is present, it contains the value returned by
     `system(3)', which is presumably 0 if the shell command succeeded.
     Note that which shell is used to invoke the command is
     system-dependent and environment-dependent.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL SYSTEM(COMMAND [, STATUS])'
     `STATUS = SYSTEM(COMMAND)'

_Arguments_:
     COMMAND    Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:


File: gfortran.info,  Node: SYSTEM_CLOCK,  Next: TAN,  Prev: SYSTEM,  Up: Intrinsic Procedures

7.210 `SYSTEM_CLOCK' -- Time function
=====================================

_Description_:
     Determines the COUNT of milliseconds of wall clock time since the
     Epoch (00:00:00 UTC, January 1, 1970) modulo COUNT_MAX, COUNT_RATE
     determines the number of clock ticks per second.  COUNT_RATE and
     COUNT_MAX are constant and specific to `gfortran'.

     If there is no clock, COUNT is set to `-HUGE(COUNT)', and
     COUNT_RATE and COUNT_MAX are set to zero

_Standard_:
     Fortran 95 and later

_Class_:
     Subroutine

_Syntax_:
     `CALL SYSTEM_CLOCK([COUNT, COUNT_RATE, COUNT_MAX])'

_Arguments_:

_Arguments_:
     COUNT      (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.
     COUNT_RATE (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.
     COUNT_MAX  (Optional) shall be a scalar of type default
                `INTEGER' with `INTENT(OUT)'.

_Example_:
          PROGRAM test_system_clock
            INTEGER :: count, count_rate, count_max
            CALL SYSTEM_CLOCK(count, count_rate, count_max)
            WRITE(*,*) count, count_rate, count_max
          END PROGRAM

_See also_:
     *note DATE_AND_TIME::, *note CPU_TIME::


File: gfortran.info,  Node: TAN,  Next: TANH,  Prev: SYSTEM_CLOCK,  Up: Intrinsic Procedures

7.211 `TAN' -- Tangent function
===============================

_Description_:
     `TAN(X)' computes the tangent of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = TAN(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL'.  The kind type parameter is
     the same as X.

_Example_:
          program test_tan
            real(8) :: x = 0.165_8
            x = tan(x)
          end program test_tan

_Specific names_:
     Name          Argument      Return type   Standard
     `DTAN(X)'     `REAL(8) X'   `REAL(8)'     Fortran 95 and
                                               later

_See also_:
     *note ATAN::


File: gfortran.info,  Node: TANH,  Next: TIME,  Prev: TAN,  Up: Intrinsic Procedures

7.212 `TANH' -- Hyperbolic tangent function
===========================================

_Description_:
     `TANH(X)' computes the hyperbolic tangent of X.

_Standard_:
     Fortran 77 and later

_Class_:
     Elemental function

_Syntax_:
     `X = TANH(X)'

_Arguments_:
     X          The type shall be `REAL'.

_Return value_:
     The return value is of type `REAL' and lies in the range  - 1 \leq
     tanh(x) \leq 1 .

_Example_:
          program test_tanh
            real(8) :: x = 2.1_8
            x = tanh(x)
          end program test_tanh

_Specific names_:
     Name          Argument      Return type   Standard
     `DTANH(X)'    `REAL(8) X'   `REAL(8)'     Fortran 95 and
                                               later

_See also_:
     *note ATANH::


File: gfortran.info,  Node: TIME,  Next: TIME8,  Prev: TANH,  Up: Intrinsic Procedures

7.213 `TIME' -- Time function
=============================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the UNIX function `time(3)'). This value is suitable for passing to
     `CTIME()', `GMTIME()', and `LTIME()'.

     This intrinsic is not fully portable, such as to systems with
     32-bit `INTEGER' types but supporting times wider than 32 bits.
     Therefore, the values returned by this intrinsic might be, or
     become, negative, or numerically less than previous values, during
     a single run of the compiled program.

     See *note TIME8::, for information on a similar intrinsic that
     might be portable to more GNU Fortran implementations, though to
     fewer Fortran compilers.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = TIME()'

_Return value_:
     The return value is a scalar of type `INTEGER(4)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK::,
     *note TIME8::



File: gfortran.info,  Node: TIME8,  Next: TINY,  Prev: TIME,  Up: Intrinsic Procedures

7.214 `TIME8' -- Time function (64-bit)
=======================================

_Description_:
     Returns the current time encoded as an integer (in the manner of
     the UNIX function `time(3)'). This value is suitable for passing to
     `CTIME()', `GMTIME()', and `LTIME()'.

     _Warning:_ this intrinsic does not increase the range of the timing
     values over that returned by `time(3)'. On a system with a 32-bit
     `time(3)', `TIME8()' will return a 32-bit value, even though it is
     converted to a 64-bit `INTEGER(8)' value. That means overflows of
     the 32-bit value can still occur. Therefore, the values returned
     by this intrinsic might be or become negative or numerically less
     than previous values during a single run of the compiled program.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = TIME8()'

_Return value_:
     The return value is a scalar of type `INTEGER(8)'.

_See also_:
     *note CTIME::, *note GMTIME::, *note LTIME::, *note MCLOCK8::,
     *note TIME::



File: gfortran.info,  Node: TINY,  Next: TRAILZ,  Prev: TIME8,  Up: Intrinsic Procedures

7.215 `TINY' -- Smallest positive number of a real kind
=======================================================

_Description_:
     `TINY(X)' returns the smallest positive (non zero) number in the
     model of the type of `X'.

_Standard_:
     Fortran 95 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = TINY(X)'

_Arguments_:
     X          Shall be of type `REAL'.

_Return value_:
     The return value is of the same type and kind as X

_Example_:
     See `HUGE' for an example.


File: gfortran.info,  Node: TRAILZ,  Next: TRANSFER,  Prev: TINY,  Up: Intrinsic Procedures

7.216 `TRAILZ' -- Number of trailing zero bits of an integer
============================================================

_Description_:
     `TRAILZ' returns the number of trailing zero bits of an integer.

_Standard_:
     Fortran 2008 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = TRAILZ(I)'

_Arguments_:
     I          Shall be of type `INTEGER'.

_Return value_:
     The type of the return value is the default `INTEGER'.  If all the
     bits of `I' are zero, the result value is `BIT_SIZE(I)'.

_Example_:
          PROGRAM test_trailz
            WRITE (*,*) TRAILZ(8)  ! prints 3
          END PROGRAM

_See also_:
     *note BIT_SIZE::, *note LEADZ::


File: gfortran.info,  Node: TRANSFER,  Next: TRANSPOSE,  Prev: TRAILZ,  Up: Intrinsic Procedures

7.217 `TRANSFER' -- Transfer bit patterns
=========================================

_Description_:
     Interprets the bitwise representation of SOURCE in memory as if it
     is the representation of a variable or array of the same type and
     type parameters as MOLD.

     This is approximately equivalent to the C concept of _casting_ one
     type to another.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRANSFER(SOURCE, MOLD[, SIZE])'

_Arguments_:
     SOURCE     Shall be a scalar or an array of any type.
     MOLD       Shall be a scalar or an array of any type.
     SIZE       (Optional) shall be a scalar of type `INTEGER'.

_Return value_:
     The result has the same type as MOLD, with the bit level
     representation of SOURCE.  If SIZE is present, the result is a
     one-dimensional array of length SIZE.  If SIZE is absent but MOLD
     is an array (of any size or shape), the result is a one-
     dimensional array of the minimum length needed to contain the
     entirety of the bitwise representation of SOURCE.   If SIZE is
     absent and MOLD is a scalar, the result is a scalar.

     If the bitwise representation of the result is longer than that of
     SOURCE, then the leading bits of the result correspond to those of
     SOURCE and any trailing bits are filled arbitrarily.

     When the resulting bit representation does not correspond to a
     valid representation of a variable of the same type as MOLD, the
     results are undefined, and subsequent operations on the result
     cannot be guaranteed to produce sensible behavior.  For example,
     it is possible to create `LOGICAL' variables for which `VAR' and
     `.NOT.VAR' both appear to be true.

_Example_:
          PROGRAM test_transfer
            integer :: x = 2143289344
            print *, transfer(x, 1.0)    ! prints "NaN" on i686
          END PROGRAM


File: gfortran.info,  Node: TRANSPOSE,  Next: TRIM,  Prev: TRANSFER,  Up: Intrinsic Procedures

7.218 `TRANSPOSE' -- Transpose an array of rank two
===================================================

_Description_:
     Transpose an array of rank two. Element (i, j) of the result has
     the value `MATRIX(j, i)', for all i, j.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRANSPOSE(MATRIX)'

_Arguments_:
     MATRIX     Shall be an array of any type and have a rank
                of two.

_Return value_:
     The result has the same type as MATRIX, and has shape `(/ m, n /)'
     if MATRIX has shape `(/ n, m /)'.


File: gfortran.info,  Node: TRIM,  Next: TTYNAM,  Prev: TRANSPOSE,  Up: Intrinsic Procedures

7.219 `TRIM' -- Remove trailing blank characters of a string
============================================================

_Description_:
     Removes trailing blank characters of a string.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = TRIM(STRING)'

_Arguments_:
     STRING     Shall be a scalar of type `CHARACTER'.

_Return value_:
     A scalar of type `CHARACTER' which length is that of STRING less
     the number of trailing blanks.

_Example_:
          PROGRAM test_trim
            CHARACTER(len=10), PARAMETER :: s = "GFORTRAN  "
            WRITE(*,*) LEN(s), LEN(TRIM(s))  ! "10 8", with/without trailing blanks
          END PROGRAM

_See also_:
     *note ADJUSTL::, *note ADJUSTR::


File: gfortran.info,  Node: TTYNAM,  Next: UBOUND,  Prev: TRIM,  Up: Intrinsic Procedures

7.220 `TTYNAM' -- Get the name of a terminal device.
====================================================

_Description_:
     Get the name of a terminal device. For more information, see
     `ttyname(3)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL TTYNAM(UNIT, NAME)'
     `NAME = TTYNAM(UNIT)'

_Arguments_:
     UNIT       Shall be a scalar `INTEGER'.
     NAME       Shall be of type `CHARACTER'.

_Example_:
          PROGRAM test_ttynam
            INTEGER :: unit
            DO unit = 1, 10
              IF (isatty(unit=unit)) write(*,*) ttynam(unit)
            END DO
          END PROGRAM

_See also_:
     *note ISATTY::


File: gfortran.info,  Node: UBOUND,  Next: UMASK,  Prev: TTYNAM,  Up: Intrinsic Procedures

7.221 `UBOUND' -- Upper dimension bounds of an array
====================================================

_Description_:
     Returns the upper bounds of an array, or a single upper bound
     along the DIM dimension.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Inquiry function

_Syntax_:
     `RESULT = UBOUND(ARRAY [, DIM [, KIND]])'

_Arguments_:
     ARRAY      Shall be an array, of any type.
     DIM        (Optional) Shall be a scalar `INTEGER'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.  If DIM is
     absent, the result is an array of the upper bounds of ARRAY.  If
     DIM is present, the result is a scalar corresponding to the upper
     bound of the array along that dimension.  If ARRAY is an
     expression rather than a whole array or array structure component,
     or if it has a zero extent along the relevant dimension, the upper
     bound is taken to be the number of elements along the relevant
     dimension.

_See also_:
     *note LBOUND::


File: gfortran.info,  Node: UMASK,  Next: UNLINK,  Prev: UBOUND,  Up: Intrinsic Procedures

7.222 `UMASK' -- Set the file creation mask
===========================================

_Description_:
     Sets the file creation mask to MASK and returns the old value in
     argument OLD if it is supplied. See `umask(2)'.

_Standard_:
     GNU extension

_Class_:
     Subroutine

_Syntax_:
     `CALL UMASK(MASK [, OLD])'

_Arguments_:
     MASK       Shall be a scalar of type `INTEGER'.
     MASK       (Optional) Shall be a scalar of type `INTEGER'.



File: gfortran.info,  Node: UNLINK,  Next: UNPACK,  Prev: UMASK,  Up: Intrinsic Procedures

7.223 `UNLINK' -- Remove a file from the file system
====================================================

_Description_:
     Unlinks the file PATH. A null character (`CHAR(0)') can be used to
     mark the end of the name in PATH; otherwise, trailing blanks in
     the file name are ignored.  If the STATUS argument is supplied, it
     contains 0 on success or a nonzero error code upon return; see
     `unlink(2)'.

     This intrinsic is provided in both subroutine and function forms;
     however, only one form can be used in any given program unit.

_Standard_:
     GNU extension

_Class_:
     Subroutine, function

_Syntax_:
     `CALL UNLINK(PATH [, STATUS])'
     `STATUS = UNLINK(PATH)'

_Arguments_:
     PATH       Shall be of default `CHARACTER' type.
     STATUS     (Optional) Shall be of default `INTEGER' type.

_See also_:
     *note LINK::, *note SYMLNK::


File: gfortran.info,  Node: UNPACK,  Next: VERIFY,  Prev: UNLINK,  Up: Intrinsic Procedures

7.224 `UNPACK' -- Unpack an array of rank one into an array
===========================================================

_Description_:
     Store the elements of VECTOR in an array of higher rank.

_Standard_:
     Fortran 95 and later

_Class_:
     Transformational function

_Syntax_:
     `RESULT = UNPACK(VECTOR, MASK, FIELD)'

_Arguments_:
     VECTOR     Shall be an array of any type and rank one. It
                shall have at least as many elements as MASK
                has `TRUE' values.
     MASK       Shall be an array of type `LOGICAL'.
     FIELD      Shall be of the same type as VECTOR and have
                the same shape as MASK.

_Return value_:
     The resulting array corresponds to FIELD with `TRUE' elements of
     MASK replaced by values from VECTOR in array element order.

_Example_:
          PROGRAM test_unpack
            integer :: vector(2)  = (/1,1/)
            logical :: mask(4)  = (/ .TRUE., .FALSE., .FALSE., .TRUE. /)
            integer :: field(2,2) = 0, unity(2,2)

            ! result: unity matrix
            unity = unpack(vector, reshape(mask, (/2,2/)), field)
          END PROGRAM

_See also_:
     *note PACK::, *note SPREAD::


File: gfortran.info,  Node: VERIFY,  Next: XOR,  Prev: UNPACK,  Up: Intrinsic Procedures

7.225 `VERIFY' -- Scan a string for the absence of a set of characters
======================================================================

_Description_:
     Verifies that all the characters in a SET are present in a STRING.

     If BACK is either absent or equals `FALSE', this function returns
     the position of the leftmost character of STRING that is not in
     SET. If BACK equals `TRUE', the rightmost position is returned. If
     all characters of SET are found in STRING, the result is zero.

_Standard_:
     Fortran 95 and later, with KIND argument Fortran 2003 and later

_Class_:
     Elemental function

_Syntax_:
     `RESULT = VERIFY(STRING, SET[, BACK [, KIND]])'

_Arguments_:
     STRING     Shall be of type `CHARACTER'.
     SET        Shall be of type `CHARACTER'.
     BACK       (Optional) shall be of type `LOGICAL'.
     KIND       (Optional) An `INTEGER' initialization
                expression indicating the kind parameter of
                the result.

_Return value_:
     The return value is of type `INTEGER' and of kind KIND. If KIND is
     absent, the return value is of default integer kind.

_Example_:
          PROGRAM test_verify
            WRITE(*,*) VERIFY("FORTRAN", "AO")           ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "FOO")          ! 3, found 'R'
            WRITE(*,*) VERIFY("FORTRAN", "C++")          ! 1, found 'F'
            WRITE(*,*) VERIFY("FORTRAN", "C++", .TRUE.)  ! 7, found 'N'
            WRITE(*,*) VERIFY("FORTRAN", "FORTRAN")      ! 0' found none
          END PROGRAM

_See also_:
     *note SCAN::, *note INDEX intrinsic::


File: gfortran.info,  Node: XOR,  Prev: VERIFY,  Up: Intrinsic Procedures

7.226 `XOR' -- Bitwise logical exclusive OR
===========================================

_Description_:
     Bitwise logical exclusive or.

     This intrinsic routine is provided for backwards compatibility with
     GNU Fortran 77.  For integer arguments, programmers should consider
     the use of the *note IEOR:: intrinsic defined by the Fortran
     standard.

_Standard_:
     GNU extension

_Class_:
     Function

_Syntax_:
     `RESULT = XOR(X, Y)'

_Arguments_:
     X          The type shall be either  a scalar `INTEGER'
                type or a scalar `LOGICAL' type.
     Y          The type shall be the same as the type of I.

_Return value_:
     The return type is either a scalar `INTEGER' or a scalar
     `LOGICAL'.  If the kind type parameters differ, then the smaller
     kind type is implicitly converted to larger kind, and the return
     has the larger kind.

_Example_:
          PROGRAM test_xor
            LOGICAL :: T = .TRUE., F = .FALSE.
            INTEGER :: a, b
            DATA a / Z'F' /, b / Z'3' /

            WRITE (*,*) XOR(T, T), XOR(T, F), XOR(F, T), XOR(F, F)
            WRITE (*,*) XOR(a, b)
          END PROGRAM

_See also_:
     Fortran 95 elemental function: *note IEOR::


File: gfortran.info,  Node: Intrinsic Modules,  Next: Contributing,  Prev: Intrinsic Procedures,  Up: Top

8 Intrinsic Modules
*******************

8.1 `ISO_FORTRAN_ENV'
=====================

_Standard_:
     Fortran 2003 and later

   The `ISO_FORTRAN_ENV' module provides the following scalar
default-integer named constants:

`CHARACTER_STORAGE_SIZE':
     Size in bits of the character storage unit.

`ERROR_UNIT':
     Identifies the preconnected unit used for error reporting.

`FILE_STORAGE_SIZE':
     Size in bits of the file-storage unit.

`INPUT_UNIT':
     Identifies the preconnected unit identified by the asterisk (`*')
     in `READ' statement.

`IOSTAT_END':
     The value assigned to the variable passed to the IOSTAT= specifier
     of an input/output statement if an end-of-file condition occurred.

`IOSTAT_EOR':
     The value assigned to the variable passed to the IOSTAT= specifier
     of an input/output statement if an end-of-record condition
     occurred.

`NUMERIC_STORAGE_SIZE':
     The size in bits of the numeric storage unit.

`OUTPUT_UNIT':
     Identifies the preconnected unit identified by the asterisk (`*')
     in `WRITE' statement.

8.2 `ISO_C_BINDING'
===================

_Standard_:
     Fortran 2003 and later, GNU extensions

   The following intrinsic procedures are provided by the module; their
definition can be found in the section Intrinsic Procedures of this
manual.

`C_ASSOCIATED'

`C_F_POINTER'

`C_F_PROCPOINTER'

`C_FUNLOC'

`C_LOC'

   The `ISO_C_BINDING' module provides the following named constants of
the type integer, which can be used as KIND type parameter. Note that
GNU Fortran currently does not support the `C_INT_FAST...' KIND type
parameters (marked by an asterisk (`*') in the list below).  The
`C_INT_FAST...' parameters have therefore the value -2 and cannot be
used as KIND type parameter of the `INTEGER' type.

   In addition to the integer named constants required by the Fortran
2003 standard, GNU Fortran provides as an extension named constants for
the 128-bit integer types supported by the C compiler: `C_INT128_T,
C_INT_LEAST128_T, C_INT_FAST128_T'.

Fortran     Named constant            C type                    Extension
Type                                                            
`INTEGER'   `C_INT'                   `int'                     
`INTEGER'   `C_SHORT'                 `short int'               
`INTEGER'   `C_LONG'                  `long int'                
`INTEGER'   `C_LONG_LONG'             `long long int'           
`INTEGER'   `C_SIGNED_CHAR'           `signed char'/`unsigned   
                                      char'                     
`INTEGER'   `C_SIZE_T'                `size_t'                  
`INTEGER'   `C_INT8_T'                `int8_t'                  
`INTEGER'   `C_INT16_T'               `int16_t'                 
`INTEGER'   `C_INT32_T'               `int32_t'                 
`INTEGER'   `C_INT64_T'               `int64_t'                 
`INTEGER'   `C_INT128_T'              `int128_t'                Ext.
`INTEGER'   `C_INT_LEAST8_T'          `int_least8_t'            
`INTEGER'   `C_INT_LEAST16_T'         `int_least16_t'           
`INTEGER'   `C_INT_LEAST32_T'         `int_least32_t'           
`INTEGER'   `C_INT_LEAST64_T'         `int_least64_t'           
`INTEGER'   `C_INT_LEAST128_T'        `int_least128_t'          Ext.
`INTEGER'   `C_INT_FAST8_T'*          `int_fast8_t'             
`INTEGER'   `C_INT_FAST16_T'*         `int_fast16_t'            
`INTEGER'   `C_INT_FAST32_T'*         `int_fast32_t'            
`INTEGER'   `C_INT_FAST64_T'*         `int_fast64_t'            
`INTEGER'   `C_INT_FAST128_T'*        `int_fast128_t'           Ext.
`INTEGER'   `C_INTMAX_T'              `intmax_t'                
`INTEGER'   `C_INTPTR_T'              `intptr_t'                
`REAL'      `C_FLOAT'                 `float'                   
`REAL'      `C_DOUBLE'                `double'                  
`REAL'      `C_LONG_DOUBLE'           `long double'             
`COMPLEX'   `C_FLOAT_COMPLEX'         `float _Complex'          
`COMPLEX'   `C_DOUBLE_COMPLEX'        `double _Complex'         
`COMPLEX'   `C_LONG_DOUBLE_COMPLEX'   `long double _Complex'    
`LOGICAL'   `C_BOOL'                  `_Bool'                   
`CHARACTER' `C_CHAR'                  `char'                    

   Additionally, the following `(CHARACTER(KIND=C_CHAR))' are defined.

Name           C definition                     Value
`C_NULL_CHAR'  null character                   `'\0''
`C_ALERT'      alert                            `'\a''
`C_BACKSPACE'  backspace                        `'\b''
`C_FORM_FEED'  form feed                        `'\f''
`C_NEW_LINE'   new line                         `'\n''
`C_CARRIAGE_RETURN'carriage return                  `'\r''
`C_HORIZONTAL_TAB'horizontal tab                   `'\t''
`C_VERTICAL_TAB'vertical tab                     `'\v''

8.3 OpenMP Modules `OMP_LIB' and `OMP_LIB_KINDS'
================================================

_Standard_:
     OpenMP Application Program Interface v3.0

   The OpenMP Fortran runtime library routines are provided both in a
form of two Fortran 90 modules, named `OMP_LIB' and `OMP_LIB_KINDS',
and in a form of a Fortran `include' file named `omp_lib.h'. The
procedures provided by `OMP_LIB' can be found in the *note
Introduction: (libgomp)Top. manual, the named constants defined in the
`OMP_LIB_KINDS' module are listed below.

   For details refer to the actual OpenMP Application Program Interface
v3.0 (http://www.openmp.org/mp-documents/spec30.pdf).

   `OMP_LIB_KINDS' provides the following scalar default-integer named
constants:

`omp_integer_kind'

`omp_logical_kind'

`omp_lock_kind'

`omp_nest_lock_kind'

`omp_sched_kind'


File: gfortran.info,  Node: Contributing,  Next: Copying,  Prev: Intrinsic Modules,  Up: Top

Contributing
************

Free software is only possible if people contribute to efforts to
create it.  We're always in need of more people helping out with ideas
and comments, writing documentation and contributing code.

   If you want to contribute to GNU Fortran, have a look at the long
lists of projects you can take on.  Some of these projects are small,
some of them are large; some are completely orthogonal to the rest of
what is happening on GNU Fortran, but others are "mainstream" projects
in need of enthusiastic hackers.  All of these projects are important!
We'll eventually get around to the things here, but they are also
things doable by someone who is willing and able.

* Menu:

* Contributors::
* Projects::
* Proposed Extensions::


File: gfortran.info,  Node: Contributors,  Next: Projects,  Up: Contributing

Contributors to GNU Fortran
===========================

Most of the parser was hand-crafted by _Andy Vaught_, who is also the
initiator of the whole project.  Thanks Andy!  Most of the interface
with GCC was written by _Paul Brook_.

   The following individuals have contributed code and/or ideas and
significant help to the GNU Fortran project (in alphabetical order):

   - Janne Blomqvist

   - Steven Bosscher

   - Paul Brook

   - Tobias Burnus

   - Franc,ois-Xavier Coudert

   - Bud Davis

   - Jerry DeLisle

   - Erik Edelmann

   - Bernhard Fischer

   - Daniel Franke

   - Richard Guenther

   - Richard Henderson

   - Katherine Holcomb

   - Jakub Jelinek

   - Niels Kristian Bech Jensen

   - Steven Johnson

   - Steven G. Kargl

   - Thomas Koenig

   - Asher Langton

   - H. J. Lu

   - Toon Moene

   - Brooks Moses

   - Andrew Pinski

   - Tim Prince

   - Christopher D. Rickett

   - Richard Sandiford

   - Tobias Schlu"ter

   - Roger Sayle

   - Paul Thomas

   - Andy Vaught

   - Feng Wang

   - Janus Weil

   The following people have contributed bug reports, smaller or larger
patches, and much needed feedback and encouragement for the GNU Fortran
project:

   - Bill Clodius

   - Dominique d'Humie`res

   - Kate Hedstrom

   - Erik Schnetter

   Many other individuals have helped debug, test and improve the GNU
Fortran compiler over the past few years, and we welcome you to do the
same!  If you already have done so, and you would like to see your name
listed in the list above, please contact us.


File: gfortran.info,  Node: Projects,  Next: Proposed Extensions,  Prev: Contributors,  Up: Contributing

Projects
========

_Help build the test suite_
     Solicit more code for donation to the test suite: the more
     extensive the testsuite, the smaller the risk of breaking things
     in the future! We can keep code private on request.

_Bug hunting/squishing_
     Find bugs and write more test cases! Test cases are especially very
     welcome, because it allows us to concentrate on fixing bugs
     instead of isolating them. Going through the bugzilla database at
     `http://gcc.gnu.org/bugzilla/' to reduce testcases posted there and
     add more information (for example, for which version does the
     testcase work, for which versions does it fail?) is also very
     helpful.



File: gfortran.info,  Node: Proposed Extensions,  Prev: Projects,  Up: Contributing

Proposed Extensions
===================

Here's a list of proposed extensions for the GNU Fortran compiler, in
no particular order.  Most of these are necessary to be fully
compatible with existing Fortran compilers, but they are not part of
the official J3 Fortran 95 standard.

Compiler extensions:
--------------------

   * User-specified alignment rules for structures.

   * Flag to generate `Makefile' info.

   * Automatically extend single precision constants to double.

   * Compile code that conserves memory by dynamically allocating
     common and module storage either on stack or heap.

   * Compile flag to generate code for array conformance checking
     (suggest -CC).

   * User control of symbol names (underscores, etc).

   * Compile setting for maximum size of stack frame size before
     spilling parts to static or heap.

   * Flag to force local variables into static space.

   * Flag to force local variables onto stack.

Environment Options
-------------------

   * Pluggable library modules for random numbers, linear algebra.  LA
     should use BLAS calling conventions.

   * Environment variables controlling actions on arithmetic exceptions
     like overflow, underflow, precision loss--Generate NaN, abort,
     default.  action.

   * Set precision for fp units that support it (i387).

   * Variable for setting fp rounding mode.

   * Variable to fill uninitialized variables with a user-defined bit
     pattern.

   * Environment variable controlling filename that is opened for that
     unit number.

   * Environment variable to clear/trash memory being freed.

   * Environment variable to control tracing of allocations and frees.

   * Environment variable to display allocated memory at normal program
     end.

   * Environment variable for filename for * IO-unit.

   * Environment variable for temporary file directory.

   * Environment variable forcing standard output to be line buffered
     (unix).



File: gfortran.info,  Node: Copying,  Next: GNU Free Documentation License,  Prev: Contributing,  Up: Top

GNU General Public License
**************************

                        Version 3, 29 June 2007

     Copyright (C) 2007 Free Software Foundation, Inc. `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program-to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the software,
or if you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those domains
in future versions of the GPL, as needed to protect the freedom of
users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     "This License" refers to version 3 of the GNU General Public
     License.

     "Copyright" also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     "The Program" refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as "you".  "Licensees" and
     "recipients" may be individuals or organizations.

     To "modify" a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a "modified
     version" of the earlier work or a work "based on" the earlier work.

     A "covered work" means either the unmodified Program or a work
     based on the Program.

     To "propagate" a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it
     on a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To "convey" a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays "Appropriate Legal Notices"
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may
     convey the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The "source code" for a work means the preferred form of the work
     for making modifications to it.  "Object code" means any
     non-source form of a work.

     A "Standard Interface" means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The "System Libraries" of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work
     with that Major Component, or to implement a Standard Interface
     for which an implementation is available to the public in source
     code form.  A "Major Component", in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The "Corresponding Source" for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including
     scripts to control those activities.  However, it does not include
     the work's System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files
     associated with source files for the work, and the source code for
     shared libraries and dynamically linked subprograms that the work
     is specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output,
     given its content, constitutes a covered work.  This License
     acknowledges your rights of fair use or other equivalent, as
     provided by copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for
     you, or provide you with facilities for running those works,
     provided that you comply with the terms of this License in
     conveying all material for which you do not control copyright.
     Those thus making or running the covered works for you must do so
     exclusively on your behalf, under your direction and control, on
     terms that prohibit them from making any copies of your
     copyrighted material outside their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention
     to limit operation or modification of the work as a means of
     enforcing, against the work's users, your or third parties' legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program's source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to "keep intact all notices".

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an "aggregate" if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation's users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for
          as long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of
          the written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access
          to the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated
          by you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to
          the object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long
          as needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.


     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A "User Product" is either (1) a "consumer product", which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product
     is a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     "normally used" refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     "Installation Information" for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or
     installed by the recipient, or for the User Product in which it
     has been modified or installed.  Access to a network may be denied
     when the modification itself materially and adversely affects the
     operation of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     "Additional permissions" are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License
     with terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be
          marked in reasonable ways as different from the original
          version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered "further
     restrictions" within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or
     conveying under this License, you may add to a covered work
     material governed by the terms of that license document, provided
     that the further restriction does not survive such relicensing or
     conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under
     the third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, you do not qualify to receive new
     licenses for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

 10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An "entity transaction" is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party's predecessor in interest had or
     could give under the previous paragraph, plus a right to
     possession of the Corresponding Source of the work from the
     predecessor in interest, if the predecessor has it or can get it
     with reasonable efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for
     exercise of rights granted under this License, and you may not
     initiate litigation (including a cross-claim or counterclaim in a
     lawsuit) alleging that any patent claim is infringed by making,
     using, selling, offering for sale, or importing the Program or any
     portion of it.

 11. Patents.

     A "contributor" is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor's "contributor
     version".

     A contributor's "essential patent claims" are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, "control"
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor's essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its
     contributor version.

     In the following three paragraphs, a "patent license" is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To
     "grant" such a patent license to a party means to make such an
     agreement or commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  "Knowingly relying" means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient's use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is "discriminatory" if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under
     which you make payment to the third party based on the extent of
     your activity of conveying the work, and under which the third
     party grants, to any of the parties who would receive the covered
     work from you, a discriminatory patent license (a) in connection
     with copies of the covered work conveyed by you (or copies made
     from those copies), or (b) primarily for and in connection with
     specific products or compilations that contain the covered work,
     unless you entered into that arrangement, or that patent license
     was granted, prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

 12. No Surrender of Others' Freedom.

     If conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot convey a covered work so as to satisfy
     simultaneously your obligations under this License and any other
     pertinent obligations, then as a consequence you may not convey it
     at all.  For example, if you agree to terms that obligate you to
     collect a royalty for further conveying from those to whom you
     convey the Program, the only way you could satisfy both those
     terms and this License would be to refrain entirely from conveying
     the Program.

 13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

 14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.
     Such new versions will be similar in spirit to the present
     version, but may differ in detail to address new problems or
     concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the
     Free Software Foundation.  If the Program does not specify a
     version number of the GNU General Public License, you may choose
     any version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

 15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS"
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

 16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU
     FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

 17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.


END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see `http://www.gnu.org/licenses/'.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an "about box".

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see `http://www.gnu.org/licenses/'.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read `http://www.gnu.org/philosophy/why-not-lgpl.html'.


File: gfortran.info,  Node: GNU Free Documentation License,  Next: Funding,  Prev: Copying,  Up: Top

GNU Free Documentation License
******************************

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: gfortran.info,  Node: Funding,  Next: Option Index,  Prev: GNU Free Documentation License,  Up: Top

Funding Free Software
*********************

If you want to have more free software a few years from now, it makes
sense for you to help encourage people to contribute funds for its
development.  The most effective approach known is to encourage
commercial redistributors to donate.

   Users of free software systems can boost the pace of development by
encouraging for-a-fee distributors to donate part of their selling price
to free software developers--the Free Software Foundation, and others.

   The way to convince distributors to do this is to demand it and
expect it from them.  So when you compare distributors, judge them
partly by how much they give to free software development.  Show
distributors they must compete to be the one who gives the most.

   To make this approach work, you must insist on numbers that you can
compare, such as, "We will donate ten dollars to the Frobnitz project
for each disk sold."  Don't be satisfied with a vague promise, such as
"A portion of the profits are donated," since it doesn't give a basis
for comparison.

   Even a precise fraction "of the profits from this disk" is not very
meaningful, since creative accounting and unrelated business decisions
can greatly alter what fraction of the sales price counts as profit.
If the price you pay is $50, ten percent of the profit is probably less
than a dollar; it might be a few cents, or nothing at all.

   Some redistributors do development work themselves.  This is useful
too; but to keep everyone honest, you need to inquire how much they do,
and what kind.  Some kinds of development make much more long-term
difference than others.  For example, maintaining a separate version of
a program contributes very little; maintaining the standard version of a
program for the whole community contributes much.  Easy new ports
contribute little, since someone else would surely do them; difficult
ports such as adding a new CPU to the GNU Compiler Collection
contribute more; major new features or packages contribute the most.

   By establishing the idea that supporting further development is "the
proper thing to do" when distributing free software for a fee, we can
assure a steady flow of resources into making more free software.

     Copyright (C) 1994 Free Software Foundation, Inc.
     Verbatim copying and redistribution of this section is permitted
     without royalty; alteration is not permitted.


File: gfortran.info,  Node: Option Index,  Next: Keyword Index,  Prev: Funding,  Up: Top

Option Index
************

`gfortran''s command line options are indexed here without any initial
`-' or `--'. Where an option has both positive and negative forms (such
as -foption and -fno-option), relevant entries in the manual are
indexed under the most appropriate form; it may sometimes be useful to
look up both forms.

 [index ]
* Menu:

* A-PREDICATE=ANSWER:                    Preprocessing Options.
                                                              (line 120)
* APREDICATE=ANSWER:                     Preprocessing Options.
                                                              (line 114)
* backslash:                             Fortran Dialect Options.
                                                              (line  59)
* C:                                     Preprocessing Options.
                                                              (line 123)
* CC:                                    Preprocessing Options.
                                                              (line 138)
* cpp:                                   Preprocessing Options.
                                                              (line  13)
* dD:                                    Preprocessing Options.
                                                              (line  35)
* dI:                                    Preprocessing Options.
                                                              (line  51)
* dM:                                    Preprocessing Options.
                                                              (line  26)
* dN:                                    Preprocessing Options.
                                                              (line  41)
* DNAME:                                 Preprocessing Options.
                                                              (line 153)
* DNAME=DEFINITION:                      Preprocessing Options.
                                                              (line 156)
* dU:                                    Preprocessing Options.
                                                              (line  44)
* falign-commons:                        Code Gen Options.    (line 255)
* fall-intrinsics:                       Fortran Dialect Options.
                                                              (line  18)
* fbacktrace:                            Debugging Options.   (line  31)
* fblas-matmul-limit:                    Code Gen Options.    (line 214)
* fbounds-check:                         Code Gen Options.    (line 130)
* fcheck-array-temporaries:              Code Gen Options.    (line 144)
* fconvert=CONVERSION:                   Runtime Options.     (line   9)
* fcray-pointer:                         Fortran Dialect Options.
                                                              (line 105)
* fd-lines-as-code:                      Fortran Dialect Options.
                                                              (line  29)
* fd-lines-as-comments:                  Fortran Dialect Options.
                                                              (line  29)
* fdefault-double-8:                     Fortran Dialect Options.
                                                              (line  36)
* fdefault-integer-8:                    Fortran Dialect Options.
                                                              (line  44)
* fdefault-real-8:                       Fortran Dialect Options.
                                                              (line  49)
* fdollar-ok:                            Fortran Dialect Options.
                                                              (line  56)
* fdump-core:                            Debugging Options.   (line  38)
* fdump-parse-tree:                      Debugging Options.   (line  10)
* fexternal-blas:                        Code Gen Options.    (line 206)
* ff2c:                                  Code Gen Options.    (line  25)
* ffixed-line-length-N:                  Fortran Dialect Options.
                                                              (line  76)
* ffpe-trap=LIST:                        Debugging Options.   (line  14)
* ffree-form:                            Fortran Dialect Options.
                                                              (line  12)
* ffree-line-length-N:                   Fortran Dialect Options.
                                                              (line  89)
* fimplicit-none:                        Fortran Dialect Options.
                                                              (line 100)
* finit-character:                       Code Gen Options.    (line 238)
* finit-integer:                         Code Gen Options.    (line 238)
* finit-local-zero:                      Code Gen Options.    (line 238)
* finit-logical:                         Code Gen Options.    (line 238)
* finit-real:                            Code Gen Options.    (line 238)
* fintrinsic-modules-path DIR:           Directory Options.   (line  40)
* fmax-array-constructor:                Code Gen Options.    (line 152)
* fmax-errors=N:                         Error and Warning Options.
                                                              (line  27)
* fmax-identifier-length=N:              Fortran Dialect Options.
                                                              (line  96)
* fmax-stack-var-size:                   Code Gen Options.    (line 170)
* fmax-subrecord-length=LENGTH:          Runtime Options.     (line  36)
* fmodule-private:                       Fortran Dialect Options.
                                                              (line  71)
* fno-automatic:                         Code Gen Options.    (line  15)
* fno-fixed-form:                        Fortran Dialect Options.
                                                              (line  12)
* fno-range-check:                       Runtime Options.     (line  20)
* fno-underscoring:                      Code Gen Options.    (line  54)
* fopenmp:                               Fortran Dialect Options.
                                                              (line 109)
* fpack-derived:                         Code Gen Options.    (line 184)
* fpp:                                   Preprocessing Options.
                                                              (line  13)
* frange-check:                          Fortran Dialect Options.
                                                              (line 117)
* frecord-marker=LENGTH:                 Runtime Options.     (line  28)
* frecursive:                            Code Gen Options.    (line 225)
* frepack-arrays:                        Code Gen Options.    (line 190)
* fsecond-underscore:                    Code Gen Options.    (line 113)
* fshort-enums <1>:                      Fortran 2003 status. (line  20)
* fshort-enums:                          Code Gen Options.    (line 200)
* fsign-zero:                            Runtime Options.     (line  41)
* fsyntax-only:                          Error and Warning Options.
                                                              (line  33)
* fworking-directory:                    Preprocessing Options.
                                                              (line  55)
* H:                                     Preprocessing Options.
                                                              (line 176)
* IDIR:                                  Directory Options.   (line  14)
* idirafter DIR:                         Preprocessing Options.
                                                              (line  70)
* imultilib DIR:                         Preprocessing Options.
                                                              (line  77)
* iprefix PREFIX:                        Preprocessing Options.
                                                              (line  81)
* iquote DIR:                            Preprocessing Options.
                                                              (line  90)
* isysroot DIR:                          Preprocessing Options.
                                                              (line  86)
* isystem DIR:                           Preprocessing Options.
                                                              (line  97)
* JDIR:                                  Directory Options.   (line  31)
* MDIR:                                  Directory Options.   (line  31)
* nostdinc:                              Preprocessing Options.
                                                              (line 105)
* P:                                     Preprocessing Options.
                                                              (line 181)
* pedantic:                              Error and Warning Options.
                                                              (line  38)
* pedantic-errors:                       Error and Warning Options.
                                                              (line  57)
* static-libgfortran:                    Link Options.        (line  11)
* std=STD option:                        Fortran Dialect Options.
                                                              (line 129)
* UNAME:                                 Preprocessing Options.
                                                              (line 187)
* undef:                                 Preprocessing Options.
                                                              (line 110)
* Waliasing:                             Error and Warning Options.
                                                              (line  68)
* Walign-commons:                        Error and Warning Options.
                                                              (line 165)
* Wall:                                  Error and Warning Options.
                                                              (line  61)
* Wampersand:                            Error and Warning Options.
                                                              (line  85)
* Warray-temporaries:                    Error and Warning Options.
                                                              (line  93)
* Wcharacter-truncation:                 Error and Warning Options.
                                                              (line  98)
* Wconversion:                           Error and Warning Options.
                                                              (line 104)
* Werror:                                Error and Warning Options.
                                                              (line 171)
* Wimplicit-interface:                   Error and Warning Options.
                                                              (line 107)
* Wintrinsic-shadow:                     Error and Warning Options.
                                                              (line 152)
* Wintrinsics-std:                       Error and Warning Options.
                                                              (line 113)
* Wline-truncation:                      Error and Warning Options.
                                                              (line 101)
* Wsurprising:                           Error and Warning Options.
                                                              (line 120)
* Wtabs:                                 Error and Warning Options.
                                                              (line 140)
* Wunderflow:                            Error and Warning Options.
                                                              (line 148)
* Wunused-parameter:                     Error and Warning Options.
                                                              (line 158)


File: gfortran.info,  Node: Keyword Index,  Prev: Option Index,  Up: Top

Keyword Index
*************

 [index ]
* Menu:

* $:                                     Fortran Dialect Options.
                                                              (line  56)
* %LOC:                                  Argument list functions.
                                                              (line   6)
* %REF:                                  Argument list functions.
                                                              (line   6)
* %VAL:                                  Argument list functions.
                                                              (line   6)
* &:                                     Error and Warning Options.
                                                              (line  85)
* [...]:                                 Fortran 2003 status. (line  13)
* ABORT:                                 ABORT.               (line   6)
* ABS:                                   ABS.                 (line   6)
* absolute value:                        ABS.                 (line   6)
* ACCESS:                                ACCESS.              (line   6)
* ACCESS='STREAM' I/O:                   Fortran 2003 status. (line  32)
* ACHAR:                                 ACHAR.               (line   6)
* ACOS:                                  ACOS.                (line   6)
* ACOSH:                                 ACOSH.               (line   6)
* adjust string <1>:                     ADJUSTR.             (line   6)
* adjust string:                         ADJUSTL.             (line   6)
* ADJUSTL:                               ADJUSTL.             (line   6)
* ADJUSTR:                               ADJUSTR.             (line   6)
* AIMAG:                                 AIMAG.               (line   6)
* AINT:                                  AINT.                (line   6)
* ALARM:                                 ALARM.               (line   6)
* ALGAMA:                                LOG_GAMMA.           (line   6)
* aliasing:                              Error and Warning Options.
                                                              (line  68)
* alignment of COMMON blocks <1>:        Code Gen Options.    (line 255)
* alignment of COMMON blocks:            Error and Warning Options.
                                                              (line 165)
* ALL:                                   ALL.                 (line   6)
* all warnings:                          Error and Warning Options.
                                                              (line  61)
* ALLOCATABLE components of derived types: Fortran 2003 status.
                                                              (line  30)
* ALLOCATABLE dummy arguments:           Fortran 2003 status. (line  26)
* ALLOCATABLE function results:          Fortran 2003 status. (line  28)
* ALLOCATED:                             ALLOCATED.           (line   6)
* allocation, moving:                    MOVE_ALLOC.          (line   6)
* allocation, status:                    ALLOCATED.           (line   6)
* ALOG:                                  LOG.                 (line   6)
* ALOG10:                                LOG10.               (line   6)
* AMAX0:                                 MAX.                 (line   6)
* AMAX1:                                 MAX.                 (line   6)
* AMIN0:                                 MIN.                 (line   6)
* AMIN1:                                 MIN.                 (line   6)
* AMOD:                                  MOD.                 (line   6)
* AND:                                   AND.                 (line   6)
* ANINT:                                 ANINT.               (line   6)
* ANY:                                   ANY.                 (line   6)
* area hyperbolic cosine:                ACOSH.               (line   6)
* area hyperbolic sine:                  ASINH.               (line   6)
* area hyperbolic tangent:               ATANH.               (line   6)
* argument list functions:               Argument list functions.
                                                              (line   6)
* arguments, to program <1>:             IARGC.               (line   6)
* arguments, to program <2>:             GET_COMMAND_ARGUMENT.
                                                              (line   6)
* arguments, to program <3>:             GET_COMMAND.         (line   6)
* arguments, to program <4>:             GETARG.              (line   6)
* arguments, to program:                 COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* array, add elements:                   SUM.                 (line   6)
* array, apply condition <1>:            ANY.                 (line   6)
* array, apply condition:                ALL.                 (line   6)
* array, bounds checking:                Code Gen Options.    (line 130)
* array, change dimensions:              RESHAPE.             (line   6)
* array, combine arrays:                 MERGE.               (line   6)
* array, condition testing <1>:          ANY.                 (line   6)
* array, condition testing:              ALL.                 (line   6)
* array, conditionally add elements:     SUM.                 (line   6)
* array, conditionally count elements:   COUNT.               (line   6)
* array, conditionally multiply elements: PRODUCT.            (line   6)
* array, constructors:                   Fortran 2003 status. (line  13)
* array, count elements:                 SIZE.                (line   6)
* array, duplicate dimensions:           SPREAD.              (line   6)
* array, duplicate elements:             SPREAD.              (line   6)
* array, element counting:               COUNT.               (line   6)
* array, gather elements:                PACK.                (line   6)
* array, increase dimension <1>:         UNPACK.              (line   6)
* array, increase dimension:             SPREAD.              (line   6)
* array, indices of type real:           Real array indices.  (line   6)
* array, location of maximum element:    MAXLOC.              (line   6)
* array, location of minimum element:    MINLOC.              (line   6)
* array, lower bound:                    LBOUND.              (line   6)
* array, maximum value:                  MAXVAL.              (line   6)
* array, merge arrays:                   MERGE.               (line   6)
* array, minimum value:                  MINVAL.              (line   6)
* array, multiply elements:              PRODUCT.             (line   6)
* array, number of elements <1>:         SIZE.                (line   6)
* array, number of elements:             COUNT.               (line   6)
* array, packing:                        PACK.                (line   6)
* array, permutation:                    CSHIFT.              (line   6)
* array, product:                        PRODUCT.             (line   6)
* array, reduce dimension:               PACK.                (line   6)
* array, rotate:                         CSHIFT.              (line   6)
* array, scatter elements:               UNPACK.              (line   6)
* array, shape:                          SHAPE.               (line   6)
* array, shift:                          EOSHIFT.             (line   6)
* array, shift circularly:               CSHIFT.              (line   6)
* array, size:                           SIZE.                (line   6)
* array, sum:                            SUM.                 (line   6)
* array, transmogrify:                   RESHAPE.             (line   6)
* array, transpose:                      TRANSPOSE.           (line   6)
* array, unpacking:                      UNPACK.              (line   6)
* array, upper bound:                    UBOUND.              (line   6)
* ASCII collating sequence <1>:          IACHAR.              (line   6)
* ASCII collating sequence:              ACHAR.               (line   6)
* ASIN:                                  ASIN.                (line   6)
* ASINH <1>:                             ATANH.               (line   6)
* ASINH:                                 ASINH.               (line   6)
* ASSOCIATED:                            ASSOCIATED.          (line   6)
* association status:                    ASSOCIATED.          (line   6)
* association status, C pointer:         C_ASSOCIATED.        (line   6)
* ATAN:                                  ATAN.                (line   6)
* ATAN2:                                 ATAN2.               (line   6)
* Authors:                               Contributors.        (line   6)
* backslash:                             Fortran Dialect Options.
                                                              (line  59)
* backtrace:                             Debugging Options.   (line  31)
* BESJ0:                                 BESSEL_J0.           (line   6)
* BESJ1:                                 BESSEL_J1.           (line   6)
* BESJN:                                 BESSEL_JN.           (line   6)
* Bessel function, first kind <1>:       BESSEL_JN.           (line   6)
* Bessel function, first kind <2>:       BESSEL_J1.           (line   6)
* Bessel function, first kind:           BESSEL_J0.           (line   6)
* Bessel function, second kind <1>:      BESSEL_YN.           (line   6)
* Bessel function, second kind <2>:      BESSEL_Y1.           (line   6)
* Bessel function, second kind:          BESSEL_Y0.           (line   6)
* BESSEL_J0:                             BESSEL_J0.           (line   6)
* BESSEL_J1:                             BESSEL_J1.           (line   6)
* BESSEL_JN:                             BESSEL_JN.           (line   6)
* BESSEL_Y0:                             BESSEL_Y0.           (line   6)
* BESSEL_Y1:                             BESSEL_Y1.           (line   6)
* BESSEL_YN:                             BESSEL_YN.           (line   6)
* BESY0:                                 BESSEL_Y0.           (line   6)
* BESY1:                                 BESSEL_Y1.           (line   6)
* BESYN:                                 BESSEL_YN.           (line   6)
* BIT_SIZE:                              BIT_SIZE.            (line   6)
* bits, clear:                           IBCLR.               (line   6)
* bits, extract:                         IBITS.               (line   6)
* bits, get:                             IBITS.               (line   6)
* bits, move <1>:                        TRANSFER.            (line   6)
* bits, move:                            MVBITS.              (line   6)
* bits, negate:                          NOT.                 (line   6)
* bits, number of:                       BIT_SIZE.            (line   6)
* bits, set:                             IBSET.               (line   6)
* bits, shift:                           ISHFT.               (line   6)
* bits, shift circular:                  ISHFTC.              (line   6)
* bits, shift left:                      LSHIFT.              (line   6)
* bits, shift right:                     RSHIFT.              (line   6)
* bits, testing:                         BTEST.               (line   6)
* bits, unset:                           IBCLR.               (line   6)
* bitwise logical and <1>:               IAND.                (line   6)
* bitwise logical and:                   AND.                 (line   6)
* bitwise logical exclusive or <1>:      XOR.                 (line   6)
* bitwise logical exclusive or:          IEOR.                (line   6)
* bitwise logical not:                   NOT.                 (line   6)
* bitwise logical or <1>:                OR.                  (line   6)
* bitwise logical or:                    IOR.                 (line   6)
* bounds checking:                       Code Gen Options.    (line 130)
* BOZ literal constants:                 BOZ literal constants.
                                                              (line   6)
* BTEST:                                 BTEST.               (line   6)
* C_ASSOCIATED:                          C_ASSOCIATED.        (line   6)
* C_F_POINTER:                           C_F_POINTER.         (line   6)
* C_F_PROCPOINTER:                       C_F_PROCPOINTER.     (line   6)
* C_FUNLOC:                              C_FUNLOC.            (line   6)
* C_LOC:                                 C_LOC.               (line   6)
* C_SIZEOF:                              C_SIZEOF.            (line   6)
* CABS:                                  ABS.                 (line   6)
* calling convention:                    Code Gen Options.    (line  25)
* CCOS:                                  COS.                 (line   6)
* CDABS:                                 ABS.                 (line   6)
* CDCOS:                                 COS.                 (line   6)
* CDEXP:                                 EXP.                 (line   6)
* CDLOG:                                 LOG.                 (line   6)
* CDSIN:                                 SIN.                 (line   6)
* CDSQRT:                                SQRT.                (line   6)
* ceiling:                               CEILING.             (line   6)
* CEILING:                               CEILING.             (line   6)
* ceiling:                               ANINT.               (line   6)
* CEXP:                                  EXP.                 (line   6)
* CHAR:                                  CHAR.                (line   6)
* character kind:                        SELECTED_CHAR_KIND.  (line   6)
* character set:                         Fortran Dialect Options.
                                                              (line  56)
* CHDIR:                                 CHDIR.               (line   6)
* checking array temporaries:            Code Gen Options.    (line 144)
* checking subscripts:                   Code Gen Options.    (line 130)
* CHMOD:                                 CHMOD.               (line   6)
* clock ticks <1>:                       SYSTEM_CLOCK.        (line   6)
* clock ticks <2>:                       MCLOCK8.             (line   6)
* clock ticks:                           MCLOCK.              (line   6)
* CLOG:                                  LOG.                 (line   6)
* CMPLX:                                 CMPLX.               (line   6)
* code generation, conventions:          Code Gen Options.    (line   6)
* collating sequence, ASCII <1>:         IACHAR.              (line   6)
* collating sequence, ASCII:             ACHAR.               (line   6)
* command options:                       Invoking GNU Fortran.
                                                              (line   6)
* command-line arguments <1>:            IARGC.               (line   6)
* command-line arguments <2>:            GET_COMMAND_ARGUMENT.
                                                              (line   6)
* command-line arguments <3>:            GET_COMMAND.         (line   6)
* command-line arguments <4>:            GETARG.              (line   6)
* command-line arguments:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* command-line arguments, number of <1>: IARGC.               (line   6)
* command-line arguments, number of:     COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* COMMAND_ARGUMENT_COUNT:                COMMAND_ARGUMENT_COUNT.
                                                              (line   6)
* COMPLEX:                               COMPLEX.             (line   6)
* complex conjugate:                     CONJG.               (line   6)
* complex numbers, conversion to <1>:    DCMPLX.              (line   6)
* complex numbers, conversion to <2>:    COMPLEX.             (line   6)
* complex numbers, conversion to:        CMPLX.               (line   6)
* complex numbers, imaginary part:       AIMAG.               (line   6)
* complex numbers, real part <1>:        REAL.                (line   6)
* complex numbers, real part:            DREAL.               (line   6)
* Conditional compilation:               Preprocessing and conditional compilation.
                                                              (line   6)
* CONJG:                                 CONJG.               (line   6)
* Contributing:                          Contributing.        (line   6)
* Contributors:                          Contributors.        (line   6)
* conversion:                            Error and Warning Options.
                                                              (line 104)
* conversion, to character:              CHAR.                (line   6)
* conversion, to complex <1>:            DCMPLX.              (line   6)
* conversion, to complex <2>:            COMPLEX.             (line   6)
* conversion, to complex:                CMPLX.               (line   6)
* conversion, to integer <1>:            LONG.                (line   6)
* conversion, to integer <2>:            INT8.                (line   6)
* conversion, to integer <3>:            INT2.                (line   6)
* conversion, to integer <4>:            INT.                 (line   6)
* conversion, to integer <5>:            ICHAR.               (line   6)
* conversion, to integer <6>:            IACHAR.              (line   6)
* conversion, to integer:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to logical <1>:            LOGICAL.             (line   6)
* conversion, to logical:                Implicitly convert LOGICAL and INTEGER values.
                                                              (line   6)
* conversion, to real <1>:               SNGL.                (line   6)
* conversion, to real <2>:               REAL.                (line   6)
* conversion, to real <3>:               FLOAT.               (line   6)
* conversion, to real <4>:               DFLOAT.              (line   6)
* conversion, to real:                   DBLE.                (line   6)
* conversion, to string:                 CTIME.               (line   6)
* CONVERT specifier:                     CONVERT specifier.   (line   6)
* core, dump <1>:                        ABORT.               (line   6)
* core, dump:                            Debugging Options.   (line  38)
* COS:                                   COS.                 (line   6)
* COSH:                                  COSH.                (line   6)
* cosine:                                COS.                 (line   6)
* cosine, hyperbolic:                    COSH.                (line   6)
* cosine, hyperbolic, inverse:           ACOSH.               (line   6)
* cosine, inverse:                       ACOS.                (line   6)
* COUNT:                                 COUNT.               (line   6)
* CPP <1>:                               Preprocessing Options.
                                                              (line   6)
* CPP:                                   Preprocessing and conditional compilation.
                                                              (line   6)
* CPU_TIME:                              CPU_TIME.            (line   6)
* Credits:                               Contributors.        (line   6)
* CSHIFT:                                CSHIFT.              (line   6)
* CSIN:                                  SIN.                 (line   6)
* CSQRT:                                 SQRT.                (line   6)
* CTIME:                                 CTIME.               (line   6)
* current date <1>:                      IDATE.               (line   6)
* current date <2>:                      FDATE.               (line   6)
* current date:                          DATE_AND_TIME.       (line   6)
* current time <1>:                      TIME8.               (line   6)
* current time <2>:                      TIME.                (line   6)
* current time <3>:                      ITIME.               (line   6)
* current time <4>:                      FDATE.               (line   6)
* current time:                          DATE_AND_TIME.       (line   6)
* DABS:                                  ABS.                 (line   6)
* DACOS:                                 ACOS.                (line   6)
* DACOSH:                                ACOSH.               (line   6)
* DASIN:                                 ASIN.                (line   6)
* DASINH <1>:                            ATANH.               (line   6)
* DASINH:                                ASINH.               (line   6)
* DATAN:                                 ATAN.                (line   6)
* DATAN2:                                ATAN2.               (line   6)
* date, current <1>:                     IDATE.               (line   6)
* date, current <2>:                     FDATE.               (line   6)
* date, current:                         DATE_AND_TIME.       (line   6)
* DATE_AND_TIME:                         DATE_AND_TIME.       (line   6)
* DBESJ0:                                BESSEL_J0.           (line   6)
* DBESJ1:                                BESSEL_J1.           (line   6)
* DBESJN:                                BESSEL_JN.           (line   6)
* DBESY0:                                BESSEL_Y0.           (line   6)
* DBESY1:                                BESSEL_Y1.           (line   6)
* DBESYN:                                BESSEL_YN.           (line   6)
* DBLE:                                  DBLE.                (line   6)
* DCMPLX:                                DCMPLX.              (line   6)
* DCONJG:                                CONJG.               (line   6)
* DCOS:                                  COS.                 (line   6)
* DCOSH:                                 COSH.                (line   6)
* DDIM:                                  DIM.                 (line   6)
* debugging information options:         Debugging Options.   (line   6)
* debugging, preprocessor:               Preprocessing Options.
                                                              (line  26)
* DECODE:                                ENCODE and DECODE statements.
                                                              (line   6)
* delayed execution <1>:                 SLEEP.               (line   6)
* delayed execution:                     ALARM.               (line   6)
* DEXP:                                  EXP.                 (line   6)
* DFLOAT:                                DFLOAT.              (line   6)
* DGAMMA:                                GAMMA.               (line   6)
* dialect options:                       Fortran Dialect Options.
                                                              (line   6)
* DIGITS:                                DIGITS.              (line   6)
* DIM:                                   DIM.                 (line   6)
* DIMAG:                                 AIMAG.               (line   6)
* DINT:                                  AINT.                (line   6)
* directive, INCLUDE:                    Directory Options.   (line   6)
* directory, options:                    Directory Options.   (line   6)
* directory, search paths for inclusion: Directory Options.   (line  14)
* division, modulo:                      MODULO.              (line   6)
* division, remainder:                   MOD.                 (line   6)
* DLGAMA:                                LOG_GAMMA.           (line   6)
* DLOG:                                  LOG.                 (line   6)
* DLOG10:                                LOG10.               (line   6)
* DMAX1:                                 MAX.                 (line   6)
* DMIN1:                                 MIN.                 (line   6)
* DMOD:                                  MOD.                 (line   6)
* DNINT:                                 ANINT.               (line   6)
* dot product:                           DOT_PRODUCT.         (line   6)
* DOT_PRODUCT:                           DOT_PRODUCT.         (line   6)
* DPROD:                                 DPROD.               (line   6)
* DREAL:                                 DREAL.               (line   6)
* DSIGN:                                 SIGN.                (line   6)
* DSIN:                                  SIN.                 (line   6)
* DSINH:                                 SINH.                (line   6)
* DSQRT:                                 SQRT.                (line   6)
* DTAN:                                  TAN.                 (line   6)
* DTANH:                                 TANH.                (line   6)
* DTIME:                                 DTIME.               (line   6)
* elapsed time <1>:                      SECOND.              (line   6)
* elapsed time <2>:                      SECNDS.              (line   6)
* elapsed time:                          DTIME.               (line   6)
* ENCODE:                                ENCODE and DECODE statements.
                                                              (line   6)
* ENUM statement:                        Fortran 2003 status. (line  20)
* ENUMERATOR statement:                  Fortran 2003 status. (line  20)
* environment variable <1>:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* environment variable <2>:              GETENV.              (line   6)
* environment variable <3>:              Runtime.             (line   6)
* environment variable:                  Environment Variables.
                                                              (line   6)
* EOSHIFT:                               EOSHIFT.             (line   6)
* EPSILON:                               EPSILON.             (line   6)
* ERF:                                   ERF.                 (line   6)
* ERFC:                                  ERFC.                (line   6)
* ERFC_SCALED:                           ERFC_SCALED.         (line   6)
* error function:                        ERF.                 (line   6)
* error function, complementary:         ERFC.                (line   6)
* error function, complementary, exponentially-scaled: ERFC_SCALED.
                                                              (line   6)
* errors, limiting:                      Error and Warning Options.
                                                              (line  27)
* escape characters:                     Fortran Dialect Options.
                                                              (line  59)
* ETIME:                                 ETIME.               (line   6)
* Euclidean distance:                    HYPOT.               (line   6)
* EXIT:                                  EXIT.                (line   6)
* EXP:                                   EXP.                 (line   6)
* EXPONENT:                              EXPONENT.            (line   6)
* exponential function:                  EXP.                 (line   6)
* exponential function, inverse <1>:     LOG10.               (line   6)
* exponential function, inverse:         LOG.                 (line   6)
* expression size <1>:                   SIZEOF.              (line   6)
* expression size:                       C_SIZEOF.            (line   6)
* extensions:                            Extensions.          (line   6)
* extensions, implemented:               Extensions implemented in GNU Fortran.
                                                              (line   6)
* extensions, not implemented:           Extensions not implemented in GNU Fortran.
                                                              (line   6)
* f2c calling convention:                Code Gen Options.    (line  25)
* Factorial function:                    GAMMA.               (line   6)
* FDATE:                                 FDATE.               (line   6)
* FDL, GNU Free Documentation License:   GNU Free Documentation License.
                                                              (line   6)
* FGET:                                  FGET.                (line   6)
* FGETC:                                 FGETC.               (line   6)
* file format, fixed:                    Fortran Dialect Options.
                                                              (line  12)
* file format, free:                     Fortran Dialect Options.
                                                              (line  12)
* file operation, file number:           FNUM.                (line   6)
* file operation, flush:                 FLUSH.               (line   6)
* file operation, position <1>:          FTELL.               (line   6)
* file operation, position:              FSEEK.               (line   6)
* file operation, read character <1>:    FGETC.               (line   6)
* file operation, read character:        FGET.                (line   6)
* file operation, seek:                  FSEEK.               (line   6)
* file operation, write character <1>:   FPUTC.               (line   6)
* file operation, write character:       FPUT.                (line   6)
* file system, access mode:              ACCESS.              (line   6)
* file system, change access mode:       CHMOD.               (line   6)
* file system, create link <1>:          SYMLNK.              (line   6)
* file system, create link:              LINK.                (line   6)
* file system, file creation mask:       UMASK.               (line   6)
* file system, file status <1>:          STAT.                (line   6)
* file system, file status <2>:          LSTAT.               (line   6)
* file system, file status:              FSTAT.               (line   6)
* file system, hard link:                LINK.                (line   6)
* file system, remove file:              UNLINK.              (line   6)
* file system, rename file:              RENAME.              (line   6)
* file system, soft link:                SYMLNK.              (line   6)
* FLOAT:                                 FLOAT.               (line   6)
* floating point, exponent:              EXPONENT.            (line   6)
* floating point, fraction:              FRACTION.            (line   6)
* floating point, nearest different:     NEAREST.             (line   6)
* floating point, relative spacing <1>:  SPACING.             (line   6)
* floating point, relative spacing:      RRSPACING.           (line   6)
* floating point, scale:                 SCALE.               (line   6)
* floating point, set exponent:          SET_EXPONENT.        (line   6)
* floor:                                 FLOOR.               (line   6)
* FLOOR:                                 FLOOR.               (line   6)
* floor:                                 AINT.                (line   6)
* FLUSH:                                 FLUSH.               (line   6)
* FLUSH statement:                       Fortran 2003 status. (line  16)
* FNUM:                                  FNUM.                (line   6)
* Fortran 77:                            GNU Fortran and G77. (line   6)
* FPP:                                   Preprocessing and conditional compilation.
                                                              (line   6)
* FPUT:                                  FPUT.                (line   6)
* FPUTC:                                 FPUTC.               (line   6)
* FRACTION:                              FRACTION.            (line   6)
* FREE:                                  FREE.                (line   6)
* FSEEK:                                 FSEEK.               (line   6)
* FSTAT:                                 FSTAT.               (line   6)
* FTELL:                                 FTELL.               (line   6)
* g77:                                   GNU Fortran and G77. (line   6)
* g77 calling convention:                Code Gen Options.    (line  25)
* GAMMA:                                 GAMMA.               (line   6)
* Gamma function:                        GAMMA.               (line   6)
* Gamma function, logarithm of:          LOG_GAMMA.           (line   6)
* GCC:                                   GNU Fortran and GCC. (line   6)
* GERROR:                                GERROR.              (line   6)
* GET_COMMAND:                           GET_COMMAND.         (line   6)
* GET_COMMAND_ARGUMENT:                  GET_COMMAND_ARGUMENT.
                                                              (line   6)
* GET_ENVIRONMENT_VARIABLE:              GET_ENVIRONMENT_VARIABLE.
                                                              (line   6)
* GETARG:                                GETARG.              (line   6)
* GETCWD:                                GETCWD.              (line   6)
* GETENV:                                GETENV.              (line   6)
* GETGID:                                GETGID.              (line   6)
* GETLOG:                                GETLOG.              (line   6)
* GETPID:                                GETPID.              (line   6)
* GETUID:                                GETUID.              (line   6)
* GMTIME:                                GMTIME.              (line   6)
* GNU Compiler Collection:               GNU Fortran and GCC. (line   6)
* GNU Fortran command options:           Invoking GNU Fortran.
                                                              (line   6)
* Hollerith constants:                   Hollerith constants support.
                                                              (line   6)
* HOSTNM:                                HOSTNM.              (line   6)
* HUGE:                                  HUGE.                (line   6)
* hyperbolic arccosine:                  ACOSH.               (line   6)
* hyperbolic arcsine:                    ASINH.               (line   6)
* hyperbolic arctangent:                 ATANH.               (line   6)
* hyperbolic cosine:                     COSH.                (line   6)
* hyperbolic function, cosine:           COSH.                (line   6)
* hyperbolic function, cosine, inverse:  ACOSH.               (line   6)
* hyperbolic function, sine:             SINH.                (line   6)
* hyperbolic function, sine, inverse:    ASINH.               (line   6)
* hyperbolic function, tangent:          TANH.                (line   6)
* hyperbolic function, tangent, inverse: ATANH.               (line   6)
* hyperbolic sine:                       SINH.                (line   6)
* hyperbolic tangent:                    TANH.                (line   6)
* HYPOT:                                 HYPOT.               (line   6)
* I/O item lists:                        I/O item lists.      (line   6)
* IABS:                                  ABS.                 (line   6)
* IACHAR:                                IACHAR.              (line   6)
* IAND:                                  IAND.                (line   6)
* IARGC:                                 IARGC.               (line   6)
* IBCLR:                                 IBCLR.               (line   6)
* IBITS:                                 IBITS.               (line   6)
* IBSET:                                 IBSET.               (line   6)
* ICHAR:                                 ICHAR.               (line   6)
* IDATE:                                 IDATE.               (line   6)
* IDIM:                                  DIM.                 (line   6)
* IDINT:                                 INT.                 (line   6)
* IDNINT:                                NINT.                (line   6)
* IEEE, ISNAN:                           ISNAN.               (line   6)
* IEOR:                                  IEOR.                (line   6)
* IERRNO:                                IERRNO.              (line   6)
* IFIX:                                  INT.                 (line   6)
* IMAG:                                  AIMAG.               (line   6)
* IMAGPART:                              AIMAG.               (line   6)
* IMPORT statement:                      Fortran 2003 status. (line  43)
* INCLUDE directive:                     Directory Options.   (line   6)
* inclusion, directory search paths for: Directory Options.   (line  14)
* INDEX:                                 INDEX intrinsic.     (line   6)
* INT:                                   INT.                 (line   6)
* INT2:                                  INT2.                (line   6)
* INT8:                                  INT8.                (line   6)
* integer kind:                          SELECTED_INT_KIND.   (line   6)
* intrinsic:                             Error and Warning Options.
                                                              (line 152)
* intrinsic Modules:                     Intrinsic Modules.   (line   6)
* intrinsic procedures:                  Intrinsic Procedures.
                                                              (line   6)
* Introduction:                          Top.                 (line   6)
* IOMSG= specifier:                      Fortran 2003 status. (line  18)
* IOR:                                   IOR.                 (line   6)
* IOSTAT, end of file:                   IS_IOSTAT_END.       (line   6)
* IOSTAT, end of record:                 IS_IOSTAT_EOR.       (line   6)
* IRAND:                                 IRAND.               (line   6)
* IS_IOSTAT_END:                         IS_IOSTAT_END.       (line   6)
* IS_IOSTAT_EOR:                         IS_IOSTAT_EOR.       (line   6)
* ISATTY:                                ISATTY.              (line   6)
* ISHFT:                                 ISHFT.               (line   6)
* ISHFTC:                                ISHFTC.              (line   6)
* ISIGN:                                 SIGN.                (line   6)
* ISNAN:                                 ISNAN.               (line   6)
* ISO C Bindings:                        Fortran 2003 status. (line  52)
* ISO_FORTRAN_ENV statement:             Fortran 2003 status. (line  46)
* ITIME:                                 ITIME.               (line   6)
* KILL:                                  KILL.                (line   6)
* kind:                                  KIND.                (line   6)
* KIND:                                  KIND.                (line   6)
* kind:                                  KIND Type Parameters.
                                                              (line   6)
* kind, character:                       SELECTED_CHAR_KIND.  (line   6)
* kind, integer:                         SELECTED_INT_KIND.   (line   6)
* kind, old-style:                       Old-style kind specifications.
                                                              (line   6)
* kind, real:                            SELECTED_REAL_KIND.  (line   6)
* language, dialect options:             Fortran Dialect Options.
                                                              (line   6)
* LBOUND:                                LBOUND.              (line   6)
* LEADZ:                                 LEADZ.               (line   6)
* LEN:                                   LEN.                 (line   6)
* LEN_TRIM:                              LEN_TRIM.            (line   6)
* lexical comparison of strings <1>:     LLT.                 (line   6)
* lexical comparison of strings <2>:     LLE.                 (line   6)
* lexical comparison of strings <3>:     LGT.                 (line   6)
* lexical comparison of strings:         LGE.                 (line   6)
* LGAMMA:                                LOG_GAMMA.           (line   6)
* LGE:                                   LGE.                 (line   6)
* LGT:                                   LGT.                 (line   6)
* libf2c calling convention:             Code Gen Options.    (line  25)
* limits, largest number:                HUGE.                (line   6)
* limits, smallest number:               TINY.                (line   6)
* LINK:                                  LINK.                (line   6)
* linking, static:                       Link Options.        (line   6)
* LLE:                                   LLE.                 (line   6)
* LLT:                                   LLT.                 (line   6)
* LNBLNK:                                LNBLNK.              (line   6)
* LOC:                                   LOC.                 (line   6)
* location of a variable in memory:      LOC.                 (line   6)
* LOG:                                   LOG.                 (line   6)
* LOG10:                                 LOG10.               (line   6)
* LOG_GAMMA:                             LOG_GAMMA.           (line   6)
* logarithmic function <1>:              LOG10.               (line   6)
* logarithmic function:                  LOG.                 (line   6)
* logarithmic function, inverse:         EXP.                 (line   6)
* LOGICAL:                               LOGICAL.             (line   6)
* logical and, bitwise <1>:              IAND.                (line   6)
* logical and, bitwise:                  AND.                 (line   6)
* logical exclusive or, bitwise <1>:     XOR.                 (line   6)
* logical exclusive or, bitwise:         IEOR.                (line   6)
* logical not, bitwise:                  NOT.                 (line   6)
* logical or, bitwise <1>:               OR.                  (line   6)
* logical or, bitwise:                   IOR.                 (line   6)
* login name:                            GETLOG.              (line   6)
* LONG:                                  LONG.                (line   6)
* LSHIFT:                                LSHIFT.              (line   6)
* LSTAT:                                 LSTAT.               (line   6)
* LTIME:                                 LTIME.               (line   6)
* MALLOC:                                MALLOC.              (line   6)
* MATMUL:                                MATMUL.              (line   6)
* matrix multiplication:                 MATMUL.              (line   6)
* matrix, transpose:                     TRANSPOSE.           (line   6)
* MAX:                                   MAX.                 (line   6)
* MAX0:                                  MAX.                 (line   6)
* MAX1:                                  MAX.                 (line   6)
* MAXEXPONENT:                           MAXEXPONENT.         (line   6)
* maximum value <1>:                     MAXVAL.              (line   6)
* maximum value:                         MAX.                 (line   6)
* MAXLOC:                                MAXLOC.              (line   6)
* MAXVAL:                                MAXVAL.              (line   6)
* MCLOCK:                                MCLOCK.              (line   6)
* MCLOCK8:                               MCLOCK8.             (line   6)
* MERGE:                                 MERGE.               (line   6)
* messages, error:                       Error and Warning Options.
                                                              (line   6)
* messages, warning:                     Error and Warning Options.
                                                              (line   6)
* MIN:                                   MIN.                 (line   6)
* MIN0:                                  MIN.                 (line   6)
* MIN1:                                  MIN.                 (line   6)
* MINEXPONENT:                           MINEXPONENT.         (line   6)
* minimum value <1>:                     MINVAL.              (line   6)
* minimum value:                         MIN.                 (line   6)
* MINLOC:                                MINLOC.              (line   6)
* MINVAL:                                MINVAL.              (line   6)
* MOD:                                   MOD.                 (line   6)
* model representation, base:            RADIX.               (line   6)
* model representation, epsilon:         EPSILON.             (line   6)
* model representation, largest number:  HUGE.                (line   6)
* model representation, maximum exponent: MAXEXPONENT.        (line   6)
* model representation, minimum exponent: MINEXPONENT.        (line   6)
* model representation, precision:       PRECISION.           (line   6)
* model representation, radix:           RADIX.               (line   6)
* model representation, range:           RANGE.               (line   6)
* model representation, significant digits: DIGITS.           (line   6)
* model representation, smallest number: TINY.                (line   6)
* module entities:                       Fortran Dialect Options.
                                                              (line  71)
* module search path:                    Directory Options.   (line  14)
* modulo:                                MODULO.              (line   6)
* MODULO:                                MODULO.              (line   6)
* MOVE_ALLOC:                            MOVE_ALLOC.          (line   6)
* moving allocation:                     MOVE_ALLOC.          (line   6)
* multiply array elements:               PRODUCT.             (line   6)
* MVBITS:                                MVBITS.              (line   6)
* Namelist:                              Extensions to namelist.
                                                              (line   6)
* NEAREST:                               NEAREST.             (line   6)
* NEW_LINE:                              NEW_LINE.            (line   6)
* newline:                               NEW_LINE.            (line   6)
* NINT:                                  NINT.                (line   6)
* NOT:                                   NOT.                 (line   6)
* NULL:                                  NULL.                (line   6)
* OpenMP <1>:                            OpenMP.              (line   6)
* OpenMP:                                Fortran Dialect Options.
                                                              (line 109)
* operators, unary:                      Unary operators.     (line   6)
* options, code generation:              Code Gen Options.    (line   6)
* options, debugging:                    Debugging Options.   (line   6)
* options, dialect:                      Fortran Dialect Options.
                                                              (line   6)
* options, directory search:             Directory Options.   (line   6)
* options, errors:                       Error and Warning Options.
                                                              (line   6)
* options, fortran dialect:              Fortran Dialect Options.
                                                              (line  12)
* options, gfortran command:             Invoking GNU Fortran.
                                                              (line   6)
* options, linking:                      Link Options.        (line   6)
* options, negative forms:               Invoking GNU Fortran.
                                                              (line  13)
* options, preprocessor:                 Preprocessing Options.
                                                              (line   6)
* options, run-time:                     Code Gen Options.    (line   6)
* options, runtime:                      Runtime Options.     (line   6)
* options, warnings:                     Error and Warning Options.
                                                              (line   6)
* OR:                                    OR.                  (line   6)
* output, newline:                       NEW_LINE.            (line   6)
* PACK:                                  PACK.                (line   6)
* paths, search:                         Directory Options.   (line  14)
* PERROR:                                PERROR.              (line   6)
* pointer, C address of pointers:        C_F_PROCPOINTER.     (line   6)
* pointer, C address of procedures:      C_FUNLOC.            (line   6)
* pointer, C association status:         C_ASSOCIATED.        (line   6)
* pointer, convert C to Fortran:         C_F_POINTER.         (line   6)
* pointer, cray <1>:                     MALLOC.              (line   6)
* pointer, cray:                         FREE.                (line   6)
* pointer, Cray:                         Cray pointers.       (line   6)
* pointer, disassociated:                NULL.                (line   6)
* pointer, status <1>:                   NULL.                (line   6)
* pointer, status:                       ASSOCIATED.          (line   6)
* positive difference:                   DIM.                 (line   6)
* PRECISION:                             PRECISION.           (line   6)
* Preprocessing:                         Preprocessing and conditional compilation.
                                                              (line   6)
* preprocessing, assertation:            Preprocessing Options.
                                                              (line 114)
* preprocessing, define macros:          Preprocessing Options.
                                                              (line 153)
* preprocessing, include path:           Preprocessing Options.
                                                              (line  70)
* preprocessing, keep comments:          Preprocessing Options.
                                                              (line 123)
* preprocessing, no linemarkers:         Preprocessing Options.
                                                              (line 181)
* preprocessing, undefine macros:        Preprocessing Options.
                                                              (line 187)
* preprocessor:                          Preprocessing Options.
                                                              (line   6)
* preprocessor, debugging:               Preprocessing Options.
                                                              (line  26)
* preprocessor, disable:                 Preprocessing Options.
                                                              (line  13)
* preprocessor, enable:                  Preprocessing Options.
                                                              (line  13)
* preprocessor, include file handling:   Preprocessing and conditional compilation.
                                                              (line   6)
* preprocessor, working directory:       Preprocessing Options.
                                                              (line  55)
* PRESENT:                               PRESENT.             (line   6)
* private:                               Fortran Dialect Options.
                                                              (line  71)
* procedure pointer, convert C to Fortran: C_LOC.             (line   6)
* process id:                            GETPID.              (line   6)
* PRODUCT:                               PRODUCT.             (line   6)
* product, double-precision:             DPROD.               (line   6)
* product, matrix:                       MATMUL.              (line   6)
* product, vector:                       DOT_PRODUCT.         (line   6)
* program termination:                   EXIT.                (line   6)
* program termination, with core dump:   ABORT.               (line   6)
* PROTECTED statement:                   Fortran 2003 status. (line  37)
* RADIX:                                 RADIX.               (line   6)
* RAN:                                   RAN.                 (line   6)
* RAND:                                  RAND.                (line   6)
* random number generation <1>:          RANDOM_NUMBER.       (line   6)
* random number generation <2>:          RAND.                (line   6)
* random number generation <3>:          RAN.                 (line   6)
* random number generation:              IRAND.               (line   6)
* random number generation, seeding <1>: SRAND.               (line   6)
* random number generation, seeding:     RANDOM_SEED.         (line   6)
* RANDOM_NUMBER:                         RANDOM_NUMBER.       (line   6)
* RANDOM_SEED:                           RANDOM_SEED.         (line   6)
* RANGE:                                 RANGE.               (line   6)
* range checking:                        Code Gen Options.    (line 130)
* read character, stream mode <1>:       FGETC.               (line   6)
* read character, stream mode:           FGET.                (line   6)
* REAL:                                  REAL.                (line   6)
* real kind:                             SELECTED_REAL_KIND.  (line   6)
* real number, exponent:                 EXPONENT.            (line   6)
* real number, fraction:                 FRACTION.            (line   6)
* real number, nearest different:        NEAREST.             (line   6)
* real number, relative spacing <1>:     SPACING.             (line   6)
* real number, relative spacing:         RRSPACING.           (line   6)
* real number, scale:                    SCALE.               (line   6)
* real number, set exponent:             SET_EXPONENT.        (line   6)
* REALPART:                              REAL.                (line   6)
* RECORD:                                STRUCTURE and RECORD.
                                                              (line   6)
* remainder:                             MOD.                 (line   6)
* RENAME:                                RENAME.              (line   6)
* repacking arrays:                      Code Gen Options.    (line 190)
* REPEAT:                                REPEAT.              (line   6)
* RESHAPE:                               RESHAPE.             (line   6)
* root:                                  SQRT.                (line   6)
* rounding, ceiling <1>:                 CEILING.             (line   6)
* rounding, ceiling:                     ANINT.               (line   6)
* rounding, floor <1>:                   FLOOR.               (line   6)
* rounding, floor:                       AINT.                (line   6)
* rounding, nearest whole number:        NINT.                (line   6)
* RRSPACING:                             RRSPACING.           (line   6)
* RSHIFT:                                RSHIFT.              (line   6)
* SAVE statement:                        Code Gen Options.    (line  15)
* SCALE:                                 SCALE.               (line   6)
* SCAN:                                  SCAN.                (line   6)
* search path:                           Directory Options.   (line   6)
* search paths, for included files:      Directory Options.   (line  14)
* SECNDS:                                SECNDS.              (line   6)
* SECOND:                                SECOND.              (line   6)
* seeding a random number generator <1>: SRAND.               (line   6)
* seeding a random number generator:     RANDOM_SEED.         (line   6)
* SELECTED_CHAR_KIND:                    SELECTED_CHAR_KIND.  (line   6)
* SELECTED_INT_KIND:                     SELECTED_INT_KIND.   (line   6)
* SELECTED_REAL_KIND:                    SELECTED_REAL_KIND.  (line   6)
* SET_EXPONENT:                          SET_EXPONENT.        (line   6)
* SHAPE:                                 SHAPE.               (line   6)
* SHORT:                                 INT2.                (line   6)
* SIGN:                                  SIGN.                (line   6)
* sign copying:                          SIGN.                (line   6)
* SIGNAL:                                SIGNAL.              (line   6)
* SIN:                                   SIN.                 (line   6)
* sine:                                  SIN.                 (line   6)
* sine, hyperbolic:                      SINH.                (line   6)
* sine, hyperbolic, inverse:             ASINH.               (line   6)
* sine, inverse:                         ASIN.                (line   6)
* SINH:                                  SINH.                (line   6)
* SIZE:                                  SIZE.                (line   6)
* size of a variable, in bits:           BIT_SIZE.            (line   6)
* size of an expression <1>:             SIZEOF.              (line   6)
* size of an expression:                 C_SIZEOF.            (line   6)
* SIZEOF:                                SIZEOF.              (line   6)
* SLEEP:                                 SLEEP.               (line   6)
* SNGL:                                  SNGL.                (line   6)
* SPACING:                               SPACING.             (line   6)
* SPREAD:                                SPREAD.              (line   6)
* SQRT:                                  SQRT.                (line   6)
* square-root:                           SQRT.                (line   6)
* SRAND:                                 SRAND.               (line   6)
* Standards:                             Standards.           (line   6)
* STAT:                                  STAT.                (line   6)
* statement, ENUM:                       Fortran 2003 status. (line  20)
* statement, ENUMERATOR:                 Fortran 2003 status. (line  20)
* statement, FLUSH:                      Fortran 2003 status. (line  16)
* statement, IMPORT:                     Fortran 2003 status. (line  43)
* statement, ISO_FORTRAN_ENV:            Fortran 2003 status. (line  46)
* statement, PROTECTED:                  Fortran 2003 status. (line  37)
* statement, SAVE:                       Code Gen Options.    (line  15)
* statement, USE, INTRINSIC:             Fortran 2003 status. (line  46)
* statement, VALUE:                      Fortran 2003 status. (line  39)
* statement, VOLATILE:                   Fortran 2003 status. (line  41)
* STREAM I/O:                            Fortran 2003 status. (line  32)
* stream mode, read character <1>:       FGETC.               (line   6)
* stream mode, read character:           FGET.                (line   6)
* stream mode, write character <1>:      FPUTC.               (line   6)
* stream mode, write character:          FPUT.                (line   6)
* string, adjust left:                   ADJUSTL.             (line   6)
* string, adjust right:                  ADJUSTR.             (line   6)
* string, comparison <1>:                LLT.                 (line   6)
* string, comparison <2>:                LLE.                 (line   6)
* string, comparison <3>:                LGT.                 (line   6)
* string, comparison:                    LGE.                 (line   6)
* string, concatenate:                   REPEAT.              (line   6)
* string, find missing set:              VERIFY.              (line   6)
* string, find non-blank character:      LNBLNK.              (line   6)
* string, find subset:                   SCAN.                (line   6)
* string, find substring:                INDEX intrinsic.     (line   6)
* string, length:                        LEN.                 (line   6)
* string, length, without trailing whitespace: LEN_TRIM.      (line   6)
* string, remove trailing whitespace:    TRIM.                (line   6)
* string, repeat:                        REPEAT.              (line   6)
* STRUCTURE:                             STRUCTURE and RECORD.
                                                              (line   6)
* structure packing:                     Code Gen Options.    (line 184)
* subscript checking:                    Code Gen Options.    (line 130)
* substring position:                    INDEX intrinsic.     (line   6)
* SUM:                                   SUM.                 (line   6)
* sum array elements:                    SUM.                 (line   6)
* suppressing warnings:                  Error and Warning Options.
                                                              (line   6)
* symbol names:                          Fortran Dialect Options.
                                                              (line  56)
* symbol names, transforming:            Code Gen Options.    (line  54)
* symbol names, underscores:             Code Gen Options.    (line  54)
* SYMLNK:                                SYMLNK.              (line   6)
* syntax checking:                       Error and Warning Options.
                                                              (line  33)
* SYSTEM:                                SYSTEM.              (line   6)
* system, error handling <1>:            PERROR.              (line   6)
* system, error handling <2>:            IERRNO.              (line   6)
* system, error handling:                GERROR.              (line   6)
* system, group id:                      GETGID.              (line   6)
* system, host name:                     HOSTNM.              (line   6)
* system, login name:                    GETLOG.              (line   6)
* system, process id:                    GETPID.              (line   6)
* system, signal handling:               SIGNAL.              (line   6)
* system, system call:                   SYSTEM.              (line   6)
* system, terminal <1>:                  TTYNAM.              (line   6)
* system, terminal:                      ISATTY.              (line   6)
* system, user id:                       GETUID.              (line   6)
* system, working directory <1>:         GETCWD.              (line   6)
* system, working directory:             CHDIR.               (line   6)
* SYSTEM_CLOCK:                          SYSTEM_CLOCK.        (line   6)
* tabulators:                            Error and Warning Options.
                                                              (line 140)
* TAN:                                   TAN.                 (line   6)
* tangent:                               TAN.                 (line   6)
* tangent, hyperbolic:                   TANH.                (line   6)
* tangent, hyperbolic, inverse:          ATANH.               (line   6)
* tangent, inverse <1>:                  ATAN2.               (line   6)
* tangent, inverse:                      ATAN.                (line   6)
* TANH:                                  TANH.                (line   6)
* terminate program:                     EXIT.                (line   6)
* terminate program, with core dump:     ABORT.               (line   6)
* TIME:                                  TIME.                (line   6)
* time, clock ticks <1>:                 SYSTEM_CLOCK.        (line   6)
* time, clock ticks <2>:                 MCLOCK8.             (line   6)
* time, clock ticks:                     MCLOCK.              (line   6)
* time, conversion to GMT info:          GMTIME.              (line   6)
* time, conversion to local time info:   LTIME.               (line   6)
* time, conversion to string:            CTIME.               (line   6)
* time, current <1>:                     TIME8.               (line   6)
* time, current <2>:                     TIME.                (line   6)
* time, current <3>:                     ITIME.               (line   6)
* time, current <4>:                     FDATE.               (line   6)
* time, current:                         DATE_AND_TIME.       (line   6)
* time, elapsed <1>:                     SECOND.              (line   6)
* time, elapsed <2>:                     SECNDS.              (line   6)
* time, elapsed <3>:                     ETIME.               (line   6)
* time, elapsed <4>:                     DTIME.               (line   6)
* time, elapsed:                         CPU_TIME.            (line   6)
* TIME8:                                 TIME8.               (line   6)
* TINY:                                  TINY.                (line   6)
* TR 15581:                              Fortran 2003 status. (line  25)
* trace:                                 Debugging Options.   (line  31)
* TRAILZ:                                TRAILZ.              (line   6)
* TRANSFER:                              TRANSFER.            (line   6)
* transforming symbol names:             Code Gen Options.    (line  54)
* transpose:                             TRANSPOSE.           (line   6)
* TRANSPOSE:                             TRANSPOSE.           (line   6)
* trigonometric function, cosine:        COS.                 (line   6)
* trigonometric function, cosine, inverse: ACOS.              (line   6)
* trigonometric function, sine:          SIN.                 (line   6)
* trigonometric function, sine, inverse: ASIN.                (line   6)
* trigonometric function, tangent:       TAN.                 (line   6)
* trigonometric function, tangent, inverse <1>: ATAN2.        (line   6)
* trigonometric function, tangent, inverse: ATAN.             (line   6)
* TRIM:                                  TRIM.                (line   6)
* TTYNAM:                                TTYNAM.              (line   6)
* type cast:                             TRANSFER.            (line   6)
* UBOUND:                                UBOUND.              (line   6)
* UMASK:                                 UMASK.               (line   6)
* underflow:                             Error and Warning Options.
                                                              (line 148)
* underscore:                            Code Gen Options.    (line  54)
* UNLINK:                                UNLINK.              (line   6)
* UNPACK:                                UNPACK.              (line   6)
* unused parameter:                      Error and Warning Options.
                                                              (line 158)
* USE, INTRINSIC statement:              Fortran 2003 status. (line  46)
* user id:                               GETUID.              (line   6)
* VALUE statement:                       Fortran 2003 status. (line  39)
* vector product:                        DOT_PRODUCT.         (line   6)
* VERIFY:                                VERIFY.              (line   6)
* VOLATILE statement:                    Fortran 2003 status. (line  41)
* warnings, aliasing:                    Error and Warning Options.
                                                              (line  68)
* warnings, alignment of COMMON blocks:  Error and Warning Options.
                                                              (line 165)
* warnings, all:                         Error and Warning Options.
                                                              (line  61)
* warnings, ampersand:                   Error and Warning Options.
                                                              (line  85)
* warnings, array temporaries:           Error and Warning Options.
                                                              (line  93)
* warnings, character truncation:        Error and Warning Options.
                                                              (line  98)
* warnings, conversion:                  Error and Warning Options.
                                                              (line 104)
* warnings, implicit interface:          Error and Warning Options.
                                                              (line 107)
* warnings, intrinsic:                   Error and Warning Options.
                                                              (line 152)
* warnings, intrinsics of other standards: Error and Warning Options.
                                                              (line 113)
* warnings, line truncation:             Error and Warning Options.
                                                              (line 101)
* warnings, non-standard intrinsics:     Error and Warning Options.
                                                              (line 113)
* warnings, suppressing:                 Error and Warning Options.
                                                              (line   6)
* warnings, suspicious code:             Error and Warning Options.
                                                              (line 120)
* warnings, tabs:                        Error and Warning Options.
                                                              (line 140)
* warnings, to errors:                   Error and Warning Options.
                                                              (line 171)
* warnings, underflow:                   Error and Warning Options.
                                                              (line 148)
* warnings, unused parameter:            Error and Warning Options.
                                                              (line 158)
* write character, stream mode <1>:      FPUTC.               (line   6)
* write character, stream mode:          FPUT.                (line   6)
* XOR:                                   XOR.                 (line   6)
* ZABS:                                  ABS.                 (line   6)
* ZCOS:                                  COS.                 (line   6)
* zero bits <1>:                         TRAILZ.              (line   6)
* zero bits:                             LEADZ.               (line   6)
* ZEXP:                                  EXP.                 (line   6)
* ZLOG:                                  LOG.                 (line   6)
* ZSIN:                                  SIN.                 (line   6)
* ZSQRT:                                 SQRT.                (line   6)



Tag Table:
Node: Top1990
Node: Introduction3305
Node: About GNU Fortran4052
Node: GNU Fortran and GCC8080
Node: Preprocessing and conditional compilation10192
Node: GNU Fortran and G7711833
Node: Project Status12406
Node: Standards14921
Node: Invoking GNU Fortran16132
Node: Option Summary17855
Node: Fortran Dialect Options21343
Node: Preprocessing Options28153
Node: Error and Warning Options36279
Node: Debugging Options43706
Node: Directory Options45869
Node: Link Options47384
Node: Runtime Options48008
Node: Code Gen Options50088
Node: Environment Variables62313
Node: Runtime62918
Node: GFORTRAN_STDIN_UNIT64146
Node: GFORTRAN_STDOUT_UNIT64513
Node: GFORTRAN_STDERR_UNIT64914
Node: GFORTRAN_USE_STDERR65312
Node: GFORTRAN_TMPDIR65757
Node: GFORTRAN_UNBUFFERED_ALL66198
Node: GFORTRAN_UNBUFFERED_PRECONNECTED66721
Node: GFORTRAN_SHOW_LOCUS67363
Node: GFORTRAN_OPTIONAL_PLUS67857
Node: GFORTRAN_DEFAULT_RECL68332
Node: GFORTRAN_LIST_SEPARATOR68823
Node: GFORTRAN_CONVERT_UNIT69432
Node: GFORTRAN_ERROR_DUMPCORE72294
Node: GFORTRAN_ERROR_BACKTRACE72841
Node: Fortran 2003 and 2008 status73392
Node: Fortran 2003 status73632
Node: Fortran 2008 status75323
Node: Compiler Characteristics76292
Node: KIND Type Parameters76630
Node: Extensions77557
Node: Extensions implemented in GNU Fortran78156
Node: Old-style kind specifications79490
Node: Old-style variable initialization80596
Node: Extensions to namelist81908
Node: X format descriptor without count field83904
Node: Commas in FORMAT specifications84431
Node: Missing period in FORMAT specifications84948
Node: I/O item lists85510
Node: BOZ literal constants85899
Node: Real array indices88468
Node: Unary operators88765
Node: Implicitly convert LOGICAL and INTEGER values89179
Node: Hollerith constants support90139
Node: Cray pointers91911
Node: CONVERT specifier97321
Node: OpenMP99319
Node: Argument list functions101574
Node: Extensions not implemented in GNU Fortran103168
Node: STRUCTURE and RECORD104020
Node: ENCODE and DECODE statements106076
Node: Intrinsic Procedures107394
Node: Introduction to Intrinsics121084
Node: ABORT123436
Node: ABS124193
Node: ACCESS125695
Node: ACHAR127616
Node: ACOS128817
Node: ACOSH129815
Node: ADJUSTL130692
Node: ADJUSTR131633
Node: AIMAG132580
Node: AINT133900
Node: ALARM135372
Node: ALL137006
Node: ALLOCATED138924
Node: AND139805
Node: ANINT141102
Node: ANY142465
Node: ASIN144395
Node: ASINH145407
Node: ASSOCIATED146289
Node: ATAN149294
Node: ATAN2150183
Node: ATANH151527
Node: BESSEL_J0152407
Node: BESSEL_J1153451
Node: BESSEL_JN154503
Node: BESSEL_Y0155670
Node: BESSEL_Y1156670
Node: BESSEL_YN157670
Node: BIT_SIZE158887
Node: BTEST159716
Node: C_ASSOCIATED160604
Node: C_FUNLOC161813
Node: C_F_PROCPOINTER163182
Node: C_F_POINTER164811
Node: C_LOC166229
Node: C_SIZEOF167346
Node: CEILING168699
Node: CHAR169704
Node: CHDIR170768
Node: CHMOD171936
Node: CMPLX173731
Node: COMMAND_ARGUMENT_COUNT175195
Node: COMPLEX176102
Node: CONJG177245
Node: COS178255
Node: COSH179526
Node: COUNT180495
Node: CPU_TIME182351
Node: CSHIFT183705
Node: CTIME185361
Node: DATE_AND_TIME186620
Node: DBLE189081
Node: DCMPLX189905
Node: DFLOAT191099
Node: DIGITS191793
Node: DIM192759
Node: DOT_PRODUCT193902
Node: DPROD195558
Node: DREAL196284
Node: DTIME196948
Node: EOSHIFT199754
Node: EPSILON201827
Node: ERF202553
Node: ERFC203327
Node: ERFC_SCALED204131
Node: ETIME204823
Node: EXIT207054
Node: EXP207913
Node: EXPONENT209071
Node: FDATE209821
Node: FLOAT211096
Node: FGET211810
Node: FGETC213604
Node: FLOOR215372
Node: FLUSH216356
Node: FNUM216994
Node: FPUT217716
Node: FPUTC219317
Node: FRACTION221057
Node: FREE221958
Node: FSEEK222795
Node: FSTAT225089
Node: FTELL226129
Node: GAMMA227107
Node: GERROR228148
Node: GETARG228867
Node: GET_COMMAND230631
Node: GET_COMMAND_ARGUMENT231577
Node: GETCWD233545
Node: GETENV234491
Node: GET_ENVIRONMENT_VARIABLE235713
Node: GETGID237413
Node: GETLOG237948
Node: GETPID238806
Node: GETUID239534
Node: GMTIME240048
Node: HOSTNM241537
Node: HUGE242453
Node: HYPOT243172
Node: IACHAR243992
Node: IAND245172
Node: IARGC246159
Node: IBCLR247182
Node: IBITS247843
Node: IBSET248758
Node: ICHAR249414
Node: IDATE251395
Node: IEOR252422
Node: IERRNO253298
Node: INDEX intrinsic253853
Node: INT255199
Node: INT2256786
Node: INT8257551
Node: IOR258263
Node: IRAND259113
Node: IS_IOSTAT_END260465
Node: IS_IOSTAT_EOR261560
Node: ISATTY262685
Node: ISHFT263468
Node: ISHFTC264448
Node: ISNAN265664
Node: ITIME266412
Node: KILL267437
Node: KIND268310
Node: LBOUND269155
Node: LEADZ270467
Node: LEN271271
Node: LEN_TRIM272362
Node: LGE273350
Node: LGT274663
Node: LINK275940
Node: LLE276975
Node: LLT278279
Node: LNBLNK279549
Node: LOC280325
Node: LOG281056
Node: LOG10282347
Node: LOG_GAMMA283319
Node: LOGICAL284407
Node: LONG285211
Node: LSHIFT285967
Node: LSTAT286921
Node: LTIME288075
Node: MALLOC289490
Node: MATMUL290950
Node: MAX292040
Node: MAXEXPONENT293539
Node: MAXLOC294355
Node: MAXVAL296404
Node: MCLOCK298067
Node: MCLOCK8299070
Node: MERGE300284
Node: MIN301026
Node: MINEXPONENT302522
Node: MINLOC303152
Node: MINVAL305201
Node: MOD306883
Node: MODULO308375
Node: MOVE_ALLOC309589
Node: MVBITS310613
Node: NEAREST311672
Node: NEW_LINE312795
Node: NINT313566
Node: NOT314834
Node: NULL315417
Node: OR316315
Node: PACK317593
Node: PERROR319585
Node: PRECISION320207
Node: PRESENT321033
Node: PRODUCT322139
Node: RADIX323664
Node: RAN324441
Node: RAND324897
Node: RANDOM_NUMBER326232
Node: RANDOM_SEED327950
Node: RANGE329833
Node: REAL330457
Node: RENAME331899
Node: REPEAT332918
Node: RESHAPE333644
Node: RRSPACING335113
Node: RSHIFT335806
Node: SCALE336768
Node: SCAN337542
Node: SECNDS339092
Node: SECOND340180
Node: SELECTED_CHAR_KIND341056
Node: SELECTED_INT_KIND342053
Node: SELECTED_REAL_KIND343228
Node: SET_EXPONENT345167
Node: SHAPE346163
Node: SIGN347276
Node: SIGNAL348359
Node: SIN349856
Node: SINH350898
Node: SIZE351710
Node: SIZEOF353018
Node: SLEEP354312
Node: SNGL354869
Node: SPACING355540
Node: SPREAD356552
Node: SQRT357697
Node: SRAND358936
Node: STAT360104
Node: SUM363216
Node: SYMLNK364685
Node: SYSTEM365817
Node: SYSTEM_CLOCK366765
Node: TAN368109
Node: TANH368945
Node: TIME369812
Node: TIME8370916
Node: TINY372053
Node: TRAILZ372653
Node: TRANSFER373438
Node: TRANSPOSE375472
Node: TRIM376159
Node: TTYNAM377016
Node: UBOUND377931
Node: UMASK379300
Node: UNLINK379855
Node: UNPACK380832
Node: VERIFY382120
Node: XOR383836
Node: Intrinsic Modules385144
Node: Contributing390935
Node: Contributors391787
Node: Projects393410
Node: Proposed Extensions394213
Node: Copying396264
Node: GNU Free Documentation License433828
Node: Funding456240
Node: Option Index458765
Node: Keyword Index470647

End Tag Table
