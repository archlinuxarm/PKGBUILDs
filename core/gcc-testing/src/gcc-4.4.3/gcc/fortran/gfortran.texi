\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename gfortran.info
@set copyrights-gfortran 1999-2008

@include gcc-common.texi

@settitle The GNU Fortran Compiler

@c Create a separate index for command line options
@defcodeindex op
@c Merge the standard indexes into a single one.
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex ky cp
@syncodeindex pg cp
@syncodeindex tp cp

@c TODO: The following "Part" definitions are included here temporarily
@c until they are incorporated into the official Texinfo distribution.
@c They borrow heavily from Texinfo's \unnchapentry definitions.

@tex
\gdef\part#1#2{%
  \pchapsepmacro
  \gdef\thischapter{}
  \begingroup
    \vglue\titlepagetopglue
    \titlefonts \rm
    \leftline{Part #1:@* #2}
    \vskip4pt \hrule height 4pt width \hsize \vskip4pt
  \endgroup
  \writetocentry{part}{#2}{#1}
}
\gdef\blankpart{%
  \writetocentry{blankpart}{}{}
}
% Part TOC-entry definition for summary contents.
\gdef\dosmallpartentry#1#2#3#4{%
  \vskip .5\baselineskip plus.2\baselineskip
  \begingroup
    \let\rm=\bf \rm
    \tocentry{Part #2: #1}{\doshortpageno\bgroup#4\egroup}
  \endgroup
}
\gdef\dosmallblankpartentry#1#2#3#4{%
  \vskip .5\baselineskip plus.2\baselineskip
}
% Part TOC-entry definition for regular contents.  This has to be
% equated to an existing entry to not cause problems when the PDF
% outline is created.
\gdef\dopartentry#1#2#3#4{%
  \unnchapentry{Part #2: #1}{}{#3}{#4}
}
\gdef\doblankpartentry#1#2#3#4{}
@end tex

@c %**end of header

@c Use with @@smallbook.

@c %** start of document

@c Cause even numbered pages to be printed on the left hand side of
@c the page and odd numbered pages to be printed on the right hand
@c side of the page.  Using this, you can print on both sides of a
@c sheet of paper and have the text on the same part of the sheet.

@c The text on right hand pages is pushed towards the right hand
@c margin and the text on left hand pages is pushed toward the left
@c hand margin.
@c (To provide the reverse effect, set bindingoffset to -0.75in.)

@c @tex
@c \global\bindingoffset=0.75in
@c \global\normaloffset =0.75in
@c @end tex

@copying
Copyright @copyright{} @value{copyrights-gfortran} Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.
@end copying

@ifinfo
@dircategory Software development
@direntry
* gfortran: (gfortran).                  The GNU Fortran Compiler.
@end direntry
This file documents the use and the internals of
the GNU Fortran compiler, (@command{gfortran}).

Published by the Free Software Foundation
51 Franklin Street, Fifth Floor
Boston, MA 02110-1301 USA

@insertcopying
@end ifinfo


@setchapternewpage odd
@titlepage
@title Using GNU Fortran
@versionsubtitle
@author The @t{gfortran} team
@page
@vskip 0pt plus 1filll
Published by the Free Software Foundation@*
51 Franklin Street, Fifth Floor@*
Boston, MA 02110-1301, USA@*
@c Last printed ??ber, 19??.@*
@c Printed copies are available for $? each.@*
@c ISBN ???
@sp 1
@insertcopying
@end titlepage

@c TODO: The following "Part" definitions are included here temporarily
@c until they are incorporated into the official Texinfo distribution.

@tex
\global\let\partentry=\dosmallpartentry
\global\let\blankpartentry=\dosmallblankpartentry
@end tex
@summarycontents

@tex
\global\let\partentry=\dopartentry
\global\let\blankpartentry=\doblankpartentry
@end tex
@contents

@page

@c ---------------------------------------------------------------------
@c TexInfo table of contents.
@c ---------------------------------------------------------------------

@ifnottex
@node Top
@top Introduction
@cindex Introduction

This manual documents the use of @command{gfortran}, 
the GNU Fortran compiler. You can find in this manual how to invoke
@command{gfortran}, as well as its features and incompatibilities.

@ifset DEVELOPMENT
@emph{Warning:} This document, and the compiler it describes, are still
under development.  While efforts are made to keep it up-to-date, it might
not accurately reflect the status of the most recent GNU Fortran compiler.
@end ifset

@comment
@comment  When you add a new menu item, please keep the right hand
@comment  aligned to the same column.  Do not use tabs.  This provides
@comment  better formatting.
@comment
@menu
* Introduction::

Part I: Invoking GNU Fortran
* Invoking GNU Fortran:: Command options supported by @command{gfortran}.
* Runtime::              Influencing runtime behavior with environment variables.

Part II: Language Reference
* Fortran 2003 and 2008 status::  Fortran 2003 and 2008 features supported by GNU Fortran.
* Compiler Characteristics::      KIND type parameters supported.
* Extensions::           Language extensions implemented by GNU Fortran.
* Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.
* Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.

* Contributing::         How you can help.
* Copying::              GNU General Public License says
                         how you can copy and share GNU Fortran.
* GNU Free Documentation License::
                         How you can copy and share this manual.
* Funding::              How to help assure continued work for free software.
* Option Index::         Index of command line options
* Keyword Index::        Index of concepts
@end menu
@end ifnottex

@c ---------------------------------------------------------------------
@c Introduction
@c ---------------------------------------------------------------------

@node Introduction
@chapter Introduction

@c The following duplicates the text on the TexInfo table of contents.
@iftex
This manual documents the use of @command{gfortran}, the GNU Fortran
compiler. You can find in this manual how to invoke @command{gfortran},
as well as its features and incompatibilities.

@ifset DEVELOPMENT
@emph{Warning:} This document, and the compiler it describes, are still
under development.  While efforts are made to keep it up-to-date, it
might not accurately reflect the status of the most recent GNU Fortran
compiler.
@end ifset
@end iftex

The GNU Fortran compiler front end was
designed initially as a free replacement for,
or alternative to, the unix @command{f95} command;
@command{gfortran} is the command you'll use to invoke the compiler.

@menu
* About GNU Fortran::    What you should know about the GNU Fortran compiler.
* GNU Fortran and GCC::  You can compile Fortran, C, or other programs.
* Preprocessing and conditional compilation:: The Fortran preprocessor
* GNU Fortran and G77::  Why we chose to start from scratch.
* Project Status::       Status of GNU Fortran, roadmap, proposed extensions.
* Standards::            Standards supported by GNU Fortran.
@end menu


@c ---------------------------------------------------------------------
@c About GNU Fortran
@c ---------------------------------------------------------------------

@node About GNU Fortran
@section About GNU Fortran

The GNU Fortran compiler is still in an early state of development.
It can generate code for most constructs and expressions,
but much work remains to be done.

When the GNU Fortran compiler is finished,
it will do everything you expect from any decent compiler: 

@itemize @bullet
@item
Read a user's program,
stored in a file and containing instructions written
in Fortran 77, Fortran 90, Fortran 95, Fortran 2003 or Fortran 2008.
This file contains @dfn{source code}.

@item
Translate the user's program into instructions a computer
can carry out more quickly than it takes to translate the
instructions in the first
place.  The result after compilation of a program is
@dfn{machine code},
code designed to be efficiently translated and processed
by a machine such as your computer.
Humans usually aren't as good writing machine code
as they are at writing Fortran (or C++, Ada, or Java),
because it is easy to make tiny mistakes writing machine code.

@item
Provide the user with information about the reasons why
the compiler is unable to create a binary from the source code.
Usually this will be the case if the source code is flawed.
The Fortran 90 standard requires that the compiler can point out
mistakes to the user.
An incorrect usage of the language causes an @dfn{error message}.

The compiler will also attempt to diagnose cases where the
user's program contains a correct usage of the language,
but instructs the computer to do something questionable.
This kind of diagnostics message is called a @dfn{warning message}.

@item
Provide optional information about the translation passes
from the source code to machine code.
This can help a user of the compiler to find the cause of
certain bugs which may not be obvious in the source code,
but may be more easily found at a lower level compiler output.
It also helps developers to find bugs in the compiler itself.

@item
Provide information in the generated machine code that can
make it easier to find bugs in the program (using a debugging tool,
called a @dfn{debugger}, such as the GNU Debugger @command{gdb}). 

@item
Locate and gather machine code already generated to
perform actions requested by statements in the user's program.
This machine code is organized into @dfn{modules} and is located
and @dfn{linked} to the user program. 
@end itemize

The GNU Fortran compiler consists of several components:

@itemize @bullet
@item
A version of the @command{gcc} command
(which also might be installed as the system's @command{cc} command)
that also understands and accepts Fortran source code.
The @command{gcc} command is the @dfn{driver} program for
all the languages in the GNU Compiler Collection (GCC);
With @command{gcc},
you can compile the source code of any language for
which a front end is available in GCC.

@item
The @command{gfortran} command itself,
which also might be installed as the
system's @command{f95} command.
@command{gfortran} is just another driver program,
but specifically for the Fortran compiler only.
The difference with @command{gcc} is that @command{gfortran}
will automatically link the correct libraries to your program.

@item
A collection of run-time libraries.
These libraries contain the machine code needed to support
capabilities of the Fortran language that are not directly
provided by the machine code generated by the
@command{gfortran} compilation phase,
such as intrinsic functions and subroutines,
and routines for interaction with files and the operating system.
@c and mechanisms to spawn,
@c unleash and pause threads in parallelized code.

@item
The Fortran compiler itself, (@command{f951}).
This is the GNU Fortran parser and code generator,
linked to and interfaced with the GCC backend library.
@command{f951} ``translates'' the source code to
assembler code.  You would typically not use this
program directly;
instead, the @command{gcc} or @command{gfortran} driver
programs will call it for you.
@end itemize


@c ---------------------------------------------------------------------
@c GNU Fortran and GCC
@c ---------------------------------------------------------------------

@node GNU Fortran and GCC
@section GNU Fortran and GCC
@cindex GNU Compiler Collection
@cindex GCC

GNU Fortran is a part of GCC, the @dfn{GNU Compiler Collection}.  GCC
consists of a collection of front ends for various languages, which
translate the source code into a language-independent form called
@dfn{GENERIC}.  This is then processed by a common middle end which
provides optimization, and then passed to one of a collection of back
ends which generate code for different computer architectures and
operating systems.

Functionally, this is implemented with a driver program (@command{gcc})
which provides the command-line interface for the compiler.  It calls
the relevant compiler front-end program (e.g., @command{f951} for
Fortran) for each file in the source code, and then calls the assembler
and linker as appropriate to produce the compiled output. In a copy of
GCC which has been compiled with Fortran language support enabled,
@command{gcc} will recognize files with @file{.f}, @file{.for}, @file{.ftn},
@file{.f90}, @file{.f95}, @file{.f03} and @file{.f08} extensions as
Fortran source code, and compile it accordingly. A @command{gfortran}
driver program is also provided, which is identical to @command{gcc}
except that it automatically links the Fortran runtime libraries into the
compiled program.

Source files with @file{.f}, @file{.for}, @file{.fpp}, @file{.ftn}, @file{.F},
@file{.FOR}, @file{.FPP}, and @file{.FTN} extensions are treated as fixed form.
Source files with @file{.f90}, @file{.f95}, @file{.f03}, @file{.f08},
@file{.F90}, @file{.F95}, @file{.F03} and @file{.F08} extensions are
treated as free form.  The capitalized versions of either form are run
through preprocessing. Source files with the lower case @file{.fpp}
extension are also run through preprocessing.

This manual specifically documents the Fortran front end, which handles
the programming language's syntax and semantics.  The aspects of GCC
which relate to the optimization passes and the back-end code generation
are documented in the GCC manual; see 
@ref{Top,,Introduction,gcc,Using the GNU Compiler Collection (GCC)}.
The two manuals together provide a complete reference for the GNU
Fortran compiler.


@c ---------------------------------------------------------------------
@c Preprocessing and conditional compilation
@c ---------------------------------------------------------------------

@node Preprocessing and conditional compilation
@section Preprocessing and conditional compilation
@cindex CPP
@cindex FPP
@cindex Conditional compilation
@cindex Preprocessing
@cindex preprocessor, include file handling

Many Fortran compilers including GNU Fortran allow passing the source code
through a C preprocessor (CPP; sometimes also called the Fortran preprocessor,
FPP) to allow for conditional compilation. In the case of GNU Fortran,
this is the GNU C Preprocessor in the traditional mode. On systems with
case-preserving file names, the preprocessor is automatically invoked if the
filename extension is @code{.F}, @code{.FOR}, @code{.FTN}, @code{.fpp},
@code{.FPP}, @code{.F90}, @code{.F95}, @code{.F03} or @code{.F08}. To manually
invoke the preprocessor on any file, use @option{-cpp}, to disable
preprocessing on files where the preprocessor is run automatically, use
@option{-nocpp}.

If a preprocessed file includes another file with the Fortran @code{INCLUDE}
statement, the included file is not preprocessed. To preprocess included
files, use the equivalent preprocessor statement @code{#include}.

If GNU Fortran invokes the preprocessor, @code{__GFORTRAN__}
is defined and @code{__GNUC__}, @code{__GNUC_MINOR__} and
@code{__GNUC_PATCHLEVEL__} can be used to determine the version of the
compiler. See @ref{Top,,Overview,cpp,The C Preprocessor} for details.

While CPP is the de-facto standard for preprocessing Fortran code,
Part 3 of the Fortran 95 standard (ISO/IEC 1539-3:1998) defines
Conditional Compilation, which is not widely used and not directly
supported by the GNU Fortran compiler. You can use the program coco
to preprocess such files (@uref{http://users.erols.com/dnagle/coco.html}).


@c ---------------------------------------------------------------------
@c GNU Fortran and G77
@c ---------------------------------------------------------------------

@node GNU Fortran and G77
@section GNU Fortran and G77
@cindex Fortran 77
@cindex @command{g77}

The GNU Fortran compiler is the successor to @command{g77}, the Fortran 
77 front end included in GCC prior to version 4.  It is an entirely new 
program that has been designed to provide Fortran 95 support and 
extensibility for future Fortran language standards, as well as providing 
backwards compatibility for Fortran 77 and nearly all of the GNU language 
extensions supported by @command{g77}.


@c ---------------------------------------------------------------------
@c Project Status
@c ---------------------------------------------------------------------

@node Project Status
@section Project Status

@quotation
As soon as @command{gfortran} can parse all of the statements correctly,
it will be in the ``larva'' state.
When we generate code, the ``puppa'' state.
When @command{gfortran} is done,
we'll see if it will be a beautiful butterfly,
or just a big bug....

--Andy Vaught, April 2000
@end quotation

The start of the GNU Fortran 95 project was announced on
the GCC homepage in March 18, 2000
(even though Andy had already been working on it for a while,
of course).

The GNU Fortran compiler is able to compile nearly all
standard-compliant Fortran 95, Fortran 90, and Fortran 77 programs,
including a number of standard and non-standard extensions, and can be
used on real-world programs.  In particular, the supported extensions
include OpenMP, Cray-style pointers, and several Fortran 2003 and Fortran
2008 features such as enumeration, stream I/O, and some of the
enhancements to allocatable array support from TR 15581.  However, it is
still under development and has a few remaining rough edges.

At present, the GNU Fortran compiler passes the
@uref{http://www.fortran-2000.com/ArnaudRecipes/fcvs21_f95.html, 
NIST Fortran 77 Test Suite}, and produces acceptable results on the
@uref{http://www.netlib.org/lapack/faq.html#1.21, LAPACK Test Suite}.
It also provides respectable performance on 
the @uref{http://www.polyhedron.com/pb05.html, Polyhedron Fortran
compiler benchmarks} and the
@uref{http://www.llnl.gov/asci_benchmarks/asci/limited/lfk/README.html,
Livermore Fortran Kernels test}.  It has been used to compile a number of
large real-world programs, including
@uref{http://mysite.verizon.net/serveall/moene.pdf, the HIRLAM
weather-forecasting code} and
@uref{http://www.theochem.uwa.edu.au/tonto/, the Tonto quantum 
chemistry package}; see @url{http://gcc.gnu.org/wiki/GfortranApps} for an
extended list.

Among other things, the GNU Fortran compiler is intended as a replacement
for G77.  At this point, nearly all programs that could be compiled with
G77 can be compiled with GNU Fortran, although there are a few minor known
regressions.

The primary work remaining to be done on GNU Fortran falls into three
categories: bug fixing (primarily regarding the treatment of invalid code
and providing useful error messages), improving the compiler optimizations
and the performance of compiled code, and extending the compiler to support
future standards---in particular, Fortran 2003.


@c ---------------------------------------------------------------------
@c Standards
@c ---------------------------------------------------------------------

@node Standards
@section Standards
@cindex Standards

The GNU Fortran compiler implements
ISO/IEC 1539:1997 (Fortran 95).  As such, it can also compile essentially all
standard-compliant Fortran 90 and Fortran 77 programs.   It also supports
the ISO/IEC TR-15581 enhancements to allocatable arrays, and
the @uref{http://www.openmp.org/drupal/mp-documents/spec25.pdf,
OpenMP Application Program Interface v2.5} specification.

In the future, the GNU Fortran compiler will also support ISO/IEC
1539-1:2004 (Fortran 2003) and future Fortran standards. Partial support
of that standard is already provided; the current status of Fortran 2003
support is reported in the @ref{Fortran 2003 status} section of the
documentation.

The next version of the Fortran standard after Fortran 2003 is currently
being developed and the GNU Fortran compiler supports some of its new
features. This support is based on the latest draft of the standard
(available from @url{http://www.nag.co.uk/sc22wg5/}) and no guarantee of
future compatibility is made, as the final standard might differ from the
draft. For more information, see the @ref{Fortran 2008 status} section.


@c =====================================================================
@c PART I: INVOCATION REFERENCE
@c =====================================================================

@tex
\part{I}{Invoking GNU Fortran}
@end tex

@c ---------------------------------------------------------------------
@c Compiler Options
@c ---------------------------------------------------------------------

@include invoke.texi


@c ---------------------------------------------------------------------
@c Runtime
@c ---------------------------------------------------------------------

@node Runtime
@chapter Runtime:  Influencing runtime behavior with environment variables
@cindex environment variable

The behavior of the @command{gfortran} can be influenced by
environment variables.

Malformed environment variables are silently ignored.

@menu
* GFORTRAN_STDIN_UNIT:: Unit number for standard input
* GFORTRAN_STDOUT_UNIT:: Unit number for standard output
* GFORTRAN_STDERR_UNIT:: Unit number for standard error
* GFORTRAN_USE_STDERR:: Send library output to standard error
* GFORTRAN_TMPDIR:: Directory for scratch files
* GFORTRAN_UNBUFFERED_ALL:: Don't buffer I/O for all units.
* GFORTRAN_UNBUFFERED_PRECONNECTED:: Don't buffer I/O for preconnected units.
* GFORTRAN_SHOW_LOCUS::  Show location for runtime errors
* GFORTRAN_OPTIONAL_PLUS:: Print leading + where permitted
* GFORTRAN_DEFAULT_RECL:: Default record length for new files
* GFORTRAN_LIST_SEPARATOR::  Separator for list output
* GFORTRAN_CONVERT_UNIT::  Set endianness for unformatted I/O
* GFORTRAN_ERROR_DUMPCORE:: Dump core on run-time errors
* GFORTRAN_ERROR_BACKTRACE:: Show backtrace on run-time errors
@end menu

@node GFORTRAN_STDIN_UNIT
@section @env{GFORTRAN_STDIN_UNIT}---Unit number for standard input

This environment variable can be used to select the unit number
preconnected to standard input.  This must be a positive integer.
The default value is 5.

@node GFORTRAN_STDOUT_UNIT
@section @env{GFORTRAN_STDOUT_UNIT}---Unit number for standard output

This environment variable can be used to select the unit number
preconnected to standard output.  This must be a positive integer.
The default value is 6.

@node GFORTRAN_STDERR_UNIT
@section @env{GFORTRAN_STDERR_UNIT}---Unit number for standard error

This environment variable can be used to select the unit number
preconnected to standard error.  This must be a positive integer.
The default value is 0.

@node GFORTRAN_USE_STDERR
@section @env{GFORTRAN_USE_STDERR}---Send library output to standard error

This environment variable controls where library output is sent.
If the first letter is @samp{y}, @samp{Y} or @samp{1}, standard
error is used. If the first letter is @samp{n}, @samp{N} or
@samp{0}, standard output is used.

@node GFORTRAN_TMPDIR
@section @env{GFORTRAN_TMPDIR}---Directory for scratch files

This environment variable controls where scratch files are
created.  If this environment variable is missing,
GNU Fortran searches for the environment variable @env{TMP}.  If
this is also missing, the default is @file{/tmp}.

@node GFORTRAN_UNBUFFERED_ALL
@section @env{GFORTRAN_UNBUFFERED_ALL}---Don't buffer I/O on all units

This environment variable controls whether all I/O is unbuffered.  If
the first letter is @samp{y}, @samp{Y} or @samp{1}, all I/O is
unbuffered. This will slow down small sequential reads and writes.  If
the first letter is @samp{n}, @samp{N} or @samp{0}, I/O is buffered.
This is the default.

@node GFORTRAN_UNBUFFERED_PRECONNECTED
@section @env{GFORTRAN_UNBUFFERED_PRECONNECTED}---Don't buffer I/O on preconnected units

The environment variable named @env{GFORTRAN_UNBUFFERED_PRECONNECTED} controls
whether I/O on a preconnected unit (i.e.@: STDOUT or STDERR) is unbuffered.  If 
the first letter is @samp{y}, @samp{Y} or @samp{1}, I/O is unbuffered. This
will slow down small sequential reads and writes.  If the first letter
is @samp{n}, @samp{N} or @samp{0}, I/O is buffered.  This is the default.

@node GFORTRAN_SHOW_LOCUS
@section @env{GFORTRAN_SHOW_LOCUS}---Show location for runtime errors

If the first letter is @samp{y}, @samp{Y} or @samp{1}, filename and
line numbers for runtime errors are printed.  If the first letter is
@samp{n}, @samp{N} or @samp{0}, don't print filename and line numbers
for runtime errors. The default is to print the location.

@node GFORTRAN_OPTIONAL_PLUS
@section @env{GFORTRAN_OPTIONAL_PLUS}---Print leading + where permitted

If the first letter is @samp{y}, @samp{Y} or @samp{1},
a plus sign is printed
where permitted by the Fortran standard.  If the first letter
is @samp{n}, @samp{N} or @samp{0}, a plus sign is not printed
in most cases. Default is not to print plus signs.

@node GFORTRAN_DEFAULT_RECL
@section @env{GFORTRAN_DEFAULT_RECL}---Default record length for new files

This environment variable specifies the default record length, in
bytes, for files which are opened without a @code{RECL} tag in the
@code{OPEN} statement.  This must be a positive integer.  The
default value is 1073741824 bytes (1 GB).

@node GFORTRAN_LIST_SEPARATOR
@section @env{GFORTRAN_LIST_SEPARATOR}---Separator for list output

This environment variable specifies the separator when writing
list-directed output.  It may contain any number of spaces and
at most one comma.  If you specify this on the command line,
be sure to quote spaces, as in
@smallexample
$ GFORTRAN_LIST_SEPARATOR='  ,  ' ./a.out
@end smallexample
when @command{a.out} is the compiled Fortran program that you want to run.
Default is a single space.

@node GFORTRAN_CONVERT_UNIT
@section @env{GFORTRAN_CONVERT_UNIT}---Set endianness for unformatted I/O

By setting the @env{GFORTRAN_CONVERT_UNIT} variable, it is possible
to change the representation of data for unformatted files.
The syntax for the @env{GFORTRAN_CONVERT_UNIT} variable is:
@smallexample
GFORTRAN_CONVERT_UNIT: mode | mode ';' exception | exception ;
mode: 'native' | 'swap' | 'big_endian' | 'little_endian' ;
exception: mode ':' unit_list | unit_list ;
unit_list: unit_spec | unit_list unit_spec ;
unit_spec: INTEGER | INTEGER '-' INTEGER ;
@end smallexample
The variable consists of an optional default mode, followed by
a list of optional exceptions, which are separated by semicolons
from the preceding default and each other.  Each exception consists
of a format and a comma-separated list of units.  Valid values for
the modes are the same as for the @code{CONVERT} specifier:

@itemize @w{}
@item @code{NATIVE} Use the native format.  This is the default.
@item @code{SWAP} Swap between little- and big-endian.
@item @code{LITTLE_ENDIAN} Use the little-endian format
for unformatted files.
@item @code{BIG_ENDIAN} Use the big-endian format for unformatted files.
@end itemize
A missing mode for an exception is taken to mean @code{BIG_ENDIAN}.
Examples of values for @env{GFORTRAN_CONVERT_UNIT} are:
@itemize @w{}
@item @code{'big_endian'}  Do all unformatted I/O in big_endian mode.
@item @code{'little_endian;native:10-20,25'}  Do all unformatted I/O 
in little_endian mode, except for units 10 to 20 and 25, which are in
native format.
@item @code{'10-20'}  Units 10 to 20 are big-endian, the rest is native.
@end itemize

Setting the environment variables should be done on the command
line or via the @command{export}
command for @command{sh}-compatible shells and via @command{setenv}
for @command{csh}-compatible shells.

Example for @command{sh}:
@smallexample
$ gfortran foo.f90
$ GFORTRAN_CONVERT_UNIT='big_endian;native:10-20' ./a.out
@end smallexample

Example code for @command{csh}:
@smallexample
% gfortran foo.f90
% setenv GFORTRAN_CONVERT_UNIT 'big_endian;native:10-20'
% ./a.out
@end smallexample

Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters
to you, it is best if you use this only for data that needs to be
portable.

@xref{CONVERT specifier}, for an alternative way to specify the
data representation for unformatted files.  @xref{Runtime Options}, for
setting a default data representation for the whole program.  The
@code{CONVERT} specifier overrides the @option{-fconvert} compile options.

@emph{Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the
open statement}.  This is to give control over data formats to
users who do not have the source code of their program available.

@node GFORTRAN_ERROR_DUMPCORE
@section @env{GFORTRAN_ERROR_DUMPCORE}---Dump core on run-time errors

If the @env{GFORTRAN_ERROR_DUMPCORE} variable is set to
@samp{y}, @samp{Y} or @samp{1} (only the first letter is relevant)
then library run-time errors cause core dumps. To disable the core
dumps, set the variable to @samp{n}, @samp{N}, @samp{0}. Default
is not to core dump unless the @option{-fdump-core} compile option
was used.

@node GFORTRAN_ERROR_BACKTRACE
@section @env{GFORTRAN_ERROR_BACKTRACE}---Show backtrace on run-time errors

If the @env{GFORTRAN_ERROR_BACKTRACE} variable is set to
@samp{y}, @samp{Y} or @samp{1} (only the first letter is relevant)
then a backtrace is printed when a run-time error occurs.
To disable the backtracing, set the variable to
@samp{n}, @samp{N}, @samp{0}. Default is not to print a backtrace
unless the @option{-fbacktrace} compile option
was used.

@c =====================================================================
@c PART II: LANGUAGE REFERENCE
@c =====================================================================

@tex
\part{II}{Language Reference}
@end tex

@c ---------------------------------------------------------------------
@c Fortran 2003 and 2008 Status
@c ---------------------------------------------------------------------

@node Fortran 2003 and 2008 status
@chapter Fortran 2003 and 2008 Status

@menu
* Fortran 2003 status::
* Fortran 2008 status::
@end menu

@node Fortran 2003 status
@section Fortran 2003 status

Although GNU Fortran focuses on implementing the Fortran 95
standard for the time being, a few Fortran 2003 features are currently
available.

@itemize
@item 
Intrinsics @code{command_argument_count}, @code{get_command},
@code{get_command_argument}, @code{get_environment_variable}, and
@code{move_alloc}.

@item 
@cindex array, constructors
@cindex @code{[...]}
Array constructors using square brackets. That is, @code{[...]} rather
than @code{(/.../)}.

@item
@cindex @code{FLUSH} statement
@cindex statement, @code{FLUSH}
@code{FLUSH} statement.

@item
@cindex @code{IOMSG=} specifier
@code{IOMSG=} specifier for I/O statements.

@item
@cindex @code{ENUM} statement
@cindex @code{ENUMERATOR} statement
@cindex statement, @code{ENUM}
@cindex statement, @code{ENUMERATOR}
@opindex @code{fshort-enums}
Support for the declaration of enumeration constants via the
@code{ENUM} and @code{ENUMERATOR} statements.  Interoperability with
@command{gcc} is guaranteed also for the case where the
@command{-fshort-enums} command line option is given.

@item
@cindex TR 15581
TR 15581:
@itemize
@item
@cindex @code{ALLOCATABLE} dummy arguments
@code{ALLOCATABLE} dummy arguments.
@item
@cindex @code{ALLOCATABLE} function results
@code{ALLOCATABLE} function results
@item
@cindex @code{ALLOCATABLE} components of derived types
@code{ALLOCATABLE} components of derived types
@end itemize

@item
@cindex @code{STREAM} I/O
@cindex @code{ACCESS='STREAM'} I/O
The @code{OPEN} statement supports the @code{ACCESS='STREAM'} specifier,
allowing I/O without any record structure.

@item
Namelist input/output for internal files.

@item
@cindex @code{PROTECTED} statement
@cindex statement, @code{PROTECTED}
The @code{PROTECTED} statement and attribute.

@item
@cindex @code{VALUE} statement
@cindex statement, @code{VALUE}
The @code{VALUE} statement and attribute.

@item
@cindex @code{VOLATILE} statement
@cindex statement, @code{VOLATILE}
The @code{VOLATILE} statement and attribute.

@item
@cindex @code{IMPORT} statement
@cindex statement, @code{IMPORT}
The @code{IMPORT} statement, allowing to import
host-associated derived types.

@item
@cindex @code{USE, INTRINSIC} statement
@cindex statement, @code{USE, INTRINSIC}
@cindex @code{ISO_FORTRAN_ENV} statement
@cindex statement, @code{ISO_FORTRAN_ENV}
@code{USE} statement with @code{INTRINSIC} and @code{NON_INTRINSIC}
attribute; supported intrinsic modules: @code{ISO_FORTRAN_ENV},
@code{OMP_LIB} and @code{OMP_LIB_KINDS}.

@item
Renaming of operators in the @code{USE} statement.

@item
@cindex ISO C Bindings
Interoperability with C (ISO C Bindings)

@item
BOZ as argument of INT, REAL, DBLE and CMPLX.

@end itemize


@node Fortran 2008 status
@section Fortran 2008 status

The next version of the Fortran standard after Fortran 2003 is currently
being worked on by the Working Group 5 of Sub-Committee 22 of the Joint
Technical Committee 1 of the International Organization for
Standardization (ISO) and the International Electrotechnical Commission
(IEC). This group is known at @uref{http://www.nag.co.uk/sc22wg5/, WG5}.
The next revision of the Fortran standard is informally referred to as
Fortran 2008, reflecting its planned release year. The GNU Fortran
compiler has support for some of the new features in Fortran 2008. This
support is based on the latest draft, available from
@url{http://www.nag.co.uk/sc22wg5/}. However, as the final standard may
differ from the drafts, no guarantee of backward compatibility can be
made and you should only use it for experimental purposes.


@c ---------------------------------------------------------------------
@c Compiler Characteristics
@c ---------------------------------------------------------------------

@node Compiler Characteristics
@chapter Compiler Characteristics

@c TODO: Formulate this introduction a little more generally once
@c there is more here than KIND type parameters.

This chapter describes certain characteristics of the GNU Fortran compiler,
namely the KIND type parameter values supported.

@menu
* KIND Type Parameters::
@end menu


@node KIND Type Parameters
@section KIND Type Parameters
@cindex kind

The @code{KIND} type parameters supported by GNU Fortran for the primitive
data types are:

@table @code

@item INTEGER
1, 2, 4, 8*, 16*, default: 4 (1)

@item LOGICAL
1, 2, 4, 8*, 16*, default: 4 (1)

@item REAL
4, 8, 10**, 16**, default: 4 (2)

@item COMPLEX
4, 8, 10**, 16**, default: 4 (2)

@item CHARACTER
1, 4, default: 1

@end table

@noindent
* = not available on all systems @*
** = not available on all systems; additionally 10 and 16 are never
available at the same time @*
(1) Unless -fdefault-integer-8 is used @*
(2) Unless -fdefault-real-8 is used

@noindent
The @code{KIND} value matches the storage size in bytes, except for
@code{COMPLEX} where the storage size is twice as much (or both real and
imaginary part are a real value of the given size).  It is recommended to use
the @code{SELECT_*_KIND} intrinsics instead of the concrete values.


@c ---------------------------------------------------------------------
@c Extensions
@c ---------------------------------------------------------------------

@c Maybe this chapter should be merged with the 'Standards' section,
@c whenever that is written :-)

@node Extensions
@chapter Extensions
@cindex extensions

The two sections below detail the extensions to standard Fortran that are
implemented in GNU Fortran, as well as some of the popular or
historically important extensions that are not (or not yet) implemented.
For the latter case, we explain the alternatives available to GNU Fortran
users, including replacement by standard-conforming code or GNU
extensions.

@menu
* Extensions implemented in GNU Fortran::
* Extensions not implemented in GNU Fortran::
@end menu


@node Extensions implemented in GNU Fortran
@section Extensions implemented in GNU Fortran
@cindex extensions, implemented

GNU Fortran implements a number of extensions over standard
Fortran. This chapter contains information on their syntax and
meaning.  There are currently two categories of GNU Fortran
extensions, those that provide functionality beyond that provided
by any standard, and those that are supported by GNU Fortran
purely for backward compatibility with legacy compilers.  By default,
@option{-std=gnu} allows the compiler to accept both types of
extensions, but to warn about the use of the latter.  Specifying
either @option{-std=f95}, @option{-std=f2003} or @option{-std=f2008}
disables both types of extensions, and @option{-std=legacy} allows both
without warning.

@menu
* Old-style kind specifications::
* Old-style variable initialization::
* Extensions to namelist::
* X format descriptor without count field::
* Commas in FORMAT specifications::
* Missing period in FORMAT specifications::
* I/O item lists::
* BOZ literal constants::
* Real array indices::
* Unary operators::
* Implicitly convert LOGICAL and INTEGER values::
* Hollerith constants support::
* Cray pointers::
* CONVERT specifier::
* OpenMP::
* Argument list functions::
@end menu

@node Old-style kind specifications
@subsection Old-style kind specifications
@cindex kind, old-style

GNU Fortran allows old-style kind specifications in declarations. These
look like:
@smallexample
      TYPESPEC*size x,y,z
@end smallexample
@noindent
where @code{TYPESPEC} is a basic type (@code{INTEGER}, @code{REAL},
etc.), and where @code{size} is a byte count corresponding to the
storage size of a valid kind for that type.  (For @code{COMPLEX}
variables, @code{size} is the total size of the real and imaginary
parts.)  The statement then declares @code{x}, @code{y} and @code{z} to
be of type @code{TYPESPEC} with the appropriate kind.  This is
equivalent to the standard-conforming declaration
@smallexample
      TYPESPEC(k) x,y,z
@end smallexample
@noindent
where @code{k} is the kind parameter suitable for the intended precision.  As
kind parameters are implementation-dependent, use the @code{KIND},
@code{SELECTED_INT_KIND} and @code{SELECTED_REAL_KIND} intrinsics to retrieve
the correct value, for instance @code{REAL*8 x} can be replaced by:
@smallexample
INTEGER, PARAMETER :: dbl = KIND(1.0d0)
REAL(KIND=dbl) :: x
@end smallexample

@node Old-style variable initialization
@subsection Old-style variable initialization

GNU Fortran allows old-style initialization of variables of the
form:
@smallexample
      INTEGER i/1/,j/2/
      REAL x(2,2) /3*0.,1./
@end smallexample
The syntax for the initializers is as for the @code{DATA} statement, but
unlike in a @code{DATA} statement, an initializer only applies to the
variable immediately preceding the initialization.  In other words,
something like @code{INTEGER I,J/2,3/} is not valid.  This style of
initialization is only allowed in declarations without double colons
(@code{::}); the double colons were introduced in Fortran 90, which also
introduced a standard syntax for initializing variables in type
declarations.

Examples of standard-conforming code equivalent to the above example
are:
@smallexample
! Fortran 90
      INTEGER :: i = 1, j = 2
      REAL :: x(2,2) = RESHAPE((/0.,0.,0.,1./),SHAPE(x))
! Fortran 77
      INTEGER i, j
      REAL x(2,2)
      DATA i/1/, j/2/, x/3*0.,1./
@end smallexample

Note that variables which are explicitly initialized in declarations
or in @code{DATA} statements automatically acquire the @code{SAVE}
attribute.

@node Extensions to namelist
@subsection Extensions to namelist
@cindex Namelist

GNU Fortran fully supports the Fortran 95 standard for namelist I/O
including array qualifiers, substrings and fully qualified derived types.
The output from a namelist write is compatible with namelist read.  The
output has all names in upper case and indentation to column 1 after the
namelist name.  Two extensions are permitted:

Old-style use of @samp{$} instead of @samp{&}
@smallexample
$MYNML
 X(:)%Y(2) = 1.0 2.0 3.0
 CH(1:4) = "abcd"
$END
@end smallexample

It should be noted that the default terminator is @samp{/} rather than
@samp{&END}.

Querying of the namelist when inputting from stdin. After at least
one space, entering @samp{?} sends to stdout the namelist name and the names of
the variables in the namelist:
@smallexample
 ?

&mynml
 x
 x%y
 ch
&end
@end smallexample

Entering @samp{=?} outputs the namelist to stdout, as if
@code{WRITE(*,NML = mynml)} had been called:
@smallexample
=?

&MYNML
 X(1)%Y=  0.000000    ,  1.000000    ,  0.000000    ,
 X(2)%Y=  0.000000    ,  2.000000    ,  0.000000    ,
 X(3)%Y=  0.000000    ,  3.000000    ,  0.000000    ,
 CH=abcd,  /
@end smallexample

To aid this dialog, when input is from stdin, errors send their
messages to stderr and execution continues, even if @code{IOSTAT} is set.

@code{PRINT} namelist is permitted.  This causes an error if
@option{-std=f95} is used.
@smallexample
PROGRAM test_print
  REAL, dimension (4)  ::  x = (/1.0, 2.0, 3.0, 4.0/)
  NAMELIST /mynml/ x
  PRINT mynml
END PROGRAM test_print
@end smallexample

Expanded namelist reads are permitted.  This causes an error if 
@option{-std=f95} is used.  In the following example, the first element
of the array will be given the value 0.00 and the two succeeding
elements will be given the values 1.00 and 2.00.
@smallexample
&MYNML
  X(1,1) = 0.00 , 1.00 , 2.00
/
@end smallexample

@node X format descriptor without count field
@subsection @code{X} format descriptor without count field

To support legacy codes, GNU Fortran permits the count field of the
@code{X} edit descriptor in @code{FORMAT} statements to be omitted.
When omitted, the count is implicitly assumed to be one.

@smallexample
       PRINT 10, 2, 3
10     FORMAT (I1, X, I1)
@end smallexample

@node Commas in FORMAT specifications
@subsection Commas in @code{FORMAT} specifications

To support legacy codes, GNU Fortran allows the comma separator
to be omitted immediately before and after character string edit
descriptors in @code{FORMAT} statements.

@smallexample
       PRINT 10, 2, 3
10     FORMAT ('FOO='I1' BAR='I2)
@end smallexample


@node Missing period in FORMAT specifications
@subsection Missing period in @code{FORMAT} specifications

To support legacy codes, GNU Fortran allows missing periods in format
specifications if and only if @option{-std=legacy} is given on the
command line.  This is considered non-conforming code and is
discouraged.

@smallexample
       REAL :: value
       READ(*,10) value
10     FORMAT ('F4')
@end smallexample

@node I/O item lists
@subsection I/O item lists
@cindex I/O item lists

To support legacy codes, GNU Fortran allows the input item list
of the @code{READ} statement, and the output item lists of the
@code{WRITE} and @code{PRINT} statements, to start with a comma.

@node BOZ literal constants
@subsection BOZ literal constants
@cindex BOZ literal constants

Besides decimal constants, Fortran also supports binary (@code{b}),
octal (@code{o}) and hexadecimal (@code{z}) integer constants. The
syntax is: @samp{prefix quote digits quote}, were the prefix is
either @code{b}, @code{o} or @code{z}, quote is either @code{'} or
@code{"} and the digits are for binary @code{0} or @code{1}, for
octal between @code{0} and @code{7}, and for hexadecimal between
@code{0} and @code{F}. (Example: @code{b'01011101'}.)

Up to Fortran 95, BOZ literals were only allowed to initialize
integer variables in DATA statements. Since Fortran 2003 BOZ literals
are also allowed as argument of @code{REAL}, @code{DBLE}, @code{INT}
and @code{CMPLX}; the result is the same as if the integer BOZ
literal had been converted by @code{TRANSFER} to, respectively,
@code{real}, @code{double precision}, @code{integer} or @code{complex}.
As GNU Fortran extension the intrinsic procedures @code{FLOAT},
@code{DFLOAT}, @code{COMPLEX} and @code{DCMPLX} are treated alike.

As an extension, GNU Fortran allows hexadecimal BOZ literal constants to
be specified using the @code{X} prefix, in addition to the standard
@code{Z} prefix. The BOZ literal can also be specified by adding a
suffix to the string, for example, @code{Z'ABC'} and @code{'ABC'Z} are
equivalent.

Furthermore, GNU Fortran allows using BOZ literal constants outside
DATA statements and the four intrinsic functions allowed by Fortran 2003.
In DATA statements, in direct assignments, where the right-hand side
only contains a BOZ literal constant, and for old-style initializers of
the form @code{integer i /o'0173'/}, the constant is transferred
as if @code{TRANSFER} had been used; for @code{COMPLEX} numbers, only
the real part is initialized unless @code{CMPLX} is used. In all other
cases, the BOZ literal constant is converted to an @code{INTEGER} value with
the largest decimal representation.  This value is then converted
numerically to the type and kind of the variable in question.
(For instance @code{real :: r = b'0000001' + 1} initializes @code{r}
with @code{2.0}.) As different compilers implement the extension
differently, one should be careful when doing bitwise initialization
of non-integer variables.

Note that initializing an @code{INTEGER} variable with a statement such
as @code{DATA i/Z'FFFFFFFF'/} will give an integer overflow error rather
than the desired result of @math{-1} when @code{i} is a 32-bit integer
on a system that supports 64-bit integers.  The @samp{-fno-range-check}
option can be used as a workaround for legacy code that initializes
integers in this manner.

@node Real array indices
@subsection Real array indices
@cindex array, indices of type real

As an extension, GNU Fortran allows the use of @code{REAL} expressions
or variables as array indices.

@node Unary operators
@subsection Unary operators
@cindex operators, unary

As an extension, GNU Fortran allows unary plus and unary minus operators
to appear as the second operand of binary arithmetic operators without
the need for parenthesis.

@smallexample
       X = Y * -Z
@end smallexample

@node Implicitly convert LOGICAL and INTEGER values
@subsection Implicitly convert @code{LOGICAL} and @code{INTEGER} values
@cindex conversion, to integer
@cindex conversion, to logical

As an extension for backwards compatibility with other compilers, GNU
Fortran allows the implicit conversion of @code{LOGICAL} values to
@code{INTEGER} values and vice versa.  When converting from a
@code{LOGICAL} to an @code{INTEGER}, @code{.FALSE.} is interpreted as
zero, and @code{.TRUE.} is interpreted as one.  When converting from
@code{INTEGER} to @code{LOGICAL}, the value zero is interpreted as
@code{.FALSE.} and any nonzero value is interpreted as @code{.TRUE.}.

@smallexample
        LOGICAL :: l
        l = 1
@end smallexample
@smallexample
        INTEGER :: i
        i = .TRUE.
@end smallexample

However, there is no implicit conversion of @code{INTEGER} values in
@code{if}-statements, nor of @code{LOGICAL} or @code{INTEGER} values
in I/O operations.

@node Hollerith constants support
@subsection Hollerith constants support
@cindex Hollerith constants

GNU Fortran supports Hollerith constants in assignments, function
arguments, and @code{DATA} and @code{ASSIGN} statements.  A Hollerith
constant is written as a string of characters preceded by an integer
constant indicating the character count, and the letter @code{H} or
@code{h}, and stored in bytewise fashion in a numeric (@code{INTEGER},
@code{REAL}, or @code{complex}) or @code{LOGICAL} variable.  The
constant will be padded or truncated to fit the size of the variable in
which it is stored.

Examples of valid uses of Hollerith constants:
@smallexample
      complex*16 x(2)
      data x /16Habcdefghijklmnop, 16Hqrstuvwxyz012345/
      x(1) = 16HABCDEFGHIJKLMNOP
      call foo (4h abc)
@end smallexample

Invalid Hollerith constants examples:
@smallexample
      integer*4 a
      a = 8H12345678 ! Valid, but the Hollerith constant will be truncated.
      a = 0H         ! At least one character is needed.
@end smallexample

In general, Hollerith constants were used to provide a rudimentary
facility for handling character strings in early Fortran compilers,
prior to the introduction of @code{CHARACTER} variables in Fortran 77;
in those cases, the standard-compliant equivalent is to convert the
program to use proper character strings.  On occasion, there may be a
case where the intent is specifically to initialize a numeric variable
with a given byte sequence.  In these cases, the same result can be
obtained by using the @code{TRANSFER} statement, as in this example.
@smallexample
      INTEGER(KIND=4) :: a
      a = TRANSFER ("abcd", a)     ! equivalent to: a = 4Habcd
@end smallexample


@node Cray pointers
@subsection Cray pointers
@cindex pointer, Cray

Cray pointers are part of a non-standard extension that provides a
C-like pointer in Fortran.  This is accomplished through a pair of
variables: an integer "pointer" that holds a memory address, and a
"pointee" that is used to dereference the pointer.

Pointer/pointee pairs are declared in statements of the form:
@smallexample
        pointer ( <pointer> , <pointee> )
@end smallexample
or,
@smallexample
        pointer ( <pointer1> , <pointee1> ), ( <pointer2> , <pointee2> ), ...
@end smallexample
The pointer is an integer that is intended to hold a memory address.
The pointee may be an array or scalar.  A pointee can be an assumed
size array---that is, the last dimension may be left unspecified by
using a @code{*} in place of a value---but a pointee cannot be an
assumed shape array.  No space is allocated for the pointee.

The pointee may have its type declared before or after the pointer
statement, and its array specification (if any) may be declared
before, during, or after the pointer statement.  The pointer may be
declared as an integer prior to the pointer statement.  However, some
machines have default integer sizes that are different than the size
of a pointer, and so the following code is not portable:
@smallexample
        integer ipt
        pointer (ipt, iarr)
@end smallexample
If a pointer is declared with a kind that is too small, the compiler
will issue a warning; the resulting binary will probably not work
correctly, because the memory addresses stored in the pointers may be
truncated.  It is safer to omit the first line of the above example;
if explicit declaration of ipt's type is omitted, then the compiler
will ensure that ipt is an integer variable large enough to hold a
pointer.

Pointer arithmetic is valid with Cray pointers, but it is not the same
as C pointer arithmetic.  Cray pointers are just ordinary integers, so
the user is responsible for determining how many bytes to add to a
pointer in order to increment it.  Consider the following example:
@smallexample
        real target(10)
        real pointee(10)
        pointer (ipt, pointee)
        ipt = loc (target)
        ipt = ipt + 1       
@end smallexample
The last statement does not set @code{ipt} to the address of
@code{target(1)}, as it would in C pointer arithmetic.  Adding @code{1}
to @code{ipt} just adds one byte to the address stored in @code{ipt}.

Any expression involving the pointee will be translated to use the
value stored in the pointer as the base address.

To get the address of elements, this extension provides an intrinsic
function @code{LOC()}.  The @code{LOC()} function is equivalent to the
@code{&} operator in C, except the address is cast to an integer type:
@smallexample
        real ar(10)
        pointer(ipt, arpte(10))
        real arpte
        ipt = loc(ar)  ! Makes arpte is an alias for ar
        arpte(1) = 1.0 ! Sets ar(1) to 1.0
@end smallexample
The pointer can also be set by a call to the @code{MALLOC} intrinsic
(see @ref{MALLOC}).

Cray pointees often are used to alias an existing variable.  For
example:
@smallexample
        integer target(10)
        integer iarr(10)
        pointer (ipt, iarr)
        ipt = loc(target)
@end smallexample
As long as @code{ipt} remains unchanged, @code{iarr} is now an alias for
@code{target}. The optimizer, however, will not detect this aliasing, so
it is unsafe to use @code{iarr} and @code{target} simultaneously.  Using
a pointee in any way that violates the Fortran aliasing rules or
assumptions is illegal. It is the user's responsibility to avoid doing
this; the compiler works under the assumption that no such aliasing
occurs.

Cray pointers will work correctly when there is no aliasing (i.e., when
they are used to access a dynamically allocated block of memory), and
also in any routine where a pointee is used, but any variable with which
it shares storage is not used.  Code that violates these rules may not
run as the user intends.  This is not a bug in the optimizer; any code
that violates the aliasing rules is illegal.  (Note that this is not
unique to GNU Fortran; any Fortran compiler that supports Cray pointers
will ``incorrectly'' optimize code with illegal aliasing.)

There are a number of restrictions on the attributes that can be applied
to Cray pointers and pointees.  Pointees may not have the
@code{ALLOCATABLE}, @code{INTENT}, @code{OPTIONAL}, @code{DUMMY},
@code{TARGET}, @code{INTRINSIC}, or @code{POINTER} attributes. Pointers
may not have the @code{DIMENSION}, @code{POINTER}, @code{TARGET},
@code{ALLOCATABLE}, @code{EXTERNAL}, or @code{INTRINSIC} attributes.
Pointees may not occur in more than one pointer statement.  A pointee
cannot be a pointer.  Pointees cannot occur in equivalence, common, or
data statements.

A Cray pointer may also point to a function or a subroutine.  For
example, the following excerpt is valid:
@smallexample
  implicit none
  external sub
  pointer (subptr,subpte)
  external subpte
  subptr = loc(sub)
  call subpte()
  [...]
  subroutine sub
  [...]
  end subroutine sub
@end smallexample

A pointer may be modified during the course of a program, and this
will change the location to which the pointee refers.  However, when
pointees are passed as arguments, they are treated as ordinary
variables in the invoked function.  Subsequent changes to the pointer
will not change the base address of the array that was passed.

@node CONVERT specifier
@subsection @code{CONVERT} specifier
@cindex @code{CONVERT} specifier

GNU Fortran allows the conversion of unformatted data between little-
and big-endian representation to facilitate moving of data
between different systems.  The conversion can be indicated with
the @code{CONVERT} specifier on the @code{OPEN} statement.
@xref{GFORTRAN_CONVERT_UNIT}, for an alternative way of specifying
the data format via an environment variable.

Valid values for @code{CONVERT} are:
@itemize @w{}
@item @code{CONVERT='NATIVE'} Use the native format.  This is the default.
@item @code{CONVERT='SWAP'} Swap between little- and big-endian.
@item @code{CONVERT='LITTLE_ENDIAN'} Use the little-endian representation
for unformatted files.
@item @code{CONVERT='BIG_ENDIAN'} Use the big-endian representation for
unformatted files.
@end itemize

Using the option could look like this:
@smallexample
  open(file='big.dat',form='unformatted',access='sequential', &
       convert='big_endian')
@end smallexample

The value of the conversion can be queried by using
@code{INQUIRE(CONVERT=ch)}.  The values returned are
@code{'BIG_ENDIAN'} and @code{'LITTLE_ENDIAN'}.

@code{CONVERT} works between big- and little-endian for
@code{INTEGER} values of all supported kinds and for @code{REAL}
on IEEE systems of kinds 4 and 8.  Conversion between different
``extended double'' types on different architectures such as
m68k and x86_64, which GNU Fortran
supports as @code{REAL(KIND=10)} and @code{REAL(KIND=16)}, will
probably not work.

@emph{Note that the values specified via the GFORTRAN_CONVERT_UNIT
environment variable will override the CONVERT specifier in the
open statement}.  This is to give control over data formats to
users who do not have the source code of their program available.

Using anything but the native representation for unformatted data
carries a significant speed overhead.  If speed in this area matters
to you, it is best if you use this only for data that needs to be
portable.

@node OpenMP
@subsection OpenMP
@cindex OpenMP

OpenMP (Open Multi-Processing) is an application programming
interface (API) that supports multi-platform shared memory 
multiprocessing programming in C/C++ and Fortran on many 
architectures, including Unix and Microsoft Windows platforms.
It consists of a set of compiler directives, library routines,
and environment variables that influence run-time behavior.

GNU Fortran strives to be compatible to the 
@uref{http://www.openmp.org/drupal/mp-documents/spec25.pdf,
OpenMP Application Program Interface v2.5}.

To enable the processing of the OpenMP directive @code{!$omp} in
free-form source code; the @code{c$omp}, @code{*$omp} and @code{!$omp}
directives in fixed form; the @code{!$} conditional compilation sentinels
in free form; and the @code{c$}, @code{*$} and @code{!$} sentinels
in fixed form, @command{gfortran} needs to be invoked with the
@option{-fopenmp}. This also arranges for automatic linking of the
GNU OpenMP runtime library @ref{Top,,libgomp,libgomp,GNU OpenMP
runtime library}.

The OpenMP Fortran runtime library routines are provided both in a
form of a Fortran 90 module named @code{omp_lib} and in a form of
a Fortran @code{include} file named @file{omp_lib.h}.

An example of a parallelized loop taken from Appendix A.1 of
the OpenMP Application Program Interface v2.5:
@smallexample
SUBROUTINE A1(N, A, B)
  INTEGER I, N
  REAL B(N), A(N)
!$OMP PARALLEL DO !I is private by default
  DO I=2,N
    B(I) = (A(I) + A(I-1)) / 2.0
  ENDDO
!$OMP END PARALLEL DO
END SUBROUTINE A1
@end smallexample

Please note:
@itemize
@item
@option{-fopenmp} implies @option{-frecursive}, i.e., all local arrays
will be allocated on the stack. When porting existing code to OpenMP,
this may lead to surprising results, especially to segmentation faults
if the stacksize is limited.

@item
On glibc-based systems, OpenMP enabled applications can not be statically
linked due to limitations of the underlying pthreads-implementation. It
might be possible to get a working solution if 
@command{-Wl,--whole-archive -lpthread -Wl,--no-whole-archive} is added
to the command line. However, this is not supported by @command{gcc} and
thus not recommended.
@end itemize

@node Argument list functions
@subsection Argument list functions @code{%VAL}, @code{%REF} and @code{%LOC}
@cindex argument list functions
@cindex @code{%VAL}
@cindex @code{%REF}
@cindex @code{%LOC}

GNU Fortran supports argument list functions @code{%VAL}, @code{%REF} 
and @code{%LOC} statements, for backward compatibility with g77. 
It is recommended that these should be used only for code that is 
accessing facilities outside of GNU Fortran, such as operating system 
or windowing facilities. It is best to constrain such uses to isolated 
portions of a program--portions that deal specifically and exclusively 
with low-level, system-dependent facilities. Such portions might well 
provide a portable interface for use by the program as a whole, but are 
themselves not portable, and should be thoroughly tested each time they 
are rebuilt using a new compiler or version of a compiler.

@code{%VAL} passes a scalar argument by value, @code{%REF} passes it by 
reference and @code{%LOC} passes its memory location.  Since gfortran 
already passes scalar arguments by reference, @code{%REF} is in effect 
a do-nothing.  @code{%LOC} has the same effect as a fortran pointer.

An example of passing an argument by value to a C subroutine foo.:
@smallexample
C
C prototype      void foo_ (float x);
C
      external foo
      real*4 x
      x = 3.14159
      call foo (%VAL (x))
      end
@end smallexample

For details refer to the g77 manual
@uref{http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/index.html#Top}.

Also, the gfortran testsuite c_by_val.f and its partner c_by_val.c are
worth a look.



@node Extensions not implemented in GNU Fortran
@section Extensions not implemented in GNU Fortran
@cindex extensions, not implemented

The long history of the Fortran language, its wide use and broad
userbase, the large number of different compiler vendors and the lack of
some features crucial to users in the first standards have lead to the
existence of a number of important extensions to the language.  While
some of the most useful or popular extensions are supported by the GNU
Fortran compiler, not all existing extensions are supported.  This section
aims at listing these extensions and offering advice on how best make
code that uses them running with the GNU Fortran compiler.

@c More can be found here:
@c   -- http://gcc.gnu.org/onlinedocs/gcc-3.4.6/g77/Missing-Features.html
@c   -- the list of fortran and libgfortran bugs closed as WONTFIX:
@c      http://tinyurl.com/2u4h5y

@menu
* STRUCTURE and RECORD::
@c * UNION and MAP::
* ENCODE and DECODE statements::
@c * Expressions in FORMAT statements::
@c * Q edit descriptor::
@c * AUTOMATIC statement::
@c * TYPE and ACCEPT I/O Statements::
@c * .XOR. operator::
@c * CARRIAGECONTROL, DEFAULTFILE, DISPOSE and RECORDTYPE I/O specifiers::
@c * Omitted arguments in procedure call:
@end menu


@node STRUCTURE and RECORD
@subsection @code{STRUCTURE} and @code{RECORD}
@cindex @code{STRUCTURE}
@cindex @code{RECORD}

Structures are user-defined aggregate data types; this functionality was
standardized in Fortran 90 with an different syntax, under the name of
``derived types''. Here is an example of code using the non portable
structure syntax:

@example
! Declaring a structure named ``item'' and containing three fields:
! an integer ID, an description string and a floating-point price.
STRUCTURE /item/
  INTEGER id
  CHARACTER(LEN=200) description
  REAL price
END STRUCTURE

! Define two variables, an single record of type ``item''
! named ``pear'', and an array of items named ``store_catalog''
RECORD /item/ pear, store_catalog(100)

! We can directly access the fields of both variables
pear.id = 92316
pear.description = "juicy D'Anjou pear"
pear.price = 0.15
store_catalog(7).id = 7831
store_catalog(7).description = "milk bottle"
store_catalog(7).price = 1.2

! We can also manipulate the whole structure
store_catalog(12) = pear
print *, store_catalog(12)
@end example

@noindent
This code can easily be rewritten in the Fortran 90 syntax as following:

@example
! ``STRUCTURE /name/ ... END STRUCTURE'' becomes
! ``TYPE name ... END TYPE''
TYPE item
  INTEGER id
  CHARACTER(LEN=200) description
  REAL price
END TYPE

! ``RECORD /name/ variable'' becomes ``TYPE(name) variable''
TYPE(item) pear, store_catalog(100)

! Instead of using a dot (.) to access fields of a record, the
! standard syntax uses a percent sign (%)
pear%id = 92316
pear%description = "juicy D'Anjou pear"
pear%price = 0.15
store_catalog(7)%id = 7831
store_catalog(7)%description = "milk bottle"
store_catalog(7)%price = 1.2

! Assignments of a whole variable don't change
store_catalog(12) = pear
print *, store_catalog(12)
@end example


@c @node UNION and MAP
@c @subsection @code{UNION} and @code{MAP}
@c @cindex @code{UNION}
@c @cindex @code{MAP}
@c
@c For help writing this one, see
@c http://www.eng.umd.edu/~nsw/ench250/fortran1.htm#UNION and
@c http://www.tacc.utexas.edu/services/userguides/pgi/pgiws_ug/pgi32u06.htm


@node ENCODE and DECODE statements
@subsection @code{ENCODE} and @code{DECODE} statements
@cindex @code{ENCODE}
@cindex @code{DECODE}

GNU Fortran doesn't support the @code{ENCODE} and @code{DECODE}
statements.  These statements are best replaced by @code{READ} and
@code{WRITE} statements involving internal files (@code{CHARACTER}
variables and arrays), which have been part of the Fortran standard since
Fortran 77. For example, replace a code fragment like

@smallexample
      INTEGER*1 LINE(80)
      REAL A, B, C
c     ... Code that sets LINE
      DECODE (80, 9000, LINE) A, B, C
 9000 FORMAT (1X, 3(F10.5))
@end smallexample

@noindent
with the following:

@smallexample
      CHARACTER(LEN=80) LINE
      REAL A, B, C
c     ... Code that sets LINE
      READ (UNIT=LINE, FMT=9000) A, B, C
 9000 FORMAT (1X, 3(F10.5))
@end smallexample

Similarly, replace a code fragment like

@smallexample
      INTEGER*1 LINE(80)
      REAL A, B, C
c     ... Code that sets A, B and C
      ENCODE (80, 9000, LINE) A, B, C
 9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))
@end smallexample

@noindent
with the following:

@smallexample
      INTEGER*1 LINE(80)
      REAL A, B, C
c     ... Code that sets A, B and C
      WRITE (UNIT=LINE, FMT=9000) A, B, C
 9000 FORMAT (1X, 'OUTPUT IS ', 3(F10.5))
@end smallexample


@c ---------------------------------------------------------------------
@c Intrinsic Procedures
@c ---------------------------------------------------------------------

@include intrinsic.texi


@tex
\blankpart
@end tex

@c ---------------------------------------------------------------------
@c Contributing
@c ---------------------------------------------------------------------

@node Contributing
@unnumbered Contributing
@cindex Contributing

Free software is only possible if people contribute to efforts
to create it.
We're always in need of more people helping out with ideas
and comments, writing documentation and contributing code.

If you want to contribute to GNU Fortran,
have a look at the long lists of projects you can take on.
Some of these projects are small,
some of them are large;
some are completely orthogonal to the rest of what is
happening on GNU Fortran,
but others are ``mainstream'' projects in need of enthusiastic hackers.
All of these projects are important!
We'll eventually get around to the things here,
but they are also things doable by someone who is willing and able.

@menu
* Contributors::
* Projects::
* Proposed Extensions::
@end menu


@node Contributors
@section Contributors to GNU Fortran
@cindex Contributors
@cindex Credits
@cindex Authors

Most of the parser was hand-crafted by @emph{Andy Vaught}, who is
also the initiator of the whole project.  Thanks Andy!
Most of the interface with GCC was written by @emph{Paul Brook}.

The following individuals have contributed code and/or
ideas and significant help to the GNU Fortran project
(in alphabetical order):

@itemize @minus
@item Janne Blomqvist
@item Steven Bosscher
@item Paul Brook
@item Tobias Burnus
@item Fran@,{c}ois-Xavier Coudert
@item Bud Davis
@item Jerry DeLisle
@item Erik Edelmann
@item Bernhard Fischer
@item Daniel Franke
@item Richard Guenther
@item Richard Henderson
@item Katherine Holcomb
@item Jakub Jelinek
@item Niels Kristian Bech Jensen
@item Steven Johnson
@item Steven G. Kargl
@item Thomas Koenig
@item Asher Langton
@item H. J. Lu
@item Toon Moene
@item Brooks Moses
@item Andrew Pinski
@item Tim Prince
@item Christopher D. Rickett
@item Richard Sandiford
@item Tobias Schl@"uter
@item Roger Sayle
@item Paul Thomas
@item Andy Vaught
@item Feng Wang
@item Janus Weil
@end itemize

The following people have contributed bug reports,
smaller or larger patches,
and much needed feedback and encouragement for the
GNU Fortran project: 

@itemize @minus
@item Bill Clodius
@item Dominique d'Humi@`eres
@item Kate Hedstrom
@item Erik Schnetter
@end itemize

Many other individuals have helped debug,
test and improve the GNU Fortran compiler over the past few years,
and we welcome you to do the same!
If you already have done so,
and you would like to see your name listed in the
list above, please contact us.


@node Projects
@section Projects

@table @emph

@item Help build the test suite
Solicit more code for donation to the test suite: the more extensive the
testsuite, the smaller the risk of breaking things in the future! We can
keep code private on request.

@item Bug hunting/squishing
Find bugs and write more test cases! Test cases are especially very
welcome, because it allows us to concentrate on fixing bugs instead of
isolating them. Going through the bugzilla database at
@url{http://gcc.gnu.org/bugzilla/} to reduce testcases posted there and
add more information (for example, for which version does the testcase
work, for which versions does it fail?) is also very helpful.

@end table


@node Proposed Extensions
@section Proposed Extensions

Here's a list of proposed extensions for the GNU Fortran compiler, in no particular
order.  Most of these are necessary to be fully compatible with
existing Fortran compilers, but they are not part of the official
J3 Fortran 95 standard.

@subsection Compiler extensions: 
@itemize @bullet
@item
User-specified alignment rules for structures.

@item
Flag to generate @code{Makefile} info.

@item
Automatically extend single precision constants to double.

@item
Compile code that conserves memory by dynamically allocating common and
module storage either on stack or heap.

@item
Compile flag to generate code for array conformance checking (suggest -CC).

@item
User control of symbol names (underscores, etc).

@item
Compile setting for maximum size of stack frame size before spilling
parts to static or heap.

@item
Flag to force local variables into static space.

@item
Flag to force local variables onto stack.
@end itemize


@subsection Environment Options
@itemize @bullet
@item
Pluggable library modules for random numbers, linear algebra.
LA should use BLAS calling conventions.

@item
Environment variables controlling actions on arithmetic exceptions like
overflow, underflow, precision loss---Generate NaN, abort, default.
action.

@item
Set precision for fp units that support it (i387).

@item
Variable for setting fp rounding mode.

@item
Variable to fill uninitialized variables with a user-defined bit
pattern.

@item
Environment variable controlling filename that is opened for that unit
number.

@item
Environment variable to clear/trash memory being freed.

@item
Environment variable to control tracing of allocations and frees.

@item
Environment variable to display allocated memory at normal program end.

@item
Environment variable for filename for * IO-unit.

@item
Environment variable for temporary file directory.

@item
Environment variable forcing standard output to be line buffered (unix).

@end itemize


@c ---------------------------------------------------------------------
@c GNU General Public License
@c ---------------------------------------------------------------------

@include gpl_v3.texi



@c ---------------------------------------------------------------------
@c GNU Free Documentation License
@c ---------------------------------------------------------------------

@include fdl.texi



@c ---------------------------------------------------------------------
@c Funding Free Software
@c ---------------------------------------------------------------------

@include funding.texi

@c ---------------------------------------------------------------------
@c Indices
@c ---------------------------------------------------------------------

@node Option Index
@unnumbered Option Index
@command{gfortran}'s command line options are indexed here without any
initial @samp{-} or @samp{--}. Where an option has both positive and
negative forms (such as -foption and -fno-option), relevant entries in
the manual are indexed under the most appropriate form; it may sometimes
be useful to look up both forms.
@printindex op

@node Keyword Index
@unnumbered Keyword Index
@printindex cp

@bye
