/* This file contains the definitions of the GIMPLE IR tuples used in GCC.

   Copyright (C) 2007, 2008 Free Software Foundation, Inc.
   Contributed by Aldy Hernandez <aldyh@redhat.com>

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

/* The format of this file is
   DEFGSCODE(GIMPLE_symbol, printable name, structure).

   Where symbol is the enumeration name without the ``GIMPLE_''.
   The argument STRUCTURE is used to compute offsets into each of the
   tuple structures that contain operands.  Since vector operands
   are at different offsets depending on the particular structure
   used, these offsets are computed at compile time for efficient
   lookup at runtime.  See gimple_ops().

   If a code does not use operand vectors, STRUCTURE should be NULL.  */

/* Error marker.  This is used in similar ways as ERROR_MARK in tree.def.  */
DEFGSCODE(GIMPLE_ERROR_MARK, "gimple_error_mark", NULL)

/* IMPORTANT.  Do not rearrange the codes between GIMPLE_COND and
   GIMPLE_RETURN.  The ordering is exposed by gimple_has_ops calls.
   These are all the GIMPLE statements with register operands.  */

/* GIMPLE_COND <COND_CODE, OP1, OP2, TRUE_LABEL, FALSE_LABEL>
   represents the conditional jump:
   
   if (OP1 COND_CODE OP2) goto TRUE_LABEL else goto FALSE_LABEL

   COND_CODE is the tree code used as the comparison predicate.  It
   must be of class tcc_comparison.

   OP1 and OP2 are the operands used in the comparison.  They must be
   accepted by is_gimple_operand.

   TRUE_LABEL and FALSE_LABEL are the LABEL_DECL nodes used as the
   jump target for the comparison.  */
DEFGSCODE(GIMPLE_COND, "gimple_cond", struct gimple_statement_with_ops)

/* GIMPLE_GOTO <TARGET> represents unconditional jumps.
   TARGET is a LABEL_DECL or an expression node for computed GOTOs.  */
DEFGSCODE(GIMPLE_GOTO, "gimple_goto", struct gimple_statement_with_ops)

/* GIMPLE_LABEL <LABEL> represents label statements.  LABEL is a
   LABEL_DECL representing a jump target.  */
DEFGSCODE(GIMPLE_LABEL, "gimple_label", struct gimple_statement_with_ops)

/* GIMPLE_SWITCH <INDEX, DEFAULT_LAB, LAB1, ..., LABN> represents the
   multiway branch:

   switch (INDEX)
   {
     case LAB1: ...; break;
     ...
     case LABN: ...; break;
     default: ...
   }

   INDEX is the variable evaluated to decide which label to jump to.

   DEFAULT_LAB, LAB1 ... LABN are the tree nodes representing case labels.
   They must be CASE_LABEL_EXPR nodes.  */
DEFGSCODE(GIMPLE_SWITCH, "gimple_switch", struct gimple_statement_with_ops)

/* GIMPLE_CHANGE_DYNAMIC_TYPE indicates a change in the dynamic type
   of a memory location.  This has no value and generates no
   executable code.  It is only used for type based alias analysis.
   This is generated by C++ placement new and it's a direct
   translation from CHANGE_DYNAMIC_TYPE_EXPR.  The first operand
   (gimple_cdt_new_type) is the new type.  The second operand
   (gimple_cdt_location) is the location (pointer) whose type is being
   changed.  */
DEFGSCODE(GIMPLE_CHANGE_DYNAMIC_TYPE, "gimple_change_dynamic_type",
	  struct gimple_statement_with_ops)

/* IMPORTANT.
   
   Do not rearrange the codes between GIMPLE_ASSIGN and GIMPLE_RETURN.
   It's exposed by GIMPLE_RANGE_CHECK calls. These are all the GIMPLE
   statements with memory and register operands.  */

/* GIMPLE_ASSIGN <SUBCODE, LHS, RHS1[, RHS2]> represents the assignment
   statement

   LHS = RHS1 SUBCODE RHS2.

   SUBCODE is the tree code for the expression computed by the RHS of the
   assignment.  It must be one of the tree codes accepted by
   get_gimple_rhs_class.

   LHS is the operand on the LHS of the assignment.  It must be a tree node
   accepted by is_gimple_operand.

   RHS1 is the first operand on the RHS of the assignment. It must be a tree
   node accepted by is_gimple_operand.

   RHS2 is the second operand on the RHS of the assignemnt. It must be a tree
   node accepted by is_gimple_operand.  This argument exists only if SUBCODE is
   of class GIMPLE_BINARY_RHS.  */
DEFGSCODE(GIMPLE_ASSIGN, "gimple_assign",
	  struct gimple_statement_with_memory_ops)

/* GIMPLE_ASM <STRING, I1, ..., IN, O1, ... OM, C1, ..., CP>
   represents inline assembly statements.

   STRING is the string containing the assembly statements.
   I1 ... IN are the N input operands.
   O1 ... OM are the M output operands.
   C1 ... CP are the P clobber operands.  */
DEFGSCODE(GIMPLE_ASM, "gimple_asm", struct gimple_statement_asm)

/* GIMPLE_CALL <FN, LHS, ARG1, ..., ARGN[, CHAIN]> represents function
   calls.

   FN is the callee.  It must be accepted by is_gimple_call_addr.

   LHS is the operand where the return value from FN is stored.  It may
   be NULL.

   ARG1 ... ARGN are the arguments.  They must all be accepted by
   is_gimple_operand.

    CHAIN is the optional static chain link for nested functions.  */
DEFGSCODE(GIMPLE_CALL, "gimple_call",
	  struct gimple_statement_with_memory_ops)

/* GIMPLE_RETURN <RETVAL> represents return statements.

   RETVAL is the value to return or NULL.  If a value is returned it
   must be accepted by is_gimple_operand.  */
DEFGSCODE(GIMPLE_RETURN, "gimple_return",
	  struct gimple_statement_with_memory_ops)

/* GIMPLE_BIND <VARS, BLOCK, BODY> represents a lexical scope.
   VARS is the set of variables declared in that scope.
   BLOCK is the symbol binding block used for debug information.  
   BODY is the sequence of statements in the scope.  */
DEFGSCODE(GIMPLE_BIND, "gimple_bind", NULL)

/* GIMPLE_CATCH <TYPES, HANDLER> represents a typed exception handler.
   TYPES is the type (or list of types) handled.  HANDLER is the
   sequence of statements that handle these types.  */
DEFGSCODE(GIMPLE_CATCH, "gimple_catch", NULL)

/* GIMPLE_EH_FILTER <TYPES, FAILURE> represents an exception
   specification.  TYPES is a list of allowed types and FAILURE is the
   sequence of statements to execute on failure.  */
DEFGSCODE(GIMPLE_EH_FILTER, "gimple_eh_filter", NULL)

/* GIMPLE_PHI <RESULT, ARG1, ..., ARGN> represents the PHI node

   RESULT = PHI <ARG1, ..., ARGN>

   RESULT is the SSA name created by this PHI node.

   ARG1 ... ARGN are the arguments to the PHI node.  N must be
   exactly the same as the number of incoming edges to the basic block
   holding the PHI node.  Every argument is either an SSA name or a
   tree node of class tcc_constant.  */
DEFGSCODE(GIMPLE_PHI, "gimple_phi", NULL)

/* GIMPLE_RESX <REGION> resumes execution after an exception.
   REGION is the region number being left.  */
DEFGSCODE(GIMPLE_RESX, "gimple_resx", NULL)

/* GIMPLE_TRY <TRY_KIND, EVAL, CLEANUP>
   represents a try/catch or a try/finally statement.

   TRY_KIND is either GIMPLE_TRY_CATCH or GIMPLE_TRY_FINALLY.

   EVAL is the sequence of statements to execute on entry to GIMPLE_TRY.

   CLEANUP is the sequence of statements to execute according to
   TRY_KIND.  If TRY_KIND is GIMPLE_TRY_CATCH, CLEANUP is only exected
   if an exception is thrown during execution of EVAL.  If TRY_KIND is
   GIMPLE_TRY_FINALLY, CLEANUP is always executed after executing EVAL
   (regardless of whether EVAL finished normally, or jumped out or an
   exception was thrown).  */
DEFGSCODE(GIMPLE_TRY, "gimple_try", NULL)

/* GIMPLE_NOP represents the "do nothing" statement.  */
DEFGSCODE(GIMPLE_NOP, "gimple_nop", NULL)


/* IMPORTANT.
   
   Do not rearrange any of the GIMPLE_OMP_* codes.  This ordering is
   exposed by the range check in gimple_omp_subcode().  */


/* Tuples used for lowering of OMP_ATOMIC.  Although the form of the OMP_ATOMIC
   expression is very simple (just in form mem op= expr), various implicit
   conversions may cause the expression to become more complex, so that it does
   not fit the gimple grammar very well.  To overcome this problem, OMP_ATOMIC
   is rewritten as a sequence of two codes in gimplification:

   GIMPLE_OMP_LOAD (tmp, mem)
   val = some computations involving tmp;
   GIMPLE_OMP_STORE (val).  */
DEFGSCODE(GIMPLE_OMP_ATOMIC_LOAD, "gimple_omp_atomic_load", NULL)
DEFGSCODE(GIMPLE_OMP_ATOMIC_STORE, "gimple_omp_atomic_store", NULL)

/* GIMPLE_OMP_CONTINUE marks the location of the loop or sections
   iteration in partially lowered OpenMP code.  */
DEFGSCODE(GIMPLE_OMP_CONTINUE, "gimple_omp_continue", NULL)

/* GIMPLE_OMP_CRITICAL <NAME, BODY> represents

   #pragma omp critical [name]

   NAME is the name given to the critical section.
   BODY is the sequence of statements that are inside the critical section.  */
DEFGSCODE(GIMPLE_OMP_CRITICAL, "gimple_omp_critical", NULL)

/* GIMPLE_OMP_FOR <BODY, CLAUSES, INDEX, INITIAL, FINAL, COND, INCR, PRE_BODY>
   represents

   PRE_BODY
   #pragma omp for [clause1 ... clauseN]
   for (INDEX = INITIAL; INDEX COND FINAL; INDEX {+=,-=} INCR)
   BODY

   BODY is the loop body.

   CLAUSES is the list of clauses.

   INDEX must be an integer or pointer variable, which is implicitly thread
   private.  It must be accepted by is_gimple_operand.

   INITIAL is the initial value given to INDEX. It must be
   accepted by is_gimple_operand.

   FINAL is the final value that INDEX should take. It must
   be accepted by is_gimple_operand.

   COND is the condition code for the controlling predicate.  It must
   be one of { <, >, <=, >= }

   INCR is the loop index increment.  It must be tree node of type
   tcc_constant.

   PRE_BODY is a landing pad filled by the gimplifier with things from
   INIT, COND, and INCR that are technically part of the OMP_FOR
   structured block, but are evaluated before the loop body begins.

   INITIAL, FINAL and INCR are required to be loop invariant integer
   expressions that are evaluated without any synchronization.
   The evaluation order, frequency of evaluation and side-effects are
   unspecified by the standard.  */
DEFGSCODE(GIMPLE_OMP_FOR, "gimple_omp_for", NULL)

/* GIMPLE_OMP_MASTER <BODY> represents #pragma omp master.
   BODY is the sequence of statements to execute in the master section.  */
DEFGSCODE(GIMPLE_OMP_MASTER, "gimple_omp_master", NULL)

/* GIMPLE_OMP_ORDERED <BODY> represents #pragma omp ordered.
   BODY is the sequence of statements to execute in the ordered section.  */
DEFGSCODE(GIMPLE_OMP_ORDERED, "gimple_omp_ordered", NULL)

/* GIMPLE_OMP_PARALLEL <BODY, CLAUSES, CHILD_FN, DATA_ARG> represents

   #pragma omp parallel [CLAUSES]
   BODY

   BODY is a the sequence of statements to be executed by all threads.

   CLAUSES is a TREE_LIST node with all the clauses.

   CHILD_FN is set when outlining the body of the parallel region.
   All the statements in BODY are moved into this newly created
   function when converting OMP constructs into low-GIMPLE.

   DATA_ARG is a local variable in the parent function containing data
   to be shared with CHILD_FN.  This is used to implement all the data
   sharing clauses.  */
DEFGSCODE(GIMPLE_OMP_PARALLEL, "gimple_omp_parallel", NULL)

/* GIMPLE_OMP_TASK <BODY, CLAUSES, CHILD_FN, DATA_ARG, COPY_FN,
		    ARG_SIZE, ARG_ALIGN> represents

   #pragma omp task [CLAUSES]
   BODY

   BODY is a the sequence of statements to be executed by all threads.

   CLAUSES is a TREE_LIST node with all the clauses.

   CHILD_FN is set when outlining the body of the explicit task region.
   All the statements in BODY are moved into this newly created
   function when converting OMP constructs into low-GIMPLE.

   DATA_ARG is a local variable in the parent function containing data
   to be shared with CHILD_FN.  This is used to implement all the data
   sharing clauses.

   COPY_FN is set when outlining the firstprivate var initialization.
   All the needed statements are emitted into the newly created
   function, or when only memcpy is needed, it is NULL.

   ARG_SIZE and ARG_ALIGN are the size and alignment of the incoming
   data area allocated by GOMP_task and passed to CHILD_FN.  */
DEFGSCODE(GIMPLE_OMP_TASK, "gimple_omp_task", NULL)

/* OMP_RETURN marks the end of an OpenMP directive.  */
DEFGSCODE(GIMPLE_OMP_RETURN, "gimple_omp_return", NULL)

/* OMP_SECTION <BODY> represents #pragma omp section.
   BODY is the sequence of statements in the section body.  */
DEFGSCODE(GIMPLE_OMP_SECTION, "gimple_omp_section", NULL)

/* OMP_SECTIONS <BODY, CLAUSES, CONTROL> represents #pragma omp sections.

   BODY is the sequence of statements in the sections body.
   CLAUSES is a TREE_LIST node holding the list of associated clauses.
   CONTROL is a VAR_DECL used for deciding which of the sections
   to execute.  */
DEFGSCODE(GIMPLE_OMP_SECTIONS, "gimple_omp_sections", NULL)

/* GIMPLE_OMP_SECTIONS_SWITCH is a marker placed immediately after
   OMP_SECTIONS.  It represents the GIMPLE_SWITCH used to decide which
   branch is taken.  */
DEFGSCODE(GIMPLE_OMP_SECTIONS_SWITCH, "gimple_omp_sections_switch", NULL)

/* GIMPLE_OMP_SINGLE <BODY, CLAUSES> represents #pragma omp single
   BODY is the sequence of statements inside the single section.
   CLAUSES is a TREE_LIST node holding the associated clauses.  */
DEFGSCODE(GIMPLE_OMP_SINGLE, "gimple_omp_single", NULL)

/* GIMPLE_PREDICT <PREDICT, OUTCOME> specifies a hint for branch prediction.

   PREDICT is one of the predictors from predict.def.

   OUTCOME is NOT_TAKEN or TAKEN.  */
DEFGSCODE(GIMPLE_PREDICT, "gimple_predict", NULL)

/*  This node represents a cleanup expression.  It is ONLY USED INTERNALLY
    by the gimplifier as a placeholder for cleanups, and its uses will be
    cleaned up by the time gimplification is done.
    
    This tuple should not exist outside of the gimplifier proper.  */
DEFGSCODE(GIMPLE_WITH_CLEANUP_EXPR, "gimple_with_cleanup_expr", NULL)
