<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title></title><meta name="generator" content="DocBook XSL Stylesheets V1.74.0" /><meta name="keywords" content="&#10;      ISO C++&#10;    , &#10;      library&#10;    , &#10;      algorithm&#10;    " /><link rel="home" href="../spine.html" title="The GNU C++ Library Documentation" /><link rel="up" href="algorithms.html" title="Part IX.  Algorithms" /><link rel="prev" href="algorithms.html" title="Part IX.  Algorithms" /><link rel="next" href="bk01pt09ch20.html" title="Chapter 20. Mutating" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center"></th></tr><tr><td width="20%" align="left"><a accesskey="p" href="algorithms.html">Prev</a> </td><th width="60%" align="center">Part IX. 
  Algorithms
  
</th><td width="20%" align="right"> <a accesskey="n" href="bk01pt09ch20.html">Next</a></td></tr></table><hr /></div><div class="preface" lang="en" xml:lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="id425058"></a></h2></div></div></div><p>
  The neatest accomplishment of the algorithms chapter is that all the
  work is done via iterators, not containers directly.  This means two
  important things:
</p><div class="orderedlist"><ol type="1"><li><p>
	  Anything that behaves like an iterator can be used in one of
          these algorithms.  Raw pointers make great candidates, thus
          built-in arrays are fine containers, as well as your own iterators.
	</p></li><li><p>
	  The algorithms do not (and cannot) affect the container as a
          whole; only the things between the two iterator endpoints.  If
          you pass a range of iterators only enclosing the middle third of
          a container, then anything outside that range is inviolate.
	</p></li></ol></div><p>
     Even strings can be fed through the algorithms here, although the
     string class has specialized versions of many of these functions
     (for example, <code class="code">string::find()</code>).  Most of the examples
     on this page will use simple arrays of integers as a playground
     for algorithms, just to keep things simple.  The use of
     <span class="emphasis"><em>N</em></span> as a size in the examples is to keep
     things easy to read but probably won't be valid code.  You can
     use wrappers such as those described in the <a class="ulink" href="../23_containers/howto.html" target="_top">containers chapter</a> to
     keep real code readable.
   </p><p>
     The single thing that trips people up the most is the definition
     of <span class="emphasis"><em>range</em></span> used with iterators; the famous
     "past-the-end" rule that everybody loves to hate.  The
     <a class="ulink" href="../24_iterators/howto.html#2" target="_top">iterators
     chapter</a> of this document has a complete explanation of
     this simple rule that seems to cause so much confusion.  Once you
     get <span class="emphasis"><em>range</em></span> into your head (it's not that
     hard, honest!), then the algorithms are a cakewalk.
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="algorithms.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="algorithms.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bk01pt09ch20.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part IX. 
  Algorithms
  
 </td><td width="20%" align="center"><a accesskey="h" href="../spine.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 20. Mutating</td></tr></table></div></body></html>
