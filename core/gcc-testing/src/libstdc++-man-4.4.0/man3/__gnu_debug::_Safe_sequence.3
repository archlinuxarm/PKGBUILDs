.TH "__gnu_debug::_Safe_sequence" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_sequence \- Base class for constructing a 'safe' sequence type that tracks iterators that reference it.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB__gnu_debug::_Safe_sequence_base\fP.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_invalidate_all\fP () const "
.br
.ti -1c
.RI "template<typename _Predicate > void \fB_M_invalidate_if\fP (_Predicate __pred)"
.br
.ti -1c
.RI "template<typename _Iterator > void \fB_M_transfer_iter\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__x)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_const_iterators\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_iterators\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_detach_all\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_singular\fP ()"
.br
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()"
.br
.ti -1c
.RI "void \fB_M_revalidate_singular\fP ()"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB_Safe_sequence_base\fP &__x)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Sequence> class __gnu_debug::_Safe_sequence< _Sequence >"
Base class for constructing a 'safe' sequence type that tracks iterators that reference it. 

The class template _Safe_sequence simplifies the construction of 'safe' sequences that track the iterators that reference the sequence, so that the iterators are notified of changes in the sequence that may affect their operation, e.g., if the container invalidates its iterators or is destructed. This class template may only be used by deriving from it and passing the name of the derived class as its template parameter via the curiously recurring template pattern. The derived class must have \fCiterator\fP and  types that are instantiations of class template \fB_Safe_iterator\fP for this sequence. Iterators will then be tracked automatically. 
.PP
Definition at line 97 of file safe_sequence.h.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_all ()\fC [protected, inherited]\fP"
.PP
Detach all iterators, leaving them singular. 
.PP
Referenced by __gnu_debug::_Safe_sequence_base::~_Safe_sequence_base().
.SS "void __gnu_debug::_Safe_sequence_base::_M_detach_singular ()\fC [protected, inherited]\fP"
.PP
Detach all singular iterators. 
.PP
\fBPostcondition:\fP
.RS 4
for all iterators i attached to this sequence, i->_M_version == _M_version. 
.RE
.PP

.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_sequence_base::_M_get_mutex ()\fC [protected, inherited]\fP"
.PP
For use in \fB_Safe_sequence\fP. 
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "void __gnu_debug::_Safe_sequence_base::_M_invalidate_all () const\fC [inline, inherited]\fP"
.PP
Invalidates all iterators. 
.PP
Definition at line 215 of file safe_base.h.
.PP
References __gnu_debug::_Safe_sequence_base::_M_version.
.SS "template<typename _Sequence > template<typename _Predicate > void \fB__gnu_debug::_Safe_sequence\fP< _Sequence >::_M_invalidate_if (_Predicate __pred)\fC [inline]\fP"
.PP
Invalidates all iterators \fCx\fP that reference this sequence, are not singular, and for which \fCpred(x)\fP returns \fCtrue\fP. The user of this routine should be careful not to make copies of the iterators passed to \fCpred\fP, as the copies may interfere with the invalidation. 
.PP
Definition at line 121 of file safe_sequence.h.
.PP
References __gnu_debug::_Safe_sequence_base::_M_const_iterators, __gnu_debug::_Safe_sequence_base::_M_get_mutex(), and __gnu_debug::_Safe_sequence_base::_M_iterators.
.SS "void __gnu_debug::_Safe_sequence_base::_M_revalidate_singular ()\fC [protected, inherited]\fP"
.PP
Revalidates all attached singular iterators. This method may be used to validate iterators that were invalidated before (but for some reason, such as an exception, need to become valid again). 
.SS "void __gnu_debug::_Safe_sequence_base::_M_swap (\fB_Safe_sequence_base\fP & __x)\fC [protected, inherited]\fP"
.PP
Swap this sequence with the given sequence. This operation also swaps ownership of the iterators, so that when the operation is complete all iterators that originally referenced one container now reference the other container. 
.SS "template<typename _Sequence> template<typename _Iterator > void \fB__gnu_debug::_Safe_sequence\fP< _Sequence >::_M_transfer_iter (const \fB_Safe_iterator\fP< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Transfers all iterators that reference this memory location to this sequence from whatever sequence they are attached to. 
.PP
Definition at line 154 of file safe_sequence.h.
.PP
References __gnu_debug::_Safe_sequence_base::_M_const_iterators, __gnu_debug::_Safe_sequence_base::_M_get_mutex(), __gnu_debug::_Safe_sequence_base::_M_iterators, __gnu_debug::_Safe_iterator_base::_M_sequence, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base().
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_sequence_base::_M_const_iterators\fP\fC [inherited]\fP"
.PP
The list of constant iterators that reference this container. 
.PP
Definition at line 166 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_sequence_base::_M_iterators\fP\fC [inherited]\fP"
.PP
The list of mutable iterators that reference this container. 
.PP
Definition at line 163 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence< _Sequence >::_M_invalidate_if(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "unsigned int \fB__gnu_debug::_Safe_sequence_base::_M_version\fP\fC [mutable, inherited]\fP"
.PP
The container version number. This number may never be 0. 
.PP
Definition at line 169 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_sequence_base::_M_invalidate_all().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
