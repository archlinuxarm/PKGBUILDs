.TH "__gnu_debug::_Safe_iterator" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_iterator \- Safe iterator wrapper.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB__gnu_debug::_Safe_iterator_base\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Iterator \fB_Base_iterator\fP"
.br
.ti -1c
.RI "typedef _Traits::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Traits::iterator_category \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef _Traits::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Traits::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Traits::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach\fP (const _Sequence *__seq)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (const _Sequence *__seq)"
.br
.ti -1c
.RI "bool \fB_M_attached_to\fP (const \fB_Safe_sequence_base\fP *__seq) const "
.br
.ti -1c
.RI "bool \fB_M_can_advance\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "bool \fB_M_can_compare\fP (const \fB_Safe_iterator_base\fP &__x) const "
.br
.ti -1c
.RI "bool \fB_M_decrementable\fP () const "
.br
.ti -1c
.RI "bool \fB_M_dereferenceable\fP () const "
.br
.ti -1c
.RI "void \fB_M_detach\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP ()"
.br
.ti -1c
.RI "const _Sequence * \fB_M_get_sequence\fP () const "
.br
.ti -1c
.RI "bool \fB_M_incrementable\fP () const "
.br
.ti -1c
.RI "void \fB_M_invalidate\fP ()"
.br
.ti -1c
.RI "void \fB_M_invalidate_single\fP ()"
.br
.ti -1c
.RI "bool \fB_M_is_begin\fP () const "
.br
.ti -1c
.RI "bool \fB_M_is_end\fP () const "
.br
.ti -1c
.RI "bool \fB_M_singular\fP () const "
.br
.ti -1c
.RI "template<typename _Other > bool \fB_M_valid_range\fP (const \fB_Safe_iterator\fP< _Other, _Sequence > &__rhs) const "
.br
.ti -1c
.RI "template<typename _MutableIterator > \fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::_Base_iterator >::__value), _Sequence >::__type > &__x)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP (const _Iterator &__i, const _Sequence *__seq)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP ()"
.br
.ti -1c
.RI "_Iterator \fBbase\fP () const "
.br
.ti -1c
.RI "\fBoperator _Iterator\fP () const "
.br
.ti -1c
.RI "reference \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator+\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator+=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator-\fP (const difference_type &__n) const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator-=\fP (const difference_type &__n)"
.br
.ti -1c
.RI "pointer \fBoperator->\fP () const "
.br
.ti -1c
.RI "\fB_Safe_iterator\fP & \fBoperator=\fP (const \fB_Safe_iterator\fP &__x)"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (const difference_type &__n) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs, \fBstd::random_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP< difference_type, _Distance_precision > \fB_M_get_distance\fP (const _Iterator1 &__lhs, const _Iterator2 &__rhs)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_next\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_prior\fP"
.br
.ti -1c
.RI "\fB_Safe_sequence_base\fP * \fB_M_sequence\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Iterator, typename _Sequence> class __gnu_debug::_Safe_iterator< _Iterator, _Sequence >"
Safe iterator wrapper. 

The class template _Safe_iterator is a wrapper around an iterator that tracks the iterator's movement among sequences and checks that operations performed on the 'safe' iterator are legal. In additional to the basic iterator operations (which are validated, and then passed to the underlying iterator), _Safe_iterator has member functions for iterator invalidation, attaching/detaching the iterator from sequences, and querying the iterator's state. 
.PP
Definition at line 63 of file safe_iterator.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP ()\fC [inline]\fP"
.PP
\fBPostcondition:\fP
.RS 4
the iterator is singular and unattached 
.RE
.PP

.PP
Definition at line 99 of file safe_iterator.h.
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const _Iterator & __i, const _Sequence * __seq)\fC [inline]\fP"
.PP
Safe iterator construction from an unsafe iterator and its sequence. 
.PP
\fBPrecondition:\fP
.RS 4
\fCseq\fP is not NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
this is not singular 
.RE
.PP

.PP
Definition at line 108 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Copy construction. 
.PP
\fBPrecondition:\fP
.RS 4
\fCx\fP is not singular 
.RE
.PP

.PP
Definition at line 120 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _Iterator, typename _Sequence> template<typename _MutableIterator > \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::\fB_Safe_iterator\fP (const \fB_Safe_iterator\fP< _MutableIterator, typename __gnu_cxx::__enable_if<(std::__are_same< _MutableIterator, typename _Sequence::iterator::_Base_iterator >::__value), _Sequence >::__type > & __x)\fC [inline]\fP"
.PP
Converting constructor from a mutable iterator to a constant iterator. 
.PP
\fBPrecondition:\fP
.RS 4
\fCx\fP is not singular 
.RE
.PP

.PP
Definition at line 136 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach (\fB_Safe_sequence_base\fP * __seq, bool __constant)\fC [inherited]\fP"
.PP
Attaches this iterator to the given sequence, detaching it from whatever sequence it was attached to originally. If the new sequence is the NULL pointer, the iterator is left unattached. 
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_Safe_iterator_base().
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach (const _Sequence * __seq)\fC [inline]\fP"
.PP
Attach iterator to the given sequence. 
.PP
Definition at line 317 of file safe_iterator.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach_single (\fB_Safe_sequence_base\fP * __seq, bool __constant)\fC [inherited]\fP"
.PP
Likewise, but not thread-safe. 
.SS "template<typename _Iterator, typename _Sequence> void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_attach_single (const _Sequence * __seq)\fC [inline]\fP"
.PP
Likewise, but not thread-safe. 
.PP
Definition at line 325 of file safe_iterator.h.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_attached_to (const \fB_Safe_sequence_base\fP * __seq) const\fC [inline, inherited]\fP"
.PP
Determines if we are attached to the given sequence. 
.PP
Definition at line 130 of file safe_base.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_can_compare (const \fB_Safe_iterator_base\fP & __x) const\fC [inherited]\fP"
.PP
Can we compare this iterator to the given iterator \fC__x\fP? Returns true if both iterators are nonsingular and reference the same sequence. 
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_dereferenceable () const\fC [inline]\fP"
.PP
Is the iterator dereferenceable? 
.PP
Definition at line 341 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), and __gnu_debug::_Safe_iterator_base::_M_singular().
.PP
Referenced by __gnu_debug::__check_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator*(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator->().
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach ()\fC [inherited]\fP"
.PP
Detach the iterator for whatever sequence it is attached to, if any. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach_single ()\fC [inherited]\fP"
.PP
Likewise, but not thread-safe. 
.SS "template<typename _Iterator, typename _Sequence> template<typename _Iterator1 , typename _Iterator2 > static \fBstd::pair\fP<difference_type, _Distance_precision> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_get_distance (const _Iterator1 & __lhs, const _Iterator2 & __rhs)\fC [inline, static]\fP"
.PP
Determine the distance between two iterators with some known precision. 
.PP
Definition at line 371 of file safe_iterator.h.
.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_iterator_base::_M_get_mutex ()\fC [protected, inherited]\fP"
.PP
For use in \fB_Safe_iterator\fP. 
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate().
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_incrementable () const\fC [inline]\fP"
.PP
Is the iterator incrementable? 
.PP
Definition at line 346 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator++().
.SS "template<typename _Iterator , typename _Sequence > void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_invalidate ()\fC [inline]\fP"
.PP
Invalidate the iterator, making it singular. 
.PP
Definition at line 106 of file safe_iterator.tcc.
.PP
References __gnu_debug::_Safe_iterator_base::_M_get_mutex(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().
.SS "template<typename _Iterator , typename _Sequence > void \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_invalidate_single ()\fC [inline]\fP"
.PP
Likewise, but not thread-safe. 
.PP
Definition at line 115 of file safe_iterator.tcc.
.PP
References __gnu_debug::_Safe_sequence_base::_M_const_iterators, __gnu_debug::_Safe_sequence_base::_M_iterators, __gnu_debug::_Safe_iterator_base::_M_next, __gnu_debug::_Safe_iterator_base::_M_sequence, __gnu_debug::_Safe_iterator_base::_M_singular(), __gnu_debug::_Safe_iterator_base::_M_version, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::base().
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate().
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_begin () const\fC [inline]\fP"
.PP
Is this iterator equal to the sequence's begin() iterator? 
.PP
Definition at line 396 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.SS "template<typename _Iterator, typename _Sequence> bool \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::_M_is_end () const\fC [inline]\fP"
.PP
Is this iterator equal to the sequence's end() iterator? 
.PP
Definition at line 400 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_sequence.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "bool __gnu_debug::_Safe_iterator_base::_M_singular () const\fC [inherited]\fP"
.PP
Is this iterator singular? 
.PP
Referenced by __gnu_debug::__check_singular(), __gnu_debug::__check_singular_aux(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "template<typename _Iterator, typename _Sequence> _Iterator \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::base () const\fC [inline]\fP"
.PP
Return the underlying iterator. 
.PP
Definition at line 307 of file safe_iterator.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), and __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter().
.SS "template<typename _Iterator, typename _Sequence> \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator _Iterator () const\fC [inline]\fP"
.PP
Conversion to underlying non-debug iterator to allow better interaction with non-debug containers. 
.PP
Definition at line 313 of file safe_iterator.h.
.SS "template<typename _Iterator, typename _Sequence> reference \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator* () const\fC [inline]\fP"
.PP
Iterator dereference. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP

.PP
Definition at line 170 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ (int)\fC [inline]\fP"
.PP
Iterator postincrement. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definition at line 214 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator++ ()\fC [inline]\fP"
.PP
Iterator preincrement. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is incrementable 
.RE
.PP

.PP
Definition at line 200 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_incrementable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- (int)\fC [inline]\fP"
.PP
Iterator postdecrement. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definition at line 244 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-- ()\fC [inline]\fP"
.PP
Iterator predecrement. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is decrementable 
.RE
.PP

.PP
Definition at line 230 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY.
.SS "template<typename _Iterator, typename _Sequence> pointer \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator-> () const\fC [inline]\fP"
.PP
Iterator dereference. 
.PP
\fBPrecondition:\fP
.RS 4
iterator is dereferenceable 
.RE
.PP
\fBTodo\fP
.RS 4
Make this correct w.r.t. iterators that return proxies 
.PP
Use addressof() instead of & operator 
.RE
.PP

.PP
Definition at line 186 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "template<typename _Iterator, typename _Sequence> \fB_Safe_iterator\fP& \fB__gnu_debug::_Safe_iterator\fP< _Iterator, _Sequence >::operator= (const \fB_Safe_iterator\fP< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Copy assignment. 
.PP
\fBPrecondition:\fP
.RS 4
\fCx\fP is not singular 
.RE
.PP

.PP
Definition at line 154 of file safe_iterator.h.
.PP
References _GLIBCXX_DEBUG_VERIFY, __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_attach(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_current, __gnu_debug::_Safe_iterator_base::_M_sequence, and __gnu_debug::_Safe_iterator_base::_M_singular().
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_next\fP\fC [inherited]\fP"
.PP
Pointer to the next iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 73 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_prior\fP\fC [inherited]\fP"
.PP
Pointer to the previous iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 69 of file safe_base.h.
.SS "\fB_Safe_sequence_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_sequence\fP\fC [inherited]\fP"
.PP
The sequence this iterator references; may be NULL to indicate a singular iterator. 
.PP
Definition at line 56 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator_base::_M_attached_to(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter(), __gnu_debug::_Safe_iterator_base::_Safe_iterator_base(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "unsigned int \fB__gnu_debug::_Safe_iterator_base::_M_version\fP\fC [inherited]\fP"
.PP
The version number of this iterator. The sentinel value 0 is used to indicate an invalidated iterator (i.e., one that is singular because of an operation on the container). This version number must equal the version number in the sequence referenced by _M_sequence for the iterator to be non-singular. 
.PP
Definition at line 65 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
