.TH "std::ctype_byname" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::ctype_byname \- class \fBctype_byname\fP [22.2.1.2].  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBctype< _CharT >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef const int * \fB__to_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef \fBctype\fP< _CharT >::mask \fBmask\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBctype_byname\fP (const char *__s, size_t __refs=0)"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBis\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const"
.br
.ti -1c
.RI "bool \fBis\fP (mask __m, \fBchar_type\fP __c) const"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBnarrow\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char __dfault, char *__to) const"
.br
.ti -1c
.RI "char \fBnarrow\fP (\fBchar_type\fP __c, char __dfault) const"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBscan_is\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBscan_not\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBtolower\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "\fBchar_type\fP \fBtolower\fP (\fBchar_type\fP __c) const"
.br
.ti -1c
.RI "const \fBchar_type\fP * \fBtoupper\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "\fBchar_type\fP \fBtoupper\fP (\fBchar_type\fP __c) const"
.br
.ti -1c
.RI "const char * \fBwiden\fP (const char *__lo, const char *__hi, \fBchar_type\fP *__to) const"
.br
.ti -1c
.RI "\fBchar_type\fP \fBwiden\fP (char __c) const"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const mask \fBalnum\fP"
.br
.ti -1c
.RI "static const mask \fBalpha\fP"
.br
.ti -1c
.RI "static const mask \fBcntrl\fP"
.br
.ti -1c
.RI "static const mask \fBdigit\fP"
.br
.ti -1c
.RI "static const mask \fBgraph\fP"
.br
.ti -1c
.RI "static \fBlocale::id\fP \fBid\fP"
.br
.ti -1c
.RI "static const mask \fBlower\fP"
.br
.ti -1c
.RI "static const mask \fBprint\fP"
.br
.ti -1c
.RI "static const mask \fBpunct\fP"
.br
.ti -1c
.RI "static const mask \fBspace\fP"
.br
.ti -1c
.RI "static const mask \fBupper\fP"
.br
.ti -1c
.RI "static const mask \fBxdigit\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_is\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, mask *__vec) const"
.br
.ti -1c
.RI "virtual bool \fBdo_is\fP (mask __m, \fBchar_type\fP __c) const"
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_narrow\fP (const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi, char __dfault, char *__dest) const"
.br
.ti -1c
.RI "virtual char \fBdo_narrow\fP (\fBchar_type\fP, char __dfault) const"
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_scan_is\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_scan_not\fP (mask __m, const \fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_tolower\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_tolower\fP (\fBchar_type\fP __c) const"
.br
.ti -1c
.RI "virtual const \fBchar_type\fP * \fBdo_toupper\fP (\fBchar_type\fP *__lo, const \fBchar_type\fP *__hi) const"
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_toupper\fP (\fBchar_type\fP __c) const"
.br
.ti -1c
.RI "virtual const char * \fBdo_widen\fP (const char *__lo, const char *__hi, \fBchar_type\fP *__dest) const"
.br
.ti -1c
.RI "virtual \fBchar_type\fP \fBdo_widen\fP (char __c) const"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static __c_locale \fB_S_clone_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static void \fB_S_create_c_locale\fP (__c_locale &__cloc, const char *__s, __c_locale __old=0)"
.br
.ti -1c
.RI "static void \fB_S_destroy_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static __c_locale \fB_S_get_c_locale\fP ()"
.br
.ti -1c
.RI "static const char * \fB_S_get_c_name\fP ()"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBlocale::_Impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT> class std::ctype_byname< _CharT >"
class \fBctype_byname\fP [22.2.1.2]. 
.PP
Definition at line 1467 of file locale_facets.h.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef _CharT  \fBstd::ctype\fP< _CharT  >::\fBchar_type\fP\fC [inherited]\fP"
.PP
Typedef for the template parameter. 
.PP
Reimplemented from \fBstd::__ctype_abstract_base< _CharT >\fP.
.PP
Definition at line 609 of file locale_facets.h.
.SH "Member Function Documentation"
.PP 
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_is (const char_type * __lo, const char_type * __hi, mask * __vec) const\fC [protected, virtual, inherited]\fP"
.PP
Return a mask array. 
.PP
This function finds the mask for each char_type in the range [lo,hi) and successively writes it to vec. vec must have as many elements as the input.
.PP
do_is() is a hook for a derived facet to change the behavior of classifying. do_is() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIvec\fP Pointer to an array of mask storage. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual bool \fBstd::ctype\fP< _CharT  >::do_is (mask __m, char_type __c) const\fC [protected, virtual, inherited]\fP"
.PP
Test char_type classification. 
.PP
This function finds a mask M for \fIc\fP and compares it to mask \fIm\fP.
.PP
do_is() is a hook for a derived facet to change the behavior of classifying. do_is() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to find the mask of. 
.br
\fIm\fP The mask to compare against. 
.RE
.PP
\fBReturns:\fP
.RS 4
(M & m) != 0. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_narrow (const char_type * __lo, const char_type * __hi, char __dfault, char * __dest) const\fC [protected, virtual, inherited]\fP"
.PP
Narrow char_type array to char. 
.PP
This virtual function converts each char_type in the range [lo,hi) to char using the simplest reasonable transformation and writes the results to the destination array. For any element in the input that cannot be converted, \fIdfault\fP is used instead.
.PP
do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIdfault\fP Char to use if conversion fails. 
.br
\fIto\fP Pointer to the destination array. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual char \fBstd::ctype\fP< _CharT  >::do_narrow (char_type, char __dfault) const\fC [protected, virtual, inherited]\fP"
.PP
Narrow char_type to char. 
.PP
This virtual function converts the argument to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead.
.PP
do_narrow() is a hook for a derived facet to change the behavior of narrowing. do_narrow() must always return the same result for the same input.
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.br
\fIdfault\fP Char to return if conversion fails. 
.RE
.PP
\fBReturns:\fP
.RS 4
The converted char. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_scan_is (mask __m, const char_type * __lo, const char_type * __hi) const\fC [protected, virtual, inherited]\fP"
.PP
Find char_type matching mask. 
.PP
This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is true.
.PP
do_scan_is() is a hook for a derived facet to change the behavior of match searching. do_is() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIm\fP The mask to compare against. 
.br
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a matching char_type if found, else \fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_scan_not (mask __m, const char_type * __lo, const char_type * __hi) const\fC [protected, virtual, inherited]\fP"
.PP
Find char_type not matching mask. 
.PP
This function searches for and returns a pointer to the first char_type c of [lo,hi) for which is(m,c) is false.
.PP
do_scan_is() is a hook for a derived facet to change the behavior of match searching. do_is() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIm\fP The mask to compare against. 
.br
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to a non-matching char_type if found, else \fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_tolower (char_type * __lo, const char_type * __hi) const\fC [protected, virtual, inherited]\fP"
.PP
Convert array to lowercase. 
.PP
This virtual function converts each char_type in the range [lo,hi) to lowercase if possible. Other elements remain untouched.
.PP
do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT  >::do_tolower (char_type) const\fC [protected, virtual, inherited]\fP"
.PP
Convert to lowercase. 
.PP
This virtual function converts the argument to lowercase if possible. If not possible (for example, '2'), returns the argument.
.PP
do_tolower() is a hook for a derived facet to change the behavior of lowercasing. do_tolower() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The lowercase char_type if convertible, else \fIc\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const \fBchar_type\fP* \fBstd::ctype\fP< _CharT  >::do_toupper (char_type * __lo, const char_type * __hi) const\fC [protected, virtual, inherited]\fP"
.PP
Convert array to uppercase. 
.PP
This virtual function converts each char_type in the range [lo,hi) to uppercase if possible. Other elements remain untouched.
.PP
do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT  >::do_toupper (char_type) const\fC [protected, virtual, inherited]\fP"
.PP
Convert to uppercase. 
.PP
This virtual function converts the char_type argument to uppercase if possible. If not possible (for example, '2'), returns the argument.
.PP
do_toupper() is a hook for a derived facet to change the behavior of uppercasing. do_toupper() must always return the same result for the same input.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The uppercase char_type if convertible, else \fIc\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual const char* \fBstd::ctype\fP< _CharT  >::do_widen (const char * __lo, const char * __hi, char_type * __dest) const\fC [protected, virtual, inherited]\fP"
.PP
Widen char array. 
.PP
This function converts each char in the input to char_type using the simplest reasonable transformation.
.PP
do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIto\fP Pointer to the destination array. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "virtual \fBchar_type\fP \fBstd::ctype\fP< _CharT  >::do_widen (char) const\fC [protected, virtual, inherited]\fP"
.PP
Widen char. 
.PP
This virtual function converts the char to char_type using the simplest reasonable transformation.
.PP
do_widen() is a hook for a derived facet to change the behavior of widening. do_widen() must always return the same result for the same input.
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The converted char_type 
.RE
.PP

.PP
Implements \fBstd::__ctype_abstract_base< _CharT >\fP.
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::is (const char_type * __lo, const char_type * __hi, mask * __vec) const\fC [inline, inherited]\fP"
.PP
Return a mask array. 
.PP
This function finds the mask for each char_type in the range [lo,hi) and successively writes it to vec. vec must have as many elements as the char array. It does so by returning the value of ctype<char_type>::do_is().
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIvec\fP Pointer to an array of mask storage. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Definition at line 179 of file locale_facets.h.
.SS "bool \fBstd::__ctype_abstract_base\fP< _CharT  >::is (mask __m, char_type __c) const\fC [inline, inherited]\fP"
.PP
Test char_type classification. 
.PP
This function finds a mask M for \fIc\fP and compares it to mask \fIm\fP. It does so by returning the value of ctype<char_type>::do_is().
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to compare the mask of. 
.br
\fIm\fP The mask to compare against. 
.RE
.PP
\fBReturns:\fP
.RS 4
(M & m) != 0. 
.RE
.PP

.PP
Definition at line 162 of file locale_facets.h.
.PP
Referenced by std::regex_traits< _Ch_type >::isctype().
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::narrow (const char_type * __lo, const char_type * __hi, char __dfault, char * __to) const\fC [inline, inherited]\fP"
.PP
Narrow array to char array. 
.PP
This function converts each char_type in the input to char using the simplest reasonable transformation and writes the results to the destination array. For any char_type in the input that cannot be converted, \fIdfault\fP is used instead. It does so by returning ctype<char_type>::do_narrow(lo, hi, dfault, to).
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIdfault\fP Char to use if conversion fails. 
.br
\fIto\fP Pointer to the destination array. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Definition at line 346 of file locale_facets.h.
.SS "char \fBstd::__ctype_abstract_base\fP< _CharT  >::narrow (char_type __c, char __dfault) const\fC [inline, inherited]\fP"
.PP
Narrow char_type to char. 
.PP
This function converts the char_type to char using the simplest reasonable transformation. If the conversion fails, dfault is returned instead. It does so by returning ctype<char_type>::do_narrow(c).
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.br
\fIdfault\fP Char to return if conversion fails. 
.RE
.PP
\fBReturns:\fP
.RS 4
The converted char. 
.RE
.PP

.PP
Definition at line 324 of file locale_facets.h.
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::scan_is (mask __m, const char_type * __lo, const char_type * __hi) const\fC [inline, inherited]\fP"
.PP
Find char_type matching a mask. 
.PP
This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is true. It does so by returning ctype<char_type>::do_scan_is().
.PP
\fBParameters:\fP
.RS 4
\fIm\fP The mask to compare against. 
.br
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to matching char_type if found, else \fIhi\fP. 
.RE
.PP

.PP
Definition at line 195 of file locale_facets.h.
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::scan_not (mask __m, const char_type * __lo, const char_type * __hi) const\fC [inline, inherited]\fP"
.PP
Find char_type not matching a mask. 
.PP
This function searches for and returns the first char_type c in [lo,hi) for which is(m,c) is false. It does so by returning ctype<char_type>::do_scan_not().
.PP
\fBParameters:\fP
.RS 4
\fIm\fP The mask to compare against. 
.br
\fIlo\fP Pointer to first char in range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to non-matching char if found, else \fIhi\fP. 
.RE
.PP

.PP
Definition at line 211 of file locale_facets.h.
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::tolower (char_type * __lo, const char_type * __hi) const\fC [inline, inherited]\fP"
.PP
Convert array to lowercase. 
.PP
This function converts each char_type in the range [lo,hi) to lowercase if possible. Other elements remain untouched. It does so by returning ctype<char_type>:: do_tolower(lo, hi).
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Definition at line 269 of file locale_facets.h.
.SS "\fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT  >::tolower (char_type __c) const\fC [inline, inherited]\fP"
.PP
Convert to lowercase. 
.PP
This function converts the argument to lowercase if possible. If not possible (for example, '2'), returns the argument. It does so by returning ctype<char_type>::do_tolower(c).
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The lowercase char_type if convertible, else \fIc\fP. 
.RE
.PP

.PP
Definition at line 254 of file locale_facets.h.
.SS "const \fBchar_type\fP* \fBstd::__ctype_abstract_base\fP< _CharT  >::toupper (char_type * __lo, const char_type * __hi) const\fC [inline, inherited]\fP"
.PP
Convert array to uppercase. 
.PP
This function converts each char_type in the range [lo,hi) to uppercase if possible. Other elements remain untouched. It does so by returning ctype<char_type>:: do_toupper(lo, hi).
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Definition at line 240 of file locale_facets.h.
.SS "\fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT  >::toupper (char_type __c) const\fC [inline, inherited]\fP"
.PP
Convert to uppercase. 
.PP
This function converts the argument to uppercase if possible. If not possible (for example, '2'), returns the argument. It does so by returning ctype<char_type>::do_toupper().
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char_type to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The uppercase char_type if convertible, else \fIc\fP. 
.RE
.PP

.PP
Definition at line 225 of file locale_facets.h.
.SS "const char* \fBstd::__ctype_abstract_base\fP< _CharT  >::widen (const char * __lo, const char * __hi, char_type * __to) const\fC [inline, inherited]\fP"
.PP
Widen array to char_type. 
.PP
This function converts each char in the input to char_type using the simplest reasonable transformation. It does so by returning ctype<char_type>::do_widen(c).
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIlo\fP Pointer to start of range. 
.br
\fIhi\fP Pointer to end of range. 
.br
\fIto\fP Pointer to the destination array. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIhi\fP. 
.RE
.PP

.PP
Definition at line 305 of file locale_facets.h.
.SS "\fBchar_type\fP \fBstd::__ctype_abstract_base\fP< _CharT  >::widen (char __c) const\fC [inline, inherited]\fP"
.PP
Widen char to char_type. 
.PP
This function converts the char argument to char_type using the simplest reasonable transformation. It does so by returning ctype<char_type>::do_widen(c).
.PP
Note: this is not what you want for codepage conversions. See codecvt for that.
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The char to convert. 
.RE
.PP
\fBReturns:\fP
.RS 4
The converted char_type. 
.RE
.PP

.PP
Definition at line 286 of file locale_facets.h.
.PP
Referenced by std::regex_traits< _Ch_type >::isctype().
.SH "Member Data Documentation"
.PP 
.SS "\fBlocale::id\fP \fBstd::ctype\fP< _CharT  >::\fBid\fP\fC [static, inherited]\fP"
.PP
The facet id for ctype<char_type>. 
.PP
Definition at line 613 of file locale_facets.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
