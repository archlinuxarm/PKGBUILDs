.TH "std" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std \- ISO C++ entities toplevel namespace is \fBstd\fP.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fB__debug\fP"
.br
.ti -1c
.RI "namespace \fB__detail\fP"
.br
.ti -1c
.RI "namespace \fB__parallel\fP"
.br
.ti -1c
.RI "namespace \fBchrono\fP"
.br
.ti -1c
.RI "namespace \fBplaceholders\fP"
.br
.ti -1c
.RI "namespace \fBregex_constants\fP"
.br
.ti -1c
.RI "namespace \fBrel_ops\fP"
.br
.ti -1c
.RI "namespace \fBthis_thread\fP"
.br
.ti -1c
.RI "namespace \fBtr1\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fB__codecvt_abstract_base\fP"
.br
.RI "\fICommon base for \fBcodecvt\fP functions. \fP"
.ti -1c
.RI "class \fB__ctype_abstract_base\fP"
.br
.RI "\fICommon base for \fBctype\fP facet. \fP"
.ti -1c
.RI "struct \fB__is_location_invariant\fP"
.br
.ti -1c
.RI "struct \fB__is_member_pointer_helper\fP"
.br
.RI "\fIis_member_pointer \fP"
.ti -1c
.RI "struct \fB__numeric_limits_base\fP"
.br
.RI "\fIPart of \fBstd::numeric_limits\fP. \fP"
.ti -1c
.RI "struct \fB_Base_bitset\fP"
.br
.ti -1c
.RI "struct \fB_Base_bitset< 0 >\fP"
.br
.ti -1c
.RI "struct \fB_Base_bitset< 1 >\fP"
.br
.ti -1c
.RI "class \fB_Deque_base\fP"
.br
.ti -1c
.RI "struct \fB_Deque_iterator\fP"
.br
.RI "\fIA deque::iterator. \fP"
.ti -1c
.RI "struct \fB_Derives_from_binary_function\fP"
.br
.RI "\fIDetermines if the type _Tp derives from \fBbinary_function\fP. \fP"
.ti -1c
.RI "struct \fB_Derives_from_unary_function\fP"
.br
.RI "\fIDetermines if the type _Tp derives from \fBunary_function\fP. \fP"
.ti -1c
.RI "struct \fB_Fnv_hash\fP"
.br
.RI "\fIDummy generic implementation (for sizeof(size_t) != 4, 8). \fP"
.ti -1c
.RI "class \fB_Function_base\fP"
.br
.RI "\fIBase class of all polymorphic function object wrappers. \fP"
.ti -1c
.RI "struct \fB_Function_to_function_pointer\fP"
.br
.RI "\fITurns a function type into a function pointer type. \fP"
.ti -1c
.RI "struct \fB_Fwd_list_base\fP"
.br
.RI "\fIBase class for forward_list. \fP"
.ti -1c
.RI "struct \fB_Fwd_list_const_iterator\fP"
.br
.RI "\fIA forward_list::const_iterator. \fP"
.ti -1c
.RI "struct \fB_Fwd_list_iterator\fP"
.br
.RI "\fIA forward_list::iterator. \fP"
.ti -1c
.RI "struct \fB_Fwd_list_node\fP"
.br
.RI "\fIA helper node class for forward_list. This is just a linked \fBlist\fP with a data value in each node. There is a sorting utility method. \fP"
.ti -1c
.RI "struct \fB_Fwd_list_node_base\fP"
.br
.RI "\fIA helper basic node class for forward_list. This is just a linked \fBlist\fP with nothing inside it. There are purely \fBlist\fP shuffling utility methods here. \fP"
.ti -1c
.RI "class \fB_Has_result_type_helper\fP"
.br
.ti -1c
.RI "struct \fB_Index_tuple\fP"
.br
.ti -1c
.RI "class \fB_List_base\fP"
.br
.RI "\fISee \fBbits/stl_deque.h\fP's \fB_Deque_base\fP for an explanation. \fP"
.ti -1c
.RI "struct \fB_List_const_iterator\fP"
.br
.RI "\fIA list::const_iterator. \fP"
.ti -1c
.RI "struct \fB_List_iterator\fP"
.br
.RI "\fIA list::iterator. \fP"
.ti -1c
.RI "struct \fB_List_node\fP"
.br
.RI "\fIAn actual node in the list. \fP"
.ti -1c
.RI "struct \fB_List_node_base\fP"
.br
.RI "\fICommon part of a node in the list. \fP"
.ti -1c
.RI "struct \fB_Maybe_get_result_type\fP"
.br
.RI "\fIIf we have found a result_type, extract it. \fP"
.ti -1c
.RI "struct \fB_Maybe_unary_or_binary_function\fP"
.br
.ti -1c
.RI "struct \fB_Maybe_unary_or_binary_function< _Res, _T1 >\fP"
.br
.RI "\fIDerives from \fC\fBunary_function\fP\fP, as appropriate. \fP"
.ti -1c
.RI "struct \fB_Maybe_unary_or_binary_function< _Res, _T1, _T2 >\fP"
.br
.RI "\fIDerives from \fC\fBbinary_function\fP\fP, as appropriate. \fP"
.ti -1c
.RI "struct \fB_Maybe_wrap_member_pointer\fP"
.br
.ti -1c
.RI "struct \fB_Maybe_wrap_member_pointer< _Tp _Class::* >\fP"
.br
.ti -1c
.RI "class \fB_Mem_fn< _Res(_Class::*)(_ArgTypes...) const  >\fP"
.br
.RI "\fIImplementation of \fCmem_fn\fP for const member function pointers. \fP"
.ti -1c
.RI "class \fB_Mem_fn< _Res(_Class::*)(_ArgTypes...) const volatile >\fP"
.br
.RI "\fIImplementation of \fCmem_fn\fP for const volatile member function pointers. \fP"
.ti -1c
.RI "class \fB_Mem_fn< _Res(_Class::*)(_ArgTypes...) volatile >\fP"
.br
.RI "\fIImplementation of \fCmem_fn\fP for volatile member function pointers. \fP"
.ti -1c
.RI "class \fB_Mem_fn< _Res(_Class::*)(_ArgTypes...)>\fP"
.br
.RI "\fIImplementation of \fCmem_fn\fP for member function pointers. \fP"
.ti -1c
.RI "class \fB_Mu< _Arg, false, false >\fP"
.br
.ti -1c
.RI "class \fB_Mu< _Arg, false, true >\fP"
.br
.ti -1c
.RI "class \fB_Mu< _Arg, true, false >\fP"
.br
.ti -1c
.RI "class \fB_Mu< reference_wrapper< _Tp >, false, false >\fP"
.br
.ti -1c
.RI "struct \fB_Placeholder\fP"
.br
.RI "\fIThe type of placeholder objects defined by libstdc++. \fP"
.ti -1c
.RI "struct \fB_Reference_wrapper_base\fP"
.br
.ti -1c
.RI "struct \fB_Result_of_impl< false, _Functor()>\fP"
.br
.ti -1c
.RI "struct \fB_Result_of_impl< false, _Functor(_ArgTypes...)>\fP"
.br
.ti -1c
.RI "struct \fB_Result_of_impl< true, _Functor(_ArgTypes...)>\fP"
.br
.RI "\fIWe already know the result type for \fCFunctor\fP; use it. \fP"
.ti -1c
.RI "struct \fB_Safe_tuple_element\fP"
.br
.ti -1c
.RI "struct \fB_Safe_tuple_element_impl\fP"
.br
.ti -1c
.RI "struct \fB_Safe_tuple_element_impl< __i, _Tuple, false >\fP"
.br
.ti -1c
.RI "class \fB_Temporary_buffer\fP"
.br
.ti -1c
.RI "struct \fB_Tuple_impl< _Idx >\fP"
.br
.ti -1c
.RI "struct \fB_Tuple_impl< _Idx, _Head, _Tail...>\fP"
.br
.ti -1c
.RI "struct \fB_Vector_base\fP"
.br
.RI "\fISee \fBbits/stl_deque.h\fP's \fB_Deque_base\fP for an explanation. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type\fP"
.br
.ti -1c
.RI "struct \fB_Weak_result_type_impl\fP"
.br
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(&)(_ArgTypes...)>\fP"
.br
.RI "\fIRetrieve the result type for a function reference. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(*)(_ArgTypes...)>\fP"
.br
.RI "\fIRetrieve the result type for a function pointer. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(_ArgTypes...)>\fP"
.br
.RI "\fIRetrieve the result type for a function type. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(_Class::*)(_ArgTypes...) const  >\fP"
.br
.RI "\fIRetrieve result type for a const member function pointer. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(_Class::*)(_ArgTypes...) const volatile >\fP"
.br
.RI "\fIRetrieve result type for a const volatile member function pointer. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(_Class::*)(_ArgTypes...) volatile >\fP"
.br
.RI "\fIRetrieve result type for a volatile member function pointer. \fP"
.ti -1c
.RI "struct \fB_Weak_result_type_impl< _Res(_Class::*)(_ArgTypes...)>\fP"
.br
.RI "\fIRetrieve result type for a member function pointer. \fP"
.ti -1c
.RI "struct \fBadd_const\fP"
.br
.RI "\fI\fBadd_const\fP \fP"
.ti -1c
.RI "struct \fBadd_cv\fP"
.br
.RI "\fI\fBadd_cv\fP \fP"
.ti -1c
.RI "struct \fBadd_lvalue_reference\fP"
.br
.RI "\fI\fBadd_lvalue_reference\fP \fP"
.ti -1c
.RI "struct \fBadd_pointer\fP"
.br
.RI "\fI\fBadd_pointer\fP \fP"
.ti -1c
.RI "struct \fBadd_rvalue_reference\fP"
.br
.RI "\fI\fBadd_rvalue_reference\fP \fP"
.ti -1c
.RI "struct \fBadd_volatile\fP"
.br
.RI "\fI\fBadd_volatile\fP \fP"
.ti -1c
.RI "struct \fBadopt_lock_t\fP"
.br
.RI "\fIAssume the calling \fBthread\fP has already obtained \fBmutex\fP ownership and manage it. \fP"
.ti -1c
.RI "struct \fBalignment_of\fP"
.br
.RI "\fI\fBalignment_of\fP \fP"
.ti -1c
.RI "class \fBallocator\fP"
.br
.RI "\fIThe 'standard' \fBallocator\fP, as per [20.4].
.PP
Further details: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt04ch11.html. \fP"
.ti -1c
.RI "class \fBallocator< void >\fP"
.br
.RI "\fI\fBallocator<void>\fP specialization. \fP"
.ti -1c
.RI "struct \fBarray\fP"
.br
.RI "\fIA standard container for storing a fixed size sequence of elements. \fP"
.ti -1c
.RI "struct \fBatomic\fP"
.br
.RI "\fI\fBatomic\fP 29.4.3, Generic \fBatomic\fP type, primary class template. \fP"
.ti -1c
.RI "struct \fBatomic< _Tp * >\fP"
.br
.RI "\fIPartial specialization for pointer types. \fP"
.ti -1c
.RI "struct \fBatomic< bool >\fP"
.br
.RI "\fIExplicit specialization for bool. \fP"
.ti -1c
.RI "struct \fBatomic< char >\fP"
.br
.RI "\fIExplicit specialization for char. \fP"
.ti -1c
.RI "struct \fBatomic< char16_t >\fP"
.br
.RI "\fIExplicit specialization for char16_t. \fP"
.ti -1c
.RI "struct \fBatomic< char32_t >\fP"
.br
.RI "\fIExplicit specialization for char32_t. \fP"
.ti -1c
.RI "struct \fBatomic< int >\fP"
.br
.RI "\fIExplicit specialization for int. \fP"
.ti -1c
.RI "struct \fBatomic< long >\fP"
.br
.RI "\fIExplicit specialization for long. \fP"
.ti -1c
.RI "struct \fBatomic< long long >\fP"
.br
.RI "\fIExplicit specialization for long long. \fP"
.ti -1c
.RI "struct \fBatomic< short >\fP"
.br
.RI "\fIExplicit specialization for short. \fP"
.ti -1c
.RI "struct \fBatomic< signed char >\fP"
.br
.RI "\fIExplicit specialization for signed char. \fP"
.ti -1c
.RI "struct \fBatomic< unsigned char >\fP"
.br
.RI "\fIExplicit specialization for unsigned char. \fP"
.ti -1c
.RI "struct \fBatomic< unsigned int >\fP"
.br
.RI "\fIExplicit specialization for unsigned int. \fP"
.ti -1c
.RI "struct \fBatomic< unsigned long >\fP"
.br
.RI "\fIExplicit specialization for unsigned long. \fP"
.ti -1c
.RI "struct \fBatomic< unsigned long long >\fP"
.br
.RI "\fIExplicit specialization for unsigned long long. \fP"
.ti -1c
.RI "struct \fBatomic< unsigned short >\fP"
.br
.RI "\fIExplicit specialization for unsigned short. \fP"
.ti -1c
.RI "struct \fBatomic< void * >\fP"
.br
.RI "\fIExplicit specialization for void*. \fP"
.ti -1c
.RI "struct \fBatomic< wchar_t >\fP"
.br
.RI "\fIExplicit specialization for wchar_t. \fP"
.ti -1c
.RI "class \fBauto_ptr\fP"
.br
.RI "\fIA simple smart pointer providing strict ownership semantics. \fP"
.ti -1c
.RI "struct \fBauto_ptr_ref\fP"
.br
.ti -1c
.RI "class \fBback_insert_iterator\fP"
.br
.RI "\fITurns assignment into insertion. \fP"
.ti -1c
.RI "class \fBbad_alloc\fP"
.br
.RI "\fIException possibly thrown by \fCnew\fP.
.PP
\fC\fBbad_alloc\fP\fP (or classes derived from it) is used to report allocation errors from the throwing forms of \fCnew\fP. \fP"
.ti -1c
.RI "class \fBbad_cast\fP"
.br
.RI "\fIThrown during incorrect typecasting.
.PP
If you attempt an invalid \fCdynamic_cast\fP expression, an instance of this class (or something derived from this class) is thrown. \fP"
.ti -1c
.RI "class \fBbad_exception\fP"
.br
.ti -1c
.RI "class \fBbad_function_call\fP"
.br
.RI "\fIException class thrown when class template function's operator() is called with an empty target. \fP"
.ti -1c
.RI "class \fBbad_typeid\fP"
.br
.RI "\fIThrown when a NULL pointer in a \fCtypeid\fP expression is used. \fP"
.ti -1c
.RI "class \fBbasic_filebuf\fP"
.br
.RI "\fIThe actual work of input and output (for files).
.PP
This class associates both its input and output sequence with an external disk file, and maintains a joint file position for both sequences. Many of its semantics are described in terms of similar behavior in the Standard C Library's \fCFILE\fP streams. \fP"
.ti -1c
.RI "class \fBbasic_fstream\fP"
.br
.RI "\fIControlling input and output for files.
.PP
This class supports reading from and writing to named files, using the inherited functions from \fBstd::basic_iostream\fP. To control the associated sequence, an instance of \fBstd::basic_filebuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbasic_ifstream\fP"
.br
.RI "\fIControlling input for files.
.PP
This class supports reading from named files, using the inherited functions from \fBstd::basic_istream\fP. To control the associated sequence, an instance of \fBstd::basic_filebuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbasic_ios\fP"
.br
.RI "\fIVirtual base class for all stream classes.
.PP
Most of the member functions called dispatched on stream objects (e.g., \fCstd::cout.foo(bar)\fP;) are consolidated in this class. \fP"
.ti -1c
.RI "class \fBbasic_iostream\fP"
.br
.RI "\fIMerging istream and ostream capabilities.
.PP
This class multiply inherits from the input and output stream classes simply to provide a single interface. \fP"
.ti -1c
.RI "class \fBbasic_istream\fP"
.br
.RI "\fIControlling input.
.PP
This is the base class for all input streams. It provides text formatting of all builtin types, and communicates with any class derived from \fBbasic_streambuf\fP to do the actual input. \fP"
.ti -1c
.RI "class \fBbasic_istringstream\fP"
.br
.RI "\fIControlling input for std::string.
.PP
This class supports reading from objects of type \fBstd::basic_string\fP, using the inherited functions from \fBstd::basic_istream\fP. To control the associated sequence, an instance of \fBstd::basic_stringbuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbasic_ofstream\fP"
.br
.RI "\fIControlling output for files.
.PP
This class supports reading from named files, using the inherited functions from \fBstd::basic_ostream\fP. To control the associated sequence, an instance of \fBstd::basic_filebuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbasic_ostream\fP"
.br
.RI "\fIControlling output.
.PP
This is the base class for all output streams. It provides text formatting of all builtin types, and communicates with any class derived from \fBbasic_streambuf\fP to do the actual output. \fP"
.ti -1c
.RI "class \fBbasic_ostringstream\fP"
.br
.RI "\fIControlling output for std::string.
.PP
This class supports writing to objects of type \fBstd::basic_string\fP, using the inherited functions from \fBstd::basic_ostream\fP. To control the associated sequence, an instance of \fBstd::basic_stringbuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbasic_regex\fP"
.br
.ti -1c
.RI "class \fBbasic_streambuf\fP"
.br
.RI "\fIThe actual work of input and output (interface). \fP"
.ti -1c
.RI "class \fBbasic_string\fP"
.br
.RI "\fIManaging sequences of characters and character-like objects. \fP"
.ti -1c
.RI "class \fBbasic_stringbuf\fP"
.br
.RI "\fIThe actual work of input and output (for std::string).
.PP
This class associates either or both of its input and output sequences with a sequence of characters, which can be initialized from, or made available as, a \fC\fBstd::basic_string\fP\fP. (Paraphrased from [27.7.1]/1.). \fP"
.ti -1c
.RI "class \fBbasic_stringstream\fP"
.br
.RI "\fIControlling input and output for std::string.
.PP
This class supports reading from and writing to objects of type \fBstd::basic_string\fP, using the inherited functions from \fBstd::basic_iostream\fP. To control the associated sequence, an instance of \fBstd::basic_stringbuf\fP is used, which this page refers to as \fCsb\fP. \fP"
.ti -1c
.RI "class \fBbernoulli_distribution\fP"
.br
.RI "\fIA Bernoulli random number distribution. \fP"
.ti -1c
.RI "struct \fBbidirectional_iterator_tag\fP"
.br
.RI "\fIBidirectional iterators support a superset of forward \fBiterator\fP operations. \fP"
.ti -1c
.RI "struct \fBbinary_function\fP"
.br
.ti -1c
.RI "class \fBbinary_negate\fP"
.br
.RI "\fIOne of the \fBnegation functors\fP. \fP"
.ti -1c
.RI "class \fBbinder1st\fP"
.br
.RI "\fIOne of the \fBbinder functors\fP. \fP"
.ti -1c
.RI "class \fBbinder2nd\fP"
.br
.RI "\fIOne of the \fBbinder functors\fP. \fP"
.ti -1c
.RI "class \fBbinomial_distribution\fP"
.br
.RI "\fIA discrete binomial random number distribution. \fP"
.ti -1c
.RI "class \fBbitset\fP"
.br
.RI "\fIThe bitset class represents a \fIfixed-size\fP sequence of bits. \fP"
.ti -1c
.RI "struct \fBchar_traits\fP"
.br
.RI "\fIBasis for explicit traits specializations. \fP"
.ti -1c
.RI "struct \fBchar_traits< __gnu_cxx::character< V, I, S > >\fP"
.br
.RI "\fIchar_traits<__gnu_cxx::character> specialization. \fP"
.ti -1c
.RI "struct \fBchar_traits< char >\fP"
.br
.RI "\fI21.1.3.1 \fBchar_traits\fP specializations \fP"
.ti -1c
.RI "struct \fBchar_traits< wchar_t >\fP"
.br
.RI "\fI21.1.3.2 \fBchar_traits\fP specializations \fP"
.ti -1c
.RI "class \fBcodecvt\fP"
.br
.RI "\fIclass \fBcodecvt\fP [22.2.1.5]. NB: Generic, mostly useless implementation. \fP"
.ti -1c
.RI "class \fBcodecvt< _InternT, _ExternT, encoding_state >\fP"
.br
.RI "\fIcodecvt<InternT, _ExternT, encoding_state> specialization. \fP"
.ti -1c
.RI "class \fBcodecvt< char, char, mbstate_t >\fP"
.br
.RI "\fIclass \fBcodecvt<char, char, mbstate_t>\fP specialization. \fP"
.ti -1c
.RI "class \fBcodecvt< wchar_t, char, mbstate_t >\fP"
.br
.RI "\fIclass \fBcodecvt<wchar_t, char, mbstate_t>\fP specialization. \fP"
.ti -1c
.RI "class \fBcodecvt_base\fP"
.br
.RI "\fIEmpty base class for \fBcodecvt\fP facet [22.2.1.5]. \fP"
.ti -1c
.RI "class \fBcodecvt_byname\fP"
.br
.RI "\fIclass \fBcodecvt_byname\fP [22.2.1.6]. \fP"
.ti -1c
.RI "class \fBcollate\fP"
.br
.RI "\fIFacet for localized string comparison. \fP"
.ti -1c
.RI "class \fBcollate_byname\fP"
.br
.RI "\fIclass \fBcollate_byname\fP [22.2.4.2]. \fP"
.ti -1c
.RI "struct \fBcomplex\fP"
.br
.ti -1c
.RI "class \fBcondition_variable\fP"
.br
.RI "\fI\fBcondition_variable\fP \fP"
.ti -1c
.RI "class \fBcondition_variable_any\fP"
.br
.RI "\fI\fBcondition_variable_any\fP \fP"
.ti -1c
.RI "class \fBconst_mem_fun1_ref_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBconst_mem_fun1_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBconst_mem_fun_ref_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBconst_mem_fun_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBctype\fP"
.br
.RI "\fITemplate \fBctype\fP facet. \fP"
.ti -1c
.RI "class \fBctype< char >\fP"
.br
.RI "\fIThe \fBctype<char>\fP specialization. \fP"
.ti -1c
.RI "class \fBctype< wchar_t >\fP"
.br
.RI "\fIThe \fBctype<wchar_t>\fP specialization. \fP"
.ti -1c
.RI "struct \fBctype_base\fP"
.br
.RI "\fIBase class for \fBctype\fP. \fP"
.ti -1c
.RI "class \fBctype_byname\fP"
.br
.RI "\fIclass \fBctype_byname\fP [22.2.1.2]. \fP"
.ti -1c
.RI "class \fBctype_byname< char >\fP"
.br
.RI "\fI22.2.1.4 Class \fBctype_byname\fP specializations. \fP"
.ti -1c
.RI "struct \fBdefault_delete\fP"
.br
.RI "\fIPrimary template, \fBdefault_delete\fP. \fP"
.ti -1c
.RI "struct \fBdefault_delete< _Tp[]>\fP"
.br
.RI "\fISpecialization, \fBdefault_delete\fP. \fP"
.ti -1c
.RI "struct \fBdefer_lock_t\fP"
.br
.RI "\fIDo not acquire ownership of the \fBmutex\fP. \fP"
.ti -1c
.RI "class \fBdeque\fP"
.br
.RI "\fIA standard container using fixed-size memory allocation and constant-time manipulation of elements at either end. \fP"
.ti -1c
.RI "class \fBdiscard_block\fP"
.br
.ti -1c
.RI "struct \fBdivides\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "class \fBdomain_error\fP"
.br
.ti -1c
.RI "struct \fBequal_to\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "class \fBerror_category\fP"
.br
.RI "\fI\fBerror_category\fP \fP"
.ti -1c
.RI "struct \fBerror_code\fP"
.br
.RI "\fI\fBerror_code\fP \fP"
.ti -1c
.RI "struct \fBerror_condition\fP"
.br
.RI "\fI\fBerror_condition\fP \fP"
.ti -1c
.RI "class \fBexception\fP"
.br
.RI "\fIBase class for all library exceptions. \fP"
.ti -1c
.RI "class \fBexponential_distribution\fP"
.br
.RI "\fIAn exponential continuous distribution for random numbers. \fP"
.ti -1c
.RI "struct \fBextent\fP"
.br
.RI "\fI\fBextent\fP \fP"
.ti -1c
.RI "struct \fBforward_iterator_tag\fP"
.br
.RI "\fIForward iterators support a superset of input \fBiterator\fP operations. \fP"
.ti -1c
.RI "class \fBforward_list\fP"
.br
.RI "\fIA standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence. \fP"
.ti -1c
.RI "class \fBfpos\fP"
.br
.RI "\fIClass representing stream positions. \fP"
.ti -1c
.RI "class \fBfront_insert_iterator\fP"
.br
.RI "\fITurns assignment into insertion. \fP"
.ti -1c
.RI "class \fBfunction< _Res(_ArgTypes...)>\fP"
.br
.RI "\fIclass function \fP"
.ti -1c
.RI "class \fBgamma_distribution\fP"
.br
.RI "\fIA gamma continuous distribution for random numbers. \fP"
.ti -1c
.RI "class \fBgeometric_distribution\fP"
.br
.RI "\fIA discrete geometric random number distribution. \fP"
.ti -1c
.RI "struct \fBgreater\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "struct \fBgreater_equal\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "class \fBgslice\fP"
.br
.RI "\fIClass defining multi-dimensional subset of an \fBarray\fP. \fP"
.ti -1c
.RI "class \fBgslice_array\fP"
.br
.RI "\fIReference to multi-dimensional subset of an \fBarray\fP. \fP"
.ti -1c
.RI "struct \fBhas_virtual_destructor\fP"
.br
.RI "\fI\fBhas_virtual_destructor\fP \fP"
.ti -1c
.RI "struct \fBhash\fP"
.br
.RI "\fIClass template \fBhash\fP. \fP"
.ti -1c
.RI "struct \fBhash< _Tp * >\fP"
.br
.RI "\fIPartial specializations for pointer types. \fP"
.ti -1c
.RI "class \fBindirect_array\fP"
.br
.RI "\fIReference to arbitrary subset of an \fBarray\fP. \fP"
.ti -1c
.RI "class \fBinitializer_list\fP"
.br
.RI "\fI\fBinitializer_list\fP \fP"
.ti -1c
.RI "struct \fBinput_iterator_tag\fP"
.br
.RI "\fIMarking input iterators. \fP"
.ti -1c
.RI "class \fBinsert_iterator\fP"
.br
.RI "\fITurns assignment into insertion. \fP"
.ti -1c
.RI "struct \fBintegral_constant\fP"
.br
.RI "\fI\fBintegral_constant\fP \fP"
.ti -1c
.RI "class \fBinvalid_argument\fP"
.br
.ti -1c
.RI "class \fBios_base\fP"
.br
.RI "\fIThe base of the I/O class hierarchy.
.PP
This class defines everything that can be defined about I/O that does not depend on the type of characters being input or output. Most people will only see \fC\fBios_base\fP\fP when they need to specify the full name of the various I/O flags (e.g., the openmodes). \fP"
.ti -1c
.RI "struct \fBis_abstract\fP"
.br
.RI "\fI\fBis_abstract\fP \fP"
.ti -1c
.RI "struct \fBis_arithmetic\fP"
.br
.RI "\fI\fBis_arithmetic\fP \fP"
.ti -1c
.RI "struct \fBis_array\fP"
.br
.RI "\fI\fBis_array\fP \fP"
.ti -1c
.RI "struct \fBis_bind_expression\fP"
.br
.RI "\fIDetermines if the given type _Tp is a function object should be treated as a subexpression when evaluating calls to function objects returned by \fBbind()\fP. [TR1 3.6.1]. \fP"
.ti -1c
.RI "struct \fBis_bind_expression< _Bind< _Signature > >\fP"
.br
.RI "\fIClass template _Bind is always a bind expression. \fP"
.ti -1c
.RI "struct \fBis_bind_expression< _Bind_result< _Result, _Signature > >\fP"
.br
.RI "\fIClass template _Bind_result is always a bind expression. \fP"
.ti -1c
.RI "struct \fBis_class\fP"
.br
.RI "\fI\fBis_class\fP \fP"
.ti -1c
.RI "struct \fBis_compound\fP"
.br
.RI "\fI\fBis_compound\fP \fP"
.ti -1c
.RI "struct \fBis_const\fP"
.br
.RI "\fI\fBis_const\fP \fP"
.ti -1c
.RI "struct \fBis_empty\fP"
.br
.RI "\fI\fBis_empty\fP \fP"
.ti -1c
.RI "struct \fBis_enum\fP"
.br
.RI "\fI\fBis_enum\fP \fP"
.ti -1c
.RI "struct \fBis_error_code_enum\fP"
.br
.RI "\fI\fBis_error_code_enum\fP \fP"
.ti -1c
.RI "struct \fBis_error_condition_enum\fP"
.br
.RI "\fI\fBis_error_condition_enum\fP \fP"
.ti -1c
.RI "struct \fBis_floating_point\fP"
.br
.RI "\fI\fBis_floating_point\fP \fP"
.ti -1c
.RI "struct \fBis_function\fP"
.br
.RI "\fI\fBis_function\fP \fP"
.ti -1c
.RI "struct \fBis_fundamental\fP"
.br
.RI "\fI\fBis_fundamental\fP \fP"
.ti -1c
.RI "struct \fBis_integral\fP"
.br
.RI "\fI\fBis_integral\fP \fP"
.ti -1c
.RI "struct \fBis_lvalue_reference\fP"
.br
.RI "\fI\fBis_lvalue_reference\fP \fP"
.ti -1c
.RI "struct \fBis_member_function_pointer\fP"
.br
.RI "\fI\fBis_member_function_pointer\fP \fP"
.ti -1c
.RI "struct \fBis_member_object_pointer\fP"
.br
.RI "\fI\fBis_member_object_pointer\fP \fP"
.ti -1c
.RI "struct \fBis_object\fP"
.br
.RI "\fI\fBis_object\fP \fP"
.ti -1c
.RI "struct \fBis_placeholder\fP"
.br
.RI "\fIDetermines if the given type _Tp is a placeholder in a \fBbind()\fP expression and, if so, which placeholder it is. [TR1 3.6.2]. \fP"
.ti -1c
.RI "struct \fBis_placeholder< _Placeholder< _Num > >\fP"
.br
.ti -1c
.RI "struct \fBis_pointer\fP"
.br
.RI "\fI\fBis_pointer\fP \fP"
.ti -1c
.RI "struct \fBis_polymorphic\fP"
.br
.RI "\fI\fBis_polymorphic\fP \fP"
.ti -1c
.RI "struct \fBis_reference\fP"
.br
.RI "\fI\fBis_reference\fP \fP"
.ti -1c
.RI "struct \fBis_rvalue_reference\fP"
.br
.RI "\fI\fBis_rvalue_reference\fP \fP"
.ti -1c
.RI "struct \fBis_same\fP"
.br
.RI "\fI\fBis_same\fP \fP"
.ti -1c
.RI "struct \fBis_scalar\fP"
.br
.RI "\fI\fBis_scalar\fP \fP"
.ti -1c
.RI "struct \fBis_union\fP"
.br
.RI "\fI\fBis_union\fP \fP"
.ti -1c
.RI "struct \fBis_void\fP"
.br
.RI "\fI\fBis_void\fP \fP"
.ti -1c
.RI "struct \fBis_volatile\fP"
.br
.RI "\fI\fBis_volatile\fP \fP"
.ti -1c
.RI "class \fBistream_iterator\fP"
.br
.RI "\fIProvides input \fBiterator\fP semantics for streams. \fP"
.ti -1c
.RI "class \fBistreambuf_iterator\fP"
.br
.RI "\fIProvides input \fBiterator\fP semantics for streambufs. \fP"
.ti -1c
.RI "struct \fBiterator\fP"
.br
.RI "\fICommon iterator class. \fP"
.ti -1c
.RI "struct \fBiterator_traits\fP"
.br
.ti -1c
.RI "class \fBlength_error\fP"
.br
.ti -1c
.RI "struct \fBless\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "struct \fBless_equal\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "class \fBlinear_congruential\fP"
.br
.RI "\fIA model of a linear congruential random number generator. \fP"
.ti -1c
.RI "class \fBlist\fP"
.br
.RI "\fIA standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence. \fP"
.ti -1c
.RI "class \fBlocale\fP"
.br
.RI "\fIContainer class for localization functionality. \fP"
.ti -1c
.RI "class \fBlock_error\fP"
.br
.RI "\fIThrown to indicate errors with lock operations. \fP"
.ti -1c
.RI "class \fBlock_guard\fP"
.br
.RI "\fIScoped lock idiom. \fP"
.ti -1c
.RI "class \fBlogic_error\fP"
.br
.RI "\fIOne of two subclasses of \fBexception\fP. \fP"
.ti -1c
.RI "struct \fBlogical_and\fP"
.br
.RI "\fIOne of the \fBBoolean operations functors\fP. \fP"
.ti -1c
.RI "struct \fBlogical_not\fP"
.br
.RI "\fIOne of the \fBBoolean operations functors\fP. \fP"
.ti -1c
.RI "struct \fBlogical_or\fP"
.br
.RI "\fIOne of the \fBBoolean operations functors\fP. \fP"
.ti -1c
.RI "class \fBmap\fP"
.br
.RI "\fIA standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time. \fP"
.ti -1c
.RI "class \fBmask_array\fP"
.br
.RI "\fIReference to selected subset of an \fBarray\fP. \fP"
.ti -1c
.RI "class \fBmatch_results\fP"
.br
.RI "\fIThe results of a match or search operation. \fP"
.ti -1c
.RI "class \fBmem_fun1_ref_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBmem_fun1_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBmem_fun_ref_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBmem_fun_t\fP"
.br
.RI "\fIOne of the \fBadaptors for member pointers\fP. \fP"
.ti -1c
.RI "class \fBmessages\fP"
.br
.RI "\fIFacet for handling message catalogs. \fP"
.ti -1c
.RI "struct \fBmessages_base\fP"
.br
.RI "\fIMessages facet base class providing catalog typedef. \fP"
.ti -1c
.RI "class \fBmessages_byname\fP"
.br
.RI "\fIclass \fBmessages_byname\fP [22.2.7.2]. \fP"
.ti -1c
.RI "struct \fBminus\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "struct \fBmodulus\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "class \fBmoney_base\fP"
.br
.RI "\fIMoney format ordering data. \fP"
.ti -1c
.RI "class \fBmoney_get\fP"
.br
.RI "\fIFacet for parsing monetary amounts. \fP"
.ti -1c
.RI "class \fBmoney_put\fP"
.br
.RI "\fIFacet for outputting monetary amounts. \fP"
.ti -1c
.RI "class \fBmoneypunct\fP"
.br
.RI "\fIFacet for formatting data for money amounts. \fP"
.ti -1c
.RI "class \fBmoneypunct_byname\fP"
.br
.RI "\fIclass \fBmoneypunct_byname\fP [22.2.6.4]. \fP"
.ti -1c
.RI "class \fBmove_iterator\fP"
.br
.ti -1c
.RI "class \fBmultimap\fP"
.br
.RI "\fIA standard container made up of (key,value) pairs, which can be retrieved based on a key, in logarithmic time. \fP"
.ti -1c
.RI "struct \fBmultiplies\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "class \fBmultiset\fP"
.br
.RI "\fIA standard container made up of elements, which can be retrieved in logarithmic time. \fP"
.ti -1c
.RI "class \fBmutex\fP"
.br
.RI "\fI\fBmutex\fP \fP"
.ti -1c
.RI "struct \fBnegate\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "class \fBnormal_distribution\fP"
.br
.RI "\fIA normal continuous distribution for random numbers. \fP"
.ti -1c
.RI "struct \fBnot_equal_to\fP"
.br
.RI "\fIOne of the \fBcomparison functors\fP. \fP"
.ti -1c
.RI "class \fBnum_get\fP"
.br
.RI "\fIFacet for parsing number strings. \fP"
.ti -1c
.RI "class \fBnum_put\fP"
.br
.RI "\fIFacet for converting numbers to strings. \fP"
.ti -1c
.RI "struct \fBnumeric_limits\fP"
.br
.RI "\fIProperties of fundamental types. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< bool >\fP"
.br
.RI "\fI\fBnumeric_limits<bool>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< char >\fP"
.br
.RI "\fI\fBnumeric_limits<char>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< char16_t >\fP"
.br
.RI "\fI\fBnumeric_limits<char16_t>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< char32_t >\fP"
.br
.RI "\fI\fBnumeric_limits<char32_t>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< double >\fP"
.br
.RI "\fI\fBnumeric_limits<double>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< float >\fP"
.br
.RI "\fI\fBnumeric_limits<float>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< int >\fP"
.br
.RI "\fI\fBnumeric_limits<int>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< long >\fP"
.br
.RI "\fI\fBnumeric_limits<long>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< long double >\fP"
.br
.RI "\fI\fBnumeric_limits<long double>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< long long >\fP"
.br
.RI "\fI\fBnumeric_limits<long long>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< short >\fP"
.br
.RI "\fI\fBnumeric_limits<short>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< signed char >\fP"
.br
.RI "\fI\fBnumeric_limits<signed char>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< unsigned char >\fP"
.br
.RI "\fI\fBnumeric_limits<unsigned char>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< unsigned int >\fP"
.br
.RI "\fI\fBnumeric_limits<unsigned int>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< unsigned long >\fP"
.br
.RI "\fI\fBnumeric_limits<unsigned long>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< unsigned long long >\fP"
.br
.RI "\fI\fBnumeric_limits<unsigned long long>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< unsigned short >\fP"
.br
.RI "\fI\fBnumeric_limits<unsigned short>\fP specialization. \fP"
.ti -1c
.RI "struct \fBnumeric_limits< wchar_t >\fP"
.br
.RI "\fI\fBnumeric_limits<wchar_t>\fP specialization. \fP"
.ti -1c
.RI "class \fBnumpunct\fP"
.br
.RI "\fINumpunct facet. \fP"
.ti -1c
.RI "class \fBnumpunct_byname\fP"
.br
.RI "\fIclass \fBnumpunct_byname\fP [22.2.3.2]. \fP"
.ti -1c
.RI "struct \fBonce_flag\fP"
.br
.RI "\fI\fBonce_flag\fP \fP"
.ti -1c
.RI "class \fBostream_iterator\fP"
.br
.RI "\fIProvides output \fBiterator\fP semantics for streams. \fP"
.ti -1c
.RI "class \fBostreambuf_iterator\fP"
.br
.RI "\fIProvides output \fBiterator\fP semantics for streambufs. \fP"
.ti -1c
.RI "class \fBout_of_range\fP"
.br
.ti -1c
.RI "struct \fBoutput_iterator_tag\fP"
.br
.RI "\fIMarking output iterators. \fP"
.ti -1c
.RI "class \fBoverflow_error\fP"
.br
.ti -1c
.RI "struct \fBpair\fP"
.br
.RI "\fI\fBpair\fP holds two objects of arbitrary type. \fP"
.ti -1c
.RI "struct \fBplus\fP"
.br
.RI "\fIOne of the \fBmath functors\fP. \fP"
.ti -1c
.RI "class \fBpointer_to_binary_function\fP"
.br
.RI "\fIOne of the \fBadaptors for function pointers\fP. \fP"
.ti -1c
.RI "class \fBpointer_to_unary_function\fP"
.br
.RI "\fIOne of the \fBadaptors for function pointers\fP. \fP"
.ti -1c
.RI "class \fBpoisson_distribution\fP"
.br
.RI "\fIA discrete Poisson random number distribution. \fP"
.ti -1c
.RI "class \fBpriority_queue\fP"
.br
.RI "\fIA standard container automatically sorting its contents. \fP"
.ti -1c
.RI "class \fBqueue\fP"
.br
.RI "\fIA standard container giving FIFO behavior. \fP"
.ti -1c
.RI "struct \fBrandom_access_iterator_tag\fP"
.br
.RI "\fIRandom-access iterators support a superset of bidirectional \fBiterator\fP operations. \fP"
.ti -1c
.RI "class \fBrandom_device\fP"
.br
.ti -1c
.RI "class \fBrange_error\fP"
.br
.ti -1c
.RI "struct \fBrank\fP"
.br
.RI "\fI\fBrank\fP \fP"
.ti -1c
.RI "struct \fBratio\fP"
.br
.RI "\fIProvides compile-time rational arithmetic. \fP"
.ti -1c
.RI "struct \fBratio_add\fP"
.br
.RI "\fI\fBratio_add\fP \fP"
.ti -1c
.RI "struct \fBratio_divide\fP"
.br
.RI "\fI\fBratio_divide\fP \fP"
.ti -1c
.RI "struct \fBratio_equal\fP"
.br
.RI "\fI\fBratio_equal\fP \fP"
.ti -1c
.RI "struct \fBratio_greater\fP"
.br
.RI "\fI\fBratio_greater\fP \fP"
.ti -1c
.RI "struct \fBratio_greater_equal\fP"
.br
.RI "\fI\fBratio_greater_equal\fP \fP"
.ti -1c
.RI "struct \fBratio_less\fP"
.br
.RI "\fI\fBratio_less\fP \fP"
.ti -1c
.RI "struct \fBratio_less_equal\fP"
.br
.RI "\fI\fBratio_less_equal\fP \fP"
.ti -1c
.RI "struct \fBratio_multiply\fP"
.br
.RI "\fI\fBratio_multiply\fP \fP"
.ti -1c
.RI "struct \fBratio_not_equal\fP"
.br
.RI "\fI\fBratio_not_equal\fP \fP"
.ti -1c
.RI "struct \fBratio_subtract\fP"
.br
.RI "\fI\fBratio_subtract\fP \fP"
.ti -1c
.RI "class \fBraw_storage_iterator\fP"
.br
.ti -1c
.RI "class \fBrecursive_mutex\fP"
.br
.RI "\fI\fBrecursive_mutex\fP \fP"
.ti -1c
.RI "class \fBrecursive_timed_mutex\fP"
.br
.RI "\fI\fBrecursive_timed_mutex\fP \fP"
.ti -1c
.RI "class \fBreference_wrapper\fP"
.br
.RI "\fI\fBreference_wrapper\fP \fP"
.ti -1c
.RI "class \fBregex_error\fP"
.br
.RI "\fIA regular expression \fBexception\fP class.
.PP
The regular expression library throws objects of this class on error. \fP"
.ti -1c
.RI "class \fBregex_iterator\fP"
.br
.ti -1c
.RI "class \fBregex_token_iterator\fP"
.br
.ti -1c
.RI "struct \fBregex_traits\fP"
.br
.RI "\fIDescribes aspects of a regular expression. \fP"
.ti -1c
.RI "struct \fBremove_all_extents\fP"
.br
.RI "\fI\fBremove_all_extents\fP \fP"
.ti -1c
.RI "struct \fBremove_const\fP"
.br
.RI "\fI\fBremove_const\fP \fP"
.ti -1c
.RI "struct \fBremove_cv\fP"
.br
.RI "\fI\fBremove_cv\fP \fP"
.ti -1c
.RI "struct \fBremove_extent\fP"
.br
.RI "\fI\fBremove_extent\fP \fP"
.ti -1c
.RI "struct \fBremove_pointer\fP"
.br
.RI "\fI\fBremove_pointer\fP \fP"
.ti -1c
.RI "struct \fBremove_reference\fP"
.br
.RI "\fI\fBremove_reference\fP \fP"
.ti -1c
.RI "struct \fBremove_volatile\fP"
.br
.RI "\fI\fBremove_volatile\fP \fP"
.ti -1c
.RI "class \fBresult_of< _Functor(_ArgTypes...)>\fP"
.br
.ti -1c
.RI "class \fBreverse_iterator\fP"
.br
.ti -1c
.RI "class \fBruntime_error\fP"
.br
.RI "\fIOne of two subclasses of \fBexception\fP. \fP"
.ti -1c
.RI "class \fBset\fP"
.br
.RI "\fIA standard container made up of unique keys, which can be retrieved in logarithmic time. \fP"
.ti -1c
.RI "class \fBslice\fP"
.br
.RI "\fIClass defining one-dimensional subset of an \fBarray\fP. \fP"
.ti -1c
.RI "class \fBslice_array\fP"
.br
.RI "\fIReference to one-dimensional subset of an \fBarray\fP. \fP"
.ti -1c
.RI "class \fBstack\fP"
.br
.RI "\fIA standard container giving FILO behavior. \fP"
.ti -1c
.RI "class \fBsub_match\fP"
.br
.ti -1c
.RI "class \fBsystem_error\fP"
.br
.RI "\fIThrown to indicate error code of underlying system. \fP"
.ti -1c
.RI "class \fBthread\fP"
.br
.RI "\fI\fBthread\fP \fP"
.ti -1c
.RI "class \fBtime_base\fP"
.br
.RI "\fITime format ordering data. \fP"
.ti -1c
.RI "class \fBtime_get\fP"
.br
.RI "\fIFacet for parsing dates and times. \fP"
.ti -1c
.RI "class \fBtime_get_byname\fP"
.br
.RI "\fIclass \fBtime_get_byname\fP [22.2.5.2]. \fP"
.ti -1c
.RI "class \fBtime_put\fP"
.br
.RI "\fIFacet for outputting dates and times. \fP"
.ti -1c
.RI "class \fBtime_put_byname\fP"
.br
.RI "\fIclass \fBtime_put_byname\fP [22.2.5.4]. \fP"
.ti -1c
.RI "class \fBtimed_mutex\fP"
.br
.RI "\fI\fBtimed_mutex\fP \fP"
.ti -1c
.RI "struct \fBtry_to_lock_t\fP"
.br
.RI "\fITry to acquire ownership of the \fBmutex\fP without blocking. \fP"
.ti -1c
.RI "class \fBtuple\fP"
.br
.RI "\fI\fBtuple\fP \fP"
.ti -1c
.RI "class \fBtuple< _T1, _T2 >\fP"
.br
.RI "\fI\fBtuple\fP (2-element), with construction and assignment from a \fBpair\fP. \fP"
.ti -1c
.RI "struct \fBtuple_element< 0, tuple< _Head, _Tail...> >\fP"
.br
.ti -1c
.RI "struct \fBtuple_element< __i, tuple< _Head, _Tail...> >\fP"
.br
.ti -1c
.RI "struct \fBtuple_size< tuple< _Elements...> >\fP"
.br
.RI "\fIclass tuple_size \fP"
.ti -1c
.RI "class \fBtype_info\fP"
.br
.RI "\fIPart of RTTI. \fP"
.ti -1c
.RI "struct \fBunary_function\fP"
.br
.ti -1c
.RI "class \fBunary_negate\fP"
.br
.RI "\fIOne of the \fBnegation functors\fP. \fP"
.ti -1c
.RI "class \fBunderflow_error\fP"
.br
.ti -1c
.RI "class \fBuniform_int\fP"
.br
.RI "\fIUniform discrete distribution for random numbers. A discrete random distribution on the range $[min, max]$ with equal probability throughout the range. \fP"
.ti -1c
.RI "class \fBuniform_real\fP"
.br
.RI "\fIUniform continuous distribution for random numbers. \fP"
.ti -1c
.RI "class \fBunique_lock\fP"
.br
.RI "\fI\fBunique_lock\fP \fP"
.ti -1c
.RI "class \fBunique_ptr\fP"
.br
.RI "\fI20.7.12.2 \fBunique_ptr\fP for single objects. \fP"
.ti -1c
.RI "class \fBunique_ptr< _Tp[], _Tp_Deleter >\fP"
.br
.RI "\fI20.7.12.3 \fBunique_ptr\fP for \fBarray\fP objects with a runtime length \fP"
.ti -1c
.RI "class \fBunordered_map\fP"
.br
.RI "\fIA standard container composed of unique keys (containing at most one of each key value) that associates values of another type with the keys. \fP"
.ti -1c
.RI "class \fBunordered_multimap\fP"
.br
.RI "\fIA standard container composed of equivalent keys (possibly containing multiple of each key value) that associates values of another type with the keys. \fP"
.ti -1c
.RI "class \fBunordered_multiset\fP"
.br
.RI "\fIA standard container composed of equivalent keys (possibly containing multiple of each key value) in which the elements' keys are the elements themselves. \fP"
.ti -1c
.RI "class \fBunordered_set\fP"
.br
.RI "\fIA standard container composed of unique keys (containing at most one of each key value) in which the elements' keys are the elements themselves. \fP"
.ti -1c
.RI "class \fBvalarray\fP"
.br
.RI "\fISmart \fBarray\fP designed to support numeric processing. \fP"
.ti -1c
.RI "class \fBvariate_generator\fP"
.br
.ti -1c
.RI "class \fBvector\fP"
.br
.RI "\fIA standard container which offers fixed time access to individual elements in any order. \fP"
.ti -1c
.RI "class \fBvector< bool, _Alloc >\fP"
.br
.RI "\fIA specialization of \fBvector\fP for booleans which offers fixed time access to individual elements in any order. \fP"
.ti -1c
.RI "class \fBxor_combine\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct std::__atomic_flag_base \fB__atomic_flag_base\fP"
.br
.ti -1c
.RI "typedef FILE \fB__c_file\fP"
.br
.ti -1c
.RI "typedef __locale_t \fB__c_locale\fP"
.br
.ti -1c
.RI "typedef __gthread_mutex_t \fB__c_lock\fP"
.br
.ti -1c
.RI "typedef unsigned long \fB_Bit_type\fP"
.br
.ti -1c
.RI "typedef \fBatomic_short\fP \fBatomic_int_fast16_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_int\fP \fBatomic_int_fast32_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_llong\fP \fBatomic_int_fast64_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_schar\fP \fBatomic_int_fast8_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_short\fP \fBatomic_int_least16_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_int\fP \fBatomic_int_least32_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_llong\fP \fBatomic_int_least64_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_schar\fP \fBatomic_int_least8_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_llong\fP \fBatomic_intmax_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_long\fP \fBatomic_intptr_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_long\fP \fBatomic_ptrdiff_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ulong\fP \fBatomic_size_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_long\fP \fBatomic_ssize_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ushort\fP \fBatomic_uint_fast16_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_uint\fP \fBatomic_uint_fast32_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ullong\fP \fBatomic_uint_fast64_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_uchar\fP \fBatomic_uint_fast8_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ushort\fP \fBatomic_uint_least16_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_uint\fP \fBatomic_uint_least32_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ullong\fP \fBatomic_uint_least64_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_uchar\fP \fBatomic_uint_least8_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ullong\fP \fBatomic_uintmax_t\fP"
.br
.ti -1c
.RI "typedef \fBatomic_ulong\fP \fBatomic_uintptr_t\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000000000000000000 > \fBatto\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 100 > \fBcenti\fP"
.br
.ti -1c
.RI "typedef \fBmatch_results\fP< const char * > \fBcmatch\fP"
.br
.ti -1c
.RI "typedef \fBregex_iterator\fP< const char * > \fBcregex_iterator\fP"
.br
.ti -1c
.RI "typedef \fBregex_token_iterator\fP< const char * > \fBcregex_token_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< const char * > \fBcsub_match\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 10, 1 > \fBdeca\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 10 > \fBdeci\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000000000000000000, 1 > \fBexa\fP"
.br
.ti -1c
.RI "typedef \fBintegral_constant\fP< bool, false > \fBfalse_type\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000000000000000 > \fBfemto\fP"
.br
.ti -1c
.RI "typedef \fBbasic_filebuf\fP< char > \fBfilebuf\fP"
.br
.ti -1c
.RI "typedef \fBbasic_fstream\fP< char > \fBfstream\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000000000, 1 > \fBgiga\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 100, 1 > \fBhecto\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ifstream\fP< char > \fBifstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ios\fP< char > \fBios\fP"
.br
.ti -1c
.RI "typedef \fBbasic_iostream\fP< char > \fBiostream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_istream\fP< char > \fBistream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_istringstream\fP< char > \fBistringstream\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000, 1 > \fBkilo\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000000, 1 > \fBmega\fP"
.br
.ti -1c
.RI "typedef enum \fBstd::memory_order\fP \fBmemory_order\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000000 > \fBmicro\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000 > \fBmilli\fP"
.br
.ti -1c
.RI "typedef \fBlinear_congruential\fP< unsigned long, 48271, 0, 2147483647 > \fBminstd_rand\fP"
.br
.ti -1c
.RI "typedef \fBlinear_congruential\fP< unsigned long, 16807, 0, 2147483647 > \fBminstd_rand0\fP"
.br
.ti -1c
.RI "typedef mersenne_twister< unsigned long, 32, 624, 397, 31, 0x9908b0dful, 11, 7, 0x9d2c5680ul, 15, 0xefc60000ul, 18 > \fBmt19937\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000000000 > \fBnano\fP"
.br
.ti -1c
.RI "typedef void(* \fBnew_handler\fP )()"
.br
.ti -1c
.RI "typedef \fBbasic_ofstream\fP< char > \fBofstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ostream\fP< char > \fBostream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ostringstream\fP< char > \fBostringstream\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000000000000000, 1 > \fBpeta\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1, 1000000000000 > \fBpico\fP"
.br
.ti -1c
.RI "typedef \fBdiscard_block\fP< subtract_with_carry< unsigned long,(1UL<< 24), 10, 24 >, 223, 24 > \fBranlux3\fP"
.br
.ti -1c
.RI "typedef \fBdiscard_block\fP< subtract_with_carry_01< float, 24, 10, 24 >, 223, 24 > \fBranlux3_01\fP"
.br
.ti -1c
.RI "typedef \fBdiscard_block\fP< subtract_with_carry< unsigned long,(1UL<< 24), 10, 24 >, 389, 24 > \fBranlux4\fP"
.br
.ti -1c
.RI "typedef \fBdiscard_block\fP< subtract_with_carry_01< float, 24, 10, 24 >, 389, 24 > \fBranlux4_01\fP"
.br
.ti -1c
.RI "typedef subtract_with_carry_01< double, 48, 5, 12 > \fBranlux64_base_01\fP"
.br
.ti -1c
.RI "typedef subtract_with_carry_01< float, 24, 10, 24 > \fBranlux_base_01\fP"
.br
.ti -1c
.RI "typedef \fBbasic_regex\fP< char > \fBregex\fP"
.br
.ti -1c
.RI "typedef \fBmatch_results\fP< string::const_iterator > \fBsmatch\fP"
.br
.ti -1c
.RI "typedef \fBregex_iterator\fP< string::const_iterator > \fBsregex_iterator\fP"
.br
.ti -1c
.RI "typedef \fBregex_token_iterator\fP< string::const_iterator > \fBsregex_token_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< string::const_iterator > \fBssub_match\fP"
.br
.ti -1c
.RI "typedef \fBbasic_streambuf\fP< char > \fBstreambuf\fP"
.br
.ti -1c
.RI "typedef long long \fBstreamoff\fP"
.br
.ti -1c
.RI "typedef \fBfpos\fP< mbstate_t > \fBstreampos\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBstreamsize\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< char > \fBstring\fP"
.br
.ti -1c
.RI "typedef \fBbasic_stringbuf\fP< char > \fBstringbuf\fP"
.br
.ti -1c
.RI "typedef \fBbasic_stringstream\fP< char > \fBstringstream\fP"
.br
.ti -1c
.RI "typedef \fBratio\fP< 1000000000000, 1 > \fBtera\fP"
.br
.ti -1c
.RI "typedef void(* \fBterminate_handler\fP )()"
.br
.ti -1c
.RI "typedef \fBintegral_constant\fP< bool, true > \fBtrue_type\fP"
.br
.ti -1c
.RI "typedef \fBfpos\fP< mbstate_t > \fBu16streampos\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< char16_t > \fBu16string\fP"
.br
.ti -1c
.RI "typedef \fBfpos\fP< mbstate_t > \fBu32streampos\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< char32_t > \fBu32string\fP"
.br
.ti -1c
.RI "typedef void(* \fBunexpected_handler\fP )()"
.br
.ti -1c
.RI "typedef \fBmatch_results\fP< const wchar_t * > \fBwcmatch\fP"
.br
.ti -1c
.RI "typedef \fBregex_iterator\fP< const wchar_t * > \fBwcregex_iterator\fP"
.br
.ti -1c
.RI "typedef \fBregex_token_iterator\fP< const wchar_t * > \fBwcregex_token_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< const wchar_t * > \fBwcsub_match\fP"
.br
.ti -1c
.RI "typedef \fBbasic_filebuf\fP< wchar_t > \fBwfilebuf\fP"
.br
.ti -1c
.RI "typedef \fBbasic_fstream\fP< wchar_t > \fBwfstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ifstream\fP< wchar_t > \fBwifstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ios\fP< wchar_t > \fBwios\fP"
.br
.ti -1c
.RI "typedef \fBbasic_iostream\fP< wchar_t > \fBwiostream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_istream\fP< wchar_t > \fBwistream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_istringstream\fP< wchar_t > \fBwistringstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ofstream\fP< wchar_t > \fBwofstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ostream\fP< wchar_t > \fBwostream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_ostringstream\fP< wchar_t > \fBwostringstream\fP"
.br
.ti -1c
.RI "typedef \fBbasic_regex\fP< wchar_t > \fBwregex\fP"
.br
.ti -1c
.RI "typedef \fBmatch_results\fP< wstring::const_iterator > \fBwsmatch\fP"
.br
.ti -1c
.RI "typedef \fBregex_iterator\fP< wstring::const_iterator > \fBwsregex_iterator\fP"
.br
.ti -1c
.RI "typedef \fBregex_token_iterator\fP< wstring::const_iterator > \fBwsregex_token_iterator\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< wstring::const_iterator > \fBwssub_match\fP"
.br
.ti -1c
.RI "typedef \fBbasic_streambuf\fP< wchar_t > \fBwstreambuf\fP"
.br
.ti -1c
.RI "typedef \fBfpos\fP< mbstate_t > \fBwstreampos\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< wchar_t > \fBwstring\fP"
.br
.ti -1c
.RI "typedef \fBbasic_stringbuf\fP< wchar_t > \fBwstringbuf\fP"
.br
.ti -1c
.RI "typedef \fBbasic_stringstream\fP< wchar_t > \fBwstringstream\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fB_S_threshold\fP }"
.br
.ti -1c
.RI "enum { \fB_S_chunk_size\fP }"
.br
.ti -1c
.RI "enum { \fB_S_word_bit\fP }"
.br
.ti -1c
.RI "enum \fB_Ios_Fmtflags\fP { \fB_S_boolalpha\fP, \fB_S_dec\fP, \fB_S_fixed\fP, \fB_S_hex\fP, \fB_S_internal\fP, \fB_S_left\fP, \fB_S_oct\fP, \fB_S_right\fP, \fB_S_scientific\fP, \fB_S_showbase\fP, \fB_S_showpoint\fP, \fB_S_showpos\fP, \fB_S_skipws\fP, \fB_S_unitbuf\fP, \fB_S_uppercase\fP, \fB_S_adjustfield\fP, \fB_S_basefield\fP, \fB_S_floatfield\fP, \fB_S_ios_fmtflags_end\fP }"
.br
.ti -1c
.RI "enum \fB_Ios_Iostate\fP { \fB_S_goodbit\fP, \fB_S_badbit\fP, \fB_S_eofbit\fP, \fB_S_failbit\fP, \fB_S_ios_iostate_end\fP }"
.br
.ti -1c
.RI "enum \fB_Ios_Openmode\fP { \fB_S_app\fP, \fB_S_ate\fP, \fB_S_bin\fP, \fB_S_in\fP, \fB_S_out\fP, \fB_S_trunc\fP, \fB_S_ios_openmode_end\fP }"
.br
.ti -1c
.RI "enum \fB_Ios_Seekdir\fP { \fB_S_beg\fP, \fB_S_cur\fP, \fB_S_end\fP, \fB_S_ios_seekdir_end\fP }"
.br
.ti -1c
.RI "enum \fB_Manager_operation\fP { \fB__get_type_info\fP, \fB__get_functor_ptr\fP, \fB__clone_functor\fP, \fB__destroy_functor\fP }"
.br
.ti -1c
.RI "enum \fB_Rb_tree_color\fP { \fB_S_red\fP, \fB_S_black\fP }"
.br
.ti -1c
.RI "enum \fBerrc\fP { \fBaddress_family_not_supported\fP, \fBaddress_in_use\fP, \fBaddress_not_available\fP, \fBalready_connected\fP, \fBargument_list_too_long\fP, \fBargument_out_of_domain\fP, \fBbad_address\fP, \fBbad_file_descriptor\fP, \fBbroken_pipe\fP, \fBconnection_aborted\fP, \fBconnection_already_in_progress\fP, \fBconnection_refused\fP, \fBconnection_reset\fP, \fBcross_device_link\fP, \fBdestination_address_required\fP, \fBdevice_or_resource_busy\fP, \fBdirectory_not_empty\fP, \fBexecutable_format_error\fP, \fBfile_exists\fP, \fBfile_too_large\fP, \fBfilename_too_long\fP, \fBfunction_not_supported\fP, \fBhost_unreachable\fP, \fBillegal_byte_sequence\fP, \fBinappropriate_io_control_operation\fP, \fBinterrupted\fP, \fBinvalid_argument\fP, \fBinvalid_seek\fP, \fBio_error\fP, \fBis_a_directory\fP, \fBmessage_size\fP, \fBnetwork_down\fP, \fBnetwork_reset\fP, \fBnetwork_unreachable\fP, \fBno_buffer_space\fP, \fBno_child_process\fP, \fBno_lock_available\fP, \fBno_message\fP, \fBno_protocol_option\fP, \fBno_space_on_device\fP, \fBno_such_device_or_address\fP, \fBno_such_device\fP, \fBno_such_file_or_directory\fP, \fBno_such_process\fP, \fBnot_a_directory\fP, \fBnot_a_socket\fP, \fBnot_connected\fP, \fBnot_enough_memory\fP, \fBoperation_in_progress\fP, \fBoperation_not_permitted\fP, \fBoperation_not_supported\fP, \fBoperation_would_block\fP, \fBpermission_denied\fP, \fBprotocol_not_supported\fP, \fBread_only_file_system\fP, \fBresource_deadlock_would_occur\fP, \fBresource_unavailable_try_again\fP, \fBresult_out_of_range\fP, \fBtimed_out\fP, \fBtoo_many_files_open_in_system\fP, \fBtoo_many_files_open\fP, \fBtoo_many_links\fP, \fBtoo_many_symbolic_link_levels\fP, \fBwrong_protocol_type\fP }"
.br
.ti -1c
.RI "enum \fBfloat_denorm_style\fP { \fBdenorm_indeterminate\fP, \fBdenorm_absent\fP, \fBdenorm_present\fP }"
.br
.ti -1c
.RI "enum \fBfloat_round_style\fP { \fBround_indeterminate\fP, \fBround_toward_zero\fP, \fBround_to_nearest\fP, \fBround_toward_infinity\fP, \fBround_toward_neg_infinity\fP }"
.br
.ti -1c
.RI "enum \fBmemory_order\fP { \fBmemory_order_relaxed\fP, \fBmemory_order_consume\fP, \fBmemory_order_acquire\fP, \fBmemory_order_release\fP, \fBmemory_order_acq_rel\fP, \fBmemory_order_seq_cst\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _CharT > _CharT * \fB__add_grouping\fP (_CharT *__s, _CharT __sep, const char *__gbeg, size_t __gsize, const _CharT *__first, const _CharT *__last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Tp , typename _Compare > void \fB__adjust_heap\fP (_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Tp > void \fB__adjust_heap\fP (_RandomAccessIterator __first, _Distance __holeIndex, _Distance __len, _Tp __value)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance > void \fB__advance\fP (_RandomAccessIterator &__i, _Distance __n, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Distance > void \fB__advance\fP (_BidirectionalIterator &__i, _Distance __n, \fBbidirectional_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Distance > void \fB__advance\fP (_InputIterator &__i, _Distance __n, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "volatile __atomic_flag_base * \fB__atomic_flag_for_address\fP (const volatile void *__z) __attribute__((const ))"
.br
.ti -1c
.RI "void \fB__atomic_flag_wait_explicit\fP (volatile __atomic_flag_base *, \fBmemory_order\fP)"
.br
.ti -1c
.RI "\fBmemory_order\fP \fB__calculate_memory_order\fP (\fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _Member , typename _Class > _Mem_fn< _Member _Class::* > \fB__callable_functor\fP (_Member _Class::*const &__p)"
.br
.ti -1c
.RI "template<typename _Member , typename _Class > _Mem_fn< _Member _Class::* > \fB__callable_functor\fP (_Member _Class::*&__p)"
.br
.ti -1c
.RI "template<typename _Functor > _Functor & \fB__callable_functor\fP (_Functor &__f)"
.br
.ti -1c
.RI "template<typename _Facet > const _Facet & \fB__check_facet\fP (const _Facet *__f)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Compare > void \fB__chunk_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance > void \fB__chunk_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Distance __chunk_size)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__cmath_power\fP (_Tp, unsigned int)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__complex_abs\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_acos\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_acosh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__complex_arg\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_asin\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_asinh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_atan\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_atanh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_cos\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_cosh\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_exp\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_log\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_pow\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fB__complex_proj\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_sin\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_sinh\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_sqrt\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_tan\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fB__complex_tanh\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "int \fB__convert_from_v\fP (const __c_locale &__cloc __attribute__((__unused__)), char *__out, const int __size __attribute__((__unused__)), const char *__fmt,...)"
.br
.ti -1c
.RI "template<> void \fB__convert_to_v\fP (const char *, long double &, \fBios_base::iostate\fP &, const __c_locale &)"
.br
.ti -1c
.RI "template<> void \fB__convert_to_v\fP (const char *, double &, \fBios_base::iostate\fP &, const __c_locale &)"
.br
.ti -1c
.RI "template<> void \fB__convert_to_v\fP (const char *, float &, \fBios_base::iostate\fP &, const __c_locale &)"
.br
.ti -1c
.RI "template<typename _Tv > void \fB__convert_to_v\fP (const char *__in, _Tv &__out, \fBios_base::iostate\fP &__err, const __c_locale &__cloc)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _II , typename _OI > _OI \fB__copy_move_a\fP (_II __first, _II __last, _OI __result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, _CharT * >::__type \fB__copy_move_a2\fP (\fBistreambuf_iterator\fP< _CharT > __first, \fBistreambuf_iterator\fP< _CharT > __last, _CharT *__result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBostreambuf_iterator\fP< _CharT > >::__type \fB__copy_move_a2\fP (const _CharT *__first, const _CharT *__last, \fBostreambuf_iterator\fP< _CharT > __result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBostreambuf_iterator\fP< _CharT > >::__type \fB__copy_move_a2\fP (_CharT *__first, _CharT *__last, \fBostreambuf_iterator\fP< _CharT > __result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _II , typename _OI > _OI \fB__copy_move_a2\fP (_II __first, _II __last, _OI __result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, _CharT * >::__type \fB__copy_move_a2\fP (\fBistreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > >, \fBistreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > >, _CharT *)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBostreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > > >::__type \fB__copy_move_a2\fP (const _CharT *, const _CharT *, \fBostreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > >)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBostreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > > >::__type \fB__copy_move_a2\fP (_CharT *, _CharT *, \fBostreambuf_iterator\fP< _CharT, \fBchar_traits\fP< _CharT > >)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _BI1 , typename _BI2 > _BI2 \fB__copy_move_backward_a\fP (_BI1 __first, _BI1 __last, _BI2 __result)"
.br
.ti -1c
.RI "template<bool _IsMove, typename _BI1 , typename _BI2 > _BI2 \fB__copy_move_backward_a2\fP (_BI1 __first, _BI1 __last, _BI2 __result)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size , typename _OutputIterator > _OutputIterator \fB__copy_n\fP (_RandomAccessIterator __first, _Size __n, _OutputIterator __result, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _OutputIterator > _OutputIterator \fB__copy_n\fP (_InputIterator __first, _Size __n, _OutputIterator __result, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fB__copy_streambufs\fP (\fBbasic_streambuf\fP< _CharT, _Traits > *__sbin, \fBbasic_streambuf\fP< _CharT, _Traits > *__sbout)"
.br
.ti -1c
.RI "template<> \fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fBbasic_streambuf\fP< wchar_t > *__sbin, \fBbasic_streambuf\fP< wchar_t > *__sbout, bool &__ineof)"
.br
.ti -1c
.RI "template<> \fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fBbasic_streambuf\fP< char > *__sbin, \fBbasic_streambuf\fP< char > *__sbout, bool &__ineof)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fBbasic_streambuf\fP< _CharT, _Traits > *, \fBbasic_streambuf\fP< _CharT, _Traits > *, bool &)"
.br
.ti -1c
.RI "size_t \fB__deque_buf_size\fP (size_t __size)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > \fBiterator_traits\fP< _RandomAccessIterator >::difference_type \fB__distance\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBiterator_traits\fP< _InputIterator >::difference_type \fB__distance\fP (_InputIterator __first, _InputIterator __last, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 > bool \fB__equal_aux\fP (_II1 __first1, _II1 __last1, _II2 __first2)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_byte< _Tp >::__value, void >::__type \fB__fill_a\fP (_Tp *__first, _Tp *__last, const _Tp &__c)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > __gnu_cxx::__enable_if<!__is_scalar< _Tp >::__value, void >::__type \fB__fill_a\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "void \fB__fill_bvector\fP (_Bit_iterator __first, _Bit_iterator __last, bool __x)"
.br
.ti -1c
.RI "template<typename _Size , typename _Tp > __gnu_cxx::__enable_if< __is_byte< _Tp >::__value, _Tp * >::__type \fB__fill_n_a\fP (_Tp *__first, _Size __n, const _Tp &__c)"
.br
.ti -1c
.RI "template<typename _OutputIterator , typename _Size , typename _Tp > __gnu_cxx::__enable_if<!__is_scalar< _Tp >::__value, _OutputIterator >::__type \fB__fill_n_a\fP (_OutputIterator __first, _Size __n, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__final_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__final_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Tp > _RandomAccessIterator \fB__find\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp &__val, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Tp > _InputIterator \fB__find\fP (_InputIterator __first, _InputIterator __last, const _Tp &__val, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _BinaryPredicate > _BidirectionalIterator1 \fB__find_end\fP (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, \fBbidirectional_iterator_tag\fP, \fBbidirectional_iterator_tag\fP, _BinaryPredicate __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 > _BidirectionalIterator1 \fB__find_end\fP (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, \fBbidirectional_iterator_tag\fP, \fBbidirectional_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate > _ForwardIterator1 \fB__find_end\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, \fBforward_iterator_tag\fP, \fBforward_iterator_tag\fP, _BinaryPredicate __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 > _ForwardIterator1 \fB__find_end\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, \fBforward_iterator_tag\fP, \fBforward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Predicate > _RandomAccessIterator \fB__find_if\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > _InputIterator \fB__find_if\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Predicate > _RandomAccessIterator \fB__find_if_not\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > _InputIterator \fB__find_if_not\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _EuclideanRingElement > _EuclideanRingElement \fB__gcd\fP (_EuclideanRingElement __m, _EuclideanRingElement __n)"
.br
.ti -1c
.RI "template<std::size_t __i, typename _Head , typename... _Tail> __add_c_ref< _Head >::type \fB__get_helper\fP (const _Tuple_impl< __i, _Head, _Tail...> &__t)"
.br
.ti -1c
.RI "template<std::size_t __i, typename _Head , typename... _Tail> __add_ref< _Head >::type \fB__get_helper\fP (_Tuple_impl< __i, _Head, _Tail...> &__t)"
.br
.ti -1c
.RI "\fBunique_lock\fP< \fBmutex\fP > & \fB__get_once_functor_lock\fP ()"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__heap_select\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__heap_select\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _Tp > size_t \fB__iconv_adaptor\fP (size_t(*__func)(iconv_t, _Tp, size_t *, char **, size_t *), iconv_t __cd, char **__inbuf, size_t *__inbytes, char **__outbuf, size_t *__outbytes)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate , typename _Distance > _ForwardIterator \fB__inplace_stable_partition\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__inplace_stable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__inplace_stable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _CharT , typename _ValueT > _GLIBCXX_END_LDBL_NAMESPACE int \fB__int_to_char\fP (_CharT *__bufend, _ValueT __v, const _CharT *__lit, \fBios_base::fmtflags\fP __flags, bool __dec)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size , typename _Compare > void \fB__introselect\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size > void \fB__introselect\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Size __depth_limit)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size , typename _Compare > void \fB__introsort_loop\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size > void \fB__introsort_loop\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit)"
.br
.ti -1c
.RI "template<typename _Functor , typename... _Args> __gnu_cxx::__enable_if< (\fBis_pointer\fP< _Functor >::value &&\fBis_function\fP< typename \fBremove_pointer\fP< _Functor >::type >::value), typename result_of< _Functor(_Args...)>::type >::__type \fB__invoke\fP (_Functor __f, _Args &...__args)"
.br
.ti -1c
.RI "template<typename _Functor , typename... _Args> __gnu_cxx::__enable_if< (!is_member_pointer< _Functor >::value &&!\fBis_function\fP< _Functor >::value &&!\fBis_function\fP< typename \fBremove_pointer\fP< _Functor >::type >::value), typename result_of< _Functor(_Args...)>::type >::__type \fB__invoke\fP (_Functor &__f, _Args &...__args)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > bool \fB__is_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > bool \fB__is_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare , typename _Distance > bool \fB__is_heap\fP (_RandomAccessIterator __first, _Compare __comp, _Distance __n)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance > bool \fB__is_heap\fP (_RandomAccessIterator __first, _Distance __n)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Compare > _Distance \fB__is_heap_until\fP (_RandomAccessIterator __first, _Distance __n, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance > _Distance \fB__is_heap_until\fP (_RandomAccessIterator __first, _Distance __n)"
.br
.ti -1c
.RI "template<typename _Iter > \fBiterator_traits\fP< _Iter >::iterator_category \fB__iterator_category\fP (const _Iter &)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 > bool \fB__lexicographical_compare_aux\fP (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)"
.br
.ti -1c
.RI "long long \fB__lg\fP (long long __n)"
.br
.ti -1c
.RI "long \fB__lg\fP (long __n)"
.br
.ti -1c
.RI "int \fB__lg\fP (int __n)"
.br
.ti -1c
.RI "template<typename _Size > _Size \fB__lg\fP (_Size __n)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fB__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fB__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Distance , typename _Pointer , typename _Compare > void \fB__merge_adaptive\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Distance , typename _Pointer > void \fB__merge_adaptive\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _BidirectionalIterator3 , typename _Compare > _BidirectionalIterator3 \fB__merge_backward\fP (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _BidirectionalIterator3 > _BidirectionalIterator3 \fB__merge_backward\fP (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator1 , typename _RandomAccessIterator2 , typename _Distance , typename _Compare > void \fB__merge_sort_loop\fP (_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator1 , typename _RandomAccessIterator2 , typename _Distance > void \fB__merge_sort_loop\fP (_RandomAccessIterator1 __first, _RandomAccessIterator1 __last, _RandomAccessIterator2 __result, _Distance __step_size)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Pointer , typename _Compare > void \fB__merge_sort_with_buffer\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Pointer > void \fB__merge_sort_with_buffer\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Distance , typename _Compare > void \fB__merge_without_buffer\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Distance > void \fB__merge_without_buffer\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2)"
.br
.ti -1c
.RI "void \fB__once_proxy\fP ()"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > void \fB__ostream_fill\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fB__ostream_insert\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, const _CharT *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > void \fB__ostream_write\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, const _CharT *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Predicate > _BidirectionalIterator \fB__partition\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, \fBbidirectional_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator \fB__partition\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, \fBforward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__pop_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__pop_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomAccessIterator __result)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__pow_helper\fP (_Tp __x, int __n)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Tp , typename _Compare > void \fB__push_heap\fP (_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Distance , typename _Tp > void \fB__push_heap\fP (_RandomAccessIterator __first, _Distance __holeIndex, _Distance __topIndex, _Tp __value)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__reverse\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > void \fB__reverse\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, \fBbidirectional_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__rotate\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > void \fB__rotate\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, \fBbidirectional_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB__rotate\fP (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, \fBforward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _Distance > _BidirectionalIterator1 \fB__rotate_adaptive\fP (_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)"
.br
.ti -1c
.RI "template<typename _RandomAccessIter , typename _Integer , typename _Tp , typename _BinaryPredicate > _RandomAccessIter \fB__search_n\fP (_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, \fBstd::random_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate > _ForwardIterator \fB__search_n\fP (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIter , typename _Integer , typename _Tp > _RandomAccessIter \fB__search_n\fP (_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp &__val, \fBstd::random_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Integer , typename _Tp > _ForwardIterator \fB__search_n\fP (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Pointer , typename _Predicate , typename _Distance > _ForwardIterator \fB__stable_partition_adaptive\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Pointer , typename _Distance , typename _Compare > void \fB__stable_sort_adaptive\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Pointer , typename _Distance > void \fB__stable_sort_adaptive\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Pointer __buffer, _Distance __buffer_size)"
.br
.ti -1c
.RI "void \fB__throw_bad_alloc\fP (void) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_bad_cast\fP (void) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_bad_exception\fP (void) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_bad_typeid\fP (void) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_bad_weak_ptr\fP ()"
.br
.ti -1c
.RI "void \fB__throw_domain_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_invalid_argument\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_ios_failure\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_length_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_logic_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_out_of_range\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_overflow_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_range_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_runtime_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_system_error\fP (int) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "void \fB__throw_underflow_error\fP (const char *) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "template<typename... _TElements, std::size_t... _TIdx, typename... _UElements, std::size_t... _UIdx> \fBtuple\fP< _TElements..., _UElements...> \fB__tuple_cat_helper\fP (\fBtuple\fP< _TElements...> &&__t, const __index_holder< _TIdx...> &, \fBtuple\fP< _UElements...> &&__u, const __index_holder< _UIdx...> &)"
.br
.ti -1c
.RI "template<typename... _TElements, std::size_t... _TIdx, typename... _UElements, std::size_t... _UIdx> \fBtuple\fP< _TElements..., _UElements...> \fB__tuple_cat_helper\fP (const \fBtuple\fP< _TElements...> &__t, const __index_holder< _TIdx...> &, \fBtuple\fP< _UElements...> &&__u, const __index_holder< _UIdx...> &)"
.br
.ti -1c
.RI "template<typename... _TElements, std::size_t... _TIdx, typename... _UElements, std::size_t... _UIdx> \fBtuple\fP< _TElements..., _UElements...> \fB__tuple_cat_helper\fP (\fBtuple\fP< _TElements...> &&__t, const __index_holder< _TIdx...> &, const \fBtuple\fP< _UElements...> &__u, const __index_holder< _UIdx...> &)"
.br
.ti -1c
.RI "template<typename... _TElements, std::size_t... _TIdx, typename... _UElements, std::size_t... _UIdx> \fBtuple\fP< _TElements..., _UElements...> \fB__tuple_cat_helper\fP (const \fBtuple\fP< _TElements...> &__t, const __index_holder< _TIdx...> &, const \fBtuple\fP< _UElements...> &__u, const __index_holder< _UIdx...> &)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fB__unguarded_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fB__unguarded_insertion_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Tp , typename _Compare > void \fB__unguarded_linear_insert\fP (_RandomAccessIterator __last, _Tp __val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Tp > void \fB__unguarded_linear_insert\fP (_RandomAccessIterator __last, _Tp __val)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Tp , typename _Compare > _RandomAccessIterator \fB__unguarded_partition\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Tp > _RandomAccessIterator \fB__unguarded_partition\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _Tp > _ForwardIterator \fB__uninitialized_copy_a\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, \fBallocator\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _Allocator > _ForwardIterator \fB__uninitialized_copy_a\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _ForwardIterator , typename _Allocator > _ForwardIterator \fB__uninitialized_copy_move\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Size , typename _ForwardIterator > _ForwardIterator \fB__uninitialized_copy_n\fP (_RandomAccessIterator __first, _Size __n, _ForwardIterator __result, \fBrandom_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _ForwardIterator > _ForwardIterator \fB__uninitialized_copy_n\fP (_InputIterator __first, _Size __n, _ForwardIterator __result, \fBinput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Tp2 > void \fB__uninitialized_fill_a\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, \fBallocator\fP< _Tp2 > &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Allocator > void \fB__uninitialized_fill_a\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _InputIterator , typename _Allocator > _ForwardIterator \fB__uninitialized_fill_move\fP (_ForwardIterator __result, _ForwardIterator __mid, const _Tp &__x, _InputIterator __first, _InputIterator __last, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Size , typename _Tp , typename _Tp2 > void \fB__uninitialized_fill_n_a\fP (_ForwardIterator __first, _Size __n, const _Tp &__x, \fBallocator\fP< _Tp2 > &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Size , typename _Tp , typename _Allocator > void \fB__uninitialized_fill_n_a\fP (_ForwardIterator __first, _Size __n, const _Tp &__x, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _Allocator > _ForwardIterator \fB__uninitialized_move_a\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _ForwardIterator , typename _Allocator > _ForwardIterator \fB__uninitialized_move_copy\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _ForwardIterator __result, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _Tp , typename _Allocator > void \fB__uninitialized_move_fill\fP (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, const _Tp &__x, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate > _ForwardIterator \fB__unique_copy\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, \fBinput_iterator_tag\fP, \fBforward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _BinaryPredicate > _OutputIterator \fB__unique_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, \fBinput_iterator_tag\fP, \fBoutput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator , typename _BinaryPredicate > _OutputIterator \fB__unique_copy\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, \fBforward_iterator_tag\fP, \fBoutput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator > _ForwardIterator \fB__unique_copy\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, \fBinput_iterator_tag\fP, \fBforward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator > _OutputIterator \fB__unique_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, \fBinput_iterator_tag\fP, \fBoutput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator > _OutputIterator \fB__unique_copy\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, \fBforward_iterator_tag\fP, \fBoutput_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB__valarray_copy\fP (const _Expr< _Dom, _Tp > &__e, size_t __n, _Array< _Tp > __a, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __e, _Array< size_t > __f, size_t __n, _Array< _Tp > __a, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB__valarray_copy\fP (const _Expr< _Dom, _Tp > &__e, size_t __n, _Array< _Tp > __a, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB__valarray_copy\fP (const _Expr< _Dom, _Tp > &__e, size_t __n, _Array< _Tp > __a, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB__valarray_copy\fP (const _Expr< _Dom, _Tp > &__e, size_t __n, _Array< _Tp > __a)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, _Array< bool > __m, size_t __n, _Array< _Tp > __b, _Array< bool > __k)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __src, size_t __n, _Array< size_t > __i, _Array< _Tp > __dst, _Array< size_t > __j)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, size_t __n, size_t __s1, _Array< _Tp > __b, size_t __s2)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __src, size_t __n, const size_t *__restrict__ __i, _Tp *__restrict__ __dst, const size_t *__restrict__ __j)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b, const size_t *__restrict__ __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __a, const size_t *__restrict__ __i, _Tp *__restrict__ __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __src, size_t __n, size_t __s1, _Tp *__restrict__ __dst, size_t __s2)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __a, _Tp *__restrict__ __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __a, size_t __n, size_t __s, _Tp *__restrict__ __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy\fP (const _Tp *__restrict__ __a, size_t __n, _Tp *__restrict__ __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB__valarray_copy_construct\fP (const _Expr< _Dom, _Tp > &__e, size_t __n, _Array< _Tp > __a)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (const _Tp *__restrict__ __a, const size_t *__restrict__ __i, _Tp *__restrict__ __o, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (const _Tp *__restrict__ __a, size_t __n, size_t __s, _Tp *__restrict__ __o)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_copy_construct\fP (const _Tp *__restrict__ __b, const _Tp *__restrict__ __e, _Tp *__restrict__ __o)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_default_construct\fP (_Tp *__restrict__ __b, _Tp *__restrict__ __e)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_destroy_elements\fP (_Tp *__restrict__ __b, _Tp *__restrict__ __e)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Array< _Tp > __a, size_t __n, _Array< bool > __m, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Array< _Tp > __a, _Array< size_t > __i, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Array< _Tp > __a, size_t __n, size_t __s, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Tp *__restrict__ __a, const size_t *__restrict__ __i, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Tp *__restrict__ __a, size_t __n, size_t __s, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill\fP (_Tp *__restrict__ __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB__valarray_fill_construct\fP (_Tp *__restrict__ __b, _Tp *__restrict__ __e, const _Tp __t)"
.br
.ti -1c
.RI "void * \fB__valarray_get_memory\fP (size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp *__restrict__ \fB__valarray_get_storage\fP (size_t __n)"
.br
.ti -1c
.RI "template<typename _Ta > _Ta::value_type \fB__valarray_max\fP (const _Ta &__a)"
.br
.ti -1c
.RI "template<typename _Ta > _Ta::value_type \fB__valarray_min\fP (const _Ta &__a)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__valarray_product\fP (const _Tp *__restrict__ __f, const _Tp *__restrict__ __l)"
.br
.ti -1c
.RI "void \fB__valarray_release_memory\fP (void *__p)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fB__valarray_sum\fP (const _Tp *__restrict__ __f, const _Tp *__restrict__ __l)"
.br
.ti -1c
.RI "bool \fB__verify_grouping\fP (const char *__grouping, size_t __grouping_size, const \fBstring\fP &__grouping_tmp)"
.br
.ti -1c
.RI "template<typename _CharT , typename _OutIter > _OutIter \fB__write\fP (_OutIter __s, const _CharT *__ws, int __len)"
.br
.ti -1c
.RI "template<typename _CharT > \fBostreambuf_iterator\fP< _CharT > \fB__write\fP (\fBostreambuf_iterator\fP< _CharT > __s, const _CharT *__ws, int __len)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_and\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_or\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___bitwise_xor\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___divides\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___minus\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___modulus\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___multiplies\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___plus\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_left\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, _Array< bool > __m, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< bool > __m)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, _Array< bool > __m, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, _Array< size_t > __i, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b, _Array< size_t > __i)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, _Array< size_t > __i, _Array< _Tp > __b, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __s, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, _Array< _Tp > __b, size_t __n, size_t __s)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __n, size_t __s, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp , class _Dom > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, const _Expr< _Dom, _Tp > &__e, size_t __n)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __n, _Array< _Tp > __b)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Array_augmented___shift_right\fP (_Array< _Tp > __a, size_t __n, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _T1 , typename _T2 > void \fB_Construct\fP (_T1 *__p, const _T2 &__value)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > void \fB_Destroy\fP (_ForwardIterator __first, _ForwardIterator __last, \fBallocator\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Allocator > void \fB_Destroy\fP (_ForwardIterator __first, _ForwardIterator __last, _Allocator &__alloc)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_Destroy\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _Tp > void \fB_Destroy\fP (_Tp *__pointer)"
.br
.ti -1c
.RI "unsigned int \fB_Rb_tree_black_count\fP (const _Rb_tree_node_base *__node, const _Rb_tree_node_base *__root)"
.br
.ti -1c
.RI "const _Rb_tree_node_base * \fB_Rb_tree_decrement\fP (const _Rb_tree_node_base *__x)"
.br
.ti -1c
.RI "_Rb_tree_node_base * \fB_Rb_tree_decrement\fP (_Rb_tree_node_base *__x)"
.br
.ti -1c
.RI "const _Rb_tree_node_base * \fB_Rb_tree_increment\fP (const _Rb_tree_node_base *__x)"
.br
.ti -1c
.RI "_Rb_tree_node_base * \fB_Rb_tree_increment\fP (_Rb_tree_node_base *__x)"
.br
.ti -1c
.RI "void \fB_Rb_tree_insert_and_rebalance\fP (const bool __insert_left, _Rb_tree_node_base *__x, _Rb_tree_node_base *__p, _Rb_tree_node_base &__header)"
.br
.ti -1c
.RI "_Rb_tree_node_base * \fB_Rb_tree_rebalance_for_erase\fP (_Rb_tree_node_base *const __z, _Rb_tree_node_base &__header)"
.br
.ti -1c
.RI "void \fBabort\fP (void)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __abs, _ValArray, _Tp >, _Tp > \fBabs\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __abs, _Expr, _Dom >, typename _Dom::value_type > \fBabs\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "long double \fBabs\fP (long double __x)"
.br
.ti -1c
.RI "float \fBabs\fP (float __x)"
.br
.ti -1c
.RI "double \fBabs\fP (double __x)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBabs\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Tp , typename _BinaryOperation > _Tp \fBaccumulate\fP (_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Tp > _Tp \fBaccumulate\fP (_InputIterator __first, _InputIterator __last, _Tp __init)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __acos, _ValArray, _Tp >, _Tp > \fBacos\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __acos, _Expr, _Dom >, typename _Dom::value_type > \fBacos\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBacos\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBacos\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBacos\fP (long double __x)"
.br
.ti -1c
.RI "float \fBacos\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBacosh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fBadjacent_difference\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator > _OutputIterator \fBadjacent_difference\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _BinaryPredicate > _ForwardIterator \fBadjacent_find\fP (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBadjacent_find\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _BinaryPredicate > _FIter \fBadjacent_find\fP (_FIter, _FIter, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter > _FIter \fBadjacent_find\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Distance > void \fBadvance\fP (_InputIterator &__i, _Distance __n)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fBall_of\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > bool \fBall_of\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fBany_of\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > bool \fBany_of\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__promote< _Tp >::__type \fBarg\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBarg\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __asin, _ValArray, _Tp >, _Tp > \fBasin\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __asin, _Expr, _Dom >, typename _Dom::value_type > \fBasin\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBasin\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBasin\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBasin\fP (long double __x)"
.br
.ti -1c
.RI "float \fBasin\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBasinh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __atan, _ValArray, _Tp >, _Tp > \fBatan\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __atan, _Expr, _Dom >, typename _Dom::value_type > \fBatan\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBatan\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBatan\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBatan\fP (long double __x)"
.br
.ti -1c
.RI "float \fBatan\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __atan2, _Constant, _ValArray, _Tp, _Tp >, _Tp > \fBatan2\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __atan2, _ValArray, _Constant, _Tp, _Tp >, _Tp > \fBatan2\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __atan2, _ValArray, _ValArray, _Tp, _Tp >, _Tp > \fBatan2\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __atan2, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > \fBatan2\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __atan2, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename _Dom::value_type > \fBatan2\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __atan2, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > \fBatan2\fP (const \fBvalarray\fP< typename _Dom::valarray > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __atan2, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename _Dom::value_type > \fBatan2\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __atan2, _Expr, _Expr, _Dom1, _Dom2 >, typename _Dom1::value_type > \fBatan2\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__e1, const _Expr< _Dom2, typename _Dom2::value_type > &__e2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Up > __gnu_cxx::__promote_2< typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value &&__is_arithmetic< _Up >::__value, _Tp >::__type, _Up >::__type \fBatan2\fP (_Tp __y, _Up __x)"
.br
.ti -1c
.RI "long double \fBatan2\fP (long double __y, long double __x)"
.br
.ti -1c
.RI "float \fBatan2\fP (float __y, float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBatanh\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "int \fBatexit\fP (void(*)())"
.br
.ti -1c
.RI "template<typename _ITp > bool \fBatomic_compare_exchange_strong\fP (volatile __atomic_base< _ITp > *__a, _ITp *__i1, _ITp __i2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_strong\fP (volatile atomic_bool *__a, bool *__i1, bool __i2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_strong\fP (volatile atomic_address *__a, void **__v1, void *__v2)"
.br
.ti -1c
.RI "template<typename _ITp > bool \fBatomic_compare_exchange_strong_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp *__i1, _ITp __i2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_strong_explicit\fP (volatile atomic_bool *__a, bool *__i1, bool __i2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_strong_explicit\fP (volatile atomic_address *__a, void **__v1, void *__v2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "template<typename _ITp > bool \fBatomic_compare_exchange_weak\fP (volatile __atomic_base< _ITp > *__a, _ITp *__i1, _ITp __i2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_weak\fP (volatile atomic_bool *__a, bool *__i1, bool __i2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_weak\fP (volatile atomic_address *__a, void **__v1, void *__v2)"
.br
.ti -1c
.RI "template<typename _ITp > bool \fBatomic_compare_exchange_weak_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp *__i1, _ITp __i2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_weak_explicit\fP (volatile atomic_bool *__a, bool *__i1, bool __i2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "bool \fBatomic_compare_exchange_weak_explicit\fP (volatile atomic_address *__a, void **__v1, void *__v2, \fBmemory_order\fP __m1, \fBmemory_order\fP __m2)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_exchange\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "bool \fBatomic_exchange\fP (volatile atomic_bool *__a, bool __i)"
.br
.ti -1c
.RI "void * \fBatomic_exchange\fP (volatile atomic_address *__a, void *__v)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_exchange_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "bool \fBatomic_exchange_explicit\fP (volatile atomic_bool *__a, bool __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void * \fBatomic_exchange_explicit\fP (volatile atomic_address *__a, void *__v, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_add\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "void * \fBatomic_fetch_add\fP (volatile atomic_address *__a, ptrdiff_t __d)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_add_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void * \fBatomic_fetch_add_explicit\fP (volatile atomic_address *__a, ptrdiff_t __d, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_and\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_and_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_or\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_or_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_sub\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "void * \fBatomic_fetch_sub\fP (volatile atomic_address *__a, ptrdiff_t __d)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_sub_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void * \fBatomic_fetch_sub_explicit\fP (volatile atomic_address *__a, ptrdiff_t __d, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_xor\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_fetch_xor_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void \fBatomic_flag_clear\fP (volatile __atomic_flag_base *__a)"
.br
.ti -1c
.RI "void \fBatomic_flag_clear_explicit\fP (volatile __atomic_flag_base *, \fBmemory_order\fP)"
.br
.ti -1c
.RI "void \fBatomic_flag_clear_explicit\fP (volatile atomic_flag *__a, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "bool \fBatomic_flag_test_and_set\fP (volatile __atomic_flag_base *__a)"
.br
.ti -1c
.RI "bool \fBatomic_flag_test_and_set_explicit\fP (volatile __atomic_flag_base *, \fBmemory_order\fP)"
.br
.ti -1c
.RI "bool \fBatomic_flag_test_and_set_explicit\fP (volatile atomic_flag *__a, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > bool \fBatomic_is_lock_free\fP (const volatile __atomic_base< _ITp > *__a)"
.br
.ti -1c
.RI "bool \fBatomic_is_lock_free\fP (const volatile atomic_bool *__a)"
.br
.ti -1c
.RI "bool \fBatomic_is_lock_free\fP (const volatile atomic_address *__a)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_load\fP (const volatile __atomic_base< _ITp > *__a)"
.br
.ti -1c
.RI "bool \fBatomic_load\fP (const volatile atomic_bool *__a)"
.br
.ti -1c
.RI "void * \fBatomic_load\fP (const volatile atomic_address *__a)"
.br
.ti -1c
.RI "template<typename _ITp > _ITp \fBatomic_load_explicit\fP (const volatile __atomic_base< _ITp > *__a, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "bool \fBatomic_load_explicit\fP (const volatile atomic_bool *__a, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void * \fBatomic_load_explicit\fP (const volatile atomic_address *__a, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _ITp > void \fBatomic_store\fP (volatile __atomic_base< _ITp > *__a, _ITp __i)"
.br
.ti -1c
.RI "void \fBatomic_store\fP (volatile atomic_bool *__a, bool __i)"
.br
.ti -1c
.RI "void \fBatomic_store\fP (volatile atomic_address *__a, void *__v)"
.br
.ti -1c
.RI "template<typename _ITp > void \fBatomic_store_explicit\fP (volatile __atomic_base< _ITp > *__a, _ITp __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void \fBatomic_store_explicit\fP (volatile atomic_bool *__a, bool __i, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "void \fBatomic_store_explicit\fP (volatile atomic_address *__a, void *__v, \fBmemory_order\fP __m)"
.br
.ti -1c
.RI "template<typename _Container > \fBback_insert_iterator\fP< _Container > \fBback_inserter\fP (_Container &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > bool \fBbinary_search\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > bool \fBbinary_search\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp , typename _Compare > bool \fBbinary_search\fP (_FIter, _FIter, const _Tp &, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > bool \fBbinary_search\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _Functor , typename... _ArgTypes> _Bind< typename \fB_Maybe_wrap_member_pointer\fP< _Functor >::type(_ArgTypes...)> \fBbind\fP (_Functor __f, _ArgTypes...__args)"
.br
.ti -1c
.RI "template<typename _Operation , typename _Tp > \fBbinder1st\fP< _Operation > \fBbind1st\fP (const _Operation &__fn, const _Tp &__x)"
.br
.ti -1c
.RI "template<typename _Operation , typename _Tp > \fBbinder2nd\fP< _Operation > \fBbind2nd\fP (const _Operation &__fn, const _Tp &__x)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBboolalpha\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Callable , typename... _Args> void \fBcall_once\fP (\fBonce_flag\fP &__once, _Callable __f, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBceil\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBceil\fP (long double __x)"
.br
.ti -1c
.RI "float \fBceil\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< typename __gnu_cxx::__promote< _Tp >::__type > \fBconj\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBconj\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBostreambuf_iterator\fP< _CharT > >::__type \fBcopy\fP (\fBistreambuf_iterator\fP< _CharT > __first, \fBistreambuf_iterator\fP< _CharT > __last, \fBostreambuf_iterator\fP< _CharT > __result)"
.br
.ti -1c
.RI "template<typename _II , typename _OI > _OI \fBcopy\fP (_II __first, _II __last, _OI __result)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter > _OIter \fBcopy\fP (_IIter, _IIter, _OIter)"
.br
.ti -1c
.RI "template<typename _BI1 , typename _BI2 > _BI2 \fBcopy_backward\fP (_BI1 __first, _BI1 __last, _BI2 __result)"
.br
.ti -1c
.RI "template<typename _BIter1 , typename _BIter2 > _BIter2 \fBcopy_backward\fP (_BIter1, _BIter1, _BIter2)"
.br
.ti -1c
.RI "template<typename _Ex > exception_ptr \fBcopy_exception\fP (_Ex __ex)  throw ()"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _Predicate > _OutputIterator \fBcopy_if\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _Predicate > _OIter \fBcopy_if\fP (_IIter, _IIter, _OIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _OutputIterator > _OutputIterator \fBcopy_n\fP (_InputIterator __first, _Size __n, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Size , typename _OIter > _OIter \fBcopy_n\fP (_IIter, _Size, _OIter)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __cos, _ValArray, _Tp >, _Tp > \fBcos\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __cos, _Expr, _Dom >, typename _Dom::value_type > \fBcos\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBcos\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBcos\fP (long double __x)"
.br
.ti -1c
.RI "float \fBcos\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBcos\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __cosh, _ValArray, _Tp >, _Tp > \fBcosh\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __cosh, _Expr, _Dom >, typename _Dom::value_type > \fBcosh\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBcosh\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBcosh\fP (long double __x)"
.br
.ti -1c
.RI "float \fBcosh\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBcosh\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Tp > \fBiterator_traits\fP< _InputIterator >::difference_type \fBcount\fP (_InputIterator __first, _InputIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Tp > \fBiterator_traits\fP< _IIter >::difference_type \fBcount\fP (_IIter, _IIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > \fBiterator_traits\fP< _InputIterator >::difference_type \fBcount_if\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > \fBiterator_traits\fP< _IIter >::difference_type \fBcount_if\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _Tp > \fBreference_wrapper\fP< const _Tp > \fBcref\fP (\fBreference_wrapper\fP< _Tp > __t)"
.br
.ti -1c
.RI "template<typename _Tp > \fBreference_wrapper\fP< const _Tp > \fBcref\fP (const _Tp &__t)"
.br
.ti -1c
.RI "exception_ptr \fBcurrent_exception\fP ()  throw ()"
.br
.ti -1c
.RI "\fBios_base\fP & \fBdec\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBiterator_traits\fP< _InputIterator >::difference_type \fBdistance\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBendl\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBends\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 > bool \fBequal\fP (_II1 __first1, _II1 __last1, _II2 __first2)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _BinaryPredicate > bool \fBequal\fP (_IIter1 __first1, _IIter1 __last1, _IIter2 __first2, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 > bool \fBequal\fP (_IIter1, _IIter1, _IIter2)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > \fBpair\fP< _ForwardIterator, _ForwardIterator > \fBequal_range\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > \fBpair\fP< _ForwardIterator, _ForwardIterator > \fBequal_range\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp , typename _Compare > \fBpair\fP< _FIter, _FIter > \fBequal_range\fP (_FIter, _FIter, const _Tp &, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > \fBpair\fP< _FIter, _FIter > \fBequal_range\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "void \fBexit\fP (int)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __exp, _ValArray, _Tp >, _Tp > \fBexp\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __exp, _Expr, _Dom >, typename _Dom::value_type > \fBexp\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBexp\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBexp\fP (long double __x)"
.br
.ti -1c
.RI "float \fBexp\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBexp\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBfabs\fP (const \fBstd::complex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBfabs\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBfabs\fP (long double __x)"
.br
.ti -1c
.RI "float \fBfabs\fP (float __x)"
.br
.ti -1c
.RI "void \fBfill\fP (_Bit_iterator __first, _Bit_iterator __last, const bool &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > void \fBfill\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _Tp > void \fBfill\fP (const \fB_Deque_iterator\fP< _Tp, _Tp &, _Tp * > &__first, const \fB_Deque_iterator\fP< _Tp, _Tp &, _Tp * > &__last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > void \fBfill\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _OI , typename _Size , typename _Tp > _OI \fBfill_n\fP (_OI __first, _Size __n, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _OIter , typename _Size , typename _Tp > _OIter \fBfill_n\fP (_OIter, _Size, const _Tp &)"
.br
.ti -1c
.RI "template<typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, \fBistreambuf_iterator\fP< _CharT > >::__type \fBfind\fP (\fBistreambuf_iterator\fP< _CharT > __first, \fBistreambuf_iterator\fP< _CharT > __last, const _CharT &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Tp > _InputIterator \fBfind\fP (_InputIterator __first, _InputIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Tp > _IIter \fBfind\fP (_IIter, _IIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate > _ForwardIterator1 \fBfind_end\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 > _ForwardIterator1 \fBfind_end\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 , typename _BinaryPredicate > _FIter1 \fBfind_end\fP (_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 > _FIter1 \fBfind_end\fP (_FIter1, _FIter1, _FIter2, _FIter2)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate > _InputIterator \fBfind_first_of\fP (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2, _BinaryPredicate __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator > _InputIterator \fBfind_first_of\fP (_InputIterator __first1, _InputIterator __last1, _ForwardIterator __first2, _ForwardIterator __last2)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 , typename _BinaryPredicate > _FIter1 \fBfind_first_of\fP (_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 > _FIter1 \fBfind_first_of\fP (_FIter1, _FIter1, _FIter2, _FIter2)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > _InputIterator \fBfind_if\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > _IIter \fBfind_if\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > _InputIterator \fBfind_if_not\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > _IIter \fBfind_if_not\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBfixed\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBfloor\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBfloor\fP (long double __x)"
.br
.ti -1c
.RI "float \fBfloor\fP (float __x)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBflush\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os)"
.br
.ti -1c
.RI "long double \fBfmod\fP (long double __x, long double __y)"
.br
.ti -1c
.RI "float \fBfmod\fP (float __x, float __y)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Function > _Function \fBfor_each\fP (_InputIterator __first, _InputIterator __last, _Function __f)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Funct > _Funct \fBfor_each\fP (_IIter, _IIter, _Funct)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp && \fBforward\fP (typename std::identity< _Tp >::type &&__t)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBfrexp\fP (_Tp __x, int *__exp)"
.br
.ti -1c
.RI "long double \fBfrexp\fP (long double __x, int *__exp)"
.br
.ti -1c
.RI "float \fBfrexp\fP (float __x, int *__exp)"
.br
.ti -1c
.RI "template<typename _Container > \fBfront_insert_iterator\fP< _Container > \fBfront_inserter\fP (_Container &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Generator > void \fBgenerate\fP (_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Generator > void \fBgenerate\fP (_FIter, _FIter, _Generator)"
.br
.ti -1c
.RI "template<typename _OutputIterator , typename _Size , typename _Generator > _OutputIterator \fBgenerate_n\fP (_OutputIterator __first, _Size __n, _Generator __gen)"
.br
.ti -1c
.RI "template<typename _OIter , typename _Size , typename _Generator > _OIter \fBgenerate_n\fP (_OIter, _Size, _Generator)"
.br
.ti -1c
.RI "const \fBerror_category\fP & \fBgeneric_category\fP ()"
.br
.ti -1c
.RI "template<std::size_t _Int, class _Tp1 , class _Tp2 > const tuple_element< _Int, \fBstd::pair\fP< _Tp1, _Tp2 > >::type & \fBget\fP (const \fBstd::pair\fP< _Tp1, _Tp2 > &__in)"
.br
.ti -1c
.RI "template<std::size_t _Int, class _Tp1 , class _Tp2 > tuple_element< _Int, \fBstd::pair\fP< _Tp1, _Tp2 > >::type & \fBget\fP (\fBstd::pair\fP< _Tp1, _Tp2 > &__in)"
.br
.ti -1c
.RI "template<std::size_t _Int, typename _Tp , std::size_t _Nm> const _Tp & \fBget\fP (const \fBarray\fP< _Tp, _Nm > &__arr)"
.br
.ti -1c
.RI "template<std::size_t _Int, typename _Tp , std::size_t _Nm> _Tp & \fBget\fP (\fBarray\fP< _Tp, _Nm > &__arr)"
.br
.ti -1c
.RI "template<std::size_t __i, typename... _Elements> __add_c_ref< typename tuple_element< __i, \fBtuple\fP< _Elements...> >::type >::type \fBget\fP (const \fBtuple\fP< _Elements...> &__t)"
.br
.ti -1c
.RI "template<std::size_t __i, typename... _Elements> __add_ref< typename tuple_element< __i, \fBtuple\fP< _Elements...> >::type >::type \fBget\fP (\fBtuple\fP< _Elements...> &__t)"
.br
.ti -1c
.RI "template<typename _Tp > \fBpair\fP< _Tp *, ptrdiff_t > \fBget_temporary_buffer\fP (ptrdiff_t __len)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > &__str)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > &__str, _CharT __delim)"
.br
.ti -1c
.RI "template<> \fBbasic_istream\fP< wchar_t > & \fBgetline\fP (\fBbasic_istream\fP< wchar_t > &__in, \fBbasic_string\fP< wchar_t > &__str, wchar_t __delim)"
.br
.ti -1c
.RI "template<> \fBbasic_istream\fP< char > & \fBgetline\fP (\fBbasic_istream\fP< char > &__in, \fBbasic_string\fP< char > &__str, char __delim)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__str)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__str, _CharT __delim)"
.br
.ti -1c
.RI "template<typename _Facet > bool \fBhas_facet\fP (const \fBlocale\fP &__loc)  throw ()"
.br
.ti -1c
.RI "\fBios_base\fP & \fBhex\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__promote< _Tp >::__type \fBimag\fP (_Tp)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBimag\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _Compare > bool \fBincludes\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 > bool \fBincludes\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _Compare > bool \fBincludes\fP (_IIter1, _IIter1, _IIter2, _IIter2, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 > bool \fBincludes\fP (_IIter1, _IIter1, _IIter2, _IIter2)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _Tp , typename _BinaryOperation1 , typename _BinaryOperation2 > _Tp \fBinner_product\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _Tp > _Tp \fBinner_product\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > void \fBinplace_merge\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > void \fBinplace_merge\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _BIter , typename _Compare > void \fBinplace_merge\fP (_BIter, _BIter, _BIter, _Compare)"
.br
.ti -1c
.RI "template<typename _BIter > void \fBinplace_merge\fP (_BIter, _BIter, _BIter)"
.br
.ti -1c
.RI "template<typename _Container , typename _Iterator > \fBinsert_iterator\fP< _Container > \fBinserter\fP (_Container &__x, _Iterator __i)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBinternal\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > void \fBiota\fP (_ForwardIterator __first, _ForwardIterator __last, _Tp __value)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > bool \fBis_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > bool \fBis_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > bool \fBis_heap\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > bool \fBis_heap\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > _RandomAccessIterator \fBis_heap_until\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > _RandomAccessIterator \fBis_heap_until\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > _RAIter \fBis_heap_until\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > _RAIter \fBis_heap_until\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fBis_partitioned\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > bool \fBis_partitioned\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > bool \fBis_sorted\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > bool \fBis_sorted\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Compare > bool \fBis_sorted\fP (_FIter, _FIter, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter > bool \fBis_sorted\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBis_sorted_until\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBis_sorted_until\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Compare > _FIter \fBis_sorted_until\fP (_FIter, _FIter, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter > _FIter \fBis_sorted_until\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisalnum\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisalpha\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBiscntrl\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisdigit\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisgraph\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBislower\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisprint\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBispunct\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > _GLIBCXX_END_LDBL_NAMESPACE bool \fBisspace\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisupper\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > bool \fBisxdigit\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 > void \fBiter_swap\fP (_ForwardIterator1 __a, _ForwardIterator2 __b)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 > void \fBiter_swap\fP (_FIter1, _FIter2)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBkill_dependency\fP (_Tp __y)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBldexp\fP (_Tp __x, int __exp)"
.br
.ti -1c
.RI "long double \fBldexp\fP (long double __x, int __exp)"
.br
.ti -1c
.RI "float \fBldexp\fP (float __x, int __exp)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBleft\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 , typename _Compare > bool \fBlexicographical_compare\fP (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 > bool \fBlexicographical_compare\fP (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _Compare > bool \fBlexicographical_compare\fP (_IIter1, _IIter1, _IIter2, _IIter2, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 > bool \fBlexicographical_compare\fP (_IIter1, _IIter1, _IIter2, _IIter2)"
.br
.ti -1c
.RI "template<typename _L1 , typename _L2 , typename... _L3> void \fBlock\fP (_L1 &, _L2 &, _L3 &...)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __log, _ValArray, _Tp >, _Tp > \fBlog\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __log, _Expr, _Dom >, typename _Dom::value_type > \fBlog\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBlog\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBlog\fP (long double __x)"
.br
.ti -1c
.RI "float \fBlog\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBlog\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __log10, _ValArray, _Tp >, _Tp > \fBlog10\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __log10, _Expr, _Dom >, typename _Dom::value_type > \fBlog10\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBlog10\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBlog10\fP (long double __x)"
.br
.ti -1c
.RI "float \fBlog10\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBlog10\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator \fBlower_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > _ForwardIterator \fBlower_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp , typename _Compare > _FIter \fBlower_bound\fP (_FIter, _FIter, const _Tp &, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > _FIter \fBlower_bound\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "\fBerror_code\fP \fBmake_error_code\fP (errc __e)"
.br
.ti -1c
.RI "\fBerror_condition\fP \fBmake_error_condition\fP (errc __e)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBmake_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBmake_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBmake_heap\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBmake_heap\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _Iterator > \fBmove_iterator\fP< _Iterator > \fBmake_move_iterator\fP (const _Iterator &__i)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > \fBpair\fP< typename __decay_and_strip< _T1 >::__type, typename __decay_and_strip< _T2 >::__type > \fBmake_pair\fP (_T1 &&__x, _T2 &&__y)"
.br
.ti -1c
.RI "template<typename... _Elements> \fBtuple\fP< typename __decay_and_strip< _Elements >::__type...> \fBmake_tuple\fP (_Elements &&...__args)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > _Tp \fBmax\fP (\fBinitializer_list\fP< _Tp >, _Compare)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBmax\fP (\fBinitializer_list\fP< _Tp >)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fBmax\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBmax\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBmax_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBmax_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Compare > _FIter \fBmax_element\fP (_FIter, _FIter, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter > _FIter \fBmax_element\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Class > _Mem_fn< _Tp _Class::* > \fBmem_fn\fP (_Tp _Class::*__pm)"
.br
.ti -1c
.RI "template<typename _Ret , typename _Tp , typename _Arg > \fBmem_fun1_t\fP< _Ret, _Tp, _Arg > \fBmem_fun\fP (_Ret(_Tp::*__f)(_Arg))"
.br
.ti -1c
.RI "template<typename _Ret , typename _Tp > \fBmem_fun_t\fP< _Ret, _Tp > \fBmem_fun\fP (_Ret(_Tp::*__f)())"
.br
.ti -1c
.RI "template<typename _Ret , typename _Tp , typename _Arg > \fBmem_fun1_ref_t\fP< _Ret, _Tp, _Arg > \fBmem_fun_ref\fP (_Ret(_Tp::*__f)(_Arg))"
.br
.ti -1c
.RI "template<typename _Ret , typename _Tp > \fBmem_fun_ref_t\fP< _Ret, _Tp > \fBmem_fun_ref\fP (_Ret(_Tp::*__f)())"
.br
.ti -1c
.RI "void * \fBmemchr\fP (void *__p, int __c, size_t __n)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBmerge\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBmerge\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _Compare > _OIter \fBmerge\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter > _OIter \fBmerge\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > _Tp \fBmin\fP (\fBinitializer_list\fP< _Tp >, _Compare)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBmin\fP (\fBinitializer_list\fP< _Tp >)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fBmin\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBmin\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBmin_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBmin_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Compare > _FIter \fBmin_element\fP (_FIter, _FIter, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter > _FIter \fBmin_element\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > \fBpair\fP< _Tp, _Tp > \fBminmax\fP (\fBinitializer_list\fP< _Tp >, _Compare)"
.br
.ti -1c
.RI "template<typename _Tp > \fBpair\fP< _Tp, _Tp > \fBminmax\fP (\fBinitializer_list\fP< _Tp >)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > \fBpair\fP< const _Tp &, const _Tp & > \fBminmax\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > \fBpair\fP< const _Tp &, const _Tp & > \fBminmax\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > \fBpair\fP< _ForwardIterator, _ForwardIterator > \fBminmax_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > \fBpair\fP< _ForwardIterator, _ForwardIterator > \fBminmax_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Compare > \fBpair\fP< _FIter, _FIter > \fBminmax_element\fP (_FIter, _FIter, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter > \fBpair\fP< _FIter, _FIter > \fBminmax_element\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _BinaryPredicate > \fBpair\fP< _InputIterator1, _InputIterator2 > \fBmismatch\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 > \fBpair\fP< _InputIterator1, _InputIterator2 > \fBmismatch\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _BinaryPredicate > \fBpair\fP< _IIter1, _IIter2 > \fBmismatch\fP (_IIter1, _IIter1, _IIter2, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 > \fBpair\fP< _IIter1, _IIter2 > \fBmismatch\fP (_IIter1, _IIter1, _IIter2)"
.br
.ti -1c
.RI "long double \fBmodf\fP (long double __x, long double *__iptr)"
.br
.ti -1c
.RI "float \fBmodf\fP (float __x, float *__iptr)"
.br
.ti -1c
.RI "template<typename _II , typename _OI > _OI \fBmove\fP (_II __first, _II __last, _OI __result)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::remove_reference\fP< _Tp >::type && \fBmove\fP (_Tp &&__t)"
.br
.ti -1c
.RI "template<typename _BI1 , typename _BI2 > _BI2 \fBmove_backward\fP (_BI1 __first, _BI1 __last, _BI2 __result)"
.br
.ti -1c
.RI "template<typename _InputIterator > _InputIterator \fBnext\fP (_InputIterator __x, typename \fBiterator_traits\fP< _InputIterator >::difference_type __n=1)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > bool \fBnext_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > bool \fBnext_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _BIter , typename _Compare > bool \fBnext_permutation\fP (_BIter, _BIter, _Compare)"
.br
.ti -1c
.RI "template<typename _BIter > bool \fBnext_permutation\fP (_BIter, _BIter)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnoboolalpha\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fBnone_of\fP (_InputIterator __first, _InputIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _Predicate > bool \fBnone_of\fP (_IIter, _IIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__promote< _Tp >::__type \fBnorm\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBnorm\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnoshowbase\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnoshowpoint\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnoshowpos\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnoskipws\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Predicate > \fBunary_negate\fP< _Predicate > \fBnot1\fP (const _Predicate &__pred)"
.br
.ti -1c
.RI "template<typename _Predicate > \fBbinary_negate\fP< _Predicate > \fBnot2\fP (const _Predicate &__pred)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnounitbuf\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBnouppercase\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBnth_element\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBnth_element\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBnth_element\fP (_RAIter, _RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBnth_element\fP (_RAIter, _RAIter, _RAIter)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBoct\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __not_equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > \fBoperator!=\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __not_equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > \fBoperator!=\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __not_equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > \fBoperator!=\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __not_equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __not_equal_to, typename _Dom::value_type >::result_type > \fBoperator!=\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __not_equal_to, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __not_equal_to, typename _Dom1::value_type >::result_type > \fBoperator!=\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator!=\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > bool \fBoperator!=\fP (const \fBistreambuf_iterator\fP< _CharT, _Traits > &__a, const \fBistreambuf_iterator\fP< _CharT, _Traits > &__b)"
.br
.ti -1c
.RI "template<class _Tp , class _CharT , class _Traits , class _Dist > bool \fBoperator!=\fP (const \fBistream_iterator\fP< _Tp, _CharT, _Traits, _Dist > &__x, const \fBistream_iterator\fP< _Tp, _CharT, _Traits, _Dist > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator!=\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator!=\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Val > bool \fBoperator!=\fP (const _Rb_tree_iterator< _Val > &__x, const _Rb_tree_const_iterator< _Val > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator!=\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator!=\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator!=\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator!=\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator!=\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator!=\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator!=\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator!=\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Val > bool \fBoperator!=\fP (const \fB_List_iterator\fP< _Val > &__x, const \fB_List_const_iterator\fP< _Val > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator!=\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator!=\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator!=\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator!=\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _StateT > bool \fBoperator!=\fP (const \fBfpos\fP< _StateT > &__lhs, const \fBfpos\fP< _StateT > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator!=\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator!=\fP (const \fB_Fwd_list_iterator\fP< _Tp, _Alloc > &__x, const \fB_Fwd_list_const_iterator\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator!=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator!=\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator!=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator!=\fP (const \fBallocator\fP< _Tp > &, const \fBallocator\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _T1 , typename _T2 > bool \fBoperator!=\fP (const \fBallocator\fP< _T1 > &, const \fBallocator\fP< _T2 > &)"
.br
.ti -1c
.RI "template<typename _Bi_iter , class _Allocator > bool \fBoperator!=\fP (const \fBmatch_results\fP< _Bi_iter, _Allocator > &__m1, const \fBmatch_results\fP< _Bi_iter, _Allocator > &__m2)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator!=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator!=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator!=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator!=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator!=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator!=\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator!=\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Signature > bool \fBoperator!=\fP (_M_clear_type *, const function< _Signature > &__f)"
.br
.ti -1c
.RI "template<typename _Signature > bool \fBoperator!=\fP (const function< _Signature > &__f, _M_clear_type *)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator!=\fP (const \fBarray\fP< _Tp, _Nm > &__one, const \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __not_equal_to, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > \fBoperator!=\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __not_equal_to, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > \fBoperator!=\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __not_equal_to, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __not_equal_to, _Tp >::result_type > \fBoperator!=\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator!=\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (\fBthread::id\fP __x, \fBthread::id\fP __y)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBerror_condition\fP &__lhs, const \fBerror_condition\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBerror_condition\fP &__lhs, const \fBerror_code\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBerror_code\fP &__lhs, const \fBerror_condition\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBerror_code\fP &__lhs, const \fBerror_code\fP &__rhs)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __modulus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __modulus, typename _Dom::value_type >::result_type > \fBoperator%\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __modulus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __modulus, typename _Dom::value_type >::result_type > \fBoperator%\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __modulus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __modulus, typename _Dom::value_type >::result_type > \fBoperator%\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __modulus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __modulus, typename _Dom::value_type >::result_type > \fBoperator%\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __modulus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __modulus, typename _Dom1::value_type >::result_type > \fBoperator%\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __modulus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > \fBoperator%\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __modulus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > \fBoperator%\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __modulus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __modulus, _Tp >::result_type > \fBoperator%\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_and, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > \fBoperator&\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_and, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > \fBoperator&\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_and, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > \fBoperator&\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_and, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_and, typename _Dom::value_type >::result_type > \fBoperator&\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __bitwise_and, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_and, typename _Dom1::value_type >::result_type > \fBoperator&\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate \fBoperator&\fP (_Ios_Iostate __a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode \fBoperator&\fP (_Ios_Openmode __a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags \fBoperator&\fP (_Ios_Fmtflags __a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_and, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > \fBoperator&\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_and, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > \fBoperator&\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_and, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_and, _Tp >::result_type > \fBoperator&\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_and, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > \fBoperator&&\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_and, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > \fBoperator&&\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_and, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > \fBoperator&&\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_and, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __logical_and, typename _Dom::value_type >::result_type > \fBoperator&&\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __logical_and, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __logical_and, typename _Dom1::value_type >::result_type > \fBoperator&&\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_and, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > \fBoperator&&\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_and, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > \fBoperator&&\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_and, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __logical_and, _Tp >::result_type > \fBoperator&&\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate & \fBoperator&=\fP (_Ios_Iostate &__a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode & \fBoperator&=\fP (_Ios_Openmode &__a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags & \fBoperator&=\fP (_Ios_Fmtflags &__a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __multiplies, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > \fBoperator*\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __multiplies, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > \fBoperator*\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __multiplies, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > \fBoperator*\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __multiplies, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __multiplies, typename _Dom::value_type >::result_type > \fBoperator*\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __multiplies, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __multiplies, typename _Dom1::value_type >::result_type > \fBoperator*\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __multiplies, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > \fBoperator*\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __multiplies, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > \fBoperator*\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __multiplies, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __multiplies, _Tp >::result_type > \fBoperator*\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __plus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __plus, typename _Dom::value_type >::result_type > \fBoperator+\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __plus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __plus, typename _Dom::value_type >::result_type > \fBoperator+\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __plus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __plus, typename _Dom::value_type >::result_type > \fBoperator+\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __plus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __plus, typename _Dom::value_type >::result_type > \fBoperator+\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __plus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __plus, typename _Dom1::value_type >::result_type > \fBoperator+\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Iterator > \fBmove_iterator\fP< _Iterator > \fBoperator+\fP (typename \fBmove_iterator\fP< _Iterator >::difference_type __n, const \fBmove_iterator\fP< _Iterator > &__x)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > \fBoperator+\fP (ptrdiff_t __n, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x)"
.br
.ti -1c
.RI "_Bit_const_iterator \fBoperator+\fP (ptrdiff_t __n, const _Bit_const_iterator &__x)"
.br
.ti -1c
.RI "_Bit_iterator \fBoperator+\fP (ptrdiff_t __n, const _Bit_iterator &__x)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > \fBoperator+\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, _CharT __rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > \fBoperator+\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > \fBoperator+\fP (_CharT __lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > \fBoperator+\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > \fBoperator+\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __plus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > \fBoperator+\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __plus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > \fBoperator+\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __plus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __plus, _Tp >::result_type > \fBoperator+\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator+\fP (const \fBcomplex\fP< _Tp > &__x)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __minus, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __minus, typename _Dom::value_type >::result_type > \fBoperator-\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __minus, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __minus, typename _Dom::value_type >::result_type > \fBoperator-\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __minus, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __minus, typename _Dom::value_type >::result_type > \fBoperator-\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __minus, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __minus, typename _Dom::value_type >::result_type > \fBoperator-\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __minus, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __minus, typename _Dom1::value_type >::result_type > \fBoperator-\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > auto \fBoperator-\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)-> decltype(__x.base()-__y.base())"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL >::difference_type \fBoperator-\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr >::difference_type \fBoperator-\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "ptrdiff_t \fBoperator-\fP (const _Bit_iterator_base &__x, const _Bit_iterator_base &__y)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __minus, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > \fBoperator-\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __minus, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > \fBoperator-\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __minus, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __minus, _Tp >::result_type > \fBoperator-\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator-\fP (const \fBcomplex\fP< _Tp > &__x)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __divides, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __divides, typename _Dom::value_type >::result_type > \fBoperator/\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __divides, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __divides, typename _Dom::value_type >::result_type > \fBoperator/\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __divides, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __divides, typename _Dom::value_type >::result_type > \fBoperator/\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __divides, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __divides, typename _Dom::value_type >::result_type > \fBoperator/\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __divides, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __divides, typename _Dom1::value_type >::result_type > \fBoperator/\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __divides, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > \fBoperator/\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __divides, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > \fBoperator/\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __divides, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __divides, _Tp >::result_type > \fBoperator/\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less, typename _Dom::value_type >::result_type > \fBoperator<\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __less, typename _Dom::value_type >::result_type > \fBoperator<\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less, typename _Dom::value_type >::result_type > \fBoperator<\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __less, typename _Dom::value_type >::result_type > \fBoperator<\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __less, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __less, typename _Dom1::value_type >::result_type > \fBoperator<\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator<\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator<\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator<\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator<\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator<\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator<\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator<\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator<\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator<\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator<\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator<\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator<\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , class _Ch_traits , class _Ch_alloc > bool \fBoperator<\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator<\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator<\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator<\fP (const \fBarray\fP< _Tp, _Nm > &__a, const \fBarray\fP< _Tp, _Nm > &__b)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > \fBoperator<\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > \fBoperator<\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __less, _Tp >::result_type > \fBoperator<\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator<\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBerror_condition\fP &__lhs, const \fBerror_condition\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator<\fP (const \fBerror_code\fP &__lhs, const \fBerror_code\fP &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, const \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > &__str)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_left, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > \fBoperator<<\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_left, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > \fBoperator<<\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_left, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > \fBoperator<<\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_left, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __shift_left, typename _Dom::value_type >::result_type > \fBoperator<<\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __shift_left, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __shift_left, typename _Dom1::value_type >::result_type > \fBoperator<<\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__str)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBgamma_distribution\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBnormal_distribution\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBexponential_distribution\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBuniform_real\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBbinomial_distribution\fP< _IntType, _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBpoisson_distribution\fP< _IntType, _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBgeometric_distribution\fP< _IntType, _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBbernoulli_distribution\fP &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBuniform_int\fP< _IntType > &__x)"
.br
.ti -1c
.RI "template<class _UniformRandomNumberGenerator1 , int __s1, class _UniformRandomNumberGenerator2 , int __s2, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBxor_combine\fP< _UniformRandomNumberGenerator1, __s1, _UniformRandomNumberGenerator2, __s2 > &__x)"
.br
.ti -1c
.RI "template<class _UniformRandomNumberGenerator , int __p, int __r, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBdiscard_block\fP< _UniformRandomNumberGenerator, __p, __r > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , int __w, int __s, int __r, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const subtract_with_carry_01< _RealType, __w, __s, __r > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , _IntType __m, int __s, int __r, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const subtract_with_carry< _IntType, __m, __s, __r > &__x)"
.br
.ti -1c
.RI "template<class _UIntType , int __w, int __n, int __m, int __r, _UIntType __a, int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const mersenne_twister< _UIntType, __w, __n, __m, __r, __a, __u, __s, __b, __t, __c, __l > &__x)"
.br
.ti -1c
.RI "template<class _UIntType , _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT , typename _Traits > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBlinear_congruential\fP< _UIntType, __a, __c, __m > &__lcr)"
.br
.ti -1c
.RI "template<typename _Ch_type , typename _Ch_traits , typename _Bi_iter > \fBbasic_ostream\fP< _Ch_type, _Ch_traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _Ch_type, _Ch_traits > &__os, const \fBsub_match\fP< _Bi_iter > &__m)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_left, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > \fBoperator<<\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_left, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > \fBoperator<<\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_left, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __shift_left, _Tp >::result_type > \fBoperator<<\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &&__out, \fBthread::id\fP __id)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, const \fBerror_code\fP &__e)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Setw __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Setprecision __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Setfill< _CharT > __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Setbase __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Setiosflags __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, _Resetiosflags __f)"
.br
.ti -1c
.RI "template<typename _Tp , typename _CharT , class _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__os, const \fBcomplex\fP< _Tp > &__x)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > \fBoperator<=\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > \fBoperator<=\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less_equal, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > \fBoperator<=\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __less_equal, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __less_equal, typename _Dom::value_type >::result_type > \fBoperator<=\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __less_equal, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __less_equal, typename _Dom1::value_type >::result_type > \fBoperator<=\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator<=\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<=\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator<=\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator<=\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator<=\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator<=\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator<=\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator<=\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator<=\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator<=\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<=\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator<=\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<=\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator<=\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator<=\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator<=\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<=\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator<=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator<=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , class _Ch_traits , class _Ch_alloc > bool \fBoperator<=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator<=\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator<=\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator<=\fP (const \fBarray\fP< _Tp, _Nm > &__one, const \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less_equal, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > \fBoperator<=\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less_equal, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > \fBoperator<=\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __less_equal, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __less_equal, _Tp >::result_type > \fBoperator<=\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator<=\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator<=\fP (\fBthread::id\fP __x, \fBthread::id\fP __y)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __equal_to, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > \fBoperator==\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __equal_to, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > \fBoperator==\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __equal_to, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > \fBoperator==\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __equal_to, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __equal_to, typename _Dom::value_type >::result_type > \fBoperator==\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __equal_to, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __equal_to, typename _Dom1::value_type >::result_type > \fBoperator==\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator==\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > bool \fBoperator==\fP (const \fBistreambuf_iterator\fP< _CharT, _Traits > &__a, const \fBistreambuf_iterator\fP< _CharT, _Traits > &__b)"
.br
.ti -1c
.RI "template<typename _Tp , typename _CharT , typename _Traits , typename _Dist > bool \fBoperator==\fP (const \fBistream_iterator\fP< _Tp, _CharT, _Traits, _Dist > &__x, const \fBistream_iterator\fP< _Tp, _CharT, _Traits, _Dist > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator==\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator==\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Val > bool \fBoperator==\fP (const _Rb_tree_iterator< _Val > &__x, const _Rb_tree_const_iterator< _Val > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator==\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator==\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator==\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator==\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator==\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator==\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator==\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator==\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Val > bool \fBoperator==\fP (const \fB_List_iterator\fP< _Val > &__x, const \fB_List_const_iterator\fP< _Val > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator==\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator==\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator==\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator==\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _StateT > bool \fBoperator==\fP (const \fBfpos\fP< _StateT > &__lhs, const \fBfpos\fP< _StateT > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator==\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator==\fP (const \fB_Fwd_list_iterator\fP< _Tp, _Alloc > &__x, const \fB_Fwd_list_const_iterator\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator==\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator==\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT > __gnu_cxx::__enable_if< __is_char< _CharT >::__value, bool >::__type \fBoperator==\fP (const \fBbasic_string\fP< _CharT > &__lhs, const \fBbasic_string\fP< _CharT > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator==\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator==\fP (const \fBallocator\fP< _Tp > &, const \fBallocator\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _T1 , typename _T2 > bool \fBoperator==\fP (const \fBallocator\fP< _T1 > &, const \fBallocator\fP< _T2 > &)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Allocator > bool \fBoperator==\fP (const \fBmatch_results\fP< _Bi_iter, _Allocator > &__m1, const \fBmatch_results\fP< _Bi_iter, _Allocator > &__m2)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator==\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator==\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator==\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator==\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator==\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator==\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator==\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Signature > bool \fBoperator==\fP (_M_clear_type *, const function< _Signature > &__f)"
.br
.ti -1c
.RI "template<typename _Signature > bool \fBoperator==\fP (const function< _Signature > &__f, _M_clear_type *)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator==\fP (const \fBarray\fP< _Tp, _Nm > &__one, const \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __equal_to, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > \fBoperator==\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __equal_to, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > \fBoperator==\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __equal_to, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __equal_to, _Tp >::result_type > \fBoperator==\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator==\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBerror_condition\fP &__lhs, const \fBerror_condition\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBerror_condition\fP &__lhs, const \fBerror_code\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBerror_code\fP &__lhs, const \fBerror_condition\fP &__rhs)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBerror_code\fP &__lhs, const \fBerror_code\fP &__rhs)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater, typename _Dom::value_type >::result_type > \fBoperator>\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __greater, typename _Dom::value_type >::result_type > \fBoperator>\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater, typename _Dom::value_type >::result_type > \fBoperator>\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __greater, typename _Dom::value_type >::result_type > \fBoperator>\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __greater, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __greater, typename _Dom1::value_type >::result_type > \fBoperator>\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator>\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator>\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator>\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator>\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator>\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator>\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator>\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator>\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator>\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator>\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator>\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator>\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , class _Ch_traits , class _Ch_alloc > bool \fBoperator>\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator>\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator>\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator>\fP (const \fBarray\fP< _Tp, _Nm > &__one, const \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > \fBoperator>\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > \fBoperator>\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __greater, _Tp >::result_type > \fBoperator>\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator>\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator>\fP (\fBthread::id\fP __x, \fBthread::id\fP __y)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater_equal, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > \fBoperator>=\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater_equal, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > \fBoperator>=\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater_equal, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > \fBoperator>=\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __greater_equal, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __greater_equal, typename _Dom::value_type >::result_type > \fBoperator>=\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __greater_equal, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __greater_equal, typename _Dom1::value_type >::result_type > \fBoperator>=\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter , typename _Up , typename _Up_Deleter > bool \fBoperator>=\fP (const \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, const \fBunique_ptr\fP< _Up, _Up_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>=\fP (const \fBvector\fP< _Tp, _Alloc > &__x, const \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > bool \fBoperator>=\fP (const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, const _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator>=\fP (const \fBstack\fP< _Tp, _Seq > &__x, const \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator>=\fP (const \fBset\fP< _Key, _Compare, _Alloc > &__x, const \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > bool \fBoperator>=\fP (const \fBqueue\fP< _Tp, _Seq > &__x, const \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > bool \fBoperator>=\fP (const \fBpair\fP< _T1, _T2 > &__x, const \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > bool \fBoperator>=\fP (const \fBmultiset\fP< _Key, _Compare, _Alloc > &__x, const \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator>=\fP (const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool \fBoperator>=\fP (const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, const \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>=\fP (const \fBlist\fP< _Tp, _Alloc > &__x, const \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator>=\fP (const \fBmove_iterator\fP< _IteratorL > &__x, const \fBmove_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>=\fP (const \fBdeque\fP< _Tp, _Alloc > &__x, const \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _RefL , typename _PtrL , typename _RefR , typename _PtrR > bool \fBoperator>=\fP (const \fB_Deque_iterator\fP< _Tp, _RefL, _PtrL > &__x, const \fB_Deque_iterator\fP< _Tp, _RefR, _PtrR > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Ref , typename _Ptr > bool \fBoperator>=\fP (const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__x, const \fB_Deque_iterator\fP< _Tp, _Ref, _Ptr > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > bool \fBoperator>=\fP (const \fBforward_list\fP< _Tp, _Alloc > &__lx, const \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>=\fP (const _CharT *__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > bool \fBoperator>=\fP (const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, const \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter > bool \fBoperator>=\fP (typename \fBiterator_traits\fP< _Bi_iter >::value_type const *__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , class _Ch_traits , class _Ch_alloc > bool \fBoperator>=\fP (const \fBsub_match\fP< _Bi_iter > &__lhs, const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_traits , typename _Ch_alloc > bool \fBoperator>=\fP (const \fBbasic_string\fP< typename \fBiterator_traits\fP< _Bi_iter >::value_type, _Ch_traits, _Ch_alloc > &__lhs, const \fBsub_match\fP< _Bi_iter > &__rhs)"
.br
.ti -1c
.RI "template<typename _BiIter > bool \fBoperator>=\fP (const \fBsub_match\fP< _BiIter > &__lhs, const \fBsub_match\fP< _BiIter > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> bool \fBoperator>=\fP (const \fBarray\fP< _Tp, _Nm > &__one, const \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater_equal, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > \fBoperator>=\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater_equal, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > \fBoperator>=\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __greater_equal, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __greater_equal, _Tp >::result_type > \fBoperator>=\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> bool \fBoperator>=\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBoperator>=\fP (\fBthread::id\fP __x, \fBthread::id\fP __y)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > &__str)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_right, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > \fBoperator>>\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_right, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > \fBoperator>>\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_right, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > \fBoperator>>\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __shift_right, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __shift_right, typename _Dom::value_type >::result_type > \fBoperator>>\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __shift_right, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __shift_right, typename _Dom1::value_type >::result_type > \fBoperator>>\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<> \fBbasic_istream\fP< char > & \fBoperator>>\fP (\fBbasic_istream\fP< char > &__is, \fBbasic_string\fP< char > &__str)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__str)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBnormal_distribution\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBuniform_real\fP< _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBbinomial_distribution\fP< _IntType, _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _RealType , typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBpoisson_distribution\fP< _IntType, _RealType > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBuniform_int\fP< _IntType > &__x)"
.br
.ti -1c
.RI "template<class _UniformRandomNumberGenerator1 , int __s1, class _UniformRandomNumberGenerator2 , int __s2, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBxor_combine\fP< _UniformRandomNumberGenerator1, __s1, _UniformRandomNumberGenerator2, __s2 > &__x)"
.br
.ti -1c
.RI "template<class _UniformRandomNumberGenerator , int __p, int __r, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBdiscard_block\fP< _UniformRandomNumberGenerator, __p, __r > &__x)"
.br
.ti -1c
.RI "template<typename _RealType , int __w, int __s, int __r, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, subtract_with_carry_01< _RealType, __w, __s, __r > &__x)"
.br
.ti -1c
.RI "template<typename _IntType , _IntType __m, int __s, int __r, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, subtract_with_carry< _IntType, __m, __s, __r > &__x)"
.br
.ti -1c
.RI "template<class _UIntType , int __w, int __n, int __m, int __r, _UIntType __a, int __u, int __s, _UIntType __b, int __t, _UIntType __c, int __l, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, mersenne_twister< _UIntType, __w, __n, __m, __r, __a, __u, __s, __b, __t, __c, __l > &__x)"
.br
.ti -1c
.RI "template<class _UIntType , _UIntType __a, _UIntType __c, _UIntType __m, typename _CharT , typename _Traits > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBlinear_congruential\fP< _UIntType, __a, __c, __m > &__lcr)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_right, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > \fBoperator>>\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_right, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > \fBoperator>>\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __shift_right, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __shift_right, _Tp >::result_type > \fBoperator>>\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Setw __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Setprecision __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Setfill< _CharT > __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Setbase __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Setiosflags __f)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, _Resetiosflags __f)"
.br
.ti -1c
.RI "template<typename _Tp , typename _CharT , class _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is, \fBcomplex\fP< _Tp > &__x)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_xor, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > \fBoperator^\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_xor, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > \fBoperator^\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_xor, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > \fBoperator^\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_xor, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_xor, typename _Dom::value_type >::result_type > \fBoperator^\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __bitwise_xor, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_xor, typename _Dom1::value_type >::result_type > \fBoperator^\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate \fBoperator^\fP (_Ios_Iostate __a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode \fBoperator^\fP (_Ios_Openmode __a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags \fBoperator^\fP (_Ios_Fmtflags __a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_xor, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > \fBoperator^\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_xor, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > \fBoperator^\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_xor, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_xor, _Tp >::result_type > \fBoperator^\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate & \fBoperator^=\fP (_Ios_Iostate &__a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode & \fBoperator^=\fP (_Ios_Openmode &__a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags & \fBoperator^=\fP (_Ios_Fmtflags &__a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_or, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > \fBoperator|\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_or, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > \fBoperator|\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_or, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > \fBoperator|\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __bitwise_or, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __bitwise_or, typename _Dom::value_type >::result_type > \fBoperator|\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __bitwise_or, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __bitwise_or, typename _Dom1::value_type >::result_type > \fBoperator|\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate \fBoperator|\fP (_Ios_Iostate __a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode \fBoperator|\fP (_Ios_Openmode __a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags \fBoperator|\fP (_Ios_Fmtflags __a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_or, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > \fBoperator|\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_or, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > \fBoperator|\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __bitwise_or, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __bitwise_or, _Tp >::result_type > \fBoperator|\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate & \fBoperator|=\fP (_Ios_Iostate &__a, _Ios_Iostate __b)"
.br
.ti -1c
.RI "_Ios_Openmode & \fBoperator|=\fP (_Ios_Openmode &__a, _Ios_Openmode __b)"
.br
.ti -1c
.RI "_Ios_Fmtflags & \fBoperator|=\fP (_Ios_Fmtflags &__a, _Ios_Fmtflags __b)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_or, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > \fBoperator||\fP (const \fBvalarray\fP< typename _Dom::value_type > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_or, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > \fBoperator||\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_or, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > \fBoperator||\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __logical_or, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename __fun< __logical_or, typename _Dom::value_type >::result_type > \fBoperator||\fP (const _Expr< _Dom, typename _Dom::value_type > &__v, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __logical_or, _Expr, _Expr, _Dom1, _Dom2 >, typename __fun< __logical_or, typename _Dom1::value_type >::result_type > \fBoperator||\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__v, const _Expr< _Dom2, typename _Dom2::value_type > &__w)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_or, _Constant, _ValArray, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > \fBoperator||\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_or, _ValArray, _Constant, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > \fBoperator||\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __logical_or, _ValArray, _ValArray, _Tp, _Tp >, typename __fun< __logical_or, _Tp >::result_type > \fBoperator||\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "_Ios_Iostate \fBoperator~\fP (_Ios_Iostate __a)"
.br
.ti -1c
.RI "_Ios_Openmode \fBoperator~\fP (_Ios_Openmode __a)"
.br
.ti -1c
.RI "_Ios_Fmtflags \fBoperator~\fP (_Ios_Fmtflags __a)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBpartial_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBpartial_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBpartial_sort\fP (_RAIter, _RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBpartial_sort\fP (_RAIter, _RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator , typename _Compare > _RandomAccessIterator \fBpartial_sort_copy\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator \fBpartial_sort_copy\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)"
.br
.ti -1c
.RI "template<typename _IIter , typename _RAIter , typename _Compare > _RAIter \fBpartial_sort_copy\fP (_IIter, _IIter, _RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter , typename _RAIter > _RAIter \fBpartial_sort_copy\fP (_IIter, _IIter, _RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fBpartial_sum\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator > _OutputIterator \fBpartial_sum\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator \fBpartition\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _BIter , typename _Predicate > _BIter \fBpartition\fP (_BIter, _BIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator1 , typename _OutputIterator2 , typename _Predicate > \fBpair\fP< _OutputIterator1, _OutputIterator2 > \fBpartition_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter1 , typename _OIter2 , typename _Predicate > \fBpair\fP< _OIter1, _OIter2 > \fBpartition_copy\fP (_IIter, _IIter, _OIter1, _OIter2, _Predicate)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator \fBpartition_point\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Predicate > _FIter \fBpartition_point\fP (_FIter, _FIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBpolar\fP (const _Tp &, const _Tp &=0)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBpop_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBpop_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBpop_heap\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBpop_heap\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __pow, _Constant, _ValArray, _Tp, _Tp >, _Tp > \fBpow\fP (const _Tp &__t, const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __pow, _ValArray, _Constant, _Tp, _Tp >, _Tp > \fBpow\fP (const \fBvalarray\fP< _Tp > &__v, const _Tp &__t)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _BinClos< __pow, _ValArray, _ValArray, _Tp, _Tp >, _Tp > \fBpow\fP (const \fBvalarray\fP< _Tp > &__v, const \fBvalarray\fP< _Tp > &__w)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __pow, _Constant, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > \fBpow\fP (const typename _Dom::value_type &__t, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __pow, _Expr, _Constant, _Dom, typename _Dom::value_type >, typename _Dom::value_type > \fBpow\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const typename _Dom::value_type &__t)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __pow, _ValArray, _Expr, typename _Dom::value_type, _Dom >, typename _Dom::value_type > \fBpow\fP (const \fBvalarray\fP< typename _Dom::valarray > &__v, const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _BinClos< __pow, _Expr, _ValArray, _Dom, typename _Dom::value_type >, typename _Dom::value_type > \fBpow\fP (const _Expr< _Dom, typename _Dom::value_type > &__e, const \fBvalarray\fP< typename _Dom::value_type > &__v)"
.br
.ti -1c
.RI "template<class _Dom1 , class _Dom2 > _Expr< _BinClos< __pow, _Expr, _Expr, _Dom1, _Dom2 >, typename _Dom1::value_type > \fBpow\fP (const _Expr< _Dom1, typename _Dom1::value_type > &__e1, const _Expr< _Dom2, typename _Dom2::value_type > &__e2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Up > \fBstd::complex\fP< typename __gnu_cxx::__promote_2< _Tp, _Up >::__type > \fBpow\fP (const \fBstd::complex\fP< _Tp > &__x, const \fBstd::complex\fP< _Up > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Up > \fBstd::complex\fP< typename __gnu_cxx::__promote_2< _Tp, _Up >::__type > \fBpow\fP (const _Tp &__x, const \fBstd::complex\fP< _Up > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Up > \fBstd::complex\fP< typename __gnu_cxx::__promote_2< _Tp, _Up >::__type > \fBpow\fP (const \fBstd::complex\fP< _Tp > &__x, const _Up &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Up > __gnu_cxx::__promote_2< typename __gnu_cxx::__enable_if< __is_arithmetic< _Tp >::__value &&__is_arithmetic< _Up >::__value, _Tp >::__type, _Up >::__type \fBpow\fP (_Tp __x, _Up __y)"
.br
.ti -1c
.RI "long double \fBpow\fP (long double __x, long double __y)"
.br
.ti -1c
.RI "float \fBpow\fP (float __x, float __y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBpow\fP (const _Tp &, const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBpow\fP (const \fBcomplex\fP< _Tp > &, const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBpow\fP (const \fBcomplex\fP< _Tp > &, const _Tp &)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > _BidirectionalIterator \fBprev\fP (_BidirectionalIterator __x, typename \fBiterator_traits\fP< _BidirectionalIterator >::difference_type __n=1)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > bool \fBprev_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > bool \fBprev_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _BIter , typename _Compare > bool \fBprev_permutation\fP (_BIter, _BIter, _Compare)"
.br
.ti -1c
.RI "template<typename _BIter > bool \fBprev_permutation\fP (_BIter, _BIter)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< typename __gnu_cxx::__promote< _Tp >::__type > \fBproj\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBstd::complex\fP< _Tp > \fBproj\fP (const \fBstd::complex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Arg1 , typename _Arg2 , typename _Result > \fBpointer_to_binary_function\fP< _Arg1, _Arg2, _Result > \fBptr_fun\fP (_Result(*__x)(_Arg1, _Arg2))"
.br
.ti -1c
.RI "template<typename _Arg , typename _Result > \fBpointer_to_unary_function\fP< _Arg, _Result > \fBptr_fun\fP (_Result(*__x)(_Arg))"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBpush_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBpush_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBpush_heap\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBpush_heap\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _RandomNumberGenerator > void \fBrandom_shuffle\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &__rand)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBrandom_shuffle\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Generator > void \fBrandom_shuffle\fP (_RAIter, _RAIter, _Generator &)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBrandom_shuffle\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__promote< _Tp >::__type \fBreal\fP (_Tp __x)"
.br
.ti -1c
.RI "template<typename _Tp > _Tp \fBreal\fP (const \fBcomplex\fP< _Tp > &__z)"
.br
.ti -1c
.RI "template<typename _Tp > \fBreference_wrapper\fP< _Tp > \fBref\fP (\fBreference_wrapper\fP< _Tp > __t)"
.br
.ti -1c
.RI "template<typename _Tp > \fBreference_wrapper\fP< _Tp > \fBref\fP (_Tp &__t)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > _ForwardIterator \fBremove\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > _FIter \fBremove\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _Tp > _OutputIterator \fBremove_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _Tp > _OIter \fBremove_copy\fP (_IIter, _IIter, _OIter, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _Predicate > _OutputIterator \fBremove_copy_if\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _Predicate > _OIter \fBremove_copy_if\fP (_IIter, _IIter, _OIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator \fBremove_if\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Predicate > _FIter \fBremove_if\fP (_FIter, _FIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > void \fBreplace\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__old_value, const _Tp &__new_value)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > void \fBreplace\fP (_FIter, _FIter, const _Tp &, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _Tp > _OutputIterator \fBreplace_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &__old_value, const _Tp &__new_value)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _Tp > _OIter \fBreplace_copy\fP (_IIter, _IIter, _OIter, const _Tp &, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _Predicate , typename _Tp > _OutputIterator \fBreplace_copy_if\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &__new_value)"
.br
.ti -1c
.RI "template<typename _Iter , typename _OIter , typename _Predicate , typename _Tp > _OIter \fBreplace_copy_if\fP (_Iter, _Iter, _OIter, _Predicate, const _Tp &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate , typename _Tp > void \fBreplace_if\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &__new_value)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Predicate , typename _Tp > void \fBreplace_if\fP (_FIter, _FIter, _Predicate, const _Tp &)"
.br
.ti -1c
.RI "_Resetiosflags \fBresetiosflags\fP (\fBios_base::fmtflags\fP __mask)"
.br
.ti -1c
.RI "void \fBrethrow_exception\fP (exception_ptr) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "template<typename _Tp > void \fBreturn_temporary_buffer\fP (_Tp *__p)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > void \fBreverse\fP (_BidirectionalIterator __first, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _BIter > void \fBreverse\fP (_BIter, _BIter)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _OutputIterator > _OutputIterator \fBreverse_copy\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _BIter , typename _OIter > _OIter \fBreverse_copy\fP (_BIter, _BIter, _OIter)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBright\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fBrotate\fP (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter > void \fBrotate\fP (_FIter, _FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator > _OutputIterator \fBrotate_copy\fP (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _FIter , typename _OIter > _OIter \fBrotate_copy\fP (_FIter, _FIter, _FIter, _OIter)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBscientific\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 , typename _BinaryPredicate > _ForwardIterator1 \fBsearch\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __predicate)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 > _ForwardIterator1 \fBsearch\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2, _ForwardIterator2 __last2)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 , typename _BinaryPredicate > _FIter1 \fBsearch\fP (_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 > _FIter1 \fBsearch\fP (_FIter1, _FIter1, _FIter2, _FIter2)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate > _ForwardIterator \fBsearch_n\fP (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Integer , typename _Tp > _ForwardIterator \fBsearch_n\fP (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Size , typename _Tp , typename _BinaryPredicate > _FIter \fBsearch_n\fP (_FIter, _FIter, _Size, const _Tp &, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Size , typename _Tp > _FIter \fBsearch_n\fP (_FIter, _FIter, _Size, const _Tp &)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBset_difference\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBset_difference\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _Compare > _OIter \fBset_difference\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter > _OIter \fBset_difference\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBset_intersection\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBset_intersection\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _Compare > _OIter \fBset_intersection\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter > _OIter \fBset_intersection\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter)"
.br
.ti -1c
.RI "\fBnew_handler\fP \fBset_new_handler\fP (\fBnew_handler\fP)  throw ()"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBset_symmetric_difference\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBset_symmetric_difference\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _Compare > _OIter \fBset_symmetric_difference\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter > _OIter \fBset_symmetric_difference\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter)"
.br
.ti -1c
.RI "\fBterminate_handler\fP \fBset_terminate\fP (\fBterminate_handler\fP)  throw ()"
.br
.ti -1c
.RI "\fBunexpected_handler\fP \fBset_unexpected\fP (\fBunexpected_handler\fP)  throw ()"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBset_union\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBset_union\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _Compare > _OIter \fBset_union\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter > _OIter \fBset_union\fP (_IIter1, _IIter1, _IIter2, _IIter2, _OIter)"
.br
.ti -1c
.RI "_Setbase \fBsetbase\fP (int __base)"
.br
.ti -1c
.RI "template<typename _CharT > _Setfill< _CharT > \fBsetfill\fP (_CharT __c)"
.br
.ti -1c
.RI "_Setiosflags \fBsetiosflags\fP (\fBios_base::fmtflags\fP __mask)"
.br
.ti -1c
.RI "_Setprecision \fBsetprecision\fP (int __n)"
.br
.ti -1c
.RI "_Setw \fBsetw\fP (int __n)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBshowbase\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBshowpoint\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBshowpos\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __sin, _ValArray, _Tp >, _Tp > \fBsin\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __sin, _Expr, _Dom >, typename _Dom::value_type > \fBsin\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBsin\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBsin\fP (long double __x)"
.br
.ti -1c
.RI "float \fBsin\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBsin\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __sinh, _ValArray, _Tp >, _Tp > \fBsinh\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __sinh, _Expr, _Dom >, typename _Dom::value_type > \fBsinh\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBsinh\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBsinh\fP (long double __x)"
.br
.ti -1c
.RI "float \fBsinh\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBsinh\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBskipws\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBsort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBsort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBsort\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBsort\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBsort_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBsort_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBsort_heap\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBsort_heap\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __sqrt, _ValArray, _Tp >, _Tp > \fBsqrt\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __sqrt, _Expr, _Dom >, typename _Dom::value_type > \fBsqrt\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBsqrt\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBsqrt\fP (long double __x)"
.br
.ti -1c
.RI "float \fBsqrt\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBsqrt\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator \fBstable_partition\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _BIter , typename _Predicate > _BIter \fBstable_partition\fP (_BIter, _BIter, _Predicate)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBstable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBstable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RAIter , typename _Compare > void \fBstable_sort\fP (_RAIter, _RAIter, _Compare)"
.br
.ti -1c
.RI "template<typename _RAIter > void \fBstable_sort\fP (_RAIter, _RAIter)"
.br
.ti -1c
.RI "char * \fBstrchr\fP (char *__s1, int __n)"
.br
.ti -1c
.RI "char * \fBstrpbrk\fP (char *__s1, const char *__s2)"
.br
.ti -1c
.RI "char * \fBstrrchr\fP (char *__s1, int __n)"
.br
.ti -1c
.RI "char * \fBstrstr\fP (char *__s1, const char *__s2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter > void \fBswap\fP (\fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, \fBunique_ptr\fP< _Tp, _Tp_Deleter > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter > void \fBswap\fP (\fBunique_ptr\fP< _Tp, _Tp_Deleter > &&__x, \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Tp_Deleter > void \fBswap\fP (\fBunique_ptr\fP< _Tp, _Tp_Deleter > &__x, \fBunique_ptr\fP< _Tp, _Tp_Deleter > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBvector\fP< _Tp, _Alloc > &__x, \fBvector\fP< _Tp, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBvector\fP< _Tp, _Alloc > &&__x, \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBvector\fP< _Tp, _Alloc > &__x, \fBvector\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Val , typename _KeyOfValue , typename _Compare , typename _Alloc > void \fBswap\fP (_Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__x, _Rb_tree< _Key, _Val, _KeyOfValue, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBstack\fP< _Tp, _Seq > &__x, \fBstack\fP< _Tp, _Seq > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBstack\fP< _Tp, _Seq > &&__x, \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBstack\fP< _Tp, _Seq > &__x, \fBstack\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBset\fP< _Key, _Compare, _Alloc > &__x, \fBset\fP< _Key, _Compare, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBset\fP< _Key, _Compare, _Alloc > &&__x, \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBset\fP< _Key, _Compare, _Alloc > &__x, \fBset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Sequence , typename _Compare > void \fBswap\fP (\fBpriority_queue\fP< _Tp, _Sequence, _Compare > &__x, \fBpriority_queue\fP< _Tp, _Sequence, _Compare > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Sequence , typename _Compare > void \fBswap\fP (\fBpriority_queue\fP< _Tp, _Sequence, _Compare > &&__x, \fBpriority_queue\fP< _Tp, _Sequence, _Compare > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Sequence , typename _Compare > void \fBswap\fP (\fBpriority_queue\fP< _Tp, _Sequence, _Compare > &__x, \fBpriority_queue\fP< _Tp, _Sequence, _Compare > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBqueue\fP< _Tp, _Seq > &__x, \fBqueue\fP< _Tp, _Seq > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBqueue\fP< _Tp, _Seq > &&__x, \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Seq > void \fBswap\fP (\fBqueue\fP< _Tp, _Seq > &__x, \fBqueue\fP< _Tp, _Seq > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > void \fBswap\fP (\fBpair\fP< _T1, _T2 > &__x, \fBpair\fP< _T1, _T2 > &&__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > void \fBswap\fP (\fBpair\fP< _T1, _T2 > &&__x, \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<class _T1 , class _T2 > void \fBswap\fP (\fBpair\fP< _T1, _T2 > &__x, \fBpair\fP< _T1, _T2 > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultiset\fP< _Key, _Compare, _Alloc > &__x, \fBmultiset\fP< _Key, _Compare, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultiset\fP< _Key, _Compare, _Alloc > &&__x, \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultiset\fP< _Key, _Compare, _Alloc > &__x, \fBmultiset\fP< _Key, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &&__x, \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__x, \fBmultimap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &&__x, \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void \fBswap\fP (\fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__x, \fBmap\fP< _Key, _Tp, _Compare, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBlist\fP< _Tp, _Alloc > &__x, \fBlist\fP< _Tp, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBlist\fP< _Tp, _Alloc > &&__x, \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBlist\fP< _Tp, _Alloc > &__x, \fBlist\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBdeque\fP< _Tp, _Alloc > &__x, \fBdeque\fP< _Tp, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBdeque\fP< _Tp, _Alloc > &&__x, \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBdeque\fP< _Tp, _Alloc > &__x, \fBdeque\fP< _Tp, _Alloc > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBforward_list\fP< _Tp, _Alloc > &__lx, \fBforward_list\fP< _Tp, _Alloc > &&__ly)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBforward_list\fP< _Tp, _Alloc > &&__lx, \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Alloc > void \fBswap\fP (\fBforward_list\fP< _Tp, _Alloc > &__lx, \fBforward_list\fP< _Tp, _Alloc > &__ly)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Alloc > void \fBswap\fP (\fBbasic_string\fP< _CharT, _Traits, _Alloc > &__lhs, \fBbasic_string\fP< _CharT, _Traits, _Alloc > &__rhs)"
.br
.ti -1c
.RI "template<typename _Tp , size_t _Nm> void \fBswap\fP (_Tp(&)[_Nm], _Tp(&)[_Nm])"
.br
.ti -1c
.RI "template<typename _Tp > void \fBswap\fP (_Tp &__a, _Tp &__b)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &__x, \fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &&__x, \fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &__x, \fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &&__x, \fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &__x, \fBunordered_multiset\fP< _Value, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &__x, \fBunordered_set\fP< _Value, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc , bool __cache_hash_code> void \fBswap\fP (__unordered_multiset< _Value, _Hash, _Pred, _Alloc, __cache_hash_code > &__x, __unordered_multiset< _Value, _Hash, _Pred, _Alloc, __cache_hash_code > &__y)"
.br
.ti -1c
.RI "template<class _Value , class _Hash , class _Pred , class _Alloc , bool __cache_hash_code> void \fBswap\fP (__unordered_set< _Value, _Hash, _Pred, _Alloc, __cache_hash_code > &__x, __unordered_set< _Value, _Hash, _Pred, _Alloc, __cache_hash_code > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__x, \fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&__x, \fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__x, \fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &&__x, \fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__x, \fBunordered_multimap\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc > void \fBswap\fP (\fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__x, \fBunordered_map\fP< _Key, _Tp, _Hash, _Pred, _Alloc > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc , bool __cache_hash_code> void \fBswap\fP (__unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc, __cache_hash_code > &__x, __unordered_multimap< _Key, _Tp, _Hash, _Pred, _Alloc, __cache_hash_code > &__y)"
.br
.ti -1c
.RI "template<class _Key , class _Tp , class _Hash , class _Pred , class _Alloc , bool __cache_hash_code> void \fBswap\fP (__unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc, __cache_hash_code > &__x, __unordered_map< _Key, _Tp, _Hash, _Pred, _Alloc, __cache_hash_code > &__y)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Allocator > void \fBswap\fP (\fBmatch_results\fP< _Bi_iter, _Allocator > &__lhs, \fBmatch_results\fP< _Bi_iter, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Ch_type , typename _Rx_traits > void \fBswap\fP (\fBbasic_regex\fP< _Ch_type, _Rx_traits > &__lhs, \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__rhs)"
.br
.ti -1c
.RI "template<typename _Signature > void \fBswap\fP (function< _Signature > &__x, function< _Signature > &__y)"
.br
.ti -1c
.RI "template<typename _Tp , std::size_t _Nm> void \fBswap\fP (\fBarray\fP< _Tp, _Nm > &__one, \fBarray\fP< _Tp, _Nm > &__two)"
.br
.ti -1c
.RI "template<typename... _Elements> void \fBswap\fP (\fBtuple\fP< _Elements...> &__x, \fBtuple\fP< _Elements...> &&__y)"
.br
.ti -1c
.RI "template<typename... _Elements> void \fBswap\fP (\fBtuple\fP< _Elements...> &&__x, \fBtuple\fP< _Elements...> &__y)"
.br
.ti -1c
.RI "template<typename... _Elements> void \fBswap\fP (\fBtuple\fP< _Elements...> &__x, \fBtuple\fP< _Elements...> &__y)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBthread\fP &__x, \fBthread\fP &&__y)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBthread\fP &&__x, \fBthread\fP &__y)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBthread\fP &__x, \fBthread\fP &__y)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBswap\fP (\fBunique_lock\fP< _Mutex > &__x, \fBunique_lock\fP< _Mutex > &&__y)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBswap\fP (\fBunique_lock\fP< _Mutex > &&__x, \fBunique_lock\fP< _Mutex > &__y)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBswap\fP (\fBunique_lock\fP< _Mutex > &__x, \fBunique_lock\fP< _Mutex > &__y)"
.br
.ti -1c
.RI "template<typename _ForwardIterator1 , typename _ForwardIterator2 > _ForwardIterator2 \fBswap_ranges\fP (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)"
.br
.ti -1c
.RI "template<typename _FIter1 , typename _FIter2 > _FIter2 \fBswap_ranges\fP (_FIter1, _FIter1, _FIter2)"
.br
.ti -1c
.RI "const \fBerror_category\fP & \fBsystem_category\fP ()"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __tan, _ValArray, _Tp >, _Tp > \fBtan\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __tan, _Expr, _Dom >, typename _Dom::value_type > \fBtan\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBtan\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBtan\fP (long double __x)"
.br
.ti -1c
.RI "float \fBtan\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBtan\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Tp > _Expr< _UnClos< __tanh, _ValArray, _Tp >, _Tp > \fBtanh\fP (const \fBvalarray\fP< _Tp > &__v)"
.br
.ti -1c
.RI "template<class _Dom > _Expr< _UnClos< __tanh, _Expr, _Dom >, typename _Dom::value_type > \fBtanh\fP (const _Expr< _Dom, typename _Dom::value_type > &__e)"
.br
.ti -1c
.RI "template<typename _Tp > __gnu_cxx::__enable_if< __is_integer< _Tp >::__value, double >::__type \fBtanh\fP (_Tp __x)"
.br
.ti -1c
.RI "long double \fBtanh\fP (long double __x)"
.br
.ti -1c
.RI "float \fBtanh\fP (float __x)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBtanh\fP (const \fBcomplex\fP< _Tp > &)"
.br
.ti -1c
.RI "void \fBterminate\fP () __attribute__((__noreturn__))"
.br
.ti -1c
.RI "template<typename... _Elements> \fBtuple\fP< _Elements &...> \fBtie\fP (_Elements &...__args)"
.br
.ti -1c
.RI "template<typename _CharT > _CharT \fBtolower\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _CharT > _CharT \fBtoupper\fP (_CharT __c, const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _BinaryOperation > _OutputIterator \fBtransform\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _UnaryOperation > _OutputIterator \fBtransform\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)"
.br
.ti -1c
.RI "template<typename _IIter1 , typename _IIter2 , typename _OIter , typename _BinaryOperation > _OIter \fBtransform\fP (_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _UnaryOperation > _OIter \fBtransform\fP (_IIter, _IIter, _OIter, _UnaryOperation)"
.br
.ti -1c
.RI "template<typename _Lock1 , typename _Lock2 , typename... _Lock3> int \fBtry_lock\fP (_Lock1 &__l1, _Lock2 &__l2, _Lock3 &...__l3)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> \fBtuple\fP< _TElements..., _UElements...> \fBtuple_cat\fP (\fBtuple\fP< _TElements...> &&__t, \fBtuple\fP< _UElements...> &&__u)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> \fBtuple\fP< _TElements..., _UElements...> \fBtuple_cat\fP (const \fBtuple\fP< _TElements...> &__t, \fBtuple\fP< _UElements...> &&__u)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> \fBtuple\fP< _TElements..., _UElements...> \fBtuple_cat\fP (\fBtuple\fP< _TElements...> &&__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "template<typename... _TElements, typename... _UElements> \fBtuple\fP< _TElements..., _UElements...> \fBtuple_cat\fP (const \fBtuple\fP< _TElements...> &__t, const \fBtuple\fP< _UElements...> &__u)"
.br
.ti -1c
.RI "bool \fBuncaught_exception\fP ()  throw ()"
.br
.ti -1c
.RI "void \fBunexpected\fP () __attribute__((__noreturn__))"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _ForwardIterator > _ForwardIterator \fBuninitialized_copy\fP (_InputIterator __first, _InputIterator __last, _ForwardIterator __result)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _ForwardIterator > _ForwardIterator \fBuninitialized_copy_n\fP (_InputIterator __first, _Size __n, _ForwardIterator __result)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > void \fBuninitialized_fill\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Size , typename _Tp > void \fBuninitialized_fill_n\fP (_ForwardIterator __first, _Size __n, const _Tp &__x)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _BinaryPredicate > _ForwardIterator \fBunique\fP (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBunique\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _FIter , typename _BinaryPredicate > _FIter \fBunique\fP (_FIter, _FIter, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _FIter > _FIter \fBunique\fP (_FIter, _FIter)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator , typename _BinaryPredicate > _OutputIterator \fBunique_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _OutputIterator > _OutputIterator \fBunique_copy\fP (_InputIterator __first, _InputIterator __last, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter , typename _BinaryPredicate > _OIter \fBunique_copy\fP (_IIter, _IIter, _OIter, _BinaryPredicate)"
.br
.ti -1c
.RI "template<typename _IIter , typename _OIter > _OIter \fBunique_copy\fP (_IIter, _IIter, _OIter)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBunitbuf\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator \fBupper_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > _ForwardIterator \fBupper_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp , typename _Compare > _FIter \fBupper_bound\fP (_FIter, _FIter, const _Tp &, _Compare)"
.br
.ti -1c
.RI "template<typename _FIter , typename _Tp > _FIter \fBupper_bound\fP (_FIter, _FIter, const _Tp &)"
.br
.ti -1c
.RI "\fBios_base\fP & \fBuppercase\fP (\fBios_base\fP &__base)"
.br
.ti -1c
.RI "template<typename _Facet > const _Facet & \fBuse_facet\fP (const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "wchar_t * \fBwcschr\fP (wchar_t *__p, wchar_t __c)"
.br
.ti -1c
.RI "wchar_t * \fBwcspbrk\fP (wchar_t *__s1, const wchar_t *__s2)"
.br
.ti -1c
.RI "wchar_t * \fBwcsrchr\fP (wchar_t *__p, wchar_t __c)"
.br
.ti -1c
.RI "wchar_t * \fBwcsstr\fP (wchar_t *__s1, const wchar_t *__s2)"
.br
.ti -1c
.RI "wchar_t * \fBwmemchr\fP (wchar_t *__p, wchar_t __c, size_t __n)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBws\fP (\fBbasic_istream\fP< _CharT, _Traits > &__is)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator!=\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator!=\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > \fBreverse_iterator\fP< _Iterator > \fBoperator+\fP (typename \fBreverse_iterator\fP< _Iterator >::difference_type __n, const \fBreverse_iterator\fP< _Iterator > &__x)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > auto \fBoperator-\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)-> decltype(__y.base()-__x.base())"
.br
.ti -1c
.RI "template<typename _Iterator > \fBreverse_iterator\fP< _Iterator >::difference_type \fBoperator-\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator<\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator<\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator<=\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator<=\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator==\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator==\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator>\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator>\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR > bool \fBoperator>=\fP (const \fBreverse_iterator\fP< _IteratorL > &__x, const \fBreverse_iterator\fP< _IteratorR > &__y)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fBoperator>=\fP (const \fBreverse_iterator\fP< _Iterator > &__x, const \fBreverse_iterator\fP< _Iterator > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > bool \fBoperator!=\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator!=\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator!=\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<size_t _Nb> \fBbitset\fP< _Nb > \fBoperator&\fP (const \fBbitset\fP< _Nb > &__x, const \fBbitset\fP< _Nb > &__y)"
.br
.ti -1c
.RI "template<size_t _Nb> \fBbitset\fP< _Nb > \fBoperator^\fP (const \fBbitset\fP< _Nb > &__x, const \fBbitset\fP< _Nb > &__y)"
.br
.ti -1c
.RI "template<size_t _Nb> \fBbitset\fP< _Nb > \fBoperator|\fP (const \fBbitset\fP< _Nb > &__x, const \fBbitset\fP< _Nb > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator*\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator*\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator*\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator+\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator+\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator+\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator-\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator-\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator-\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator/\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator/\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > \fBcomplex\fP< _Tp > \fBoperator/\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, const unsigned char *__s)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, const signed char *__s)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, const char *__s)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, const char *__s)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, const _CharT *__s)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, unsigned char __c)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, signed char __c)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_ostream\fP< char, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< char, _Traits > &__out, char __c)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, char __c)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBbasic_ostream\fP< _CharT, _Traits > &__out, _CharT __c)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class _CharT , class _Traits , size_t _Nb> \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const \fBbitset\fP< _Nb > &__x)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , size_t _Nb> \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, \fBbitset\fP< _Nb > &__x)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Tp > bool \fBoperator==\fP (const _Tp &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator==\fP (const \fBcomplex\fP< _Tp > &__x, const _Tp &__y)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fBoperator==\fP (const \fBcomplex\fP< _Tp > &__x, const \fBcomplex\fP< _Tp > &__y)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class _Traits > \fBbasic_istream\fP< char, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< char, _Traits > &__in, signed char *__s)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_istream\fP< char, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< char, _Traits > &__in, unsigned char *__s)"
.br
.ti -1c
.RI "template<> \fBbasic_istream\fP< char > & \fBoperator>>\fP (\fBbasic_istream\fP< char > &__in, char *__s)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__in, _CharT *__s)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<class _Traits > \fBbasic_istream\fP< char, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< char, _Traits > &__in, signed char &__c)"
.br
.ti -1c
.RI "template<class _Traits > \fBbasic_istream\fP< char, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< char, _Traits > &__in, unsigned char &__c)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT, _Traits > &__in, _CharT &__c)"
.br
.in -1c
.in -1c
.PP
.RI "\fBMatching, Searching, and Replacing\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _Ch_traits , typename _Str_allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_match\fP (const \fBbasic_string\fP< _Ch_type, _Ch_traits, _Str_allocator > &__s, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_type , class _Rx_traits > bool \fBregex_match\fP (const _Ch_type *__s, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __f=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_traits , typename _Ch_alloc , typename _Allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_match\fP (const \fBbasic_string\fP< _Ch_type, _Ch_traits, _Ch_alloc > &__s, \fBmatch_results\fP< typename \fBbasic_string\fP< _Ch_type, _Ch_traits, _Ch_alloc >::const_iterator, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_type , typename _Allocator , typename _Rx_traits > bool \fBregex_match\fP (const _Ch_type *__s, \fBmatch_results\fP< const _Ch_type *, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __f=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_type , typename _Rx_traits > bool \fBregex_match\fP (_Bi_iter __first, _Bi_iter __last, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_match\fP (_Bi_iter __first, _Bi_iter __last, \fBmatch_results\fP< _Bi_iter, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Rx_traits , typename _Ch_type > \fBbasic_string\fP< _Ch_type > \fBregex_replace\fP (const \fBbasic_string\fP< _Ch_type > &__s, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, const \fBbasic_string\fP< _Ch_type > &__fmt, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Out_iter , typename _Bi_iter , typename _Rx_traits , typename _Ch_type > _Out_iter \fBregex_replace\fP (_Out_iter __out, _Bi_iter __first, _Bi_iter __last, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, const \fBbasic_string\fP< _Ch_type > &__fmt, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_traits , typename _Ch_alloc , typename _Allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_search\fP (const \fBbasic_string\fP< _Ch_type, _Ch_traits, _Ch_alloc > &__s, \fBmatch_results\fP< typename \fBbasic_string\fP< _Ch_type, _Ch_traits, _Ch_alloc >::const_iterator, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, \fBregex_constants::match_flag_type\fP __f=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_traits , typename _String_allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_search\fP (const \fBbasic_string\fP< _Ch_type, _Ch_traits, _String_allocator > &__s, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_type , typename _Rx_traits > bool \fBregex_search\fP (const _Ch_type *__s, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, \fBregex_constants::match_flag_type\fP __f=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Ch_type , class _Allocator , class _Rx_traits > bool \fBregex_search\fP (const _Ch_type *__s, \fBmatch_results\fP< const _Ch_type *, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__e, \fBregex_constants::match_flag_type\fP __f=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Ch_type , typename _Rx_traits > bool \fBregex_search\fP (_Bi_iter __first, _Bi_iter __last, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.ti -1c
.RI "template<typename _Bi_iter , typename _Allocator , typename _Ch_type , typename _Rx_traits > bool \fBregex_search\fP (_Bi_iter __first, _Bi_iter __last, \fBmatch_results\fP< _Bi_iter, _Allocator > &__m, const \fBbasic_regex\fP< _Ch_type, _Rx_traits > &__re, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::match_default\fP)"
.br
.in -1c
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static ios_base::Init \fB__ioinit\fP"
.br
.ti -1c
.RI "function< void()> \fB__once_functor\fP"
.br
.ti -1c
.RI "struct \fBstd::auto_ptr_ref\fP \fB_GLIBCXX_DEPRECATED_ATTR\fP"
.br
.ti -1c
.RI "const \fBadopt_lock_t\fP \fBadopt_lock\fP"
.br
.ti -1c
.RI "const \fBdefer_lock_t\fP \fBdefer_lock\fP"
.br
.ti -1c
.RI "const nothrow_t \fBnothrow\fP"
.br
.ti -1c
.RI "const \fBtry_to_lock_t\fP \fBtry_to_lock\fP"
.br
.in -1c
.PP
.RI "\fBStandard Stream Objects\fP"
.br
The <iostream> header declares the eight \fIstandard stream objects\fP. For other declarations, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch24.html and the \fBI/O forward declarations \fP
.PP
They are required by default to cooperate with the global C library's \fCFILE\fP streams, and to be available during program startup and termination. For more information, see the HOWTO linked to above. 
.PP
.in +1c
.in +1c
.ti -1c
.RI "\fBostream\fP \fBcerr\fP"
.br
.ti -1c
.RI "\fBistream\fP \fBcin\fP"
.br
.ti -1c
.RI "\fBostream\fP \fBclog\fP"
.br
.ti -1c
.RI "\fBostream\fP \fBcout\fP"
.br
.ti -1c
.RI "\fBwostream\fP \fBwcerr\fP"
.br
.ti -1c
.RI "\fBwistream\fP \fBwcin\fP"
.br
.ti -1c
.RI "\fBwostream\fP \fBwclog\fP"
.br
.ti -1c
.RI "\fBwostream\fP \fBwcout\fP"
.br
.in -1c
.in -1c
.SH "Detailed Description"
.PP 
ISO C++ entities toplevel namespace is \fBstd\fP. 
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* \fBstd::new_handler\fP)()"
.PP
If you write your own error handler to be called by \fCnew\fP, it must be of this type. 
.PP
Definition at line 73 of file new.
.SS "typedef long long \fBstd::streamoff\fP"
.PP
Type used by \fBfpos\fP, \fBchar_traits<char>\fP, and \fBchar_traits<wchar_t>\fP. 
.PP
In clauses 21.1.3.1 and 27.4.1 streamoff is described as an implementation defined type. Note: In versions of GCC up to and including GCC 3.3, streamoff was typedef long. 
.PP
Definition at line 94 of file postypes.h.
.SS "typedef \fBfpos\fP<mbstate_t> \fBstd::streampos\fP"
.PP
File position for char streams. 
.PP
Definition at line 228 of file postypes.h.
.SS "typedef ptrdiff_t \fBstd::streamsize\fP"
.PP
Integral type for I/O operation counts and buffer sizes. 
.PP
Definition at line 98 of file postypes.h.
.SS "typedef \fBfpos\fP<mbstate_t> \fBstd::u16streampos\fP"
.PP
File position for char16_t streams. 
.PP
Definition at line 234 of file postypes.h.
.SS "typedef \fBfpos\fP<mbstate_t> \fBstd::u32streampos\fP"
.PP
File position for char32_t streams. 
.PP
Definition at line 236 of file postypes.h.
.SS "typedef \fBfpos\fP<mbstate_t> \fBstd::wstreampos\fP"
.PP
File position for wchar_t streams. 
.PP
Definition at line 230 of file postypes.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. This controls some aspect of the sort routines. 
.RE
.PP

.PP
Definition at line 2168 of file stl_algo.h.
.SS "enum \fBstd::float_denorm_style\fP"
.PP
Describes the denormalization for floating-point types. 
.PP
These values represent the presence or absence of a variable number of exponent bits. This type is used in the \fBstd::numeric_limits\fP class. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIdenorm_indeterminate \fP\fP
Indeterminate at compile time whether denormalized values are allowed. 
.TP
\fB\fIdenorm_absent \fP\fP
The type does not allow denormalized values. 
.TP
\fB\fIdenorm_present \fP\fP
The type allows denormalized values. 
.PP
Definition at line 168 of file limits.
.SS "enum \fBstd::float_round_style\fP"
.PP
Describes the rounding style for floating-point types. 
.PP
This is used in the \fBstd::numeric_limits\fP class. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIround_indeterminate \fP\fP
Self-explanatory. 
.TP
\fB\fIround_toward_zero \fP\fP
Self-explanatory. 
.TP
\fB\fIround_to_nearest \fP\fP
To the nearest representable value. 
.TP
\fB\fIround_toward_infinity \fP\fP
Self-explanatory. 
.TP
\fB\fIround_toward_neg_infinity \fP\fP
Self-explanatory. 
.PP
Definition at line 153 of file limits.
.SH "Function Documentation"
.PP 
.SS "size_t std::__deque_buf_size (size_t __size)\fC [inline]\fP"
.PP
This function controls the size of memory nodes. 
.PP
\fBParameters:\fP
.RS 4
\fIsize\fP The size of an element. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number (not byte size) of elements per node.
.RE
.PP
This function started off as a compiler kludge from SGI, but seems to be a useful wrapper around a repeated constant expression. The '512' is tunable (and no other code needs to change), but no investigation has been done since inheriting the SGI code. 
.PP
Definition at line 78 of file stl_deque.h.
.PP
Referenced by std::_Deque_base< _Tp, _Alloc >::_M_initialize_map().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::__final_insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2188 of file stl_algo.h.
.PP
References __insertion_sort(), and __unguarded_insertion_sort().
.SS "template<typename _RandomAccessIterator > void std::__final_insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2173 of file stl_algo.h.
.PP
References __insertion_sort(), and __unguarded_insertion_sort().
.PP
Referenced by sort().
.SS "template<typename _RandomAccessIterator , typename _Tp > _RandomAccessIterator std::__find (_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp & __val, random_access_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find() for the RAI case. 
.PP
Definition at line 166 of file stl_algo.h.
.SS "template<typename _InputIterator , typename _Tp > _InputIterator std::__find (_InputIterator __first, _InputIterator __last, const _Tp & __val, input_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find() for the Input Iterator case. 
.PP
Definition at line 144 of file stl_algo.h.
.PP
Referenced by find().
.SS "template<typename _RandomAccessIterator , typename _Predicate > _RandomAccessIterator std::__find_if (_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, random_access_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find_if() for the RAI case. 
.PP
Definition at line 214 of file stl_algo.h.
.PP
References __find_if().
.SS "template<typename _InputIterator , typename _Predicate > _InputIterator std::__find_if (_InputIterator __first, _InputIterator __last, _Predicate __pred, input_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find_if() for the Input Iterator case. 
.PP
Definition at line 155 of file stl_algo.h.
.PP
References __find_if().
.PP
Referenced by __find_if(), and find_if().
.SS "template<typename _RandomAccessIterator , typename _Predicate > _RandomAccessIterator std::__find_if_not (_RandomAccessIterator __first, _RandomAccessIterator __last, _Predicate __pred, random_access_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find_if_not() for the RAI case. 
.PP
Definition at line 274 of file stl_algo.h.
.SS "template<typename _InputIterator , typename _Predicate > _InputIterator std::__find_if_not (_InputIterator __first, _InputIterator __last, _Predicate __pred, input_iterator_tag)\fC [inline]\fP"
.PP
This is an overload used by find_if_not() for the Input Iterator case. 
.PP
Definition at line 263 of file stl_algo.h.
.PP
Referenced by find_if_not().
.SS "template<typename _EuclideanRingElement > _EuclideanRingElement std::__gcd (_EuclideanRingElement __m, _EuclideanRingElement __n)\fC [inline]\fP"
.PP
This is a helper function for the rotate algorithm specialized on RAIs. It returns the greatest common divisor of two integer values. 
.PP
Definition at line 1503 of file stl_algo.h.
.PP
Referenced by __rotate().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::__heap_select (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routines. 
.PP
Definition at line 1913 of file stl_algo.h.
.PP
References make_heap().
.SS "template<typename _RandomAccessIterator > void std::__heap_select (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is a helper function for the sort routines. 
.PP
Definition at line 1900 of file stl_algo.h.
.PP
References make_heap().
.PP
Referenced by partial_sort().
.SS "template<typename _ForwardIterator , typename _Predicate , typename _Distance > _ForwardIterator std::__inplace_stable_partition (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 1777 of file stl_algo.h.
.PP
References advance(), distance(), and rotate().
.PP
Referenced by stable_partition().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::__inplace_stable_sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the stable sorting routines. 
.PP
Definition at line 3428 of file stl_algo.h.
.PP
References __inplace_stable_sort(), __insertion_sort(), and __merge_without_buffer().
.SS "template<typename _RandomAccessIterator > void std::__inplace_stable_sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is a helper function for the stable sorting routines. 
.PP
Definition at line 3409 of file stl_algo.h.
.PP
References __insertion_sort(), and __merge_without_buffer().
.PP
Referenced by __inplace_stable_sort(), and stable_sort().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::__insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2119 of file stl_algo.h.
.PP
References __unguarded_linear_insert(), and copy_backward().
.SS "template<typename _RandomAccessIterator > void std::__insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2096 of file stl_algo.h.
.PP
References __unguarded_linear_insert(), and copy_backward().
.PP
Referenced by __final_insertion_sort(), and __inplace_stable_sort().
.SS "template<typename _RandomAccessIterator , typename _Size , typename _Compare > void std::__introsort_loop (_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2277 of file stl_algo.h.
.PP
References __introsort_loop(), __median(), and __unguarded_partition().
.SS "template<typename _RandomAccessIterator , typename _Size > void std::__introsort_loop (_RandomAccessIterator __first, _RandomAccessIterator __last, _Size __depth_limit)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2245 of file stl_algo.h.
.PP
References __median(), and __unguarded_partition().
.PP
Referenced by __introsort_loop(), and sort().
.SS "template<typename _Functor , typename... _Args> __gnu_cxx::__enable_if< (is_member_pointer< _Functor >::value &&!\fBis_function\fP< _Functor >::value &&!\fBis_function\fP< typename \fBremove_pointer\fP< _Functor >::type >::value), typename result_of< _Functor(_Args...)>::type >::__type std::__invoke (_Functor & __f, _Args &... __args)\fC [inline]\fP"
.PP
Invoke a function object, which may be either a member pointer or a function object. The first parameter will tell which. 
.PP
Definition at line 265 of file tr1_impl/functional.
.SS "template<typename _Size > _Size std::__lg (_Size __n)\fC [inline]\fP"
.PP
This is a helper function for the sort routines. Precondition: __n > 0. 
.PP
Definition at line 2310 of file stl_algo.h.
.PP
References __lg().
.PP
Referenced by __lg(), std::tr1::__detail::__log_gamma_bernoulli(), nth_element(), and sort().
.SS "template<typename _BidirectionalIterator , typename _Distance , typename _Pointer , typename _Compare > void std::__merge_adaptive (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 2966 of file stl_algo.h.
.PP
References __merge_adaptive(), __merge_backward(), __rotate_adaptive(), advance(), distance(), lower_bound(), and upper_bound().
.SS "template<typename _BidirectionalIterator , typename _Distance , typename _Pointer > void std::__merge_adaptive (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Pointer __buffer, _Distance __buffer_size)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 2910 of file stl_algo.h.
.PP
References __merge_backward(), __rotate_adaptive(), advance(), distance(), lower_bound(), and upper_bound().
.PP
Referenced by __merge_adaptive(), and inplace_merge().
.SS "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _BidirectionalIterator3 , typename _Compare > _BidirectionalIterator3 std::__merge_backward (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 2842 of file stl_algo.h.
.PP
References copy_backward().
.SS "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _BidirectionalIterator3 > _BidirectionalIterator3 std::__merge_backward (_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1, _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BidirectionalIterator3 __result)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 2807 of file stl_algo.h.
.PP
References copy_backward().
.PP
Referenced by __merge_adaptive().
.SS "template<typename _BidirectionalIterator , typename _Distance , typename _Compare > void std::__merge_without_buffer (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 3067 of file stl_algo.h.
.PP
References __merge_without_buffer(), advance(), distance(), iter_swap(), lower_bound(), rotate(), and upper_bound().
.SS "template<typename _BidirectionalIterator , typename _Distance > void std::__merge_without_buffer (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Distance __len1, _Distance __len2)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 3023 of file stl_algo.h.
.PP
References advance(), distance(), iter_swap(), lower_bound(), rotate(), and upper_bound().
.PP
Referenced by __inplace_stable_sort(), __merge_without_buffer(), and inplace_merge().
.SS "template<typename _BidirectionalIterator , typename _Predicate > _BidirectionalIterator std::__partition (_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred, bidirectional_iterator_tag)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 1747 of file stl_algo.h.
.PP
References iter_swap().
.SS "template<typename _ForwardIterator , typename _Predicate > _ForwardIterator std::__partition (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 1722 of file stl_algo.h.
.PP
References iter_swap().
.PP
Referenced by partition().
.SS "template<typename _RandomAccessIterator > void std::__reverse (_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified reverse(_BidirectionalIterator, _BidirectionalIterator) overloaded for random access iterators. 
.PP
Definition at line 1423 of file stl_algo.h.
.PP
References iter_swap().
.SS "template<typename _BidirectionalIterator > void std::__reverse (_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified reverse(_BidirectionalIterator, _BidirectionalIterator) overloaded for bidirectional iterators. 
.PP
Definition at line 1403 of file stl_algo.h.
.PP
References iter_swap().
.PP
Referenced by __rotate(), and reverse().
.SS "template<typename _RandomAccessIterator > void std::__rotate (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, random_access_iterator_tag)\fC [inline]\fP"
.PP
This is a helper function for the rotate algorithm. 
.PP
Definition at line 1583 of file stl_algo.h.
.PP
References __gcd(), and swap_ranges().
.PP
Referenced by __gnu_cxx::bitmap_allocator< _Tp >::_M_deallocate_single_object().
.SS "template<typename _BidirectionalIterator > void std::__rotate (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, bidirectional_iterator_tag)\fC [inline]\fP"
.PP
This is a helper function for the rotate algorithm. 
.PP
Definition at line 1553 of file stl_algo.h.
.PP
References __reverse(), and iter_swap().
.SS "template<typename _ForwardIterator > void std::__rotate (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, forward_iterator_tag)\fC [inline]\fP"
.PP
This is a helper function for the rotate algorithm. 
.PP
Definition at line 1517 of file stl_algo.h.
.PP
References iter_swap().
.PP
Referenced by rotate().
.SS "template<typename _BidirectionalIterator1 , typename _BidirectionalIterator2 , typename _Distance > _BidirectionalIterator1 std::__rotate_adaptive (_BidirectionalIterator1 __first, _BidirectionalIterator1 __middle, _BidirectionalIterator1 __last, _Distance __len1, _Distance __len2, _BidirectionalIterator2 __buffer, _Distance __buffer_size)\fC [inline]\fP"
.PP
This is a helper function for the merge routines. 
.PP
Definition at line 2878 of file stl_algo.h.
.PP
References advance(), copy_backward(), distance(), and rotate().
.PP
Referenced by __merge_adaptive().
.SS "template<typename _RandomAccessIter , typename _Integer , typename _Tp , typename _BinaryPredicate > _RandomAccessIter std::__search_n (_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp & __val, _BinaryPredicate __binary_pred, \fBstd::random_access_iterator_tag\fP)\fC [inline]\fP"
.PP
This is an uglified search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&, _BinaryPredicate) overloaded for random access iterators. 
.PP
Definition at line 465 of file stl_algo.h.
.SS "template<typename _ForwardIterator , typename _Integer , typename _Tp , typename _BinaryPredicate > _ForwardIterator std::__search_n (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val, _BinaryPredicate __binary_pred, \fBstd::forward_iterator_tag\fP)\fC [inline]\fP"
.PP
This is an uglified search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&, _BinaryPredicate) overloaded for forward iterators. 
.PP
Definition at line 426 of file stl_algo.h.
.SS "template<typename _RandomAccessIter , typename _Integer , typename _Tp > _RandomAccessIter std::__search_n (_RandomAccessIter __first, _RandomAccessIter __last, _Integer __count, const _Tp & __val, \fBstd::random_access_iterator_tag\fP)\fC [inline]\fP"
.PP
This is an uglified \fBsearch_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)\fP overloaded for random access iterators. 
.PP
Definition at line 372 of file stl_algo.h.
.SS "template<typename _ForwardIterator , typename _Integer , typename _Tp > _ForwardIterator std::__search_n (_ForwardIterator __first, _ForwardIterator __last, _Integer __count, const _Tp & __val, \fBstd::forward_iterator_tag\fP)\fC [inline]\fP"
.PP
This is an uglified \fBsearch_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)\fP overloaded for forward iterators. 
.PP
Definition at line 340 of file stl_algo.h.
.PP
Referenced by search_n().
.SS "template<typename _ForwardIterator , typename _Pointer , typename _Predicate , typename _Distance > _ForwardIterator std::__stable_partition_adaptive (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, _Distance __len, _Pointer __buffer, _Distance __buffer_size)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 1802 of file stl_algo.h.
.PP
References advance(), distance(), and rotate().
.PP
Referenced by stable_partition().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::__unguarded_insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2154 of file stl_algo.h.
.PP
References __unguarded_linear_insert().
.SS "template<typename _RandomAccessIterator > void std::__unguarded_insertion_sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2141 of file stl_algo.h.
.PP
References __unguarded_linear_insert().
.PP
Referenced by __final_insertion_sort().
.SS "template<typename _RandomAccessIterator , typename _Tp , typename _Compare > void std::__unguarded_linear_insert (_RandomAccessIterator __last, _Tp __val, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2079 of file stl_algo.h.
.SS "template<typename _RandomAccessIterator , typename _Tp > void std::__unguarded_linear_insert (_RandomAccessIterator __last, _Tp __val)\fC [inline]\fP"
.PP
This is a helper function for the sort routine. 
.PP
Definition at line 2063 of file stl_algo.h.
.PP
Referenced by __insertion_sort(), and __unguarded_insertion_sort().
.SS "template<typename _RandomAccessIterator , typename _Tp , typename _Compare > _RandomAccessIterator std::__unguarded_partition (_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot, _Compare __comp)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 2224 of file stl_algo.h.
.PP
References iter_swap().
.SS "template<typename _RandomAccessIterator , typename _Tp > _RandomAccessIterator std::__unguarded_partition (_RandomAccessIterator __first, _RandomAccessIterator __last, _Tp __pivot)\fC [inline]\fP"
.PP
This is a helper function... 
.PP
Definition at line 2204 of file stl_algo.h.
.PP
References iter_swap().
.PP
Referenced by __introsort_loop().
.SS "template<typename _InputIterator , typename _ForwardIterator , typename _BinaryPredicate > _ForwardIterator std::__unique_copy (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __binary_pred, input_iterator_tag, forward_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator, _BinaryPredicate) overloaded for input iterators and forward \fBiterator\fP as result. 
.PP
Definition at line 1380 of file stl_algo.h.
.SS "template<typename _InputIterator , typename _OutputIterator , typename _BinaryPredicate > _OutputIterator std::__unique_copy (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, input_iterator_tag, output_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator, _BinaryPredicate) overloaded for input iterators and output \fBiterator\fP as result. 
.PP
Definition at line 1351 of file stl_algo.h.
.SS "template<typename _ForwardIterator , typename _OutputIterator , typename _BinaryPredicate > _OutputIterator std::__unique_copy (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred, forward_iterator_tag, output_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator, _BinaryPredicate) overloaded for forward iterators and output \fBiterator\fP as result. 
.PP
Definition at line 1322 of file stl_algo.h.
.SS "template<typename _InputIterator , typename _ForwardIterator > _ForwardIterator std::__unique_copy (_InputIterator __first, _InputIterator __last, _ForwardIterator __result, input_iterator_tag, forward_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator) overloaded for input iterators and forward \fBiterator\fP as result. 
.PP
Definition at line 1301 of file stl_algo.h.
.SS "template<typename _InputIterator , typename _OutputIterator > _OutputIterator std::__unique_copy (_InputIterator __first, _InputIterator __last, _OutputIterator __result, input_iterator_tag, output_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator) overloaded for input iterators and output \fBiterator\fP as result. 
.PP
Definition at line 1278 of file stl_algo.h.
.SS "template<typename _ForwardIterator , typename _OutputIterator > _OutputIterator std::__unique_copy (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, forward_iterator_tag, output_iterator_tag)\fC [inline]\fP"
.PP
This is an uglified unique_copy(_InputIterator, _InputIterator, _OutputIterator) overloaded for forward iterators and output \fBiterator\fP as result. 
.PP
Definition at line 1255 of file stl_algo.h.
.PP
Referenced by unique_copy().
.SS "template<typename _T1 , typename _T2 > void std::_Construct (_T1 * __p, const _T2 & __value)\fC [inline]\fP"
.PP
Constructs an object in existing memory by invoking an allocated object's constructor with an initializer. 
.PP
Definition at line 70 of file stl_construct.h.
.SS "template<typename _ForwardIterator > void std::_Destroy (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Destroy a range of objects. If the value_type of the object has a trivial destructor, the compiler should optimize all of this away, otherwise the objects' destructors must be invoked. 
.PP
Definition at line 92 of file stl_construct.h.
.PP
References _Destroy().
.SS "template<typename _Tp > void std::_Destroy (_Tp * __pointer)\fC [inline]\fP"
.PP
Destroy the object pointed to by a pointer type. 
.PP
Definition at line 82 of file stl_construct.h.
.PP
References _Destroy().
.PP
Referenced by _Destroy(), std::deque< _Tp, _Alloc >::_M_fill_initialize(), std::deque< _Tp, _Alloc >::_M_range_initialize(), std::vector< _Tp, _Alloc >::operator=(), std::vector< _Tp, _Alloc >::reserve(), and std::vector< _Node *, _Nodeptr_Alloc >::~vector().
.SS "template<typename _InputIterator , typename _Tp , typename _BinaryOperation > _Tp std::accumulate (_InputIterator __first, _InputIterator __last, _Tp __init, _BinaryOperation __binary_op)\fC [inline]\fP"
.PP
Accumulate values in a range with operation. 
.PP
Accumulates the values in the range [first,last) using the function object \fIbinary_op\fP. The initial value is \fIinit\fP. The values are processed in order.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIinit\fP Starting value to add other values to. 
.br
\fIbinary_op\fP Function object to accumulate with. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final sum. 
.RE
.PP

.PP
Definition at line 141 of file stl_numeric.h.
.SS "template<typename _InputIterator , typename _Tp > _Tp std::accumulate (_InputIterator __first, _InputIterator __last, _Tp __init)\fC [inline]\fP"
.PP
Accumulate values in a range. 
.PP
Accumulates the values in the range [first,last) using \fBoperator+()\fP. The initial value is \fIinit\fP. The values are processed in order.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIinit\fP Starting value to add other values to. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final sum. 
.RE
.PP

.PP
Definition at line 115 of file stl_numeric.h.
.PP
Referenced by __gnu_parallel::parallel_partial_sum_linear().
.SS "template<typename _InputIterator , typename _OutputIterator , typename _BinaryOperation > _OutputIterator std::adjacent_difference (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)\fC [inline]\fP"
.PP
Return differences between adjacent values. 
.PP
Computes the difference between adjacent values in the range [first,last) using the function object \fIbinary_op\fP and writes the result to \fIresult\fP.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of input range. 
.br
\fIlast\fP End of input range. 
.br
\fIresult\fP Output to write sums to. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing just beyond the values written to result. 
.RE
.PP

.PP
Definition at line 347 of file stl_numeric.h.
.SS "template<typename _InputIterator , typename _OutputIterator > _OutputIterator std::adjacent_difference (_InputIterator __first, _InputIterator __last, _OutputIterator __result)\fC [inline]\fP"
.PP
Return differences between adjacent values. 
.PP
Computes the difference between adjacent values in the range [first,last) using \fBoperator-()\fP and writes the result to \fIresult\fP.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of input range. 
.br
\fIlast\fP End of input range. 
.br
\fIresult\fP Output to write sums to. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing just beyond the values written to result. 
.RE
.PP

.PP
Definition at line 308 of file stl_numeric.h.
.SS "template<typename _InputIterator , typename _Distance > void std::advance (_InputIterator & __i, _Distance __n)\fC [inline]\fP"
.PP
A generalization of pointer arithmetic. 
.PP
\fBParameters:\fP
.RS 4
\fIi\fP An input \fBiterator\fP. 
.br
\fIn\fP The 'delta' by which to change \fCi\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
This increments \fCi\fP by \fCn\fP. For bidirectional and random access iterators, \fCn\fP may be negative, in which case \fCi\fP is decremented.
.PP
For random access iterators, this uses their \fC+\fP and \fC-\fP operations and are constant time. For other iterator classes they are linear time. 
.PP
Definition at line 168 of file stl_iterator_base_funcs.h.
.PP
References __iterator_category().
.PP
Referenced by __inplace_stable_partition(), __merge_adaptive(), __merge_without_buffer(), __rotate_adaptive(), __stable_partition_adaptive(), std::deque< _Tp, _Alloc >::_M_range_initialize(), equal_range(), lower_bound(), partition_point(), and upper_bound().
.SS "template<typename _Container > \fBback_insert_iterator\fP<_Container> std::back_inserter (_Container & __x)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A container of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
An instance of \fBback_insert_iterator\fP working on \fCx\fP.
.RE
.PP
This wrapper function helps in creating \fBback_insert_iterator\fP instances. Typing the name of the iterator requires knowing the precise full type of the container, which can be tedious and impedes generic programming. Using this function lets you take advantage of automatic template parameter deduction, making the compiler match the correct types for you. 
.PP
Definition at line 459 of file stl_iterator.h.
.PP
Referenced by regex_replace().
.SS "template<typename _Functor , typename... _ArgTypes> _Bind_result< _Result, typename \fB_Maybe_wrap_member_pointer\fP< _Functor >::type(_ArgTypes...)> std::bind (_Functor __f, _ArgTypes... __args)\fC [inline]\fP"
.PP
bind 
.PP
Definition at line 1343 of file tr1_impl/functional.
.PP
Referenced by call_once().
.SS "\fBios_base\fP& std::boolalpha (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::boolalpha). 
.PP
Definition at line 799 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by noboolalpha().
.SS "\fBios_base\fP& std::dec (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::dec, ios_base::basefield). 
.PP
Definition at line 937 of file ios_base.h.
.PP
References std::ios_base::setf().
.SS "template<typename _InputIterator > \fBiterator_traits\fP<_InputIterator>::difference_type std::distance (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
A generalization of pointer arithmetic. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
The distance between them.
.RE
.PP
Returns \fCn\fP such that first + n == last. This requires that \fClast\fP must be reachable from \fCfirst\fP. Note that \fCn\fP may be negative.
.PP
For random access iterators, this uses their \fC+\fP and \fC-\fP operations and are constant time. For other iterator classes they are linear time. 
.PP
Definition at line 110 of file stl_iterator_base_funcs.h.
.PP
References __iterator_category().
.PP
Referenced by __inplace_stable_partition(), __merge_adaptive(), __merge_without_buffer(), __rotate_adaptive(), __stable_partition_adaptive(), std::deque< _Tp, _Alloc >::_M_range_initialize(), equal_range(), inplace_merge(), is_heap_until(), std::sub_match< _Bi_iter >::length(), lower_bound(), __gnu_parallel::multiseq_partition(), __gnu_parallel::multiseq_selection(), partition_point(), std::match_results< _Bi_iter >::position(), __gnu_cxx::random_sample_n(), std::list< _Tp, _Alloc >::size(), and upper_bound().
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::endl (basic_ostream< _CharT, _Traits > & __os)\fC [inline]\fP"
.PP
Write a newline and flush the stream. 
.PP
This manipulator is often mistakenly used when a simple newline is desired, leading to poor buffering performance. See http://gcc.gnu.org/onlinedocs/libstdc++/27_io/howto.html#2 for more on this subject. 
.PP
Definition at line 538 of file ostream.
.PP
References flush(), std::basic_ostream< _CharT, _Traits >::put(), and std::basic_ios< _CharT, _Traits >::widen().
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::ends (basic_ostream< _CharT, _Traits > & __os)\fC [inline]\fP"
.PP
Write a null character into the output sequence. 
.PP
'Null character' is \fCCharT()\fP by definition. For CharT of \fCchar\fP, this correctly writes the ASCII \fCNUL\fP character string terminator. 
.PP
Definition at line 549 of file ostream.
.PP
References std::basic_ostream< _CharT, _Traits >::put().
.SS "\fBios_base\fP& std::fixed (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::fixed, ios_base::floatfield). 
.PP
Definition at line 962 of file ios_base.h.
.PP
References std::ios_base::setf().
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::flush (basic_ostream< _CharT, _Traits > & __os)\fC [inline]\fP"
.PP
Flushes the output stream. 
.PP
This manipulator simply calls the stream's \fC\fBflush()\fP\fP member function. 
.PP
Definition at line 559 of file ostream.
.PP
References std::basic_ostream< _CharT, _Traits >::flush().
.PP
Referenced by endl().
.SS "template<typename _Container > \fBfront_insert_iterator\fP<_Container> std::front_inserter (_Container & __x)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A container of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
An instance of \fBfront_insert_iterator\fP working on \fCx\fP.
.RE
.PP
This wrapper function helps in creating \fBfront_insert_iterator\fP instances. Typing the name of the iterator requires knowing the precise full type of the container, which can be tedious and impedes generic programming. Using this function lets you take advantage of automatic template parameter deduction, making the compiler match the correct types for you. 
.PP
Definition at line 542 of file stl_iterator.h.
.SS "template<typename _Tp > \fBpair\fP<_Tp*, ptrdiff_t> std::get_temporary_buffer (ptrdiff_t __len)\fC [inline]\fP"
.PP
Allocates a temporary buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIlen\fP The number of objects of type Tp. 
.RE
.PP
\fBReturns:\fP
.RS 4
See full description.
.RE
.PP
Reinventing the wheel, but this time with prettier spokes!
.PP
This function tries to obtain storage for \fClen\fP adjacent Tp objects. The objects themselves are not constructed, of course. A pair<> is returned containing 'the buffer s address and capacity (in the units of sizeof(Tp)), or a \fBpair\fP of 0 values if no storage can be obtained.' Note that the capacity obtained may be \fBless\fP than that requested if the memory is unavailable; you should compare len with the .second return value.
.PP
Provides the nothrow \fBexception\fP guarantee. 
.PP
Definition at line 85 of file stl_tempbuf.h.
.PP
Referenced by std::_Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer().
.SS "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP<_CharT, _Traits>& std::getline (basic_istream< _CharT, _Traits > & __is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > & __str)\fC [inline]\fP"
.PP
Read a line from stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fI__is\fP Input stream. 
.br
\fI__str\fP Buffer to store into. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from is into \fI__str\fP until '
.br
' is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fI__str\fP. Any previous contents of \fI__str\fP are erased. If end of line was encountered, it is extracted but not stored into \fI__str\fP. 
.PP
Definition at line 2435 of file vstring.h.
.PP
References std::basic_ios< _CharT, _Traits >::widen().
.PP
Referenced by getline().
.SS "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP< _CharT, _Traits > & std::getline (basic_istream< _CharT, _Traits > & __is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > & __str, _CharT __delim)\fC [inline]\fP"
.PP
Read a line from stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fI__is\fP Input stream. 
.br
\fI__str\fP Buffer to store into. 
.br
\fI__delim\fP Character marking end of line. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from \fI__is\fP into \fI__str\fP until \fI__delim\fP is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fI__str\fP. Any previous contents of \fI__str\fP are erased. If \fIdelim\fP was encountered, it is extracted but not stored into \fI__str\fP. 
.PP
Definition at line 622 of file vstring.tcc.
.PP
References std::basic_ios< _CharT, _Traits >::_M_setstate(), __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::append(), __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::erase(), __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::max_size(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_streambuf< _CharT, _Traits >::sbumpc(), std::basic_ios< _CharT, _Traits >::setstate(), std::basic_streambuf< _CharT, _Traits >::sgetc(), and std::basic_streambuf< _CharT, _Traits >::snextc().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP<_CharT, _Traits>& std::getline (basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str)\fC [inline]\fP"
.PP
Read a line from stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fIis\fP Input stream. 
.br
\fIstr\fP Buffer to store into. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from is into \fIstr\fP until '
.br
' is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fIstr\fP. Any previous contents of \fIstr\fP are erased. If end of line was encountered, it is extracted but not stored into \fIstr\fP. 
.PP
Definition at line 2541 of file basic_string.h.
.PP
References getline(), and std::basic_ios< _CharT, _Traits >::widen().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP< _CharT, _Traits > & std::getline (basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str, _CharT __delim)\fC [inline]\fP"
.PP
Read a line from stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fIis\fP Input stream. 
.br
\fIstr\fP Buffer to store into. 
.br
\fIdelim\fP Character marking end of line. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from \fIis\fP into \fIstr\fP until \fIdelim\fP is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fIstr\fP. Any previous contents of \fIstr\fP are erased. If \fIdelim\fP was encountered, it is extracted but not stored into \fIstr\fP. 
.PP
Definition at line 1046 of file basic_string.tcc.
.PP
References std::basic_ios< _CharT, _Traits >::_M_setstate(), std::basic_string< _CharT, _Traits, _Alloc >::erase(), std::basic_string< _CharT, _Traits, _Alloc >::max_size(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_streambuf< _CharT, _Traits >::sbumpc(), std::basic_ios< _CharT, _Traits >::setstate(), std::basic_streambuf< _CharT, _Traits >::sgetc(), and std::basic_streambuf< _CharT, _Traits >::snextc().
.SS "template<typename _Facet > bool std::has_facet (const locale & __loc)  throw ()\fC [inline]\fP"
.PP
Test for the presence of a facet. 
.PP
has_facet tests the \fBlocale\fP argument for the presence of the facet type provided as the template parameter. Facets derived from the facet parameter will also return true.
.PP
\fBParameters:\fP
.RS 4
\fIFacet\fP The facet type to test the presence of. 
.br
\fI\fBlocale\fP\fP The \fBlocale\fP to test. 
.RE
.PP
\fBReturns:\fP
.RS 4
true if \fBlocale\fP contains a facet of type Facet, else false. 
.RE
.PP

.PP
Definition at line 91 of file locale_classes.tcc.
.SS "\fBios_base\fP& std::hex (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::hex, ios_base::basefield). 
.PP
Definition at line 945 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by std::basic_ostream< _CharT, _Traits >::operator<<(), and std::regex_traits< _Ch_type >::value().
.SS "template<typename _InputIterator1 , typename _InputIterator2 , typename _Tp , typename _BinaryOperation1 , typename _BinaryOperation2 > _Tp std::inner_product (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init, _BinaryOperation1 __binary_op1, _BinaryOperation2 __binary_op2)\fC [inline]\fP"
.PP
Compute inner product of two ranges. 
.PP
Starting with an initial value of \fIinit\fP, applies \fIbinary_op2\fP to successive elements from the two ranges and accumulates each result into the accumulated value using \fIbinary_op1\fP. The values in the ranges are processed in order.
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP Start of range 1. 
.br
\fIlast1\fP End of range 1. 
.br
\fIfirst2\fP Start of range 2. 
.br
\fIinit\fP Starting value to add other values to. 
.br
\fIbinary_op1\fP Function object to accumulate with. 
.br
\fIbinary_op2\fP Function object to apply to pairs of input values. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final inner product. 
.RE
.PP

.PP
Definition at line 201 of file stl_numeric.h.
.SS "template<typename _InputIterator1 , typename _InputIterator2 , typename _Tp > _Tp std::inner_product (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _Tp __init)\fC [inline]\fP"
.PP
Compute inner product of two ranges. 
.PP
Starting with an initial value of \fIinit\fP, \fBmultiplies\fP successive elements from the two ranges and adds each product into the accumulated value using \fBoperator+()\fP. The values in the ranges are processed in order.
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP Start of range 1. 
.br
\fIlast1\fP End of range 1. 
.br
\fIfirst2\fP Start of range 2. 
.br
\fIinit\fP Starting value to add other values to. 
.RE
.PP
\fBReturns:\fP
.RS 4
The final inner product. 
.RE
.PP

.PP
Definition at line 169 of file stl_numeric.h.
.SS "template<typename _Container , typename _Iterator > \fBinsert_iterator\fP<_Container> std::inserter (_Container & __x, _Iterator __i)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A container of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
An instance of \fBinsert_iterator\fP working on \fCx\fP.
.RE
.PP
This wrapper function helps in creating \fBinsert_iterator\fP instances. Typing the name of the iterator requires knowing the precise full type of the container, which can be tedious and impedes generic programming. Using this function lets you take advantage of automatic template parameter deduction, making the compiler match the correct types for you. 
.PP
Definition at line 648 of file stl_iterator.h.
.SS "\fBios_base\fP& std::internal (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::internal, ios_base::adjustfield). 
.PP
Definition at line 912 of file ios_base.h.
.PP
References std::ios_base::setf().
.SS "template<typename _ForwardIterator , typename _Tp > void std::iota (_ForwardIterator __first, _ForwardIterator __last, _Tp __value)\fC [inline]\fP"
.PP
Create a range of sequentially increasing values. 
.PP
For each element in the range \fC\fP[first,last) assigns \fCvalue\fP and increments \fCvalue\fP as if by \fC++value\fP.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIvalue\fP Starting value. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP

.PP
Definition at line 80 of file stl_numeric.h.
.SS "template<typename _CharT > bool std::isalnum (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::alnum, __c). 
.PP
Definition at line 2575 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isalpha (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::alpha, __c). 
.PP
Definition at line 2551 of file locale_facets.h.
.SS "template<typename _CharT > bool std::iscntrl (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::cntrl, __c). 
.PP
Definition at line 2533 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isdigit (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::digit, __c). 
.PP
Definition at line 2557 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isgraph (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::graph, __c). 
.PP
Definition at line 2581 of file locale_facets.h.
.SS "template<typename _CharT > bool std::islower (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::lower, __c). 
.PP
Definition at line 2545 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isprint (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::print, __c). 
.PP
Definition at line 2527 of file locale_facets.h.
.SS "template<typename _CharT > bool std::ispunct (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::punct, __c). 
.PP
Definition at line 2563 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isspace (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::space, __c). 
.PP
Definition at line 2521 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isupper (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::upper, __c). 
.PP
Definition at line 2539 of file locale_facets.h.
.SS "template<typename _CharT > bool std::isxdigit (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.is(ctype_base::xdigit, __c). 
.PP
Definition at line 2569 of file locale_facets.h.
.SS "\fBios_base\fP& std::left (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::left, ios_base::adjustfield). 
.PP
Definition at line 920 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by __gnu_parallel::LoserTree< false, T, Comparator >::init_winner(), operator<<(), and __gnu_parallel::parallel_partition().
.SS "template<typename _Tp , typename _Class > _Mem_fn<_Tp _Class::*> std::mem_fn (_Tp _Class::* __pm)\fC [inline]\fP"
.PP
Returns a function object that forwards to the member pointer \fIpm\fP. 
.PP
Definition at line 794 of file tr1_impl/functional.
.SS "\fBios_base\fP& std::noboolalpha (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::boolalpha). 
.PP
Definition at line 807 of file ios_base.h.
.PP
References boolalpha(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::noshowbase (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::showbase). 
.PP
Definition at line 823 of file ios_base.h.
.PP
References showbase(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::noshowpoint (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::showpoint). 
.PP
Definition at line 839 of file ios_base.h.
.PP
References showpoint(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::noshowpos (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::showpos). 
.PP
Definition at line 855 of file ios_base.h.
.PP
References showpos(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::noskipws (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::skipws). 
.PP
Definition at line 871 of file ios_base.h.
.PP
References skipws(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::nounitbuf (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::unitbuf). 
.PP
Definition at line 903 of file ios_base.h.
.PP
References unitbuf(), and std::ios_base::unsetf().
.SS "\fBios_base\fP& std::nouppercase (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.unsetf(ios_base::uppercase). 
.PP
Definition at line 887 of file ios_base.h.
.PP
References std::ios_base::unsetf(), and uppercase().
.SS "\fBios_base\fP& std::oct (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::oct, ios_base::basefield). 
.PP
Definition at line 953 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by std::basic_ostream< _CharT, _Traits >::operator<<(), and std::regex_traits< _Ch_type >::value().
.SS "template<class _Tp , class _CharT , class _Traits , class _Dist > bool std::operator!= (const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __x, const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __y)\fC [inline]\fP"
.PP
Return false if x and y are both end or not end, or x and y are the same. 
.PP
Definition at line 130 of file stream_iterator.h.
.PP
References std::istream_iterator< _Tp, _CharT, _Traits, _Dist >::_M_equal().
.SS "template<typename _Tp , typename _Alloc > bool std::operator!= (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 1192 of file stl_vector.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator!= (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 259 of file stl_stack.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator!= (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(x == y). 
.PP
Definition at line 663 of file stl_set.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator!= (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 294 of file stl_queue.h.
.SS "template<class _T1 , class _T2 > bool std::operator!= (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
Uses \fCoperator==\fP to find the result. 
.PP
Definition at line 159 of file stl_pair.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator!= (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(x == y). 
.PP
Definition at line 649 of file stl_multiset.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator!= (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 752 of file stl_multimap.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator!= (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 823 of file stl_map.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator!= (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 1492 of file stl_list.h.
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator!= (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 340 of file stl_iterator.h.
.SS "template<typename _Iterator > bool std::operator!= (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 290 of file stl_iterator.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator!= (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 1774 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator!= (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Based on operator==. 
.PP
Definition at line 1256 of file forward_list.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator!= (const _Fwd_list_iterator< _Tp, _Alloc > & __x, const _Fwd_list_const_iterator< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Forward \fBlist\fP \fBiterator\fP inequality comparison. 
.PP
Definition at line 254 of file forward_list.h.
.PP
References std::_Fwd_list_const_iterator< _Tp, _Alloc >::_M_node, and std::_Fwd_list_iterator< _Tp, _Alloc >::_M_node.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator!= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test difference of string and C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs.compare\fP(\fIrhs\fP) != 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2305 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator!= (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test difference of C string and string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIrhs.compare\fP(\fIlhs\fP) != 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2293 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator!= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test difference of two strings. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs.compare\fP(\fIrhs\fP) != 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2281 of file basic_string.h.
.SS "template<typename _Signature > bool std::operator!= (_M_clear_type *, const function< _Signature > & __f)\fC [inline]\fP"
.PP
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 
.PP
Definition at line 2114 of file tr1_impl/functional.
.SS "template<typename _Signature > bool std::operator!= (const function< _Signature > & __f, _M_clear_type *)\fC [inline]\fP"
.PP
Compares a polymorphic function object wrapper against 0 (the NULL pointer). 
.PP
\fBReturns:\fP
.RS 4
\fCfalse\fP if the wrapper has no target, \fCtrue\fP otherwise
.RE
.PP
This function will not throw an \fBexception\fP. 
.PP
Definition at line 2108 of file tr1_impl/functional.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> std::operator& (const bitset< _Nb > & __x, const bitset< _Nb > & __y)\fC [inline]\fP"
.PP
Global bitwise operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A \fBbitset\fP. 
.br
\fIy\fP A \fBbitset\fP of the same size as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 1269 of file bitset.
.PP
References operator&().
.PP
Referenced by operator&().
.SS "template<typename _Iterator > \fBreverse_iterator\fP<_Iterator> std::operator+ (typename reverse_iterator< _Iterator >::difference_type __n, const reverse_iterator< _Iterator > & __x)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 320 of file stl_iterator.h.
.PP
References std::reverse_iterator< _Iterator >::base().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP<_CharT, _Traits, _Alloc> std::operator+ (const basic_string< _CharT, _Traits, _Alloc > & __lhs, _CharT __rhs)\fC [inline]\fP"
.PP
Concatenate string and character. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Last string. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with \fIlhs\fP followed by \fIrhs\fP. 
.RE
.PP

.PP
Definition at line 2217 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP<_CharT, _Traits, _Alloc> std::operator+ (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Concatenate string and C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Last string. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with \fIlhs\fP followed by \fIrhs\fP. 
.RE
.PP

.PP
Definition at line 2201 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::append().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > std::operator+ (_CharT __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Concatenate character and string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Last string. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with \fIlhs\fP followed by \fIrhs\fP. 
.RE
.PP

.PP
Definition at line 686 of file basic_string.tcc.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP< _CharT, _Traits, _Alloc > std::operator+ (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Concatenate C string and string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Last string. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with value of \fIlhs\fP followed by \fIrhs\fP. 
.RE
.PP

.PP
Definition at line 670 of file basic_string.tcc.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_string\fP<_CharT, _Traits, _Alloc> std::operator+ (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Concatenate two strings. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Last string. 
.RE
.PP
\fBReturns:\fP
.RS 4
New string with value of \fIlhs\fP followed by \fIrhs\fP. 
.RE
.PP

.PP
Definition at line 2164 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::append().
.SS "template<typename _IteratorL , typename _IteratorR > auto std::operator- (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 366 of file stl_iterator.h.
.PP
References std::reverse_iterator< _Iterator >::base(), and operator-().
.SS "template<typename _Iterator > \fBreverse_iterator\fP<_Iterator>::difference_type std::operator- (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 314 of file stl_iterator.h.
.PP
References std::reverse_iterator< _Iterator >::base(), and operator-().
.SS "template<typename _Tp , typename _Alloc > bool std::operator< (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Vector ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector. 
.br
\fIy\fP A vector of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the vectors. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 1185 of file stl_vector.h.
.PP
References lexicographical_compare().
.SS "template<typename _Tp , typename _Seq > bool std::operator< (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Stack ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A stack. 
.br
\fIy\fP A stack of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is an total ordering relation. Complexity and semantics depend on the underlying sequence type, but the expected rules are: this relation is linear in the size of the sequences, the elements must be comparable with \fC<\fP, and std::lexicographical_compare() is usually used to make the determination. 
.PP
Definition at line 253 of file stl_stack.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator< (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Set ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A set. 
.br
\fIy\fP A set of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the maps. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 656 of file stl_set.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator< (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Queue ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A queue. 
.br
\fIy\fP A queue of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is an total ordering relation. Complexity and semantics depend on the underlying sequence type, but the expected rules are: this relation is linear in the size of the sequences, the elements must be comparable with \fC<\fP, and std::lexicographical_compare() is usually used to make the determination. 
.PP
Definition at line 288 of file stl_queue.h.
.SS "template<class _T1 , class _T2 > bool std::operator< (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
<http://gcc.gnu.org/onlinedocs/libstdc++/manual/utilities.html> 
.PP
Definition at line 152 of file stl_pair.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator< (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Multiset ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A multiset. 
.br
\fIy\fP A multiset of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the maps. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 642 of file stl_multiset.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator< (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Multimap ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A multimap. 
.br
\fIy\fP A multimap of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the multimaps. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 745 of file stl_multimap.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator< (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Map ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A map. 
.br
\fIy\fP A map of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the maps. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 816 of file stl_map.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator< (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
List ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list. 
.br
\fIy\fP A list of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the lists. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 1485 of file stl_list.h.
.PP
References lexicographical_compare().
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator< (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 334 of file stl_iterator.h.
.SS "template<typename _Iterator > bool std::operator< (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 284 of file stl_iterator.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator< (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Deque ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque. 
.br
\fIy\fP A deque of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIx\fP is lexicographically \fBless\fP than \fIy\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the deques. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 1766 of file stl_deque.h.
.PP
References lexicographical_compare().
.SS "template<typename _Tp , typename _Alloc > bool std::operator< (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Forward \fBlist\fP ordering relation. 
.PP
\fBParameters:\fP
.RS 4
\fIlx\fP A forward_list. 
.br
\fIly\fP A forward_list of the same type as \fIlx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff \fIlx\fP is lexicographically \fBless\fP than \fIly\fP.
.RE
.PP
This is a total ordering relation. It is linear in the size of the forward lists. The elements must be comparable with \fC<\fP.
.PP
See std::lexicographical_compare() for how the determination is made. 
.PP
Definition at line 1248 of file forward_list.h.
.PP
References lexicographical_compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator< (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if C string precedes string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP precedes \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2342 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator< (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test if string precedes C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP precedes \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2330 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator< (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if string precedes string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP precedes \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2318 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_ostream\fP<_CharT, _Traits>& std::operator<< (basic_ostream< _CharT, _Traits > & __os, const \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > & __str)\fC [inline]\fP"
.PP
Write string to a stream. 
.PP
\fBParameters:\fP
.RS 4
\fI__os\fP Output stream. 
.br
\fI__str\fP String to write out. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the output stream.
.RE
.PP
Output characters of \fI__str\fP into os following the same rules as for writing a C string. 
.PP
Definition at line 2389 of file vstring.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_ostream\fP<_CharT, _Traits>& std::operator<< (basic_ostream< _CharT, _Traits > & __os, const basic_string< _CharT, _Traits, _Alloc > & __str)\fC [inline]\fP"
.PP
Write string to a stream. 
.PP
\fBParameters:\fP
.RS 4
\fIos\fP Output stream. 
.br
\fIstr\fP String to write out. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the output stream.
.RE
.PP
Output characters of \fIstr\fP into os following the same rules as for writing a C string. 
.PP
Definition at line 2501 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits > \fBstd::basic_ostream\fP<_CharT, _Traits>& std::operator<< (\fBstd::basic_ostream\fP< _CharT, _Traits > & __os, const bernoulli_distribution & __x)\fC [inline]\fP"
.PP
Inserts a bernoulli_distribution random number distribution \fC__x\fP into the output stream \fC__os\fP.
.PP
\fBParameters:\fP
.RS 4
\fI__os\fP An output stream. 
.br
\fI__x\fP A bernoulli_distribution random number distribution.
.RE
.PP
\fBReturns:\fP
.RS 4
The output stream with the state of \fC__x\fP inserted or in an error state. 
.RE
.PP

.PP
Definition at line 823 of file random.tcc.
.PP
References std::ios_base::flags(), left(), and scientific().
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, const unsigned char * __s)\fC [inline]\fP"
.PP
String inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIs\fP A character string. 
.RE
.PP
\fBReturns:\fP
.RS 4
out 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fIs\fP must be a non-NULL pointer
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts \fCtraits::length(s)\fP characters starting at \fIs\fP, widened if necessary, followed by any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called. 
.PP
Definition at line 523 of file ostream.
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, const signed char * __s)\fC [inline]\fP"
.PP
String inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIs\fP A character string. 
.RE
.PP
\fBReturns:\fP
.RS 4
out 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fIs\fP must be a non-NULL pointer
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts \fCtraits::length(s)\fP characters starting at \fIs\fP, widened if necessary, followed by any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called. 
.PP
Definition at line 518 of file ostream.
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, const char * __s)\fC [inline]\fP"
.PP
String inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIs\fP A character string. 
.RE
.PP
\fBReturns:\fP
.RS 4
out 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fIs\fP must be a non-NULL pointer
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts \fCtraits::length(s)\fP characters starting at \fIs\fP, widened if necessary, followed by any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called. 
.PP
Definition at line 505 of file ostream.
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP< _CharT, _Traits > & std::operator<< (basic_ostream< _CharT, _Traits > & __out, const char * __s)\fC [inline]\fP"
.PP
String inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIs\fP A character string. 
.RE
.PP
\fBReturns:\fP
.RS 4
out 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fIs\fP must be a non-NULL pointer
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts \fCtraits::length(s)\fP characters starting at \fIs\fP, widened if necessary, followed by any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called. 
.PP
Definition at line 321 of file ostream.tcc.
.PP
References std::ios_base::badbit.
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::operator<< (basic_ostream< _CharT, _Traits > & __out, const _CharT * __s)\fC [inline]\fP"
.PP
String inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIs\fP A character string. 
.RE
.PP
\fBReturns:\fP
.RS 4
out 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fIs\fP must be a non-NULL pointer
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts \fCtraits::length(s)\fP characters starting at \fIs\fP, widened if necessary, followed by any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called. 
.PP
Definition at line 488 of file ostream.
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, unsigned char __c)\fC [inline]\fP"
.PP
Character inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIc\fP A character. 
.RE
.PP
\fBReturns:\fP
.RS 4
out
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts a single character and any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called.
.PP
If \fIc\fP is of type \fCchar\fP and the character type of the stream is not \fCchar\fP, the character is widened before insertion. 
.PP
Definition at line 468 of file ostream.
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, signed char __c)\fC [inline]\fP"
.PP
Character inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIc\fP A character. 
.RE
.PP
\fBReturns:\fP
.RS 4
out
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts a single character and any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called.
.PP
If \fIc\fP is of type \fCchar\fP and the character type of the stream is not \fCchar\fP, the character is widened before insertion. 
.PP
Definition at line 463 of file ostream.
.SS "template<class _Traits > \fBbasic_ostream\fP<char, _Traits>& std::operator<< (basic_ostream< char, _Traits > & __out, char __c)\fC [inline]\fP"
.PP
Character inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIc\fP A character. 
.RE
.PP
\fBReturns:\fP
.RS 4
out
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts a single character and any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called.
.PP
If \fIc\fP is of type \fCchar\fP and the character type of the stream is not \fCchar\fP, the character is widened before insertion. 
.PP
Definition at line 457 of file ostream.
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::operator<< (basic_ostream< _CharT, _Traits > & __out, char __c)\fC [inline]\fP"
.PP
Character inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIc\fP A character. 
.RE
.PP
\fBReturns:\fP
.RS 4
out
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts a single character and any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called.
.PP
If \fIc\fP is of type \fCchar\fP and the character type of the stream is not \fCchar\fP, the character is widened before insertion. 
.PP
Definition at line 451 of file ostream.
.SS "template<typename _CharT , typename _Traits > \fBbasic_ostream\fP<_CharT, _Traits>& std::operator<< (basic_ostream< _CharT, _Traits > & __out, _CharT __c)\fC [inline]\fP"
.PP
Character inserters. 
.PP
\fBParameters:\fP
.RS 4
\fIout\fP An output stream. 
.br
\fIc\fP A character. 
.RE
.PP
\fBReturns:\fP
.RS 4
out
.RE
.PP
Behaves like one of the formatted arithmetic inserters described in \fBstd::basic_ostream\fP. After constructing a sentry object with good status, this function inserts a single character and any required padding (as determined by [22.2.2.2.2]). \fCout.width(0)\fP is then called.
.PP
If \fIc\fP is of type \fCchar\fP and the character type of the stream is not \fCchar\fP, the character is widened before insertion. 
.PP
Definition at line 446 of file ostream.
.SS "template<class _CharT , class _Traits , size_t _Nb> \fBstd::basic_ostream\fP<_CharT, _Traits>& std::operator<< (\fBstd::basic_ostream\fP< _CharT, _Traits > & __os, const bitset< _Nb > & __x)\fC [inline]\fP"
.PP
Global I/O operators for bitsets. 
.PP
Direct I/O between streams and bitsets is supported. Output is straightforward. Input will skip whitespace, only accept '0' and '1' characters, and will only extract as many digits as the bitset will hold. 
.PP
Definition at line 1374 of file bitset.
.PP
References std::__ctype_abstract_base< _CharT >::widen().
.SS "template<typename _Tp , typename _Alloc > bool std::operator<= (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1204 of file stl_vector.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator<= (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 271 of file stl_stack.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator<= (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(y < x). 
.PP
Definition at line 677 of file stl_set.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator<= (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 306 of file stl_queue.h.
.SS "template<class _T1 , class _T2 > bool std::operator<= (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
Uses \fCoperator<\fP to find the result. 
.PP
Definition at line 171 of file stl_pair.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator<= (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(y < x). 
.PP
Definition at line 663 of file stl_multiset.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator<= (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 766 of file stl_multimap.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator<= (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 837 of file stl_map.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator<= (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1504 of file stl_list.h.
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator<= (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 352 of file stl_iterator.h.
.SS "template<typename _Iterator > bool std::operator<= (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 302 of file stl_iterator.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator<= (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1788 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator<= (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1277 of file forward_list.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator<= (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if C string doesn't follow string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't follow \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2416 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator<= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test if string doesn't follow C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't follow \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2404 of file basic_string.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator<= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if string doesn't follow string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't follow \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2392 of file basic_string.h.
.SS "template<typename _Tp , typename _CharT , typename _Traits , typename _Dist > bool std::operator== (const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __x, const istream_iterator< _Tp, _CharT, _Traits, _Dist > & __y)\fC [inline]\fP"
.PP
Return true if x and y are both end or not end, or x and y are the same. 
.PP
Definition at line 123 of file stream_iterator.h.
.PP
References std::istream_iterator< _Tp, _CharT, _Traits, _Dist >::_M_equal().
.SS "template<typename _Tp , typename _Alloc > bool std::operator== (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Vector equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector. 
.br
\fIy\fP A vector of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the vectors are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the vectors. Vectors are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 1168 of file stl_vector.h.
.PP
References std::vector< _Tp, _Alloc >::begin(), std::vector< _Tp, _Alloc >::end(), equal(), and std::vector< _Tp, _Alloc >::size().
.SS "template<typename _Tp , typename _Seq > bool std::operator== (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Stack equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A stack. 
.br
\fIy\fP A stack of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the stacks are equal.
.RE
.PP
This is an equivalence relation. Complexity and semantics depend on the underlying sequence type, but the expected rules are: this relation is linear in the size of the sequences, and stacks are considered equivalent if their sequences compare equal. 
.PP
Definition at line 235 of file stl_stack.h.
.PP
References std::stack< _Tp, _Sequence >::c.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator== (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Set equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A set. 
.br
\fIy\fP A set of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the sets are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the sets. Sets are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 639 of file stl_set.h.
.PP
References std::set< _Key, _Compare, _Alloc >::_M_t.
.SS "template<typename _Tp , typename _Seq > bool std::operator== (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Queue equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A queue. 
.br
\fIy\fP A queue of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the queues are equal.
.RE
.PP
This is an equivalence relation. Complexity and semantics depend on the underlying sequence type, but the expected rules are: this relation is linear in the size of the sequences, and queues are considered equivalent if their sequences compare equal. 
.PP
Definition at line 270 of file stl_queue.h.
.PP
References std::queue< _Tp, _Sequence >::c.
.SS "template<class _T1 , class _T2 > bool std::operator== (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
Two pairs of the same type are equal iff their members are equal. 
.PP
Definition at line 146 of file stl_pair.h.
.PP
References std::pair< _T1, _T2 >::first, and std::pair< _T1, _T2 >::second.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator== (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Multiset equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A multiset. 
.br
\fIy\fP A multiset of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the multisets are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the multisets. Multisets are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 625 of file stl_multiset.h.
.PP
References std::multiset< _Key, _Compare, _Alloc >::_M_t.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator== (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Multimap equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A multimap. 
.br
\fIy\fP A multimap of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the maps are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the multimaps. Multimaps are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 728 of file stl_multimap.h.
.PP
References std::multimap< _Key, _Tp, _Compare, _Alloc >::_M_t.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator== (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Map equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A map. 
.br
\fIy\fP A map of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the maps are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the maps. Maps are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 799 of file stl_map.h.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::_M_t.
.SS "template<typename _Tp , typename _Alloc > bool std::operator== (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
List equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list. 
.br
\fIy\fP A list of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the lists are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the lists. Lists are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 1456 of file stl_list.h.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator== (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 328 of file stl_iterator.h.
.PP
References std::reverse_iterator< _Iterator >::base().
.SS "template<typename _Iterator > bool std::operator== (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 278 of file stl_iterator.h.
.PP
References std::reverse_iterator< _Iterator >::base().
.SS "template<typename _Tp , typename _Alloc > bool std::operator== (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Deque equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque. 
.br
\fIy\fP A deque of the same type as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the deques are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the deques. Deques are considered equivalent if their sizes are equal, and if corresponding elements compare equal. 
.PP
Definition at line 1748 of file stl_deque.h.
.PP
References std::deque< _Tp, _Alloc >::begin(), std::deque< _Tp, _Alloc >::end(), equal(), and std::deque< _Tp, _Alloc >::size().
.SS "template<typename _StateT > bool std::operator== (const fpos< _StateT > & __lhs, const fpos< _StateT > & __rhs)\fC [inline]\fP"
.PP
Test if equivalent to another position. 
.PP
Definition at line 216 of file postypes.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator== (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Forward \fBlist\fP equality comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIlx\fP A forward_list 
.br
\fIly\fP A forward_list of the same type as \fIlx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True iff the size and elements of the forward lists are equal.
.RE
.PP
This is an equivalence relation. It is linear in the size of the forward lists. Deques are considered equivalent if corresponding elements compare equal. 
.PP
Definition at line 455 of file forward_list.tcc.
.PP
References std::forward_list< _Tp, _Alloc >::cbegin(), and std::forward_list< _Tp, _Alloc >::cend().
.SS "template<typename _Tp , typename _Alloc > bool std::operator== (const _Fwd_list_iterator< _Tp, _Alloc > & __x, const _Fwd_list_const_iterator< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Forward \fBlist\fP \fBiterator\fP equality comparison. 
.PP
Definition at line 245 of file forward_list.h.
.PP
References std::_Fwd_list_const_iterator< _Tp, _Alloc >::_M_node, and std::_Fwd_list_iterator< _Tp, _Alloc >::_M_node.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator== (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test equivalence of string and C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs.compare\fP(\fIrhs\fP) == 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2268 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator== (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test equivalence of C string and string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIrhs.compare\fP(\fIlhs\fP) == 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2256 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator== (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test equivalence of two strings. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs.compare\fP(\fIrhs\fP) == 0. False otherwise. 
.RE
.PP

.PP
Definition at line 2235 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _Signature > bool std::operator== (_M_clear_type *, const function< _Signature > & __f)\fC [inline]\fP"
.PP
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. 
.PP
Definition at line 2096 of file tr1_impl/functional.
.SS "template<typename _Signature > bool std::operator== (const function< _Signature > & __f, _M_clear_type *)\fC [inline]\fP"
.PP
Compares a polymorphic function object wrapper against 0 (the NULL pointer). 
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if the wrapper has no target, \fCfalse\fP otherwise
.RE
.PP
This function will not throw an \fBexception\fP. 
.PP
Definition at line 2090 of file tr1_impl/functional.
.SS "template<typename _Tp , typename _Alloc > bool std::operator> (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1198 of file stl_vector.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator> (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 265 of file stl_stack.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator> (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns y < x. 
.PP
Definition at line 670 of file stl_set.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator> (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 300 of file stl_queue.h.
.SS "template<class _T1 , class _T2 > bool std::operator> (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
Uses \fCoperator<\fP to find the result. 
.PP
Definition at line 165 of file stl_pair.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator> (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns y < x. 
.PP
Definition at line 656 of file stl_multiset.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator> (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 759 of file stl_multimap.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator> (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 830 of file stl_map.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator> (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1498 of file stl_list.h.
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator> (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 346 of file stl_iterator.h.
.SS "template<typename _Iterator > bool std::operator> (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 296 of file stl_iterator.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator> (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1781 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator> (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1263 of file forward_list.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator> (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if C string follows string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP follows \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2379 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator> (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test if string follows C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP follows \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2367 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator> (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if string follows string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP follows \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2355 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _Tp , typename _Alloc > bool std::operator>= (const vector< _Tp, _Alloc > & __x, const vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1210 of file stl_vector.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator>= (const stack< _Tp, _Seq > & __x, const stack< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 277 of file stl_stack.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator>= (const set< _Key, _Compare, _Alloc > & __x, const set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(x < y). 
.PP
Definition at line 684 of file stl_set.h.
.SS "template<typename _Tp , typename _Seq > bool std::operator>= (const queue< _Tp, _Seq > & __x, const queue< _Tp, _Seq > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 312 of file stl_queue.h.
.SS "template<class _T1 , class _T2 > bool std::operator>= (const pair< _T1, _T2 > & __x, const pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
Uses \fCoperator<\fP to find the result. 
.PP
Definition at line 177 of file stl_pair.h.
.SS "template<typename _Key , typename _Compare , typename _Alloc > bool std::operator>= (const multiset< _Key, _Compare, _Alloc > & __x, const multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Returns !(x < y). 
.PP
Definition at line 670 of file stl_multiset.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator>= (const multimap< _Key, _Tp, _Compare, _Alloc > & __x, const multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 773 of file stl_multimap.h.
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > bool std::operator>= (const map< _Key, _Tp, _Compare, _Alloc > & __x, const map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 844 of file stl_map.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator>= (const list< _Tp, _Alloc > & __x, const list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1510 of file stl_list.h.
.SS "template<typename _IteratorL , typename _IteratorR > bool std::operator>= (const reverse_iterator< _IteratorL > & __x, const reverse_iterator< _IteratorR > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 358 of file stl_iterator.h.
.SS "template<typename _Iterator > bool std::operator>= (const reverse_iterator< _Iterator > & __x, const reverse_iterator< _Iterator > & __y)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A reverse_iterator. 
.br
\fIy\fP A reverse_iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A simple bool.
.RE
.PP
Reverse iterators forward many operations to their underlying base() iterators. Others are implemented in terms of one another. 
.PP
Definition at line 308 of file stl_iterator.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator>= (const deque< _Tp, _Alloc > & __x, const deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1795 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > bool std::operator>= (const forward_list< _Tp, _Alloc > & __lx, const forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
Based on operator<. 
.PP
Definition at line 1270 of file forward_list.h.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator>= (const _CharT * __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if C string doesn't precede string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP C string. 
.br
\fIrhs\fP String. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't precede \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2453 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator>= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const _CharT * __rhs)\fC [inline]\fP"
.PP
Test if string doesn't precede C string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP String. 
.br
\fIrhs\fP C string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't precede \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2441 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > bool std::operator>= (const basic_string< _CharT, _Traits, _Alloc > & __lhs, const basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Test if string doesn't precede string. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIlhs\fP doesn't precede \fIrhs\fP. False otherwise. 
.RE
.PP

.PP
Definition at line 2429 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::compare().
.SS "template<typename _CharT , typename _Traits , typename _Alloc , template< typename, typename, typename > class _Base> \fBbasic_istream\fP< _CharT, _Traits > & std::operator>> (basic_istream< _CharT, _Traits > & __is, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, _Base > & __str)\fC [inline]\fP"
.PP
Read stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fI__is\fP Input stream. 
.br
\fI__str\fP Buffer to store into. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from \fI__is\fP into \fI__str\fP until whitespace is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fI__str\fP. Any previous contents of \fI__str\fP are erased. 
.PP
Definition at line 547 of file vstring.tcc.
.SS "template<typename _CharT , typename _Traits , typename _Alloc > \fBbasic_istream\fP< _CharT, _Traits > & std::operator>> (basic_istream< _CharT, _Traits > & __is, basic_string< _CharT, _Traits, _Alloc > & __str)\fC [inline]\fP"
.PP
Read stream into a string. 
.PP
\fBParameters:\fP
.RS 4
\fIis\fP Input stream. 
.br
\fIstr\fP Buffer to store into. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to the input stream.
.RE
.PP
Stores characters from \fIis\fP into \fIstr\fP until whitespace is found, the end of the stream is encountered, or str.max_size() is reached. If is.width() is non-zero, that is the limit on the number of characters stored into \fIstr\fP. Any previous contents of \fIstr\fP are erased. 
.PP
Definition at line 974 of file basic_string.tcc.
.PP
References std::basic_ios< _CharT, _Traits >::_M_setstate(), std::basic_string< _CharT, _Traits, _Alloc >::append(), std::basic_string< _CharT, _Traits, _Alloc >::erase(), std::ios_base::getloc(), std::basic_string< _CharT, _Traits, _Alloc >::max_size(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_ios< _CharT, _Traits >::setstate(), std::basic_streambuf< _CharT, _Traits >::sgetc(), std::basic_streambuf< _CharT, _Traits >::snextc(), and std::ios_base::width().
.SS "template<class _Traits > \fBbasic_istream\fP<char, _Traits>& std::operator>> (basic_istream< char, _Traits > & __in, signed char * __s)\fC [inline]\fP"
.PP
Character string extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIs\fP A pointer to a character \fBarray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts up to \fCn\fP characters and stores them into the \fBarray\fP starting at \fIs\fP. \fCn\fP is defined as:
.PP
.IP "\(bu" 2
if \fCwidth()\fP is \fBgreater\fP than zero, \fCn\fP is width()
.IP "\(bu" 2
otherwise \fCn\fP is 'the number of elements of the largest \fBarray\fP of \fCchar_type\fP that can store a terminating \fCeos\fP.' [27.6.1.2.3]/6
.PP
.PP
Characters are extracted and stored until one of the following happens:
.IP "\(bu" 2
\fCn-1\fP characters are stored
.IP "\(bu" 2
EOF is reached
.IP "\(bu" 2
the next character is whitespace according to the current \fBlocale\fP
.IP "\(bu" 2
the next character is a null byte (i.e., \fCcharT()\fP )
.PP
.PP
\fCwidth(0)\fP is then called for the input stream.
.PP
If no characters are extracted, sets failbit. 
.PP
Definition at line 750 of file istream.
.SS "template<class _Traits > \fBbasic_istream\fP<char, _Traits>& std::operator>> (basic_istream< char, _Traits > & __in, unsigned char * __s)\fC [inline]\fP"
.PP
Character string extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIs\fP A pointer to a character \fBarray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts up to \fCn\fP characters and stores them into the \fBarray\fP starting at \fIs\fP. \fCn\fP is defined as:
.PP
.IP "\(bu" 2
if \fCwidth()\fP is \fBgreater\fP than zero, \fCn\fP is width()
.IP "\(bu" 2
otherwise \fCn\fP is 'the number of elements of the largest \fBarray\fP of \fCchar_type\fP that can store a terminating \fCeos\fP.' [27.6.1.2.3]/6
.PP
.PP
Characters are extracted and stored until one of the following happens:
.IP "\(bu" 2
\fCn-1\fP characters are stored
.IP "\(bu" 2
EOF is reached
.IP "\(bu" 2
the next character is whitespace according to the current \fBlocale\fP
.IP "\(bu" 2
the next character is a null byte (i.e., \fCcharT()\fP )
.PP
.PP
\fCwidth(0)\fP is then called for the input stream.
.PP
If no characters are extracted, sets failbit. 
.PP
Definition at line 745 of file istream.
.SS "template<> \fBbasic_istream\fP<char>& std::operator>> (basic_istream< char > & __in, char * __s)\fC [inline]\fP"
.PP
Character string extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIs\fP A pointer to a character \fBarray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts up to \fCn\fP characters and stores them into the \fBarray\fP starting at \fIs\fP. \fCn\fP is defined as:
.PP
.IP "\(bu" 2
if \fCwidth()\fP is \fBgreater\fP than zero, \fCn\fP is width()
.IP "\(bu" 2
otherwise \fCn\fP is 'the number of elements of the largest \fBarray\fP of \fCchar_type\fP that can store a terminating \fCeos\fP.' [27.6.1.2.3]/6
.PP
.PP
Characters are extracted and stored until one of the following happens:
.IP "\(bu" 2
\fCn-1\fP characters are stored
.IP "\(bu" 2
EOF is reached
.IP "\(bu" 2
the next character is whitespace according to the current \fBlocale\fP
.IP "\(bu" 2
the next character is a null byte (i.e., \fCcharT()\fP )
.PP
.PP
\fCwidth(0)\fP is then called for the input stream.
.PP
If no characters are extracted, sets failbit. 
.SS "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & std::operator>> (basic_istream< _CharT, _Traits > & __in, _CharT * __s)\fC [inline]\fP"
.PP
Character string extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIs\fP A pointer to a character \fBarray\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts up to \fCn\fP characters and stores them into the \fBarray\fP starting at \fIs\fP. \fCn\fP is defined as:
.PP
.IP "\(bu" 2
if \fCwidth()\fP is \fBgreater\fP than zero, \fCn\fP is width()
.IP "\(bu" 2
otherwise \fCn\fP is 'the number of elements of the largest \fBarray\fP of \fCchar_type\fP that can store a terminating \fCeos\fP.' [27.6.1.2.3]/6
.PP
.PP
Characters are extracted and stored until one of the following happens:
.IP "\(bu" 2
\fCn-1\fP characters are stored
.IP "\(bu" 2
EOF is reached
.IP "\(bu" 2
the next character is whitespace according to the current \fBlocale\fP
.IP "\(bu" 2
the next character is a null byte (i.e., \fCcharT()\fP )
.PP
.PP
\fCwidth(0)\fP is then called for the input stream.
.PP
If no characters are extracted, sets failbit. 
.PP
Definition at line 885 of file istream.tcc.
.PP
References std::basic_ios< _CharT, _Traits >::_M_setstate(), std::ios_base::getloc(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_ios< _CharT, _Traits >::setstate(), std::basic_streambuf< _CharT, _Traits >::sgetc(), and std::ios_base::width().
.SS "template<class _Traits > \fBbasic_istream\fP<char, _Traits>& std::operator>> (basic_istream< char, _Traits > & __in, signed char & __c)\fC [inline]\fP"
.PP
Character extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIc\fP A character reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts a character (if one is available) and stores it in \fIc\fP. Otherwise, sets failbit in the input stream. 
.PP
Definition at line 704 of file istream.
.SS "template<class _Traits > \fBbasic_istream\fP<char, _Traits>& std::operator>> (basic_istream< char, _Traits > & __in, unsigned char & __c)\fC [inline]\fP"
.PP
Character extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIc\fP A character reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts a character (if one is available) and stores it in \fIc\fP. Otherwise, sets failbit in the input stream. 
.PP
Definition at line 699 of file istream.
.SS "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & std::operator>> (basic_istream< _CharT, _Traits > & __in, _CharT & __c)\fC [inline]\fP"
.PP
Character extractors. 
.PP
\fBParameters:\fP
.RS 4
\fIin\fP An input stream. 
.br
\fIc\fP A character reference. 
.RE
.PP
\fBReturns:\fP
.RS 4
in
.RE
.PP
Behaves like one of the formatted arithmetic extractors described in \fBstd::basic_istream\fP. After constructing a sentry object with good status, this function extracts a character (if one is available) and stores it in \fIc\fP. Otherwise, sets failbit in the input stream. 
.PP
Definition at line 853 of file istream.tcc.
.PP
References std::basic_ios< _CharT, _Traits >::_M_setstate(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_streambuf< _CharT, _Traits >::sbumpc(), and std::basic_ios< _CharT, _Traits >::setstate().
.SS "template<class _CharT , class _Traits , size_t _Nb> \fBstd::basic_istream\fP<_CharT, _Traits>& std::operator>> (\fBstd::basic_istream\fP< _CharT, _Traits > & __is, bitset< _Nb > & __x)\fC [inline]\fP"
.PP
Global I/O operators for bitsets. 
.PP
Direct I/O between streams and bitsets is supported. Output is straightforward. Input will skip whitespace, only accept '0' and '1' characters, and will only extract as many digits as the bitset will hold. 
.PP
Definition at line 1306 of file bitset.
.PP
References std::bitset< _Nb >::_M_copy_from_string(), std::basic_ios< _CharT, _Traits >::_M_setstate(), std::basic_string< _CharT, _Traits, _Alloc >::empty(), std::basic_string< _CharT, _Traits, _Alloc >::push_back(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_string< _CharT, _Traits, _Alloc >::reserve(), std::basic_streambuf< _CharT, _Traits >::sbumpc(), std::basic_ios< _CharT, _Traits >::setstate(), std::basic_streambuf< _CharT, _Traits >::sputbackc(), and std::basic_ios< _CharT, _Traits >::widen().
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> std::operator^ (const bitset< _Nb > & __x, const bitset< _Nb > & __y)\fC [inline]\fP"
.PP
Global bitwise operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A \fBbitset\fP. 
.br
\fIy\fP A \fBbitset\fP of the same size as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 1287 of file bitset.
.PP
References operator^().
.PP
Referenced by operator^().
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> std::operator| (const bitset< _Nb > & __x, const bitset< _Nb > & __y)\fC [inline]\fP"
.PP
Global bitwise operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A \fBbitset\fP. 
.br
\fIy\fP A \fBbitset\fP of the same size as \fIx\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A new \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 1278 of file bitset.
.PP
References operator|().
.PP
Referenced by operator|().
.SS "template<typename _InputIterator , typename _OutputIterator , typename _BinaryOperation > _OutputIterator std::partial_sum (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryOperation __binary_op)\fC [inline]\fP"
.PP
Return \fBlist\fP of partial sums. 
.PP
Accumulates the values in the range [first,last) using \fBoperator+()\fP. As each successive input value is added into the total, that partial sum is written to \fIresult\fP. Therefore, the first value in result is the first value of the input, the second value in result is the sum of the first and second input values, and so on.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of input range. 
.br
\fIlast\fP End of input range. 
.br
\fIresult\fP Output to write sums to. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing just beyond the values written to result. 
.RE
.PP

.PP
Definition at line 272 of file stl_numeric.h.
.SS "template<typename _InputIterator , typename _OutputIterator > _OutputIterator std::partial_sum (_InputIterator __first, _InputIterator __last, _OutputIterator __result)\fC [inline]\fP"
.PP
Return \fBlist\fP of partial sums. 
.PP
Accumulates the values in the range [first,last) using \fBoperator+()\fP. As each successive input value is added into the total, that partial sum is written to \fIresult\fP. Therefore, the first value in result is the first value of the input, the second value in result is the sum of the first and second input values, and so on.
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of input range. 
.br
\fIlast\fP End of input range. 
.br
\fIresult\fP Output to write sums to. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator pointing just beyond the values written to result. 
.RE
.PP

.PP
Definition at line 232 of file stl_numeric.h.
.SS "template<typename _InputIterator , typename _OutputIterator , typename _Tp > _OutputIterator std::replace_copy (_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp & __old_value, const _Tp & __new_value)\fC [inline]\fP"
.PP
Copy a sequence, replacing each element of one value with another value. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIresult\fP An output \fBiterator\fP. 
.br
\fIold_value\fP The value to be replaced. 
.br
\fInew_value\fP The replacement value. 
.RE
.PP
\fBReturns:\fP
.RS 4
The end of the output sequence, \fCresult+\fP(last-first).
.RE
.PP
Copies each element in the input range \fC\fP[first,last) to the output range \fC\fP[result,result+(last-first)) replacing elements equal to \fCold_value\fP with \fCnew_value\fP. 
.PP
Definition at line 3804 of file stl_algo.h.
.SS "_Resetiosflags std::resetiosflags (ios_base::fmtflags __mask)\fC [inline]\fP"
.PP
Manipulator for \fCsetf\fP. 
.PP
\fBParameters:\fP
.RS 4
\fImask\fP A format flags mask.
.RE
.PP
Sent to a stream object, this manipulator resets the specified flags, via \fIstream.setf(0,mask)\fP. 
.PP
Definition at line 59 of file iomanip.
.SS "template<typename _Tp > void std::return_temporary_buffer (_Tp * __p)\fC [inline]\fP"
.PP
The companion to \fBget_temporary_buffer()\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP A buffer previously allocated by get_temporary_buffer. 
.RE
.PP
\fBReturns:\fP
.RS 4
None.
.RE
.PP
Frees the memory pointed to by p. 
.PP
Definition at line 112 of file stl_tempbuf.h.
.PP
Referenced by std::_Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer().
.SS "\fBios_base\fP& std::right (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::right, ios_base::adjustfield). 
.PP
Definition at line 928 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by __gnu_parallel::LoserTree< false, T, Comparator >::init_winner(), and __gnu_parallel::parallel_partition().
.SS "\fBios_base\fP& std::scientific (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::scientific, ios_base::floatfield). 
.PP
Definition at line 970 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by operator<<().
.SS "\fBnew_handler\fP std::set_new_handler (new_handler)  throw ()"
.PP
Takes a replacement handler as the argument, returns the previous handler. 
.PP
.SS "_Setbase std::setbase (int __base)\fC [inline]\fP"
.PP
Manipulator for \fCsetf\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIbase\fP A numeric base.
.RE
.PP
Sent to a stream object, this manipulator changes the \fC\fBios_base::basefield\fP\fP flags to \fCoct\fP, \fCdec\fP, or \fChex\fP when \fIbase\fP is 8, 10, or 16, accordingly, and to 0 if \fIbase\fP is any other value. 
.PP
Definition at line 128 of file iomanip.
.SS "template<typename _CharT > _Setfill<_CharT> std::setfill (_CharT __c)\fC [inline]\fP"
.PP
Manipulator for \fCfill\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The new fill character.
.RE
.PP
Sent to a stream object, this manipulator calls \fCfill(c)\fP for that object. 
.PP
Definition at line 170 of file iomanip.
.SS "_Setiosflags std::setiosflags (ios_base::fmtflags __mask)\fC [inline]\fP"
.PP
Manipulator for \fCsetf\fP. 
.PP
\fBParameters:\fP
.RS 4
\fImask\fP A format flags mask.
.RE
.PP
Sent to a stream object, this manipulator sets the format flags to \fImask\fP. 
.PP
Definition at line 93 of file iomanip.
.SS "_Setprecision std::setprecision (int __n)\fC [inline]\fP"
.PP
Manipulator for \fCprecision\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The new precision.
.RE
.PP
Sent to a stream object, this manipulator calls \fCprecision(n)\fP for that object. 
.PP
Definition at line 204 of file iomanip.
.SS "_Setw std::setw (int __n)\fC [inline]\fP"
.PP
Manipulator for \fCwidth\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The new width.
.RE
.PP
Sent to a stream object, this manipulator calls \fCwidth(n)\fP for that object. 
.PP
Definition at line 238 of file iomanip.
.SS "\fBios_base\fP& std::showbase (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::showbase). 
.PP
Definition at line 815 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by noshowbase().
.SS "\fBios_base\fP& std::showpoint (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::showpoint). 
.PP
Definition at line 831 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by noshowpoint().
.SS "\fBios_base\fP& std::showpos (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::showpos). 
.PP
Definition at line 847 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by noshowpos().
.SS "\fBios_base\fP& std::skipws (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::skipws). 
.PP
Definition at line 863 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by noskipws(), and std::basic_istream< _CharT, _Traits >::basic_istream::sentry::sentry().
.SS "template<typename _Tp , typename _Alloc > void std::swap (vector< _Tp, _Alloc > & __x, vector< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::vector::swap()\fP. 
.PP
Definition at line 1216 of file stl_vector.h.
.PP
References std::vector< _Tp, _Alloc >::swap().
.SS "template<typename _Key , typename _Compare , typename _Alloc > void std::swap (set< _Key, _Compare, _Alloc > & __x, set< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::set::swap()\fP. 
.PP
Definition at line 691 of file stl_set.h.
.PP
References std::set< _Key, _Compare, _Alloc >::swap().
.SS "template<class _T1 , class _T2 > void std::swap (pair< _T1, _T2 > & __x, pair< _T1, _T2 > & __y)\fC [inline]\fP"
.PP
See std::pair::swap(). 
.PP
Definition at line 186 of file stl_pair.h.
.PP
References std::pair< _T1, _T2 >::swap().
.SS "template<typename _Key , typename _Compare , typename _Alloc > void std::swap (multiset< _Key, _Compare, _Alloc > & __x, multiset< _Key, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::multiset::swap()\fP. 
.PP
Definition at line 677 of file stl_multiset.h.
.PP
References std::multiset< _Key, _Compare, _Alloc >::swap().
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void std::swap (multimap< _Key, _Tp, _Compare, _Alloc > & __x, multimap< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::multimap::swap()\fP. 
.PP
Definition at line 780 of file stl_multimap.h.
.PP
References std::multimap< _Key, _Tp, _Compare, _Alloc >::swap().
.SS "template<typename _Key , typename _Tp , typename _Compare , typename _Alloc > void std::swap (map< _Key, _Tp, _Compare, _Alloc > & __x, map< _Key, _Tp, _Compare, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::map::swap()\fP. 
.PP
Definition at line 851 of file stl_map.h.
.PP
References std::map< _Key, _Tp, _Compare, _Alloc >::swap().
.SS "template<typename _Tp , typename _Alloc > void std::swap (list< _Tp, _Alloc > & __x, list< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::list::swap()\fP. 
.PP
Definition at line 1516 of file stl_list.h.
.PP
References std::list< _Tp, _Alloc >::swap().
.SS "template<typename _Tp , typename _Alloc > void std::swap (deque< _Tp, _Alloc > & __x, deque< _Tp, _Alloc > & __y)\fC [inline]\fP"
.PP
See \fBstd::deque::swap()\fP. 
.PP
Definition at line 1802 of file stl_deque.h.
.PP
References std::deque< _Tp, _Alloc >::swap().
.SS "template<typename _Tp , typename _Alloc > void std::swap (forward_list< _Tp, _Alloc > & __lx, forward_list< _Tp, _Alloc > && __ly)\fC [inline]\fP"
.PP
See \fBstd::forward_list::swap()\fP. 
.PP
Definition at line 1298 of file forward_list.h.
.PP
References std::forward_list< _Tp, _Alloc >::swap().
.SS "template<typename _Tp , typename _Alloc > void std::swap (forward_list< _Tp, _Alloc > && __lx, forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
See \fBstd::forward_list::swap()\fP. 
.PP
Definition at line 1291 of file forward_list.h.
.SS "template<typename _Tp , typename _Alloc > void std::swap (forward_list< _Tp, _Alloc > & __lx, forward_list< _Tp, _Alloc > & __ly)\fC [inline]\fP"
.PP
See \fBstd::forward_list::swap()\fP. 
.PP
Definition at line 1284 of file forward_list.h.
.PP
References std::forward_list< _Tp, _Alloc >::swap().
.SS "template<typename _CharT , typename _Traits , typename _Alloc > void std::swap (basic_string< _CharT, _Traits, _Alloc > & __lhs, basic_string< _CharT, _Traits, _Alloc > & __rhs)\fC [inline]\fP"
.PP
Swap contents of two strings. 
.PP
\fBParameters:\fP
.RS 4
\fIlhs\fP First string. 
.br
\fIrhs\fP Second string.
.RE
.PP
Exchanges the contents of \fIlhs\fP and \fIrhs\fP in constant time. 
.PP
Definition at line 2466 of file basic_string.h.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::swap().
.SS "template<typename _Tp > void std::swap (_Tp & __a, _Tp & __b)\fC [inline]\fP"
.PP
Swaps two values. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP

.PP
Definition at line 76 of file move.h.
.SS "template<typename _Signature > void std::swap (function< _Signature > & __x, function< _Signature > & __y)\fC [inline]\fP"
.PP
Swap the targets of two polymorphic function object wrappers. 
.PP
This function will not throw an \fBexception\fP. 
.PP
Definition at line 2126 of file tr1_impl/functional.
.SS "template<typename _CharT > _CharT std::tolower (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.tolower(__c). 
.PP
Definition at line 2593 of file locale_facets.h.
.PP
Referenced by std::regex_traits< _Ch_type >::translate_nocase().
.SS "template<typename _CharT > _CharT std::toupper (_CharT __c, const locale & __loc)\fC [inline]\fP"
.PP
Convenience interface to ctype.toupper(__c). 
.PP
Definition at line 2587 of file locale_facets.h.
.SS "template<typename _InputIterator , typename _ForwardIterator > _ForwardIterator std::uninitialized_copy (_InputIterator __first, _InputIterator __last, _ForwardIterator __result)\fC [inline]\fP"
.PP
Copies the range [first,last) into result. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIresult\fP An output \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
result + (first - last)
.RE
.PP
Like copy(), but does not require an initialized output range. 
.PP
Definition at line 107 of file stl_uninitialized.h.
.PP
Referenced by __gnu_parallel::parallel_sort_mwms_pu().
.SS "template<typename _InputIterator , typename _Size , typename _ForwardIterator > _ForwardIterator std::uninitialized_copy_n (_InputIterator __first, _Size __n, _ForwardIterator __result)\fC [inline]\fP"
.PP
Copies the range [first,first+n) into result. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIn\fP The number of elements to copy. 
.br
\fIresult\fP An output \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
result + n
.RE
.PP
Like \fBcopy_n()\fP, but does not require an initialized output range. 
.PP
Definition at line 470 of file stl_uninitialized.h.
.PP
References __iterator_category().
.SS "template<typename _ForwardIterator , typename _Tp > void std::uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __x)\fC [inline]\fP"
.PP
Copies the value x into the range [first,last). 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIx\fP The source value. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Like fill(), but does not require an initialized output range. 
.PP
Definition at line 164 of file stl_uninitialized.h.
.SS "template<typename _ForwardIterator , typename _Size , typename _Tp > void std::uninitialized_fill_n (_ForwardIterator __first, _Size __n, const _Tp & __x)\fC [inline]\fP"
.PP
Copies the value x into the range [first,first+n). 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIn\fP The number of copies to make. 
.br
\fIx\fP The source value. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Like fill_n(), but does not require an initialized output range. 
.PP
Definition at line 218 of file stl_uninitialized.h.
.PP
Referenced by std::_Temporary_buffer< _ForwardIterator, _Tp >::_Temporary_buffer().
.SS "\fBios_base\fP& std::unitbuf (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::unitbuf). 
.PP
Definition at line 895 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by nounitbuf(), and std::basic_ostream< _CharT, _Traits >::basic_ostream::sentry::~sentry().
.SS "\fBios_base\fP& std::uppercase (ios_base & __base)\fC [inline]\fP"
.PP
Calls base.setf(ios_base::uppercase). 
.PP
Definition at line 879 of file ios_base.h.
.PP
References std::ios_base::setf().
.PP
Referenced by nouppercase().
.SS "template<typename _Facet > const _Facet & std::use_facet (const locale & __loc)\fC [inline]\fP"
.PP
Return a facet. 
.PP
use_facet looks for and returns a reference to a facet of type Facet where Facet is the template parameter. If has_facet(locale) is true, there is a suitable facet to return. It throws \fBstd::bad_cast\fP if the \fBlocale\fP doesn't contain a facet of type Facet.
.PP
\fBParameters:\fP
.RS 4
\fIFacet\fP The facet type to access. 
.br
\fI\fBlocale\fP\fP The \fBlocale\fP to use. 
.RE
.PP
\fBReturns:\fP
.RS 4
Reference to facet of type Facet. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::bad_cast\fP\fP if \fBlocale\fP doesn't contain a facet of type Facet. 
.RE
.PP

.PP
Definition at line 105 of file locale_classes.tcc.
.PP
References std::locale::_M_impl.
.PP
Referenced by std::regex_traits< _Ch_type >::isctype(), std::regex_traits< _Ch_type >::transform(), and std::regex_traits< _Ch_type >::translate_nocase().
.SS "template<typename _CharT , typename _Traits > \fBbasic_istream\fP< _CharT, _Traits > & std::ws (basic_istream< _CharT, _Traits > & __is)\fC [inline]\fP"
.PP
Quick and easy way to eat whitespace. 
.PP
This manipulator extracts whitespace characters, stopping when the next character is non-whitespace, or when the input sequence is empty. If the sequence is empty, \fCeofbit\fP is \fBset\fP in the stream, but not \fCfailbit\fP.
.PP
The current \fBlocale\fP is used to distinguish whitespace characters.
.PP
Example: 
.PP
.nf
     MyClass   mc;

     std::cin >> std::ws >> mc;

.fi
.PP
 will skip leading whitespace before calling operator>> on cin and your object. Note that the same effect can be achieved by creating a \fBstd::basic_istream::sentry\fP inside your definition of operator>>. 
.PP
Definition at line 946 of file istream.tcc.
.PP
References std::ios_base::getloc(), std::basic_ios< _CharT, _Traits >::rdbuf(), std::basic_ios< _CharT, _Traits >::setstate(), and std::basic_streambuf< _CharT, _Traits >::sgetc().
.SH "Variable Documentation"
.PP 
.SS "\fBostream\fP \fBstd::cerr\fP"
.PP
Linked to standard error (unbuffered). 
.PP
.SS "\fBistream\fP \fBstd::cin\fP"
.PP
Linked to standard input. 
.PP
.SS "\fBostream\fP \fBstd::clog\fP"
.PP
Linked to standard error (buffered). 
.PP
.SS "\fBostream\fP \fBstd::cout\fP"
.PP
Linked to standard output. 
.PP
.SS "\fBwostream\fP \fBstd::wcerr\fP"
.PP
Linked to standard error (unbuffered). 
.PP
.SS "\fBwistream\fP \fBstd::wcin\fP"
.PP
Linked to standard input. 
.PP
.SS "\fBwostream\fP \fBstd::wclog\fP"
.PP
Linked to standard error (buffered). 
.PP
.SS "\fBwostream\fP \fBstd::wcout\fP"
.PP
Linked to standard output. 
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
