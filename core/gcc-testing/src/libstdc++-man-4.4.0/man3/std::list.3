.TH "std::list" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::list \- A standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB_List_base< _Tp, _Alloc >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_List_const_iterator\fP< _Tp > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_List_iterator\fP< _Tp > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const "
.br
.ti -1c
.RI "template<typename... _Args> \fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace_back\fP (_Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace_front\fP (_Args &&...__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, value_type &&__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, const value_type &__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBlist\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBlist\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBlist\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "\fBlist\fP (size_type __n, const value_type &__value=value_type(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBlist\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBlist\fP ()"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "template<typename _StrictWeakOrdering > void \fBmerge\fP (\fBlist\fP &&, _StrictWeakOrdering)"
.br
.ti -1c
.RI "void \fBmerge\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "\fBlist\fP & \fBoperator=\fP (const \fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (const value_type &__x)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "void \fBremove\fP (const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _Predicate > void \fBremove_if\fP (_Predicate)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, value_type __x=value_type())"
.br
.ti -1c
.RI "void \fBreverse\fP ()"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "template<typename _StrictWeakOrdering > void \fBsort\fP (_StrictWeakOrdering)"
.br
.ti -1c
.RI "void \fBsort\fP ()"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x, \fBiterator\fP __i)"
.br
.ti -1c
.RI "void \fBsplice\fP (\fBiterator\fP __position, \fBlist\fP &&__x)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBlist\fP &&__x)"
.br
.ti -1c
.RI "template<typename _BinaryPredicate > void \fBunique\fP (_BinaryPredicate)"
.br
.ti -1c
.RI "void \fBunique\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef \fB_List_node\fP< _Tp > \fB_Node\fP"
.br
.ti -1c
.RI "typedef _Alloc::template rebind< \fB_List_node\fP< _Tp > >::other \fB_Node_alloc_type\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_check_equal_allocators\fP (\fBlist\fP &__x)"
.br
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "template<typename... _Args> \fB_Node\fP * \fB_M_create_node\fP (_Args &&...__args)"
.br
.ti -1c
.RI "void \fB_M_erase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "\fB_List_node\fP< _Tp > * \fB_M_get_node\fP ()"
.br
.ti -1c
.RI "const _Node_alloc_type & \fB_M_get_Node_allocator\fP () const"
.br
.ti -1c
.RI "_Node_alloc_type & \fB_M_get_Node_allocator\fP ()"
.br
.ti -1c
.RI "_Tp_alloc_type \fB_M_get_Tp_allocator\fP () const"
.br
.ti -1c
.RI "void \fB_M_init\fP ()"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "template<typename... _Args> void \fB_M_insert\fP (\fBiterator\fP __position, _Args &&...__args)"
.br
.ti -1c
.RI "void \fB_M_put_node\fP (\fB_List_node\fP< _Tp > *__p)"
.br
.ti -1c
.RI "void \fB_M_transfer\fP (\fBiterator\fP __position, \fBiterator\fP __first, \fBiterator\fP __last)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_List_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> class std::list< _Tp, _Alloc >"
A standard container with linear time access to elements, and fixed time insertion/deletion at any point in the sequence. 

Meets the requirements of a \fCcontainer\fP, a \fCreversible container\fP, and a \fCsequence\fP, including the \fCoptional sequence requirements\fP with the exception of \fCat\fP and \fCoperator\fP[].
.PP
This is a \fIdoubly\fP \fIlinked\fP list. Traversal up and down the list requires linear time, but adding and removing elements (or \fInodes\fP) is done in constant time, regardless of where the change takes place. Unlike \fBstd::vector\fP and \fBstd::deque\fP, random-access iterators are not provided, so subscripting ( \fC\fP[] ) access is not allowed. For algorithms which only need sequential access, this lack makes no difference.
.PP
Also unlike the other standard containers, \fBstd::list\fP provides specialized algorithms unique to linked lists, such as splicing, sorting, and in-place reversal.
.PP
A couple points on memory allocation for list<Tp>:
.PP
First, we never actually allocate a Tp, we allocate List_node<Tp>'s and trust [20.1.5]/4 to DTRT. This is to ensure that after elements from list<X,Alloc1> are spliced into list<X,Alloc2>, destroying the memory of the second list is a valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.
.PP
Second, a list conceptually represented as 
.PP
.nf
    A <---> B <---> C <---> D

.fi
.PP
 is actually circular; a link exists between A and D. The list class holds (as its only data member) a private list::iterator pointing to \fID\fP, not to \fIA!\fP To get to the head of the list, we start at the tail and move forward by one. When this member iterator's next/previous pointers refer to itself, the list is empty. 
.PP
Definition at line 417 of file stl_list.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP ()\fC [inline]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 499 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (const allocator_type & __a)\fC [inline, explicit]\fP"
.PP
Creates a list with no elements. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP An \fBallocator\fP object. 
.RE
.PP

.PP
Definition at line 507 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (size_type __n, const value_type & __value = \fCvalue_type()\fP, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline, explicit]\fP"
.PP
Creates a list with copies of an exemplar element. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The number of elements to initially create. 
.br
\fIvalue\fP An element to copy. 
.br
\fIa\fP An \fBallocator\fP object.
.RE
.PP
This constructor fills the list with \fIn\fP copies of \fIvalue\fP. 
.PP
Definition at line 519 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (const \fBlist\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
List copy constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created list uses a copy of the allocation object used by \fIx\fP. 
.PP
Definition at line 531 of file stl_list.h.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (\fBlist\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
List move constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created list contains the exact contents of \fIx\fP. The contents of \fIx\fP are a valid, but unspecified list. 
.PP
Definition at line 543 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a list from an \fBinitializer_list\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP of value_type. 
.br
\fIa\fP An \fBallocator\fP object.
.RE
.PP
Create a list consisting of copies of the elements in the \fBinitializer_list\fP \fIl\fP. This is linear in l.size(). 
.PP
Definition at line 554 of file stl_list.h.
.PP
References std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > \fBstd::list\fP< _Tp, _Alloc >::\fBlist\fP (_InputIterator __first, _InputIterator __last, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a list from a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIa\fP An \fBallocator\fP object.
.RE
.PP
Create a list consisting of copies of the elements from [\fIfirst\fP,\fIlast\fP). This is linear in N (where N is distance(\fIfirst\fP,\fIlast\fP)). 
.PP
Definition at line 571 of file stl_list.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename... _Args> \fB_Node\fP* \fBstd::list\fP< _Tp, _Alloc >::_M_create_node (_Args &&... __args)\fC [inline, protected]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIx\fP An instance of user data.
.RE
.PP
Allocates space for a new node and constructs a copy of \fIx\fP in it. 
.PP
Definition at line 476 of file stl_list.h.
.PP
Referenced by std::list< _Tp, _Alloc >::emplace(), and std::list< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Assigns an \fBinitializer_list\fP to a list. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP of value_type.
.RE
.PP
Replace the contents of the list with copies of the elements in the \fBinitializer_list\fP \fIl\fP. This is linear in l.size(). 
.PP
Definition at line 674 of file stl_list.h.
.PP
References std::list< _Tp, _Alloc >::assign(), std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.PP
Referenced by std::list< _Tp, _Alloc >::assign().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::list\fP< _Tp, _Alloc >::assign (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Assigns a range to a list. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function fills a list with copies of the elements in the range [\fIfirst\fP,\fIlast\fP).
.PP
Note that the assignment completely changes the list and that the resulting list's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 658 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::assign (size_type __n, const value_type & __val)\fC [inline]\fP"
.PP
Assigns a given value to a list. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements to be assigned. 
.br
\fIval\fP Value to be assigned.
.RE
.PP
This function fills a list with \fIn\fP copies of the given value. Note that the assignment completely changes the list and that the resulting list's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 641 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::list\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the last element of the list. 
.PP
Definition at line 859 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::list\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the last element of the list. 
.PP
Definition at line 847 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 698 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points to the first element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 689 of file stl_list.h.
.PP
Referenced by std::list< _Tp, _Alloc >::list(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::operator=(), std::operator==(), std::list< _Tp, _Alloc >::remove(), std::list< _Tp, _Alloc >::remove_if(), std::list< _Tp, _Alloc >::resize(), std::list< _Tp, _Alloc >::sort(), std::list< _Tp, _Alloc >::splice(), and std::list< _Tp, _Alloc >::unique().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 762 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 771 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP"
.PP
Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 1130 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 780 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 789 of file stl_list.h.
.SS "template<typename _Tp , typename _Alloc > template<typename... _Args> \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP list::emplace (\fBiterator\fP __position, _Args &&... __args)\fC [inline]\fP"
.PP
Constructs object in list before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP A const_iterator into the list. 
.br
\fIargs\fP Arguments. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert an object of type T constructed with T(std::forward<Args>(args)...) before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. 
.PP
Definition at line 87 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::_M_create_node(), std::_List_iterator< _Tp >::_M_node, and std::_List_node_base::hook().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::list\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP"
.PP
Returns true if the list is empty. (Thus \fBbegin()\fP would equal \fBend()\fP.) 
.PP
Definition at line 799 of file stl_list.h.
.PP
Referenced by std::list< _Tp, _Alloc >::sort(), and std::list< _Tp, _Alloc >::splice().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::end () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 716 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::end ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points one past the last element in the list. Iteration is done in ordinary element order. 
.PP
Definition at line 707 of file stl_list.h.
.PP
Referenced by std::list< _Tp, _Alloc >::list(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::operator=(), std::operator==(), std::list< _Tp, _Alloc >::remove(), std::list< _Tp, _Alloc >::remove_if(), std::list< _Tp, _Alloc >::resize(), std::list< _Tp, _Alloc >::splice(), and std::list< _Tp, _Alloc >::unique().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::erase (\fBiterator\fP __first, \fBiterator\fP __last)\fC [inline]\fP"
.PP
Remove a range of elements. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Iterator pointing to the first element to be erased. 
.br
\fIlast\fP Iterator pointing to one past the last element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the element pointed to by \fIlast\fP prior to erasing (or \fBend()\fP).
.RE
.PP
This function will erase the elements in the range \fI\fP[first,last) and shorten the list accordingly.
.PP
This operation is linear time in the size of the range and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 1092 of file stl_list.h.
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP list::erase (\fBiterator\fP __position)\fC [inline]\fP"
.PP
Remove element at given position. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator pointing to element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the next element (or \fBend()\fP).
.RE
.PP
This function will erase the element at the given position and thus shorten the list by one.
.PP
Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 108 of file list.tcc.
.PP
References std::_List_node_base::_M_next, and std::_List_iterator< _Tp >::_M_node.
.PP
Referenced by std::list< _Tp, _Alloc >::operator=(), and std::list< _Tp, _Alloc >::resize().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::list\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the first element of the list. 
.PP
Definition at line 839 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::list\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the first element of the list. 
.PP
Definition at line 831 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> allocator_type \fBstd::list\fP< _Tp, _Alloc >::get_allocator () const\fC [inline]\fP"
.PP
Get a copy of the memory allocation object. 
.PP
Reimplemented from \fBstd::_List_base< _Tp, _Alloc >\fP.
.PP
Definition at line 680 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Inserts a range into the list. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the list. 
.br
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function will insert copies of the data in the range [\fIfirst\fP,\fIlast\fP) into the list before the location specified by \fIposition\fP.
.PP
This operation is linear in the number of elements inserted and does not invalidate iterators and references. 
.PP
Definition at line 1048 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, size_type __n, const value_type & __x)\fC [inline]\fP"
.PP
Inserts a number of copies of given data into the list. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the list. 
.br
\fIn\fP Number of elements to be inserted. 
.br
\fIx\fP Data to be inserted.
.RE
.PP
This function will insert a specified number of copies of the given data before the location specified by \fIposition\fP.
.PP
This operation is linear in the number of elements inserted and does not invalidate iterators and references. 
.PP
Definition at line 1027 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Inserts the contents of an \fBinitializer_list\fP into list before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP An \fBiterator\fP into the list. 
.br
\fIl\fP An \fBinitializer_list\fP of value_type.
.RE
.PP
This function will insert copies of the data in the \fBinitializer_list\fP \fIl\fP into the list before the location specified by \fIp\fP.
.PP
This operation is linear in the number of elements inserted and does not invalidate iterators and references. 
.PP
Definition at line 1010 of file stl_list.h.
.PP
References std::initializer_list< _E >::begin(), std::initializer_list< _E >::end(), and std::list< _Tp, _Alloc >::insert().
.PP
Referenced by std::list< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::list\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, value_type && __x)\fC [inline]\fP"
.PP
Inserts given rvalue into list before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the list. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given rvalue before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. 
.PP
Definition at line 993 of file stl_list.h.
.PP
References std::move().
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc >::\fBiterator\fP list::insert (\fBiterator\fP __position, const value_type & __x)\fC [inline]\fP"
.PP
Inserts given value into list before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the list. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given value before the specified location. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. 
.PP
Definition at line 98 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::_M_create_node(), std::_List_iterator< _Tp >::_M_node, and std::_List_node_base::hook().
.PP
Referenced by std::list< _Tp, _Alloc >::operator=(), and std::list< _Tp, _Alloc >::resize().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::list\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP"
.PP
Returns the \fBsize()\fP of the largest possible list. 
.PP
Definition at line 809 of file stl_list.h.
.SS "template<typename _Tp , typename _Alloc > template<typename _StrictWeakOrdering > void list::merge (\fBlist\fP< _Tp, _Alloc > && __x, _StrictWeakOrdering __comp)\fC [inline]\fP"
.PP
Merge sorted lists according to comparison function. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Sorted \fBlist\fP to merge. 
.br
\fIStrictWeakOrdering\fP Comparison function defining sort order.
.RE
.PP
Assumes that both \fIx\fP and this \fBlist\fP are sorted according to StrictWeakOrdering. Merges elements of \fIx\fP into this \fBlist\fP in sorted order, leaving \fIx\fP empty when complete. Elements in this \fBlist\fP precede elements in \fIx\fP that are equivalent according to StrictWeakOrdering(). 
.PP
Definition at line 270 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _Tp , typename _Alloc > void list::merge (\fBlist\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Merge sorted lists. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Sorted \fBlist\fP to merge.
.RE
.PP
Assumes that both \fIx\fP and this \fBlist\fP are sorted according to operator<(). Merges elements of \fIx\fP into this \fBlist\fP in sorted order, leaving \fIx\fP empty when complete. Elements in this \fBlist\fP precede elements in \fIx\fP that are equal. 
.PP
Definition at line 236 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.PP
Referenced by std::list< _Tp, _Alloc >::sort().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBlist\fP& \fBstd::list\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
List initializer \fBlist\fP assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP of value_type.
.RE
.PP
Replace the contents of the list with copies of the elements in the \fBinitializer_list\fP \fIl\fP. This is linear in l.size(). 
.PP
Definition at line 623 of file stl_list.h.
.PP
References std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBlist\fP& \fBstd::list\fP< _Tp, _Alloc >::operator= (\fBlist\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
List move assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list of identical element and \fBallocator\fP types.
.RE
.PP
The contents of \fIx\fP are moved into this list (without copying). \fIx\fP is a valid, but unspecified list 
.PP
Definition at line 607 of file stl_list.h.
.SS "template<typename _Tp , typename _Alloc > \fBlist\fP< _Tp, _Alloc > & list::operator= (const \fBlist\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
List assignment operator. 
.PP
No explicit dtor needed as the _Base dtor takes care of things. The _Base dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list of identical element and \fBallocator\fP types.
.RE
.PP
All the elements of \fIx\fP are copied, but unlike the copy constructor, the \fBallocator\fP object is not copied. 
.PP
Definition at line 133 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::end(), std::list< _Tp, _Alloc >::erase(), and std::list< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"
.PP
Removes last element. 
.PP
This is a typical \fBstack\fP operation. It shrinks the list by one. Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed.
.PP
Note that no data is returned, and if the last element's data is needed, it should be retrieved before \fBpop_back()\fP is called. 
.PP
Definition at line 945 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::pop_front ()\fC [inline]\fP"
.PP
Removes first element. 
.PP
This is a typical \fBstack\fP operation. It shrinks the list by one. Due to the nature of a list this operation can be done in constant time, and only invalidates iterators/references to the element being removed.
.PP
Note that no data is returned, and if the first element's data is needed, it should be retrieved before \fBpop_front()\fP is called. 
.PP
Definition at line 905 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::push_back (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the end of the list. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical \fBstack\fP operation. The function creates an element at the end of the list and assigns the given data to it. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. 
.PP
Definition at line 919 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::push_front (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the front of the list. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical \fBstack\fP operation. The function creates an element at the front of the list and assigns the given data to it. Due to the nature of a list this operation can be done in constant time, and does not invalidate iterators and references. 
.PP
Definition at line 878 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 734 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to the last element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 725 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc > void list::remove (const _Tp & __value)\fC [inline]\fP"
.PP
Remove all elements equal to value. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP The value to remove.
.RE
.PP
Removes every element in the \fBlist\fP equal to \fIvalue\fP. Remaining elements stay in \fBlist\fP order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 187 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _Tp , typename _Alloc > template<typename _Predicate > void list::remove_if (_Predicate __pred)\fC [inline]\fP"
.PP
Remove all elements satisfying a predicate. 
.PP
\fBParameters:\fP
.RS 4
\fIPredicate\fP Unary predicate function or object.
.RE
.PP
Removes every element in the \fBlist\fP for which the predicate returns true. Remaining elements stay in \fBlist\fP order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 340 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 752 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::list\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to one before the first element in the list. Iteration is done in reverse element order. 
.PP
Definition at line 743 of file stl_list.h.
.SS "template<typename _Tp , typename _Alloc > void list::resize (size_type __new_size, value_type __x = \fCvalue_type()\fP)\fC [inline]\fP"
.PP
Resizes the list to the specified number of elements. 
.PP
\fBParameters:\fP
.RS 4
\fInew_size\fP Number of elements the list should contain. 
.br
\fIx\fP Data with which new elements should be populated.
.RE
.PP
This function will resize the list to the specified number of elements. If the number is smaller than the list's current size the list is truncated, otherwise the list is extended and new elements are populated with given data. 
.PP
Definition at line 118 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::end(), std::list< _Tp, _Alloc >::erase(), and std::list< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::reverse ()\fC [inline]\fP"
.PP
Reverse the elements in \fBlist\fP. 
.PP
Reverse the order of elements in the \fBlist\fP in linear time. 
.PP
Definition at line 1320 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::list\fP< _Tp, _Alloc >::size () const\fC [inline]\fP"
.PP
Returns the number of elements in the list. 
.PP
Definition at line 804 of file stl_list.h.
.PP
References std::distance().
.SS "template<typename _Tp , typename _Alloc > template<typename _StrictWeakOrdering > void list::sort (_StrictWeakOrdering __comp)\fC [inline]\fP"
.PP
Sort the elements according to comparison function. 
.PP
Sorts the elements of this \fBlist\fP in NlogN time. Equivalent elements remain in \fBlist\fP order. 
.PP
Definition at line 379 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::empty(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::splice(), and std::list< _Tp, _Alloc >::swap().
.SS "template<typename _Tp , typename _Alloc > void list::sort ()\fC [inline]\fP"
.PP
Sort the elements. 
.PP
Sorts the elements of this \fBlist\fP in NlogN time. Equivalent elements remain in \fBlist\fP order. 
.PP
Definition at line 302 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::empty(), std::list< _Tp, _Alloc >::merge(), std::list< _Tp, _Alloc >::splice(), and std::list< _Tp, _Alloc >::swap().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP __position, \fBlist\fP< _Tp, _Alloc > && __x, \fBiterator\fP __first, \fBiterator\fP __last)\fC [inline]\fP"
.PP
Insert range from another list. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator referencing the element to insert before. 
.br
\fIx\fP Source \fBlist\fP. 
.br
\fIfirst\fP Iterator referencing the start of range in x. 
.br
\fIlast\fP Iterator referencing the end of range in x.
.RE
.PP
Removes elements in the range [first,last) and inserts them before \fIposition\fP in constant time.
.PP
Undefined if \fIposition\fP is in [first,last). 
.PP
Definition at line 1204 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP __position, \fBlist\fP< _Tp, _Alloc > && __x, \fBiterator\fP __i)\fC [inline]\fP"
.PP
Insert element from another list. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator referencing the element to insert before. 
.br
\fIx\fP Source \fBlist\fP. 
.br
\fIi\fP Iterator referencing the element to move.
.RE
.PP
Removes the element in \fBlist\fP \fIx\fP referenced by \fIi\fP and inserts it into the current \fBlist\fP before \fIposition\fP. 
.PP
Definition at line 1174 of file stl_list.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::splice (\fBiterator\fP __position, \fBlist\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Insert contents of another list. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator referencing the element to insert before. 
.br
\fIx\fP Source \fBlist\fP.
.RE
.PP
The elements of \fIx\fP are inserted in constant time in front of the element referenced by \fIposition\fP. \fIx\fP becomes an empty \fBlist\fP.
.PP
Requires this != \fIx\fP. 
.PP
Definition at line 1150 of file stl_list.h.
.PP
References std::list< _Tp, _Alloc >::begin(), std::list< _Tp, _Alloc >::empty(), and std::list< _Tp, _Alloc >::end().
.PP
Referenced by std::list< _Tp, _Alloc >::sort().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::list\fP< _Tp, _Alloc >::swap (\fBlist\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Swaps data with another list. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A list of the same element and \fBallocator\fP types.
.RE
.PP
This exchanges the elements between two lists in constant time. Note that the global std::swap() function is specialized such that std::swap(l1,l2) will feed to this function. 
.PP
Definition at line 1110 of file stl_list.h.
.PP
References std::_List_base< _Tp, _Alloc >::_M_get_Node_allocator(), and std::_List_base< _Tp, _Alloc >::_M_impl.
.PP
Referenced by std::list< _Tp, _Alloc >::sort(), and std::swap().
.SS "template<typename _Tp , typename _Alloc > template<typename _BinaryPredicate > void list::unique (_BinaryPredicate __binary_pred)\fC [inline]\fP"
.PP
Remove consecutive elements satisfying a predicate. 
.PP
\fBParameters:\fP
.RS 4
\fIBinaryPredicate\fP Binary predicate function or object.
.RE
.PP
For each consecutive \fBset\fP of elements [first,last) that satisfy predicate(first,i) where i is an \fBiterator\fP in [first,last), remove all but the first one. Remaining elements stay in \fBlist\fP order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 358 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().
.SS "template<typename _Tp , typename _Alloc > void list::unique ()\fC [inline]\fP"
.PP
Remove consecutive duplicate elements. 
.PP
For each consecutive \fBset\fP of elements with the same value, remove all but the first one. Remaining elements stay in \fBlist\fP order. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 215 of file list.tcc.
.PP
References std::list< _Tp, _Alloc >::begin(), and std::list< _Tp, _Alloc >::end().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
