.TH "__gnu_parallel" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_parallel \- GNU parallel code for public use.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB_Settings\fP"
.br
.RI "\fIclass \fB_Settings\fP Run-time settings for the parallel mode, including all tunable parameters. \fP"
.ti -1c
.RI "struct \fBaccumulate_binop_reduct\fP"
.br
.RI "\fIGeneral reduction, using a binary operator. \fP"
.ti -1c
.RI "struct \fBaccumulate_selector\fP"
.br
.RI "\fI\fBstd::accumulate()\fP selector. \fP"
.ti -1c
.RI "struct \fBadjacent_difference_selector\fP"
.br
.RI "\fISelector that returns the difference between two adjacent elements. \fP"
.ti -1c
.RI "struct \fBadjacent_find_selector\fP"
.br
.RI "\fITest predicate on two adjacent elements. \fP"
.ti -1c
.RI "struct \fBbalanced_quicksort_tag\fP"
.br
.RI "\fIForces parallel sorting using balanced quicksort at compile time. \fP"
.ti -1c
.RI "struct \fBbalanced_tag\fP"
.br
.RI "\fIRecommends parallel execution using dynamic load-balancing at compile time. \fP"
.ti -1c
.RI "class \fBbinder1st\fP"
.br
.RI "\fISimilar to \fBstd::binder1st\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "class \fBbinder2nd\fP"
.br
.RI "\fISimilar to \fBstd::binder2nd\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "struct \fBconstant_size_blocks_tag\fP"
.br
.RI "\fISelects the constant block size variant for std::find(). \fP"
.ti -1c
.RI "struct \fBcount_if_selector\fP"
.br
.RI "\fIstd::count_if () selector. \fP"
.ti -1c
.RI "struct \fBcount_selector\fP"
.br
.RI "\fIstd::count() selector. \fP"
.ti -1c
.RI "struct \fBdefault_parallel_tag\fP"
.br
.RI "\fIRecommends parallel execution using the default parallel algorithm. \fP"
.ti -1c
.RI "struct \fBDRandomShufflingGlobalData\fP"
.br
.RI "\fIData known to every thread participating in \fB__gnu_parallel::parallel_random_shuffle()\fP. \fP"
.ti -1c
.RI "struct \fBDRSSorterPU\fP"
.br
.RI "\fILocal data for a thread participating in \fB__gnu_parallel::parallel_random_shuffle()\fP. \fP"
.ti -1c
.RI "struct \fBdummy_reduct\fP"
.br
.RI "\fIReduction function doing \fBnothing\fP. \fP"
.ti -1c
.RI "class \fBequal_from_less\fP"
.br
.RI "\fIConstructs predicate for equality from strict weak ordering predicate. \fP"
.ti -1c
.RI "struct \fBequal_split_tag\fP"
.br
.RI "\fISelects the equal splitting variant for std::find(). \fP"
.ti -1c
.RI "struct \fBequal_to\fP"
.br
.RI "\fISimilar to \fBstd::equal_to\fP, but allows two different types. \fP"
.ti -1c
.RI "struct \fBexact_tag\fP"
.br
.RI "\fIForces parallel merging with exact splitting, at compile time. \fP"
.ti -1c
.RI "struct \fBfill_selector\fP"
.br
.RI "\fIstd::fill() selector. \fP"
.ti -1c
.RI "struct \fBfind_first_of_selector\fP"
.br
.RI "\fITest predicate on several elements. \fP"
.ti -1c
.RI "struct \fBfind_if_selector\fP"
.br
.RI "\fITest predicate on a single element, used for std::find() and std::find_if (). \fP"
.ti -1c
.RI "struct \fBfind_tag\fP"
.br
.RI "\fIBase class for for std::find() variants. \fP"
.ti -1c
.RI "struct \fBfor_each_selector\fP"
.br
.RI "\fIstd::for_each() selector. \fP"
.ti -1c
.RI "struct \fBgenerate_selector\fP"
.br
.RI "\fIstd::generate() selector. \fP"
.ti -1c
.RI "struct \fBgeneric_find_selector\fP"
.br
.RI "\fIBase class of all \fB__gnu_parallel::find_template\fP selectors. \fP"
.ti -1c
.RI "struct \fBgeneric_for_each_selector\fP"
.br
.RI "\fIGeneric selector for embarrassingly parallel functions. \fP"
.ti -1c
.RI "struct \fBgrowing_blocks_tag\fP"
.br
.RI "\fISelects the growing block size variant for std::find(). \fP"
.ti -1c
.RI "class \fBguarded_iterator\fP"
.br
.RI "\fIIterator wrapper supporting an implicit supremum at the end of the sequence, dominating all comparisons. \fP"
.ti -1c
.RI "struct \fBidentity_selector\fP"
.br
.RI "\fISelector that just returns the passed iterator. \fP"
.ti -1c
.RI "struct \fBinner_product_selector\fP"
.br
.RI "\fI\fBstd::inner_product()\fP selector. \fP"
.ti -1c
.RI "class \fBiterator_pair\fP"
.br
.RI "\fIA pair of iterators. The usual iterator operations are applied to both child iterators. \fP"
.ti -1c
.RI "class \fBiterator_triple\fP"
.br
.RI "\fIA triple of iterators. The usual iterator operations are applied to all three child iterators. \fP"
.ti -1c
.RI "struct \fBJob\fP"
.br
.RI "\fIOne job for a certain thread. \fP"
.ti -1c
.RI "struct \fBless\fP"
.br
.RI "\fISimilar to \fBstd::less\fP, but allows two different types. \fP"
.ti -1c
.RI "class \fBlexicographic\fP"
.br
.RI "\fICompare a pair of types lexicographically, ascending. \fP"
.ti -1c
.RI "class \fBlexicographic_reverse\fP"
.br
.RI "\fICompare a pair of types lexicographically, descending. \fP"
.ti -1c
.RI "struct \fBloser_tree_traits\fP"
.br
.RI "\fITraits for determining whether the loser tree should use pointers or copies. \fP"
.ti -1c
.RI "class \fBLoserTree\fP"
.br
.RI "\fIStable \fBLoserTree\fP variant. \fP"
.ti -1c
.RI "class \fBLoserTree< false, T, Comparator >\fP"
.br
.RI "\fIUnstable \fBLoserTree\fP variant. \fP"
.ti -1c
.RI "class \fBLoserTreeBase\fP"
.br
.RI "\fIGuarded loser/tournament tree. \fP"
.ti -1c
.RI "class \fBLoserTreePointer\fP"
.br
.RI "\fIStable \fBLoserTree\fP implementation. \fP"
.ti -1c
.RI "class \fBLoserTreePointer< false, T, Comparator >\fP"
.br
.RI "\fIUnstable \fBLoserTree\fP implementation. \fP"
.ti -1c
.RI "class \fBLoserTreePointerBase\fP"
.br
.RI "\fIBase class of \fBLoser\fP Tree implementation using pointers. \fP"
.ti -1c
.RI "class \fBLoserTreePointerUnguarded\fP"
.br
.RI "\fIStable unguarded \fBLoserTree\fP variant storing pointers. \fP"
.ti -1c
.RI "class \fBLoserTreePointerUnguarded< false, T, Comparator >\fP"
.br
.RI "\fIUnstable unguarded \fBLoserTree\fP variant storing pointers. \fP"
.ti -1c
.RI "class \fBLoserTreePointerUnguardedBase\fP"
.br
.RI "\fIUnguarded loser tree, keeping only pointers to the elements in the tree structure. \fP"
.ti -1c
.RI "class \fBLoserTreeUnguarded\fP"
.br
.RI "\fIStable implementation of unguarded \fBLoserTree\fP. \fP"
.ti -1c
.RI "class \fBLoserTreeUnguarded< false, T, Comparator >\fP"
.br
.RI "\fINon-Stable implementation of unguarded \fBLoserTree\fP. \fP"
.ti -1c
.RI "class \fBLoserTreeUnguardedBase\fP"
.br
.RI "\fIBase class for unguarded \fBLoserTree\fP implementation. \fP"
.ti -1c
.RI "struct \fBmax_element_reduct\fP"
.br
.RI "\fIReduction for finding the maximum element, using a comparator. \fP"
.ti -1c
.RI "struct \fBmin_element_reduct\fP"
.br
.RI "\fIReduction for finding the maximum element, using a comparator. \fP"
.ti -1c
.RI "struct \fBmismatch_selector\fP"
.br
.RI "\fITest inverted predicate on a single element. \fP"
.ti -1c
.RI "struct \fBmultiplies\fP"
.br
.RI "\fISimilar to \fBstd::multiplies\fP, but allows two different types. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_3_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for 3-way merging with sentinels turned off. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_3_variant_sentinel_switch< true, RandomAccessIteratorIterator, RandomAccessIterator3, _DifferenceTp, Comparator >\fP"
.br
.RI "\fISwitch for 3-way merging with sentinels turned on. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_4_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for 4-way merging with sentinels turned off. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_4_variant_sentinel_switch< true, RandomAccessIteratorIterator, RandomAccessIterator3, _DifferenceTp, Comparator >\fP"
.br
.RI "\fISwitch for 4-way merging with sentinels turned on. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_k_variant_sentinel_switch\fP"
.br
.RI "\fISwitch for k-way merging with sentinels turned on. \fP"
.ti -1c
.RI "struct \fBmultiway_merge_k_variant_sentinel_switch< false, stable, RandomAccessIteratorIterator, RandomAccessIterator3, _DifferenceTp, Comparator >\fP"
.br
.RI "\fISwitch for k-way merging with sentinels turned off. \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_exact_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort with exact splitting at compile time. \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_sampling_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort with splitting by sampling at compile time. \fP"
.ti -1c
.RI "struct \fBmultiway_mergesort_tag\fP"
.br
.RI "\fIForces parallel sorting using multiway mergesort at compile time. \fP"
.ti -1c
.RI "struct \fBnothing\fP"
.br
.RI "\fIFunctor doing \fBnothing\fP. \fP"
.ti -1c
.RI "struct \fBomp_loop_static_tag\fP"
.br
.RI "\fIRecommends parallel execution using OpenMP static load-balancing at compile time. \fP"
.ti -1c
.RI "struct \fBomp_loop_tag\fP"
.br
.RI "\fIRecommends parallel execution using OpenMP dynamic load-balancing at compile time. \fP"
.ti -1c
.RI "struct \fBparallel_tag\fP"
.br
.RI "\fIRecommends parallel execution at compile time, optionally using a user-specified number of threads. \fP"
.ti -1c
.RI "struct \fBPiece\fP"
.br
.RI "\fISubsequence description. \fP"
.ti -1c
.RI "struct \fBplus\fP"
.br
.RI "\fISimilar to \fBstd::plus\fP, but allows two different types. \fP"
.ti -1c
.RI "struct \fBPMWMSSortingData\fP"
.br
.RI "\fIData accessed by all threads. \fP"
.ti -1c
.RI "class \fBpseudo_sequence\fP"
.br
.RI "\fISequence that conceptually consists of multiple copies of the same element. The copies are not stored explicitly, of course. \fP"
.ti -1c
.RI "class \fBpseudo_sequence_iterator\fP"
.br
.RI "\fIIterator associated with \fB__gnu_parallel::pseudo_sequence\fP. If features the usual random-access iterator functionality. \fP"
.ti -1c
.RI "struct \fBQSBThreadLocal\fP"
.br
.RI "\fIInformation local to one thread in the parallel quicksort run. \fP"
.ti -1c
.RI "struct \fBquicksort_tag\fP"
.br
.RI "\fIForces parallel sorting using unbalanced quicksort at compile time. \fP"
.ti -1c
.RI "class \fBrandom_number\fP"
.br
.RI "\fIRandom number generator, based on the Mersenne twister. \fP"
.ti -1c
.RI "struct \fBreplace_if_selector\fP"
.br
.RI "\fIstd::replace() selector. \fP"
.ti -1c
.RI "struct \fBreplace_selector\fP"
.br
.RI "\fIstd::replace() selector. \fP"
.ti -1c
.RI "class \fBRestrictedBoundedConcurrentQueue\fP"
.br
.RI "\fIDouble-ended queue of bounded size, allowing lock-free atomic access. \fBpush_front()\fP and \fBpop_front()\fP must not be called concurrently to each other, while \fBpop_back()\fP can be called concurrently at all times. \fCempty()\fP, \fCsize()\fP, and \fCtop()\fP are intentionally not provided. Calling them would not make sense in a concurrent setting. \fP"
.ti -1c
.RI "struct \fBsampling_sorter\fP"
.br
.RI "\fIStable sorting functor. \fP"
.ti -1c
.RI "struct \fBsampling_sorter< false, RandomAccessIterator, StrictWeakOrdering >\fP"
.br
.RI "\fINon-stable sorting functor. \fP"
.ti -1c
.RI "struct \fBsampling_tag\fP"
.br
.RI "\fIForces parallel merging with exact splitting, at compile time. \fP"
.ti -1c
.RI "struct \fBsequential_tag\fP"
.br
.RI "\fIForces sequential execution at compile time. \fP"
.ti -1c
.RI "struct \fBsplit_consistently\fP"
.br
.RI "\fISplit consistently. \fP"
.ti -1c
.RI "struct \fBsplit_consistently< false, RandomAccessIterator, Comparator, SortingPlacesIterator >\fP"
.br
.RI "\fISplit by sampling. \fP"
.ti -1c
.RI "struct \fBsplit_consistently< true, RandomAccessIterator, Comparator, SortingPlacesIterator >\fP"
.br
.RI "\fISplit by exact splitting. \fP"
.ti -1c
.RI "struct \fBtransform1_selector\fP"
.br
.RI "\fIstd::transform() selector, one input sequence variant. \fP"
.ti -1c
.RI "struct \fBtransform2_selector\fP"
.br
.RI "\fIstd::transform() selector, two input sequences variant. \fP"
.ti -1c
.RI "class \fBunary_negate\fP"
.br
.RI "\fISimilar to \fBstd::binder1st\fP, but giving the argument types explicitly. \fP"
.ti -1c
.RI "struct \fBunbalanced_tag\fP"
.br
.RI "\fIRecommends parallel execution using static load-balancing at compile time. \fP"
.ti -1c
.RI "class \fBvoid_functor\fP"
.br
.RI "\fIFunctor that does \fBnothing\fP. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef unsigned short \fBbin_index\fP"
.br
.ti -1c
.RI "typedef short \fBint16\fP"
.br
.ti -1c
.RI "typedef int \fBint32\fP"
.br
.ti -1c
.RI "typedef long long \fBint64\fP"
.br
.ti -1c
.RI "typedef \fBint64\fP \fBlcas_t\fP"
.br
.ti -1c
.RI "typedef \fBuint64\fP \fBsequence_index_t\fP"
.br
.ti -1c
.RI "typedef \fBuint16\fP \fBthread_index_t\fP"
.br
.ti -1c
.RI "typedef unsigned short \fBuint16\fP"
.br
.ti -1c
.RI "typedef unsigned int \fBuint32\fP"
.br
.ti -1c
.RI "typedef unsigned long long \fBuint64\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_AlgorithmStrategy\fP { \fBheuristic\fP, \fBforce_sequential\fP, \fBforce_parallel\fP }"
.br
.ti -1c
.RI "enum \fB_FindAlgorithm\fP { \fBGROWING_BLOCKS\fP, \fBCONSTANT_SIZE_BLOCKS\fP, \fBEQUAL_SPLIT\fP }"
.br
.ti -1c
.RI "enum \fB_MultiwayMergeAlgorithm\fP { \fBLOSER_TREE\fP }"
.br
.ti -1c
.RI "enum \fB_Parallelism\fP { \fBsequential\fP, \fBparallel_unbalanced\fP, \fBparallel_balanced\fP, \fBparallel_omp_loop\fP, \fBparallel_omp_loop_static\fP, \fBparallel_taskqueue\fP }"
.br
.ti -1c
.RI "enum \fB_PartialSumAlgorithm\fP { \fBRECURSIVE\fP, \fBLINEAR\fP }"
.br
.ti -1c
.RI "enum \fB_SortAlgorithm\fP { \fBMWMS\fP, \fBQS\fP, \fBQS_BALANCED\fP }"
.br
.ti -1c
.RI "enum \fB_SplittingAlgorithm\fP { \fBSAMPLING\fP, \fBEXACT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename Size > Size \fB__log2\fP (Size n)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename _DifferenceTp > void \fBcalc_borders\fP (RandomAccessIterator elements, _DifferenceTp length, _DifferenceTp *off)"
.br
.ti -1c
.RI "template<typename T > bool \fBcompare_and_swap\fP (volatile T *ptr, T comparand, T replacement)"
.br
.ti -1c
.RI "bool \fBcompare_and_swap_32\fP (volatile \fBint32\fP *ptr, \fBint32\fP comparand, \fBint32\fP replacement)"
.br
.ti -1c
.RI "bool \fBcompare_and_swap_64\fP (volatile \fBint64\fP *ptr, \fBint64\fP comparand, \fBint64\fP replacement)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator > OutputIterator \fBcopy_tail\fP (\fBstd::pair\fP< InputIterator, InputIterator > b, \fBstd::pair\fP< InputIterator, InputIterator > e, OutputIterator r)"
.br
.ti -1c
.RI "void \fBdecode2\fP (\fBlcas_t\fP x, int &a, int &b)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename _DifferenceTp > void \fBdetermine_samples\fP (\fBPMWMSSortingData\fP< RandomAccessIterator > *sd, _DifferenceTp num_samples)"
.br
.ti -1c
.RI "\fBlcas_t\fP \fBencode2\fP (int a, int b)"
.br
.ti -1c
.RI "template<typename difference_type , typename OutputIterator > OutputIterator \fBequally_split\fP (difference_type n, \fBthread_index_t\fP num_threads, OutputIterator s)"
.br
.ti -1c
.RI "template<typename difference_type > difference_type \fBequally_split_point\fP (difference_type n, \fBthread_index_t\fP num_threads, \fBthread_index_t\fP thread_no)"
.br
.ti -1c
.RI "template<typename T > T \fBfetch_and_add\fP (volatile T *ptr, T addend)"
.br
.ti -1c
.RI "\fBint32\fP \fBfetch_and_add_32\fP (volatile \fBint32\fP *ptr, \fBint32\fP addend)"
.br
.ti -1c
.RI "\fBint64\fP \fBfetch_and_add_64\fP (volatile \fBint64\fP *ptr, \fBint64\fP addend)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename Pred , typename Selector > \fBstd::pair\fP< RandomAccessIterator1, RandomAccessIterator2 > \fBfind_template\fP (RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred, Selector selector)"
.br
.ti -1c
.RI "template<typename InputIterator , typename UserOp , typename Functionality , typename Red , typename Result > UserOp \fBfor_each_template_random_access\fP (InputIterator begin, InputIterator end, UserOp user_op, Functionality &functionality, Red reduction, Result reduction_start, Result &output, typename \fBstd::iterator_traits\fP< InputIterator >::difference_type bound, \fB_Parallelism\fP parallelism_tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op \fBfor_each_template_random_access_ed\fP (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu &f, Red r, Result base, Result &output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op \fBfor_each_template_random_access_omp_loop\fP (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu &f, Red r, Result base, Result &output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op \fBfor_each_template_random_access_omp_loop_static\fP (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu &f, Red r, Result base, Result &output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op \fBfor_each_template_random_access_workstealing\fP (RandomAccessIterator begin, RandomAccessIterator end, Op op, Fu &f, Red r, Result base, Result &output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)"
.br
.ti -1c
.RI "int \fBget_max_threads\fP ()"
.br
.ti -1c
.RI "bool \fBis_parallel\fP (const \fB_Parallelism\fP __p)"
.br
.ti -1c
.RI "template<typename InputIterator , typename Comparator > bool \fBis_sorted\fP (InputIterator begin, InputIterator end, Comparator comp=\fBstd::less\fP< typename \fBstd::iterator_traits\fP< InputIterator >::value_type >())"
.br
.ti -1c
.RI "template<typename InputIterator , typename Comparator > bool \fBis_sorted_failure\fP (InputIterator begin, InputIterator end, InputIterator &first_failure, Comparator comp=\fBstd::less\fP< typename \fBstd::iterator_traits\fP< InputIterator >::value_type >())"
.br
.ti -1c
.RI "template<typename InputIterator , typename Comparator > bool \fBis_sorted_print_failures\fP (InputIterator begin, InputIterator end, Comparator comp=\fBstd::less\fP< typename \fBstd::iterator_traits\fP< InputIterator >::value_type >())"
.br
.ti -1c
.RI "template<typename InputIterator , typename FunctorType > size_t \fBlist_partition\fP (const InputIterator begin, const InputIterator end, InputIterator *starts, size_t *lengths, const int num_parts, FunctorType &f, int oversampling=0)"
.br
.ti -1c
.RI "template<typename T > const T & \fBmax\fP (const T &a, const T &b)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > RandomAccessIterator \fBmedian_of_three_iterators\fP (RandomAccessIterator a, RandomAccessIterator b, RandomAccessIterator c, Comparator &comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator \fBmerge_advance\fP (RandomAccessIterator1 &begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator \fBmerge_advance_movc\fP (RandomAccessIterator1 &begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator \fBmerge_advance_usual\fP (RandomAccessIterator1 &begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)"
.br
.ti -1c
.RI "template<typename T > const T & \fBmin\fP (const T &a, const T &b)"
.br
.ti -1c
.RI "template<typename RanSeqs , typename RankType , typename RankIterator , typename Comparator > void \fBmultiseq_partition\fP (RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank, RankIterator begin_offsets, Comparator comp=\fBstd::less\fP< typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RanSeqs >::value_type::first_type >::value_type >())"
.br
.ti -1c
.RI "template<typename T , typename RanSeqs , typename RankType , typename Comparator > T \fBmultiseq_selection\fP (RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank, RankType &offset, Comparator comp=\fBstd::less\fP< T >())"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBdefault_parallel_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBparallel_tag\fP tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sampling_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::exact_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<template< typename RAI, typename C > class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBmultiway_merge_3_variant\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<template< typename RAI, typename C > class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBmultiway_merge_4_variant\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIteratorIterator , typename Comparator , typename difference_type > void \fBmultiway_merge_exact_splitting\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, difference_type length, difference_type total_length, Comparator comp, \fBstd::vector\fP< \fBstd::pair\fP< difference_type, difference_type > > *pieces)"
.br
.ti -1c
.RI "template<typename LT , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBmultiway_merge_loser_tree\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<typename UnguardedLoserTree , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBmultiway_merge_loser_tree_sentinel\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type &sentinel, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<typename LT , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBmultiway_merge_loser_tree_unguarded\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type &sentinel, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIteratorIterator , typename Comparator , typename difference_type > void \fBmultiway_merge_sampling_splitting\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, difference_type length, difference_type total_length, Comparator comp, \fBstd::vector\fP< \fBstd::pair\fP< difference_type, difference_type > > *pieces)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBdefault_parallel_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBparallel_tag\fP tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBsampling_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::exact_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBmultiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > bool \fBoperator<\fP (unguarded_iterator< RandomAccessIterator, Comparator > &bi1, unguarded_iterator< RandomAccessIterator, Comparator > &bi2)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > bool \fBoperator<\fP (\fBguarded_iterator\fP< RandomAccessIterator, Comparator > &bi1, \fBguarded_iterator\fP< RandomAccessIterator, Comparator > &bi2)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > bool \fBoperator<=\fP (unguarded_iterator< RandomAccessIterator, Comparator > &bi1, unguarded_iterator< RandomAccessIterator, Comparator > &bi2)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > bool \fBoperator<=\fP (\fBguarded_iterator\fP< RandomAccessIterator, Comparator > &bi1, \fBguarded_iterator\fP< RandomAccessIterator, Comparator > &bi2)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator3 , typename Comparator > RandomAccessIterator3 \fBparallel_merge_advance\fP (RandomAccessIterator1 &begin1, RandomAccessIterator1 end1, RandomAccessIterator1 &begin2, RandomAccessIterator1 end2, RandomAccessIterator3 target, typename \fBstd::iterator_traits\fP< RandomAccessIterator1 >::difference_type max_length, Comparator comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename RandomAccessIterator3 , typename Comparator > RandomAccessIterator3 \fBparallel_merge_advance\fP (RandomAccessIterator1 &begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &begin2, RandomAccessIterator2 end2, RandomAccessIterator3 target, typename \fBstd::iterator_traits\fP< RandomAccessIterator1 >::difference_type max_length, Comparator comp)"
.br
.ti -1c
.RI "template<bool stable, bool sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Splitter , typename Comparator > RandomAccessIterator3 \fBparallel_multiway_merge\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Splitter splitter, _DifferenceTp length, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBparallel_nth_element\fP (RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBparallel_partial_sort\fP (RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end, Comparator comp)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator \fBparallel_partial_sum\fP (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator \fBparallel_partial_sum_basecase\fP (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, typename \fBstd::iterator_traits\fP< InputIterator >::value_type value)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator \fBparallel_partial_sum_linear\fP (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, typename \fBstd::iterator_traits\fP< InputIterator >::difference_type n)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Predicate > \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type \fBparallel_partition\fP (RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename RandomNumberGenerator > void \fBparallel_random_shuffle\fP (RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator rng=\fBrandom_number\fP())"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename RandomNumberGenerator > void \fBparallel_random_shuffle_drs\fP (RandomAccessIterator begin, RandomAccessIterator end, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type n, \fBthread_index_t\fP num_threads, RandomNumberGenerator &rng)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename RandomNumberGenerator > void \fBparallel_random_shuffle_drs_pu\fP (\fBDRSSorterPU\fP< RandomAccessIterator, RandomNumberGenerator > *pus)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename Comparator > OutputIterator \fBparallel_set_difference\fP (InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename Comparator > OutputIterator \fBparallel_set_intersection\fP (InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename Operation > OutputIterator \fBparallel_set_operation\fP (InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Operation op)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename Comparator > OutputIterator \fBparallel_set_symmetric_difference\fP (InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)"
.br
.ti -1c
.RI "template<typename InputIterator , typename OutputIterator , typename Comparator > OutputIterator \fBparallel_set_union\fP (InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBparallel_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBdefault_parallel_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBbalanced_quicksort_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBquicksort_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBmultiway_mergesort_sampling_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBmultiway_mergesort_exact_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBmultiway_mergesort_tag\fP parallelism)"
.br
.ti -1c
.RI "template<bool stable, typename RandomAccessIterator , typename Comparator , typename Parallelism > void \fBparallel_sort\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, Parallelism parallelism)"
.br
.ti -1c
.RI "template<bool stable, bool exact, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort_mwms\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<bool stable, bool exact, typename RandomAccessIterator , typename Comparator > void \fBparallel_sort_mwms_pu\fP (\fBPMWMSSortingData\fP< RandomAccessIterator > *sd, Comparator &comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBparallel_sort_qs\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBparallel_sort_qs_conquer\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type \fBparallel_sort_qs_divide\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type pivot_rank, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type num_samples, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBparallel_sort_qsb\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename InputIterator , class OutputIterator > OutputIterator \fBparallel_unique_copy\fP (InputIterator first, InputIterator last, OutputIterator result)"
.br
.ti -1c
.RI "template<typename InputIterator , class OutputIterator , class BinaryPredicate > OutputIterator \fBparallel_unique_copy\fP (InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBqsb_conquer\fP (\fBQSBThreadLocal\fP< RandomAccessIterator > **tls, RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP iam, \fBthread_index_t\fP num_threads, bool parent_wait)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type \fBqsb_divide\fP (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, \fBthread_index_t\fP num_threads)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename Comparator > void \fBqsb_local_sort_with_helping\fP (\fBQSBThreadLocal\fP< RandomAccessIterator > **tls, Comparator &comp, int iam, bool wait)"
.br
.ti -1c
.RI "template<typename RandomNumberGenerator > int \fBrandom_number_pow2\fP (int logp, RandomNumberGenerator &rng)"
.br
.ti -1c
.RI "template<typename T > T \fBround_up_to_pow2\fP (T x)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator1 , typename _RandomAccessIterator2 , typename Pred > _RandomAccessIterator1 \fBsearch_template\fP (_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1, _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2, Pred pred)"
.br
.ti -1c
.RI "template<bool stable, bool sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 \fBsequential_multiway_merge\fP (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type &sentinel, _DifferenceTp length, Comparator comp)"
.br
.ti -1c
.RI "template<typename RandomAccessIterator , typename RandomNumberGenerator > void \fBsequential_random_shuffle\fP (RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator &rng)"
.br
.ti -1c
.RI "template<typename InputIterator > void \fBshrink\fP (\fBstd::vector\fP< InputIterator > &os_starts, size_t &count_to_two, size_t &range_length)"
.br
.ti -1c
.RI "template<typename InputIterator > void \fBshrink_and_double\fP (\fBstd::vector\fP< InputIterator > &os_starts, size_t &count_to_two, size_t &range_length, const bool make_twice)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBdefault_parallel_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBparallel_tag\fP tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBsampling_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::exact_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBdefault_parallel_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBparallel_tag\fP tag=\fBparallel_tag\fP(0))"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fBsampling_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::exact_tag\fP tag)"
.br
.ti -1c
.RI "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut \fBstable_multiway_merge_sentinels\fP (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)"
.br
.ti -1c
.RI "void \fByield\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static const int \fBlcas_t_bits\fP"
.br
.ti -1c
.RI "static const \fBlcas_t\fP \fBlcas_t_mask\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
GNU parallel code for public use. 
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef unsigned short \fB__gnu_parallel::bin_index\fP"
.PP
Type to hold the index of a bin. 
.PP
Since many variables of this type are allocated, it should be chosen as small as possible. 
.PP
Definition at line 47 of file random_shuffle.h.
.SS "typedef short \fB__gnu_parallel::int16\fP"
.PP
Integer Types. 
.PP
16-bit signed integer. 
.PP
Definition at line 114 of file types.h.
.SS "typedef int \fB__gnu_parallel::int32\fP"
.PP
32-bit signed integer. 
.PP
Definition at line 120 of file types.h.
.SS "typedef long long \fB__gnu_parallel::int64\fP"
.PP
64-bit signed integer. 
.PP
Definition at line 126 of file types.h.
.SS "typedef \fBint64\fP \fB__gnu_parallel::lcas_t\fP"
.PP
Longest compare-and-swappable integer type on this platform. 
.PP
Definition at line 145 of file types.h.
.SS "typedef \fBuint64\fP \fB__gnu_parallel::sequence_index_t\fP"
.PP
Unsigned integer to index elements. The total number of elements for each algorithm must fit into this type. 
.PP
Definition at line 135 of file types.h.
.SS "typedef \fBuint16\fP \fB__gnu_parallel::thread_index_t\fP"
.PP
Unsigned integer to index a thread number. The maximum thread number (for each processor) must fit into this type. 
.PP
Definition at line 141 of file types.h.
.SS "typedef unsigned short \fB__gnu_parallel::uint16\fP"
.PP
16-bit unsigned integer. 
.PP
Definition at line 117 of file types.h.
.SS "typedef unsigned int \fB__gnu_parallel::uint32\fP"
.PP
32-bit unsigned integer. 
.PP
Definition at line 123 of file types.h.
.SS "typedef unsigned long long \fB__gnu_parallel::uint64\fP"
.PP
64-bit unsigned integer. 
.PP
Definition at line 129 of file types.h.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fB__gnu_parallel::_AlgorithmStrategy\fP"
.PP
Strategies for run-time algorithm selection:. 
.PP
Definition at line 65 of file types.h.
.SS "enum \fB__gnu_parallel::_FindAlgorithm\fP"
.PP
Find algorithms:. 
.PP
Definition at line 104 of file types.h.
.SS "enum \fB__gnu_parallel::_MultiwayMergeAlgorithm\fP"
.PP
Merging algorithms:. 
.PP
Definition at line 83 of file types.h.
.SS "enum \fB__gnu_parallel::_Parallelism\fP"
.PP
Run-time equivalents for the compile-time tags. 
.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIsequential \fP\fP
Not parallel. 
.TP
\fB\fIparallel_unbalanced \fP\fP
Parallel unbalanced (equal-sized chunks). 
.TP
\fB\fIparallel_balanced \fP\fP
Parallel balanced (work-stealing). 
.TP
\fB\fIparallel_omp_loop \fP\fP
Parallel with OpenMP dynamic load-balancing. 
.TP
\fB\fIparallel_omp_loop_static \fP\fP
Parallel with OpenMP static load-balancing. 
.TP
\fB\fIparallel_taskqueue \fP\fP
Parallel with OpenMP taskqueue construct. 
.PP
Definition at line 42 of file types.h.
.SS "enum \fB__gnu_parallel::_PartialSumAlgorithm\fP"
.PP
Partial sum algorithms: recursive, linear. 
.PP
Definition at line 89 of file types.h.
.SS "enum \fB__gnu_parallel::_SortAlgorithm\fP"
.PP
Sorting algorithms:. 
.PP
Definition at line 74 of file types.h.
.SS "enum \fB__gnu_parallel::_SplittingAlgorithm\fP"
.PP
Sorting/merging algorithms: sampling, exact. 
.PP
Definition at line 96 of file types.h.
.SH "Function Documentation"
.PP 
.SS "template<typename Size > Size __gnu_parallel::__log2 (Size n)\fC [inline]\fP"
.PP
Calculates the rounded-down logarithm of \fCn\fP for base 2. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Argument. 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 0 for any argument <1. 
.RE
.PP

.PP
Definition at line 105 of file base.h.
.PP
Referenced by __gnu_parallel::LoserTreeBase< T, Comparator >::LoserTreeBase(), multiseq_partition(), multiseq_selection(), parallel_random_shuffle_drs(), round_up_to_pow2(), and sequential_random_shuffle().
.SS "template<typename RandomAccessIterator , typename _DifferenceTp > void __gnu_parallel::calc_borders (RandomAccessIterator elements, _DifferenceTp length, _DifferenceTp * off)\fC [inline]\fP"
.PP
Precalculate advances for Knuth-Morris-Pratt algorithm. 
.PP
\fBParameters:\fP
.RS 4
\fIelements\fP Begin iterator of sequence to search for. 
.br
\fIlength\fP Length of sequence to search for. 
.br
\fIadvances\fP Returned offsets. 
.RE
.PP

.PP
Definition at line 52 of file search.h.
.PP
Referenced by search_template().
.SS "template<typename T > bool __gnu_parallel::compare_and_swap (volatile T * ptr, T comparand, T replacement)\fC [inline]\fP"
.PP
Compare \fC*ptr\fP and \fCcomparand\fP. If equal, let \fC*ptr=replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to signed integer. 
.br
\fIcomparand\fP Compare value. 
.br
\fIreplacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 327 of file parallel/compatibility.h.
.PP
References compare_and_swap_32(), and compare_and_swap_64().
.PP
Referenced by __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_back(), and __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_front().
.SS "bool __gnu_parallel::compare_and_swap_32 (volatile int32 * ptr, int32 comparand, int32 replacement)\fC [inline]\fP"
.PP
Compare \fC*ptr\fP and \fCcomparand\fP. If equal, let \fC*ptr=replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to 32-bit signed integer. 
.br
\fIcomparand\fP Compare value. 
.br
\fIreplacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 235 of file parallel/compatibility.h.
.PP
Referenced by compare_and_swap().
.SS "bool __gnu_parallel::compare_and_swap_64 (volatile int64 * ptr, int64 comparand, int64 replacement)\fC [inline]\fP"
.PP
Compare \fC*ptr\fP and \fCcomparand\fP. If equal, let \fC*ptr=replacement\fP and return \fCtrue\fP, return \fCfalse\fP otherwise. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to 64-bit signed integer. 
.br
\fIcomparand\fP Compare value. 
.br
\fIreplacement\fP Replacement value. 
.RE
.PP

.PP
Definition at line 275 of file parallel/compatibility.h.
.PP
Referenced by compare_and_swap().
.SS "void __gnu_parallel::decode2 (lcas_t x, int & a, int & b)\fC [inline]\fP"
.PP
Decode two integers from one \fB__gnu_parallel::lcas_t\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP \fB__gnu_parallel::lcas_t\fP to decode integers from. 
.br
\fIa\fP First integer, to be decoded from the most-significant \fClcas_t_bits/2\fP bits of \fCx\fP. 
.br
\fIb\fP Second integer, to be encoded in the least-significant \fClcas_t_bits/2\fP bits of \fCx\fP. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBencode2\fP 
.RE
.PP

.PP
Definition at line 136 of file base.h.
.PP
References lcas_t_bits, and lcas_t_mask.
.PP
Referenced by __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_back(), __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_front(), and __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::push_front().
.SS "template<typename RandomAccessIterator , typename _DifferenceTp > void __gnu_parallel::determine_samples (PMWMSSortingData< RandomAccessIterator > * sd, _DifferenceTp num_samples)\fC [inline]\fP"
.PP
Select samples from a sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIsd\fP Pointer to algorithm data. Result will be placed in \fCsd->samples\fP. 
.br
\fInum_samples\fP Number of samples to select. 
.RE
.PP

.PP
Definition at line 98 of file multiway_mergesort.h.
.PP
References equally_split(), __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::samples, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::source, and __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::starts.
.SS "\fBlcas_t\fP __gnu_parallel::encode2 (int a, int b)\fC [inline]\fP"
.PP
Encode two integers into one \fB__gnu_parallel::lcas_t\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP First integer, to be encoded in the most-significant \fClcas_t_bits/2\fP bits. 
.br
\fIb\fP Second integer, to be encoded in the least-significant \fClcas_t_bits/2\fP bits. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fB__gnu_parallel::lcas_t\fP value encoding \fCa\fP and \fCb\fP. 
.RE
.PP
\fBSee also:\fP
.RS 4
\fBdecode2\fP 
.RE
.PP

.PP
Definition at line 122 of file base.h.
.PP
References lcas_t_bits.
.PP
Referenced by __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_back(), __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::pop_front(), __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::push_front(), and __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::RestrictedBoundedConcurrentQueue().
.SS "template<typename difference_type , typename OutputIterator > OutputIterator __gnu_parallel::equally_split (difference_type n, thread_index_t num_threads, OutputIterator s)\fC [inline]\fP"
.PP
Function to split a sequence into parts of almost equal size. 
.PP
The resulting sequence s of length num_threads+1 contains the splitting positions when splitting the range [0,n) into parts of almost equal size (\fBplus\fP minus 1). The first entry is 0, the last one n. There may result empty parts. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements 
.br
\fInum_threads\fP Number of parts 
.br
\fIs\fP Splitters 
.RE
.PP
\fBReturns:\fP
.RS 4
End of splitter sequence, i. e. \fCs+num_threads+1\fP 
.RE
.PP

.PP
Definition at line 48 of file equally_split.h.
.PP
Referenced by determine_samples(), multiway_merge_exact_splitting(), parallel_partial_sum_linear(), parallel_unique_copy(), and search_template().
.SS "template<typename difference_type > difference_type __gnu_parallel::equally_split_point (difference_type n, thread_index_t num_threads, thread_index_t thread_no)\fC [inline]\fP"
.PP
Function to split a sequence into parts of almost equal size. 
.PP
Returns the position of the splitting point between thread number thread_no (included) and thread number thread_no+1 (excluded). 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements 
.br
\fInum_threads\fP Number of parts 
.RE
.PP
\fBReturns:\fP
.RS 4
_SplittingAlgorithm point 
.RE
.PP

.PP
Definition at line 73 of file equally_split.h.
.PP
Referenced by for_each_template_random_access_ed().
.SS "template<typename T > T __gnu_parallel::fetch_and_add (volatile T * ptr, T addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a signed integer. 
.br
\fIaddend\fP Value to add. 
.RE
.PP

.PP
Definition at line 185 of file parallel/compatibility.h.
.PP
References fetch_and_add_32(), and fetch_and_add_64().
.PP
Referenced by __gnu_parallel::RestrictedBoundedConcurrentQueue< Piece >::push_front().
.SS "\fBint32\fP __gnu_parallel::fetch_and_add_32 (volatile int32 * ptr, int32 addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a 32-bit signed integer. 
.br
\fIaddend\fP Value to add. 
.RE
.PP

.PP
Definition at line 95 of file parallel/compatibility.h.
.PP
Referenced by fetch_and_add().
.SS "\fBint64\fP __gnu_parallel::fetch_and_add_64 (volatile int64 * ptr, int64 addend)\fC [inline]\fP"
.PP
Add a value to a variable, atomically. 
.PP
Implementation is heavily platform-dependent. 
.PP
\fBParameters:\fP
.RS 4
\fIptr\fP Pointer to a 64-bit signed integer. 
.br
\fIaddend\fP Value to add. 
.RE
.PP

.PP
Definition at line 134 of file parallel/compatibility.h.
.PP
Referenced by fetch_and_add().
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename Pred , typename Selector > \fBstd::pair\fP<RandomAccessIterator1, RandomAccessIterator2> __gnu_parallel::find_template (RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred, Selector selector)\fC [inline]\fP"
.PP
Parallel std::find, switch for different algorithms. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. Must have same length as first sequence. 
.br
\fIpred\fP Find predicate. 
.br
\fIselector\fP Functionality (e. g. std::find_if (), std::equal(),...) 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in both sequences. 
.RE
.PP

.PP
Definition at line 60 of file find.h.
.PP
References __gnu_parallel::_Settings::get().
.SS "template<typename InputIterator , typename UserOp , typename Functionality , typename Red , typename Result > UserOp __gnu_parallel::for_each_template_random_access (InputIterator begin, InputIterator end, UserOp user_op, Functionality & functionality, Red reduction, Result reduction_start, Result & output, typename \fBstd::iterator_traits\fP< InputIterator >::difference_type bound, _Parallelism parallelism_tag)\fC [inline]\fP"
.PP
Chose the desired algorithm by evaluating \fCparallelism_tag\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIuser_op\fP A user-specified functor (comparator, predicate, associative operator,...) 
.br
\fIfunctionality\fP functor to 'process' an element with user_op (depends on desired functionality, e. g. accumulate, for_each,... 
.br
\fIreduction\fP Reduction functor. 
.br
\fIreduction_start\fP Initial value for reduction. 
.br
\fIoutput\fP Output iterator. 
.br
\fIbound\fP Maximum number of elements processed. 
.br
\fIparallelism_tag\fP Parallelization method 
.RE
.PP

.PP
Definition at line 61 of file for_each.h.
.PP
References for_each_template_random_access_ed(), for_each_template_random_access_omp_loop(), for_each_template_random_access_workstealing(), parallel_omp_loop, parallel_omp_loop_static, and parallel_unbalanced.
.SS "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op __gnu_parallel::for_each_template_random_access_ed (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu & f, Red r, Result base, Result & output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)\fC [inline]\fP"
.PP
Embarrassingly parallel algorithm for random access iterators, using hand-crafted parallelization by equal splitting the work. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of element sequence. 
.br
\fIend\fP End iterator of element sequence. 
.br
\fIo\fP User-supplied functor (comparator, predicate, adding functor, ...) 
.br
\fIf\fP Functor to 'process' an element with op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fIr\fP Functor to 'add' a single result to the already processed elements (depends on functionality). 
.br
\fIbase\fP Base value for reduction. 
.br
\fIoutput\fP Pointer to position where final result is written to 
.br
\fIbound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 68 of file par_loop.h.
.PP
References equally_split_point().
.PP
Referenced by for_each_template_random_access().
.SS "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op __gnu_parallel::for_each_template_random_access_omp_loop (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu & f, Red r, Result base, Result & output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)\fC [inline]\fP"
.PP
Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of element sequence. 
.br
\fIend\fP End iterator of element sequence. 
.br
\fIo\fP User-supplied functor (comparator, predicate, adding functor, etc.). 
.br
\fIf\fP Functor to 'process' an element with op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fIr\fP Functor to 'add' a single result to the already processed elements (depends on functionality). 
.br
\fIbase\fP Base value for reduction. 
.br
\fIoutput\fP Pointer to position where final result is written to 
.br
\fIbound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 67 of file omp_loop.h.
.PP
Referenced by for_each_template_random_access().
.SS "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op __gnu_parallel::for_each_template_random_access_omp_loop_static (RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu & f, Red r, Result base, Result & output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)\fC [inline]\fP"
.PP
Embarrassingly parallel algorithm for random access iterators, using an OpenMP for loop with static scheduling. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of element sequence. 
.br
\fIend\fP End iterator of element sequence. 
.br
\fIo\fP User-supplied functor (comparator, predicate, adding functor, ...). 
.br
\fIf\fP Functor to 'process' an element with op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fIr\fP Functor to 'add' a single result to the already processed elements (depends on functionality). 
.br
\fIbase\fP Base value for reduction. 
.br
\fIoutput\fP Pointer to position where final result is written to 
.br
\fIbound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 67 of file omp_loop_static.h.
.SS "template<typename RandomAccessIterator , typename Op , typename Fu , typename Red , typename Result > Op __gnu_parallel::for_each_template_random_access_workstealing (RandomAccessIterator begin, RandomAccessIterator end, Op op, Fu & f, Red r, Result base, Result & output, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type bound)\fC [inline]\fP"
.PP
Work stealing algorithm for random access iterators. 
.PP
Uses O(1) additional memory. Synchronization at job lists is done with atomic operations. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of element sequence. 
.br
\fIend\fP End iterator of element sequence. 
.br
\fIop\fP User-supplied functor (comparator, predicate, adding functor, ...). 
.br
\fIf\fP Functor to 'process' an element with op (depends on desired functionality, e. g. for std::for_each(), ...). 
.br
\fIr\fP Functor to 'add' a single result to the already processed elements (depends on functionality). 
.br
\fIbase\fP Base value for reduction. 
.br
\fIoutput\fP Pointer to position where final result is written to 
.br
\fIbound\fP Maximum number of elements processed (e. g. for std::count_n()). 
.RE
.PP
\fBReturns:\fP
.RS 4
User-supplied functor (that may contain a part of the result). 
.RE
.PP

.PP
Definition at line 99 of file workstealing.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::cache_line_size, __gnu_parallel::Job< _DifferenceTp >::first, __gnu_parallel::_Settings::get(), __gnu_parallel::Job< _DifferenceTp >::last, __gnu_parallel::Job< _DifferenceTp >::load, min(), __gnu_parallel::_Settings::workstealing_chunk_size, and yield().
.PP
Referenced by for_each_template_random_access().
.SS "template<typename InputIterator , typename Comparator > bool __gnu_parallel::is_sorted (InputIterator begin, InputIterator end, Comparator comp = \fC\fBstd::less\fP<typename \fBstd::iterator_traits\fP<InputIterator>:: value_type>()\fP)\fC [inline]\fP"
.PP
Check whether \fC\fP[begin, \fCend\fP) is sorted according to \fCcomp\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if sorted, \fCfalse\fP otherwise. 
.RE
.PP

.PP
Definition at line 51 of file checkers.h.
.PP
Referenced by multiway_merge_loser_tree_sentinel(), parallel_multiway_merge(), and sequential_multiway_merge().
.SS "template<typename InputIterator , typename Comparator > bool __gnu_parallel::is_sorted_failure (InputIterator begin, InputIterator end, InputIterator & first_failure, Comparator comp = \fC\fBstd::less\fP<typename \fBstd::iterator_traits\fP<InputIterator>:: value_type>()\fP)\fC [inline]\fP"
.PP
Check whether \fC\fP[begin, \fCend\fP) is sorted according to \fCcomp\fP. Prints the position in case an unordered pair is found. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIfirst_failure\fP The first failure is returned in this variable. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if sorted, \fCfalse\fP otherwise. 
.RE
.PP

.PP
Definition at line 89 of file checkers.h.
.SS "template<typename InputIterator , typename Comparator > bool __gnu_parallel::is_sorted_print_failures (InputIterator begin, InputIterator end, Comparator comp = \fC\fBstd::less\fP<typename \fBstd::iterator_traits\fP <InputIterator>::value_type>()\fP)\fC [inline]\fP"
.PP
Check whether \fC\fP[begin, \fCend\fP) is sorted according to \fCcomp\fP. Prints all unordered pair, including the surrounding two elements. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCtrue\fP if sorted, \fCfalse\fP otherwise. 
.RE
.PP

.PP
Definition at line 129 of file checkers.h.
.SS "template<typename InputIterator , typename FunctorType > size_t __gnu_parallel::list_partition (const InputIterator begin, const InputIterator end, InputIterator * starts, size_t * lengths, const int num_parts, FunctorType & f, int oversampling = \fC0\fP)\fC [inline]\fP"
.PP
Splits a sequence given by input iterators into parts of almost equal size. 
.PP
The function needs only one pass over the sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIstarts\fP Start iterators for the resulting parts, dimension \fCnum_parts+1\fP. For convenience, \fCstarts\fP \fC\fP[num_parts] contains the end iterator of the sequence. 
.br
\fIlengths\fP Length of the resulting parts. 
.br
\fInum_parts\fP Number of parts to split the sequence into. 
.br
\fIf\fP Functor to be applied to each element by traversing it 
.br
\fIoversampling\fP Oversampling factor. If 0, then the partitions will differ in at most $ \sqrt{\mathrm{end} - \mathrm{begin}} $ elements. Otherwise, the ratio between the longest and the shortest part is bounded by $ 1/(\mathrm{oversampling} \cdot \mathrm{num\_parts}) $. 
.RE
.PP
\fBReturns:\fP
.RS 4
Length of the whole sequence. 
.RE
.PP

.PP
Definition at line 100 of file list_partition.h.
.PP
References shrink_and_double(), and std::vector< _Tp, _Alloc >::size().
.SS "template<typename T > const T& __gnu_parallel::max (const T & a, const T & b)\fC [inline]\fP"
.PP
Equivalent to \fBstd::max\fP. 
.PP
Definition at line 151 of file base.h.
.PP
Referenced by std::_Deque_base< _Tp, _Alloc >::_M_initialize_map(), multiseq_partition(), and multiseq_selection().
.SS "template<typename RandomAccessIterator , typename Comparator > RandomAccessIterator __gnu_parallel::median_of_three_iterators (RandomAccessIterator a, RandomAccessIterator b, RandomAccessIterator c, Comparator & comp)\fC [inline]\fP"
.PP
Compute the median of three referenced elements, according to \fCcomp\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP First iterator. 
.br
\fIb\fP Second iterator. 
.br
\fIc\fP Third iterator. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 443 of file base.h.
.PP
Referenced by qsb_divide().
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator __gnu_parallel::merge_advance (RandomAccessIterator1 & begin1, RandomAccessIterator1 end1, RandomAccessIterator2 & begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\fC [inline]\fP"
.PP
Merge routine being able to merge only the \fCmax_length\fP smallest elements. 
.PP
The \fCbegin\fP iterators are advanced accordingly, they might not reach \fCend\fP, in contrast to the usual variant. Static switch on whether to use the conditional-move variant. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fItarget\fP Target begin iterator. 
.br
\fImax_length\fP Maximum number of elements to merge. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 174 of file merge.h.
.PP
References _GLIBCXX_CALL, and merge_advance_movc().
.PP
Referenced by parallel_merge_advance(), and sequential_multiway_merge().
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator __gnu_parallel::merge_advance_movc (RandomAccessIterator1 & begin1, RandomAccessIterator1 end1, RandomAccessIterator2 & begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\fC [inline]\fP"
.PP
Merge routine being able to merge only the \fCmax_length\fP smallest elements. 
.PP
The \fCbegin\fP iterators are advanced accordingly, they might not reach \fCend\fP, in contrast to the usual variant. Specially designed code should allow the compiler to generate conditional moves instead of branches. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fItarget\fP Target begin iterator. 
.br
\fImax_length\fP Maximum number of elements to merge. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 106 of file merge.h.
.PP
Referenced by merge_advance().
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename _DifferenceTp , typename Comparator > OutputIterator __gnu_parallel::merge_advance_usual (RandomAccessIterator1 & begin1, RandomAccessIterator1 end1, RandomAccessIterator2 & begin2, RandomAccessIterator2 end2, OutputIterator target, _DifferenceTp max_length, Comparator comp)\fC [inline]\fP"
.PP
Merge routine being able to merge only the \fCmax_length\fP smallest elements. 
.PP
The \fCbegin\fP iterators are advanced accordingly, they might not reach \fCend\fP, in contrast to the usual variant. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fItarget\fP Target begin iterator. 
.br
\fImax_length\fP Maximum number of elements to merge. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 57 of file merge.h.
.SS "template<typename T > const T& __gnu_parallel::min (const T & a, const T & b)\fC [inline]\fP"
.PP
Equivalent to \fBstd::min\fP. 
.PP
Definition at line 145 of file base.h.
.PP
Referenced by __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::compare(), for_each_template_random_access_workstealing(), multiseq_partition(), multiseq_selection(), parallel_sort_qs_divide(), __gnu_cxx::random_sample_n(), __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::rfind(), search_template(), and std::basic_filebuf< _CharT, _Traits >::xsputn().
.SS "template<typename RanSeqs , typename RankType , typename RankIterator , typename Comparator > void __gnu_parallel::multiseq_partition (RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank, RankIterator begin_offsets, Comparator comp = \fC\fBstd::less\fP< typename \fBstd::iterator_traits\fP<typename \fBstd::iterator_traits\fP<RanSeqs>::value_type:: first_type>::value_type>()\fP)\fC [inline]\fP"
.PP
Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence. The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. If there are several equal elements across the split, the ones on the left side will be chosen from sequences with smaller number. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin_seqs\fP Begin of the sequence of iterator pairs. 
.br
\fIend_seqs\fP End of the sequence of iterator pairs. 
.br
\fIrank\fP The global rank to partition at. 
.br
\fIbegin_offsets\fP A random-access sequence begin where the result will be stored in. Each element of the sequence is an iterator that points to the first element on the greater part of the respective sequence. 
.br
\fIcomp\fP The ordering functor, defaults to std::less<T>. 
.RE
.PP

.PP
Definition at line 123 of file multiseq_selection.h.
.PP
References __log2(), _GLIBCXX_CALL, std::vector< _Tp, _Alloc >::begin(), std::distance(), std::priority_queue< _Tp, _Sequence, _Compare >::empty(), std::vector< _Tp, _Alloc >::end(), max(), min(), std::priority_queue< _Tp, _Sequence, _Compare >::pop(), std::priority_queue< _Tp, _Sequence, _Compare >::push(), std::vector< _Tp, _Alloc >::push_back(), and std::priority_queue< _Tp, _Sequence, _Compare >::top().
.PP
Referenced by multiway_merge_exact_splitting().
.SS "template<typename T , typename RanSeqs , typename RankType , typename Comparator > T __gnu_parallel::multiseq_selection (RanSeqs begin_seqs, RanSeqs end_seqs, RankType rank, RankType & offset, Comparator comp = \fC\fBstd::less\fP<T>()\fP)\fC [inline]\fP"
.PP
Selects the element at a certain global rank from several sorted sequences. 
.PP
The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin_seqs\fP Begin of the sequence of iterator pairs. 
.br
\fIend_seqs\fP End of the sequence of iterator pairs. 
.br
\fIrank\fP The global rank to partition at. 
.br
\fIoffset\fP The rank of the selected element in the global subsequence of elements equal to the selected element. If the selected element is unique, this number is 0. 
.br
\fIcomp\fP The ordering functor, defaults to \fBstd::less\fP. 
.RE
.PP

.PP
Definition at line 384 of file multiseq_selection.h.
.PP
References __log2(), _GLIBCXX_CALL, std::vector< _Tp, _Alloc >::begin(), std::distance(), std::priority_queue< _Tp, _Sequence, _Compare >::empty(), std::vector< _Tp, _Alloc >::end(), std::lower_bound(), max(), min(), std::priority_queue< _Tp, _Sequence, _Compare >::pop(), std::priority_queue< _Tp, _Sequence, _Compare >::push(), std::vector< _Tp, _Alloc >::push_back(), and std::priority_queue< _Tp, _Sequence, _Compare >::top().
.SS "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut __gnu_parallel::multiway_merge (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)\fC [inline]\fP"
.PP
Multiway Merge Frontend. 
.PP
Merge the sequences specified by seqs_begin and seqs_end into target. seqs_begin and seqs_end must point to a sequence of pairs. These pairs must contain an iterator to the beginning of a sequence in their first entry and an iterator the end of the same sequence in their second entry.
.PP
Ties are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence number but is slower.
.PP
The first entries of the pairs (i.e. the begin iterators) will be moved forward.
.PP
The output sequence has to provide enough space for all elements that are written to it.
.PP
This function will merge the input sequences:
.PP
.IP "\(bu" 2
not stable
.IP "\(bu" 2
parallel, depending on the input size and Settings
.IP "\(bu" 2
using sampling for splitting
.IP "\(bu" 2
not using sentinels
.PP
.PP
Example:
.PP
.PP
.nf

   int sequences[10][10];
   for (int i = 0; i < 10; ++i)
     for (int j = 0; i < 10; ++j)
       sequences[i][j] = j;
.fi
.PP
.PP
.PP
.nf
   int out[33];
   \fBstd::vector\fP<std::pair<int*> > seqs;
   for (int i = 0; i < 10; ++i)
     { seqs.push(std::make_pair<int*>(sequences[i], sequences[i] + 10)) }
.fi
.PP
.PP
.PP
.nf
   multiway_merge(seqs.begin(), seqs.end(), target, std::less<int>(), 33);
 
.fi
.PP
.PP
\fBSee also:\fP
.RS 4
stable_multiway_merge
.RE
.PP
\fBPrecondition:\fP
.RS 4
All input sequences must be sorted. 
.PP
Target must provide enough space to merge out length elements or the number of elements in all sequences, whichever is smaller.
.RE
.PP
\fBPostcondition:\fP
.RS 4
[target, return value) contains merged elements from the input sequences. 
.PP
return value - target = min(length, number of elements in all sequences).
.RE
.PP
\fBParameters:\fP
.RS 4
\fIRandomAccessIteratorPairIterator\fP iterator over sequence of pairs of iterators 
.br
\fIRandomAccessIteratorOut\fP iterator over target sequence 
.br
\fI_DifferenceTp\fP difference type for the sequence 
.br
\fIComparator\fP strict weak ordering type to compare elements in sequences
.br
\fIseqs_begin\fP begin of sequence sequence 
.br
\fIseqs_end\fP end of sequence sequence 
.br
\fItarget\fP target sequence to merge to. 
.br
\fIcomp\fP strict weak ordering to use for element comparison. 
.br
\fIlength\fP Maximum length to merge, possibly larger than the number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
end iterator of output sequence 
.RE
.PP

.PP
Definition at line 1482 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, and sequential_multiway_merge().
.SS "template<template< typename RAI, typename C > class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::multiway_merge_3_variant (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Highly efficient 3-way merging procedure. 
.PP
Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging out an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into labels in C++).
.PP
This works well for merging up to 4 sequences.
.PP
Note that making the merging stable does \fInot\fP come at a performance hit.
.PP
Whether the merging is done guarded or unguarded is selected by the used iterator class.
.PP
\fBParameters:\fP
.RS 4
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, \fBless\fP equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 290 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.SS "template<template< typename RAI, typename C > class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::multiway_merge_4_variant (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Highly efficient 4-way merging procedure. 
.PP
Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging out an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into goto labels in C++).
.PP
This works well for merging up to 4 sequences.
.PP
Note that making the merging stable does \fInot\fP come at a performance hit.
.PP
Whether the merging is done guarded or unguarded is selected by the used iterator class.
.PP
\fBParameters:\fP
.RS 4
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, \fBless\fP equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 410 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.SS "template<bool stable, typename RandomAccessIteratorIterator , typename Comparator , typename difference_type > void __gnu_parallel::multiway_merge_exact_splitting (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, difference_type length, difference_type total_length, Comparator comp, \fBstd::vector\fP< \fBstd::pair\fP< difference_type, difference_type > > * pieces)\fC [inline]\fP"
.PP
Exact splitting for parallel multiway-merge routine. 
.PP
None of the passed sequences may be empty. 
.PP
Definition at line 1181 of file multiway_merge.h.
.PP
References _GLIBCXX_PARALLEL_LENGTH, std::vector< _Tp, _Alloc >::begin(), equally_split(), multiseq_partition(), and std::vector< _Tp, _Alloc >::resize().
.PP
Referenced by parallel_merge_advance().
.SS "template<typename LT , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::multiway_merge_loser_tree (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Multi-way merging procedure for a high branching factor, guarded case. 
.PP
This merging variant uses a \fBLoserTree\fP class as selected by \fCLT\fP.
.PP
Stability is selected through the used \fBLoserTree\fP class \fCLT\fP.
.PP
At least one non-empty sequence is required.
.PP
\fBParameters:\fP
.RS 4
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, \fBless\fP equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 534 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, and _GLIBCXX_PARALLEL_LENGTH.
.SS "template<typename UnguardedLoserTree , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::multiway_merge_loser_tree_sentinel (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type & sentinel, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Multi-way merging procedure for a high branching factor, requiring sentinels to exist. 
.PP
\fBParameters:\fP
.RS 4
\fIstable\fP The value must the same as for the used LoserTrees. 
.br
\fIUnguardedLoserTree\fP Loser Tree variant to use for the unguarded merging. 
.br
\fIGuardedLoserTree\fP Loser Tree variant to use for the guarded merging.
.br
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, \fBless\fP equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 705 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, is_sorted(), and multiway_merge_loser_tree_unguarded().
.SS "template<typename LT , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::multiway_merge_loser_tree_unguarded (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type & sentinel, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Multi-way merging procedure for a high branching factor, unguarded case. 
.PP
Merging is done using the \fBLoserTree\fP class \fCLT\fP.
.PP
Stability is selected by the used LoserTrees.
.PP
\fBPrecondition:\fP
.RS 4
No input will run out of elements during the merge.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, \fBless\fP equal than the total number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 615 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL.
.PP
Referenced by multiway_merge_loser_tree_sentinel().
.SS "template<bool stable, typename RandomAccessIteratorIterator , typename Comparator , typename difference_type > void __gnu_parallel::multiway_merge_sampling_splitting (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, difference_type length, difference_type total_length, Comparator comp, \fBstd::vector\fP< \fBstd::pair\fP< difference_type, difference_type > > * pieces)\fC [inline]\fP"
.PP
Sampling based splitting for parallel multiway-merge routine. 
.PP
Definition at line 1100 of file multiway_merge.h.
.PP
References _GLIBCXX_PARALLEL_LENGTH, __gnu_parallel::_Settings::get(), __gnu_parallel::_Settings::merge_oversampling, and std::upper_bound().
.SS "template<typename RandomAccessIteratorPairIterator , typename RandomAccessIteratorOut , typename _DifferenceTp , typename Comparator > RandomAccessIteratorOut __gnu_parallel::multiway_merge_sentinels (RandomAccessIteratorPairIterator seqs_begin, RandomAccessIteratorPairIterator seqs_end, RandomAccessIteratorOut target, _DifferenceTp length, Comparator comp, \fB__gnu_parallel::sequential_tag\fP)\fC [inline]\fP"
.PP
Multiway Merge Frontend. 
.PP
Merge the sequences specified by seqs_begin and seqs_end into target. seqs_begin and seqs_end must point to a sequence of pairs. These pairs must contain an iterator to the beginning of a sequence in their first entry and an iterator the end of the same sequence in their second entry.
.PP
Ties are broken arbitrarily. See stable_multiway_merge for a variant that breaks ties by sequence number but is slower.
.PP
The first entries of the pairs (i.e. the begin iterators) will be moved forward accordingly.
.PP
The output sequence has to provide enough space for all elements that are written to it.
.PP
This function will merge the input sequences:
.PP
.IP "\(bu" 2
not stable
.IP "\(bu" 2
parallel, depending on the input size and Settings
.IP "\(bu" 2
using sampling for splitting
.IP "\(bu" 2
using sentinels
.PP
.PP
You have to take care that the element the end iterator points to is readable and contains a value that is greater than any other non-sentinel value in all sequences.
.PP
Example:
.PP
.PP
.nf

   int sequences[10][11];
   for (int i = 0; i < 10; ++i)
     for (int j = 0; i < 11; ++j)
       sequences[i][j] = j; // last one is sentinel!
.fi
.PP
.PP
.PP
.nf
   int out[33];
   \fBstd::vector\fP<std::pair<int*> > seqs;
   for (int i = 0; i < 10; ++i)
     { seqs.push(std::make_pair<int*>(sequences[i], sequences[i] + 10)) }
.fi
.PP
.PP
.PP
.nf
   multiway_merge(seqs.begin(), seqs.end(), target, std::less<int>(), 33);
 
.fi
.PP
.PP
\fBPrecondition:\fP
.RS 4
All input sequences must be sorted. 
.PP
Target must provide enough space to merge out length elements or the number of elements in all sequences, whichever is smaller. 
.PP
For each \fCi\fP, \fCseqs_begin\fP[i].second must be the end marker of the sequence, but also reference the one more sentinel element.
.RE
.PP
\fBPostcondition:\fP
.RS 4
[target, return value) contains merged elements from the input sequences. 
.PP
return value - target = min(length, number of elements in all sequences).
.RE
.PP
\fBSee also:\fP
.RS 4
stable_multiway_merge_sentinels
.RE
.PP
\fBParameters:\fP
.RS 4
\fIRandomAccessIteratorPairIterator\fP iterator over sequence of pairs of iterators 
.br
\fIRandomAccessIteratorOut\fP iterator over target sequence 
.br
\fI_DifferenceTp\fP difference type for the sequence 
.br
\fIComparator\fP strict weak ordering type to compare elements in sequences
.br
\fIseqs_begin\fP begin of sequence sequence 
.br
\fIseqs_end\fP end of sequence sequence 
.br
\fItarget\fP target sequence to merge to. 
.br
\fIcomp\fP strict weak ordering to use for element comparison. 
.br
\fIlength\fP Maximum length to merge, possibly larger than the number of elements available.
.RE
.PP
\fBReturns:\fP
.RS 4
end iterator of output sequence 
.RE
.PP

.PP
Definition at line 1854 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, and sequential_multiway_merge().
.SS "template<typename RandomAccessIterator , typename Comparator > bool __gnu_parallel::operator< (unguarded_iterator< RandomAccessIterator, Comparator > & bi1, unguarded_iterator< RandomAccessIterator, Comparator > & bi2)\fC [inline]\fP"
.PP
Compare two elements referenced by unguarded iterators. 
.PP
\fBParameters:\fP
.RS 4
\fIbi1\fP First iterator. 
.br
\fIbi2\fP Second iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCTrue\fP if \fBless\fP. 
.RE
.PP

.PP
Definition at line 239 of file multiway_merge.h.
.SS "template<typename RandomAccessIterator , typename Comparator > bool __gnu_parallel::operator< (guarded_iterator< RandomAccessIterator, Comparator > & bi1, guarded_iterator< RandomAccessIterator, Comparator > & bi2)\fC [inline]\fP"
.PP
Compare two elements referenced by guarded iterators. 
.PP
\fBParameters:\fP
.RS 4
\fIbi1\fP First iterator. 
.br
\fIbi2\fP Second iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCTrue\fP if \fBless\fP. 
.RE
.PP

.PP
Definition at line 144 of file multiway_merge.h.
.SS "template<typename RandomAccessIterator , typename Comparator > bool __gnu_parallel::operator<= (unguarded_iterator< RandomAccessIterator, Comparator > & bi1, unguarded_iterator< RandomAccessIterator, Comparator > & bi2)\fC [inline]\fP"
.PP
Compare two elements referenced by unguarded iterators. 
.PP
\fBParameters:\fP
.RS 4
\fIbi1\fP First iterator. 
.br
\fIbi2\fP Second iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCTrue\fP if \fBless\fP equal. 
.RE
.PP

.PP
Definition at line 252 of file multiway_merge.h.
.SS "template<typename RandomAccessIterator , typename Comparator > bool __gnu_parallel::operator<= (guarded_iterator< RandomAccessIterator, Comparator > & bi1, guarded_iterator< RandomAccessIterator, Comparator > & bi2)\fC [inline]\fP"
.PP
Compare two elements referenced by guarded iterators. 
.PP
\fBParameters:\fP
.RS 4
\fIbi1\fP First iterator. 
.br
\fIbi2\fP Second iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCTrue\fP if \fBless\fP equal. 
.RE
.PP

.PP
Definition at line 160 of file multiway_merge.h.
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator3 , typename Comparator > RandomAccessIterator3 __gnu_parallel::parallel_merge_advance (RandomAccessIterator1 & begin1, RandomAccessIterator1 end1, RandomAccessIterator1 & begin2, RandomAccessIterator1 end2, RandomAccessIterator3 target, typename \fBstd::iterator_traits\fP< RandomAccessIterator1 >::difference_type max_length, Comparator comp)\fC [inline]\fP"
.PP
Parallel merge routine being able to merge only the \fCmax_length\fP smallest elements. 
.PP
The \fCbegin\fP iterators are advanced accordingly, they might not reach \fCend\fP, in contrast to the usual variant. The functionality is projected onto parallel_multiway_merge. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fItarget\fP Target begin iterator. 
.br
\fImax_length\fP Maximum number of elements to merge. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 228 of file merge.h.
.PP
References multiway_merge_exact_splitting(), and parallel_multiway_merge().
.SS "template<typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename RandomAccessIterator3 , typename Comparator > RandomAccessIterator3 __gnu_parallel::parallel_merge_advance (RandomAccessIterator1 & begin1, RandomAccessIterator1 end1, RandomAccessIterator2 & begin2, RandomAccessIterator2 end2, RandomAccessIterator3 target, typename \fBstd::iterator_traits\fP< RandomAccessIterator1 >::difference_type max_length, Comparator comp)\fC [inline]\fP"
.PP
Merge routine fallback to sequential in case the iterators of the two input sequences are of different type. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fItarget\fP Target begin iterator. 
.br
\fImax_length\fP Maximum number of elements to merge. 
.br
\fIcomp\fP Comparator. 
.RE
.PP
\fBReturns:\fP
.RS 4
Output end iterator. 
.RE
.PP

.PP
Definition at line 198 of file merge.h.
.PP
References merge_advance().
.SS "template<bool stable, bool sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Splitter , typename Comparator > RandomAccessIterator3 __gnu_parallel::parallel_multiway_merge (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Splitter splitter, _DifferenceTp length, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
Parallel multi-way merge routine. 
.PP
The _GLIBCXX_PARALLEL_DECISION is based on the branching factor and runtime settings.
.PP
Must not be called if the number of sequences is 1.
.PP
\fBParameters:\fP
.RS 4
\fISplitter\fP functor to split input (either exact or sampling based)
.br
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, possibly larger than the number of elements available. 
.br
\fIstable\fP Stable merging incurs a performance penalty. 
.br
\fIsentinel\fP Ignored. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 1286 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, _GLIBCXX_PARALLEL_LENGTH, __gnu_parallel::_Settings::get(), is_sorted(), and __gnu_parallel::_Settings::merge_oversampling.
.PP
Referenced by parallel_merge_advance().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_nth_element (RandomAccessIterator begin, RandomAccessIterator nth, RandomAccessIterator end, Comparator comp)\fC [inline]\fP"
.PP
Parallel implementation of std::nth_element(). 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fInth\fP Iterator of element that must be in position afterwards. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 330 of file partition.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), parallel_partition(), and __gnu_parallel::_Settings::partition_minimal_n.
.PP
Referenced by parallel_partial_sort().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_partial_sort (RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end, Comparator comp)\fC [inline]\fP"
.PP
Parallel implementation of std::partial_sort(). 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fImiddle\fP Sort until this position. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 417 of file partition.h.
.PP
References parallel_nth_element().
.SS "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator __gnu_parallel::parallel_partial_sum (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op)\fC [inline]\fP"
.PP
Parallel partial sum front-end. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIresult\fP Begin iterator of output sequence. 
.br
\fIbin_op\fP Associative binary function. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 196 of file partial_sum.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), and parallel_partial_sum_linear().
.SS "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator __gnu_parallel::parallel_partial_sum_basecase (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, typename \fBstd::iterator_traits\fP< InputIterator >::value_type value)\fC [inline]\fP"
.PP
Base case prefix sum routine. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIresult\fP Begin iterator of output sequence. 
.br
\fIbin_op\fP Associative binary function. 
.br
\fIvalue\fP Start value. Must be passed since the neutral element is unknown in general. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 58 of file partial_sum.h.
.PP
Referenced by parallel_partial_sum_linear().
.SS "template<typename InputIterator , typename OutputIterator , typename BinaryOperation > OutputIterator __gnu_parallel::parallel_partial_sum_linear (InputIterator begin, InputIterator end, OutputIterator result, BinaryOperation bin_op, typename \fBstd::iterator_traits\fP< InputIterator >::difference_type n)\fC [inline]\fP"
.PP
Parallel partial sum implementation, two-phase approach, no recursion. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIresult\fP Begin iterator of output sequence. 
.br
\fIbin_op\fP Associative binary function. 
.br
\fIn\fP Length of sequence. 
.br
\fInum_threads\fP Number of threads to use. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 90 of file partial_sum.h.
.PP
References std::accumulate(), equally_split(), __gnu_parallel::_Settings::get(), parallel_partial_sum_basecase(), and __gnu_parallel::_Settings::partial_sum_dilation.
.PP
Referenced by parallel_partial_sum().
.SS "template<typename RandomAccessIterator , typename Predicate > \fBstd::iterator_traits\fP<RandomAccessIterator>::difference_type __gnu_parallel::parallel_partition (RandomAccessIterator begin, RandomAccessIterator end, Predicate pred, thread_index_t num_threads)\fC [inline]\fP"
.PP
Parallel implementation of std::partition. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence to split. 
.br
\fIend\fP End iterator of input sequence to split. 
.br
\fIpred\fP Partition predicate, possibly including some kind of pivot. 
.br
\fInum_threads\fP Maximum number of threads to use for this task. 
.RE
.PP
\fBReturns:\fP
.RS 4
Number of elements not fulfilling the predicate. 
.RE
.PP

.PP
Definition at line 55 of file partition.h.
.PP
References _GLIBCXX_CALL, _GLIBCXX_VOLATILE, __gnu_parallel::_Settings::get(), std::left(), __gnu_parallel::_Settings::partition_chunk_share, __gnu_parallel::_Settings::partition_chunk_size, std::right(), and std::swap_ranges().
.PP
Referenced by parallel_nth_element(), parallel_sort_qs_divide(), and qsb_divide().
.SS "template<typename RandomAccessIterator , typename RandomNumberGenerator > void __gnu_parallel::parallel_random_shuffle (RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator rng = \fCrandom_number()\fP)\fC [inline]\fP"
.PP
Parallel random public call. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIrng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 507 of file random_shuffle.h.
.PP
References parallel_random_shuffle_drs().
.SS "template<typename RandomAccessIterator , typename RandomNumberGenerator > void __gnu_parallel::parallel_random_shuffle_drs (RandomAccessIterator begin, RandomAccessIterator end, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type n, thread_index_t num_threads, RandomNumberGenerator & rng)\fC [inline]\fP"
.PP
Main parallel random shuffle step. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIn\fP Length of sequence. 
.br
\fInum_threads\fP Number of threads to use. 
.br
\fIrng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 258 of file random_shuffle.h.
.PP
References __log2(), _GLIBCXX_CALL, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::bin_proc, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::bins_begin, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::bins_end, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::dist, __gnu_parallel::_Settings::L2_cache_size, std::min(), __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::num_bins, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::num_bits, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::num_threads, parallel_random_shuffle_drs_pu(), round_up_to_pow2(), __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::sd, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::seed, sequential_random_shuffle(), __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::starts, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::temporaries, and __gnu_parallel::_Settings::TLB_size.
.PP
Referenced by parallel_random_shuffle().
.SS "template<typename RandomAccessIterator , typename RandomNumberGenerator > void __gnu_parallel::parallel_random_shuffle_drs_pu (DRSSorterPU< RandomAccessIterator, RandomNumberGenerator > * pus)\fC [inline]\fP"
.PP
Random shuffle code executed by each thread. 
.PP
\fBParameters:\fP
.RS 4
\fIpus\fP Array of thread-local data records. 
.RE
.PP

.PP
Definition at line 122 of file random_shuffle.h.
.PP
References __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::dist, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::num_bins, __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::num_bits, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::num_threads, random_number_pow2(), __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::sd, __gnu_parallel::DRSSorterPU< RandomAccessIterator, RandomNumberGenerator >::seed, and __gnu_parallel::DRandomShufflingGlobalData< RandomAccessIterator >::starts.
.PP
Referenced by parallel_random_shuffle_drs().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, parallel_tag parallelism)\fC [inline]\fP"
.PP
Choose a parallel sorting algorithm. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIstable\fP Sort stable. 
.RE
.PP

.PP
Definition at line 196 of file sort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), __gnu_parallel::parallel_tag::get_num_threads(), parallel_sort_qs(), parallel_sort_qsb(), and __gnu_parallel::_Settings::sort_algorithm.
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, default_parallel_tag parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with exact splitting, for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 175 of file sort.h.
.PP
References _GLIBCXX_CALL, and __gnu_parallel::parallel_tag::get_num_threads().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, balanced_quicksort_tag parallelism)\fC [inline]\fP"
.PP
Choose balanced quicksort for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIstable\fP Sort stable. 
.RE
.PP

.PP
Definition at line 154 of file sort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::parallel_tag::get_num_threads(), and parallel_sort_qsb().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, quicksort_tag parallelism)\fC [inline]\fP"
.PP
Choose quicksort for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 134 of file sort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::parallel_tag::get_num_threads(), and parallel_sort_qs().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, multiway_mergesort_sampling_tag parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with splitting by sampling, for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 116 of file sort.h.
.PP
References _GLIBCXX_CALL, and __gnu_parallel::parallel_tag::get_num_threads().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, multiway_mergesort_exact_tag parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort with exact splitting, for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 97 of file sort.h.
.PP
References _GLIBCXX_CALL, and __gnu_parallel::parallel_tag::get_num_threads().
.SS "template<bool stable, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, multiway_mergesort_tag parallelism)\fC [inline]\fP"
.PP
Choose multiway mergesort, splitting variant at run-time, for parallel sorting. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator of input sequence. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 74 of file sort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), and __gnu_parallel::parallel_tag::get_num_threads().
.SS "template<bool stable, bool exact, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort_mwms (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
PMWMS main call. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIn\fP Length of sequence. 
.br
\fInum_threads\fP Number of threads to use. 
.RE
.PP

.PP
Definition at line 398 of file multiway_mergesort.h.
.PP
References _GLIBCXX_CALL, __gnu_parallel::_Settings::get(), __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::num_threads, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::offsets, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::pieces, std::vector< _Tp, _Alloc >::resize(), __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::samples, __gnu_parallel::_Settings::sort_mwms_oversampling, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::source, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::starts, and __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::temporary.
.SS "template<bool stable, bool exact, typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort_mwms_pu (PMWMSSortingData< RandomAccessIterator > * sd, Comparator & comp)\fC [inline]\fP"
.PP
PMWMS code executed by each thread. 
.PP
\fBParameters:\fP
.RS 4
\fIsd\fP Pointer to algorithm data. 
.br
\fIcomp\fP Comparator. 
.RE
.PP

.PP
Definition at line 315 of file multiway_mergesort.h.
.PP
References std::vector< _Tp, _Alloc >::begin(), std::vector< _Tp, _Alloc >::end(), __gnu_parallel::_Settings::get(), __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::num_threads, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::pieces, __gnu_parallel::_Settings::sort_mwms_oversampling, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::source, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::starts, __gnu_parallel::PMWMSSortingData< RandomAccessIterator >::temporary, and std::uninitialized_copy().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort_qs (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
Unbalanced quicksort main call. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of input sequence. 
.br
\fIend\fP End iterator input sequence, ignored. 
.br
\fIcomp\fP Comparator. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 157 of file quicksort.h.
.PP
References _GLIBCXX_CALL, and parallel_sort_qs_conquer().
.PP
Referenced by parallel_sort().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort_qs_conquer (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
Unbalanced quicksort conquer step. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of subsequence. 
.br
\fIend\fP End iterator of subsequence. 
.br
\fIcomp\fP Comparator. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 101 of file quicksort.h.
.PP
References __gnu_parallel::_Settings::get(), and parallel_sort_qs_divide().
.PP
Referenced by parallel_sort_qs().
.SS "template<typename RandomAccessIterator , typename Comparator > \fBstd::iterator_traits\fP<RandomAccessIterator>::difference_type __gnu_parallel::parallel_sort_qs_divide (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type pivot_rank, typename \fBstd::iterator_traits\fP< RandomAccessIterator >::difference_type num_samples, thread_index_t num_threads)\fC [inline]\fP"
.PP
Unbalanced quicksort divide step. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of subsequence. 
.br
\fIend\fP End iterator of subsequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIpivot_rank\fP Desired rank of the pivot. 
.br
\fInum_samples\fP Choose pivot from that many samples. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 51 of file quicksort.h.
.PP
References min(), and parallel_partition().
.PP
Referenced by parallel_sort_qs_conquer().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::parallel_sort_qsb (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
Top-level quicksort routine. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 418 of file balanced_quicksort.h.
.PP
References _GLIBCXX_CALL, and qsb_conquer().
.PP
Referenced by parallel_sort().
.SS "template<typename InputIterator , class OutputIterator > OutputIterator __gnu_parallel::parallel_unique_copy (InputIterator first, InputIterator last, OutputIterator result)\fC [inline]\fP"
.PP
Parallel std::unique_copy(), without explicit equality predicate. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Begin iterator of input sequence. 
.br
\fIlast\fP End iterator of input sequence. 
.br
\fIresult\fP Begin iterator of result sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of result sequence. 
.RE
.PP

.PP
Definition at line 181 of file unique_copy.h.
.PP
References parallel_unique_copy().
.SS "template<typename InputIterator , class OutputIterator , class BinaryPredicate > OutputIterator __gnu_parallel::parallel_unique_copy (InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate binary_pred)\fC [inline]\fP"
.PP
Parallel std::unique_copy(), w/o explicit equality predicate. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Begin iterator of input sequence. 
.br
\fIlast\fP End iterator of input sequence. 
.br
\fIresult\fP Begin iterator of result sequence. 
.br
\fIbinary_pred\fP Equality predicate. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of result sequence. 
.RE
.PP

.PP
Definition at line 51 of file unique_copy.h.
.PP
References _GLIBCXX_CALL, and equally_split().
.PP
Referenced by parallel_unique_copy().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::qsb_conquer (QSBThreadLocal< RandomAccessIterator > ** tls, RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t iam, thread_index_t num_threads, bool parent_wait)\fC [inline]\fP"
.PP
Quicksort conquer step. 
.PP
\fBParameters:\fP
.RS 4
\fItls\fP Array of thread-local storages. 
.br
\fIbegin\fP Begin iterator of subsequence. 
.br
\fIend\fP End iterator of subsequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIiam\fP Number of the thread processing this function. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP

.PP
Definition at line 163 of file balanced_quicksort.h.
.PP
References __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::elements_leftover, __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::initial, qsb_divide(), and qsb_local_sort_with_helping().
.PP
Referenced by parallel_sort_qsb().
.SS "template<typename RandomAccessIterator , typename Comparator > \fBstd::iterator_traits\fP<RandomAccessIterator>::difference_type __gnu_parallel::qsb_divide (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, thread_index_t num_threads)\fC [inline]\fP"
.PP
Balanced quicksort divide step. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of subsequence. 
.br
\fIend\fP End iterator of subsequence. 
.br
\fIcomp\fP Comparator. 
.br
\fInum_threads\fP Number of threads that are allowed to work on this part. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
\fC\fP(end-begin)>=1 
.RE
.PP

.PP
Definition at line 100 of file balanced_quicksort.h.
.PP
References median_of_three_iterators(), and parallel_partition().
.PP
Referenced by qsb_conquer().
.SS "template<typename RandomAccessIterator , typename Comparator > void __gnu_parallel::qsb_local_sort_with_helping (QSBThreadLocal< RandomAccessIterator > ** tls, Comparator & comp, int iam, bool wait)\fC [inline]\fP"
.PP
Quicksort step doing load-balanced local sort. 
.PP
\fBParameters:\fP
.RS 4
\fItls\fP Array of thread-local storages. 
.br
\fIcomp\fP Comparator. 
.br
\fIiam\fP Number of the thread processing this function. 
.RE
.PP

.PP
Definition at line 239 of file balanced_quicksort.h.
.PP
References _GLIBCXX_ASSERTIONS, __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::elements_leftover, __gnu_parallel::_Settings::get(), __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::initial, __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::leftover_parts, __gnu_parallel::QSBThreadLocal< RandomAccessIterator >::num_threads, __gnu_parallel::RestrictedBoundedConcurrentQueue< T >::pop_front(), __gnu_parallel::RestrictedBoundedConcurrentQueue< T >::push_front(), __gnu_parallel::_Settings::sort_qsb_base_case_maximal_n, and yield().
.PP
Referenced by qsb_conquer().
.SS "template<typename RandomNumberGenerator > int __gnu_parallel::random_number_pow2 (int logp, RandomNumberGenerator & rng)\fC [inline]\fP"
.PP
Generate a random number in \fC\fP[0,2^logp). 
.PP
\fBParameters:\fP
.RS 4
\fIlogp\fP Logarithm (basis 2) of the upper range bound. 
.br
\fIrng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 115 of file random_shuffle.h.
.PP
Referenced by parallel_random_shuffle_drs_pu(), and sequential_random_shuffle().
.SS "template<typename T > T __gnu_parallel::round_up_to_pow2 (T x)\fC [inline]\fP"
.PP
Round up to the next greater power of 2. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Integer to round up 
.RE
.PP

.PP
Definition at line 241 of file random_shuffle.h.
.PP
References __log2().
.PP
Referenced by parallel_random_shuffle_drs(), and sequential_random_shuffle().
.SS "template<typename _RandomAccessIterator1 , typename _RandomAccessIterator2 , typename Pred > _RandomAccessIterator1 __gnu_parallel::search_template (_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1, _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2, Pred pred)\fC [inline]\fP"
.PP
Parallel std::search. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin1\fP Begin iterator of first sequence. 
.br
\fIend1\fP End iterator of first sequence. 
.br
\fIbegin2\fP Begin iterator of second sequence. 
.br
\fIend2\fP End iterator of second sequence. 
.br
\fIpred\fP Find predicate. 
.RE
.PP
\fBReturns:\fP
.RS 4
Place of finding in first sequences. 
.RE
.PP

.PP
Definition at line 82 of file search.h.
.PP
References _GLIBCXX_CALL, calc_borders(), equally_split(), and min().
.SS "template<bool stable, bool sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename _DifferenceTp , typename Comparator > RandomAccessIterator3 __gnu_parallel::sequential_multiway_merge (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename \fBstd::iterator_traits\fP< typename \fBstd::iterator_traits\fP< RandomAccessIteratorIterator >::value_type::first_type >::value_type & sentinel, _DifferenceTp length, Comparator comp)\fC [inline]\fP"
.PP
Sequential multi-way merging switch. 
.PP
The _GLIBCXX_PARALLEL_DECISION is based on the branching factor and runtime settings. 
.PP
\fBParameters:\fP
.RS 4
\fIseqs_begin\fP Begin iterator of iterator pair input sequence. 
.br
\fIseqs_end\fP End iterator of iterator pair input sequence. 
.br
\fItarget\fP Begin iterator out output sequence. 
.br
\fIcomp\fP Comparator. 
.br
\fIlength\fP Maximum length to merge, possibly larger than the number of elements available. 
.br
\fIstable\fP Stable merging incurs a performance penalty. 
.br
\fIsentinel\fP The sequences have a sentinel element. 
.RE
.PP
\fBReturns:\fP
.RS 4
End iterator of output sequence. 
.RE
.PP

.PP
Definition at line 979 of file multiway_merge.h.
.PP
References _GLIBCXX_CALL, _GLIBCXX_PARALLEL_LENGTH, is_sorted(), and merge_advance().
.PP
Referenced by multiway_merge(), and multiway_merge_sentinels().
.SS "template<typename RandomAccessIterator , typename RandomNumberGenerator > void __gnu_parallel::sequential_random_shuffle (RandomAccessIterator begin, RandomAccessIterator end, RandomNumberGenerator & rng)\fC [inline]\fP"
.PP
Sequential cache-efficient random shuffle. 
.PP
\fBParameters:\fP
.RS 4
\fIbegin\fP Begin iterator of sequence. 
.br
\fIend\fP End iterator of sequence. 
.br
\fIrng\fP Random number generator to use. 
.RE
.PP

.PP
Definition at line 394 of file random_shuffle.h.
.PP
References __log2(), __gnu_parallel::_Settings::L2_cache_size, std::min(), random_number_pow2(), round_up_to_pow2(), and __gnu_parallel::_Settings::TLB_size.
.PP
Referenced by parallel_random_shuffle_drs().
.SS "template<typename InputIterator > void __gnu_parallel::shrink (\fBstd::vector\fP< InputIterator > & os_starts, size_t & count_to_two, size_t & range_length)\fC [inline]\fP"
.PP
Combines two ranges into one and thus halves the number of ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIos_starts\fP Start positions worked on (oversampled). 
.br
\fIcount_to_two\fP Counts up to 2. 
.br
\fIrange_length\fP Current length of a chunk. 
.RE
.PP

.PP
Definition at line 70 of file list_partition.h.
.PP
References std::vector< _Tp, _Alloc >::size().
.PP
Referenced by shrink_and_double().
.SS "template<typename InputIterator > void __gnu_parallel::shrink_and_double (\fBstd::vector\fP< InputIterator > & os_starts, size_t & count_to_two, size_t & range_length, const bool make_twice)\fC [inline]\fP"
.PP
Shrinks and doubles the ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIos_starts\fP Start positions worked on (oversampled). 
.br
\fIcount_to_two\fP Counts up to 2. 
.br
\fIrange_length\fP Current length of a chunk. 
.br
\fImake_twice\fP Whether the \fCos_starts\fP is allowed to be grown or not 
.RE
.PP

.PP
Definition at line 50 of file list_partition.h.
.PP
References std::vector< _Tp, _Alloc >::resize(), shrink(), and std::vector< _Tp, _Alloc >::size().
.PP
Referenced by list_partition().
.SS "void __gnu_parallel::yield ()\fC [inline]\fP"
.PP
Yield the control to another thread, without waiting for the end to the time slice. 
.PP
Definition at line 340 of file parallel/compatibility.h.
.PP
Referenced by for_each_template_random_access_workstealing(), and qsb_local_sort_with_helping().
.SH "Variable Documentation"
.PP 
.SS "const int \fB__gnu_parallel::lcas_t_bits\fP\fC [static]\fP"
.PP
Number of bits of \fBlcas_t\fP. 
.PP
Definition at line 149 of file types.h.
.PP
Referenced by decode2(), and encode2().
.SS "const \fBlcas_t\fP \fB__gnu_parallel::lcas_t_mask\fP\fC [static]\fP"
.PP
\fBlcas_t\fP with the right half of bits set to 1. 
.PP
Definition at line 152 of file types.h.
.PP
Referenced by decode2().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
