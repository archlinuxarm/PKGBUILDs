.TH "std::regex_constants" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::regex_constants \- ISO C++ 0x entities sub namespace for regex.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "5.2 Matching Rules"
Matching a regular expression against a sequence of characters [first, last) proceeds according to the rules of the grammar specified for the regular expression object, modified according to the effects listed below for any bitmask elements \fBset\fP. 
.in +1c
.ti -1c
.RI "enum \fB__match_flag\fP { \fB_S_not_bol\fP, \fB_S_not_eol\fP, \fB_S_not_bow\fP, \fB_S_not_eow\fP, \fB_S_any\fP, \fB_S_not_null\fP, \fB_S_continuous\fP, \fB_S_prev_avail\fP, \fB_S_sed\fP, \fB_S_no_copy\fP, \fB_S_first_only\fP, \fB_S_match_flag_last\fP }"
.br
.ti -1c
.RI "typedef \fBstd::bitset\fP< _S_match_flag_last > \fBmatch_flag_type\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBformat_default\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBformat_first_only\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBformat_no_copy\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBformat_sed\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_any\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_continuous\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_default\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_not_bol\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_not_bow\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_not_eol\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_not_eow\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_not_null\fP"
.br
.ti -1c
.RI "static const \fBmatch_flag_type\fP \fBmatch_prev_avail\fP"
.br
.in -1c
.SS "5.1 Regular Expression Syntax Options"

.in +1c
.ti -1c
.RI "enum \fB__syntax_option\fP { \fB_S_icase\fP, \fB_S_nosubs\fP, \fB_S_optimize\fP, \fB_S_collate\fP, \fB_S_ECMAScript\fP, \fB_S_basic\fP, \fB_S_extended\fP, \fB_S_awk\fP, \fB_S_grep\fP, \fB_S_egrep\fP, \fB_S_syntax_last\fP }"
.br
.ti -1c
.RI "typedef unsigned int \fBsyntax_option_type\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBawk\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBbasic\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBcollate\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBECMAScript\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBegrep\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBextended\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBgrep\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBicase\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBnosubs\fP"
.br
.ti -1c
.RI "static const \fBsyntax_option_type\fP \fBoptimize\fP"
.br
.in -1c
.SS "5.3 Error Types"

.in +1c
.ti -1c
.RI "enum \fBerror_type\fP { \fB_S_error_collate\fP, \fB_S_error_ctype\fP, \fB_S_error_escape\fP, \fB_S_error_backref\fP, \fB_S_error_brack\fP, \fB_S_error_paren\fP, \fB_S_error_brace\fP, \fB_S_error_badbrace\fP, \fB_S_error_range\fP, \fB_S_error_space\fP, \fB_S_error_badrepeat\fP, \fB_S_error_complexity\fP, \fB_S_error_stack\fP, \fB_S_error_last\fP }"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_backref\fP (_S_error_backref)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_badbrace\fP (_S_error_badbrace)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_badrepeat\fP (_S_error_badrepeat)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_brace\fP (_S_error_brace)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_brack\fP (_S_error_brack)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_collate\fP (_S_error_collate)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_complexity\fP (_S_error_complexity)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_ctype\fP (_S_error_ctype)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_escape\fP (_S_error_escape)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_paren\fP (_S_error_paren)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_range\fP (_S_error_range)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_space\fP (_S_error_space)"
.br
.ti -1c
.RI "static const \fBerror_type\fP \fBerror_stack\fP (_S_error_stack)"
.br
.in -1c
.SH "Detailed Description"
.PP 
ISO C++ 0x entities sub namespace for regex. 
.PP
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBstd::bitset\fP<_S_match_flag_last> \fBstd::regex_constants::match_flag_type\fP"
.PP
This is a bitmask type indicating regex matching rules. 
.PP
The \fCmatch_flag_type\fP is implementation defined but it is valid to perform bitwise operations on these values and expect the right thing to happen. 
.PP
Definition at line 196 of file tr1_impl/regex.
.SS "typedef unsigned int \fBstd::regex_constants::syntax_option_type\fP"
.PP
This is a bitmask type indicating how to interpret the regex. 
.PP
The \fCsyntax_option_type\fP is implementation defined but it is valid to perform bitwise operations on these values and expect the right thing to happen.
.PP
A valid value of type syntax_option_type shall have exactly one of the elements \fCECMAScript\fP, \fCbasic\fP, \fCextended\fP, \fCawk\fP, \fCgrep\fP, \fCegrep\fP set. 
.PP
Definition at line 78 of file tr1_impl/regex.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBstd::regex_constants::__match_flag\fP"
.PP
This is a bitmask type indicating regex matching rules. 
.PP
The \fCmatch_flag_type\fP is implementation defined but it is valid to perform bitwise operations on these values and expect the right thing to happen. 
.PP
Definition at line 173 of file tr1_impl/regex.
.SS "enum \fBstd::regex_constants::__syntax_option\fP"
.PP
This is a bitmask type indicating how to interpret the regex. 
.PP
The \fCsyntax_option_type\fP is implementation defined but it is valid to perform bitwise operations on these values and expect the right thing to happen.
.PP
A valid value of type syntax_option_type shall have exactly one of the elements \fCECMAScript\fP, \fCbasic\fP, \fCextended\fP, \fCawk\fP, \fCgrep\fP, \fCegrep\fP set. 
.PP
Definition at line 52 of file tr1_impl/regex.
.SS "enum \fBstd::regex_constants::error_type\fP"
.PP
The expression contained an invalid back reference. 
.PP
Definition at line 308 of file tr1_impl/regex.
.SH "Function Documentation"
.PP 
.SS "static const \fBerror_type\fP std::regex_constants::error_backref (_S_error_backref)\fC [static]\fP"
.PP
The expression contained an invalid back reference. 
.SS "static const \fBerror_type\fP std::regex_constants::error_badbrace (_S_error_badbrace)\fC [static]\fP"
.PP
The expression contained an invalid range in a {} expression. 
.SS "static const \fBerror_type\fP std::regex_constants::error_badrepeat (_S_error_badrepeat)\fC [static]\fP"
.PP
One of '*?+{' was not preceded by a valid regular expression. 
.SS "static const \fBerror_type\fP std::regex_constants::error_brace (_S_error_brace)\fC [static]\fP"
.PP
The expression contained mismatched { and } 
.SS "static const \fBerror_type\fP std::regex_constants::error_brack (_S_error_brack)\fC [static]\fP"
.PP
The expression contained mismatched [ and ]. 
.SS "static const \fBerror_type\fP std::regex_constants::error_collate (_S_error_collate)\fC [static]\fP"
.PP
The expression contained an invalid collating element name. 
.SS "static const \fBerror_type\fP std::regex_constants::error_complexity (_S_error_complexity)\fC [static]\fP"
.PP
The complexity of an attempted match against a regular expression exceeded a pre-set level. 
.SS "static const \fBerror_type\fP std::regex_constants::error_ctype (_S_error_ctype)\fC [static]\fP"
.PP
The expression contained an invalid character class name. 
.SS "static const \fBerror_type\fP std::regex_constants::error_escape (_S_error_escape)\fC [static]\fP"
.PP
The expression contained an invalid escaped character, or a trailing escape. 
.SS "static const \fBerror_type\fP std::regex_constants::error_paren (_S_error_paren)\fC [static]\fP"
.PP
The expression contained mismatched ( and ). 
.SS "static const \fBerror_type\fP std::regex_constants::error_range (_S_error_range)\fC [static]\fP"
.PP
The expression contained an invalid character range, such as [b-a] in most encodings. 
.SS "static const \fBerror_type\fP std::regex_constants::error_space (_S_error_space)\fC [static]\fP"
.PP
There was insufficient memory to convert the expression into a finite state machine. 
.SS "static const \fBerror_type\fP std::regex_constants::error_stack (_S_error_stack)\fC [static]\fP"
.PP
There was insufficient memory to determine whether the regular expression could match the specified character sequence. 
.SH "Variable Documentation"
.PP 
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::awk\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by POSIX utility awk in IEEE Std 1003.1-2001. This option is identical to syntax_option_type extended, except that C-style escape sequences are supported. These sequences are, explicitly, '\\\\', '\\a', '\\b', '\\f', '\\n', '\\r', '\\t' , '\\v', '\\'', ''', and '\\ddd' (where ddd is one, two, or three octal digits). 
.PP
Definition at line 142 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::basic\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by POSIX basic regular expressions in IEEE Std 1003.1-2001, Portable Operating System Interface (POSIX), Base Definitions and Headers, Section 9, Regular Expressions [IEEE, Information Technology -- Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001]. 
.PP
Definition at line 124 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::collate\fP\fC [static]\fP"
.PP
Specifies that character ranges of the form [a-b] should be \fBlocale\fP sensitive. 
.PP
Definition at line 105 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::ECMAScript\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by ECMAScript in ECMA-262 [Ecma International, ECMAScript Language Specification, Standard Ecma-262, third edition, 1999], as modified in \fBtr1\fP section [7.13]. This grammar is similar to that defined in the PERL scripting language but extended with elements found in the POSIX regular expression grammar. 
.PP
Definition at line 115 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::egrep\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by POSIX utility grep when given the -E option in IEEE Std 1003.1-2001. This option is identical to syntax_option_type extended, except that newlines are treated as whitespace. 
.PP
Definition at line 158 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::extended\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by POSIX extended regular expressions in IEEE Std 1003.1-2001, Portable Operating System Interface (POSIX), Base Definitions and Headers, Section 9, Regular Expressions. 
.PP
Definition at line 132 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::format_default\fP\fC [static]\fP"
.PP
When a regular expression match is to be replaced by a new string, the new string is constructed using the rules used by the ECMAScript replace function in ECMA- 262 [Ecma International, ECMAScript Language Specification, Standard Ecma-262, third edition, 1999], part 15.5.4.11 String.prototype.replace. In addition, during search and replace operations all non-overlapping occurrences of the regular expression are located and replaced, and sections of the input that did not match the expression are copied unchanged to the output string.
.PP
Format strings (from ECMA-262 [15.5.4.11]): 
.PD 0

.IP "\(bu" 2
$$ The dollar-sign itself ($) 
.IP "\(bu" 2
$& The matched substring. 
.IP "\(bu" 2
$` The portion of \fIstring\fP that precedes the matched substring. This would be \fBmatch_results::prefix()\fP. 
.IP "\(bu" 2
$' The portion of \fIstring\fP that follows the matched substring. This would be \fBmatch_results::suffix()\fP. 
.IP "\(bu" 2
$n The nth capture, where n is in [1,9] and $n is not followed by a decimal digit. If n <= \fBmatch_results::size()\fP and the nth capture is undefined, use the empty string instead. If n > \fBmatch_results::size()\fP, the result is implementation-defined. 
.IP "\(bu" 2
$nn The nnth capture, where nn is a two-digit decimal number on [01, 99]. If nn <= \fBmatch_results::size()\fP and the nth capture is undefined, use the empty string instead. If nn > \fBmatch_results::size()\fP, the result is implementation-defined. 
.PP

.PP
Definition at line 278 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::format_first_only\fP\fC [static]\fP"
.PP
When specified during a search and replace operation, only the first occurrence of the regular expression shall be replaced. 
.PP
Definition at line 299 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::format_no_copy\fP\fC [static]\fP"
.PP
During a search and replace operation, sections of the character container sequence being searched that do not match the regular expression shall not be copied to the output string. 
.PP
Definition at line 293 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::format_sed\fP\fC [static]\fP"
.PP
When a regular expression match is to be replaced by a new string, the new string is constructed using the rules used by the POSIX sed utility in IEEE Std 1003.1- 2001 [IEEE, Information Technology -- Portable Operating System Interface (POSIX), IEEE Standard 1003.1-2001]. 
.PP
Definition at line 286 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::grep\fP\fC [static]\fP"
.PP
Specifies that the grammar recognized by the regular expression engine is that used by POSIX utility grep in IEEE Std 1003.1-2001. This option is identical to syntax_option_type basic, except that newlines are treated as whitespace. 
.PP
Definition at line 150 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::icase\fP\fC [static]\fP"
.PP
Specifies that the matching of regular expressions against a character sequence shall be performed without regard to case. 
.PP
Definition at line 84 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_any\fP\fC [static]\fP"
.PP
If more than one match is possible then any match is an acceptable result. 
.PP
Definition at line 233 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_continuous\fP\fC [static]\fP"
.PP
The expression only matches a sub-sequence that begins at first . 
.PP
Definition at line 243 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_default\fP\fC [static]\fP"
.PP
The default matching rules. 
.PP
Definition at line 201 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_not_bol\fP\fC [static]\fP"
.PP
The first character in the sequence [first, last) is treated as though it is not at the beginning of a line, so the character '^' in the regular expression shall not match [first, first). 
.PP
Definition at line 208 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_not_bow\fP\fC [static]\fP"
.PP
The expression '\\b' is not matched against the sub-sequence [first,first). 
.PP
Definition at line 221 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_not_eol\fP\fC [static]\fP"
.PP
The last character in the sequence [first, last) is treated as though it is not at the end of a line, so the character '$' in the regular expression shall not match [last, last). 
.PP
Definition at line 215 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_not_eow\fP\fC [static]\fP"
.PP
The expression '\\b' should not be matched against the sub-sequence [last,last). 
.PP
Definition at line 227 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_not_null\fP\fC [static]\fP"
.PP
The expression does not match an empty sequence. 
.PP
Definition at line 238 of file tr1_impl/regex.
.SS "const \fBmatch_flag_type\fP \fBstd::regex_constants::match_prev_avail\fP\fC [static]\fP"
.PP
--first is a valid \fBiterator\fP position. When this flag is \fBset\fP then the flags match_not_bol and match_not_bow are ignored by the regular expression algorithms 7.11 and iterators 7.12. 
.PP
Definition at line 250 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::nosubs\fP\fC [static]\fP"
.PP
Specifies that when a regular expression is matched against a character container sequence, no sub-expression matches are to be stored in the supplied \fBmatch_results\fP structure. 
.PP
Definition at line 91 of file tr1_impl/regex.
.SS "const \fBsyntax_option_type\fP \fBstd::regex_constants::optimize\fP\fC [static]\fP"
.PP
Specifies that the regular expression engine should pay more attention to the speed with which regular expressions are matched, and \fBless\fP to the speed with which regular expression objects are constructed. Otherwise it has no detectable effect on the program output. 
.PP
Definition at line 99 of file tr1_impl/regex.
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
