.TH "std::queue" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::queue \- A standard container giving FIFO behavior.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Sequence::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Sequence \fBcontainer_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Sequence::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace\fP (_Args &&...__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "\fBqueue\fP & \fBoperator=\fP (\fBqueue\fP &&__q)"
.br
.ti -1c
.RI "void \fBpop\fP ()"
.br
.ti -1c
.RI "void \fBpush\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush\fP (const value_type &__x)"
.br
.ti -1c
.RI "\fBqueue\fP (\fBqueue\fP &&__q)"
.br
.ti -1c
.RI "\fBqueue\fP (_Sequence &&__c=_Sequence())"
.br
.ti -1c
.RI "\fBqueue\fP (const _Sequence &__c)"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBqueue\fP &&__q)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Sequence \fBc\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Tp1 , typename _Seq1 > bool \fBoperator<\fP (const \fBqueue\fP< _Tp1, _Seq1 > &, const \fBqueue\fP< _Tp1, _Seq1 > &)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Seq1 > bool \fBoperator==\fP (const \fBqueue\fP< _Tp1, _Seq1 > &, const \fBqueue\fP< _Tp1, _Seq1 > &)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> class std::queue< _Tp, _Sequence >"
A standard container giving FIFO behavior. 

Meets many of the requirements of a \fCcontainer\fP, but does not define anything to do with iterators. Very few of the other standard container interfaces are defined.
.PP
This is not a true container, but an \fIadaptor\fP. It holds another container, and provides a wrapper interface to that container. The wrapper is what enforces strict first-in-first-out queue behavior.
.PP
The second template parameter defines the type of the underlying sequence/container. It defaults to \fBstd::deque\fP, but it can be any type that supports \fCfront\fP, \fCback\fP, \fCpush_back\fP, and \fCpop_front\fP, such as \fBstd::list\fP or an appropriate user-defined type.
.PP
Members not found in 'normal' containers are \fCcontainer_type\fP, which is a typedef for the second Sequence parameter, and \fCpush\fP and \fCpop\fP, which are standard queue/FIFO operations. 
.PP
Definition at line 89 of file stl_queue.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> \fBstd::queue\fP< _Tp, _Sequence >::\fBqueue\fP (const _Sequence & __c)\fC [inline, explicit]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 134 of file stl_queue.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> const_reference \fBstd::queue\fP< _Tp, _Sequence >::back () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the last element of the queue. 
.PP
Definition at line 202 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> reference \fBstd::queue\fP< _Tp, _Sequence >::back ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the last element of the queue. 
.PP
Definition at line 191 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> bool \fBstd::queue\fP< _Tp, _Sequence >::empty () const\fC [inline]\fP"
.PP
Returns true if the queue is empty. 
.PP
Definition at line 156 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> const_reference \fBstd::queue\fP< _Tp, _Sequence >::front () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the first element of the queue. 
.PP
Definition at line 180 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> reference \fBstd::queue\fP< _Tp, _Sequence >::front ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the first element of the queue. 
.PP
Definition at line 169 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> void \fBstd::queue\fP< _Tp, _Sequence >::pop ()\fC [inline]\fP"
.PP
Removes first element. 
.PP
This is a typical queue operation. It shrinks the queue by one. The time complexity of the operation depends on the underlying sequence.
.PP
Note that no data is returned, and if the first element's data is needed, it should be retrieved before \fBpop()\fP is called. 
.PP
Definition at line 244 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> void \fBstd::queue\fP< _Tp, _Sequence >::push (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the end of the queue. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical queue operation. The function creates an element at the end of the queue and assigns the given data to it. The time complexity of the operation depends on the underlying sequence. 
.PP
Definition at line 218 of file stl_queue.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> size_type \fBstd::queue\fP< _Tp, _Sequence >::size () const\fC [inline]\fP"
.PP
Returns the number of elements in the queue. 
.PP
Definition at line 161 of file stl_queue.h.
.SH "Member Data Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> _Sequence \fBstd::queue\fP< _Tp, _Sequence >::\fBc\fP\fC [protected]\fP"
.PP
'c' is the underlying container. Maintainers wondering why this isn't uglified as per style guidelines should note that this name is specified in the standard, [23.2.3.1]. (Why? Presumably for the same reason that it's protected instead of private: to allow derivation. But none of the other containers allow for derivation. Odd.) 
.PP
Definition at line 122 of file stl_queue.h.
.PP
Referenced by std::operator==().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
