.TH "std::insert_iterator" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::insert_iterator \- Turns assignment into insertion.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBiterator< output_iterator_tag, void, void, void, void >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Container \fBcontainer_type\fP"
.br
.ti -1c
.RI "typedef void \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fBoutput_iterator_tag\fP \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef void \fBpointer\fP"
.br
.ti -1c
.RI "typedef void \fBreference\fP"
.br
.ti -1c
.RI "typedef void \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBinsert_iterator\fP (_Container &__x, typename _Container::iterator __i)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator*\fP ()"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator=\fP (typename _Container::value_type &&__value)"
.br
.ti -1c
.RI "\fBinsert_iterator\fP & \fBoperator=\fP (typename _Container::const_reference __value)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Container * \fBcontainer\fP"
.br
.ti -1c
.RI "_Container::iterator \fBiter\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Container> class std::insert_iterator< _Container >"
Turns assignment into insertion. 

These are output iterators, constructed from a container-of-T. Assigning a T to the \fBiterator\fP inserts it in the container at the iterator's position, rather than overwriting the value at that position.
.PP
(Sequences will actually insert a \fIcopy\fP of the value before the iterator's position.)
.PP
Tip: Using the inserter function to create these iterators can save typing. 
.PP
Definition at line 560 of file stl_iterator.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Container> typedef _Container \fBstd::insert_iterator\fP< _Container >::\fBcontainer_type\fP"
.PP
A nested typedef for the type of whatever container you used. 
.PP
Definition at line 569 of file stl_iterator.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBdifference_type\fP\fC [inherited]\fP"
.PP
Distance between iterators is represented as this type. 
.PP
Definition at line 111 of file stl_iterator_base_types.h.
.SS "typedef \fBoutput_iterator_tag\fP  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBiterator_category\fP\fC [inherited]\fP"
.PP
One of the \fBtag types\fP. 
.PP
Definition at line 107 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBpointer\fP\fC [inherited]\fP"
.PP
This type represents a pointer-to-value_type. 
.PP
Definition at line 113 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBreference\fP\fC [inherited]\fP"
.PP
This type represents a reference-to-value_type. 
.PP
Definition at line 115 of file stl_iterator_base_types.h.
.SS "typedef void  \fBstd::iterator\fP< \fBoutput_iterator_tag\fP , void , void , void , void  >::\fBvalue_type\fP\fC [inherited]\fP"
.PP
The type 'pointed to' by the iterator. 
.PP
Definition at line 109 of file stl_iterator_base_types.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Container> \fBstd::insert_iterator\fP< _Container >::\fBinsert_iterator\fP (_Container & __x, typename _Container::iterator __i)\fC [inline]\fP"
.PP
The only way to create this iterator is with a container and an initial position (a normal iterator into the container). 
.PP
Definition at line 575 of file stl_iterator.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator* ()\fC [inline]\fP"
.PP
Simply returns *this. 
.PP
Definition at line 621 of file stl_iterator.h.
.PP
References std::operator*().
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator++ (int)\fC [inline]\fP"
.PP
Simply returns *this. (This iterator does not 'move'.). 
.PP
Definition at line 631 of file stl_iterator.h.
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator++ ()\fC [inline]\fP"
.PP
Simply returns *this. (This iterator does not 'move'.). 
.PP
Definition at line 626 of file stl_iterator.h.
.SS "template<typename _Container> \fBinsert_iterator\fP& \fBstd::insert_iterator\fP< _Container >::operator= (typename _Container::const_reference __value)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP An instance of whatever type container_type::const_reference is; presumably a reference-to-const T for container<T>. 
.RE
.PP
\fBReturns:\fP
.RS 4
This iterator, for chained operations.
.RE
.PP
This kind of iterator maintains its own position in the container. Assigning a value to the iterator will insert the value into the container at the place before the iterator.
.PP
The position is maintained such that subsequent assignments will insert values immediately after one another. For example, 
.PP
.nf
     // vector v contains A and Z

     insert_iterator i (v, ++v.begin());
     i = 1;
     i = 2;
     i = 3;

     // vector v contains A, 1, 2, 3, and Z

.fi
.PP
 
.PP
Definition at line 602 of file stl_iterator.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
