.TH "__gnu_cxx::bitmap_allocator" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::bitmap_allocator \- Bitmap Allocator, primary template.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB__gnu_cxx::free_list\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef free_list::__mutex_type \fB__mutex_type\fP"
.br
.ti -1c
.RI "typedef const _Tp * \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef const _Tp & \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _Tp * \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp & \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "pointer \fB_M_allocate_single_object\fP ()  throw (std::bad_alloc)"
.br
.ti -1c
.RI "void \fB_M_deallocate_single_object\fP (pointer __p)  throw ()"
.br
.ti -1c
.RI "const_pointer \fBaddress\fP (const_reference __r) const "
.br
.ti -1c
.RI "pointer \fBaddress\fP (reference __r) const "
.br
.ti -1c
.RI "pointer \fBallocate\fP (size_type __n, typename \fBbitmap_allocator\fP< void >::const_pointer)"
.br
.ti -1c
.RI "pointer \fBallocate\fP (size_type __n)"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBbitmap_allocator\fP (const \fBbitmap_allocator\fP< _Tp1 > &)  throw ()"
.br
.ti -1c
.RI "\fBbitmap_allocator\fP (const \fBbitmap_allocator\fP &)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBconstruct\fP (pointer __p, _Args &&...__args)"
.br
.ti -1c
.RI "void \fBconstruct\fP (pointer __p, const_reference __data)"
.br
.ti -1c
.RI "void \fBdeallocate\fP (pointer __p, size_type __n)  throw ()"
.br
.ti -1c
.RI "void \fBdestroy\fP (pointer __p)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const   throw ()"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "size_t * \fB_M_get\fP (size_t __sz)  throw (std::bad_alloc)"
.br
.ti -1c
.RI "void \fB_M_insert\fP (size_t *__addr)  throw ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp> class __gnu_cxx::bitmap_allocator< _Tp >"
Bitmap Allocator, primary template. 
.PP
Definition at line 710 of file bitmap_allocator.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp> pointer \fB__gnu_cxx::bitmap_allocator\fP< _Tp >::_M_allocate_single_object ()  throw (\fBstd::bad_alloc\fP)\fC [inline]\fP"
.PP
Allocates memory for a single object of size sizeof(_Tp). 
.PP
\fBExceptions:\fP
.RS 4
\fIstd::bad_alloc.\fP If memory can not be allocated.
.RE
.PP
Complexity: Worst case complexity is O(N), but that is hardly ever hit. If and when this particular case is encountered, the next few cases are guaranteed to have a worst case complexity of O(1)! That's why this function performs very well on average. You can consider this function to have a complexity referred to commonly as: Amortized Constant time. 
.PP
Definition at line 846 of file bitmap_allocator.h.
.PP
References __gnu_cxx::__detail::__bit_allocate(), __gnu_cxx::__detail::__num_bitmaps(), and __gnu_cxx::_Bit_scan_forward().
.SS "template<typename _Tp> void \fB__gnu_cxx::bitmap_allocator\fP< _Tp >::_M_deallocate_single_object (pointer __p)  throw ()\fC [inline]\fP"
.PP
Deallocates memory that belongs to a single object of size sizeof(_Tp). 
.PP
Complexity: O(lg(N)), but the worst case is not hit often! This is because containers usually deallocate memory close to each other and this case is handled in O(1) time by the deallocate function. 
.PP
Definition at line 944 of file bitmap_allocator.h.
.PP
References __gnu_cxx::__detail::__bit_free(), __gnu_cxx::__detail::__num_bitmaps(), and std::__rotate().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
