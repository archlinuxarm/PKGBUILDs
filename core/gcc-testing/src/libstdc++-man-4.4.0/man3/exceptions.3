.TH "Exceptions" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Exceptions \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fB__cxxabiv1::__forced_unwind\fP"
.br
.RI "\fIThrown as part of forced unwinding.
.PP
A magic placeholder class that can be caught by reference to recognize forced unwinding. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::forced_exception_error\fP"
.br
.RI "\fIThown by \fBthrow_allocator\fP. \fP"
.ti -1c
.RI "class \fBstd::bad_alloc\fP"
.br
.RI "\fIException possibly thrown by \fCnew\fP.
.PP
\fC\fBbad_alloc\fP\fP (or classes derived from it) is used to report allocation errors from the throwing forms of \fCnew\fP. \fP"
.ti -1c
.RI "class \fBstd::bad_cast\fP"
.br
.RI "\fIThrown during incorrect typecasting.
.PP
If you attempt an invalid \fCdynamic_cast\fP expression, an instance of this class (or something derived from this class) is thrown. \fP"
.ti -1c
.RI "class \fBstd::bad_exception\fP"
.br
.ti -1c
.RI "class \fBstd::bad_typeid\fP"
.br
.RI "\fIThrown when a NULL pointer in a \fCtypeid\fP expression is used. \fP"
.ti -1c
.RI "class \fBstd::domain_error\fP"
.br
.ti -1c
.RI "class \fBstd::exception\fP"
.br
.RI "\fIBase class for all library exceptions. \fP"
.ti -1c
.RI "class \fBstd::invalid_argument\fP"
.br
.ti -1c
.RI "class \fBstd::ios_base::ios_base::failure\fP"
.br
.RI "\fIThese are thrown to indicate problems with io.
.PP
27.4.2.1.1 Class \fBios_base::failure\fP. \fP"
.ti -1c
.RI "class \fBstd::length_error\fP"
.br
.ti -1c
.RI "class \fBstd::lock_error\fP"
.br
.RI "\fIThrown to indicate errors with lock operations. \fP"
.ti -1c
.RI "class \fBstd::logic_error\fP"
.br
.RI "\fIOne of two subclasses of \fBexception\fP. \fP"
.ti -1c
.RI "class \fBstd::out_of_range\fP"
.br
.ti -1c
.RI "class \fBstd::overflow_error\fP"
.br
.ti -1c
.RI "class \fBstd::range_error\fP"
.br
.ti -1c
.RI "class \fBstd::regex_error\fP"
.br
.RI "\fIA regular expression \fBexception\fP class.
.PP
The regular expression library throws objects of this class on error. \fP"
.ti -1c
.RI "class \fBstd::runtime_error\fP"
.br
.RI "\fIOne of two subclasses of \fBexception\fP. \fP"
.ti -1c
.RI "class \fBstd::system_error\fP"
.br
.RI "\fIThrown to indicate error code of underlying system. \fP"
.ti -1c
.RI "class \fBstd::underflow_error\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBstd::terminate_handler\fP )()"
.br
.ti -1c
.RI "typedef void(* \fBstd::unexpected_handler\fP )()"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB__gnu_cxx::__verbose_terminate_handler\fP ()"
.br
.ti -1c
.RI "template<typename _Ex > exception_ptr \fBstd::copy_exception\fP (_Ex __ex)  throw ()"
.br
.ti -1c
.RI "exception_ptr \fBstd::current_exception\fP ()  throw ()"
.br
.ti -1c
.RI "void \fBstd::rethrow_exception\fP (exception_ptr) __attribute__((__noreturn__))"
.br
.ti -1c
.RI "terminate_handler \fBstd::set_terminate\fP (terminate_handler)  throw ()"
.br
.ti -1c
.RI "unexpected_handler \fBstd::set_unexpected\fP (unexpected_handler)  throw ()"
.br
.ti -1c
.RI "void \fBstd::terminate\fP () __attribute__((__noreturn__))"
.br
.ti -1c
.RI "bool \fBstd::uncaught_exception\fP ()  throw ()"
.br
.ti -1c
.RI "void \fBstd::unexpected\fP () __attribute__((__noreturn__))"
.br
.in -1c
.SH "Detailed Description"
.PP 
Classes and functions for reporting errors via \fBexception\fP classes. 
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* \fBstd::terminate_handler\fP)()"
.PP
If you write a replacement terminate handler, it must be of this type. 
.PP
Definition at line 86 of file exception.
.SS "typedef void(* \fBstd::unexpected_handler\fP)()"
.PP
If you write a replacement unexpected handler, it must be of this type. 
.PP
Definition at line 89 of file exception.
.SH "Function Documentation"
.PP 
.SS "void __gnu_cxx::__verbose_terminate_handler ()"
.PP
A replacement for the standard terminate_handler which prints more information about the terminating exception (if any) on stderr. 
.PP
Call 
.PP
.nf
     std::set_terminate(__gnu_cxx::__verbose_terminate_handler)

.fi
.PP
 to use. For more info, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt02ch06s02.html
.PP
In 3.4 and later, this is on by default. 
.SS "template<typename _Ex > exception_ptr std::copy_exception (_Ex __ex)  throw ()\fC [inline]\fP"
.PP
Obtain an exception_ptr pointing to a copy of the supplied object. 
.PP
Definition at line 159 of file exception_ptr.h.
.PP
References std::current_exception().
.SS "exception_ptr std::current_exception ()  throw ()"
.PP
Obtain an exception_ptr to the currently handled \fBexception\fP. If there is none, or the currently handled \fBexception\fP is foreign, return the null value. 
.PP
Referenced by std::copy_exception().
.SS "void std::rethrow_exception (exception_ptr)"
.PP
Throw the object pointed to by the exception_ptr. 
.PP
.SS "terminate_handler std::set_terminate (terminate_handler)  throw ()"
.PP
Takes a new handler function as an argument, returns the old function. 
.PP
.SS "unexpected_handler std::set_unexpected (unexpected_handler)  throw ()"
.PP
Takes a new handler function as an argument, returns the old function. 
.PP
.SS "void std::terminate ()"
.PP
The runtime will call this function if exception handling must be abandoned for any reason. It can also be called by the user. 
.SS "bool std::uncaught_exception ()  throw ()"
.PP
[18.6.4]/1: 'Returns true after completing evaluation of a throw-expression until either completing initialization of the exception-declaration in the matching handler or entering \fC\fBunexpected()\fP\fP due to the throw; or after entering \fC\fBterminate()\fP\fP for any reason other than an explicit call to \fC\fBterminate()\fP\fP. [Note: This includes \fBstack\fP unwinding [15.2]. end note]'
.PP
2: 'When \fC\fBuncaught_exception()\fP\fP is true, throwing an exception can result in a call of \fC\fBterminate()\fP\fP (15.5.1).' 
.PP
Referenced by std::basic_ostream< _CharT, _Traits >::basic_ostream::sentry::~sentry().
.SS "void std::unexpected ()"
.PP
The runtime will call this function if an exception is thrown which violates the function's exception specification. 
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
