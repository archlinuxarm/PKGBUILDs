.TH "std::bitset" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::bitset \- The bitset class represents a \fIfixed-size\fP sequence of bits.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB_Base_bitset<((_Nb)< 1?0:((_Nb)+(__CHAR_BIT__ *sizeof(unsigned long))-1)/(__CHAR_BIT__ *sizeof(unsigned long)))>\fP.
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "size_t \fB_Find_first\fP () const "
.br
.ti -1c
.RI "size_t \fB_Find_next\fP (size_t __prev) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > void \fB_M_copy_from_ptr\fP (const _CharT *, size_t, size_t, size_t, _CharT, _CharT)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_from_string\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __pos, size_t __n)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_from_string\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __pos, size_t __n, _CharT __zero, _CharT __one)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_to_string\fP (\fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > void \fB_M_copy_to_string\fP (\fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &, _CharT, _CharT) const "
.br
.ti -1c
.RI "bool \fBall\fP () const "
.br
.ti -1c
.RI "bool \fBany\fP () const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position, size_t __n, _CharT __zero, _CharT __one=_CharT('1'))"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position, size_t __n)"
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > &__s, size_t __position=0)"
.br
.ti -1c
.RI "\fBbitset\fP (unsigned long __val)"
.br
.ti -1c
.RI "\fBbitset\fP ()"
.br
.ti -1c
.RI "size_t \fBcount\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP (size_t __position)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBflip\fP ()"
.br
.ti -1c
.RI "bool \fBnone\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator~\fP () const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP (size_t __position)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBreset\fP ()"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP (size_t __position, bool __val=true)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBset\fP ()"
.br
.ti -1c
.RI "size_t \fBsize\fP () const "
.br
.ti -1c
.RI "bool \fBtest\fP (size_t __position) const "
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP (char __zero, char __one= '1') const "
.br
.ti -1c
.RI "\fBstd::basic_string\fP< char, \fBstd::char_traits\fP< char >, \fBstd::allocator\fP< char > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT > \fBstd::basic_string\fP< _CharT, \fBstd::char_traits\fP< _CharT >, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits > \fBstd::basic_string\fP< _CharT, _Traits, \fBstd::allocator\fP< _CharT > > \fBto_string\fP () const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP (_CharT __zero, _CharT __one=_CharT('1')) const "
.br
.ti -1c
.RI "template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > \fBto_string\fP () const "
.br
.ti -1c
.RI "unsigned long \fBto_ulong\fP () const "
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_flip\fP (size_t __pos)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_reset\fP (size_t __pos)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_set\fP (size_t __pos, int __val)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fB_Unchecked_set\fP (size_t __pos)"
.br
.ti -1c
.RI "bool \fB_Unchecked_test\fP (size_t __pos) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBbitset\fP< _Nb > &__rhs) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator&=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator^=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator|=\fP (const \fBbitset\fP< _Nb > &__rhs)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator<<\fP (size_t __position) const "
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > \fBoperator>>\fP (size_t __position) const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator<<=\fP (size_t __position)"
.br
.ti -1c
.RI "\fBbitset\fP< _Nb > & \fBoperator>>=\fP (size_t __position)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "bool \fBoperator[]\fP (size_t __position) const "
.br
.ti -1c
.RI "\fBreference\fP \fBoperator[]\fP (size_t __position)"
.br
.in -1c
.in -1c
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef unsigned long \fB_WordT\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "size_t \fB_M_are_all_aux\fP () const"
.br
.ti -1c
.RI "void \fB_M_do_and\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "size_t \fB_M_do_count\fP () const"
.br
.ti -1c
.RI "size_t \fB_M_do_find_first\fP (size_t __not_found) const"
.br
.ti -1c
.RI "size_t \fB_M_do_find_next\fP (size_t __prev, size_t __not_found) const"
.br
.ti -1c
.RI "void \fB_M_do_flip\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_left_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_or\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "void \fB_M_do_reset\fP ()"
.br
.ti -1c
.RI "void \fB_M_do_right_shift\fP (size_t __shift)"
.br
.ti -1c
.RI "void \fB_M_do_set\fP ()"
.br
.ti -1c
.RI "unsigned long \fB_M_do_to_ulong\fP () const"
.br
.ti -1c
.RI "void \fB_M_do_xor\fP (const \fB_Base_bitset\fP< _Nw > &__x)"
.br
.ti -1c
.RI "_WordT \fB_M_getword\fP (size_t __pos) const"
.br
.ti -1c
.RI "_WordT & \fB_M_getword\fP (size_t __pos)"
.br
.ti -1c
.RI "_WordT \fB_M_hiword\fP () const"
.br
.ti -1c
.RI "_WordT & \fB_M_hiword\fP ()"
.br
.ti -1c
.RI "bool \fB_M_is_any\fP () const"
.br
.ti -1c
.RI "bool \fB_M_is_equal\fP (const \fB_Base_bitset\fP< _Nw > &__x) const"
.br
.in -1c
.SS "Static Private Member Functions"

.in +1c
.ti -1c
.RI "static _WordT \fB_S_maskbit\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichbit\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichbyte\fP (size_t __pos)"
.br
.ti -1c
.RI "static size_t \fB_S_whichword\fP (size_t __pos)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "_WordT \fB_M_w\fP [_Nw]"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBreference\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<size_t _Nb> class std::bitset< _Nb >"
The bitset class represents a \fIfixed-size\fP sequence of bits. 

(Note that bitset does \fInot\fP meet the formal requirements of a \fCcontainer\fP. Mainly, it lacks iterators.)
.PP
The template argument, \fINb\fP, may be any non-negative number, specifying the number of bits (e.g., '0', '12', '1024*1024').
.PP
In the general unoptimized case, storage is allocated in word-sized blocks. Let B be the number of bits in a word, then (Nb+(B-1))/B words will be used for storage. B - NbB bits are unused. (They are the high-order bits in the highest word.) It is a class invariant that those unused bits are always zero.
.PP
If you think of bitset as 'a simple array of bits,' be aware that your mental picture is reversed: a bitset behaves the same way as bits in integers do, with the bit at index 0 in the 'least significant / right-hand' position, and the bit at index Nb-1 in the 'most significant / left-hand' position. Thus, unlike other containers, a bitset's index 'counts from right to left,' to put it very loosely.
.PP
This behavior is preserved when translating to and from strings. For example, the first line of the following program probably prints 'b('a') is 0001100001' on a modern ASCII system.
.PP
.PP
.nf
     #include <bitset>
     #include <iostream>
     #include <sstream>

     using namespace std;

     int main()
     {
         long         a = 'a';
         bitset<10>   b(a);

         cout << 'b('a') is ' << b << endl;

         ostringstream s;
         s << b;
         string  str = s.str();
         cout << 'index 3 in the string is ' << str[3] << ' but\n'
              << 'index 3 in the bitset is ' << b[3] << endl;
     }
.fi
.PP
.PP
Also see: http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt12ch33s02.html for a description of extensions.
.PP
Most of the actual code isn't contained in bitset<> itself, but in the base class \fB_Base_bitset\fP. The base class works with whole words, not with individual bits. This allows us to specialize \fB_Base_bitset\fP for the important special case where the bitset is only a single word.
.PP
Extra confusion can result due to the fact that the storage for \fB_Base_bitset\fP \fIis\fP a regular \fBarray\fP, and is indexed as such. This is carefully encapsulated. 
.PP
Definition at line 646 of file bitset.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<size_t _Nb> \fBstd::bitset\fP< _Nb >::\fBbitset\fP ()\fC [inline]\fP"
.PP
All bits \fBset\fP to zero. 
.PP
Definition at line 736 of file bitset.
.SS "template<size_t _Nb> \fBstd::bitset\fP< _Nb >::\fBbitset\fP (unsigned long __val)\fC [inline]\fP"
.PP
Initial bits bitwise-copied from a single word (others \fBset\fP to zero). 
.PP
Definition at line 740 of file bitset.
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::bitset\fP< _Nb >::\fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > & __s, size_t __position = \fC0\fP)\fC [inline, explicit]\fP"
.PP
Use a subset of a string. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A string of '0' and '1' characters. 
.br
\fIposition\fP Index of the first character in \fIs\fP to use; defaults to zero. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of \fIs\fP. 
.br
\fI\fBstd::invalid_argument\fP\fP If a character appears in the string which is neither '0' nor '1'. 
.RE
.PP

.PP
Definition at line 755 of file bitset.
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::bitset\fP< _Nb >::\fBbitset\fP (const \fBstd::basic_string\fP< _CharT, _Traits, _Alloc > & __s, size_t __position, size_t __n)\fC [inline]\fP"
.PP
Use a subset of a string. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A string of '0' and '1' characters. 
.br
\fIposition\fP Index of the first character in \fIs\fP to use. 
.br
\fIn\fP The number of characters to copy. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of \fIs\fP. 
.br
\fI\fBstd::invalid_argument\fP\fP If a character appears in the string which is neither '0' nor '1'. 
.RE
.PP

.PP
Definition at line 777 of file bitset.
.SH "Member Function Documentation"
.PP 
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::_Unchecked_flip (size_t __pos)\fC [inline]\fP"
.PP
These versions of single-bit \fBset\fP, reset, flip, and test are extensions from the SGI version. They do no range checking. 
.PP
Definition at line 896 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::_Unchecked_reset (size_t __pos)\fC [inline]\fP"
.PP
These versions of single-bit \fBset\fP, reset, flip, and test are extensions from the SGI version. They do no range checking. 
.PP
Definition at line 889 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::_Unchecked_set (size_t __pos, int __val)\fC [inline]\fP"
.PP
These versions of single-bit \fBset\fP, reset, flip, and test are extensions from the SGI version. They do no range checking. 
.PP
Definition at line 879 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::_Unchecked_test (size_t __pos) const\fC [inline]\fP"
.PP
These versions of single-bit \fBset\fP, reset, flip, and test are extensions from the SGI version. They do no range checking. 
.PP
Definition at line 903 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::all () const\fC [inline]\fP"
.PP
Tests whether all the bits are on. 
.PP
\fBReturns:\fP
.RS 4
True if all the bits are \fBset\fP. 
.RE
.PP

.PP
Definition at line 1170 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::any () const\fC [inline]\fP"
.PP
Tests whether any of the bits are on. 
.PP
\fBReturns:\fP
.RS 4
True if at least one bit is \fBset\fP. 
.RE
.PP

.PP
Definition at line 1178 of file bitset.
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::count () const\fC [inline]\fP"
.PP
Returns the number of bits which are \fBset\fP. 
.PP
Definition at line 1130 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::flip (size_t __position)\fC [inline]\fP"
.PP
Toggles a given bit to its opposite value. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 976 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::flip ()\fC [inline]\fP"
.PP
Toggles every bit to its opposite value. 
.PP
Definition at line 963 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::none () const\fC [inline]\fP"
.PP
Tests whether any of the bits are on. 
.PP
\fBReturns:\fP
.RS 4
True if none of the bits are \fBset\fP. 
.RE
.PP

.PP
Definition at line 1186 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator!= (const \fBbitset\fP< _Nb > & __rhs) const\fC [inline]\fP"
.PP
These comparisons for equality/inequality are, well, \fIbitwise\fP. 
.PP
Definition at line 1145 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator&= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 810 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator<< (size_t __position) const\fC [inline]\fP"
.PP
Self-explanatory. 
.PP
Definition at line 1192 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator<<= (size_t __position)\fC [inline]\fP"
.PP
Operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The number of places to shift.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 839 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator== (const \fBbitset\fP< _Nb > & __rhs) const\fC [inline]\fP"
.PP
These comparisons for equality/inequality are, well, \fIbitwise\fP. 
.PP
Definition at line 1141 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator>> (size_t __position) const\fC [inline]\fP"
.PP
Self-explanatory. 
.PP
Definition at line 1196 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator>>= (size_t __position)\fC [inline]\fP"
.PP
Operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The number of places to shift.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 852 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::operator[] (size_t __position) const\fC [inline]\fP"
.PP
Array-indexing support. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Index into the bitset. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool for a 'const bitset'. For non-const bitsets, an instance of the \fBreference\fP proxy class. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.
.RE
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but does not do the range-checking required by that DR's resolution. -pme The DR has since been changed: range-checking is a precondition (users' responsibility), and these functions must not throw. -pme 
.PP
Definition at line 1008 of file bitset.
.SS "template<size_t _Nb> \fBreference\fP \fBstd::bitset\fP< _Nb >::operator[] (size_t __position)\fC [inline]\fP"
.PP
Array-indexing support. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Index into the bitset. 
.RE
.PP
\fBReturns:\fP
.RS 4
A bool for a 'const bitset'. For non-const bitsets, an instance of the \fBreference\fP proxy class. 
.RE
.PP
\fBNote:\fP
.RS 4
These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.
.RE
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but does not do the range-checking required by that DR's resolution. -pme The DR has since been changed: range-checking is a precondition (users' responsibility), and these functions must not throw. -pme 
.PP
Definition at line 1004 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator^= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 824 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::operator|= (const \fBbitset\fP< _Nb > & __rhs)\fC [inline]\fP"
.PP
Operations on bitsets. 
.PP
\fBParameters:\fP
.RS 4
\fIrhs\fP A same-sized \fBbitset\fP.
.RE
.PP
These should be self-explanatory. 
.PP
Definition at line 817 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb> \fBstd::bitset\fP< _Nb >::operator~ () const\fC [inline]\fP"
.PP
See the no-argument \fBflip()\fP. 
.PP
Definition at line 985 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::reset (size_t __position)\fC [inline]\fP"
.PP
Sets a given bit to false. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set.
.RE
.PP
Same as writing \fCset(pos,false)\fP. 
.PP
Definition at line 952 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::reset ()\fC [inline]\fP"
.PP
Sets every bit to false. 
.PP
Definition at line 938 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::\fBset\fP (size_t __position, bool __val = \fCtrue\fP)\fC [inline]\fP"
.PP
Sets a given bit to a particular value. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The index of the bit. 
.br
\fIval\fP Either true or false, defaults to true. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 927 of file bitset.
.SS "template<size_t _Nb> \fBbitset\fP<_Nb>& \fBstd::bitset\fP< _Nb >::\fBset\fP ()\fC [inline]\fP"
.PP
Sets every bit to true. 
.PP
Definition at line 913 of file bitset.
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::size () const\fC [inline]\fP"
.PP
Returns the total number of bits. 
.PP
Definition at line 1135 of file bitset.
.SS "template<size_t _Nb> bool \fBstd::bitset\fP< _Nb >::test (size_t __position) const\fC [inline]\fP"
.PP
Tests the value of a bit. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP The index of a bit. 
.RE
.PP
\fBReturns:\fP
.RS 4
The value at \fIpos\fP. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIpos\fP is bigger the size of the set. 
.RE
.PP

.PP
Definition at line 1156 of file bitset.
.SS "template<size_t _Nb> template<class _CharT , class _Traits , class _Alloc > \fBstd::basic_string\fP<_CharT, _Traits, _Alloc> \fBstd::bitset\fP< _Nb >::to_string () const\fC [inline]\fP"
.PP
Returns a character interpretation of the bitset. 
.PP
\fBReturns:\fP
.RS 4
The string equivalent of the bits.
.RE
.PP
Note the ordering of the bits: decreasing character positions correspond to increasing bit positions (see the main class notes for an example). 
.PP
Definition at line 1032 of file bitset.
.SS "template<size_t _Nb> unsigned long \fBstd::bitset\fP< _Nb >::to_ulong () const\fC [inline]\fP"
.PP
Returns a numerical interpretation of the bitset. 
.PP
\fBReturns:\fP
.RS 4
The integral equivalent of the bits. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::overflow_error\fP\fP If there are too many bits to be represented in an \fCunsigned\fP \fClong\fP. 
.RE
.PP

.PP
Definition at line 1019 of file bitset.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
