.TH "__gnu_debug" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug \- GNU debug classes for public use.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB__is_same\fP"
.br
.ti -1c
.RI "class \fB_After_nth_from\fP"
.br
.ti -1c
.RI "class \fB_Not_equal_to\fP"
.br
.ti -1c
.RI "class \fB_Safe_iterator\fP"
.br
.RI "\fISafe iterator wrapper. \fP"
.ti -1c
.RI "class \fB_Safe_iterator_base\fP"
.br
.RI "\fIBasic functionality for a 'safe' iterator. \fP"
.ti -1c
.RI "class \fB_Safe_sequence\fP"
.br
.RI "\fIBase class for constructing a 'safe' sequence type that tracks iterators that reference it. \fP"
.ti -1c
.RI "class \fB_Safe_sequence_base\fP"
.br
.RI "\fIBase class that supports tracking of iterators that reference a sequence. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef basic_string< char > \fBstring\fP"
.br
.ti -1c
.RI "typedef basic_string< wchar_t > \fBwstring\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_Debug_msg_id\fP { \fB__msg_valid_range\fP, \fB__msg_insert_singular\fP, \fB__msg_insert_different\fP, \fB__msg_erase_bad\fP, \fB__msg_erase_different\fP, \fB__msg_subscript_oob\fP, \fB__msg_empty\fP, \fB__msg_unpartitioned\fP, \fB__msg_unpartitioned_pred\fP, \fB__msg_unsorted\fP, \fB__msg_unsorted_pred\fP, \fB__msg_not_heap\fP, \fB__msg_not_heap_pred\fP, \fB__msg_bad_bitset_write\fP, \fB__msg_bad_bitset_read\fP, \fB__msg_bad_bitset_flip\fP, \fB__msg_self_splice\fP, \fB__msg_splice_alloc\fP, \fB__msg_splice_bad\fP, \fB__msg_splice_other\fP, \fB__msg_splice_overlap\fP, \fB__msg_init_singular\fP, \fB__msg_init_copy_singular\fP, \fB__msg_init_const_singular\fP, \fB__msg_copy_singular\fP, \fB__msg_bad_deref\fP, \fB__msg_bad_inc\fP, \fB__msg_bad_dec\fP, \fB__msg_iter_subscript_oob\fP, \fB__msg_advance_oob\fP, \fB__msg_retreat_oob\fP, \fB__msg_iter_compare_bad\fP, \fB__msg_compare_different\fP, \fB__msg_iter_order_bad\fP, \fB__msg_order_different\fP, \fB__msg_distance_bad\fP, \fB__msg_distance_different\fP, \fB__msg_deref_istream\fP, \fB__msg_inc_istream\fP, \fB__msg_output_ostream\fP, \fB__msg_deref_istreambuf\fP, \fB__msg_inc_istreambuf\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fB__check_dereferenceable\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__x)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fB__check_dereferenceable\fP (const _Tp *__ptr)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fB__check_dereferenceable\fP (_Iterator &)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Pred > bool \fB__check_partitioned_lower\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Pred __pred)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > bool \fB__check_partitioned_lower\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Pred > bool \fB__check_partitioned_upper\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value, _Pred __pred)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > bool \fB__check_partitioned_upper\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__value)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fB__check_singular\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__x)"
.br
.ti -1c
.RI "template<typename _Tp > bool \fB__check_singular\fP (const _Tp *__ptr)"
.br
.ti -1c
.RI "template<typename _Iterator > bool \fB__check_singular\fP (_Iterator &__x)"
.br
.ti -1c
.RI "bool \fB__check_singular_aux\fP (const \fB_Safe_iterator_base\fP *__x)"
.br
.ti -1c
.RI "bool \fB__check_singular_aux\fP (const void *)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fB__check_sorted\fP (const _InputIterator &__first, const _InputIterator &__last, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__check_sorted\fP (const _InputIterator &__first, const _InputIterator &__last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Predicate > bool \fB__check_sorted_aux\fP (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fB__check_sorted_aux\fP (const _InputIterator &, const _InputIterator &, _Predicate, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > bool \fB__check_sorted_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__check_sorted_aux\fP (const _InputIterator &, const _InputIterator &, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _Predicate > bool \fB__check_sorted_set\fP (const _InputIterator1 &__first, const _InputIterator1 &__last, const _InputIterator2 &, _Predicate __pred)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 > bool \fB__check_sorted_set\fP (const _InputIterator1 &__first, const _InputIterator1 &__last, const _InputIterator2 &)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fB__check_sorted_set_aux\fP (const _InputIterator &, const _InputIterator &, _Predicate, std::__false_type)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Predicate > bool \fB__check_sorted_set_aux\fP (const _InputIterator &__first, const _InputIterator &__last, _Predicate __pred, std::__true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__check_sorted_set_aux\fP (const _InputIterator &, const _InputIterator &, std::__false_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__check_sorted_set_aux\fP (const _InputIterator &__first, const _InputIterator &__last, std::__true_type)"
.br
.ti -1c
.RI "template<typename _CharT > const _CharT * \fB__check_string\fP (const _CharT *__s)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Integer > const _CharT * \fB__check_string\fP (const _CharT *__s, const _Integer &__n __attribute__((__unused__)))"
.br
.ti -1c
.RI "template<typename _InputIterator > _InputIterator \fB__check_valid_range\fP (const _InputIterator &__first, const _InputIterator &__last __attribute__((__unused__)))"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fB__valid_range\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__first, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__last)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__valid_range\fP (const _InputIterator &__first, const _InputIterator &__last)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__valid_range_aux\fP (const _InputIterator &__first, const _InputIterator &__last, std::__false_type)"
.br
.ti -1c
.RI "template<typename _Integral > bool \fB__valid_range_aux\fP (const _Integral &, const _Integral &, std::__true_type)"
.br
.ti -1c
.RI "template<typename _InputIterator > bool \fB__valid_range_aux2\fP (const _InputIterator &, const _InputIterator &, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > bool \fB__valid_range_aux2\fP (const _RandomAccessIterator &__first, const _RandomAccessIterator &__last, \fBstd::random_access_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, basic_string< _CharT, _Traits, _Allocator > &__str)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBgetline\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, basic_string< _CharT, _Traits, _Allocator > &__str, _CharT __delim)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator!=\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator!=\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator!=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator!=\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator!=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > \fB_Safe_iterator\fP< _Iterator, _Sequence > \fBoperator+\fP (typename \fB_Safe_iterator\fP< _Iterator, _Sequence >::difference_type __n, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__i)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > basic_string< _CharT, _Traits, _Allocator > \fBoperator+\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, _CharT __rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > basic_string< _CharT, _Traits, _Allocator > \fBoperator+\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > basic_string< _CharT, _Traits, _Allocator > \fBoperator+\fP (_CharT __lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > basic_string< _CharT, _Traits, _Allocator > \fBoperator+\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > basic_string< _CharT, _Traits, _Allocator > \fBoperator+\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > \fB_Safe_iterator\fP< _Iterator, _Sequence >::difference_type \fBoperator-\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > \fB_Safe_iterator\fP< _IteratorL, _Sequence >::difference_type \fBoperator-\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator<\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator<\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > \fBstd::basic_ostream\fP< _CharT, _Traits > & \fBoperator<<\fP (\fBstd::basic_ostream\fP< _CharT, _Traits > &__os, const basic_string< _CharT, _Traits, _Allocator > &__str)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator<=\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator<=\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<=\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator<=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator==\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator==\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator==\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator==\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator==\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator>\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator>\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _Iterator , typename _Sequence > bool \fBoperator>=\fP (const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _Iterator, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _IteratorL , typename _IteratorR , typename _Sequence > bool \fBoperator>=\fP (const \fB_Safe_iterator\fP< _IteratorL, _Sequence > &__lhs, const \fB_Safe_iterator\fP< _IteratorR, _Sequence > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const _CharT *__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>=\fP (const _CharT *__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > bool \fBoperator>=\fP (const basic_string< _CharT, _Traits, _Allocator > &__lhs, const basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > \fBstd::basic_istream\fP< _CharT, _Traits > & \fBoperator>>\fP (\fBstd::basic_istream\fP< _CharT, _Traits > &__is, basic_string< _CharT, _Traits, _Allocator > &__str)"
.br
.ti -1c
.RI "template<typename _CharT , typename _Traits , typename _Allocator > void \fBswap\fP (basic_string< _CharT, _Traits, _Allocator > &__lhs, basic_string< _CharT, _Traits, _Allocator > &__rhs)"
.br
.in -1c
.SH "Detailed Description"
.PP 
GNU debug classes for public use. 
.PP
.SH "Function Documentation"
.PP 
.SS "template<typename _Iterator , typename _Sequence > bool __gnu_debug::__check_dereferenceable (const _Safe_iterator< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Safe iterators know if they are singular. 
.PP
Definition at line 82 of file functions.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable().
.SS "template<typename _Tp > bool __gnu_debug::__check_dereferenceable (const _Tp * __ptr)\fC [inline]\fP"
.PP
Non-NULL pointers are dereferenceable. 
.PP
Definition at line 76 of file functions.h.
.SS "template<typename _Iterator > bool __gnu_debug::__check_dereferenceable (_Iterator &)\fC [inline]\fP"
.PP
Assume that some arbitrary iterator is dereferenceable, because we can't prove that it isn't. 
.PP
Definition at line 70 of file functions.h.
.SS "template<typename _Iterator , typename _Sequence > bool __gnu_debug::__check_singular (const _Safe_iterator< _Iterator, _Sequence > & __x)\fC [inline]\fP"
.PP
Safe iterators know if they are singular. 
.PP
Definition at line 63 of file functions.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _Tp > bool __gnu_debug::__check_singular (const _Tp * __ptr)\fC [inline]\fP"
.PP
Non-NULL pointers are nonsingular. 
.PP
Definition at line 57 of file functions.h.
.SS "bool __gnu_debug::__check_singular_aux (const _Safe_iterator_base * __x)\fC [inline]\fP"
.PP
Iterators that derive from \fB_Safe_iterator_base\fP but that aren't _Safe_iterators can be determined singular or non-singular via \fB_Safe_iterator_base\fP. 
.PP
Definition at line 48 of file safe_iterator.h.
.PP
References __gnu_debug::_Safe_iterator_base::_M_singular().
.SS "template<typename _CharT > const _CharT* __gnu_debug::__check_string (const _CharT * __s)\fC [inline]\fP"
.PP
Checks that __s is non-NULL and then returns __s. 
.PP
Definition at line 176 of file functions.h.
.SS "template<typename _CharT , typename _Integer > const _CharT* __gnu_debug::__check_string (const _CharT * __s, const _Integer &__n  __attribute__(__unused__))\fC [inline]\fP"
.PP
Checks that __s is non-NULL or __n == 0, and then returns __s. 
.PP
Definition at line 164 of file functions.h.
.SS "template<typename _Iterator , typename _Sequence > bool __gnu_debug::__valid_range (const _Safe_iterator< _Iterator, _Sequence > & __first, const _Safe_iterator< _Iterator, _Sequence > & __last)\fC [inline]\fP"
.PP
Safe iterators know how to check if they form a valid range. 
.PP
Definition at line 143 of file functions.h.
.PP
References __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_valid_range().
.SS "template<typename _InputIterator > bool __gnu_debug::__valid_range (const _InputIterator & __first, const _InputIterator & __last)\fC [inline]\fP"
.PP
Don't know what these iterators are, or if they are even iterators (we may get an integral type for InputIterator), so see if they are integral and pass them on to the next phase otherwise. 
.PP
Definition at line 134 of file functions.h.
.PP
References __valid_range_aux().
.SS "template<typename _InputIterator > bool __gnu_debug::__valid_range_aux (const _InputIterator & __first, const _InputIterator & __last, std::__false_type)\fC [inline]\fP"
.PP
We have iterators, so figure out what kind of iterators that are to see if we can check the range ahead of time. 
.PP
Definition at line 119 of file functions.h.
.PP
References __valid_range_aux2().
.SS "template<typename _Integral > bool __gnu_debug::__valid_range_aux (const _Integral &, const _Integral &, std::__true_type)\fC [inline]\fP"
.PP
We say that integral types for a valid range, and defer to other routines to realize what to do with integral types instead of iterators. 
.PP
Definition at line 111 of file functions.h.
.PP
Referenced by __valid_range().
.SS "template<typename _InputIterator > bool __gnu_debug::__valid_range_aux2 (const _InputIterator &, const _InputIterator &, \fBstd::input_iterator_tag\fP)\fC [inline]\fP"
.PP
Can't test for a valid range with input iterators, because iteration may be destructive. So we just assume that the range is valid. 
.PP
Definition at line 101 of file functions.h.
.SS "template<typename _RandomAccessIterator > bool __gnu_debug::__valid_range_aux2 (const _RandomAccessIterator & __first, const _RandomAccessIterator & __last, \fBstd::random_access_iterator_tag\fP)\fC [inline]\fP"
.PP
If the distance between two random access iterators is nonnegative, assume the range is valid. 
.PP
Definition at line 90 of file functions.h.
.PP
Referenced by __valid_range_aux().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
