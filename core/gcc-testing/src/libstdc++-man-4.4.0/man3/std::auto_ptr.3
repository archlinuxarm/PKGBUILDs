.TH "std::auto_ptr" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::auto_ptr \- A simple smart pointer providing strict ownership semantics.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Tp \fBelement_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBauto_ptr\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP > __ref)  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBauto_ptr\fP (\fBauto_ptr\fP< _Tp1 > &__a)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP (\fBauto_ptr\fP &__a)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP (\fBelement_type\fP *__p=0)  throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBget\fP () const   throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBoperator auto_ptr< _Tp1 >\fP ()  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBoperator auto_ptr_ref< _Tp1 >\fP ()  throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP & \fBoperator*\fP () const   throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBoperator->\fP () const   throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP > __ref)  throw ()"
.br
.ti -1c
.RI "template<typename _Tp1 > \fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr\fP< _Tp1 > &__a)  throw ()"
.br
.ti -1c
.RI "\fBauto_ptr\fP & \fBoperator=\fP (\fBauto_ptr\fP &__a)  throw ()"
.br
.ti -1c
.RI "\fBelement_type\fP * \fBrelease\fP ()  throw ()"
.br
.ti -1c
.RI "void \fBreset\fP (\fBelement_type\fP *__p=0)  throw ()"
.br
.ti -1c
.RI "\fB~auto_ptr\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp> class std::auto_ptr< _Tp >"
A simple smart pointer providing strict ownership semantics. 

The Standard says: 
.PP
.nf

  An \fC\fBauto_ptr\fP\fP owns the object it holds a pointer to.  Copying
  an \fC\fBauto_ptr\fP\fP copies the pointer and transfers ownership to the
  destination.  If more than one \fC\fBauto_ptr\fP\fP owns the same object
  at the same time the behavior of the program is undefined.
.fi
.PP
.PP
.PP
.nf
  The uses of \fC\fBauto_ptr\fP\fP include providing temporary
  exception-safety for dynamically allocated memory, passing
  ownership of dynamically allocated memory to a function, and
  returning dynamically allocated memory from a function.  \fC\fBauto_ptr\fP\fP does not meet the CopyConstructible and Assignable
  requirements for Standard Library \fCcontainer\fP elements and thus
  instantiating a Standard Library container with an \fC\fBauto_ptr\fP\fP results in undefined behavior.
  
.fi
.PP
 Quoted from [20.4.5]/3.
.PP
Good examples of what can and cannot be done with \fBauto_ptr\fP can be found in the libstdc++ testsuite.
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS 127. auto_ptr<> conversion issues These resolutions have all been incorporated. 
.PP
Definition at line 85 of file auto_ptr.h.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _Tp> typedef _Tp \fBstd::auto_ptr\fP< _Tp >::\fBelement_type\fP"
.PP
The pointed-to type. 
.PP
Definition at line 92 of file auto_ptr.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBelement_type\fP * __p = \fC0\fP)  throw ()\fC [inline, explicit]\fP"
.PP
An auto_ptr is usually constructed from a raw pointer. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP A pointer (defaults to NULL).
.RE
.PP
This object now \fIowns\fP the object pointed to by \fIp\fP. 
.PP
Definition at line 101 of file auto_ptr.h.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr\fP< _Tp > & __a)  throw ()\fC [inline]\fP"
.PP
An auto_ptr can be constructed from another auto_ptr. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Another auto_ptr of the same type.
.RE
.PP
This object now \fIowns\fP the object previously owned by \fIa\fP, which has given up ownership. 
.PP
Definition at line 110 of file auto_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr\fP< _Tp1 > & __a)  throw ()\fC [inline]\fP"
.PP
An auto_ptr can be constructed from another auto_ptr. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Another auto_ptr of a different but related type.
.RE
.PP
A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.
.PP
This object now \fIowns\fP the object previously owned by \fIa\fP, which has given up ownership. 
.PP
Definition at line 123 of file auto_ptr.h.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::~\fBauto_ptr\fP ()\fC [inline]\fP"
.PP
When the auto_ptr goes out of scope, the object it owns is deleted. If it no longer owns anything (i.e., \fC\fBget()\fP\fP is \fCNULL\fP), then this has no effect.
.PP
The C++ standard says there is supposed to be an empty throw specification here, but omitting it is standard conforming. Its presence can be detected only if _Tp::~_Tp() throws, but this is prohibited. [17.4.3.6]/2 
.PP
Definition at line 168 of file auto_ptr.h.
.SS "template<typename _Tp> \fBstd::auto_ptr\fP< _Tp >::\fBauto_ptr\fP (\fBauto_ptr_ref\fP< \fBelement_type\fP > __ref)  throw ()\fC [inline]\fP"
.PP
Automatic conversions. 
.PP
These operations convert an auto_ptr into and from an \fBauto_ptr_ref\fP automatically as needed. This allows constructs such as 
.PP
.nf
    auto_ptr<Derived>  func_returning_auto_ptr(.....);
    ...
    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);

.fi
.PP
 
.PP
Definition at line 258 of file auto_ptr.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::get (void) const  throw ()\fC [inline]\fP"
.PP
Bypassing the smart pointer. 
.PP
\fBReturns:\fP
.RS 4
The raw pointer being managed.
.RE
.PP
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.
.PP
\fBNote:\fP
.RS 4
This auto_ptr still owns the memory. 
.RE
.PP

.PP
Definition at line 209 of file auto_ptr.h.
.SS "template<typename _Tp> \fBelement_type\fP& \fBstd::auto_ptr\fP< _Tp >::operator* () const  throw ()\fC [inline]\fP"
.PP
Smart pointer dereferencing. 
.PP
If this auto_ptr no longer owns anything, then this operation will crash. (For a smart pointer, 'no longer owns anything' is the same as being a null pointer, and you know what happens when you dereference one of those...) 
.PP
Definition at line 179 of file auto_ptr.h.
.PP
References std::operator*().
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::operator-> () const  throw ()\fC [inline]\fP"
.PP
Smart pointer dereferencing. 
.PP
This returns the pointer itself, which the language then will automatically cause to be dereferenced. 
.PP
Definition at line 192 of file auto_ptr.h.
.SS "template<typename _Tp> template<typename _Tp1 > \fBauto_ptr\fP& \fBstd::auto_ptr\fP< _Tp >::operator= (\fBauto_ptr\fP< _Tp1 > & __a)  throw ()\fC [inline]\fP"
.PP
auto_ptr assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Another auto_ptr of a different but related type.
.RE
.PP
A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.
.PP
This object now \fIowns\fP the object previously owned by \fIa\fP, which has given up ownership. The object that this one \fIused\fP to own and track has been deleted. 
.PP
Definition at line 152 of file auto_ptr.h.
.SS "template<typename _Tp> \fBauto_ptr\fP& \fBstd::auto_ptr\fP< _Tp >::operator= (\fBauto_ptr\fP< _Tp > & __a)  throw ()\fC [inline]\fP"
.PP
auto_ptr assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP Another auto_ptr of the same type.
.RE
.PP
This object now \fIowns\fP the object previously owned by \fIa\fP, which has given up ownership. The object that this one \fIused\fP to own and track has been deleted. 
.PP
Definition at line 134 of file auto_ptr.h.
.SS "template<typename _Tp> \fBelement_type\fP* \fBstd::auto_ptr\fP< _Tp >::release ()  throw ()\fC [inline]\fP"
.PP
Bypassing the smart pointer. 
.PP
\fBReturns:\fP
.RS 4
The raw pointer being managed.
.RE
.PP
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.
.PP
\fBNote:\fP
.RS 4
This auto_ptr no longer owns the memory. When this object goes out of scope, nothing will happen. 
.RE
.PP

.PP
Definition at line 223 of file auto_ptr.h.
.SS "template<typename _Tp> void \fBstd::auto_ptr\fP< _Tp >::reset (\fBelement_type\fP * __p = \fC0\fP)  throw ()\fC [inline]\fP"
.PP
Forcibly deletes the managed object. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP A pointer (defaults to NULL).
.RE
.PP
This object now \fIowns\fP the object pointed to by \fIp\fP. The previous object has been deleted. 
.PP
Definition at line 238 of file auto_ptr.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
