.TH "Binder Classes" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Binder Classes \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBstd::binder1st< _Operation >\fP"
.br
.RI "\fIOne of the \fBbinder functors\fP. \fP"
.ti -1c
.RI "class \fBstd::binder2nd< _Operation >\fP"
.br
.RI "\fIOne of the \fBbinder functors\fP. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _Operation , typename _Tp > binder1st< _Operation > \fBstd::bind1st\fP (const _Operation &__fn, const _Tp &__x)"
.br
.ti -1c
.RI "template<typename _Operation , typename _Tp > binder2nd< _Operation > \fBstd::bind2nd\fP (const _Operation &__fn, const _Tp &__x)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "struct \fBstd::auto_ptr_ref\fP \fBstd::_GLIBCXX_DEPRECATED_ATTR\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Binders turn functions/functors with two arguments into functors with a single argument, storing an argument to be applied later. For example, a variable \fCB\fP of type \fC\fBbinder1st\fP\fP is constructed from a functor \fCf\fP and an argument \fCx\fP. Later, B's \fCoperator()\fP is called with a single argument \fCy\fP. The return value is the value of \fCf(x,y)\fP. \fCB\fP can be 'called' with various arguments (y1, y2, ...) and will in turn call \fCf(x,y1)\fP, \fCf(x,y2)\fP, ...
.PP
The function \fCbind1st\fP is provided to save some typing. It takes the function and an argument as parameters, and returns an instance of \fC\fBbinder1st\fP\fP.
.PP
The type \fC\fBbinder2nd\fP\fP and its creator function \fCbind2nd\fP do the same thing, but the stored argument is passed as the second parameter instead of the first, e.g., \fCbind2nd\fP(std::minus<float>,1.3) will create a functor whose \fCoperator()\fP accepts a floating-point number, subtracts 1.3 from it, and returns the result. (If \fCbind1st\fP had been used, the functor would perform '1.3 - x' instead.
.PP
Creator-wrapper functions like \fCbind1st\fP are intended to be used in calling algorithms. Their return values will be temporary objects. (The goal is to not require you to type names like \fC\fBstd::binder1st\fP<std::plus<int>>\fP for declaring a variable to hold the return value from \fCbind1st(std::plus<int>,5)\fP.
.PP
These become more useful when combined with the composition functions. 
.SH "Function Documentation"
.PP 
.SS "template<typename _Operation , typename _Tp > binder1st<_Operation> std::bind1st (const _Operation & __fn, const _Tp & __x)\fC [inline]\fP"
.PP
One of the \fBbinder functors\fP. 
.PP
Definition at line 124 of file binders.h.
.SS "template<typename _Operation , typename _Tp > binder2nd<_Operation> std::bind2nd (const _Operation & __fn, const _Tp & __x)\fC [inline]\fP"
.PP
One of the \fBbinder functors\fP. 
.PP
Definition at line 159 of file binders.h.
.SH "Variable Documentation"
.PP 
.SS "\fBstd::binder2nd\fP \fBstd::_GLIBCXX_DEPRECATED_ATTR\fP"
.PP
A simple smart pointer providing strict ownership semantics. 
.PP
One of the \fBbinder functors\fP.
.PP
A wrapper class to provide \fBauto_ptr\fP with reference semantics. For example, an \fBauto_ptr\fP can be assigned (or constructed from) the result of a function which returns an \fBauto_ptr\fP by value.
.PP
All the \fBauto_ptr_ref\fP stuff should happen behind the scenes.
.PP
The Standard says: 
.PP
.nf

  An \fC\fBauto_ptr\fP\fP owns the object it holds a pointer to.  Copying
  an \fC\fBauto_ptr\fP\fP copies the pointer and transfers ownership to the
  destination.  If more than one \fC\fBauto_ptr\fP\fP owns the same object
  at the same time the behavior of the program is undefined.
.fi
.PP
.PP
.PP
.nf
  The uses of \fC\fBauto_ptr\fP\fP include providing temporary
  exception-safety for dynamically allocated memory, passing
  ownership of dynamically allocated memory to a function, and
  returning dynamically allocated memory from a function.  \fC\fBauto_ptr\fP\fP does not meet the CopyConstructible and Assignable
  requirements for Standard Library \fCcontainer\fP elements and thus
  instantiating a Standard Library container with an \fC\fBauto_ptr\fP\fP results in undefined behavior.
  
.fi
.PP
 Quoted from [20.4.5]/3.
.PP
Good examples of what can and cannot be done with \fBauto_ptr\fP can be found in the libstdc++ testsuite.
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS 127. auto_ptr<> conversion issues These resolutions have all been incorporated. 
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
