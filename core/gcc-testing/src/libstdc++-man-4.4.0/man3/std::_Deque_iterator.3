.TH "std::_Deque_iterator" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::_Deque_iterator \- A deque::iterator.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Tp ** \fB_Map_pointer\fP"
.br
.ti -1c
.RI "typedef \fB_Deque_iterator\fP \fB_Self\fP"
.br
.ti -1c
.RI "typedef \fB_Deque_iterator\fP< _Tp, const _Tp &, const _Tp * > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_Deque_iterator\fP< _Tp, _Tp &, _Tp * > \fBiterator\fP"
.br
.ti -1c
.RI "typedef \fBstd::random_access_iterator_tag\fP \fBiterator_category\fP"
.br
.ti -1c
.RI "typedef _Ptr \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Ref \fBreference\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Deque_iterator\fP (const \fBiterator\fP &__x)"
.br
.ti -1c
.RI "\fB_Deque_iterator\fP (_Tp *__x, _Map_pointer __y)"
.br
.ti -1c
.RI "void \fB_M_set_node\fP (_Map_pointer __new_node)"
.br
.ti -1c
.RI "reference \fBoperator*\fP () const "
.br
.ti -1c
.RI "\fB_Self\fP \fBoperator+\fP (difference_type __n) const "
.br
.ti -1c
.RI "\fB_Self\fP \fBoperator++\fP (int)"
.br
.ti -1c
.RI "\fB_Self\fP & \fBoperator++\fP ()"
.br
.ti -1c
.RI "\fB_Self\fP & \fBoperator+=\fP (difference_type __n)"
.br
.ti -1c
.RI "\fB_Self\fP \fBoperator-\fP (difference_type __n) const "
.br
.ti -1c
.RI "\fB_Self\fP \fBoperator--\fP (int)"
.br
.ti -1c
.RI "\fB_Self\fP & \fBoperator--\fP ()"
.br
.ti -1c
.RI "\fB_Self\fP & \fBoperator-=\fP (difference_type __n)"
.br
.ti -1c
.RI "pointer \fBoperator->\fP () const "
.br
.ti -1c
.RI "reference \fBoperator[]\fP (difference_type __n) const "
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static size_t \fB_S_buffer_size\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "_Tp * \fB_M_cur\fP"
.br
.ti -1c
.RI "_Tp * \fB_M_first\fP"
.br
.ti -1c
.RI "_Tp * \fB_M_last\fP"
.br
.ti -1c
.RI "_Map_pointer \fB_M_node\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Ref, typename _Ptr> struct std::_Deque_iterator< _Tp, _Ref, _Ptr >"
A deque::iterator. 

Quite a bit of intelligence here. Much of the functionality of \fBdeque\fP is actually passed off to this class. A \fBdeque\fP holds two of these internally, marking its valid range. Access to elements is done as offsets of either of those two, relying on operator overloading in this class.
.PP
All the functions are op overloads except for _M_set_node. 
.PP
Definition at line 94 of file stl_deque.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Ref, typename _Ptr> void \fBstd::_Deque_iterator\fP< _Tp, _Ref, _Ptr >::_M_set_node (_Map_pointer __new_node)\fC [inline]\fP"
.PP
Prepares to traverse new_node. Sets everything except _M_cur, which should therefore be \fBset\fP by the caller immediately afterwards, based on _M_first and _M_last. 
.PP
Definition at line 222 of file stl_deque.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
