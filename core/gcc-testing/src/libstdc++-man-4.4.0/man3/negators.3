.TH "Negators" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Negators \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBstd::binary_negate< _Predicate >\fP"
.br
.RI "\fIOne of the \fBnegation functors\fP. \fP"
.ti -1c
.RI "class \fBstd::unary_negate< _Predicate >\fP"
.br
.RI "\fIOne of the \fBnegation functors\fP. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _Predicate > unary_negate< _Predicate > \fBstd::not1\fP (const _Predicate &__pred)"
.br
.ti -1c
.RI "template<typename _Predicate > binary_negate< _Predicate > \fBstd::not2\fP (const _Predicate &__pred)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The functions \fCnot1\fP and \fCnot2\fP each take a predicate functor and return an instance of \fC\fBunary_negate\fP\fP or \fC\fBbinary_negate\fP\fP, respectively. These classes are functors whose \fCoperator()\fP performs the stored predicate function and then returns the negation of the result.
.PP
For example, given a \fBvector\fP of integers and a trivial predicate, 
.PP
.nf
  struct IntGreaterThanThree
    : public std::unary_function<int, bool>
  {
      bool operator() (int x) { return x > 3; }
  };

  std::find_if (v.begin(), v.end(), not1(IntGreaterThanThree()));

.fi
.PP
 The call to \fCfind_if\fP will locate the first index (i) of \fCv\fP for which '!(v[i] > 3)' is true.
.PP
The not1/unary_negate combination works on predicates taking a single argument. The not2/binary_negate combination works on predicates which take two arguments. 
.SH "Function Documentation"
.PP 
.SS "template<typename _Predicate > unary_negate<_Predicate> std::not1 (const _Predicate & __pred)\fC [inline]\fP"
.PP
One of the \fBnegation functors\fP. 
.PP
Definition at line 364 of file stl_function.h.
.SS "template<typename _Predicate > binary_negate<_Predicate> std::not2 (const _Predicate & __pred)\fC [inline]\fP"
.PP
One of the \fBnegation functors\fP. 
.PP
Definition at line 389 of file stl_function.h.
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
