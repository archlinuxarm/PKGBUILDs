.TH "std::vector" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::vector \- A standard container which offers fixed time access to individual elements in any order.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB_Vector_base< _Tp, _Alloc >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< const_pointer, \fBvector\fP > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< pointer, \fBvector\fP > \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< iterator > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "const_iterator \fBbegin\fP () const "
.br
.ti -1c
.RI "iterator \fBbegin\fP ()"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const "
.br
.ti -1c
.RI "const_pointer \fBdata\fP () const "
.br
.ti -1c
.RI "pointer \fBdata\fP ()"
.br
.ti -1c
.RI "template<typename... _Args> iterator \fBemplace\fP (iterator __position, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace_back\fP (_Args &&...__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "const_iterator \fBend\fP () const "
.br
.ti -1c
.RI "iterator \fBend\fP ()"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (iterator __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, value_type &&__x)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const value_type &__x)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (\fBvector\fP &&__x)"
.br
.ti -1c
.RI "\fBvector\fP & \fBoperator=\fP (const \fBvector\fP &__x)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, value_type __x=value_type())"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBvector\fP &&__x)"
.br
.ti -1c
.RI "template<typename _InputIterator > \fBvector\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBvector\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBvector\fP (\fBvector\fP &&__x)"
.br
.ti -1c
.RI "\fBvector\fP (const \fBvector\fP &__x)"
.br
.ti -1c
.RI "\fBvector\fP (size_type __n, const value_type &__value=value_type(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBvector\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBvector\fP ()"
.br
.ti -1c
.RI "\fB~vector\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "_Tp_alloc_type::pointer \fB_M_allocate\fP (size_t __n)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > pointer \fB_M_allocate_and_copy\fP (size_type __n, _ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "size_type \fB_M_check_len\fP (size_type __n, const char *__s) const "
.br
.ti -1c
.RI "void \fB_M_deallocate\fP (typename _Tp_alloc_type::pointer __p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (pointer __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const value_type &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (iterator __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP ()"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __value, __true_type)"
.br
.ti -1c
.RI "template<typename... _Args> void \fB_M_insert_aux\fP (iterator __position, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_dispatch\fP (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_insert_dispatch\fP (iterator __pos, _Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const "
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_insert\fP (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_insert\fP (iterator __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Vector_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> class std::vector< _Tp, _Alloc >"
A standard container which offers fixed time access to individual elements in any order. 

Meets the requirements of a \fCcontainer\fP, a \fCreversible container\fP, and a \fCsequence\fP, including the \fCoptional sequence requirements\fP with the exception of \fCpush_front\fP and \fCpop_front\fP.
.PP
In some terminology a vector can be described as a dynamic C-style \fBarray\fP, it offers fast and efficient access to individual elements in any order and saves the user from worrying about memory and size allocation. Subscripting ( \fC\fP[] ) access is also provided as with C-style arrays. 
.PP
Definition at line 170 of file stl_vector.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP ()\fC [inline]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 207 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (const allocator_type & __a)\fC [inline, explicit]\fP"
.PP
Creates a vector with no elements. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP An \fBallocator\fP object. 
.RE
.PP

.PP
Definition at line 215 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (size_type __n, const value_type & __value = \fCvalue_type()\fP, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline, explicit]\fP"
.PP
Creates a vector with copies of an exemplar element. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The number of elements to initially create. 
.br
\fIvalue\fP An element to copy. 
.br
\fIa\fP An \fBallocator\fP.
.RE
.PP
This constructor fills the vector with \fIn\fP copies of \fIvalue\fP. 
.PP
Definition at line 227 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (const \fBvector\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
Vector copy constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created vector uses a copy of the allocation object used by \fIx\fP. All the elements of \fIx\fP are copied, but any extra memory in \fIx\fP (for fast expansion) will not be copied. 
.PP
Definition at line 241 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (\fBvector\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Vector move constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created vector contains the exact contents of \fIx\fP. The contents of \fIx\fP are a valid, but unspecified vector. 
.PP
Definition at line 257 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a vector from an initializer \fBlist\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP. 
.br
\fIa\fP An \fBallocator\fP.
.RE
.PP
Create a vector consisting of copies of the elements in the \fBinitializer_list\fP \fIl\fP.
.PP
This will call the element type's copy constructor N times (where N is \fIl.size()\fP) and do no memory reallocation. 
.PP
Definition at line 271 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > \fBstd::vector\fP< _Tp, _Alloc >::\fBvector\fP (_InputIterator __first, _InputIterator __last, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a vector from a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIa\fP An \fBallocator\fP.
.RE
.PP
Create a vector consisting of copies of the elements from [first,last).
.PP
If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations. 
.PP
Definition at line 297 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::vector\fP< _Tp, _Alloc >::~\fBvector\fP ()\fC [inline]\fP"
.PP
The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 312 of file stl_vector.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _ForwardIterator > pointer \fBstd::vector\fP< _Tp, _Alloc >::_M_allocate_and_copy (size_type __n, _ForwardIterator __first, _ForwardIterator __last)\fC [inline, protected]\fP"
.PP
Memory expansion handler. Uses the member allocation function to obtain \fIn\fP bytes of memory, and then copies [first,last) into it. 
.PP
Definition at line 960 of file stl_vector.h.
.PP
Referenced by std::vector< _Tp, _Alloc >::operator=().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::_M_range_check (size_type __n) const\fC [inline, protected]\fP"
.PP
Safety check used only from \fBat()\fP. 
.PP
Definition at line 631 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Assigns an initializer \fBlist\fP to a vector. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function fills a vector with copies of the elements in the initializer \fBlist\fP \fIl\fP.
.PP
Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 411 of file stl_vector.h.
.PP
Referenced by std::vector< _Node *, _Nodeptr_Alloc >::assign().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::vector\fP< _Tp, _Alloc >::assign (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Assigns a range to a vector. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function fills a vector with copies of the elements in the range [first,last).
.PP
Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 391 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::assign (size_type __n, const value_type & __val)\fC [inline]\fP"
.PP
Assigns a given value to a vector. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements to be assigned. 
.br
\fIval\fP Value to be assigned.
.RE
.PP
This function fills a vector with \fIn\fP copies of the given value. Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 374 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::at (size_type __n) const\fC [inline]\fP"
.PP
Provides access to the data contained in the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference to data. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIn\fP is an invalid index.
.RE
.PP
This function provides for safer data access. The parameter is first checked that it is in the range of the \fBvector\fP. The function throws \fBout_of_range\fP if the check fails. 
.PP
Definition at line 668 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::at (size_type __n)\fC [inline]\fP"
.PP
Provides access to the data contained in the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference to data. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIn\fP is an invalid index.
.RE
.PP
This function provides for safer data access. The parameter is first checked that it is in the range of the \fBvector\fP. The function throws \fBout_of_range\fP if the check fails. 
.PP
Definition at line 650 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the last element of the vector. 
.PP
Definition at line 703 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the last element of the vector. 
.PP
Definition at line 695 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the vector. Iteration is done in ordinary element order. 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 434 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points to the first element in the vector. Iteration is done in ordinary element order. 
.PP
Definition at line 425 of file stl_vector.h.
.PP
Referenced by std::vector< _Tp, _Alloc >::emplace(), std::vector< _Tp, _Alloc >::insert(), __gnu_parallel::multiseq_partition(), __gnu_parallel::multiseq_selection(), __gnu_parallel::multiway_merge_exact_splitting(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), __gnu_parallel::parallel_sort_mwms_pu(), and std::vector< _Node *, _Nodeptr_Alloc >::vector().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::capacity () const\fC [inline]\fP"
.PP
Returns the total number of elements that the vector can hold before needing to allocate more memory. 
.PP
Definition at line 565 of file stl_vector.h.
.PP
Referenced by std::vector< _Tp, _Alloc >::operator=().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the vector. Iteration is done in ordinary element order. 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 498 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the vector. Iteration is done in ordinary element order. 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 507 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP"
.PP
Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 950 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 516 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 525 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> pointer \fBstd::vector\fP< _Tp, _Alloc >::data ()\fC [inline]\fP"
.PP
Returns a pointer such that [\fBdata()\fP, \fBdata()\fP + \fBsize()\fP) is a valid range. For a non-empty vector, \fBdata()\fP == &\fBfront()\fP. 
.PP
Definition at line 714 of file stl_vector.h.
.SS "template<typename _Tp , typename _Alloc > template<typename... _Args> \fBvector\fP< _Tp, _Alloc >::iterator vector::emplace (iterator __position, _Args &&... __args)\fC [inline]\fP"
.PP
Inserts an object in vector before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIargs\fP Arguments. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert an object of type T constructed with T(std::forward<Args>(args)...) before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 272 of file vector.tcc.
.PP
References std::vector< _Tp, _Alloc >::begin(), and std::vector< _Tp, _Alloc >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::vector\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP"
.PP
Returns true if the vector is empty. (Thus \fBbegin()\fP would equal \fBend()\fP.) 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 574 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_iterator \fBstd::vector\fP< _Tp, _Alloc >::end () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the vector. Iteration is done in ordinary element order. 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 452 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::end ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points one past the last element in the vector. Iteration is done in ordinary element order. 
.PP
Definition at line 443 of file stl_vector.h.
.PP
Referenced by std::vector< _Tp, _Alloc >::emplace(), std::vector< _Tp, _Alloc >::erase(), std::vector< _Tp, _Alloc >::insert(), __gnu_parallel::multiseq_partition(), __gnu_parallel::multiseq_selection(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), __gnu_parallel::parallel_sort_mwms_pu(), and std::vector< _Node *, _Nodeptr_Alloc >::vector().
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::erase (iterator __first, iterator __last)\fC [inline]\fP"
.PP
Remove a range of elements. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Iterator pointing to the first element to be erased. 
.br
\fIlast\fP Iterator pointing to one past the last element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the element pointed to by \fIlast\fP prior to erasing (or \fBend()\fP).
.RE
.PP
This function will erase the elements in the range [first,last) and shorten the vector accordingly.
.PP
Note This operation could be expensive and if it is frequently used the user should consider using \fBstd::list\fP. The user is also cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 146 of file vector.tcc.
.PP
References std::vector< _Tp, _Alloc >::end().
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::erase (iterator __position)\fC [inline]\fP"
.PP
Remove element at given position. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator pointing to element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the next element (or \fBend()\fP).
.RE
.PP
This function will erase the element at the given position and thus shorten the vector by one.
.PP
Note This operation could be expensive and if it is frequently used the user should consider using \fBstd::list\fP. The user is also cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 134 of file vector.tcc.
.PP
References std::vector< _Tp, _Alloc >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the first element of the vector. 
.PP
Definition at line 687 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the first element of the vector. 
.PP
Definition at line 679 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator __position, _InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Inserts a range into the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function will insert copies of the data in the range [first,last) into the vector before the location specified by \fIpos\fP.
.PP
Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 869 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator __position, size_type __n, const value_type & __x)\fC [inline]\fP"
.PP
Inserts a number of copies of given data into the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIn\fP Number of elements to be inserted. 
.br
\fIx\fP Data to be inserted.
.RE
.PP
This function will insert a specified number of copies of the given data before the location specified by \fIposition\fP.
.PP
Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 850 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator __position, \fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Inserts an \fBinitializer_list\fP into the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function will insert copies of the data in the \fBinitializer_list\fP \fIl\fP into the vector before the location specified by \fIposition\fP.
.PP
Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 832 of file stl_vector.h.
.PP
Referenced by std::vector< _Node *, _Nodeptr_Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> iterator \fBstd::vector\fP< _Tp, _Alloc >::insert (iterator __position, value_type && __x)\fC [inline]\fP"
.PP
Inserts given rvalue into vector before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given rvalue before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 815 of file stl_vector.h.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc >::iterator vector::insert (iterator __position, const value_type & __x)\fC [inline]\fP"
.PP
Inserts given value into vector before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the vector. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given value before the specified location. Note that this kind of operation could be expensive for a vector and if it is frequently used the user should consider using \fBstd::list\fP. 
.PP
Definition at line 107 of file vector.tcc.
.PP
References std::vector< _Tp, _Alloc >::begin(), std::vector< _Tp, _Alloc >::end(), and std::move().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP"
.PP
Returns the \fBsize()\fP of the largest possible vector. 
.PP
Definition at line 537 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBvector\fP& \fBstd::vector\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Vector \fBlist\fP assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function fills a vector with copies of the elements in the initializer \fBlist\fP \fIl\fP.
.PP
Note that the assignment completely changes the vector and that the resulting vector's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 356 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBvector\fP& \fBstd::vector\fP< _Tp, _Alloc >::operator= (\fBvector\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Vector move assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector of identical element and \fBallocator\fP types.
.RE
.PP
The contents of \fIx\fP are moved into this vector (without copying). \fIx\fP is a valid, but unspecified vector. 
.PP
Definition at line 336 of file stl_vector.h.
.SS "template<typename _Tp , typename _Alloc > \fBvector\fP< _Tp, _Alloc > & vector::operator= (const \fBvector\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
Vector assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector of identical element and \fBallocator\fP types.
.RE
.PP
All the elements of \fIx\fP are copied, but any extra memory in \fIx\fP (for fast expansion) will not be copied. Unlike the copy constructor, the \fBallocator\fP object is not copied. 
.PP
Definition at line 157 of file vector.tcc.
.PP
References std::_Destroy(), std::vector< _Tp, _Alloc >::_M_allocate_and_copy(), std::_Vector_base< _Tp, _Alloc >::_M_impl, std::vector< _Tp, _Alloc >::begin(), std::vector< _Tp, _Alloc >::capacity(), std::vector< _Tp, _Alloc >::end(), and std::vector< _Tp, _Alloc >::size().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::vector\fP< _Tp, _Alloc >::operator[] (size_type __n) const\fC [inline]\fP"
.PP
Subscript access to the data contained in the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference to data.
.RE
.PP
This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and \fBout_of_range\fP lookups are not defined. (For checked lookups see \fBat()\fP.) 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 625 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::vector\fP< _Tp, _Alloc >::operator[] (size_type __n)\fC [inline]\fP"
.PP
Subscript access to the data contained in the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference to data.
.RE
.PP
This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and \fBout_of_range\fP lookups are not defined. (For checked lookups see \fBat()\fP.) 
.PP
Definition at line 610 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"
.PP
Removes last element. 
.PP
This is a typical \fBstack\fP operation. It shrinks the vector by one.
.PP
Note that no data is returned, and if the last element's data is needed, it should be retrieved before \fBpop_back()\fP is called. 
.PP
Definition at line 764 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::push_back (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the end of the vector. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical \fBstack\fP operation. The function creates an element at the end of the vector and assigns the given data to it. Due to the nature of a vector this operation can be done in constant time if the vector has preallocated space available. 
.PP
Definition at line 733 of file stl_vector.h.
.PP
Referenced by __gnu_parallel::multiseq_partition(), and __gnu_parallel::multiseq_selection().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 470 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to the last element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 461 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 488 of file stl_vector.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::vector\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to one before the first element in the vector. Iteration is done in reverse element order. 
.PP
Definition at line 479 of file stl_vector.h.
.SS "template<typename _Tp , typename _Alloc > void vector::reserve (size_type __n)\fC [inline]\fP"
.PP
Attempt to preallocate enough memory for specified number of elements. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements required. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::length_error\fP\fP If \fIn\fP exceeds \fC\fBmax_size()\fP\fP.
.RE
.PP
This function attempts to reserve enough memory for the vector to hold the specified number of elements. If the number requested is more than \fBmax_size()\fP, \fBlength_error\fP is thrown.
.PP
The advantage of this function is that if optimal code is a necessity and the user can determine the number of elements that will be required, the user can reserve the memory in advance, and thus prevent a possible reallocation of memory and copying of vector data. 
.PP
Definition at line 65 of file vector.tcc.
.PP
References std::_Destroy().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::resize (size_type __new_size, value_type __x = \fCvalue_type()\fP)\fC [inline]\fP"
.PP
Resizes the vector to the specified number of elements. 
.PP
\fBParameters:\fP
.RS 4
\fInew_size\fP Number of elements the vector should contain. 
.br
\fIx\fP Data with which new elements should be populated.
.RE
.PP
This function will resize the vector to the specified number of elements. If the number is smaller than the vector's current size the vector is truncated, otherwise the vector is extended and new elements are populated with given data. 
.PP
Definition at line 552 of file stl_vector.h.
.PP
Referenced by __gnu_parallel::multiway_merge_exact_splitting(), __gnu_parallel::parallel_sort_mwms(), and __gnu_parallel::shrink_and_double().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::vector\fP< _Tp, _Alloc >::size () const\fC [inline]\fP"
.PP
Returns the number of elements in the vector. 
.PP
Reimplemented in \fBstd::match_results< _Bi_iter, _Allocator >\fP, and \fBstd::match_results< _Bi_iter >\fP.
.PP
Definition at line 532 of file stl_vector.h.
.PP
Referenced by __gnu_parallel::list_partition(), std::vector< _Tp, _Alloc >::operator=(), std::operator==(), __gnu_parallel::shrink(), and __gnu_parallel::shrink_and_double().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::vector\fP< _Tp, _Alloc >::swap (\fBvector\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Swaps data with another vector. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A vector of the same element and \fBallocator\fP types.
.RE
.PP
This exchanges the elements between two vectors in constant time. (Three pointers, so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(v1,v2) will feed to this function. 
.PP
Definition at line 927 of file stl_vector.h.
.PP
Referenced by std::swap().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
