.TH "Sorting Algorithms" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Sorting Algorithms \- 
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBSet Operation Algorithms\fP"
.br
.ti -1c
.RI "\fBBinary Search Algorithms\fP"
.br
.ti -1c
.RI "\fBHeap Algorithms\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > void \fBstd::inplace_merge\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > void \fBstd::inplace_merge\fP (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > bool \fBstd::is_sorted\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > bool \fBstd::is_sorted\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBstd::is_sorted_until\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBstd::is_sorted_until\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 , typename _Compare > bool \fBstd::lexicographical_compare\fP (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _II1 , typename _II2 > bool \fBstd::lexicographical_compare\fP (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fBstd::max\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBstd::max\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBstd::max_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBstd::max_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator \fBstd::merge\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator \fBstd::merge\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fBstd::min\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBstd::min\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > _ForwardIterator \fBstd::min_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > _ForwardIterator \fBstd::min_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Compare > pair< const _Tp &, const _Tp & > \fBstd::minmax\fP (const _Tp &__a, const _Tp &__b, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > pair< const _Tp &, const _Tp & > \fBstd::minmax\fP (const _Tp &__a, const _Tp &__b)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Compare > pair< _ForwardIterator, _ForwardIterator > \fBstd::minmax_element\fP (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > pair< _ForwardIterator, _ForwardIterator > \fBstd::minmax_element\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > bool \fBstd::next_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > bool \fBstd::next_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBstd::nth_element\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBstd::nth_element\fP (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBstd::partial_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBstd::partial_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator , typename _Compare > _RandomAccessIterator \fBstd::partial_sort_copy\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator \fBstd::partial_sort_copy\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator , typename _Compare > bool \fBstd::prev_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _BidirectionalIterator > bool \fBstd::prev_permutation\fP (_BidirectionalIterator __first, _BidirectionalIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBstd::sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBstd::sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _Compare > void \fBstd::stable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > void \fBstd::stable_sort\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename _BidirectionalIterator , typename _Compare > void std::inplace_merge (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Merges two sorted ranges in place. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fImiddle\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Merges two sorted and consecutive ranges, [first,middle) and [middle,last), and puts the result in [first,last). The output will be sorted. The sort is \fIstable\fP, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.
.PP
If enough additional memory is available, this takes (last-first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(first,last).
.PP
The comparison function should have the same effects on ordering as the function used for the initial sort. 
.PP
Definition at line 3185 of file stl_algo.h.
.PP
References std::__merge_adaptive(), std::__merge_without_buffer(), std::_Temporary_buffer< _ForwardIterator, _Tp >::begin(), std::distance(), and std::_Temporary_buffer< _ForwardIterator, _Tp >::size().
.SS "template<typename _BidirectionalIterator > void std::inplace_merge (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\fC [inline]\fP"
.PP
Merges two sorted ranges in place. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fImiddle\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Merges two sorted and consecutive ranges, [first,middle) and [middle,last), and puts the result in [first,last). The output will be sorted. The sort is \fIstable\fP, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.
.PP
If enough additional memory is available, this takes (last-first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(first,last). 
.PP
Definition at line 3130 of file stl_algo.h.
.PP
References std::__merge_adaptive(), std::__merge_without_buffer(), std::_Temporary_buffer< _ForwardIterator, _Tp >::begin(), std::distance(), and std::_Temporary_buffer< _ForwardIterator, _Tp >::size().
.SS "template<typename _ForwardIterator , typename _Compare > bool std::is_sorted (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Determines whether the elements of a sequence are sorted according to a comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if the elements are sorted, false otherwise. 
.RE
.PP

.PP
Definition at line 3886 of file stl_algo.h.
.PP
References std::is_sorted_until().
.SS "template<typename _ForwardIterator > bool std::is_sorted (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Determines whether the elements of a sequence are sorted. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if the elements are sorted, false otherwise. 
.RE
.PP

.PP
Definition at line 3872 of file stl_algo.h.
.PP
References std::is_sorted_until().
.SS "template<typename _ForwardIterator , typename _Compare > _ForwardIterator std::is_sorted_until (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Determines the end of a sorted sequence using comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the last \fBiterator\fP i in [first, last) for which the range [first, i) is sorted. 
.RE
.PP

.PP
Definition at line 3929 of file stl_algo.h.
.PP
Referenced by std::is_sorted().
.SS "template<typename _ForwardIterator > _ForwardIterator std::is_sorted_until (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Determines the end of a sorted sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the last \fBiterator\fP i in [first, last) for which the range [first, i) is sorted. 
.RE
.PP

.PP
Definition at line 3900 of file stl_algo.h.
.SS "template<typename _II1 , typename _II2 , typename _Compare > bool std::lexicographical_compare (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)\fC [inline]\fP"
.PP
Performs 'dictionary' comparison on ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP An input \fBiterator\fP. 
.br
\fIlast1\fP An input \fBiterator\fP. 
.br
\fIfirst2\fP An input \fBiterator\fP. 
.br
\fIlast2\fP An input \fBiterator\fP. 
.br
\fIcomp\fP A \fBcomparison functor\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A boolean true or false.
.RE
.PP
The same as the four-parameter \fClexicographical_compare\fP, but uses the comp parameter instead of \fC<\fP. 
.PP
Definition at line 1050 of file stl_algobase.h.
.PP
Referenced by std::operator<().
.SS "template<typename _II1 , typename _II2 > bool std::lexicographical_compare (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)\fC [inline]\fP"
.PP
Performs 'dictionary' comparison on ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP An input \fBiterator\fP. 
.br
\fIlast1\fP An input \fBiterator\fP. 
.br
\fIfirst2\fP An input \fBiterator\fP. 
.br
\fIlast2\fP An input \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A boolean true or false.
.RE
.PP
'Returns true if the sequence of elements defined by the range [first1,last1) is lexicographically \fBless\fP than the sequence of elements defined by the range [first2,last2). Returns false otherwise.' (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to \fCmemcmp\fP. 
.PP
Definition at line 1015 of file stl_algobase.h.
.SS "template<typename _Tp , typename _Compare > const _Tp & std::max (const _Tp & __a, const _Tp & __b, _Compare __comp)\fC [inline]\fP"
.PP
This does what you think it does. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.br
\fIcomp\fP A \fBcomparison functor\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBgreater\fP of the parameters.
.RE
.PP
This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. 
.PP
Definition at line 253 of file stl_algobase.h.
.SS "template<typename _Tp > const _Tp & std::max (const _Tp & __a, const _Tp & __b)\fC [inline]\fP"
.PP
This does what you think it does. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
The \fBgreater\fP of the parameters.
.RE
.PP
This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. 
.PP
Definition at line 209 of file stl_algobase.h.
.PP
Referenced by std::tr1::__detail::__bessel_jn(), std::tr1::__detail::__ellint_rc(), std::tr1::__detail::__ellint_rd(), std::tr1::__detail::__ellint_rf(), std::tr1::__detail::__ellint_rj(), std::deque< _Tp, _Alloc >::_M_reallocate_map(), std::binomial_distribution< _IntType, _RealType >::operator()(), std::poisson_distribution< _IntType, _RealType >::operator()(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow().
.SS "template<typename _ForwardIterator , typename _Compare > _ForwardIterator std::max_element (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Return the maximum element in a range using comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIcomp\fP Comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencing the first instance of the largest value according to comp. 
.RE
.PP

.PP
Definition at line 6070 of file stl_algo.h.
.PP
Referenced by std::valarray< _Tp >::max().
.SS "template<typename _ForwardIterator > _ForwardIterator std::max_element (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Return the maximum element in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencing the first instance of the largest value. 
.RE
.PP

.PP
Definition at line 6042 of file stl_algo.h.
.SS "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare > _OutputIterator std::merge (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\fC [inline]\fP"
.PP
Merges two sorted ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP An \fBiterator\fP. 
.br
\fIfirst2\fP Another \fBiterator\fP. 
.br
\fIlast1\fP Another \fBiterator\fP. 
.br
\fIlast2\fP Another \fBiterator\fP. 
.br
\fIresult\fP An \fBiterator\fP pointing to the end of the merged range. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element 'not \fBless\fP than' \fIval\fP.
.RE
.PP
Merges the ranges [first1,last1) and [first2,last2) into the sorted range [result, result + (last1-first1) + (last2-first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is \fIstable\fP, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.
.PP
The comparison function should have the same effects on ordering as the function used for the initial sort. 
.PP
Definition at line 5348 of file stl_algo.h.
.SS "template<typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator > _OutputIterator std::merge (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\fC [inline]\fP"
.PP
Merges two sorted ranges. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP An \fBiterator\fP. 
.br
\fIfirst2\fP Another \fBiterator\fP. 
.br
\fIlast1\fP Another \fBiterator\fP. 
.br
\fIlast2\fP Another \fBiterator\fP. 
.br
\fIresult\fP An \fBiterator\fP pointing to the end of the merged range. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element 'not \fBless\fP than' \fIval\fP.
.RE
.PP
Merges the ranges [first1,last1) and [first2,last2) into the sorted range [result, result + (last1-first1) + (last2-first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is \fIstable\fP, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second. 
.PP
Definition at line 5285 of file stl_algo.h.
.SS "template<typename _Tp , typename _Compare > const _Tp & std::min (const _Tp & __a, const _Tp & __b, _Compare __comp)\fC [inline]\fP"
.PP
This does what you think it does. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.br
\fIcomp\fP A \fBcomparison functor\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
The lesser of the parameters.
.RE
.PP
This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. 
.PP
Definition at line 232 of file stl_algobase.h.
.SS "template<typename _Tp > const _Tp & std::min (const _Tp & __a, const _Tp & __b)\fC [inline]\fP"
.PP
This does what you think it does. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
The lesser of the parameters.
.RE
.PP
This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. 
.PP
Definition at line 186 of file stl_algobase.h.
.PP
Referenced by std::tr1::__detail::__ellint_rc(), std::tr1::__detail::__ellint_rd(), std::tr1::__detail::__ellint_rf(), std::tr1::__detail::__ellint_rj(), std::tr1::__detail::__expint_En_cont_frac(), __gnu_cxx::__versa_string< _CharT, _Traits, _Alloc, _Base >::compare(), std::basic_string< _CharT, _Traits, _Alloc >::compare(), std::basic_string< char >::compare(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), __gnu_parallel::parallel_random_shuffle_drs(), std::basic_istream< _CharT, _Traits >::readsome(), std::basic_string< _CharT, _Traits, _Alloc >::rfind(), __gnu_parallel::sequential_random_shuffle(), std::basic_filebuf< _CharT, _Traits >::underflow(), std::basic_streambuf< _CharT, _Traits >::xsgetn(), and std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _ForwardIterator , typename _Compare > _ForwardIterator std::min_element (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Return the minimum element in a range using comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIcomp\fP Comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencing the first instance of the smallest value according to comp. 
.RE
.PP

.PP
Definition at line 6014 of file stl_algo.h.
.PP
Referenced by std::valarray< _Tp >::min().
.SS "template<typename _ForwardIterator > _ForwardIterator std::min_element (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Return the minimum element in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
Iterator referencing the first instance of the smallest value. 
.RE
.PP

.PP
Definition at line 5986 of file stl_algo.h.
.SS "template<typename _Tp , typename _Compare > pair< const _Tp &, const _Tp & > std::minmax (const _Tp & __a, const _Tp & __b, _Compare __comp)\fC [inline]\fP"
.PP
Determines min and max at once as an ordered \fBpair\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.br
\fIcomp\fP A \fBcomparison functor\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pair(b, a) if b is smaller than a, pair(a, b) otherwise. 
.RE
.PP

.PP
Definition at line 3977 of file stl_algo.h.
.PP
References std::minmax().
.SS "template<typename _Tp > pair< const _Tp &, const _Tp & > std::minmax (const _Tp & __a, const _Tp & __b)\fC [inline]\fP"
.PP
Determines min and max at once as an ordered \fBpair\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A thing of arbitrary type. 
.br
\fIb\fP Another thing of arbitrary type. 
.RE
.PP
\fBReturns:\fP
.RS 4
A pair(b, a) if b is smaller than a, pair(a, b) otherwise. 
.RE
.PP

.PP
Definition at line 3958 of file stl_algo.h.
.PP
References std::minmax().
.PP
Referenced by std::minmax().
.SS "template<typename _ForwardIterator , typename _Compare > pair<_ForwardIterator, _ForwardIterator> std::minmax_element (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Return a \fBpair\fP of iterators pointing to the minimum and maximum elements in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIcomp\fP Comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
make_pair(m, M), where m is the first \fBiterator\fP i in [first, last) such that no other element in the range is smaller, and where M is the last \fBiterator\fP i in [first, last) such that no other element in the range is larger. 
.RE
.PP

.PP
Definition at line 4072 of file stl_algo.h.
.SS "template<typename _ForwardIterator > pair<_ForwardIterator, _ForwardIterator> std::minmax_element (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
Return a \fBpair\fP of iterators pointing to the minimum and maximum elements in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
make_pair(m, M), where m is the first \fBiterator\fP i in [first, last) such that no other element in the range is smaller, and where M is the last \fBiterator\fP i in [first, last) such that no other element in the range is larger. 
.RE
.PP

.PP
Definition at line 3996 of file stl_algo.h.
.SS "template<typename _BidirectionalIterator , typename _Compare > bool std::next_permutation (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Permute range into the next 'dictionary' ordering using comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
False if wrapped to first permutation, true otherwise.
.RE
.PP
Treats all permutations of the range [first,last) as a \fBset\fP of 'dictionary' sorted sequences ordered by \fIcomp\fP. Permutes the current sequence into the next one of this \fBset\fP. Returns true if there are more sequences to generate. If the sequence is the largest of the \fBset\fP, the smallest is generated and false returned. 
.PP
Definition at line 3631 of file stl_algo.h.
.PP
References std::iter_swap(), and std::reverse().
.SS "template<typename _BidirectionalIterator > bool std::next_permutation (_BidirectionalIterator __first, _BidirectionalIterator __last)\fC [inline]\fP"
.PP
Permute range into the next 'dictionary' ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
False if wrapped to first permutation, true otherwise.
.RE
.PP
Treats all permutations of the range as a \fBset\fP of 'dictionary' sorted sequences. Permutes the current sequence into the next one of this \fBset\fP. Returns true if there are more sequences to generate. If the sequence is the largest of the \fBset\fP, the smallest is generated and false returned. 
.PP
Definition at line 3574 of file stl_algo.h.
.PP
References std::iter_swap(), and std::reverse().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::nth_element (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Sort a sequence just enough to find a particular position using a predicate for comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fInth\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Rearranges the elements in the range \fC\fP[first,last) so that \fC*nth\fP is the same element that would have been in that position had the whole sequence been sorted. The elements either side of \fC*nth\fP are not completely sorted, but for any \fBiterator\fP  in the range \fC\fP[first,nth) and any \fBiterator\fP  in the range \fC\fP[nth,last) it holds that \fCcomp(*j,*i)\fP is false. 
.PP
Definition at line 5169 of file stl_algo.h.
.PP
References std::__lg().
.SS "template<typename _RandomAccessIterator > void std::nth_element (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
Sort a sequence just enough to find a particular position. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fInth\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Rearranges the elements in the range \fC\fP[first,last) so that \fC*nth\fP is the same element that would have been in that position had the whole sequence been sorted. whole sequence been sorted. The elements either side of \fC*nth\fP are not completely sorted, but for any \fBiterator\fP  in the range \fC\fP[first,nth) and any \fBiterator\fP  in the range \fC\fP[nth,last) it holds that \fC*j<*i\fP is false. 
.PP
Definition at line 5130 of file stl_algo.h.
.PP
References std::__lg().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::partial_sort (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Sort the smallest elements of a sequence using a predicate for comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fImiddle\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the smallest \fC\fP(middle-first) elements in the range \fC\fP[first,last) and moves them to the range \fC\fP[first,middle). The order of the remaining elements in the range \fC\fP[middle,last) is undefined. After the sort if \fCi\fP and  are iterators in the range \fC\fP[first,middle) such that  precedes  and  is an \fBiterator\fP in the range \fC\fP[middle,last) then \fC*comp\fP(j,*i) and \fCcomp(*k,*i)\fP are both false. 
.PP
Definition at line 5092 of file stl_algo.h.
.PP
References std::__heap_select(), and std::sort_heap().
.SS "template<typename _RandomAccessIterator > void std::partial_sort (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
Sort the smallest elements of a sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fImiddle\fP Another \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the smallest \fC\fP(middle-first) elements in the range \fC\fP[first,last) and moves them to the range \fC\fP[first,middle). The order of the remaining elements in the range \fC\fP[middle,last) is undefined. After the sort if \fCi\fP and  are iterators in the range \fC\fP[first,middle) such that  precedes  and  is an \fBiterator\fP in the range \fC\fP[middle,last) then \fC*j<*i\fP and \fC*k<*i\fP are both false. 
.PP
Definition at line 5053 of file stl_algo.h.
.PP
References std::__heap_select(), and std::sort_heap().
.SS "template<typename _InputIterator , typename _RandomAccessIterator , typename _Compare > _RandomAccessIterator std::partial_sort_copy (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\fC [inline]\fP"
.PP
Copy the smallest elements of a sequence using a predicate for comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP Another input \fBiterator\fP. 
.br
\fIresult_first\fP A random-access \fBiterator\fP. 
.br
\fIresult_last\fP Another random-access \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP indicating the end of the resulting sequence.
.RE
.PP
Copies and sorts the smallest N values from the range \fC\fP[first,last) to the range beginning at \fCresult_first\fP, where the number of elements to be copied, \fCN\fP, is the smaller of \fC\fP(last-first) and \fC\fP(result_last-result_first). After the sort if \fCi\fP and  are iterators in the range \fC\fP[result_first,result_first+N) such that  precedes  then \fCcomp(*j,*i)\fP is false. The value returned is \fCresult_first+N\fP. 
.PP
Definition at line 2011 of file stl_algo.h.
.PP
References std::make_heap(), and std::sort_heap().
.SS "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator std::partial_sort_copy (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\fC [inline]\fP"
.PP
Copy the smallest elements of a sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIresult_first\fP A random-access \fBiterator\fP. 
.br
\fIresult_last\fP Another random-access \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP indicating the end of the resulting sequence.
.RE
.PP
Copies and sorts the smallest N values from the range \fC\fP[first,last) to the range beginning at \fCresult_first\fP, where the number of elements to be copied, \fCN\fP, is the smaller of \fC\fP(last-first) and \fC\fP(result_last-result_first). After the sort if \fCi\fP and  are iterators in the range \fC\fP[result_first,result_first+N) such that  precedes  then \fC*j<*i\fP is false. The value returned is \fCresult_first+N\fP. 
.PP
Definition at line 1945 of file stl_algo.h.
.PP
References std::make_heap(), and std::sort_heap().
.SS "template<typename _BidirectionalIterator , typename _Compare > bool std::prev_permutation (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Permute range into the previous 'dictionary' ordering using comparison functor. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
False if wrapped to last permutation, true otherwise.
.RE
.PP
Treats all permutations of the range [first,last) as a \fBset\fP of 'dictionary' sorted sequences ordered by \fIcomp\fP. Permutes the current sequence into the previous one of this \fBset\fP. Returns true if there are more sequences to generate. If the sequence is the smallest of the \fBset\fP, the largest is generated and false returned. 
.PP
Definition at line 3744 of file stl_algo.h.
.PP
References std::iter_swap(), and std::reverse().
.SS "template<typename _BidirectionalIterator > bool std::prev_permutation (_BidirectionalIterator __first, _BidirectionalIterator __last)\fC [inline]\fP"
.PP
Permute range into the previous 'dictionary' ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Start of range. 
.br
\fIlast\fP End of range. 
.RE
.PP
\fBReturns:\fP
.RS 4
False if wrapped to last permutation, true otherwise.
.RE
.PP
Treats all permutations of the range as a \fBset\fP of 'dictionary' sorted sequences. Permutes the current sequence into the previous one of this \fBset\fP. Returns true if there are more sequences to generate. If the sequence is the smallest of the \fBset\fP, the largest is generated and false returned. 
.PP
Definition at line 3687 of file stl_algo.h.
.PP
References std::iter_swap(), and std::reverse().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Sort the elements of a sequence using a predicate for comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the elements in the range \fC\fP[first,last) in ascending order, such that \fCcomp\fP(*(i+1),*i) is false for every \fBiterator\fP \fCi\fP in the range \fC\fP[first,last-1).
.PP
The relative ordering of equivalent elements is not preserved, use \fCstable_sort()\fP if this is needed. 
.PP
Definition at line 5243 of file stl_algo.h.
.PP
References std::__final_insertion_sort(), std::__introsort_loop(), and std::__lg().
.SS "template<typename _RandomAccessIterator > void std::sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
Sort the elements of a sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the elements in the range \fC\fP[first,last) in ascending order, such that \fC*\fP(i+1)<*i is false for each \fBiterator\fP \fCi\fP in the range \fC\fP[first,last-1).
.PP
The relative ordering of equivalent elements is not preserved, use \fCstable_sort()\fP if this is needed. 
.PP
Definition at line 5207 of file stl_algo.h.
.PP
References std::__final_insertion_sort(), std::__introsort_loop(), and std::__lg().
.SS "template<typename _RandomAccessIterator , typename _Compare > void std::stable_sort (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\fC [inline]\fP"
.PP
Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIcomp\fP A comparison functor. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the elements in the range \fC\fP[first,last) in ascending order, such that \fCcomp\fP(*(i+1),*i) is false for each \fBiterator\fP \fCi\fP in the range \fC\fP[first,last-1).
.PP
The relative ordering of equivalent elements is preserved, so any two elements \fCx\fP and \fCy\fP in the range \fC\fP[first,last) such that \fCcomp(x,y)\fP is false and \fCcomp(y,x)\fP is false will have the same relative ordering after calling \fCstable_sort()\fP. 
.PP
Definition at line 5449 of file stl_algo.h.
.PP
References std::__inplace_stable_sort(), std::_Temporary_buffer< _ForwardIterator, _Tp >::begin(), and std::_Temporary_buffer< _ForwardIterator, _Tp >::size().
.SS "template<typename _RandomAccessIterator > void std::stable_sort (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
Sort the elements of a sequence, preserving the relative order of equivalent elements. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
Sorts the elements in the range \fC\fP[first,last) in ascending order, such that \fC*\fP(i+1)<*i is false for each \fBiterator\fP \fCi\fP in the range \fC\fP[first,last-1).
.PP
The relative ordering of equivalent elements is preserved, so any two elements \fCx\fP and \fCy\fP in the range \fC\fP[first,last) such that \fCx<y\fP is false and \fCy<x\fP is false will have the same relative ordering after calling \fCstable_sort()\fP. 
.PP
Definition at line 5407 of file stl_algo.h.
.PP
References std::__inplace_stable_sort(), std::_Temporary_buffer< _ForwardIterator, _Tp >::begin(), and std::_Temporary_buffer< _ForwardIterator, _Tp >::size().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
