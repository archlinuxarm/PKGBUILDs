.TH "std::stack" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::stack \- A standard container giving FILO behavior.  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Sequence::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef _Sequence \fBcontainer_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Sequence::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Sequence::value_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename... _Args> void \fBemplace\fP (_Args &&...__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "void \fBpop\fP ()"
.br
.ti -1c
.RI "void \fBpush\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush\fP (const value_type &__x)"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "\fBstack\fP (_Sequence &&__c=_Sequence())"
.br
.ti -1c
.RI "\fBstack\fP (const _Sequence &__c)"
.br
.ti -1c
.RI "void \fBswap\fP (\fBstack\fP &&__s)"
.br
.ti -1c
.RI "const_reference \fBtop\fP () const "
.br
.ti -1c
.RI "reference \fBtop\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Sequence \fBc\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<typename _Tp1 , typename _Seq1 > bool \fBoperator<\fP (const \fBstack\fP< _Tp1, _Seq1 > &, const \fBstack\fP< _Tp1, _Seq1 > &)"
.br
.ti -1c
.RI "template<typename _Tp1 , typename _Seq1 > bool \fBoperator==\fP (const \fBstack\fP< _Tp1, _Seq1 > &, const \fBstack\fP< _Tp1, _Seq1 > &)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> class std::stack< _Tp, _Sequence >"
A standard container giving FILO behavior. 

Meets many of the requirements of a \fCcontainer\fP, but does not define anything to do with iterators. Very few of the other standard container interfaces are defined.
.PP
This is not a true container, but an \fIadaptor\fP. It holds another container, and provides a wrapper interface to that container. The wrapper is what enforces strict first-in-last-out stack behavior.
.PP
The second template parameter defines the type of the underlying sequence/container. It defaults to \fBstd::deque\fP, but it can be any type that supports \fCback\fP, \fCpush_back\fP, and \fCpop_front\fP, such as \fBstd::list\fP, \fBstd::vector\fP, or an appropriate user-defined type.
.PP
Members not found in 'normal' containers are \fCcontainer_type\fP, which is a typedef for the second Sequence parameter, and \fCpush\fP, \fCpop\fP, and \fCtop\fP, which are standard stack/FILO operations. 
.PP
Definition at line 92 of file stl_stack.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> \fBstd::stack\fP< _Tp, _Sequence >::\fBstack\fP (const _Sequence & __c)\fC [inline, explicit]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 130 of file stl_stack.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> bool \fBstd::stack\fP< _Tp, _Sequence >::empty () const\fC [inline]\fP"
.PP
Returns true if the stack is empty. 
.PP
Definition at line 142 of file stl_stack.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> void \fBstd::stack\fP< _Tp, _Sequence >::pop ()\fC [inline]\fP"
.PP
Removes first element. 
.PP
This is a typical stack operation. It shrinks the stack by one. The time complexity of the operation depends on the underlying sequence.
.PP
Note that no data is returned, and if the first element's data is needed, it should be retrieved before \fBpop()\fP is called. 
.PP
Definition at line 208 of file stl_stack.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> void \fBstd::stack\fP< _Tp, _Sequence >::push (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the top of the stack. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical stack operation. The function creates an element at the top of the stack and assigns the given data to it. The time complexity of the operation depends on the underlying sequence. 
.PP
Definition at line 182 of file stl_stack.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> size_type \fBstd::stack\fP< _Tp, _Sequence >::size () const\fC [inline]\fP"
.PP
Returns the number of elements in the stack. 
.PP
Definition at line 147 of file stl_stack.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> const_reference \fBstd::stack\fP< _Tp, _Sequence >::top () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the first element of the stack. 
.PP
Definition at line 166 of file stl_stack.h.
.SS "template<typename _Tp, typename _Sequence = deque<_Tp>> reference \fBstd::stack\fP< _Tp, _Sequence >::top ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the first element of the stack. 
.PP
Definition at line 155 of file stl_stack.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
