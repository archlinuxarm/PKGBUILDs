.TH "SGI STL extensions" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
SGI STL extensions \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fB__gnu_cxx::binary_compose< _Operation1, _Operation2, _Operation3 >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::constant_binary_fun< _Result, _Arg1, _Arg2 >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::constant_unary_fun< _Result, _Argument >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::constant_void_fun< _Result >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "class \fB__gnu_cxx::hash_map< _Key, _Tp, _HashFn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_multimap< _Key, _Tp, _HashFn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_multiset< _Value, _HashFcn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::hash_set< _Value, _HashFcn, _EqualKey, _Alloc >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::project1st< _Arg1, _Arg2 >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::project2nd< _Arg1, _Arg2 >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::rb_tree< _Key, _Value, _KeyOfValue, _Compare, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::rope< _CharT, _Alloc >\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::select1st< _Pair >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "struct \fB__gnu_cxx::select2nd< _Pair >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.ti -1c
.RI "class \fB__gnu_cxx::slist< _Tp, _Alloc >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::subtractive_rng\fP"
.br
.ti -1c
.RI "struct \fB__gnu_cxx::temporary_buffer< _ForwardIterator, _Tp >\fP"
.br
.ti -1c
.RI "class \fB__gnu_cxx::unary_compose< _Operation1, _Operation2 >\fP"
.br
.RI "\fIAn \fBSGI extension \fP. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _Tp , typename _Compare > const _Tp & \fBstd::__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _Tp > const _Tp & \fBstd::__median\fP (const _Tp &__a, const _Tp &__b, const _Tp &__c)"
.br
.ti -1c
.RI "size_t \fBstd::bitset::_Find_first\fP () const "
.br
.ti -1c
.RI "size_t \fBstd::bitset::_Find_next\fP (size_t __prev) const "
.br
.ti -1c
.RI "template<class _Operation1 , class _Operation2 > unary_compose< _Operation1, _Operation2 > \fB__gnu_cxx::compose1\fP (const _Operation1 &__fn1, const _Operation2 &__fn2)"
.br
.ti -1c
.RI "template<class _Operation1 , class _Operation2 , class _Operation3 > binary_compose< _Operation1, _Operation2, _Operation3 > \fB__gnu_cxx::compose2\fP (const _Operation1 &__fn1, const _Operation2 &__fn2, const _Operation3 &__fn3)"
.br
.ti -1c
.RI "template<class _Result > constant_void_fun< _Result > \fB__gnu_cxx::constant0\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<class _Result > constant_unary_fun< _Result, _Result > \fB__gnu_cxx::constant1\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<class _Result > constant_binary_fun< _Result, _Result, _Result > \fB__gnu_cxx::constant2\fP (const _Result &__val)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Size , typename _OutputIterator > pair< _InputIterator, _OutputIterator > \fB__gnu_cxx::copy_n\fP (_InputIterator __first, _Size __count, _OutputIterator __result)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _Distance > void \fB__gnu_cxx::distance\fP (_InputIterator __first, _InputIterator __last, _Distance &__n)"
.br
.ti -1c
.RI "template<class _Tp > _Tp \fB__gnu_cxx::identity_element\fP (\fBstd::multiplies\fP< _Tp >)"
.br
.ti -1c
.RI "template<class _Tp > _Tp \fB__gnu_cxx::identity_element\fP (\fBstd::plus\fP< _Tp >)"
.br
.ti -1c
.RI "template<typename _ForwardIter , typename _Tp > void \fB__gnu_cxx::iota\fP (_ForwardIter __first, _ForwardIter __last, _Tp __value)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator , typename _StrictWeakOrdering > bool \fB__gnu_cxx::is_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last, _StrictWeakOrdering __comp)"
.br
.ti -1c
.RI "template<typename _RandomAccessIterator > bool \fB__gnu_cxx::is_heap\fP (_RandomAccessIterator __first, _RandomAccessIterator __last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _StrictWeakOrdering > bool \fB__gnu_cxx::is_sorted\fP (_ForwardIterator __first, _ForwardIterator __last, _StrictWeakOrdering __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > bool \fB__gnu_cxx::is_sorted\fP (_ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "template<typename _InputIterator1 , typename _InputIterator2 > int \fB__gnu_cxx::lexicographical_compare_3way\fP (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Integer > _Tp \fB__gnu_cxx::power\fP (_Tp __x, _Integer __n)"
.br
.ti -1c
.RI "template<typename _Tp , typename _Integer , typename _MonoidOperation > _Tp \fB__gnu_cxx::power\fP (_Tp __x, _Integer __n, _MonoidOperation __monoid_op)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator , typename _RandomNumberGenerator > _RandomAccessIterator \fB__gnu_cxx::random_sample\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last, _RandomNumberGenerator &__rand)"
.br
.ti -1c
.RI "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator \fB__gnu_cxx::random_sample\fP (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator , typename _Distance , typename _RandomNumberGenerator > _OutputIterator \fB__gnu_cxx::random_sample_n\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distance __n, _RandomNumberGenerator &__rand)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _OutputIterator , typename _Distance > _OutputIterator \fB__gnu_cxx::random_sample_n\fP (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distance __n)"
.br
.ti -1c
.RI "template<typename _InputIter , typename _Size , typename _ForwardIter > pair< _InputIter, _ForwardIter > \fB__gnu_cxx::uninitialized_copy_n\fP (_InputIter __first, _Size __count, _ForwardIter __result)"
.br
.in -1c
.in +1c
.ti -1c
.RI "bitset< _Nb > & \fBstd::bitset::_Unchecked_set\fP (size_t __pos)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Because libstdc++ based its implementation of the STL subsections of the library on the SGI 3.3 implementation, we inherited their extensions as well.
.PP
They are additionally documented in the \fConline documentation\fP, a copy of which is also shipped with the library source code (in .../docs/html/documentation.html). You can also read the documentation \fCon SGI's site\fP, which is still running even though the code is not maintained.
.PP
\fBNB\fP that the following notes are pulled from various comments all over the place, so they may seem stilted. 
.PP
.PP
The \fCidentity_element\fP functions are not part of the C++ standard; SGI provided them as an extension. Its argument is an operation, and its return value is the identity element for that operation. It is overloaded for addition and multiplication, and you can overload it for your own nefarious operations.
.PP
As an extension to the binders, SGI provided composition functors and wrapper functions to aid in their creation. The \fC\fBunary_compose\fP\fP functor is constructed from two functions/functors, \fCf\fP and \fCg\fP. Calling \fCoperator()\fP with a single argument \fCx\fP returns \fCf\fP(g(x)). The function \fCcompose1\fP takes the two functions and constructs a \fC\fBunary_compose\fP\fP variable for you.
.PP
\fC\fBbinary_compose\fP\fP is constructed from three functors, \fCf\fP, \fCg1\fP, and \fCg2\fP. Its \fCoperator()\fP returns \fCf\fP(g1(x),g2(x)). The function  takes f, g1, and g2, and constructs the \fC\fBbinary_compose\fP\fP instance for you. For example, if \fCf\fP returns an int, then 
.PP
.nf
  int answer = (compose2(f,g1,g2))(x);

.fi
.PP
 is equivalent to 
.PP
.nf
  int temp1 = g1(x);
  int temp2 = g2(x);
  int answer = f(temp1,temp2);

.fi
.PP
 But the first form is more compact, and can be passed around as a functor to other algorithms.
.PP
As an extension, SGI provided a functor called \fCidentity\fP. When a functor is required but no operations are desired, this can be used as a pass-through. Its \fCoperator()\fP returns its argument unchanged.
.PP
\fC\fBselect1st\fP\fP and \fC\fBselect2nd\fP\fP are extensions provided by SGI. Their \fCoperator()s\fP take a \fC\fBstd::pair\fP\fP as an argument, and return either the first member or the second member, respectively. They can be used (especially with the composition functors) to 'strip' data from a sequence before performing the remainder of an algorithm.
.PP
The \fCoperator()\fP of the \fC\fBproject1st\fP\fP functor takes two arbitrary arguments and returns the first one, while \fC\fBproject2nd\fP\fP returns the second one. They are extensions provided by SGI.
.PP
These three functors are each constructed from a single arbitrary variable/value. Later, their \fCoperator()s\fP completely ignore any arguments passed, and return the stored value.
.IP "\(bu" 2
\fCconstant_void_fun's\fP \fCoperator()\fP takes no arguments
.IP "\(bu" 2
\fCconstant_unary_fun's\fP \fCoperator()\fP takes one argument (ignored)
.IP "\(bu" 2
\fCconstant_binary_fun's\fP \fCoperator()\fP takes two arguments (ignored)
.PP
.PP
The helper creator functions \fCconstant0\fP, \fCconstant1\fP, and \fCconstant2\fP each take a 'result' argument and construct variables of the appropriate functor type. 
.SH "Function Documentation"
.PP 
.SS "template<typename _Tp , typename _Compare > const _Tp& std::__median (const _Tp & __a, const _Tp & __b, const _Tp & __c, _Compare __comp)\fC [inline]\fP"
.PP
Find the median of three values using a predicate for comparison. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A value. 
.br
\fIb\fP A value. 
.br
\fIc\fP A value. 
.br
\fIcomp\fP A binary predicate. 
.RE
.PP
\fBReturns:\fP
.RS 4
One of \fCa\fP, \fCb\fP or \fCc\fP.
.RE
.PP
If \fC{l\fP,m,n} is some convolution of \fC{a\fP,b,c} such that \fCcomp(l,m)\fP and \fCcomp(m,n)\fP are both true then the value returned will be \fCm\fP. This is an SGI extension. 
.PP
Definition at line 119 of file stl_algo.h.
.SS "template<typename _Tp > const _Tp& std::__median (const _Tp & __a, const _Tp & __b, const _Tp & __c)\fC [inline]\fP"
.PP
Find the median of three values. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP A value. 
.br
\fIb\fP A value. 
.br
\fIc\fP A value. 
.RE
.PP
\fBReturns:\fP
.RS 4
One of \fCa\fP, \fCb\fP or \fCc\fP.
.RE
.PP
If \fC{l\fP,m,n} is some convolution of \fC{a\fP,b,c} such that \fCl<=m<=n\fP then the value returned will be \fCm\fP. This is an SGI extension. 
.PP
Definition at line 85 of file stl_algo.h.
.PP
Referenced by std::__introsort_loop().
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::_Find_first () const\fC [inline, inherited]\fP"
.PP
Finds the index of the first 'on' bit. 
.PP
\fBReturns:\fP
.RS 4
The index of the first bit \fBset\fP, or \fBsize()\fP if not found.
.RE
.PP
\fBSee also:\fP
.RS 4
\fB_Find_next\fP 
.RE
.PP

.PP
Definition at line 1207 of file bitset.
.SS "template<size_t _Nb> size_t \fBstd::bitset\fP< _Nb >::_Find_next (size_t __prev) const\fC [inline, inherited]\fP"
.PP
Finds the index of the next 'on' bit after prev. 
.PP
\fBReturns:\fP
.RS 4
The index of the next bit \fBset\fP, or \fBsize()\fP if not found. 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIprev\fP Where to start searching.
.RE
.PP
\fBSee also:\fP
.RS 4
\fB_Find_first\fP 
.RE
.PP

.PP
Definition at line 1218 of file bitset.
.SS "template<size_t _Nb> bitset<_Nb>& \fBstd::bitset\fP< _Nb >::_Unchecked_set (size_t __pos)\fC [inline, inherited]\fP"
.PP
These versions of single-bit \fBset\fP, reset, flip, and test are extensions from the SGI version. They do no range checking. 
.PP
Definition at line 872 of file bitset.
.SS "template<class _Operation1 , class _Operation2 > unary_compose<_Operation1, _Operation2> __gnu_cxx::compose1 (const _Operation1 & __fn1, const _Operation2 & __fn2)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 145 of file ext/functional.
.SS "template<class _Operation1 , class _Operation2 , class _Operation3 > binary_compose<_Operation1, _Operation2, _Operation3> __gnu_cxx::compose2 (const _Operation1 & __fn1, const _Operation2 & __fn2, const _Operation3 & __fn3)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 172 of file ext/functional.
.SS "template<class _Result > constant_void_fun<_Result> __gnu_cxx::constant0 (const _Result & __val)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 326 of file ext/functional.
.SS "template<class _Result > constant_unary_fun<_Result, _Result> __gnu_cxx::constant1 (const _Result & __val)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 332 of file ext/functional.
.SS "template<class _Result > constant_binary_fun<_Result,_Result,_Result> __gnu_cxx::constant2 (const _Result & __val)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 338 of file ext/functional.
.SS "template<typename _InputIterator , typename _Size , typename _OutputIterator > pair<_InputIterator, _OutputIterator> __gnu_cxx::copy_n (_InputIterator __first, _Size __count, _OutputIterator __result)\fC [inline]\fP"
.PP
Copies the range [first,first+count) into [result,result+count). 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input iterator. 
.br
\fIcount\fP The number of elements to copy. 
.br
\fIresult\fP An output iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
A \fBstd::pair\fP composed of first+count and result+count.
.RE
.PP
This is an SGI extension. This inline function will boil down to a call to \fCmemmove\fP whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). 
.PP
Definition at line 119 of file ext/algorithm.
.PP
References std::__iterator_category().
.SS "template<typename _InputIterator , typename _Distance > void __gnu_cxx::distance (_InputIterator __first, _InputIterator __last, _Distance & __n)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 103 of file ext/iterator.
.PP
References std::__iterator_category().
.SS "template<class _Tp > _Tp __gnu_cxx::identity_element (\fBstd::multiplies\fP< _Tp >)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 93 of file ext/functional.
.SS "template<class _Tp > _Tp __gnu_cxx::identity_element (\fBstd::plus\fP< _Tp >)\fC [inline]\fP"
.PP
An \fBSGI extension \fP. 
.PP
Definition at line 87 of file ext/functional.
.SS "template<typename _ForwardIter , typename _Tp > void __gnu_cxx::iota (_ForwardIter __first, _ForwardIter __last, _Tp __value)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 132 of file ext/numeric.
.SS "template<typename _RandomAccessIterator , typename _StrictWeakOrdering > bool __gnu_cxx::is_heap (_RandomAccessIterator __first, _RandomAccessIterator __last, _StrictWeakOrdering __comp)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 452 of file ext/algorithm.
.SS "template<typename _RandomAccessIterator > bool __gnu_cxx::is_heap (_RandomAccessIterator __first, _RandomAccessIterator __last)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 433 of file ext/algorithm.
.SS "template<typename _ForwardIterator , typename _StrictWeakOrdering > bool __gnu_cxx::is_sorted (_ForwardIterator __first, _ForwardIterator __last, _StrictWeakOrdering __comp)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 502 of file ext/algorithm.
.SS "template<typename _ForwardIterator > bool __gnu_cxx::is_sorted (_ForwardIterator __first, _ForwardIterator __last)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 477 of file ext/algorithm.
.SS "template<typename _InputIterator1 , typename _InputIterator2 > int __gnu_cxx::lexicographical_compare_3way (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\fC [inline]\fP"
.PP
\fCmemcmp\fP on steroids. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst1\fP An input iterator. 
.br
\fIlast1\fP An input iterator. 
.br
\fIfirst2\fP An input iterator. 
.br
\fIlast2\fP An input iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
An int, as with \fCmemcmp\fP.
.RE
.PP
The return value will be less than zero if the first range is 'lexigraphically less than' the second, greater than zero if the second range is 'lexigraphically less than' the first, and zero otherwise. This is an SGI extension. 
.PP
Definition at line 199 of file ext/algorithm.
.SS "template<typename _Tp , typename _Integer > _Tp __gnu_cxx::power (_Tp __x, _Integer __n)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 121 of file ext/numeric.
.SS "template<typename _Tp , typename _Integer , typename _MonoidOperation > _Tp __gnu_cxx::power (_Tp __x, _Integer __n, _MonoidOperation __monoid_op)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 111 of file ext/numeric.
.SS "template<typename _InputIterator , typename _RandomAccessIterator , typename _RandomNumberGenerator > _RandomAccessIterator __gnu_cxx::random_sample (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last, _RandomNumberGenerator & __rand)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 409 of file ext/algorithm.
.SS "template<typename _InputIterator , typename _RandomAccessIterator > _RandomAccessIterator __gnu_cxx::random_sample (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __out_first, _RandomAccessIterator __out_last)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 386 of file ext/algorithm.
.SS "template<typename _ForwardIterator , typename _OutputIterator , typename _Distance , typename _RandomNumberGenerator > _OutputIterator __gnu_cxx::random_sample_n (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distance __n, _RandomNumberGenerator & __rand)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 299 of file ext/algorithm.
.PP
References std::distance(), and __gnu_parallel::min().
.SS "template<typename _ForwardIterator , typename _OutputIterator , typename _Distance > _OutputIterator __gnu_cxx::random_sample_n (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out, const _Distance __n)\fC [inline]\fP"
.PP
This is an SGI extension.
.PP
\fBTodo\fP
.RS 4
Doc me! See doc/doxygen/TODO and http://gcc.gnu.org/ml/libstdc++/2002-02/msg00003.html for more. 
.RE
.PP

.PP
Definition at line 265 of file ext/algorithm.
.PP
References std::distance(), and __gnu_parallel::min().
.SS "template<typename _InputIter , typename _Size , typename _ForwardIter > pair<_InputIter, _ForwardIter> __gnu_cxx::uninitialized_copy_n (_InputIter __first, _Size __count, _ForwardIter __result)\fC [inline]\fP"
.PP
Copies the range [first,last) into result. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input iterator. 
.br
\fIlast\fP An input iterator. 
.br
\fIresult\fP An output iterator. 
.RE
.PP
\fBReturns:\fP
.RS 4
result + (first - last)
.RE
.PP
Like copy(), but does not require an initialized output range. 
.PP
Definition at line 121 of file ext/memory.
.PP
References std::__iterator_category().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
