.TH "Mutexes" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Mutexes \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstd::adopt_lock_t\fP"
.br
.RI "\fIAssume the calling \fBthread\fP has already obtained \fBmutex\fP ownership and manage it. \fP"
.ti -1c
.RI "struct \fBstd::defer_lock_t\fP"
.br
.RI "\fIDo not acquire ownership of the \fBmutex\fP. \fP"
.ti -1c
.RI "class \fBstd::lock_error\fP"
.br
.RI "\fIThrown to indicate errors with lock operations. \fP"
.ti -1c
.RI "class \fBstd::lock_guard< _Mutex >\fP"
.br
.RI "\fIScoped lock idiom. \fP"
.ti -1c
.RI "class \fBstd::mutex\fP"
.br
.RI "\fI\fBmutex\fP \fP"
.ti -1c
.RI "struct \fBstd::once_flag\fP"
.br
.RI "\fI\fBonce_flag\fP \fP"
.ti -1c
.RI "class \fBstd::recursive_mutex\fP"
.br
.RI "\fI\fBrecursive_mutex\fP \fP"
.ti -1c
.RI "class \fBstd::recursive_timed_mutex\fP"
.br
.RI "\fI\fBrecursive_timed_mutex\fP \fP"
.ti -1c
.RI "class \fBstd::timed_mutex\fP"
.br
.RI "\fI\fBtimed_mutex\fP \fP"
.ti -1c
.RI "struct \fBstd::try_to_lock_t\fP"
.br
.RI "\fITry to acquire ownership of the \fBmutex\fP without blocking. \fP"
.ti -1c
.RI "class \fBstd::unique_lock< _Mutex >\fP"
.br
.RI "\fI\fBunique_lock\fP \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "unique_lock< mutex > & \fBstd::__get_once_functor_lock\fP ()"
.br
.ti -1c
.RI "void \fBstd::__once_proxy\fP ()"
.br
.ti -1c
.RI "template<typename _Callable , typename... _Args> void \fBstd::call_once\fP (once_flag &__once, _Callable __f, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename _L1 , typename _L2 , typename... _L3> void \fBstd::lock\fP (_L1 &, _L2 &, _L3 &...)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBstd::swap\fP (unique_lock< _Mutex > &__x, unique_lock< _Mutex > &&__y)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBstd::swap\fP (unique_lock< _Mutex > &&__x, unique_lock< _Mutex > &__y)"
.br
.ti -1c
.RI "template<typename _Mutex > void \fBstd::swap\fP (unique_lock< _Mutex > &__x, unique_lock< _Mutex > &__y)"
.br
.ti -1c
.RI "template<typename _Lock1 , typename _Lock2 , typename... _Lock3> int \fBstd::try_lock\fP (_Lock1 &__l1, _Lock2 &__l2, _Lock3 &...__l3)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "function< void()> \fBstd::__once_functor\fP"
.br
.ti -1c
.RI "const adopt_lock_t \fBstd::adopt_lock\fP"
.br
.ti -1c
.RI "const defer_lock_t \fBstd::defer_lock\fP"
.br
.ti -1c
.RI "const try_to_lock_t \fBstd::try_to_lock\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Classes for \fBmutex\fP support. 
.SH "Function Documentation"
.PP 
.SS "template<typename _Callable , typename... _Args> void std::call_once (once_flag & __once, _Callable __f, _Args &&... __args)\fC [inline]\fP"
.PP
call_once 
.PP
Definition at line 741 of file mutex.
.PP
References std::once_flag::_M_once, std::bind(), std::unique_lock< _Mutex >::lock(), and std::unique_lock< _Mutex >::unlock().
.SS "template<typename _L1 , typename _L2 , typename... _L3> void std::lock (_L1 &, _L2 &, _L3 & ...)\fC [inline]\fP"
.PP
lock 
.PP
.SS "template<typename _Lock1 , typename _Lock2 , typename... _Lock3> int std::try_lock (_Lock1 & __l1, _Lock2 & __l2, _Lock3 &... __l3)\fC [inline]\fP"
.PP
Generic try_lock. 
.PP
\fBParameters:\fP
.RS 4
\fI__l1\fP Meets Mutex requirements (\fBtry_lock()\fP may throw). 
.br
\fI__l2\fP Meets Mutex requirements (\fBtry_lock()\fP may throw). 
.br
\fI__l3\fP Meets Mutex requirements (\fBtry_lock()\fP may throw). 
.RE
.PP
\fBReturns:\fP
.RS 4
Returns -1 if all \fBtry_lock()\fP calls return true. Otherwise returns a 0-based index corresponding to the argument that returned false. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
Either all arguments are locked, or none will be.
.RE
.PP
Sequentially calls \fBtry_lock()\fP on each argument. 
.PP
Definition at line 686 of file mutex.
.PP
References std::try_lock().
.PP
Referenced by std::try_lock().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
