.TH "std::deque" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::deque \- A standard container using fixed-size memory allocation and constant-time manipulation of elements at either end.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fB_Deque_base< _Tp, _Alloc >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base::const_iterator\fP \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBconst_iterator\fP > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef ptrdiff_t \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef \fB_Base::iterator\fP \fBiterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::reference \fBreference\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< \fBiterator\fP > \fBreverse_iterator\fP"
.br
.ti -1c
.RI "typedef size_t \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Tp \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBback\fP () const "
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBbegin\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBcend\fP () const "
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const "
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const "
.br
.ti -1c
.RI "template<typename _InputIterator > \fBdeque\fP (_InputIterator __first, _InputIterator __last, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBdeque\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBdeque\fP (\fBdeque\fP &&__x)"
.br
.ti -1c
.RI "\fBdeque\fP (const \fBdeque\fP &__x)"
.br
.ti -1c
.RI "\fBdeque\fP (size_type __n, const value_type &__value=value_type(), const allocator_type &__a=allocator_type())"
.br
.ti -1c
.RI "\fBdeque\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fBdeque\fP ()"
.br
.ti -1c
.RI "template<typename... _Args> \fBiterator\fP \fBemplace\fP (\fBiterator\fP __position, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace_back\fP (_Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fBemplace_front\fP (_Args &&...__args)"
.br
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "\fBconst_iterator\fP \fBend\fP () const "
.br
.ti -1c
.RI "\fBiterator\fP \fBend\fP ()"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "\fBiterator\fP \fBerase\fP (\fBiterator\fP __position)"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const "
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.ti -1c
.RI "template<typename _InputIterator > void \fBinsert\fP (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __position, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, value_type &&__x)"
.br
.ti -1c
.RI "\fBiterator\fP \fBinsert\fP (\fBiterator\fP __position, const value_type &__x)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const "
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (\fBinitializer_list\fP< value_type > __l)"
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (\fBdeque\fP &&__x)"
.br
.ti -1c
.RI "\fBdeque\fP & \fBoperator=\fP (const \fBdeque\fP &__x)"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const "
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpop_front\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (const value_type &__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (value_type &&__x)"
.br
.ti -1c
.RI "void \fBpush_front\fP (const value_type &__x)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const "
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, value_type __x=value_type())"
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.ti -1c
.RI "void \fBswap\fP (\fBdeque\fP &&__x)"
.br
.ti -1c
.RI "\fB~deque\fP ()"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum "
.br
.ti -1c
.RI "typedef _Alloc::template rebind< _Tp * >::other \fB_Map_alloc_type\fP"
.br
.ti -1c
.RI "typedef pointer * \fB_Map_pointer\fP"
.br
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "_Tp ** \fB_M_allocate_map\fP (size_t __n)"
.br
.ti -1c
.RI "_Tp * \fB_M_allocate_node\fP ()"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_create_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "void \fB_M_deallocate_map\fP (_Tp **__p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_deallocate_node\fP (_Tp *__p)"
.br
.ti -1c
.RI "void \fB_M_destroy_data\fP (\fBiterator\fP __first, \fBiterator\fP __last, const \fBstd::allocator\fP< _Tp > &)"
.br
.ti -1c
.RI "template<typename _Alloc1 > void \fB_M_destroy_data\fP (\fBiterator\fP __first, \fBiterator\fP __last, const _Alloc1 &)"
.br
.ti -1c
.RI "void \fB_M_destroy_data_aux\fP (\fBiterator\fP __first, \fBiterator\fP __last)"
.br
.ti -1c
.RI "void \fB_M_destroy_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "void \fB_M_erase_at_begin\fP (\fBiterator\fP __pos)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (\fBiterator\fP __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const value_type &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (const value_type &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (\fBiterator\fP __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "_Map_alloc_type \fB_M_get_map_allocator\fP () const"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP ()"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "void \fB_M_initialize_map\fP (size_t)"
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_insert_aux\fP (\fBiterator\fP __pos, _ForwardIterator __first, _ForwardIterator __last, size_type __n)"
.br
.ti -1c
.RI "void \fB_M_insert_aux\fP (\fBiterator\fP __pos, size_type __n, const value_type &__x)"
.br
.ti -1c
.RI "template<typename... _Args> \fBiterator\fP \fB_M_insert_aux\fP (\fBiterator\fP __pos, _Args &&...__args)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_insert_dispatch\fP (\fBiterator\fP __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "template<typename _Integer > void \fB_M_insert_dispatch\fP (\fBiterator\fP __pos, _Integer __n, _Integer __x, __true_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const "
.br
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_insert_aux\fP (\fBiterator\fP __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_insert_aux\fP (\fBiterator\fP __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fB_M_new_elements_at_back\fP (size_type __new_elements)"
.br
.ti -1c
.RI "void \fB_M_new_elements_at_front\fP (size_type __new_elements)"
.br
.ti -1c
.RI "\fBiterator\fP \fB_M_reserve_elements_at_back\fP (size_type __n)"
.br
.ti -1c
.RI "\fBiterator\fP \fB_M_reserve_elements_at_front\fP (size_type __n)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fB_M_pop_back_aux\fP ()"
.br
.ti -1c
.RI "void \fB_M_pop_front_aux\fP ()"
.br
.ti -1c
.RI "template<typename... _Args> void \fB_M_push_back_aux\fP (_Args &&...__args)"
.br
.ti -1c
.RI "template<typename... _Args> void \fB_M_push_front_aux\fP (_Args &&...__args)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "template<typename _ForwardIterator > void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "template<typename _InputIterator > void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "void \fB_M_reallocate_map\fP (size_type __nodes_to_add, bool __add_at_front)"
.br
.ti -1c
.RI "void \fB_M_reserve_map_at_back\fP (size_type __nodes_to_add=1)"
.br
.ti -1c
.RI "void \fB_M_reserve_map_at_front\fP (size_type __nodes_to_add=1)"
.br
.in -1c
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static size_t \fB_S_buffer_size\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Deque_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> class std::deque< _Tp, _Alloc >"
A standard container using fixed-size memory allocation and constant-time manipulation of elements at either end. 

Meets the requirements of a \fCcontainer\fP, a \fCreversible container\fP, and a \fCsequence\fP, including the \fCoptional sequence requirements\fP.
.PP
In previous HP/SGI versions of \fBdeque\fP, there was an extra template parameter so users could control the node size. This extension turned out to violate the C++ standard (it can be detected using template template parameters), and it was removed.
.PP
Here's how a deque<Tp> manages memory. Each \fBdeque\fP has 4 members:
.PP
.IP "\(bu" 2
Tp** _M_map
.IP "\(bu" 2
size_t _M_map_size
.IP "\(bu" 2
\fBiterator\fP _M_start, _M_finish
.PP
.PP
map_size is at least 8. map is an \fBarray\fP of map_size pointers-to-'nodes'. (The name map has nothing to do with the \fBstd::map\fP class, and 'nodes' should not be confused with \fBstd::list\fP's usage of 'node'.)
.PP
A 'node' has no specific type name as such, but it is referred to as 'node' in this file. It is a simple array-of-Tp. If Tp is very large, there will be one Tp element per node (i.e., an 'array' of one). For non-huge Tp's, node size is inversely related to Tp size: the larger the Tp, the fewer Tp's will fit in a node. The goal here is to keep the total size of a node relatively small and constant over different Tp's, to improve \fBallocator\fP efficiency.
.PP
Not every pointer in the map \fBarray\fP will point to a node. If the initial number of elements in the \fBdeque\fP is small, the /middle/ map pointers will be valid, and the ones at the edges will be unused. This same situation will arise as the map grows: available map pointers, if any, will be on the ends. As new nodes are created, only a subset of the map's pointers need to be copied 'outward'.
.PP
Class invariants:
.IP "\(bu" 2
For any nonsingular \fBiterator\fP i:
.IP "  \(bu" 4
i.node points to a member of the map \fBarray\fP. (Yes, you read that correctly: i.node does not actually point to a node.) The member of the map \fBarray\fP is what actually points to the node.
.IP "  \(bu" 4
i.first == *(i.node) (This points to the node (first Tp element).)
.IP "  \(bu" 4
i.last == i.first + node_size
.IP "  \(bu" 4
i.cur is a pointer in the range [i.first, i.last). NOTE: the implication of this is that i.cur is always a dereferenceable pointer, even if i is a past-the-end \fBiterator\fP.
.PP

.IP "\(bu" 2
Start and Finish are always nonsingular iterators. NOTE: this means that an empty \fBdeque\fP must have one node, a \fBdeque\fP with <N elements (where N is the node buffer size) must have one node, a \fBdeque\fP with N through (2N-1) elements must have two nodes, etc.
.IP "\(bu" 2
For every node other than start.node and finish.node, every element in the node is an initialized object. If start.node == finish.node, then [start.cur, finish.cur) are initialized objects, and the elements outside that range are uninitialized storage. Otherwise, [start.cur, start.last) and [finish.first, finish.cur) are initialized objects, and [start.first, start.cur) and [finish.cur, finish.last) are uninitialized storage.
.IP "\(bu" 2
[map, map + map_size) is a valid, non-empty range.
.IP "\(bu" 2
[start.node, finish.node] is a valid range contained within [map, map + map_size).
.IP "\(bu" 2
A pointer in the range [map, map + map_size) points to an allocated node if and only if the pointer is in the range [start.node, finish.node].
.PP
.PP
Here's the magic: nothing in \fBdeque\fP is 'aware' of the discontiguous storage!
.PP
The memory setup and layout occurs in the parent, _Base, and the \fBiterator\fP class is entirely responsible for 'leaping' from one node to the next. All the implementation routines for \fBdeque\fP itself work only through the start and finish iterators. This keeps the routines simple and sane, and we can use other standard algorithms as well. 
.PP
Definition at line 638 of file stl_deque.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP ()\fC [inline]\fP"
.PP
Default constructor creates no elements. 
.PP
Definition at line 690 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (const allocator_type & __a)\fC [inline, explicit]\fP"
.PP
Creates a deque with no elements. 
.PP
\fBParameters:\fP
.RS 4
\fIa\fP An \fBallocator\fP object. 
.RE
.PP

.PP
Definition at line 698 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (size_type __n, const value_type & __value = \fCvalue_type()\fP, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline, explicit]\fP"
.PP
Creates a deque with copies of an exemplar element. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The number of elements to initially create. 
.br
\fIvalue\fP An element to copy. 
.br
\fIa\fP An \fBallocator\fP.
.RE
.PP
This constructor fills the deque with \fIn\fP copies of \fIvalue\fP. 
.PP
Definition at line 710 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (const \fBdeque\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
Deque copy constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created deque uses a copy of the allocation object used by \fIx\fP. 
.PP
Definition at line 722 of file stl_deque.h.
.PP
References std::deque< _Tp, _Alloc >::begin(), and std::deque< _Tp, _Alloc >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (\fBdeque\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Deque move constructor. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque of identical element and \fBallocator\fP types.
.RE
.PP
The newly-created deque contains the exact contents of \fIx\fP. The contents of \fIx\fP are a valid, but unspecified deque. 
.PP
Definition at line 736 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (\fBinitializer_list\fP< value_type > __l, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a deque from an initializer \fBlist\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP. 
.br
\fIa\fP An \fBallocator\fP object.
.RE
.PP
Create a deque consisting of copies of the elements in the \fBinitializer_list\fP \fIl\fP.
.PP
This will call the element type's copy constructor N times (where N is l.size()) and do no memory reallocation. 
.PP
Definition at line 750 of file stl_deque.h.
.PP
References std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > \fBstd::deque\fP< _Tp, _Alloc >::\fBdeque\fP (_InputIterator __first, _InputIterator __last, const allocator_type & __a = \fCallocator_type()\fP)\fC [inline]\fP"
.PP
Builds a deque from a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.br
\fIa\fP An \fBallocator\fP object.
.RE
.PP
Create a deque consisting of copies of the elements from [first, last).
.PP
If the iterators are forward, bidirectional, or random-access, then this will call the elements' copy constructor N times (where N is distance(first,last)) and do no memory reallocation. But if only input iterators are used, then this will do at most 2N calls to the copy constructor, and logN memory reallocations. 
.PP
Definition at line 775 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBstd::deque\fP< _Tp, _Alloc >::~\fBdeque\fP ()\fC [inline]\fP"
.PP
The dtor only erases the elements, and note that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 789 of file stl_deque.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp , typename _Alloc > void deque::_M_fill_initialize (const value_type & __value)\fC [inline, protected]\fP"
.PP
Fills the deque with copies of value. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Initial value. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing. 
.RE
.PP
\fBPrecondition:\fP
.RS 4
_M_start and _M_finish have already been initialized, but none of the deque's elements have yet been constructed.
.RE
.PP
This function is called only when the user provides an explicit size (with or without an explicit exemplar value). 
.PP
Definition at line 277 of file deque.tcc.
.PP
References std::_Destroy().
.SS "template<typename _Tp , typename _Alloc > void deque::_M_new_elements_at_back (size_type __new_elements)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the previous internal insert functions. 
.PP
Definition at line 771 of file deque.tcc.
.PP
References std::deque< _Tp, _Alloc >::_M_reserve_map_at_back(), std::deque< _Tp, _Alloc >::max_size(), and std::deque< _Tp, _Alloc >::size().
.SS "template<typename _Tp , typename _Alloc > void deque::_M_new_elements_at_front (size_type __new_elements)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the previous internal insert functions. 
.PP
Definition at line 746 of file deque.tcc.
.PP
References std::deque< _Tp, _Alloc >::_M_reserve_map_at_front(), std::deque< _Tp, _Alloc >::max_size(), and std::deque< _Tp, _Alloc >::size().
.SS "template<typename _Tp , typename _Alloc > void deque::_M_pop_back_aux ()\fC [inline, protected]\fP"
.PP
Helper functions for push_* and pop_*. 
.PP
Definition at line 427 of file deque.tcc.
.SS "template<typename _Tp , typename _Alloc > void deque::_M_pop_front_aux ()\fC [inline, protected]\fP"
.PP
Helper functions for push_* and pop_*. 
.PP
Definition at line 442 of file deque.tcc.
.SS "template<typename _Tp , typename _Alloc > template<typename... _Args> void deque::_M_push_back_aux (_Args &&... __args)\fC [inline, protected]\fP"
.PP
Helper functions for push_* and pop_*. 
.PP
Definition at line 361 of file deque.tcc.
.SS "template<typename _Tp , typename _Alloc > template<typename... _Args> void deque::_M_push_front_aux (_Args &&... __args)\fC [inline, protected]\fP"
.PP
Helper functions for push_* and pop_*. 
.PP
Definition at line 395 of file deque.tcc.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_range_check (size_type __n) const\fC [inline, protected]\fP"
.PP
Safety check used only from \fBat()\fP. 
.PP
Definition at line 1076 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > template<typename _ForwardIterator > void deque::_M_range_initialize (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)\fC [inline, protected]\fP"
.PP
Fills the \fBdeque\fP with whatever is in [first,last). 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
If the iterators are actually forward iterators (or better), then the memory layout can be done all at once. Else we move forward using push_back on each value from the \fBiterator\fP. 
.PP
Definition at line 323 of file deque.tcc.
.PP
References std::_Destroy(), std::_Deque_base< _Tp, _Alloc >::_M_initialize_map(), std::advance(), and std::distance().
.SS "template<typename _Tp , typename _Alloc > template<typename _InputIterator > void deque::_M_range_initialize (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)\fC [inline, protected]\fP"
.PP
Fills the \fBdeque\fP with whatever is in [first,last). 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
If the iterators are actually forward iterators (or better), then the memory layout can be done all at once. Else we move forward using push_back on each value from the \fBiterator\fP. 
.PP
Definition at line 303 of file deque.tcc.
.PP
References std::_Deque_base< _Tp, _Alloc >::_M_initialize_map(), std::deque< _Tp, _Alloc >::clear(), and std::deque< _Tp, _Alloc >::push_back().
.SS "template<typename _Tp , typename _Alloc > void deque::_M_reallocate_map (size_type __nodes_to_add, bool __add_at_front)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the major map. 
.PP
Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) 
.PP
Definition at line 796 of file deque.tcc.
.PP
References std::copy_backward(), and std::max().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_elements_at_back (size_type __n)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the previous internal insert functions. 
.PP
Definition at line 1689 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_elements_at_front (size_type __n)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the previous internal insert functions. 
.PP
Definition at line 1679 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_map_at_back (size_type __nodes_to_add = \fC1\fP)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the major map. 
.PP
Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) 
.PP
Definition at line 1715 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_new_elements_at_back().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::_M_reserve_map_at_front (size_type __nodes_to_add = \fC1\fP)\fC [inline, protected]\fP"
.PP
Memory-handling helpers for the major map. 
.PP
Makes sure the _M_map has space for new nodes. Does not actually add the nodes. Can invalidate _M_map pointers. (And consequently, deque iterators.) 
.PP
Definition at line 1723 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_new_elements_at_front().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::assign (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Assigns an initializer \fBlist\fP to a deque. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function fills a deque with copies of the elements in the \fBinitializer_list\fP \fIl\fP.
.PP
Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 885 of file stl_deque.h.
.PP
References std::deque< _Tp, _Alloc >::assign(), std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.PP
Referenced by std::deque< _Tp, _Alloc >::assign().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::deque\fP< _Tp, _Alloc >::assign (_InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Assigns a range to a deque. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function fills a deque with copies of the elements in the range [first,last).
.PP
Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 866 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::assign (size_type __n, const value_type & __val)\fC [inline]\fP"
.PP
Assigns a given value to a deque. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP Number of elements to be assigned. 
.br
\fIval\fP Value to be assigned.
.RE
.PP
This function fills a deque with \fIn\fP copies of the given value. Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 849 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::at (size_type __n) const\fC [inline]\fP"
.PP
Provides access to the data contained in the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference to data. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIn\fP is an invalid index.
.RE
.PP
This function provides for safer data access. The parameter is first checked that it is in the range of the \fBdeque\fP. The function throws \fBout_of_range\fP if the check fails. 
.PP
Definition at line 1113 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::at (size_type __n)\fC [inline]\fP"
.PP
Provides access to the data contained in the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference to data. 
.RE
.PP
\fBExceptions:\fP
.RS 4
\fI\fBstd::out_of_range\fP\fP If \fIn\fP is an invalid index.
.RE
.PP
This function provides for safer data access. The parameter is first checked that it is in the range of the \fBdeque\fP. The function throws \fBout_of_range\fP if the check fails. 
.PP
Definition at line 1095 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::back () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the last element of the deque. 
.PP
Definition at line 1152 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::back ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the last element of the deque. 
.PP
Definition at line 1140 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::begin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 908 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::begin ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points to the first element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 900 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::deque(), std::deque< _Tp, _Alloc >::erase(), and std::operator==().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::cbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points to the first element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 971 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::cend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 980 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::clear ()\fC [inline]\fP"
.PP
Erases all the elements. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 1422 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_range_initialize(), and std::deque< _Tp, _Alloc >::erase().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::crbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 989 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::crend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 998 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > template<typename... _Args> \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::emplace (\fBiterator\fP __position, _Args &&... __args)\fC [inline]\fP"
.PP
Inserts an object in deque before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the deque. 
.br
\fIargs\fP Arguments. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert an object of type T constructed with T(std::forward<Args>(args)...) before the specified location. 
.PP
Definition at line 144 of file deque.tcc.
.PP
References std::_Deque_iterator< _Tp, _Ref, _Ptr >::_M_cur, std::deque< _Tp, _Alloc >::push_back(), and std::deque< _Tp, _Alloc >::push_front().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> bool \fBstd::deque\fP< _Tp, _Alloc >::empty () const\fC [inline]\fP"
.PP
Returns true if the deque is empty. (Thus \fBbegin()\fP would equal \fBend()\fP.) 
.PP
Definition at line 1039 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::end () const\fC [inline]\fP"
.PP
Returns a read-only (constant) \fBiterator\fP that points one past the last element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 926 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::end ()\fC [inline]\fP"
.PP
Returns a read/write \fBiterator\fP that points one past the last element in the deque. Iteration is done in ordinary element order. 
.PP
Definition at line 917 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::deque(), std::deque< _Tp, _Alloc >::erase(), and std::operator==().
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::erase (\fBiterator\fP __first, \fBiterator\fP __last)\fC [inline]\fP"
.PP
Remove a range of elements. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP Iterator pointing to the first element to be erased. 
.br
\fIlast\fP Iterator pointing to one past the last element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the element pointed to by \fIlast\fP prior to erasing (or \fBend()\fP).
.RE
.PP
This function will erase the elements in the range [first,last) and shorten the deque accordingly.
.PP
The user is cautioned that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 189 of file deque.tcc.
.PP
References std::deque< _Tp, _Alloc >::begin(), std::deque< _Tp, _Alloc >::clear(), std::deque< _Tp, _Alloc >::end(), and std::deque< _Tp, _Alloc >::size().
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::erase (\fBiterator\fP __position)\fC [inline]\fP"
.PP
Remove element at given position. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP Iterator pointing to element to be erased. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the next element (or \fBend()\fP).
.RE
.PP
This function will erase the element at the given position and thus shorten the deque by one.
.PP
The user is cautioned that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. 
.PP
Definition at line 166 of file deque.tcc.
.PP
References std::deque< _Tp, _Alloc >::begin(), std::deque< _Tp, _Alloc >::end(), std::deque< _Tp, _Alloc >::pop_back(), std::deque< _Tp, _Alloc >::pop_front(), and std::deque< _Tp, _Alloc >::size().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::front () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reference to the data at the first element of the deque. 
.PP
Definition at line 1132 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::front ()\fC [inline]\fP"
.PP
Returns a read/write reference to the data at the first element of the deque. 
.PP
Definition at line 1124 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> allocator_type \fBstd::deque\fP< _Tp, _Alloc >::get_allocator () const\fC [inline]\fP"
.PP
Get a copy of the memory allocation object. 
.PP
Reimplemented from \fBstd::_Deque_base< _Tp, _Alloc >\fP.
.PP
Definition at line 891 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> template<typename _InputIterator > void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, _InputIterator __first, _InputIterator __last)\fC [inline]\fP"
.PP
Inserts a range into the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the deque. 
.br
\fIfirst\fP An input \fBiterator\fP. 
.br
\fIlast\fP An input \fBiterator\fP.
.RE
.PP
This function will insert copies of the data in the range [first,last) into the deque before the location specified by \fIpos\fP. This is known as 'range insert.' 
.PP
Definition at line 1345 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, size_type __n, const value_type & __x)\fC [inline]\fP"
.PP
Inserts a number of copies of given data into the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the deque. 
.br
\fIn\fP Number of elements to be inserted. 
.br
\fIx\fP Data to be inserted.
.RE
.PP
This function will insert a specified number of copies of the given data before the location specified by \fIposition\fP. 
.PP
Definition at line 1330 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP __p, \fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Inserts an initializer \fBlist\fP into the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIp\fP An \fBiterator\fP into the deque. 
.br
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function will insert copies of the data in the \fBinitializer_list\fP \fIl\fP into the deque before the location specified by \fIp\fP. This is known as 'list insert.' 
.PP
Definition at line 1316 of file stl_deque.h.
.PP
References std::initializer_list< _E >::begin(), std::initializer_list< _E >::end(), and std::deque< _Tp, _Alloc >::insert().
.PP
Referenced by std::deque< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBiterator\fP \fBstd::deque\fP< _Tp, _Alloc >::insert (\fBiterator\fP __position, value_type && __x)\fC [inline]\fP"
.PP
Inserts given rvalue into deque before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the deque. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given rvalue before the specified location. 
.PP
Definition at line 1303 of file stl_deque.h.
.PP
References std::move().
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc >::\fBiterator\fP deque::insert (\fBiterator\fP __position, const value_type & __x)\fC [inline]\fP"
.PP
Inserts given value into deque before specified \fBiterator\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIposition\fP An \fBiterator\fP into the deque. 
.br
\fIx\fP Data to be inserted. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP that points to the inserted data.
.RE
.PP
This function will insert a copy of the given value before the specified location. 
.PP
Definition at line 121 of file deque.tcc.
.PP
References std::_Deque_iterator< _Tp, _Ref, _Ptr >::_M_cur, std::deque< _Tp, _Alloc >::push_back(), and std::deque< _Tp, _Alloc >::push_front().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::deque\fP< _Tp, _Alloc >::max_size () const\fC [inline]\fP"
.PP
Returns the \fBsize()\fP of the largest possible deque. 
.PP
Definition at line 1010 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_new_elements_at_back(), and std::deque< _Tp, _Alloc >::_M_new_elements_at_front().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBdeque\fP& \fBstd::deque\fP< _Tp, _Alloc >::operator= (\fBinitializer_list\fP< value_type > __l)\fC [inline]\fP"
.PP
Assigns an initializer \fBlist\fP to a deque. 
.PP
\fBParameters:\fP
.RS 4
\fIl\fP An \fBinitializer_list\fP.
.RE
.PP
This function fills a deque with copies of the elements in the \fBinitializer_list\fP \fIl\fP.
.PP
Note that the assignment completely changes the deque and that the resulting deque's size is the same as the number of elements assigned. Old data may be lost. 
.PP
Definition at line 831 of file stl_deque.h.
.PP
References std::initializer_list< _E >::begin(), and std::initializer_list< _E >::end().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBdeque\fP& \fBstd::deque\fP< _Tp, _Alloc >::operator= (\fBdeque\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Deque move assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque of identical element and \fBallocator\fP types.
.RE
.PP
The contents of \fIx\fP are moved into this \fBdeque\fP (without copying). \fIx\fP is a valid, but unspecified deque. 
.PP
Definition at line 811 of file stl_deque.h.
.SS "template<typename _Tp , typename _Alloc > \fBdeque\fP< _Tp, _Alloc > & deque::operator= (const \fBdeque\fP< _Tp, _Alloc > & __x)\fC [inline]\fP"
.PP
Deque assignment operator. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque of identical element and \fBallocator\fP types.
.RE
.PP
All the elements of \fIx\fP are copied, but unlike the copy constructor, the \fBallocator\fP object is not copied. 
.PP
Definition at line 65 of file deque.tcc.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> const_reference \fBstd::deque\fP< _Tp, _Alloc >::operator[] (size_type __n) const\fC [inline]\fP"
.PP
Subscript access to the data contained in the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read-only (constant) reference to data.
.RE
.PP
This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and \fBout_of_range\fP lookups are not defined. (For checked lookups see \fBat()\fP.) 
.PP
Definition at line 1070 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> reference \fBstd::deque\fP< _Tp, _Alloc >::operator[] (size_type __n)\fC [inline]\fP"
.PP
Subscript access to the data contained in the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The index of the element for which data should be accessed. 
.RE
.PP
\fBReturns:\fP
.RS 4
Read/write reference to data.
.RE
.PP
This operator allows for easy, array-style, data access. Note that data access with this operator is unchecked and \fBout_of_range\fP lookups are not defined. (For checked lookups see \fBat()\fP.) 
.PP
Definition at line 1055 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::pop_back ()\fC [inline]\fP"
.PP
Removes last element. 
.PP
This is a typical \fBstack\fP operation. It shrinks the deque by one.
.PP
Note that no data is returned, and if the last element's data is needed, it should be retrieved before \fBpop_back()\fP is called. 
.PP
Definition at line 1253 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::erase().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::pop_front ()\fC [inline]\fP"
.PP
Removes first element. 
.PP
This is a typical \fBstack\fP operation. It shrinks the deque by one.
.PP
Note that no data is returned, and if the first element's data is needed, it should be retrieved before \fBpop_front()\fP is called. 
.PP
Definition at line 1232 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::erase().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::push_back (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the end of the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical \fBstack\fP operation. The function creates an element at the end of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time. 
.PP
Definition at line 1201 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_range_initialize(), std::deque< _Tp, _Alloc >::emplace(), and std::deque< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::push_front (const value_type & __x)\fC [inline]\fP"
.PP
Add data to the front of the deque. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP Data to be added.
.RE
.PP
This is a typical \fBstack\fP operation. The function creates an element at the front of the deque and assigns the given data to it. Due to the nature of a deque this operation can be done in constant time. 
.PP
Definition at line 1170 of file stl_deque.h.
.PP
References std::_Deque_iterator< _Tp, _Ref, _Ptr >::_M_cur.
.PP
Referenced by std::deque< _Tp, _Alloc >::emplace(), and std::deque< _Tp, _Alloc >::insert().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rbegin () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to the last element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 944 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rbegin ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to the last element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 935 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBconst_reverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rend () const\fC [inline]\fP"
.PP
Returns a read-only (constant) reverse \fBiterator\fP that points to one before the first element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 962 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> \fBreverse_iterator\fP \fBstd::deque\fP< _Tp, _Alloc >::rend ()\fC [inline]\fP"
.PP
Returns a read/write reverse \fBiterator\fP that points to one before the first element in the deque. Iteration is done in reverse element order. 
.PP
Definition at line 953 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::resize (size_type __new_size, value_type __x = \fCvalue_type()\fP)\fC [inline]\fP"
.PP
Resizes the deque to the specified number of elements. 
.PP
\fBParameters:\fP
.RS 4
\fInew_size\fP Number of elements the deque should contain. 
.br
\fIx\fP Data with which new elements should be populated.
.RE
.PP
This function will resize the deque to the specified number of elements. If the number is smaller than the deque's current size the deque is truncated, otherwise the deque is extended and new elements are populated with given data. 
.PP
Definition at line 1025 of file stl_deque.h.
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> size_type \fBstd::deque\fP< _Tp, _Alloc >::size () const\fC [inline]\fP"
.PP
Returns the number of elements in the deque. 
.PP
Definition at line 1005 of file stl_deque.h.
.PP
Referenced by std::deque< _Tp, _Alloc >::_M_new_elements_at_back(), std::deque< _Tp, _Alloc >::_M_new_elements_at_front(), std::deque< _Tp, _Alloc >::erase(), and std::operator==().
.SS "template<typename _Tp, typename _Alloc = std::allocator<_Tp>> void \fBstd::deque\fP< _Tp, _Alloc >::swap (\fBdeque\fP< _Tp, _Alloc > && __x)\fC [inline]\fP"
.PP
Swaps data with another deque. 
.PP
\fBParameters:\fP
.RS 4
\fIx\fP A deque of the same element and \fBallocator\fP types.
.RE
.PP
This exchanges the elements between two deques in constant time. (Four pointers, so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(d1,d2) will feed to this function. 
.PP
Definition at line 1399 of file stl_deque.h.
.PP
References std::_Deque_base< _Tp, _Alloc >::_M_get_Tp_allocator(), and std::_Deque_base< _Tp, _Alloc >::_M_impl.
.PP
Referenced by std::swap().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
