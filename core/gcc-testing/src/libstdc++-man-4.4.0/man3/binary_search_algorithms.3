.TH "Binary Search Algorithms" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Binary Search Algorithms \- 
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > bool \fBstd::binary_search\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > bool \fBstd::binary_search\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > pair< _ForwardIterator, _ForwardIterator > \fBstd::equal_range\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > pair< _ForwardIterator, _ForwardIterator > \fBstd::equal_range\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator \fBstd::lower_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > _ForwardIterator \fBstd::lower_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator \fBstd::upper_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val, _Compare __comp)"
.br
.ti -1c
.RI "template<typename _ForwardIterator , typename _Tp > _ForwardIterator \fBstd::upper_bound\fP (_ForwardIterator __first, _ForwardIterator __last, const _Tp &__val)"
.br
.in -1c
.SH "Detailed Description"
.PP 
These algorithms are variations of a classic binary search, and all assume that the sequence being searched is already sorted.
.PP
The number of comparisons will be logarithmic (and as few as possible). The number of steps through the sequence will be logarithmic for random-access iterators (e.g., pointers), and linear otherwise.
.PP
The LWG has passed Defect Report 270, which notes: \fIThe proposed resolution reinterprets binary search. Instead of thinking about searching for a value in a sorted range, we view that as an important special case of a more general algorithm: searching for the partition point in a partitioned range. We also add a guarantee that the old wording did not: we ensure that the upper bound is no earlier than the lower bound, that the \fBpair\fP returned by equal_range is a valid range, and that the first part of that \fBpair\fP is the lower bound.\fP
.PP
The actual effect of the first sentence is that a comparison functor passed by the user doesn't necessarily need to induce a strict weak ordering relation. Rather, it partitions the range. 
.SH "Function Documentation"
.PP 
.SS "template<typename _ForwardIterator , typename _Tp , typename _Compare > bool std::binary_search (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)\fC [inline]\fP"
.PP
Determines whether an element exists in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIval\fP (or its equivalent) is in [\fIfirst\fP,\fIlast\fP ].
.RE
.PP
Note that this does not actually return an \fBiterator\fP to \fIval\fP. For that, use std::find or a container's specialized find member functions.
.PP
The comparison function should have the same effects on ordering as the function used for the initial sort. 
.PP
Definition at line 2782 of file stl_algo.h.
.PP
References std::lower_bound().
.SS "template<typename _ForwardIterator , typename _Tp > bool std::binary_search (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)\fC [inline]\fP"
.PP
Determines whether an element exists in a range. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.RE
.PP
\fBReturns:\fP
.RS 4
True if \fIval\fP (or its equivalent) is in [\fIfirst\fP,\fIlast\fP ].
.RE
.PP
Note that this does not actually return an \fBiterator\fP to \fIval\fP. For that, use std::find or a container's specialized find member functions. 
.PP
Definition at line 2749 of file stl_algo.h.
.PP
References std::lower_bound().
.SS "template<typename _ForwardIterator , typename _Tp , typename _Compare > pair<_ForwardIterator, _ForwardIterator> std::equal_range (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)\fC [inline]\fP"
.PP
Finds the largest subrange in which \fIval\fP could be inserted at any place in it without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBpair\fP of iterators defining the subrange.
.RE
.PP
This is equivalent to 
.PP
.nf
    std::make_pair(lower_bound(first, last, val, comp),
                   upper_bound(first, last, val, comp))

.fi
.PP
 but does not actually call those functions. 
.PP
Definition at line 2688 of file stl_algo.h.
.PP
References std::advance(), std::distance(), std::lower_bound(), and std::upper_bound().
.SS "template<typename _ForwardIterator , typename _Tp > pair<_ForwardIterator, _ForwardIterator> std::equal_range (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)\fC [inline]\fP"
.PP
Finds the largest subrange in which \fIval\fP could be inserted at any place in it without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBpair\fP of iterators defining the subrange.
.RE
.PP
This is equivalent to 
.PP
.nf
    std::make_pair(lower_bound(first, last, val),
                   upper_bound(first, last, val))

.fi
.PP
 but does not actually call those functions. 
.PP
Definition at line 2626 of file stl_algo.h.
.PP
References std::advance(), std::distance(), std::lower_bound(), and std::upper_bound().
.SS "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator std::lower_bound (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)\fC [inline]\fP"
.PP
Finds the first position in which \fIval\fP could be inserted without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element 'not less than' \fIval\fP, or end() if every element is \fBless\fP than \fIval\fP.
.RE
.PP
The comparison function should have the same effects on ordering as the function used for the initial sort. 
.PP
Definition at line 2471 of file stl_algo.h.
.PP
References std::advance(), and std::distance().
.PP
Referenced by std::__merge_adaptive(), std::__merge_without_buffer(), std::map< _Key, _Tp, _Compare, _Alloc >::at(), std::binary_search(), std::equal_range(), __gnu_parallel::multiseq_selection(), and std::map< _Key, _Tp, _Compare, _Alloc >::operator[]().
.SS "template<typename _ForwardIterator , typename _Tp > _ForwardIterator std::lower_bound (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)\fC [inline]\fP"
.PP
Finds the first position in which \fIval\fP could be inserted without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element 'not \fBless\fP than' \fIval\fP, or end() if every element is \fBless\fP than \fIval\fP. 
.RE
.PP

.PP
Definition at line 2420 of file stl_algo.h.
.PP
References std::advance(), and std::distance().
.SS "template<typename _ForwardIterator , typename _Tp , typename _Compare > _ForwardIterator std::upper_bound (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val, _Compare __comp)\fC [inline]\fP"
.PP
Finds the last position in which \fIval\fP could be inserted without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.br
\fIcomp\fP A functor to use for comparisons. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element \fBgreater\fP than \fIval\fP, or end() if no elements are \fBgreater\fP than \fIval\fP.
.RE
.PP
The comparison function should have the same effects on ordering as the function used for the initial sort. 
.PP
Definition at line 2571 of file stl_algo.h.
.PP
References std::advance(), and std::distance().
.PP
Referenced by std::__merge_adaptive(), std::__merge_without_buffer(), std::equal_range(), and __gnu_parallel::multiway_merge_sampling_splitting().
.SS "template<typename _ForwardIterator , typename _Tp > _ForwardIterator std::upper_bound (_ForwardIterator __first, _ForwardIterator __last, const _Tp & __val)\fC [inline]\fP"
.PP
Finds the last position in which \fIval\fP could be inserted without changing the ordering. 
.PP
\fBParameters:\fP
.RS 4
\fIfirst\fP An \fBiterator\fP. 
.br
\fIlast\fP Another \fBiterator\fP. 
.br
\fIval\fP The search term. 
.RE
.PP
\fBReturns:\fP
.RS 4
An \fBiterator\fP pointing to the first element \fBgreater\fP than \fIval\fP, or end() if no elements are \fBgreater\fP than \fIval\fP. 
.RE
.PP

.PP
Definition at line 2520 of file stl_algo.h.
.PP
References std::advance(), and std::distance().
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
