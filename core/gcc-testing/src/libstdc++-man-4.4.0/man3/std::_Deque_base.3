.TH "std::_Deque_base" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::_Deque_base \- 
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fB_Deque_iterator\fP< _Tp, const _Tp &, const _Tp * > \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef \fB_Deque_iterator\fP< _Tp, _Tp &, _Tp * > \fBiterator\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB_Deque_base\fP (\fB_Deque_base\fP &&__x)"
.br
.ti -1c
.RI "\fB_Deque_base\fP (const allocator_type &__a)"
.br
.ti -1c
.RI "\fB_Deque_base\fP (const allocator_type &__a, size_t __num_elements)"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const "
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "enum { \fB_S_initial_map_size\fP }"
.br
.ti -1c
.RI "typedef _Alloc::template rebind< _Tp * >::other \fB_Map_alloc_type\fP"
.br
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "_Tp ** \fB_M_allocate_map\fP (size_t __n)"
.br
.ti -1c
.RI "_Tp * \fB_M_allocate_node\fP ()"
.br
.ti -1c
.RI "void \fB_M_create_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "void \fB_M_deallocate_map\fP (_Tp **__p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_deallocate_node\fP (_Tp *__p)"
.br
.ti -1c
.RI "void \fB_M_destroy_nodes\fP (_Tp **__nstart, _Tp **__nfinish)"
.br
.ti -1c
.RI "_Map_alloc_type \fB_M_get_map_allocator\fP () const "
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const "
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP ()"
.br
.ti -1c
.RI "void \fB_M_initialize_map\fP (size_t)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "_Deque_impl \fB_M_impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp, typename _Alloc> class std::_Deque_base< _Tp, _Alloc >"
Deque base class. This class provides the unified face for deque's allocation. This class's constructor and destructor allocate and deallocate (but do not initialize) storage. This makes exception safety easier.
.PP
Nothing in this class ever constructs or destroys an actual Tp element. (Deque handles that itself.) Only/All memory management is performed here. 
.PP
Definition at line 361 of file stl_deque.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp , typename _Alloc > void \fBstd::_Deque_base\fP< _Tp, _Alloc >::_M_initialize_map (size_t __num_elements)\fC [inline, protected]\fP"
.PP
Layout storage. 
.PP
\fBParameters:\fP
.RS 4
\fInum_elements\fP The count of T's for which to allocate space at first. 
.RE
.PP
\fBReturns:\fP
.RS 4
Nothing.
.RE
.PP
The initial underlying memory layout is a bit complicated... 
.PP
Definition at line 493 of file stl_deque.h.
.PP
References std::__deque_buf_size(), and __gnu_parallel::max().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
