.TH "std::__codecvt_abstract_base" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::__codecvt_abstract_base \- Common base for \fBcodecvt\fP functions.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBstd::locale::facet\fP, and \fBstd::codecvt_base\fP.
.PP
.SS "Public Types"
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "bool \fBalways_noconv\fP () const   throw ()"
.br
.ti -1c
.RI "int \fBencoding\fP () const   throw ()"
.br
.ti -1c
.RI "result \fBin\fP (state_type &__state, const extern_type *__from, const extern_type *__from_end, const extern_type *&__from_next, intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const "
.br
.ti -1c
.RI "int \fBlength\fP (state_type &__state, const extern_type *__from, const extern_type *__end, size_t __max) const "
.br
.ti -1c
.RI "int \fBmax_length\fP () const   throw ()"
.br
.ti -1c
.RI "result \fBout\fP (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.ti -1c
.RI "result \fBunshift\fP (state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const "
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fB__codecvt_abstract_base\fP (size_t __refs=0)"
.br
.ti -1c
.RI "virtual bool \fBdo_always_noconv\fP () const =0  throw ()"
.br
.ti -1c
.RI "virtual int \fBdo_encoding\fP () const =0  throw ()"
.br
.ti -1c
.RI "virtual result \fBdo_in\fP (state_type &__state, const extern_type *__from, const extern_type *__from_end, const extern_type *&__from_next, intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const =0"
.br
.ti -1c
.RI "virtual int \fBdo_length\fP (state_type &, const extern_type *__from, const extern_type *__end, size_t __max) const =0"
.br
.ti -1c
.RI "virtual int \fBdo_max_length\fP () const =0  throw ()"
.br
.ti -1c
.RI "virtual result \fBdo_out\fP (state_type &__state, const intern_type *__from, const intern_type *__from_end, const intern_type *&__from_next, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const =0"
.br
.ti -1c
.RI "virtual result \fBdo_unshift\fP (state_type &__state, extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const =0"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static __c_locale \fB_S_clone_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static void \fB_S_create_c_locale\fP (__c_locale &__cloc, const char *__s, __c_locale __old=0)"
.br
.ti -1c
.RI "static void \fB_S_destroy_c_locale\fP (__c_locale &__cloc)"
.br
.ti -1c
.RI "static __c_locale \fB_S_get_c_locale\fP ()"
.br
.ti -1c
.RI "static const char * \fB_S_get_c_name\fP ()"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "class \fBlocale::_Impl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _InternT, typename _ExternT, typename _StateT> class std::__codecvt_abstract_base< _InternT, _ExternT, _StateT >"
Common base for \fBcodecvt\fP functions. 

This template class provides implementations of the public functions that forward to the protected virtual functions.
.PP
This template also provides abstract stubs for the protected virtual functions. 
.PP
Definition at line 67 of file codecvt.h.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _InternT, typename _ExternT, typename _StateT> virtual result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::do_out (state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const\fC [protected, pure virtual]\fP"
.PP
Convert from internal to external character \fBset\fP. 
.PP
Converts input string of intern_type to output string of extern_type. This function is a hook for derived classes to change the value returned. 
.PP
\fBSee also:\fP
.RS 4
\fBout\fP for more information. 
.RE
.PP

.PP
Implemented in \fBstd::codecvt< _InternT, _ExternT, _StateT >\fP, \fBstd::codecvt< char, char, mbstate_t >\fP, \fBstd::codecvt< wchar_t, char, mbstate_t >\fP, \fBstd::codecvt< _InternT, _ExternT, encoding_state >\fP, and \fBstd::codecvt< _InternT, _ExternT, _StateT >\fP.
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::in (state_type & __state, const extern_type * __from, const extern_type * __from_end, const extern_type *& __from_next, intern_type * __to, intern_type * __to_end, intern_type *& __to_next) const\fC [inline]\fP"
.PP
Convert from external to internal character \fBset\fP. 
.PP
Converts input string of extern_type to output string of intern_type. This is analogous to mbsrtowcs. It does this by calling codecvt::do_in.
.PP
The source and destination character sets are determined by the facet's \fBlocale\fP, internal and external types.
.PP
The characters in [from,from_end) are converted and written to [to,to_end). from_next and to_next are \fBset\fP to point to the character following the last successfully converted character, respectively. If the result needed no conversion, from_next and to_next are not affected.
.PP
The \fIstate\fP argument should be initialized if the input is at the beginning and carried from a previous call if continuing conversion. There are no guarantees about how \fIstate\fP is used.
.PP
The result returned is a member of codecvt_base::result. If all the input is converted, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the input ends early or there is insufficient space in the output, returns codecvt_base::partial. Otherwise the conversion failed and codecvt_base::error is returned.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP Persistent conversion state data. 
.br
\fIfrom\fP Start of input. 
.br
\fIfrom_end\fP End of input. 
.br
\fIfrom_next\fP Returns start of unconverted data. 
.br
\fIto\fP Start of output buffer. 
.br
\fIto_end\fP End of output buffer. 
.br
\fIto_next\fP Returns start of unused output area. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result. 
.RE
.PP

.PP
Definition at line 195 of file codecvt.h.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::underflow().
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::out (state_type & __state, const intern_type * __from, const intern_type * __from_end, const intern_type *& __from_next, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const\fC [inline]\fP"
.PP
Convert from internal to external character \fBset\fP. 
.PP
Converts input string of intern_type to output string of extern_type. This is analogous to wcsrtombs. It does this by calling \fBcodecvt::do_out\fP.
.PP
The source and destination character sets are determined by the facet's \fBlocale\fP, internal and external types.
.PP
The characters in [from,from_end) are converted and written to [to,to_end). from_next and to_next are \fBset\fP to point to the character following the last successfully converted character, respectively. If the result needed no conversion, from_next and to_next are not affected.
.PP
The \fIstate\fP argument should be initialized if the input is at the beginning and carried from a previous call if continuing conversion. There are no guarantees about how \fIstate\fP is used.
.PP
The result returned is a member of codecvt_base::result. If all the input is converted, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the input ends early or there is insufficient space in the output, returns codecvt_base::partial. Otherwise the conversion failed and codecvt_base::error is returned.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP Persistent conversion state data. 
.br
\fIfrom\fP Start of input. 
.br
\fIfrom_end\fP End of input. 
.br
\fIfrom_next\fP Returns start of unconverted data. 
.br
\fIto\fP Start of output buffer. 
.br
\fIto_end\fP End of output buffer. 
.br
\fIto_next\fP Returns start of unused output area. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result. 
.RE
.PP

.PP
Definition at line 115 of file codecvt.h.
.SS "template<typename _InternT, typename _ExternT, typename _StateT> result \fBstd::__codecvt_abstract_base\fP< _InternT, _ExternT, _StateT >::unshift (state_type & __state, extern_type * __to, extern_type * __to_end, extern_type *& __to_next) const\fC [inline]\fP"
.PP
Reset conversion state. 
.PP
Writes characters to output that would restore \fIstate\fP to initial conditions. The idea is that if a partial conversion occurs, then the converting the characters written by this function would leave the state in initial conditions, rather than partial conversion state. It does this by calling codecvt::do_unshift().
.PP
For example, if 4 external characters always converted to 1 internal character, and input to \fBin()\fP had 6 external characters with state saved, this function would write two characters to the output and \fBset\fP the state to initialized conditions.
.PP
The source and destination character sets are determined by the facet's \fBlocale\fP, internal and external types.
.PP
The result returned is a member of codecvt_base::result. If the state could be reset and data written, returns codecvt_base::ok. If no conversion is necessary, returns codecvt_base::noconv. If the output has insufficient space, returns codecvt_base::partial. Otherwise the reset failed and codecvt_base::error is returned.
.PP
\fBParameters:\fP
.RS 4
\fIstate\fP Persistent conversion state data. 
.br
\fIto\fP Start of output buffer. 
.br
\fIto_end\fP End of output buffer. 
.br
\fIto_next\fP Returns start of unused output area. 
.RE
.PP
\fBReturns:\fP
.RS 4
codecvt_base::result. 
.RE
.PP

.PP
Definition at line 154 of file codecvt.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
