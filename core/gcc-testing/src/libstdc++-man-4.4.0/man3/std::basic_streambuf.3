.TH "std::basic_streambuf" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::basic_streambuf \- The actual work of input and output (interface).  

.PP
.SH SYNOPSIS
.br
.PP
.SS "Public Types"

.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "typedef \fBbasic_streambuf\fP< \fBchar_type\fP, \fBtraits_type\fP > \fB__streambuf_type\fP"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef traits_type::int_type \fBint_type\fP"
.br
.ti -1c
.RI "typedef traits_type::off_type \fBoff_type\fP"
.br
.ti -1c
.RI "typedef traits_type::pos_type \fBpos_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.in -1c
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstreamsize\fP \fBin_avail\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsbumpc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsgetc\fP ()"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsnextc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputbackc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "void \fBstossc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsungetc\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_streambuf\fP ()"
.br
.ti -1c
.RI "void \fBgbump\fP (int __n)"
.br
.ti -1c
.RI "virtual void \fBimbue\fP (const \fBlocale\fP &)"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP=traits_type::eof())"
.br
.ti -1c
.RI "void \fBpbump\fP (int __n)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP, \fBios_base::openmode\fP=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBbasic_streambuf\fP< \fBchar_type\fP, _Traits > * \fBsetbuf\fP (\fBchar_type\fP *, \fBstreamsize\fP)"
.br
.ti -1c
.RI "void \fBsetg\fP (\fBchar_type\fP *__gbeg, \fBchar_type\fP *__gnext, \fBchar_type\fP *__gend)"
.br
.ti -1c
.RI "void \fBsetp\fP (\fBchar_type\fP *__pbeg, \fBchar_type\fP *__pend)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBshowmanyc\fP ()"
.br
.ti -1c
.RI "virtual int \fBsync\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBuflow\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBunderflow\fP ()"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBeback\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBegptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBgptr\fP () const "
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBepptr\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpbase\fP () const "
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpptr\fP () const "
.br
.in -1c
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "template<bool _IsMove, typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type \fB__copy_move_a2\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, _CharT2 *)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fB__streambuf_type\fP *, \fB__streambuf_type\fP *, bool &)"
.br
.ti -1c
.RI "class \fBbasic_ios< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_istream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_ostream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 > __gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, \fBistreambuf_iterator\fP< _CharT2 > >::__type \fBfind\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, const _CharT2 &)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBgetline\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &, _CharT2)"
.br
.ti -1c
.RI "class \fBistreambuf_iterator< char_type, traits_type >\fP"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 , typename _Alloc > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &)"
.br
.ti -1c
.RI "template<typename _CharT2 , typename _Traits2 > \fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, _CharT2 *)"
.br
.ti -1c
.RI "class \fBostreambuf_iterator< char_type, traits_type >\fP"
.br
.in -1c
.in +1c
.ti -1c
.RI "\fBlocale\fP \fB_M_buf_locale\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_end\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_end\fP"
.br
.ti -1c
.RI "\fBlocale\fP \fBgetloc\fP () const "
.br
.ti -1c
.RI "\fBlocale\fP \fBpubimbue\fP (const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekoff\fP (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekpos\fP (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fB__streambuf_type\fP * \fBpubsetbuf\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "int \fBpubsync\fP ()"
.br
.ti -1c
.RI "virtual \fB~basic_streambuf\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits> class std::basic_streambuf< _CharT, _Traits >"
The actual work of input and output (interface). 

This is a base class. Derived stream buffers each control a \fBpair\fP of character sequences: one for input, and one for output.
.PP
Section [27.5.1] of the standard describes the requirements and behavior of stream buffer classes. That section (three paragraphs) is reproduced here, for simplicity and accuracy.
.PP
.IP "1." 4
Stream buffers can impose various constraints on the sequences they control. Some constraints are:
.IP "  \(bu" 4
The controlled input sequence can be not readable.
.IP "  \(bu" 4
The controlled output sequence can be not writable.
.IP "  \(bu" 4
The controlled sequences can be associated with the contents of other representations for character sequences, such as external files.
.IP "  \(bu" 4
The controlled sequences can support operations \fIdirectly\fP to or from associated sequences.
.IP "  \(bu" 4
The controlled sequences can impose limitations on how the program can read characters from a sequence, write characters to a sequence, put characters back into an input sequence, or alter the stream position.
.PP

.IP "2." 4
Each sequence is characterized by three pointers which, if non-null, all point into the same \fCcharT\fP \fBarray\fP object. The \fBarray\fP object represents, at any moment, a (sub)sequence of characters from the sequence. Operations performed on a sequence alter the values stored in these pointers, perform reads and writes directly to or from associated sequences, and alter 'the stream position' and conversion state as needed to maintain this subsequence relationship. The three pointers are:
.IP "  \(bu" 4
the \fIbeginning pointer\fP, or lowest element address in the \fBarray\fP (called \fIxbeg\fP here);
.IP "  \(bu" 4
the \fInext pointer\fP, or next element address that is a current candidate for reading or writing (called \fIxnext\fP here);
.IP "  \(bu" 4
the \fIend pointer\fP, or first element address beyond the end of the \fBarray\fP (called \fIxend\fP here).
.PP

.IP "3." 4
The following semantic constraints shall always apply for any \fBset\fP of three pointers for a sequence, using the pointer names given immediately above:
.IP "  \(bu" 4
If \fIxnext\fP is not a null pointer, then \fIxbeg\fP and \fIxend\fP shall also be non-null pointers into the same \fCcharT\fP \fBarray\fP, as described above; otherwise, \fIxbeg\fP and \fIxend\fP shall also be null.
.IP "  \(bu" 4
If \fIxnext\fP is not a null pointer and \fIxnext\fP < \fIxend\fP for an output sequence, then a \fIwrite position\fP is available. In this case, \fI*xnext\fP shall be assignable as the next element to write (to put, or to store a character value, into the sequence).
.IP "  \(bu" 4
If \fIxnext\fP is not a null pointer and \fIxbeg\fP < \fIxnext\fP for an input sequence, then a \fIputback position\fP is available. In this case, \fIxnext\fP[-1] shall have a defined value and is the next (preceding) element to store a character that is put back into the input sequence.
.IP "  \(bu" 4
If \fIxnext\fP is not a null pointer and \fIxnext<\fP \fIxend\fP for an input sequence, then a \fIread position\fP is available. In this case, \fI*xnext\fP shall have a defined value and is the next element to read (to get, or to obtain a character value, from the sequence). 
.PP

.PP

.PP
Definition at line 114 of file streambuf.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> typedef \fBbasic_streambuf\fP<\fBchar_type\fP, \fBtraits_type\fP> \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB__streambuf_type\fP"
.PP
This is a non-standard type. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 132 of file streambuf.
.SS "template<typename _CharT, typename _Traits> typedef _CharT \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBchar_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 123 of file streambuf.
.SS "template<typename _CharT, typename _Traits> typedef traits_type::int_type \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBint_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 125 of file streambuf.
.SS "template<typename _CharT, typename _Traits> typedef traits_type::off_type \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBoff_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 127 of file streambuf.
.SS "template<typename _CharT, typename _Traits> typedef traits_type::pos_type \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBpos_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::enc_filebuf< _CharT >\fP, \fB__gnu_cxx::stdio_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 126 of file streambuf.
.SS "template<typename _CharT, typename _Traits> typedef _Traits \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBtraits_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::enc_filebuf< _CharT >\fP, \fB__gnu_cxx::stdio_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 124 of file streambuf.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> virtual \fBstd::basic_streambuf\fP< _CharT, _Traits >::~\fBbasic_streambuf\fP ()\fC [inline, virtual]\fP"
.PP
Destructor deallocates no buffer space. 
.PP
Definition at line 192 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fBbasic_streambuf\fP ()\fC [inline, protected]\fP"
.PP
Base constructor. 
.PP
Only called from derived constructors, and sets up all the buffer data to zero, including the pointers described in the \fBbasic_streambuf\fP class description. Note that, as a result,
.IP "\(bu" 2
the class starts with no read nor write positions available,
.IP "\(bu" 2
this is not an error 
.PP

.PP
Definition at line 439 of file streambuf.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::eback () const\fC [inline, protected]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 458 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::egptr () const\fC [inline, protected]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 464 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::epptr () const\fC [inline, protected]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 511 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::gbump (int __n)\fC [inline, protected]\fP"
.PP
Moving the read position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the read position without returning any data. 
.PP
Definition at line 474 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::getloc () const\fC [inline]\fP"
.PP
Locale access. 
.PP
\fBReturns:\fP
.RS 4
The current \fBlocale\fP in effect.
.RE
.PP
If pubimbue(loc) has been called, then the most recent \fCloc\fP is returned. Otherwise the global \fBlocale\fP in effect at the time of construction is returned. 
.PP
Definition at line 221 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::gptr () const\fC [inline, protected]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBeback()\fP returns the beginning pointer for the input sequence
.IP "\(bu" 2
\fBgptr()\fP returns the next pointer for the input sequence
.IP "\(bu" 2
\fBegptr()\fP returns the end pointer for the input sequence 
.PP

.PP
Definition at line 461 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual void \fBstd::basic_streambuf\fP< _CharT, _Traits >::imbue (const \fBlocale\fP &)\fC [inline, protected, virtual]\fP"
.PP
Changes translations. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP A new \fBlocale\fP.
.RE
.PP
Translations done during I/O which depend on the current \fBlocale\fP are changed by this call. The standard adds, 'Between invocations of this function a class derived from streambuf can safely cache results of calls to \fBlocale\fP functions and to members of facets so obtained.'
.PP
\fBNote:\fP
.RS 4
Base class version does nothing. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 552 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::in_avail ()\fC [inline]\fP"
.PP
Looking ahead into the stream. 
.PP
\fBReturns:\fP
.RS 4
The number of characters available.
.RE
.PP
If a read position is available, returns the number of characters available for reading before the buffer must be refilled. Otherwise returns the derived \fC\fBshowmanyc()\fP\fP. 
.PP
Definition at line 261 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::overflow (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual]\fP"
.PP
Consumes data from the buffer; writes to the controlled sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP An additional character to consume. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() to indicate failure, something else (usually \fIc\fP, or not_eof())
.RE
.PP
Informally, this function is called when the output buffer is full (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'consumed', with 'some effect' on the controlled sequence. (Typically, the buffer is written out to the sequence verbatim.) In either case, the character \fIc\fP is also written out, if \fIc\fP is not \fCeof()\fP.
.PP
For a formal definition of this function, see a good text such as Langer & Kreft, or [27.5.2.4.5]/3-7.
.PP
A functioning output streambuf can be created by overriding only this function (no buffer area will be used).
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 743 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbackfail (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual]\fP"
.PP
Tries to back up the input sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to be inserted back into the sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() on failure, 'some other value' on success 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The constraints of \fC\fBgptr()\fP\fP, \fC\fBeback()\fP\fP, and \fC\fBpptr()\fP\fP are the same as for \fC\fBunderflow()\fP\fP.
.RE
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 700 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbase () const\fC [inline, protected]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 505 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::pbump (int __n)\fC [inline, protected]\fP"
.PP
Moving the write position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the write position without returning any data. 
.PP
Definition at line 521 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pptr () const\fC [inline, protected]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
\fBpbase()\fP returns the beginning pointer for the output sequence
.IP "\(bu" 2
\fBpptr()\fP returns the next pointer for the output sequence
.IP "\(bu" 2
\fBepptr()\fP returns the end pointer for the output sequence 
.PP

.PP
Definition at line 508 of file streambuf.
.PP
Referenced by std::basic_streambuf< _CharT, _Traits >::xsputn().
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubimbue (const \fBlocale\fP & __loc)\fC [inline]\fP"
.PP
Entry point for \fBimbue()\fP. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP The new \fBlocale\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous \fBlocale\fP.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 204 of file streambuf.
.PP
Referenced by std::basic_ios< _CharT, _Traits >::imbue().
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekoff (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 238 of file streambuf.
.PP
Referenced by std::basic_ostream< _CharT, _Traits >::seekp(), and std::basic_ostream< _CharT, _Traits >::tellp().
.SS "template<typename _CharT, typename _Traits> \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubseekpos (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 243 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::seekg().
.SS "template<typename _CharT, typename _Traits> \fB__streambuf_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsetbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline]\fP"
.PP
Entry points for derived buffer functions. 
.PP
The public versions of \fCpubfoo\fP dispatch to the protected derived \fCfoo\fP member functions, passing the arguments (if any) and returning the result unchanged. 
.PP
Definition at line 234 of file streambuf.
.SS "template<typename _CharT, typename _Traits> int \fBstd::basic_streambuf\fP< _CharT, _Traits >::pubsync ()\fC [inline]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 248 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::sync().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sbumpc ()\fC [inline]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character and increments the read pointer, otherwise calls and returns \fC\fBuflow()\fP\fP. 
.PP
Definition at line 293 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::getline(), std::basic_istream< _CharT, _Traits >::ignore(), std::istreambuf_iterator< _CharT, _Traits >::operator++(), and std::operator>>().
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekoff (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 578 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::seekpos (\fBpos_type\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 590 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBbasic_streambuf\fP<\fBchar_type\fP,_Traits>* \fBstd::basic_streambuf\fP< _CharT, _Traits >::setbuf (\fBchar_type\fP *, \fBstreamsize\fP)\fC [inline, protected, virtual]\fP"
.PP
Manipulates the buffer. 
.PP
Each derived class provides its own appropriate behavior. See the next-to-last paragraph of http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more on this function.
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns \fCthis\fP. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 567 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setg (\fBchar_type\fP * __gbeg, \fBchar_type\fP * __gnext, \fBchar_type\fP * __gend)\fC [inline, protected]\fP"
.PP
Setting the three read area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIgbeg\fP A pointer. 
.br
\fIgnext\fP A pointer. 
.br
\fIgend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIgbeg\fP == \fC\fBeback()\fP\fP, \fIgnext\fP == \fC\fBgptr()\fP\fP, and \fIgend\fP == \fC\fBegptr()\fP\fP 
.RE
.PP

.PP
Definition at line 485 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::setp (\fBchar_type\fP * __pbeg, \fBchar_type\fP * __pend)\fC [inline, protected]\fP"
.PP
Setting the three write area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIpbeg\fP A pointer. 
.br
\fIpend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIpbeg\fP == \fC\fBpbase()\fP\fP, \fIpbeg\fP == \fC\fBpptr()\fP\fP, and \fIpend\fP == \fC\fBepptr()\fP\fP 
.RE
.PP

.PP
Definition at line 531 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetc ()\fC [inline]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character, otherwise calls and returns \fC\fBunderflow()\fP\fP. Does not move the read position after fetching the character. 
.PP
Definition at line 315 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::getline(), std::basic_istream< _CharT, _Traits >::ignore(), std::operator>>(), std::basic_istream< _CharT, _Traits >::basic_istream::sentry::sentry(), and std::ws().
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline]\fP"
.PP
Entry point for xsgetn. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP A count.
.RE
.PP
Returns xsgetn(s,n). The effect is to fill \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, if possible. 
.PP
Definition at line 334 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::read().
.SS "template<typename _CharT, typename _Traits> virtual \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::showmanyc ()\fC [inline, protected, virtual]\fP"
.PP
Investigating the data available. 
.PP
\fBReturns:\fP
.RS 4
An estimate of the number of characters available in the input sequence, or -1.
.RE
.PP
'If it returns a positive value, then successive calls to \fC\fBunderflow()\fP\fP will not return \fCtraits::eof()\fP until at least that number of characters have been supplied. If \fC\fBshowmanyc()\fP\fP returns -1, then calls to \fC\fBunderflow()\fP\fP or \fC\fBuflow()\fP\fP will fail.' [27.5.2.4.3]/1
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.PP
The standard adds that 'the intention is not only that the calls [to underflow or uflow] will not return \fCeof()\fP but that they will return 'immediately'. 
.PP
The standard adds that 'the morphemes of \fCshowmanyc\fP are 'es-how-many-see', not 'show-manic'. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 625 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::snextc ()\fC [inline]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
Calls \fC\fBsbumpc()\fP\fP, and if that function returns \fCtraits::eof()\fP, so does this function. Otherwise, \fC\fBsgetc()\fP\fP. 
.PP
Definition at line 275 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), std::basic_istream< _CharT, _Traits >::getline(), std::getline(), std::basic_istream< _CharT, _Traits >::ignore(), std::operator>>(), and std::basic_istream< _CharT, _Traits >::basic_istream::sentry::sentry().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputbackc (\fBchar_type\fP __c)\fC [inline]\fP"
.PP
Pushing characters back into the input stream. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to push back. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
Similar to \fBsungetc()\fP, but \fIc\fP is pushed onto the stream instead of 'the previous character'. If successful, the next character fetched from the input stream will be \fIc\fP. 
.PP
Definition at line 348 of file streambuf.
.PP
Referenced by std::operator>>(), and std::basic_istream< _CharT, _Traits >::putback().
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputc (\fBchar_type\fP __c)\fC [inline]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP A character to output. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIc\fP, if possible.
.RE
.PP
One of two public output functions.
.PP
If a write position is available for the output sequence (i.e., the buffer is not full), stores \fIc\fP in that position, increments the position, and returns \fCtraits::to_int_type(c)\fP. If a write position is not available, returns \fCoverflow(c)\fP. 
.PP
Definition at line 400 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::get(), and std::ostreambuf_iterator< _CharT, _Traits >::operator=().
.SS "template<typename _CharT, typename _Traits> \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer read area. 
.br
\fIn\fP A count.
.RE
.PP
One of two public output functions.
.PP
Returns xsputn(s,n). The effect is to write \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, if possible. 
.PP
Definition at line 426 of file streambuf.
.SS "template<typename _CharT, typename _Traits> void \fBstd::basic_streambuf\fP< _CharT, _Traits >::stossc ()\fC [inline]\fP"
.PP
Tosses a character. 
.PP
Advances the read pointer, ignoring the character that would have been read.
.PP
See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html 
.PP
Definition at line 758 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::sungetc ()\fC [inline]\fP"
.PP
Moving backwards in the input stream. 
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
If a putback position is available, this function decrements the input pointer and returns that character. Otherwise, calls and returns \fBpbackfail()\fP. The effect is to 'unget' the last character 'gotten'. 
.PP
Definition at line 373 of file streambuf.
.PP
Referenced by std::basic_istream< _CharT, _Traits >::unget().
.SS "template<typename _CharT, typename _Traits> virtual int \fBstd::basic_streambuf\fP< _CharT, _Traits >::sync (void)\fC [inline, protected, virtual]\fP"
.PP
Synchronizes the buffer arrays with the controlled sequences. 
.PP
\fBReturns:\fP
.RS 4
-1 on failure.
.RE
.PP
Each derived class provides its own appropriate behavior, including the definition of 'failure'. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 603 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::uflow ()\fC [inline, protected, virtual]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function does the same thing as \fC\fBunderflow()\fP\fP, and in fact is required to call that function. It also returns the new character, like \fC\fBunderflow()\fP\fP does. However, this function also moves the read position forward by one. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 676 of file streambuf.
.SS "template<typename _CharT, typename _Traits> virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::underflow ()\fC [inline, protected, virtual]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function is called when the input buffer is exhausted (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'refilled'. In either case, the next available character is returned, or \fCtraits::eof()\fP to indicate a null pending sequence.
.PP
For a formal definition of the pending sequence, see a good text such as Langer & Kreft, or [27.5.2.4.3]/7-14.
.PP
A functioning input streambuf can be created by overriding only this function (no buffer area will be used). For an example, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_stringbuf< _CharT, _Traits, _Alloc >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 663 of file streambuf.
.SS "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsgetn (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, protected, virtual]\fP"
.PP
Multiple character extraction. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to assign. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters assigned.
.RE
.PP
Fills \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, as if by \fC\fBsbumpc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fCtraits::eof()\fP would be copied.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 45 of file streambuf.tcc.
.PP
References std::min().
.SS "template<typename _CharT , typename _Traits > \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::xsputn (const \fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, protected, virtual]\fP"
.PP
Multiple character insertion. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to write. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written.
.RE
.PP
Writes \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, as if by \fC\fBsputc()\fP\fP. Stops when either \fIn\fP characters have been copied, or when \fC\fBsputc()\fP\fP would return \fCtraits::eof()\fP.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fBstd::basic_filebuf< char_type, traits_type >\fP, and \fBstd::basic_filebuf< _CharT, encoding_char_traits< _CharT > >\fP.
.PP
Definition at line 79 of file streambuf.tcc.
.PP
References std::basic_streambuf< _CharT, _Traits >::epptr(), std::min(), std::basic_streambuf< _CharT, _Traits >::overflow(), std::basic_streambuf< _CharT, _Traits >::pbump(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SH "Member Data Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits> \fBlocale\fP \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_buf_locale\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 187 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_beg\fP\fC [protected]\fP"
.PP
This is based on _IO_FILE, just reordered to be more consistent, and is intended to be the most minimal abstraction for an internal buffer.
.IP "\(bu" 2
get == input == read
.IP "\(bu" 2
put == output == write 
.PP

.PP
Definition at line 179 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_cur\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 180 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_in_end\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 181 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_beg\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 182 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_cur\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 183 of file streambuf.
.SS "template<typename _CharT, typename _Traits> \fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT, _Traits >::\fB_M_out_end\fP\fC [protected]\fP"
.PP
Current \fBlocale\fP setting. 
.PP
Definition at line 184 of file streambuf.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
