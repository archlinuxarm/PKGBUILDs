.TH "std::basic_stringbuf" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::basic_stringbuf \- The actual work of input and output (for std::string).
.PP
This class associates either or both of its input and output sequences with a sequence of characters, which can be initialized from, or made available as, a \fC\fBstd::basic_string\fP\fP. (Paraphrased from [27.7.1]/1.).  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBbasic_streambuf< _CharT, _Traits >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef __string_type::size_type \fB__size_type\fP"
.br
.ti -1c
.RI "typedef \fBbasic_streambuf\fP< \fBchar_type\fP, \fBtraits_type\fP > \fB__streambuf_type\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< \fBchar_type\fP, _Traits, _Alloc > \fB__string_type\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef traits_type::int_type \fBint_type\fP"
.br
.ti -1c
.RI "typedef traits_type::off_type \fBoff_type\fP"
.br
.ti -1c
.RI "typedef traits_type::pos_type \fBpos_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBbasic_stringbuf\fP (const \fB__string_type\fP &__str, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBbasic_stringbuf\fP (\fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBin_avail\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsbumpc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsgetc\fP ()"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsnextc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputbackc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fBsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "void \fBstossc\fP ()"
.br
.ti -1c
.RI "void \fBstr\fP (const \fB__string_type\fP &__s)"
.br
.ti -1c
.RI "\fB__string_type\fP \fBstr\fP () const "
.br
.ti -1c
.RI "\fBint_type\fP \fBsungetc\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_stringbuf_init\fP (\fBios_base::openmode\fP __mode)"
.br
.ti -1c
.RI "void \fB_M_sync\fP (\fBchar_type\fP *__base, __size_type __i, __size_type __o)"
.br
.ti -1c
.RI "void \fB_M_update_egptr\fP ()"
.br
.ti -1c
.RI "void \fBgbump\fP (int __n)"
.br
.ti -1c
.RI "virtual void \fBimbue\fP (const \fBlocale\fP &)"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP __c=traits_type::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP __c=traits_type::eof())"
.br
.ti -1c
.RI "void \fBpbump\fP (int __n)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "virtual \fB__streambuf_type\fP * \fBsetbuf\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "void \fBsetg\fP (\fBchar_type\fP *__gbeg, \fBchar_type\fP *__gnext, \fBchar_type\fP *__gend)"
.br
.ti -1c
.RI "void \fBsetp\fP (\fBchar_type\fP *__pbeg, \fBchar_type\fP *__pend)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBshowmanyc\fP ()"
.br
.ti -1c
.RI "virtual int \fBsync\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBuflow\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBunderflow\fP ()"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsgetn\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "virtual \fBstreamsize\fP \fBxsputn\fP (const \fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBeback\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBegptr\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBgptr\fP () const"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBepptr\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpbase\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpptr\fP () const"
.br
.in -1c
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBios_base::openmode\fP \fB_M_mode\fP"
.br
.ti -1c
.RI "\fB__string_type\fP \fB_M_string\fP"
.br
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "__gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type \fB__copy_move_a2\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, _CharT2 *)"
.br
.ti -1c
.RI "\fBstreamsize\fP \fB__copy_streambufs_eof\fP (\fB__streambuf_type\fP *, \fB__streambuf_type\fP *, bool &)"
.br
.ti -1c
.RI "class \fBbasic_ios< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_istream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_ostream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "__gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, \fBistreambuf_iterator\fP< _CharT2 > >::__type \fBfind\fP (\fBistreambuf_iterator\fP< _CharT2 >, \fBistreambuf_iterator\fP< _CharT2 >, const _CharT2 &)"
.br
.ti -1c
.RI "\fBbasic_istream\fP< _CharT2, _Traits2 > & \fBgetline\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &, _CharT2)"
.br
.ti -1c
.RI "class \fBistreambuf_iterator< char_type, traits_type >\fP"
.br
.ti -1c
.RI "\fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, \fBbasic_string\fP< _CharT2, _Traits2, _Alloc > &)"
.br
.ti -1c
.RI "\fBbasic_istream\fP< _CharT2, _Traits2 > & \fBoperator>>\fP (\fBbasic_istream\fP< _CharT2, _Traits2 > &, _CharT2 *)"
.br
.ti -1c
.RI "class \fBostreambuf_iterator< char_type, traits_type >\fP"
.br
.in -1c
.in +1c
.ti -1c
.RI "\fBlocale\fP \fB_M_buf_locale\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_end\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_end\fP"
.br
.ti -1c
.RI "\fBlocale\fP \fBgetloc\fP () const"
.br
.ti -1c
.RI "\fBlocale\fP \fBpubimbue\fP (const \fBlocale\fP &__loc)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekoff\fP (\fBoff_type\fP __off, \fBios_base::seekdir\fP __way, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekpos\fP (\fBpos_type\fP __sp, \fBios_base::openmode\fP __mode=\fBios_base::in\fP|\fBios_base::out\fP)"
.br
.ti -1c
.RI "\fB__streambuf_type\fP * \fBpubsetbuf\fP (\fBchar_type\fP *__s, \fBstreamsize\fP __n)"
.br
.ti -1c
.RI "int \fBpubsync\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits, typename _Alloc> class std::basic_stringbuf< _CharT, _Traits, _Alloc >"
The actual work of input and output (for std::string).
.PP
This class associates either or both of its input and output sequences with a sequence of characters, which can be initialized from, or made available as, a \fC\fBstd::basic_string\fP\fP. (Paraphrased from [27.7.1]/1.). 

For this class, open modes (of type \fC\fBios_base::openmode\fP\fP) have \fCin\fP \fBset\fP if the input sequence can be read, and \fCout\fP \fBset\fP if the output sequence can be written. 
.PP
Definition at line 58 of file sstream.
.SH "Member Typedef Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef \fBbasic_streambuf\fP<\fBchar_type\fP, \fBtraits_type\fP> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fB__streambuf_type\fP"
.PP
This is a non-standard type. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 71 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef _CharT \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBchar_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 62 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::int_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 67 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::off_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBoff_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 69 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef traits_type::pos_type \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBpos_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 68 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> typedef _Traits \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBtraits_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 63 of file sstream.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBbasic_stringbuf\fP (\fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, explicit]\fP"
.PP
Starts with an empty string buffer. 
.PP
\fBParameters:\fP
.RS 4
\fImode\fP Whether the buffer can read, or write, or both.
.RE
.PP
The default constructor initializes the parent class using its own default ctor. 
.PP
Definition at line 92 of file sstream.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBbasic_stringbuf\fP (const \fB__string_type\fP & __str, \fBios_base::openmode\fP __mode = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, explicit]\fP"
.PP
Starts with an existing string buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP A string to copy as a starting buffer. 
.br
\fImode\fP Whether the buffer can read, or write, or both.
.RE
.PP
This constructor initializes the parent class using its own default ctor. 
.PP
Definition at line 105 of file sstream.
.SH "Member Function Documentation"
.PP 
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::eback () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 458 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::egptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 464 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::epptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 511 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow().
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::gbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the read position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the read position without returning any data. 
.PP
Definition at line 474 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "\fBlocale\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::getloc () const\fC [inline, inherited]\fP"
.PP
Locale access. 
.PP
\fBReturns:\fP
.RS 4
The current locale in effect.
.RE
.PP
If pubimbue(loc) has been called, then the most recent \fCloc\fP is returned. Otherwise the global locale in effect at the time of construction is returned. 
.PP
Definition at line 221 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::gptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 461 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "virtual void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::imbue (const \fBlocale\fP &)\fC [inline, protected, virtual, inherited]\fP"
.PP
Changes translations. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP A new locale.
.RE
.PP
Translations done during I/O which depend on the current locale are changed by this call. The standard adds, 'Between invocations of this function a class derived from streambuf can safely cache results of calls to locale functions and to members of facets so obtained.'
.PP
\fBNote:\fP
.RS 4
Base class version does nothing. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, and \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 552 of file streambuf.
.SS "\fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::in_avail ()\fC [inline, inherited]\fP"
.PP
Looking ahead into the stream. 
.PP
\fBReturns:\fP
.RS 4
The number of characters available.
.RE
.PP
If a read position is available, returns the number of characters available for reading before the buffer must be refilled. Otherwise returns the derived \fCshowmanyc()\fP. 
.PP
Definition at line 261 of file streambuf.
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::overflow (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual]\fP"
.PP
Consumes data from the buffer; writes to the controlled sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP An additional character to consume. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() to indicate failure, something else (usually \fIc\fP, or not_eof())
.RE
.PP
Informally, this function is called when the output buffer is full (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'consumed', with 'some effect' on the controlled sequence. (Typically, the buffer is written out to the sequence verbatim.) In either case, the character \fIc\fP is also written out, if \fIc\fP is not \fCeof()\fP.
.PP
For a formal definition of this function, see a good text such as Langer & Kreft, or [27.5.2.4.5]/3-7.
.PP
A functioning output streambuf can be created by overriding only this function (no buffer area will be used).
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 80 of file sstream.tcc.
.PP
References std::basic_stringbuf< _CharT, _Traits, _Alloc >::_M_mode, std::basic_string< _CharT, _Traits, _Alloc >::assign(), std::basic_string< _CharT, _Traits, _Alloc >::capacity(), std::basic_string< _CharT, _Traits, _Alloc >::data(), std::basic_streambuf< _CharT, _Traits >::eback(), std::basic_streambuf< _CharT, _Traits >::epptr(), std::basic_streambuf< _CharT, _Traits >::gptr(), std::max(), std::basic_string< _CharT, _Traits, _Alloc >::max_size(), std::min(), std::ios_base::out, std::basic_streambuf< _CharT, _Traits >::pbase(), std::basic_streambuf< _CharT, _Traits >::pbump(), std::basic_streambuf< _CharT, _Traits >::pptr(), std::basic_string< _CharT, _Traits, _Alloc >::push_back(), std::basic_string< _CharT, _Traits, _Alloc >::reserve(), and std::basic_string< _CharT, _Traits, _Alloc >::swap().
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::pbackfail (\fBint_type\fP = \fCtraits_type::eof()\fP)\fC [inline, protected, virtual]\fP"
.PP
Tries to back up the input sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to be inserted back into the sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() on failure, 'some other value' on success 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The constraints of \fC\fBgptr()\fP\fP, \fC\fBeback()\fP\fP, and \fC\fBpptr()\fP\fP are the same as for \fC\fBunderflow()\fP\fP.
.RE
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 46 of file sstream.tcc.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pbase () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 505 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the write position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the write position without returning any data. 
.PP
Definition at line 521 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 508 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "\fBlocale\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubimbue (const \fBlocale\fP & __loc)\fC [inline, inherited]\fP"
.PP
Entry point for imbue(). 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 204 of file streambuf.
.SS "\fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubseekoff (off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = \fCios_base::in | ios_base::out\fP)\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 238 of file streambuf.
.SS "\fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubseekpos (pos_type __sp, ios_base::openmode __mode = \fCios_base::in | ios_base::out\fP)\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 243 of file streambuf.
.SS "\fB__streambuf_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubsetbuf (char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry points for derived buffer functions. 
.PP
The public versions of \fCpubfoo\fP dispatch to the protected derived \fCfoo\fP member functions, passing the arguments (if any) and returning the result unchanged. 
.PP
Definition at line 234 of file streambuf.
.SS "int \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubsync ()\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 248 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sbumpc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character and increments the read pointer, otherwise calls and returns \fCuflow()\fP. 
.PP
Definition at line 293 of file streambuf.
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBpos_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::seekoff (\fBoff_type\fP, \fBios_base::seekdir\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 149 of file sstream.tcc.
.PP
References std::basic_stringbuf< _CharT, _Traits, _Alloc >::_M_mode, std::ios_base::cur, std::basic_streambuf< _CharT, _Traits >::eback(), std::basic_streambuf< _CharT, _Traits >::egptr(), std::ios_base::end, std::basic_streambuf< _CharT, _Traits >::gbump(), std::basic_streambuf< _CharT, _Traits >::gptr(), std::ios_base::in, std::ios_base::out, std::basic_streambuf< _CharT, _Traits >::pbase(), std::basic_streambuf< _CharT, _Traits >::pbump(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBpos_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::seekpos (\fBpos_type\fP, \fBios_base::openmode\fP = \fC\fBios_base::in\fP | \fBios_base::out\fP\fP)\fC [inline, protected, virtual]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 196 of file sstream.tcc.
.PP
References std::basic_stringbuf< _CharT, _Traits, _Alloc >::_M_mode, std::basic_streambuf< _CharT, _Traits >::eback(), std::basic_streambuf< _CharT, _Traits >::egptr(), std::basic_streambuf< _CharT, _Traits >::gbump(), std::basic_streambuf< _CharT, _Traits >::gptr(), std::ios_base::in, std::ios_base::out, std::basic_streambuf< _CharT, _Traits >::pbase(), std::basic_streambuf< _CharT, _Traits >::pbump(), and std::basic_streambuf< _CharT, _Traits >::pptr().
.SS "template<typename _CharT, typename _Traits, typename _Alloc> virtual \fB__streambuf_type\fP* \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::setbuf (\fBchar_type\fP * __s, \fBstreamsize\fP __n)\fC [inline, protected, virtual]\fP"
.PP
Manipulates the buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to a buffer area. 
.br
\fIn\fP Size of \fIs\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP 
.RE
.PP
If no buffer has already been created, and both \fIs\fP and \fIn\fP are non-zero, then \fCs\fP is used as a buffer; see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 196 of file sstream.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::clear().
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::setg (char_type * __gbeg, char_type * __gnext, char_type * __gend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three read area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIgbeg\fP A pointer. 
.br
\fIgnext\fP A pointer. 
.br
\fIgend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIgbeg\fP == \fCeback()\fP, \fIgnext\fP == \fCgptr()\fP, and \fIgend\fP == \fCegptr()\fP 
.RE
.PP

.PP
Definition at line 485 of file streambuf.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::setp (char_type * __pbeg, char_type * __pend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three write area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIpbeg\fP A pointer. 
.br
\fIpend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIpbeg\fP == \fCpbase()\fP, \fIpbeg\fP == \fCpptr()\fP, and \fIpend\fP == \fCepptr()\fP 
.RE
.PP

.PP
Definition at line 531 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sgetc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character, otherwise calls and returns \fCunderflow()\fP. Does not move the read position after fetching the character. 
.PP
Definition at line 315 of file streambuf.
.SS "\fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sgetn (char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for xsgetn. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP A count.
.RE
.PP
Returns xsgetn(s,n). The effect is to fill \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, if possible. 
.PP
Definition at line 334 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> virtual \fBstreamsize\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::showmanyc ()\fC [inline, protected, virtual]\fP"
.PP
Investigating the data available. 
.PP
\fBReturns:\fP
.RS 4
An estimate of the number of characters available in the input sequence, or -1.
.RE
.PP
'If it returns a positive value, then successive calls to \fC\fBunderflow()\fP\fP will not return \fCtraits::eof()\fP until at least that number of characters have been supplied. If \fC\fBshowmanyc()\fP\fP returns -1, then calls to \fC\fBunderflow()\fP\fP or \fC\fBuflow()\fP\fP will fail.' [27.5.2.4.3]/1
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.PP
The standard adds that 'the intention is not only that the calls [to underflow or uflow] will not return \fCeof()\fP but that they will return 'immediately'. 
.PP
The standard adds that 'the morphemes of \fCshowmanyc\fP are 'es-how-many-see', not 'show-manic'. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 164 of file sstream.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::snextc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
Calls \fCsbumpc()\fP, and if that function returns \fCtraits::eof()\fP, so does this function. Otherwise, \fCsgetc()\fP. 
.PP
Definition at line 275 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputbackc (char_type __c)\fC [inline, inherited]\fP"
.PP
Pushing characters back into the input stream. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to push back. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
Similar to sungetc(), but \fIc\fP is pushed onto the stream instead of 'the previous character'. If successful, the next character fetched from the input stream will be \fIc\fP. 
.PP
Definition at line 348 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputc (char_type __c)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP A character to output. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIc\fP, if possible.
.RE
.PP
One of two public output functions.
.PP
If a write position is available for the output sequence (i.e., the buffer is not full), stores \fIc\fP in that position, increments the position, and returns \fCtraits::to_int_type(c)\fP. If a write position is not available, returns \fCoverflow(c)\fP. 
.PP
Definition at line 400 of file streambuf.
.SS "\fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputn (const char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer read area. 
.br
\fIn\fP A count.
.RE
.PP
One of two public output functions.
.PP
Returns xsputn(s,n). The effect is to write \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, if possible. 
.PP
Definition at line 426 of file streambuf.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::stossc ()\fC [inline, inherited]\fP"
.PP
Tosses a character. 
.PP
Advances the read pointer, ignoring the character that would have been read.
.PP
See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html 
.PP
Definition at line 758 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> void \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::str (const \fB__string_type\fP & __s)\fC [inline]\fP"
.PP
Setting a new buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The string to use as a new sequence.
.RE
.PP
Deallocates any previous stored sequence, then copies \fIs\fP to use as a new one. 
.PP
Definition at line 144 of file sstream.
.PP
References std::basic_string< _CharT, _Traits, _Alloc >::assign(), std::basic_string< _CharT, _Traits, _Alloc >::data(), and std::basic_string< _CharT, _Traits, _Alloc >::size().
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fB__string_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::str () const\fC [inline]\fP"
.PP
Copying out the string buffer. 
.PP
\fBReturns:\fP
.RS 4
A copy of one of the underlying sequences.
.RE
.PP
'If the buffer is only created in input mode, the underlying character sequence is equal to the input sequence; otherwise, it is equal to the output sequence.' [27.7.1.2]/1 
.PP
Definition at line 120 of file sstream.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sungetc ()\fC [inline, inherited]\fP"
.PP
Moving backwards in the input stream. 
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
If a putback position is available, this function decrements the input pointer and returns that character. Otherwise, calls and returns pbackfail(). The effect is to 'unget' the last character 'gotten'. 
.PP
Definition at line 373 of file streambuf.
.SS "virtual int \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sync (void)\fC [inline, protected, virtual, inherited]\fP"
.PP
Synchronizes the buffer arrays with the controlled sequences. 
.PP
\fBReturns:\fP
.RS 4
-1 on failure.
.RE
.PP
Each derived class provides its own appropriate behavior, including the definition of 'failure'. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.RE
.PP

.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, and \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 603 of file streambuf.
.SS "virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::uflow ()\fC [inline, protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function does the same thing as \fCunderflow()\fP, and in fact is required to call that function. It also returns the new character, like \fCunderflow()\fP does. However, this function also moves the read position forward by one. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 676 of file streambuf.
.SS "template<class _CharT , class _Traits , class _Alloc > \fBbasic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fBint_type\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::underflow ()\fC [inline, protected, virtual]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function is called when the input buffer is exhausted (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'refilled'. In either case, the next available character is returned, or \fCtraits::eof()\fP to indicate a null pending sequence.
.PP
For a formal definition of the pending sequence, see a good text such as Langer & Kreft, or [27.5.2.4.3]/7-14.
.PP
A functioning input streambuf can be created by overriding only this function (no buffer area will be used). For an example, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 131 of file sstream.tcc.
.PP
References std::basic_stringbuf< _CharT, _Traits, _Alloc >::_M_mode, std::basic_streambuf< _CharT, _Traits >::egptr(), std::basic_streambuf< _CharT, _Traits >::gptr(), and std::ios_base::in.
.SS "virtual \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::xsgetn (char_type * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character extraction. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to assign. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters assigned.
.RE
.PP
Fills \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, as if by \fCsbumpc()\fP. Stops when either \fIn\fP characters have been copied, or when \fCtraits::eof()\fP would be copied.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, and \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.SS "virtual \fBstreamsize\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::xsputn (const char_type * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character insertion. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to write. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written.
.RE
.PP
Writes \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, as if by \fCsputc()\fP. Stops when either \fIn\fP characters have been copied, or when \fCsputc()\fP would return \fCtraits::eof()\fP.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented in \fBstd::basic_filebuf< _CharT, _Traits >\fP, \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP, and \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.SH "Member Data Documentation"
.PP 
.SS "\fBlocale\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_buf_locale\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 187 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::basic_filebuf().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_beg\fP\fC [protected, inherited]\fP"
.PP
This is based on _IO_FILE, just reordered to be more consistent, and is intended to be the most minimal abstraction for an internal buffer.
.IP "\(bu" 2
get == input == read
.IP "\(bu" 2
put == output == write 
.PP

.PP
Definition at line 179 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_cur\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 180 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_end\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 181 of file streambuf.
.SS "template<typename _CharT, typename _Traits, typename _Alloc> \fBios_base::openmode\fP \fBstd::basic_stringbuf\fP< _CharT, _Traits, _Alloc >::\fB_M_mode\fP\fC [protected]\fP"
.PP
Place to stash in || out || in | out settings for current stringbuf. 
.PP
Definition at line 77 of file sstream.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_beg\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 182 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_cur\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 183 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_end\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 184 of file streambuf.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
