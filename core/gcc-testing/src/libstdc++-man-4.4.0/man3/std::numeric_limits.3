.TH "std::numeric_limits" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::numeric_limits \- Properties of fundamental types.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBstd::__numeric_limits_base\fP.
.PP
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static _Tp \fBdenorm_min\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBepsilon\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBinfinity\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBmax\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBmin\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBquiet_NaN\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBround_error\fP ()  throw ()"
.br
.ti -1c
.RI "static _Tp \fBsignaling_NaN\fP ()  throw ()"
.br
.in -1c
.SS "Static Public Attributes"

.in +1c
.ti -1c
.RI "static const int \fBdigits\fP"
.br
.ti -1c
.RI "static const int \fBdigits10\fP"
.br
.ti -1c
.RI "static const \fBfloat_denorm_style\fP \fBhas_denorm\fP"
.br
.ti -1c
.RI "static const bool \fBhas_denorm_loss\fP"
.br
.ti -1c
.RI "static const bool \fBhas_infinity\fP"
.br
.ti -1c
.RI "static const bool \fBhas_quiet_NaN\fP"
.br
.ti -1c
.RI "static const bool \fBhas_signaling_NaN\fP"
.br
.ti -1c
.RI "static const bool \fBis_bounded\fP"
.br
.ti -1c
.RI "static const bool \fBis_exact\fP"
.br
.ti -1c
.RI "static const bool \fBis_iec559\fP"
.br
.ti -1c
.RI "static const bool \fBis_integer\fP"
.br
.ti -1c
.RI "static const bool \fBis_modulo\fP"
.br
.ti -1c
.RI "static const bool \fBis_signed\fP"
.br
.ti -1c
.RI "static const bool \fBis_specialized\fP"
.br
.ti -1c
.RI "static const int \fBmax_exponent\fP"
.br
.ti -1c
.RI "static const int \fBmax_exponent10\fP"
.br
.ti -1c
.RI "static const int \fBmin_exponent\fP"
.br
.ti -1c
.RI "static const int \fBmin_exponent10\fP"
.br
.ti -1c
.RI "static const int \fBradix\fP"
.br
.ti -1c
.RI "static const \fBfloat_round_style\fP \fBround_style\fP"
.br
.ti -1c
.RI "static const bool \fBtinyness_before\fP"
.br
.ti -1c
.RI "static const bool \fBtraps\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Tp> struct std::numeric_limits< _Tp >"
Properties of fundamental types. 

This class allows a program to obtain information about the representation of a fundamental type on a given platform. For non-fundamental types, the functions will return 0 and the data members will all be \fCfalse\fP.
.PP
_GLIBCXX_RESOLVE_LIB_DEFECTS: DRs 201 and 184 (hi Gaby!) are noted, but not incorporated in this documented (yet). 
.PP
Definition at line 278 of file limits.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::denorm_min ()  throw ()\fC [inline, static]\fP"
.PP
The minimum positive denormalized value. For types where \fChas_denorm\fP is false, this is the minimum positive normalized value. 
.PP
Definition at line 300 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::epsilon ()  throw ()\fC [inline, static]\fP"
.PP
The \fImachine\fP \fIepsilon:\fP the difference between 1 and the least value \fBgreater\fP than 1 that is representable. 
.PP
Definition at line 287 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::infinity ()  throw ()\fC [inline, static]\fP"
.PP
The representation of positive infinity, if \fChas_infinity\fP. 
.PP
Definition at line 291 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::max ()  throw ()\fC [inline, static]\fP"
.PP
The maximum finite value. 
.PP
Definition at line 284 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::min ()  throw ()\fC [inline, static]\fP"
.PP
The minimum finite value, or for floating types with denormalization, the minimum positive normalized value. 
.PP
Definition at line 282 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::quiet_NaN ()  throw ()\fC [inline, static]\fP"
.PP
The representation of a quiet 'Not a Number,' if \fChas_quiet_NaN\fP. 
.PP
Definition at line 293 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::round_error ()  throw ()\fC [inline, static]\fP"
.PP
The maximum rounding error measurement (see LIA-1). 
.PP
Definition at line 289 of file limits.
.SS "template<typename _Tp> static _Tp \fBstd::numeric_limits\fP< _Tp >::signaling_NaN ()  throw ()\fC [inline, static]\fP"
.PP
The representation of a signaling 'Not a Number,' if \fChas_signaling_NaN\fP. 
.PP
Definition at line 296 of file limits.
.SH "Member Data Documentation"
.PP 
.SS "const int \fBstd::__numeric_limits_base::digits\fP\fC [static, inherited]\fP"
.PP
The number of \fCradix\fP digits that be represented without change: for integer types, the number of non-sign bits in the mantissa; for floating types, the number of \fCradix\fP digits in the mantissa. 
.PP
Definition at line 197 of file limits.
.SS "const int \fBstd::__numeric_limits_base::digits10\fP\fC [static, inherited]\fP"
.PP
The number of base 10 digits that can be represented without change. 
.PP
Definition at line 199 of file limits.
.SS "const \fBfloat_denorm_style\fP \fBstd::__numeric_limits_base::has_denorm\fP\fC [static, inherited]\fP"
.PP
See \fBstd::float_denorm_style\fP for more information. 
.PP
Definition at line 238 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_denorm_loss\fP\fC [static, inherited]\fP"
.PP
'True if loss of accuracy is detected as a denormalization loss, rather than as an inexact result.' [18.2.1.2]/42 
.PP
Definition at line 241 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_infinity\fP\fC [static, inherited]\fP"
.PP
True if the type has a representation for positive infinity. 
.PP
Definition at line 230 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_quiet_NaN\fP\fC [static, inherited]\fP"
.PP
True if the type has a representation for a quiet (non-signaling) 'Not a Number.' 
.PP
Definition at line 233 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::has_signaling_NaN\fP\fC [static, inherited]\fP"
.PP
True if the type has a representation for a signaling 'Not a Number.' 
.PP
Definition at line 236 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_bounded\fP\fC [static, inherited]\fP"
.PP
'True if the \fBset\fP of values representable by the type is finite. All built-in types are bounded, this member would be false for arbitrary precision types.' [18.2.1.2]/54 
.PP
Definition at line 249 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_exact\fP\fC [static, inherited]\fP"
.PP
True if the type uses an exact representation. 'All integer types are exact, but not all exact types are integer. For example, rational and fixed-exponent representations are exact but not integer.' [18.2.1.2]/15 
.PP
Definition at line 210 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_iec559\fP\fC [static, inherited]\fP"
.PP
True if-and-only-if the type adheres to the IEC 559 standard, also known as IEEE 754. (Only makes sense for floating point types.) 
.PP
Definition at line 245 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_integer\fP\fC [static, inherited]\fP"
.PP
True if the type is integer. Is this supposed to be 'if the type is integral'? 
.PP
Definition at line 205 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_modulo\fP\fC [static, inherited]\fP"
.PP
True if the type is \fImodulo\fP, that is, if it is possible to add two positive numbers and have a result that wraps around to a third number that is \fBless\fP. Typically false for floating types, true for unsigned integers, and true for signed integers. 
.PP
Definition at line 254 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_signed\fP\fC [static, inherited]\fP"
.PP
True if the type is signed. 
.PP
Definition at line 201 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::is_specialized\fP\fC [static, inherited]\fP"
.PP
This will be true for all fundamental types (which have specializations), and false for everything else. 
.PP
Definition at line 192 of file limits.
.SS "const int \fBstd::__numeric_limits_base::max_exponent\fP\fC [static, inherited]\fP"
.PP
The maximum positive integer such that \fCradix\fP raised to the power of (one \fBless\fP than that integer) is a representable finite floating point number. 
.PP
Definition at line 224 of file limits.
.SS "const int \fBstd::__numeric_limits_base::max_exponent10\fP\fC [static, inherited]\fP"
.PP
The maximum positive integer such that 10 raised to that power is in the range of representable finite floating point numbers. 
.PP
Definition at line 227 of file limits.
.SS "const int \fBstd::__numeric_limits_base::min_exponent\fP\fC [static, inherited]\fP"
.PP
The minimum negative integer such that \fCradix\fP raised to the power of (one \fBless\fP than that integer) is a normalized floating point number. 
.PP
Definition at line 217 of file limits.
.SS "const int \fBstd::__numeric_limits_base::min_exponent10\fP\fC [static, inherited]\fP"
.PP
The minimum negative integer such that 10 raised to that power is in the range of normalized floating point numbers. 
.PP
Definition at line 220 of file limits.
.SS "const int \fBstd::__numeric_limits_base::radix\fP\fC [static, inherited]\fP"
.PP
For integer types, specifies the base of the representation. For floating types, specifies the base of the exponent representation. 
.PP
Definition at line 213 of file limits.
.SS "const \fBfloat_round_style\fP \fBstd::__numeric_limits_base::round_style\fP\fC [static, inherited]\fP"
.PP
See \fBstd::float_round_style\fP for more information. This is only meaningful for floating types; integer types will all be round_toward_zero. 
.PP
Definition at line 263 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::tinyness_before\fP\fC [static, inherited]\fP"
.PP
True if tininess is detected before rounding. (see IEC 559) 
.PP
Definition at line 259 of file limits.
.SS "const bool \fBstd::__numeric_limits_base::traps\fP\fC [static, inherited]\fP"
.PP
True if trapping is implemented for this type. 
.PP
Definition at line 257 of file limits.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
