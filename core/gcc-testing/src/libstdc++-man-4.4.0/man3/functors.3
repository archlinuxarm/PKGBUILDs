.TH "Function Objects" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Function Objects \- 
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBstd::binary_function< _Arg1, _Arg2, _Result >\fP"
.br
.ti -1c
.RI "struct \fBstd::unary_function< _Arg, _Result >\fP"
.br
.in -1c
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBBinder Classes\fP"
.br
.ti -1c
.RI "\fBArithmetic Classes\fP"
.br
.ti -1c
.RI "\fBComparison Classes\fP"
.br
.ti -1c
.RI "\fBBoolean Operations Classes\fP"
.br
.ti -1c
.RI "\fBNegators\fP"
.br
.ti -1c
.RI "\fBAdaptors for pointers to functions\fP"
.br
.ti -1c
.RI "\fBAdaptors for pointers to members\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Function objects, or \fIfunctors\fP, are objects with an \fCoperator()\fP defined and accessible. They can be passed as arguments to algorithm templates and used in place of a function pointer. Not only is the resulting expressiveness of the library increased, but the generated code can be more efficient than what you might write by hand. When we refer to 'functors,' then, generally we include function pointers in the description as well.
.PP
Often, functors are only created as temporaries passed to algorithm calls, rather than being created as named variables.
.PP
Two examples taken from the standard itself follow. To perform a by-element addition of two vectors \fCa\fP and \fCb\fP containing \fCdouble\fP, and put the result in \fCa\fP, use 
.PP
.nf
  transform (a.begin(), a.end(), b.begin(), a.begin(), plus<double>());

.fi
.PP
 To \fBnegate\fP every element in \fCa\fP, use 
.PP
.nf
  transform(a.begin(), a.end(), a.begin(), negate<double>());

.fi
.PP
 The addition and negation functions will be inlined directly.
.PP
The standard functors are derived from structs named \fC\fBunary_function\fP\fP and \fC\fBbinary_function\fP\fP. These two classes contain nothing but typedefs, to aid in generic (template) programming. If you write your own functors, you might consider doing the same. 
.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
