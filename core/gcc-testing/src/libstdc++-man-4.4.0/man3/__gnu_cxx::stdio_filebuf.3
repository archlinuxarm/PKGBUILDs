.TH "__gnu_cxx::stdio_filebuf" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::stdio_filebuf \- Provides a layer of compatibility for C/POSIX.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBbasic_filebuf< _CharT, _Traits >\fP.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef codecvt< \fBchar_type\fP, char, __state_type > \fB__codecvt_type\fP"
.br
.ti -1c
.RI "typedef __basic_file< char > \fB__file_type\fP"
.br
.ti -1c
.RI "typedef basic_filebuf< \fBchar_type\fP, \fBtraits_type\fP > \fB__filebuf_type\fP"
.br
.ti -1c
.RI "typedef traits_type::state_type \fB__state_type\fP"
.br
.ti -1c
.RI "typedef basic_streambuf< \fBchar_type\fP, \fBtraits_type\fP > \fB__streambuf_type\fP"
.br
.ti -1c
.RI "typedef _CharT \fBchar_type\fP"
.br
.ti -1c
.RI "typedef traits_type::int_type \fBint_type\fP"
.br
.ti -1c
.RI "typedef traits_type::off_type \fBoff_type\fP"
.br
.ti -1c
.RI "typedef traits_type::pos_type \fBpos_type\fP"
.br
.ti -1c
.RI "typedef std::size_t \fBsize_t\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB__filebuf_type\fP * \fBclose\fP ()"
.br
.ti -1c
.RI "int \fBfd\fP ()"
.br
.ti -1c
.RI "std::__c_file * \fBfile\fP ()"
.br
.ti -1c
.RI "streamsize \fBin_avail\fP ()"
.br
.ti -1c
.RI "bool \fBis_open\fP () const  throw ()"
.br
.ti -1c
.RI "\fB__filebuf_type\fP * \fBopen\fP (const \fBstd::string\fP &__s, ios_base::openmode __mode)"
.br
.ti -1c
.RI "\fB__filebuf_type\fP * \fBopen\fP (const char *__s, ios_base::openmode __mode)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsbumpc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsgetc\fP ()"
.br
.ti -1c
.RI "streamsize \fBsgetn\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsnextc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputbackc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "\fBint_type\fP \fBsputc\fP (\fBchar_type\fP __c)"
.br
.ti -1c
.RI "streamsize \fBsputn\fP (const \fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "\fBstdio_filebuf\fP (std::__c_file *__f, \fBstd::ios_base::openmode\fP __mode, size_t __size=static_cast< size_t >(BUFSIZ))"
.br
.ti -1c
.RI "\fBstdio_filebuf\fP (int __fd, \fBstd::ios_base::openmode\fP __mode, size_t __size=static_cast< size_t >(BUFSIZ))"
.br
.ti -1c
.RI "\fBstdio_filebuf\fP ()"
.br
.ti -1c
.RI "void \fBstossc\fP ()"
.br
.ti -1c
.RI "\fBint_type\fP \fBsungetc\fP ()"
.br
.ti -1c
.RI "virtual \fB~stdio_filebuf\fP ()"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_allocate_internal_buffer\fP ()"
.br
.ti -1c
.RI "bool \fB_M_convert_to_external\fP (\fBchar_type\fP *, streamsize)"
.br
.ti -1c
.RI "void \fB_M_create_pback\fP ()"
.br
.ti -1c
.RI "void \fB_M_destroy_internal_buffer\fP ()  throw ()"
.br
.ti -1c
.RI "void \fB_M_destroy_pback\fP ()  throw ()"
.br
.ti -1c
.RI "\fBpos_type\fP \fB_M_seek\fP (\fBoff_type\fP __off, ios_base::seekdir __way, __state_type __state)"
.br
.ti -1c
.RI "void \fB_M_set_buffer\fP (streamsize __off)"
.br
.ti -1c
.RI "bool \fB_M_terminate_output\fP ()"
.br
.ti -1c
.RI "void \fBgbump\fP (int __n)"
.br
.ti -1c
.RI "virtual void \fBimbue\fP (const locale &__loc)"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBoverflow\fP (\fBint_type\fP __c=_Traits::eof())"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBpbackfail\fP (\fBint_type\fP __c=_Traits::eof())"
.br
.ti -1c
.RI "void \fBpbump\fP (int __n)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekoff\fP (\fBoff_type\fP __off, ios_base::seekdir __way, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fBpos_type\fP \fBseekpos\fP (\fBpos_type\fP __pos, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "virtual \fB__streambuf_type\fP * \fBsetbuf\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "void \fBsetg\fP (\fBchar_type\fP *__gbeg, \fBchar_type\fP *__gnext, \fBchar_type\fP *__gend)"
.br
.ti -1c
.RI "void \fBsetp\fP (\fBchar_type\fP *__pbeg, \fBchar_type\fP *__pend)"
.br
.ti -1c
.RI "virtual streamsize \fBshowmanyc\fP ()"
.br
.ti -1c
.RI "virtual int \fBsync\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBuflow\fP ()"
.br
.ti -1c
.RI "virtual \fBint_type\fP \fBunderflow\fP ()"
.br
.ti -1c
.RI "virtual streamsize \fBxsgetn\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "virtual streamsize \fBxsputn\fP (const \fBchar_type\fP *__s, streamsize __n)"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBeback\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBegptr\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBgptr\fP () const"
.br
.in -1c
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fBepptr\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpbase\fP () const"
.br
.ti -1c
.RI "\fBchar_type\fP * \fBpptr\fP () const"
.br
.in -1c
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBchar_type\fP * \fB_M_buf\fP"
.br
.ti -1c
.RI "bool \fB_M_buf_allocated\fP"
.br
.ti -1c
.RI "size_t \fB_M_buf_size\fP"
.br
.ti -1c
.RI "const \fB__codecvt_type\fP * \fB_M_codecvt\fP"
.br
.ti -1c
.RI "char * \fB_M_ext_buf\fP"
.br
.ti -1c
.RI "streamsize \fB_M_ext_buf_size\fP"
.br
.ti -1c
.RI "char * \fB_M_ext_end\fP"
.br
.ti -1c
.RI "const char * \fB_M_ext_next\fP"
.br
.ti -1c
.RI "__file_type \fB_M_file\fP"
.br
.ti -1c
.RI "__c_lock \fB_M_lock\fP"
.br
.ti -1c
.RI "ios_base::openmode \fB_M_mode\fP"
.br
.ti -1c
.RI "bool \fB_M_reading\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_beg\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_cur\fP"
.br
.ti -1c
.RI "__state_type \fB_M_state_last\fP"
.br
.ti -1c
.RI "bool \fB_M_writing\fP"
.br
.in -1c
.PP
.RI "\fB\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "\fBchar_type\fP \fB_M_pback\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_pback_cur_save\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_pback_end_save\fP"
.br
.ti -1c
.RI "bool \fB_M_pback_init\fP"
.br
.in -1c
.in -1c
.SS "Friends"

.in +1c
.ti -1c
.RI "__gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, _CharT2 * >::__type \fB__copy_move_a2\fP (istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, _CharT2 *)"
.br
.ti -1c
.RI "streamsize \fB__copy_streambufs_eof\fP (\fB__streambuf_type\fP *, \fB__streambuf_type\fP *, bool &)"
.br
.ti -1c
.RI "class \fBbasic_ios< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_istream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "class \fBbasic_ostream< char_type, traits_type >\fP"
.br
.ti -1c
.RI "__gnu_cxx::__enable_if< __is_char< _CharT2 >::__value, istreambuf_iterator< _CharT2 > >::__type \fBfind\fP (istreambuf_iterator< _CharT2 >, istreambuf_iterator< _CharT2 >, const _CharT2 &)"
.br
.ti -1c
.RI "basic_istream< _CharT2, _Traits2 > & \fBgetline\fP (basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &, _CharT2)"
.br
.ti -1c
.RI "class \fBios_base\fP"
.br
.ti -1c
.RI "class \fBistreambuf_iterator< char_type, traits_type >\fP"
.br
.ti -1c
.RI "basic_istream< _CharT2, _Traits2 > & \fBoperator>>\fP (basic_istream< _CharT2, _Traits2 > &, basic_string< _CharT2, _Traits2, _Alloc > &)"
.br
.ti -1c
.RI "basic_istream< _CharT2, _Traits2 > & \fBoperator>>\fP (basic_istream< _CharT2, _Traits2 > &, _CharT2 *)"
.br
.ti -1c
.RI "class \fBostreambuf_iterator< char_type, traits_type >\fP"
.br
.in -1c
.in +1c
.ti -1c
.RI "locale \fBgetloc\fP () const"
.br
.ti -1c
.RI "locale \fBpubimbue\fP (const locale &__loc)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekoff\fP (\fBoff_type\fP __off, ios_base::seekdir __way, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "\fBpos_type\fP \fBpubseekpos\fP (\fBpos_type\fP __sp, ios_base::openmode __mode=ios_base::in|ios_base::out)"
.br
.ti -1c
.RI "\fB__streambuf_type\fP * \fBpubsetbuf\fP (\fBchar_type\fP *__s, streamsize __n)"
.br
.ti -1c
.RI "int \fBpubsync\fP ()"
.br
.ti -1c
.RI "locale \fB_M_buf_locale\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_in_end\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_beg\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_cur\fP"
.br
.ti -1c
.RI "\fBchar_type\fP * \fB_M_out_end\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits = std::char_traits<_CharT>> class __gnu_cxx::stdio_filebuf< _CharT, _Traits >"
Provides a layer of compatibility for C/POSIX. 

This GNU extension provides extensions for working with standard C FILE*'s and POSIX file descriptors. It must be instantiated by the user with the type of \fBcharacter\fP used in the file stream, e.g., stdio_filebuf<char>. 
.PP
Definition at line 47 of file stdio_filebuf.h.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef basic_streambuf<\fBchar_type\fP, \fBtraits_type\fP> \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB__streambuf_type\fP\fC [inherited]\fP"
.PP
This is a non-standard type. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.PP
Definition at line 77 of file fstream.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef _CharT \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBchar_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 51 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::int_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBint_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 53 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::off_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBoff_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 55 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef traits_type::pos_type \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBpos_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 54 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> typedef _Traits \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBtraits_type\fP"
.PP
These are standard types. They permit a standardized way of referring to names of (or names dependant on) the template parameters, which are specific to the implementation. 
.PP
Reimplemented from \fBstd::basic_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 52 of file stdio_filebuf.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP ()\fC [inline]\fP"
.PP
deferred initialization 
.PP
Definition at line 62 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP (int __fd, \fBstd::ios_base::openmode\fP __mode, size_t __size = \fCstatic_cast<size_t>(BUFSIZ)\fP)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIfd\fP An open file descriptor. 
.br
\fImode\fP Same meaning as in a standard filebuf. 
.br
\fIsize\fP Optimal or preferred size of internal buffer, in chars.
.RE
.PP
This constructor associates a file stream buffer with an open POSIX file descriptor. The file descriptor will be automatically closed when the \fBstdio_filebuf\fP is closed/destroyed. 
.PP
Definition at line 124 of file stdio_filebuf.h.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::\fBstdio_filebuf\fP (std::__c_file * __f, \fBstd::ios_base::openmode\fP __mode, size_t __size = \fCstatic_cast<size_t>(BUFSIZ)\fP)\fC [inline]\fP"
.PP
\fBParameters:\fP
.RS 4
\fIf\fP An open \fCFILE*\fP. 
.br
\fImode\fP Same meaning as in a standard filebuf. 
.br
\fIsize\fP Optimal or preferred size of internal buffer, in chars. Defaults to system's \fCBUFSIZ\fP.
.RE
.PP
This constructor associates a file stream buffer with an open C \fCFILE*\fP. The \fCFILE*\fP will not be automatically closed when the \fBstdio_filebuf\fP is closed/destroyed. 
.PP
Definition at line 140 of file stdio_filebuf.h.
.PP
References std::basic_filebuf< _CharT, _Traits >::_M_buf_size, std::basic_filebuf< _CharT, _Traits >::_M_mode, std::basic_filebuf< _CharT, _Traits >::_M_reading, std::basic_filebuf< _CharT, _Traits >::_M_set_buffer(), and std::basic_filebuf< _CharT, _Traits >::is_open().
.SS "template<typename _CharT , typename _Traits > \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::~\fBstdio_filebuf\fP ()\fC [inline, virtual]\fP"
.PP
Closes the external data stream if the file descriptor constructor was used. 
.PP
Definition at line 119 of file stdio_filebuf.h.
.SH "Member Function Documentation"
.PP 
.SS "void \fBstd::basic_filebuf\fP< _CharT , _Traits  >::_M_create_pback ()\fC [inline, protected, inherited]\fP"
.PP
Initializes pback buffers, and moves normal buffers to safety. Assumptions: _M_in_cur has already been moved back 
.PP
Definition at line 172 of file fstream.
.SS "void \fBstd::basic_filebuf\fP< _CharT , _Traits  >::_M_destroy_pback ()  throw ()\fC [inline, protected, inherited]\fP"
.PP
Deactivates pback buffer contents, and restores normal buffer. Assumptions: The pback buffer has only moved forward. 
.PP
Definition at line 189 of file fstream.
.SS "void \fBstd::basic_filebuf\fP< _CharT , _Traits  >::_M_set_buffer (\fBstreamsize\fP __off)\fC [inline, protected, inherited]\fP"
.PP
This function sets the pointers of the internal buffer, both get and put areas. Typically:
.PP
__off == egptr() - eback() upon underflow/uflow ('read' mode); __off == 0 upon overflow ('write' mode); __off == -1 upon open, setbuf, seekoff/pos ('uncommitted' mode).
.PP
NB: epptr() - pbase() == _M_buf_size - 1, since _M_buf_size reflects the actual allocated memory and the last cell is reserved for the overflow char of a full put area. 
.PP
Definition at line 386 of file fstream.
.PP
Referenced by __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().
.SS "\fB__filebuf_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::close ()\fC [inherited]\fP"
.PP
Closes the currently associated file. 
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure
.RE
.PP
If no file is currently open, this function immediately fails.
.PP
If a 'put buffer area' exists, \fCoverflow(eof)\fP is called to flush all the characters. The file is then closed.
.PP
If any operations fail, this function also fails. 
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::eback () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 458 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::egptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 464 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::epptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 511 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow().
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> int \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::fd ()\fC [inline]\fP"
.PP
\fBReturns:\fP
.RS 4
The underlying file descriptor.
.RE
.PP
Once associated with an external data stream, this function can be used to access the underlying POSIX file descriptor. Note that there is no way for the library to track what you do with the descriptor, so be careful. 
.PP
Definition at line 105 of file stdio_filebuf.h.
.SS "template<typename _CharT , typename _Traits  = std::char_traits<_CharT>> std::__c_file* \fB__gnu_cxx::stdio_filebuf\fP< _CharT, _Traits >::file ()\fC [inline]\fP"
.PP
\fBReturns:\fP
.RS 4
The underlying FILE*.
.RE
.PP
This function can be used to access the underlying 'C' file pointer. Note that there is no way for the library to track what you do with the file, so be careful. 
.PP
Definition at line 115 of file stdio_filebuf.h.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::gbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the read position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the read position without returning any data. 
.PP
Definition at line 474 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "locale \fBstd::basic_streambuf\fP< _CharT , _Traits  >::getloc () const\fC [inline, inherited]\fP"
.PP
Locale access. 
.PP
\fBReturns:\fP
.RS 4
The current locale in effect.
.RE
.PP
If pubimbue(loc) has been called, then the most recent \fCloc\fP is returned. Otherwise the global locale in effect at the time of construction is returned. 
.PP
Definition at line 221 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::gptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the get area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
eback() returns the beginning pointer for the input sequence
.IP "\(bu" 2
gptr() returns the next pointer for the input sequence
.IP "\(bu" 2
egptr() returns the end pointer for the input sequence 
.PP

.PP
Definition at line 461 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::imbue(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::underflow(), std::basic_filebuf< _CharT, _Traits >::underflow(), and std::basic_filebuf< _CharT, _Traits >::xsgetn().
.SS "virtual void \fBstd::basic_filebuf\fP< _CharT , _Traits  >::imbue (const \fBlocale\fP &)\fC [protected, virtual, inherited]\fP"
.PP
Changes translations. 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP A new locale.
.RE
.PP
Translations done during I/O which depend on the current locale are changed by this call. The standard adds, 'Between invocations of this function a class derived from streambuf can safely cache results of calls to locale functions and to members of facets so obtained.'
.PP
\fBNote:\fP
.RS 4
Base class version does nothing. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "streamsize \fBstd::basic_streambuf\fP< _CharT , _Traits  >::in_avail ()\fC [inline, inherited]\fP"
.PP
Looking ahead into the stream. 
.PP
\fBReturns:\fP
.RS 4
The number of characters available.
.RE
.PP
If a read position is available, returns the number of characters available for reading before the buffer must be refilled. Otherwise returns the derived \fCshowmanyc()\fP. 
.PP
Definition at line 261 of file streambuf.
.SS "bool \fBstd::basic_filebuf\fP< _CharT , _Traits  >::is_open () const  throw ()\fC [inline, inherited]\fP"
.PP
Returns true if the external file is open. 
.PP
Definition at line 222 of file fstream.
.PP
Referenced by __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().
.SS "\fB__filebuf_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::open (const \fBstd::string\fP & __s, ios_base::openmode __mode)\fC [inline, inherited]\fP"
.PP
Opens an external file. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The name of the file. 
.br
\fImode\fP The open mode flags. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure 
.RE
.PP

.PP
Definition at line 275 of file fstream.
.SS "\fB__filebuf_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::open (const char * __s, ios_base::openmode __mode)\fC [inherited]\fP"
.PP
Opens an external file. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP The name of the file. 
.br
\fImode\fP The open mode flags. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP on success, NULL on failure
.RE
.PP
If a file is already open, this function immediately fails. Otherwise it tries to open the file named \fIs\fP using the flags given in \fImode\fP.
.PP
Table 92, adapted here, gives the relation between openmode combinations and the equivalent fopen() flags. (NB: lines app, in|out|app, in|app, binary|app, binary|in|out|app, and binary|in|app per DR 596) +---------------------------------------------------------+ | ios_base Flag combination stdio equivalent | |binary in out trunc app | +---------------------------------------------------------+ | + 'w' | | + + 'a' | | + 'a' | | + + 'w' | | + 'r' | | + + 'r+' | | + + + 'w+' | | + + + 'a+' | | + + 'a+' | +---------------------------------------------------------+ | + + 'wb' | | + + + 'ab' | | + + 'ab' | | + + + 'wb' | | + + 'rb' | | + + + 'r+b' | | + + + + 'w+b' | | + + + + 'a+b' | | + + + 'a+b' | +---------------------------------------------------------+ 
.SS "virtual \fBint_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::overflow (int_type = \fC_Traits::eof()\fP)\fC [protected, virtual, inherited]\fP"
.PP
Consumes data from the buffer; writes to the controlled sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP An additional character to consume. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() to indicate failure, something else (usually \fIc\fP, or not_eof())
.RE
.PP
Informally, this function is called when the output buffer is full (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'consumed', with 'some effect' on the controlled sequence. (Typically, the buffer is written out to the sequence verbatim.) In either case, the character \fIc\fP is also written out, if \fIc\fP is not \fCeof()\fP.
.PP
For a formal definition of this function, see a good text such as Langer & Kreft, or [27.5.2.4.5]/3-7.
.PP
A functioning output streambuf can be created by overriding only this function (no buffer area will be used).
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual \fBint_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::pbackfail (int_type = \fC_Traits::eof()\fP)\fC [protected, virtual, inherited]\fP"
.PP
Tries to back up the input sequence. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to be inserted back into the sequence. 
.RE
.PP
\fBReturns:\fP
.RS 4
eof() on failure, 'some other value' on success 
.RE
.PP
\fBPostcondition:\fP
.RS 4
The constraints of \fCgptr()\fP, \fCeback()\fP, and \fCpptr()\fP are the same as for \fCunderflow()\fP.
.RE
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pbase () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 505 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pbump (int __n)\fC [inline, protected, inherited]\fP"
.PP
Moving the write position. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP The delta by which to move.
.RE
.PP
This just advances the write position without returning any data. 
.PP
Definition at line 521 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pptr () const\fC [inline, protected, inherited]\fP"
.PP
Access to the put area. 
.PP
These functions are only available to other protected functions, including derived classes.
.PP
.IP "\(bu" 2
pbase() returns the beginning pointer for the output sequence
.IP "\(bu" 2
pptr() returns the next pointer for the output sequence
.IP "\(bu" 2
epptr() returns the end pointer for the output sequence 
.PP

.PP
Definition at line 508 of file streambuf.
.PP
Referenced by std::basic_stringbuf< _CharT, _Traits, _Alloc >::overflow(), std::basic_filebuf< _CharT, _Traits >::overflow(), std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekoff(), and std::basic_stringbuf< _CharT, _Traits, _Alloc >::seekpos().
.SS "locale \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubimbue (const \fBlocale\fP & __loc)\fC [inline, inherited]\fP"
.PP
Entry point for imbue(). 
.PP
\fBParameters:\fP
.RS 4
\fIloc\fP The new locale. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous locale.
.RE
.PP
Calls the derived imbue(loc). 
.PP
Definition at line 204 of file streambuf.
.SS "\fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubseekoff (off_type __off, ios_base::seekdir __way, ios_base::openmode __mode = \fCios_base::in | ios_base::out\fP)\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 238 of file streambuf.
.SS "\fBpos_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubseekpos (pos_type __sp, ios_base::openmode __mode = \fCios_base::in | ios_base::out\fP)\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 243 of file streambuf.
.SS "\fB__streambuf_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubsetbuf (char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry points for derived buffer functions. 
.PP
The public versions of \fCpubfoo\fP dispatch to the protected derived \fCfoo\fP member functions, passing the arguments (if any) and returning the result unchanged. 
.PP
Definition at line 234 of file streambuf.
.SS "int \fBstd::basic_streambuf\fP< _CharT , _Traits  >::pubsync ()\fC [inline, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 248 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sbumpc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character and increments the read pointer, otherwise calls and returns \fCuflow()\fP. 
.PP
Definition at line 293 of file streambuf.
.SS "virtual \fBpos_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::seekoff (off_type, ios_base::seekdir, ios_base::openmode = \fCios_base::in | ios_base::out\fP)\fC [protected, virtual, inherited]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual \fBpos_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::seekpos (pos_type, ios_base::openmode = \fCios_base::in | ios_base::out\fP)\fC [protected, virtual, inherited]\fP"
.PP
Alters the stream positions. 
.PP
Each derived class provides its own appropriate behavior. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns a \fCpos_type\fP that represents an invalid stream position. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual \fB__streambuf_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::setbuf (char_type * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Manipulates the buffer. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Pointer to a buffer area. 
.br
\fIn\fP Size of \fIs\fP. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fCthis\fP 
.RE
.PP
If no file has been opened, and both \fIs\fP and \fIn\fP are zero, then the stream becomes unbuffered. Otherwise, \fCs\fP is used as a buffer; see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25s02.html for more. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::setg (char_type * __gbeg, char_type * __gnext, char_type * __gend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three read area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIgbeg\fP A pointer. 
.br
\fIgnext\fP A pointer. 
.br
\fIgend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIgbeg\fP == \fCeback()\fP, \fIgnext\fP == \fCgptr()\fP, and \fIgend\fP == \fCegptr()\fP 
.RE
.PP

.PP
Definition at line 485 of file streambuf.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::setp (char_type * __pbeg, char_type * __pend)\fC [inline, protected, inherited]\fP"
.PP
Setting the three write area pointers. 
.PP
\fBParameters:\fP
.RS 4
\fIpbeg\fP A pointer. 
.br
\fIpend\fP A pointer. 
.RE
.PP
\fBPostcondition:\fP
.RS 4
\fIpbeg\fP == \fCpbase()\fP, \fIpbeg\fP == \fCpptr()\fP, and \fIpend\fP == \fCepptr()\fP 
.RE
.PP

.PP
Definition at line 531 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sgetc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
If the input read position is available, returns that character, otherwise calls and returns \fCunderflow()\fP. Does not move the read position after fetching the character. 
.PP
Definition at line 315 of file streambuf.
.SS "streamsize \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sgetn (char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for xsgetn. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP A count.
.RE
.PP
Returns xsgetn(s,n). The effect is to fill \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, if possible. 
.PP
Definition at line 334 of file streambuf.
.SS "virtual streamsize \fBstd::basic_filebuf\fP< _CharT , _Traits  >::showmanyc ()\fC [protected, virtual, inherited]\fP"
.PP
Investigating the data available. 
.PP
\fBReturns:\fP
.RS 4
An estimate of the number of characters available in the input sequence, or -1.
.RE
.PP
'If it returns a positive value, then successive calls to \fCunderflow()\fP will not return \fCtraits::eof()\fP until at least that number of characters have been supplied. If \fCshowmanyc()\fP returns -1, then calls to \fCunderflow()\fP or \fCuflow()\fP will fail.' [27.5.2.4.3]/1
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.PP
The standard adds that 'the intention is not only that the calls [to underflow or uflow] will not return \fCeof()\fP but that they will return 'immediately'. 
.PP
The standard adds that 'the morphemes of \fCshowmanyc\fP are 'es-how-many-see', not 'show-manic'. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::snextc ()\fC [inline, inherited]\fP"
.PP
Getting the next character. 
.PP
\fBReturns:\fP
.RS 4
The next character, or eof.
.RE
.PP
Calls \fCsbumpc()\fP, and if that function returns \fCtraits::eof()\fP, so does this function. Otherwise, \fCsgetc()\fP. 
.PP
Definition at line 275 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputbackc (char_type __c)\fC [inline, inherited]\fP"
.PP
Pushing characters back into the input stream. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP The character to push back. 
.RE
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
Similar to sungetc(), but \fIc\fP is pushed onto the stream instead of 'the previous character'. If successful, the next character fetched from the input stream will be \fIc\fP. 
.PP
Definition at line 348 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputc (char_type __c)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIc\fP A character to output. 
.RE
.PP
\fBReturns:\fP
.RS 4
\fIc\fP, if possible.
.RE
.PP
One of two public output functions.
.PP
If a write position is available for the output sequence (i.e., the buffer is not full), stores \fIc\fP in that position, increments the position, and returns \fCtraits::to_int_type(c)\fP. If a write position is not available, returns \fCoverflow(c)\fP. 
.PP
Definition at line 400 of file streambuf.
.SS "streamsize \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sputn (const char_type * __s, \fBstreamsize\fP __n)\fC [inline, inherited]\fP"
.PP
Entry point for all single-character output functions. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer read area. 
.br
\fIn\fP A count.
.RE
.PP
One of two public output functions.
.PP
Returns xsputn(s,n). The effect is to write \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, if possible. 
.PP
Definition at line 426 of file streambuf.
.SS "void \fBstd::basic_streambuf\fP< _CharT , _Traits  >::stossc ()\fC [inline, inherited]\fP"
.PP
Tosses a character. 
.PP
Advances the read pointer, ignoring the character that would have been read.
.PP
See http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html 
.PP
Definition at line 758 of file streambuf.
.SS "\fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::sungetc ()\fC [inline, inherited]\fP"
.PP
Moving backwards in the input stream. 
.PP
\fBReturns:\fP
.RS 4
The previous character, if possible.
.RE
.PP
If a putback position is available, this function decrements the input pointer and returns that character. Otherwise, calls and returns pbackfail(). The effect is to 'unget' the last character 'gotten'. 
.PP
Definition at line 373 of file streambuf.
.SS "virtual int \fBstd::basic_filebuf\fP< _CharT , _Traits  >::sync (void)\fC [protected, virtual, inherited]\fP"
.PP
Synchronizes the buffer arrays with the controlled sequences. 
.PP
\fBReturns:\fP
.RS 4
-1 on failure.
.RE
.PP
Each derived class provides its own appropriate behavior, including the definition of 'failure'. 
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns zero. 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual \fBint_type\fP \fBstd::basic_streambuf\fP< _CharT , _Traits  >::uflow ()\fC [inline, protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function does the same thing as \fCunderflow()\fP, and in fact is required to call that function. It also returns the new character, like \fCunderflow()\fP does. However, this function also moves the read position forward by one. 
.PP
Reimplemented in \fB__gnu_cxx::stdio_sync_filebuf< _CharT, _Traits >\fP.
.PP
Definition at line 676 of file streambuf.
.SS "virtual \fBint_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::underflow ()\fC [protected, virtual, inherited]\fP"
.PP
Fetches more data from the controlled sequence. 
.PP
\fBReturns:\fP
.RS 4
The first character from the \fIpending sequence\fP.
.RE
.PP
Informally, this function is called when the input buffer is exhausted (or does not exist, as buffering need not actually be done). If a buffer exists, it is 'refilled'. In either case, the next available character is returned, or \fCtraits::eof()\fP to indicate a null pending sequence.
.PP
For a formal definition of the pending sequence, see a good text such as Langer & Kreft, or [27.5.2.4.3]/7-14.
.PP
A functioning input streambuf can be created by overriding only this function (no buffer area will be used). For an example, see http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt11ch25.html
.PP
\fBNote:\fP
.RS 4
Base class version does nothing, returns eof(). 
.RE
.PP

.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual streamsize \fBstd::basic_filebuf\fP< _CharT , _Traits  >::xsgetn (char_type * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character extraction. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to assign. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters assigned.
.RE
.PP
Fills \fIs\fP[0] through \fIs\fP[n-1] with characters from the input sequence, as if by \fCsbumpc()\fP. Stops when either \fIn\fP characters have been copied, or when \fCtraits::eof()\fP would be copied.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SS "virtual streamsize \fBstd::basic_filebuf\fP< _CharT , _Traits  >::xsputn (const char_type * __s, \fBstreamsize\fP __n)\fC [protected, virtual, inherited]\fP"
.PP
Multiple character insertion. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP A buffer area. 
.br
\fIn\fP Maximum number of characters to write. 
.RE
.PP
\fBReturns:\fP
.RS 4
The number of characters written.
.RE
.PP
Writes \fIs\fP[0] through \fIs\fP[n-1] to the output sequence, as if by \fCsputc()\fP. Stops when either \fIn\fP characters have been copied, or when \fCsputc()\fP would return \fCtraits::eof()\fP.
.PP
It is expected that derived classes provide a more efficient implementation by overriding this definition. 
.PP
Reimplemented from \fBstd::basic_streambuf< _CharT, _Traits >\fP.
.SH "Member Data Documentation"
.PP 
.SS "\fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_buf\fP\fC [protected, inherited]\fP"
.PP
Pointer to the beginning of internal buffer. 
.PP
Definition at line 109 of file fstream.
.SS "locale \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_buf_locale\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 187 of file streambuf.
.PP
Referenced by std::basic_filebuf< _CharT, _Traits >::basic_filebuf().
.SS "size_t \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_buf_size\fP\fC [protected, inherited]\fP"
.PP
Actual size of internal buffer. This number is equal to the size of the put area + 1 position, reserved for the overflow char of a full area. 
.PP
Definition at line 116 of file fstream.
.PP
Referenced by __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().
.SS "char* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_ext_buf\fP\fC [protected, inherited]\fP"
.PP
Buffer for external characters. Used for input when codecvt::always_noconv() == false. When valid, this corresponds to eback(). 
.PP
Definition at line 151 of file fstream.
.SS "streamsize \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_ext_buf_size\fP\fC [protected, inherited]\fP"
.PP
Size of buffer held by _M_ext_buf. 
.PP
Definition at line 156 of file fstream.
.SS "const char* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_ext_next\fP\fC [protected, inherited]\fP"
.PP
Pointers into the buffer held by _M_ext_buf that delimit a subsequence of bytes that have been read but not yet converted. When valid, _M_ext_next corresponds to egptr(). 
.PP
Definition at line 163 of file fstream.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_beg\fP\fC [protected, inherited]\fP"
.PP
This is based on _IO_FILE, just reordered to be more consistent, and is intended to be the most minimal abstraction for an internal buffer.
.IP "\(bu" 2
get == input == read
.IP "\(bu" 2
put == output == write 
.PP

.PP
Definition at line 179 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_cur\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 180 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_in_end\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 181 of file streambuf.
.SS "ios_base::openmode \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_mode\fP\fC [protected, inherited]\fP"
.PP
Place to stash in || out || in | out settings for current filebuf. 
.PP
Definition at line 94 of file fstream.
.PP
Referenced by __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_beg\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 182 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_cur\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 183 of file streambuf.
.SS "\fBchar_type\fP* \fBstd::basic_streambuf\fP< _CharT , _Traits  >::\fB_M_out_end\fP\fC [protected, inherited]\fP"
.PP
Current locale setting. 
.PP
Definition at line 184 of file streambuf.
.SS "\fBchar_type\fP \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_pback\fP\fC [protected, inherited]\fP"
.PP
Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 137 of file fstream.
.SS "\fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_pback_cur_save\fP\fC [protected, inherited]\fP"
.PP
Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 138 of file fstream.
.SS "\fBchar_type\fP* \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_pback_end_save\fP\fC [protected, inherited]\fP"
.PP
Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 139 of file fstream.
.SS "bool \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_pback_init\fP\fC [protected, inherited]\fP"
.PP
Necessary bits for putback buffer management.
.PP
\fBNote:\fP
.RS 4
pbacks of over one character are not currently supported. 
.RE
.PP

.PP
Definition at line 140 of file fstream.
.SS "bool \fBstd::basic_filebuf\fP< _CharT , _Traits  >::\fB_M_reading\fP\fC [protected, inherited]\fP"
.PP
_M_reading == false && _M_writing == false for 'uncommitted' mode; _M_reading == true for 'read' mode; _M_writing == true for 'write' mode;
.PP
NB: _M_reading == true && _M_writing == true is unused. 
.PP
Definition at line 128 of file fstream.
.PP
Referenced by __gnu_cxx::stdio_filebuf< _CharT, _Traits >::stdio_filebuf().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
