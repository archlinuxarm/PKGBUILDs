.TH "__gnu_debug::_Safe_iterator_base" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_debug::_Safe_iterator_base \- Basic functionality for a 'safe' iterator.  

.PP
.SH SYNOPSIS
.br
.PP
Inherited by \fB__gnu_debug::_Safe_iterator< _Iterator, _Sequence >\fP, and std::__debug::bitset< _Nb >::bitset::reference.
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fB_M_attach\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "void \fB_M_attach_single\fP (\fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "bool \fB_M_attached_to\fP (const \fB_Safe_sequence_base\fP *__seq) const "
.br
.ti -1c
.RI "bool \fB_M_can_compare\fP (const \fB_Safe_iterator_base\fP &__x) const "
.br
.ti -1c
.RI "void \fB_M_detach\fP ()"
.br
.ti -1c
.RI "void \fB_M_detach_single\fP ()"
.br
.ti -1c
.RI "bool \fB_M_singular\fP () const "
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_next\fP"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP * \fB_M_prior\fP"
.br
.ti -1c
.RI "\fB_Safe_sequence_base\fP * \fB_M_sequence\fP"
.br
.ti -1c
.RI "unsigned int \fB_M_version\fP"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "__gnu_cxx::__mutex & \fB_M_get_mutex\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_iterator_base\fP &)"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_iterator_base\fP &__x, bool __constant)"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP (const \fB_Safe_sequence_base\fP *__seq, bool __constant)"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP ()"
.br
.ti -1c
.RI "\fB_Safe_iterator_base\fP & \fBoperator=\fP (const \fB_Safe_iterator_base\fP &)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Basic functionality for a 'safe' iterator. 

The _Safe_iterator_base base class implements the functionality of a safe iterator that is not specific to a particular iterator type. It contains a pointer back to the sequence it references along with iterator version information and pointers to form a doubly-linked list of iterators referenced by the container.
.PP
This class must not perform any operations that can throw an exception, or the exception guarantees of derived iterators will be broken. 
.PP
Definition at line 51 of file safe_base.h.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base ()\fC [inline, protected]\fP"
.PP
Initializes the iterator and makes it singular. 
.PP
Definition at line 77 of file safe_base.h.
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base (const \fB_Safe_sequence_base\fP * __seq, bool __constant)\fC [inline, protected]\fP"
.PP
Initialize the iterator to reference the sequence pointed to by . \fC__constant\fP is true when we are initializing a constant iterator, and false if it is a mutable iterator. Note that \fC__seq\fP may be NULL, in which case the iterator will be singular. Otherwise, the iterator will reference \fC__seq\fP and be nonsingular. 
.PP
Definition at line 88 of file safe_base.h.
.PP
References _M_attach().
.SS "__gnu_debug::_Safe_iterator_base::_Safe_iterator_base (const \fB_Safe_iterator_base\fP & __x, bool __constant)\fC [inline, protected]\fP"
.PP
Initializes the iterator to reference the same sequence that \fC__x\fP does. \fC__constant\fP is true if this is a constant iterator, and false if it is mutable. 
.PP
Definition at line 95 of file safe_base.h.
.PP
References _M_attach(), and _M_sequence.
.SH "Member Function Documentation"
.PP 
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach (\fB_Safe_sequence_base\fP * __seq, bool __constant)"
.PP
Attaches this iterator to the given sequence, detaching it from whatever sequence it was attached to originally. If the new sequence is the NULL pointer, the iterator is left unattached. 
.PP
Referenced by _Safe_iterator_base().
.SS "void __gnu_debug::_Safe_iterator_base::_M_attach_single (\fB_Safe_sequence_base\fP * __seq, bool __constant)"
.PP
Likewise, but not thread-safe. 
.SS "bool __gnu_debug::_Safe_iterator_base::_M_attached_to (const \fB_Safe_sequence_base\fP * __seq) const\fC [inline]\fP"
.PP
Determines if we are attached to the given sequence. 
.PP
Definition at line 130 of file safe_base.h.
.PP
References _M_sequence.
.SS "bool __gnu_debug::_Safe_iterator_base::_M_can_compare (const \fB_Safe_iterator_base\fP & __x) const"
.PP
Can we compare this iterator to the given iterator \fC__x\fP? Returns true if both iterators are nonsingular and reference the same sequence. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach ()"
.PP
Detach the iterator for whatever sequence it is attached to, if any. 
.SS "void __gnu_debug::_Safe_iterator_base::_M_detach_single ()"
.PP
Likewise, but not thread-safe. 
.SS "__gnu_cxx::__mutex& __gnu_debug::_Safe_iterator_base::_M_get_mutex ()\fC [protected]\fP"
.PP
For use in \fB_Safe_iterator\fP. 
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate().
.SS "bool __gnu_debug::_Safe_iterator_base::_M_singular () const"
.PP
Is this iterator singular? 
.PP
Referenced by __gnu_debug::__check_singular(), __gnu_debug::__check_singular_aux(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_dereferenceable(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_Safe_iterator(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SH "Member Data Documentation"
.PP 
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_next\fP"
.PP
Pointer to the next iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 73 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().
.SS "\fB_Safe_iterator_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_prior\fP"
.PP
Pointer to the previous iterator in the sequence's list of iterators. Only valid when _M_sequence != NULL. 
.PP
Definition at line 69 of file safe_base.h.
.SS "\fB_Safe_sequence_base\fP* \fB__gnu_debug::_Safe_iterator_base::_M_sequence\fP"
.PP
The sequence this iterator references; may be NULL to indicate a singular iterator. 
.PP
Definition at line 56 of file safe_base.h.
.PP
Referenced by _M_attached_to(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_begin(), __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_is_end(), __gnu_debug::_Safe_sequence< _Sequence >::_M_transfer_iter(), _Safe_iterator_base(), and __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::operator=().
.SS "unsigned int \fB__gnu_debug::_Safe_iterator_base::_M_version\fP"
.PP
The version number of this iterator. The sentinel value 0 is used to indicate an invalidated iterator (i.e., one that is singular because of an operation on the container). This version number must equal the version number in the sequence referenced by _M_sequence for the iterator to be non-singular. 
.PP
Definition at line 65 of file safe_base.h.
.PP
Referenced by __gnu_debug::_Safe_iterator< _Iterator, _Sequence >::_M_invalidate_single().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
