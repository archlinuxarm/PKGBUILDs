.TH "__gnu_cxx::__rc_string_base" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
__gnu_cxx::__rc_string_base \- 
.SH SYNOPSIS
.br
.PP
Inherits __gnu_cxx::__vstring_utility<_CharT, _Traits, _Alloc>.
.PP
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef _Util_Base::_CharT_alloc_type \fB_CharT_alloc_type\fP"
.br
.ti -1c
.RI "typedef __vstring_utility< _CharT, _Traits, _Alloc > \fB_Util_Base\fP"
.br
.ti -1c
.RI "typedef _Alloc \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef _CharT_alloc_type::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef _Traits \fBtraits_type\fP"
.br
.ti -1c
.RI "typedef _Traits::char_type \fBvalue_type\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename _InputIterator > \fB__rc_string_base\fP (_InputIterator __beg, _InputIterator __end, const _Alloc &__a)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (size_type __n, _CharT __c, const _Alloc &__a)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (\fB__rc_string_base\fP &&__rcs)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (const \fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "\fB__rc_string_base\fP (const _Alloc &__a)"
.br
.ti -1c
.RI "void \fB_M_assign\fP (const \fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "size_type \fB_M_capacity\fP () const "
.br
.ti -1c
.RI "void \fB_M_clear\fP ()"
.br
.ti -1c
.RI "template<> bool \fB_M_compare\fP (const \fB__rc_string_base\fP &__rcs) const"
.br
.ti -1c
.RI "template<> bool \fB_M_compare\fP (const \fB__rc_string_base\fP &__rcs) const"
.br
.ti -1c
.RI "bool \fB_M_compare\fP (const \fB__rc_string_base\fP &) const "
.br
.ti -1c
.RI "_CharT * \fB_M_data\fP () const "
.br
.ti -1c
.RI "void \fB_M_erase\fP (size_type __pos, size_type __n)"
.br
.ti -1c
.RI "const allocator_type & \fB_M_get_allocator\fP () const "
.br
.ti -1c
.RI "allocator_type & \fB_M_get_allocator\fP ()"
.br
.ti -1c
.RI "bool \fB_M_is_shared\fP () const "
.br
.ti -1c
.RI "void \fB_M_leak\fP ()"
.br
.ti -1c
.RI "size_type \fB_M_length\fP () const "
.br
.ti -1c
.RI "size_type \fB_M_max_size\fP () const "
.br
.ti -1c
.RI "void \fB_M_mutate\fP (size_type __pos, size_type __len1, const _CharT *__s, size_type __len2)"
.br
.ti -1c
.RI "void \fB_M_reserve\fP (size_type __res)"
.br
.ti -1c
.RI "void \fB_M_set_leaked\fP ()"
.br
.ti -1c
.RI "void \fB_M_set_length\fP (size_type __n)"
.br
.ti -1c
.RI "void \fB_M_swap\fP (\fB__rc_string_base\fP &__rcs)"
.br
.ti -1c
.RI "template<typename _InIterator > _CharT * \fB_S_construct\fP (_InIterator __beg, _InIterator __end, const _Alloc &__a, \fBstd::forward_iterator_tag\fP)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< const_pointer, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, \fB__rc_string_base\fP > > \fB__const_rc_iterator\fP"
.br
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< const_pointer, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, __sso_string_base > > \fB__const_sso_iterator\fP"
.br
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< pointer, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, \fB__rc_string_base\fP > > \fB__rc_iterator\fP"
.br
.ti -1c
.RI "typedef __gnu_cxx::__normal_iterator< pointer, \fB__gnu_cxx::__versa_string\fP< _CharT, _Traits, _Alloc, __sso_string_base > > \fB__sso_iterator\fP"
.br
.ti -1c
.RI "typedef _CharT_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef _CharT_alloc_type::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef _CharT_alloc_type::pointer \fBpointer\fP"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fB_S_assign\fP (_CharT *__d, size_type __n, _CharT __c)"
.br
.ti -1c
.RI "static int \fB_S_compare\fP (size_type __n1, size_type __n2)"
.br
.ti -1c
.RI "static void \fB_S_copy\fP (_CharT *__d, const _CharT *__s, size_type __n)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, const _CharT *__k1, const _CharT *__k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, _CharT *__k1, _CharT *__k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __const_rc_iterator __k1, __const_rc_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __rc_iterator __k1, __rc_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __const_sso_iterator __k1, __const_sso_iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_copy_chars\fP (_CharT *__p, __sso_iterator __k1, __sso_iterator __k2)"
.br
.ti -1c
.RI "template<typename _Iterator > static void \fB_S_copy_chars\fP (_CharT *__p, _Iterator __k1, _Iterator __k2)"
.br
.ti -1c
.RI "static void \fB_S_move\fP (_CharT *__d, const _CharT *__s, size_type __n)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _CharT, typename _Traits, typename _Alloc> class __gnu_cxx::__rc_string_base< _CharT, _Traits, _Alloc >"
Documentation? What's that? Nathan Myers <ncm@cantrip.org>.
.PP
A string looks like this:
.PP
.PP
.nf
                                        [_Rep]
                                        _M_length
   [__rc_string_base<char_type>]        _M_capacity
   _M_dataplus                          _M_refcount
   _M_p ---------------->               unnamed array of char_type
.fi
.PP
.PP
Where the _M_p points to the first \fBcharacter\fP in the string, and you cast it to a pointer-to-_Rep and subtract 1 to get a pointer to the header.
.PP
This approach has the enormous advantage that a string object requires only one allocation. All the ugliness is confined within a single pair of inline functions, which each compile to a single 'add' instruction: _Rep::_M_refdata(), and __rc_string_base::_M_rep(); and the allocation function which gets a block of raw bytes and with room enough and constructs a _Rep object at the front.
.PP
The reason you want _M_data pointing to the \fBcharacter\fP array and not the _Rep is so that the debugger can see the string contents. (Probably we should add a non-inline member to get the _Rep for the debugger to use, so users can check the actual string length.)
.PP
Note that the _Rep object is a POD so that you can have a static 'empty string' _Rep object already 'constructed' before static constructors have run. The reference-count encoding is chosen so that a 0 indicates one reference, so you never try to destroy the empty-string _Rep object.
.PP
All but the last paragraph is considered pretty conventional for a C++ string implementation. 
.PP
Definition at line 81 of file rc_string_base.h.

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
