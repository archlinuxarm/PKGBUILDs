.TH "std::match_results" 3 "21 Apr 2009" "libstdc++" \" -*- nroff -*-
.ad l
.nh
.SH NAME
std::match_results \- The results of a match or search operation.  

.PP
.SH SYNOPSIS
.br
.PP
Inherits \fBvector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
.SS "Private Types"

.in +1c
.ti -1c
.RI "typedef _Tp_alloc_type::const_pointer \fBconst_pointer\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< const_iterator > \fBconst_reverse_iterator\fP"
.br
.ti -1c
.RI "typedef _Tp_alloc_type::pointer \fBpointer\fP"
.br
.ti -1c
.RI "typedef \fBstd::reverse_iterator\fP< iterator > \fBreverse_iterator\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "_Tp_alloc_type::pointer \fB_M_allocate\fP (size_t __n)"
.br
.ti -1c
.RI "pointer \fB_M_allocate_and_copy\fP (size_type __n, _ForwardIterator __first, _ForwardIterator __last)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_aux\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_assign_dispatch\fP (_Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "size_type \fB_M_check_len\fP (size_type __n, const char *__s) const"
.br
.ti -1c
.RI "void \fB_M_deallocate\fP (typename _Tp_alloc_type::pointer __p, size_t __n)"
.br
.ti -1c
.RI "void \fB_M_erase_at_end\fP (pointer __pos)"
.br
.ti -1c
.RI "void \fB_M_fill_assign\fP (size_type __n, const \fBvalue_type\fP &__val)"
.br
.ti -1c
.RI "void \fB_M_fill_initialize\fP (size_type __n, const \fBvalue_type\fP &__value)"
.br
.ti -1c
.RI "void \fB_M_fill_insert\fP (iterator __pos, size_type __n, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "const _Tp_alloc_type & \fB_M_get_Tp_allocator\fP () const"
.br
.ti -1c
.RI "_Tp_alloc_type & \fB_M_get_Tp_allocator\fP ()"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_initialize_dispatch\fP (_Integer __n, _Integer __value, __true_type)"
.br
.ti -1c
.RI "void \fB_M_insert_aux\fP (iterator __position, _Args &&...__args)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _InputIterator __first, _InputIterator __last, __false_type)"
.br
.ti -1c
.RI "void \fB_M_insert_dispatch\fP (iterator __pos, _Integer __n, _Integer __val, __true_type)"
.br
.ti -1c
.RI "void \fB_M_range_check\fP (size_type __n) const"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_initialize\fP (_InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _ForwardIterator __first, _ForwardIterator __last, \fBstd::forward_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fB_M_range_insert\fP (iterator __pos, _InputIterator __first, _InputIterator __last, \fBstd::input_iterator_tag\fP)"
.br
.ti -1c
.RI "void \fBassign\fP (\fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "void \fBassign\fP (_InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBassign\fP (size_type __n, const \fBvalue_type\fP &__val)"
.br
.ti -1c
.RI "const_reference \fBat\fP (size_type __n) const"
.br
.ti -1c
.RI "reference \fBat\fP (size_type __n)"
.br
.ti -1c
.RI "const_reference \fBback\fP () const"
.br
.ti -1c
.RI "reference \fBback\fP ()"
.br
.ti -1c
.RI "iterator \fBbegin\fP ()"
.br
.ti -1c
.RI "size_type \fBcapacity\fP () const"
.br
.ti -1c
.RI "void \fBclear\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrbegin\fP () const"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBcrend\fP () const"
.br
.ti -1c
.RI "const_pointer \fBdata\fP () const"
.br
.ti -1c
.RI "pointer \fBdata\fP ()"
.br
.ti -1c
.RI "iterator \fBemplace\fP (iterator __position, _Args &&...__args)"
.br
.ti -1c
.RI "void \fBemplace_back\fP (_Args &&...__args)"
.br
.ti -1c
.RI "iterator \fBend\fP ()"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __first, iterator __last)"
.br
.ti -1c
.RI "iterator \fBerase\fP (iterator __position)"
.br
.ti -1c
.RI "const_reference \fBfront\fP () const"
.br
.ti -1c
.RI "reference \fBfront\fP ()"
.br
.ti -1c
.RI "allocator_type \fBget_allocator\fP () const"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, _InputIterator __first, _InputIterator __last)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, size_type __n, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "void \fBinsert\fP (iterator __position, \fBinitializer_list\fP< \fBvalue_type\fP > __l)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, \fBvalue_type\fP &&__x)"
.br
.ti -1c
.RI "iterator \fBinsert\fP (iterator __position, const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "size_type \fBmax_size\fP () const"
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __n) const"
.br
.ti -1c
.RI "reference \fBoperator[]\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBpop_back\fP ()"
.br
.ti -1c
.RI "void \fBpush_back\fP (\fBvalue_type\fP &&__x)"
.br
.ti -1c
.RI "void \fBpush_back\fP (const \fBvalue_type\fP &__x)"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrbegin\fP () const"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrbegin\fP ()"
.br
.ti -1c
.RI "\fBconst_reverse_iterator\fP \fBrend\fP () const"
.br
.ti -1c
.RI "\fBreverse_iterator\fP \fBrend\fP ()"
.br
.ti -1c
.RI "void \fBreserve\fP (size_type __n)"
.br
.ti -1c
.RI "void \fBresize\fP (size_type __new_size, \fBvalue_type\fP __x=\fBvalue_type\fP())"
.br
.ti -1c
.RI "void \fBswap\fP (\fBvector\fP &&__x)"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "_Vector_impl \fB_M_impl\fP"
.br
.in -1c
.SS "10.? Public Types"

.in +1c
.ti -1c
.RI "typedef _Allocator \fBallocator_type\fP"
.br
.ti -1c
.RI "typedef \fBiterator_traits\fP< _Bi_iter >::\fBvalue_type\fP \fBchar_type\fP"
.br
.ti -1c
.RI "typedef _Base_type::const_iterator \fBconst_iterator\fP"
.br
.ti -1c
.RI "typedef _Allocator::const_reference \fBconst_reference\fP"
.br
.ti -1c
.RI "typedef \fBiterator_traits\fP< _Bi_iter >::difference_type \fBdifference_type\fP"
.br
.ti -1c
.RI "typedef const_iterator \fBiterator\fP"
.br
.ti -1c
.RI "typedef const_reference \fBreference\fP"
.br
.ti -1c
.RI "typedef _Allocator::size_type \fBsize_type\fP"
.br
.ti -1c
.RI "typedef \fBbasic_string\fP< char_type > \fBstring_type\fP"
.br
.ti -1c
.RI "typedef \fBsub_match\fP< _Bi_iter > \fBvalue_type\fP"
.br
.in -1c
.SS "10.3 Element Access"

.in +1c
.ti -1c
.RI "const_iterator \fBbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcbegin\fP () const "
.br
.ti -1c
.RI "const_iterator \fBcend\fP () const "
.br
.ti -1c
.RI "const_iterator \fBend\fP () const "
.br
.ti -1c
.RI "difference_type \fBlength\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "const_reference \fBoperator[]\fP (size_type __sub) const "
.br
.ti -1c
.RI "difference_type \fBposition\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "const_reference \fBprefix\fP () const "
.br
.ti -1c
.RI "\fBstring_type\fP \fBstr\fP (size_type __sub=0) const "
.br
.ti -1c
.RI "const_reference \fBsuffix\fP () const "
.br
.in -1c
.SS "10.2 Size"

.in +1c
.ti -1c
.RI "bool \fBempty\fP () const "
.br
.ti -1c
.RI "size_type \fBsize\fP () const "
.br
.in -1c
.SS "10.4 Formatting"
These functions perform formatted substitution of the matched character sequences into their target. The format specifiers and escape sequences accepted by these functions are determined by their \fCflags\fP parameter as documented above. 
.in +1c
.ti -1c
.RI "\fBstring_type\fP \fBformat\fP (const \fBstring_type\fP &__fmt, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::format_default\fP) const "
.br
.ti -1c
.RI "template<typename _Out_iter > _Out_iter \fBformat\fP (_Out_iter __out, const \fBstring_type\fP &__fmt, \fBregex_constants::match_flag_type\fP __flags=\fBregex_constants::format_default\fP) const "
.br
.in -1c
.SS "10.1 Construction, Copying, and Destruction"

.in +1c
.ti -1c
.RI "\fBmatch_results\fP (const \fBmatch_results\fP &__rhs)"
.br
.ti -1c
.RI "\fBmatch_results\fP (const _Allocator &__a=_Allocator())"
.br
.ti -1c
.RI "\fBmatch_results\fP & \fBoperator=\fP (const \fBmatch_results\fP &__rhs)"
.br
.ti -1c
.RI "\fB~match_results\fP ()"
.br
.in -1c
.SS "10.6 Swap"

.in +1c
.ti -1c
.RI "void \fBswap\fP (\fBmatch_results\fP &__that)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> class std::match_results< _Bi_iter, _Allocator >"
The results of a match or search operation. 

A collection of character sequences representing the result of a regular expression match. Storage for the collection is allocated and freed as necessary by the member functions of class template \fBmatch_results\fP.
.PP
This class satisfies the Sequence requirements, with the \fBexception\fP that only the operations defined for a const-qualified Sequence are supported.
.PP
The \fBsub_match\fP object stored at index 0 represents sub-expression 0, i.e. the whole match. In this case the \fBsub_match\fP member matched is always true. The \fBsub_match\fP object stored at index n denotes what matched the marked sub-expression n within the matched expression. If the sub-expression n participated in a regular expression match then the \fBsub_match\fP member matched evaluates to true, and members first and second denote the range of characters [first, second) which formed that match. Otherwise matched is false, and members first and second point to the end of the sequence that was searched. 
.PP
Definition at line 1763 of file tr1_impl/regex.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Allocator >::\fBmatch_results\fP (const _Allocator & __a = \fC_Allocator()\fP)\fC [inline, explicit]\fP"
.PP
Constructs a default match_results container. 
.PP
\fBPostcondition:\fP
.RS 4
\fBsize()\fP returns 0 and \fBstr()\fP returns an empty string. 
.RE
.PP

.PP
Definition at line 1799 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Allocator >::\fBmatch_results\fP (const \fBmatch_results\fP< _Bi_iter, _Allocator > & __rhs)\fC [inline]\fP"
.PP
Copy constructs a match_results. 
.PP
Definition at line 1806 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBstd::match_results\fP< _Bi_iter, _Allocator >::~\fBmatch_results\fP ()\fC [inline]\fP"
.PP
Destroys a match_results object. 
.PP
Definition at line 1825 of file tr1_impl/regex.
.SH "Member Function Documentation"
.PP 
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Allocator >::begin () const\fC [inline]\fP"
.PP
Gets an \fBiterator\fP to the start of the sub_match collection. 
.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1947 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Allocator >::cbegin () const\fC [inline]\fP"
.PP
Gets an \fBiterator\fP to the start of the sub_match collection. 
.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1955 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Allocator >::cend () const\fC [inline]\fP"
.PP
Gets an \fBiterator\fP to one-past-the-end of the collection. 
.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1971 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> bool \fBstd::match_results\fP< _Bi_iter, _Allocator >::empty () const\fC [inline]\fP"
.PP
Indicates if the match_results contains no results. 
.PP
\fBReturn values:\fP
.RS 4
\fItrue\fP The match_results object is empty. 
.br
\fIfalse\fP The match_results object is not empty. 
.RE
.PP

.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1858 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_iterator \fBstd::match_results\fP< _Bi_iter, _Allocator >::end () const\fC [inline]\fP"
.PP
Gets an \fBiterator\fP to one-past-the-end of the collection. 
.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1963 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBstring_type\fP \fBstd::match_results\fP< _Bi_iter, _Allocator >::format (const \fBstring_type\fP & __fmt, \fBregex_constants::match_flag_type\fP __flags = \fC\fBregex_constants::format_default\fP\fP) const"
.PP
\fBTodo\fP
.RS 4
Implement this function. 
.RE
.PP

.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> template<typename _Out_iter > _Out_iter \fBstd::match_results\fP< _Bi_iter, _Allocator >::format (_Out_iter __out, const \fBstring_type\fP & __fmt, \fBregex_constants::match_flag_type\fP __flags = \fC\fBregex_constants::format_default\fP\fP) const\fC [inline]\fP"
.PP
\fBTodo\fP
.RS 4
Implement this function. 
.RE
.PP

.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> difference_type \fBstd::match_results\fP< _Bi_iter, _Allocator >::length (size_type __sub = \fC0\fP) const\fC [inline]\fP"
.PP
Gets the length of the indicated submatch. 
.PP
\fBParameters:\fP
.RS 4
\fIsub\fP indicates the submatch.
.RE
.PP
This function returns the length of the indicated submatch, or the length of the entire match if \fCsub\fP is zero (the default). 
.PP
Definition at line 1876 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBmatch_results\fP& \fBstd::match_results\fP< _Bi_iter, _Allocator >::operator= (const \fBmatch_results\fP< _Bi_iter, _Allocator > & __rhs)\fC [inline]\fP"
.PP
Assigns rhs to *this. 
.PP
Definition at line 1815 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_reference \fBstd::match_results\fP< _Bi_iter, _Allocator >::operator[] (size_type __sub) const\fC [inline]\fP"
.PP
Gets a sub_match reference for the match or submatch. 
.PP
\fBParameters:\fP
.RS 4
\fIsub\fP indicates the submatch.
.RE
.PP
This function gets a reference to the indicated submatch, or the entire match if \fCsub\fP is zero.
.PP
If \fCsub\fP >= \fBsize()\fP then this function returns a sub_match with a special value indicating no submatch. 
.PP
Definition at line 1918 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> difference_type \fBstd::match_results\fP< _Bi_iter, _Allocator >::position (size_type __sub = \fC0\fP) const\fC [inline]\fP"
.PP
Gets the offset of the beginning of the indicated submatch. 
.PP
\fBParameters:\fP
.RS 4
\fIsub\fP indicates the submatch.
.RE
.PP
This function returns the offset from the beginning of the target sequence to the beginning of the submatch, unless the value of \fCsub\fP is zero (the default), in which case this function returns the offset from the beginning of the target sequence to the beginning of the match. 
.PP
Definition at line 1890 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_reference \fBstd::match_results\fP< _Bi_iter, _Allocator >::prefix () const\fC [inline]\fP"
.PP
Gets a sub_match representing the match prefix. 
.PP
This function gets a reference to a sub_match object representing the part of the target range between the start of the target range and the start of the match. 
.PP
Definition at line 1929 of file tr1_impl/regex.
.PP
Referenced by std::match_results< _Bi_iter >::position().
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> size_type \fBstd::match_results\fP< _Bi_iter, _Allocator >::size () const\fC [inline]\fP"
.PP
Gets the number of matches and submatches. 
.PP
The number of matches for a given regular expression will be either 0 if there was no match or mark_count() + 1 if a match was successful. Some matches may be empty.
.PP
\fBReturns:\fP
.RS 4
the number of matches found. 
.RE
.PP

.PP
Reimplemented from \fBstd::vector< std::sub_match< _Bi_iter >, _Allocator >\fP.
.PP
Definition at line 1845 of file tr1_impl/regex.
.PP
Referenced by std::match_results< _Bi_iter >::empty().
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> \fBstring_type\fP \fBstd::match_results\fP< _Bi_iter, _Allocator >::str (size_type __sub = \fC0\fP) const\fC [inline]\fP"
.PP
Gets the match or submatch converted to a string type. 
.PP
\fBParameters:\fP
.RS 4
\fIsub\fP indicates the submatch.
.RE
.PP
This function gets the submatch (or match, if \fCsub\fP is zero) extracted from the target range and converted to the associated string type. 
.PP
Definition at line 1904 of file tr1_impl/regex.
.PP
Referenced by std::match_results< _Bi_iter >::length().
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> const_reference \fBstd::match_results\fP< _Bi_iter, _Allocator >::suffix () const\fC [inline]\fP"
.PP
Gets a sub_match representing the match suffix. 
.PP
This function gets a reference to a sub_match object representing the part of the target range between the end of the match and the end of the target range. 
.PP
Definition at line 1940 of file tr1_impl/regex.
.SS "template<typename _Bi_iter, typename _Allocator = allocator<sub_match<_Bi_iter> >> void \fBstd::match_results\fP< _Bi_iter, _Allocator >::swap (\fBmatch_results\fP< _Bi_iter, _Allocator > & __that)\fC [inline]\fP"
.PP
Swaps the contents of two \fBmatch_results\fP. 
.PP
Definition at line 2029 of file tr1_impl/regex.
.PP
Referenced by std::match_results< _Bi_iter >::operator=(), std::swap(), and std::match_results< _Bi_iter >::swap().

.SH "Author"
.PP 
Generated automatically by Doxygen for libstdc++ from the source code.
