# PCMCIA devices:
#
ACTION!="add", GOTO="pcmciautils_end"
# modprobe $env{MODALIAS} loads all possibly appropriate modules
SUBSYSTEM=="pcmcia", ENV{MODALIAS}=="?*", \
		RUN+="/lib/udev/load-modules.sh $env{MODALIAS}"

# Very few CIS firmware entries (which we use for matching)
# are so broken that we need to read out random bytes of it
# instead of the manufactor, card or product ID. Then the
# matching is done in userspace.
SUBSYSTEM=="pcmcia", ENV{MODALIAS}=="?*", \
		RUN+="/sbin/pcmcia-check-broken-cis"

# However, the "weak" matching by func_id is only allowed _after_ modprobe
# returns, so that "strong" matches have a higher priority.
SUBSYSTEM=="pcmcia", ENV{MODALIAS}=="?*", ATTR{allow_func_id_match}="1"

# PCMCIA sockets:
#
# modprobe the pcmcia bus module so that 16-bit PCMCIA devices work
SUBSYSTEM=="pcmcia_socket", \
		RUN+="/lib/udev/load-modules.sh pcmcia"

# if this is a PCMCIA socket which needs a resource database,
# pcmcia-socket-startup sets it up
SUBSYSTEM=="pcmcia_socket", \
		RUN+="/sbin/pcmcia-socket-startup"

LABEL="pcmciautils_end"
