diff --git a/jpeg.c b/jpeg.c
index 936bc55..7a83542 100644
--- a/jpeg.c
+++ b/jpeg.c
@@ -46,7 +46,7 @@ typedef unsigned char jboolean;
 typedef int jboolean;
 #endif
 
-#define JPEG_LIB_VERSION  62  // Version 6b
+#define JPEG_LIB_VERSION  70  // Version 7
 
 typedef void *j_common_ptr;
 typedef struct jpeg_compress_struct *j_compress_ptr;
@@ -130,6 +130,41 @@ struct jpeg_source_mgr
 	void (*term_source) (j_decompress_ptr cinfo);
 };
 
+/* Types for JPEG compression parameters and working tables. */
+
+
+/* DCT coefficient quantization tables. */
+
+typedef struct {
+  /* This array gives the coefficient quantizers in natural array order
+   * (not the zigzag order in which they are stored in a JPEG DQT marker).
+   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
+   */
+  unsigned short quantval[DCTSIZE2];	/* quantization step for each coefficient */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  jboolean sent_table;			/* TRUE when table has been output */
+} JQUANT_TBL;
+
+
+/* Huffman coding tables. */
+
+typedef struct {
+  /* These two fields directly represent the contents of a JPEG DHT marker */
+  unsigned char bits[17];	/* bits[k] = # of symbols with codes of */
+				/* length k bits; bits[0] is unused */
+  unsigned char huffval[256];	/* The symbols, in order of incr code length */
+  /* This field is used only during compression.  It's initialized FALSE when
+   * the table is created, and set TRUE when it's been output to the file.
+   * You could suppress output of a table by setting this to TRUE.
+   * (See jpeg_suppress_tables for an example.)
+   */
+  jboolean sent_table;		/* TRUE when table has been output */
+} JHUFF_TBL;
+
 typedef struct {
   /* These values are fixed over the whole image. */
   /* For compression, they must be supplied by parameter setup; */
@@ -161,12 +196,13 @@ typedef struct {
    * Values of 1,2,4,8 are likely to be supported.  Note that different
    * components may receive different IDCT scalings.
    */
-  int DCT_scaled_size;
+  int DCT_h_scaled_size;
+  int DCT_v_scaled_size;
   /* The downsampled dimensions are the component's actual, unpadded number
-   * of samples at the main buffer (preprocessing/compression interface), thus
-   * downsampled_width = ceil(image_width * Hi/Hmax)
-   * and similarly for height.  For decompression, IDCT scaling is included, so
-   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
+   * of samples at the main buffer (preprocessing/compression interface);
+   * DCT scaling is included, so
+   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_h_scaled_size/DCTSIZE)
+   * and similarly for height.
    */
   JDIMENSION downsampled_width;  /* actual width in samples */
   JDIMENSION downsampled_height; /* actual height in samples */
@@ -195,6 +231,15 @@ typedef struct {
   void * dct_table;
 } jpeg_component_info;
 
+/* The script for encoding a multiple-scan file is an array of these: */
+
+typedef struct {
+  int comps_in_scan;		/* number of components encoded in this scan */
+  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
+  int Ss, Se;			/* progressive JPEG spectral selection parms */
+  int Ah, Al;			/* progressive JPEG successive approx. parms */
+} jpeg_scan_info;
+
 struct jpeg_decompress_struct
 {
 	struct jpeg_error_mgr *err;		// USED
@@ -268,7 +313,8 @@ struct jpeg_decompress_struct
 	void *marker_list;
 	int max_h_samp_factor;
 	int max_v_samp_factor;
-	int min_DCT_scaled_size;
+	int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
+	int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */
 	JDIMENSION total_iMCU_rows;
 	void *sample_range_limit;
 	int comps_in_scan;
@@ -297,35 +343,45 @@ struct jpeg_compress_struct
 {
 	struct jpeg_error_mgr *err;
 	struct jpeg_memory_mgr *mem;
-	void *progress;
+	struct jpeg_profress_mgr *progress;
 	void *client_data;
 	jboolean is_decompressor;
 	int global_state;
 
-	void *dest;
+	struct jpeg_destination_mgr *dest;
 	JDIMENSION image_width;
 	JDIMENSION image_height;
 	int input_components;
 	J_COLOR_SPACE in_color_space;
 	double input_gamma;
-	int data_precision;
+	unsigned int scale_num, scale_denom;
+
+	JDIMENSION jpeg_width;
+	JDIMENSION jpeg_height;
 
+	int data_precision;
 	int num_components;
+
 	J_COLOR_SPACE jpeg_color_space;
 	jpeg_component_info *comp_info;
-	void *quant_tbl_ptrs[NUM_QUANT_TBLS];
-	void *dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
-	void *ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+
+	JQUANT_TBL *quant_tbl_ptrs[NUM_QUANT_TBLS];
+	int q_scale_factor[NUM_QUANT_TBLS];
+
+	JHUFF_TBL *dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
+	JHUFF_TBL *ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
+
 	unsigned char arith_dc_L[NUM_ARITH_TBLS];
 	unsigned char arith_dc_U[NUM_ARITH_TBLS];
 	unsigned char arith_ac_K[NUM_ARITH_TBLS];
 
 	int num_scans;
-	const void *scan_info;
+	const jpeg_scan_info *scan_info;
 	jboolean raw_data_in;
 	jboolean arith_code;
 	jboolean optimize_coding;
 	jboolean CCIR601_sampling;
+	jboolean do_fancy_downsampling;
 	int smoothing_factor;
 	J_DCT_METHOD dct_method;
 
@@ -344,6 +400,8 @@ struct jpeg_compress_struct
 	jboolean progressive_mode;
 	int max_h_samp_factor;
 	int max_v_samp_factor;
+	int min_DCT_h_scaled_size;	/* smallest DCT_h_scaled_size of any component */
+	int min_DCT_v_scaled_size;	/* smallest DCT_v_scaled_size of any component */
 	JDIMENSION total_iMCU_rows;
 	int comps_in_scan;
 	jpeg_component_info *cur_comp_info[MAX_COMPS_IN_SCAN];
@@ -353,16 +411,16 @@ struct jpeg_compress_struct
 	int MCU_membership[C_MAX_BLOCKS_IN_MCU];
 	int Ss, Se, Ah, Al;
 
-	void *master;
-	void *main;
-	void *prep;
-	void *coef;
-	void *marker;
-	void *cconvert;
-	void *downsample;
-	void *fdct;
-	void *entropy;
-	void *script_space;
+	struct jpeg_comp_master * master;
+	struct jpeg_c_main_controller * main;
+	struct jpeg_c_prep_controller * prep;
+	struct jpeg_c_coef_controller * coef;
+	struct jpeg_marker_writer * marker;
+	struct jpeg_color_converter * cconvert;
+	struct jpeg_downsampler * downsample;
+	struct jpeg_forward_dct * fdct;
+	struct jpeg_entropy_encoder * entropy;
+	jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
 	int script_space_size;
 };
 
@@ -473,7 +531,7 @@ qboolean JPEG_OpenLibrary (void)
 #elif defined(MACOSX)
 		"libjpeg.62.dylib",
 #else
-		"libjpeg.so.62",
+		"libjpeg.so.7",
 		"libjpeg.so",
 #endif
 		NULL
