diff -Naur pyPdf-1.12/pyPdf/generic.py src/pyPdf-1.12/pyPdf/generic.py
--- pyPdf-1.12/pyPdf/generic.py	2009-08-03 19:11:12.000000000 +0200
+++ pyPdf-1.12/pyPdf/generic.py	2009-08-03 20:40:22.000000000 +0200
@@ -212,8 +212,6 @@
 
 
 class NumberObject(int, PdfObject):
-    def __init__(self, value):
-        int.__init__(self, value)
 
     def writeToStream(self, stream, encryption_key):
         stream.write(repr(self))
@@ -402,9 +400,6 @@
 class NameObject(str, PdfObject):
     delimiterCharacters = "(", ")", "<", ">", "[", "]", "{", "}", "/", "%"
 
-    def __init__(self, data):
-        str.__init__(self, data)
-
     def writeToStream(self, stream, encryption_key):
         stream.write(self)
 
diff -Naur pyPdf-1.12/pyPdf/pdf.py src/pyPdf-1.12/pyPdf/pdf.py
--- pyPdf-1.12/pyPdf/pdf.py	2009-08-03 19:11:12.000000000 +0200
+++ pyPdf-1.12/pyPdf/pdf.py	2009-08-03 20:40:22.000000000 +0200
@@ -49,7 +49,6 @@
 import warnings
 from generic import *
 from utils import readNonWhitespace, readUntilWhitespace, ConvertFunctionsToVirtualList
-from sets import ImmutableSet
 
 ##
 # This class supports writing PDF files out, given pages produced by another
@@ -119,7 +118,8 @@
     # encryption.  When false, 40bit encryption will be used.  By default, this
     # flag is on.
     def encrypt(self, user_pwd, owner_pwd = None, use_128bit = True):
-        import md5, time, random
+        import time, random
+        from hashlib import md5
         if owner_pwd == None:
             owner_pwd = user_pwd
         if use_128bit:
@@ -160,7 +160,8 @@
     # @param stream An object to write the file to.  The object must support
     # the write method, and the tell method, similar to a file object.
     def write(self, stream):
-        import struct, md5
+        import struct
+        from hashlib import md5
 
         externalReferenceMap = {}
         self.stack = []
@@ -554,7 +555,8 @@
             if not hasattr(self, '_decryption_key'):
                 raise Exception, "file has not been decrypted"
             # otherwise, decrypt here...
-            import struct, md5
+            import struct
+            from hashlib import md5
             pack1 = struct.pack("<i", indirectReference.idnum)[:3]
             pack2 = struct.pack("<i", indirectReference.generation)[:2]
             key = self._decryption_key + pack1 + pack2
@@ -986,8 +988,8 @@
 
         # Combine /ProcSet sets.
         newResources[NameObject("/ProcSet")] = ArrayObject(
-            ImmutableSet(originalResources.get("/ProcSet", ArrayObject()).getObject()).union(
-                ImmutableSet(page2Resources.get("/ProcSet", ArrayObject()).getObject())
+            frozenset(originalResources.get("/ProcSet", ArrayObject()).getObject()).union(
+                frozenset(page2Resources.get("/ProcSet", ArrayObject()).getObject())
             )
         )
 
@@ -1369,7 +1371,8 @@
     password = (password + _encryption_padding)[:32]
     # 2. Initialize the MD5 hash function and pass the result of step 1 as
     # input to this function.
-    import md5, struct
+    import struct
+    from hashlib import md5
     m = md5.new(password)
     # 3. Pass the value of the encryption dictionary's /O entry to the MD5 hash
     # function.
@@ -1436,7 +1439,7 @@
     password = (password + _encryption_padding)[:32]
     # 2. Initialize the MD5 hash function and pass the result of step 1 as
     # input to this function.
-    import md5
+    from hashlib import md5
     m = md5.new(password)
     # 3. (Revision 3 or greater) Do the following 50 times: Take the output
     # from the previous MD5 hash and pass it as input into a new MD5 hash.
@@ -1473,7 +1476,7 @@
     key = _alg32(password, rev, keylen, owner_entry, p_entry, id1_entry)
     # 2. Initialize the MD5 hash function and pass the 32-byte padding string
     # shown in step 1 of Algorithm 3.2 as input to this function. 
-    import md5
+    from hashlib import md5
     m = md5.new()
     m.update(_encryption_padding)
     # 3. Pass the first element of the file's file identifier array (the value

